 Welcome to this last module for this course. We are going to do two things in this week's videos. One is about file input and output that will be the first part and later we will also learn something about structured programming. So, let us let me give you a little bit of motivation for the lecture itself on file IO. So, it is not reasonable to expect a user to always give inputs from the keyboard or always just print things on the screen. There are several places and instances where you want something recorded and you want it to be reused later and this is a place where files come into picture. It is not the notion of files is probably not alien to you. So, what we will do in this lecture is we will try and learn what a file is and how to perform input and output operations on a file. We will also see how to write programs that will read from or write to files and we will learn one another topic about command line arguments. So, that will be the first video for this week. So, let us look at the notion of a stream. When we look at files things like MP3 files, video files, document files or even HTML pages that you download or all files they have all been created somewhere they enable you to transmit information from one place to the other save it, retrieve it and so on and without files we cannot do any of those. So, if you expect a user to always give inputs over a keyboard that is not always good. Sometimes the input is not even coming from the keyboard it could be coming from some other device. So, the notion of a file let you both store and retrieve information and in this context we will use this notion called a stream. A stream is essentially a flow of input or output data. These could be anything these could be characters, bytes, numbers anything that you send from one program to another program or one from one device to another device and so on. So, let us look at this basic example. So, let us say I write a program and what we have been doing is we have always been taking inputs from the keyboard whatever I do demonstration of I take inputs from the keyboard and the output was always on the screen. And when you did your programming exercises online, this input itself was not from a keyboard you had saved something and it got saved into a file but the output was still on your screen. There are other places for example, let us say my program is actually an MP3 player or a CD player. The input is going to come from a compact disk and the output is probably a speaker or the input stream is coming from a compact disk and let us say you take a wave file and make MP3 out of it. So, the input is from your CD you are ripping a CD and you are writing to a disk which is the hard disk. So, we need to be able to not just interact with keyboard and monitor alone, we need to be able to interact with other devices also. At the same time we do not want to be bogged down by all the details of these devices and so on and that is where the notion of file IOs come in. So, see basically has no direct support for input and output. Instead it is supplied through a library and we have seen this so far the header file that we have been including called a CDIO.H is essentially that. So, it has several functions that will enable you to do input and output. You do not have to really remember all of them but it is good to know that all the functions that you need for input and output are actually in this file are all in this header called a CDIO.H. So, let us now concentrate on what C gives us. So, every C program is automatically associated with three standard streams. So, that is how you will see the prefix called STD in STD for it. So, there are three standard streams STD in STD out and STD R. So, STD in is for input stream, STD out is for output stream or anything that gets written from the program and STD R is for printing any errors and it is usually associated with the screen itself. So, STD in is usually associated with keyboard STD out is usually associated with the screen and STD R is also usually associated with the screen. And whenever we did things like scan up and get car and so on, we were actually reading from the keyboard. So, that is your standard stream. So, you do not have to do anything especially and output was always written to the screen also. So, with print up we did not bother what to do with it because we know that the default stream is anyway STD out which is connected to the monitor. But when you have files that you want to deal with on your own, it is not the case anymore. So, even though STD in out an error automatically connected, if you want to do anything more with other files, if you want streams from other places you need to do something more. So, reading and writing a file in C requires three basic steps. You need to be able to open a file you need to be able to do all the reading or writing that goes with it and finally, you should close the file. And instead of dealing with file names explicitly in our programs, we will deal with what are called file pointers. So, file pointers essentially a pointer to a structure that contains a lot of information about the file. Again, we do not have to know a lot of details about what is in the structure. But just remember that we will deal with file pointers and not file names directly. So, let us start with the first step namely opening a file. So, if I want a programmatic way to open a file. So, it is not about clicking on a screen and opening a file. So, I want my program to be able to open a file and do some operations on it. So, to do that, you declare a file pointer and you open a file using this function called F open. So, file pointer is declared with as you see in the second bullet here, file star F p. So, F p, star F p is indicates that it is a pointer and to what is it pointing? It is pointing to a structure called file. So, F p is a pointer to the data type structure and many times we will drop this thing called structure and we will just say that F p is a file pointer. So, we have a file pointer now and we can do F p equals F open of name comma mode. So, the name should be the name of the file that you are trying to open and mode can be one of the three things. So, let us see this example F p is F open of data dot text comma R. So, if you say R it is supposed to be in read only mode. We are trying to open the file data dot text in read only mode which means you do not want to write anything from your program. You want to only read contents of the file data dot text. So, one can notice that both the file name and the mode are actually put within double codes. So, F open expects two strings, one string which is the name of the file and another string which is the mode itself. So, let us look at the other modes of opening a file. So, R I already mentioned in the previous slide. W is the other mode in which you open the file but only for writing which means from your program you can only write to it you cannot go and read what is in the file. So, that is called write mode and A which is called the append mode. So, let us look at the distinction between among these three modes R means it will try and open an existing file. So, clearly what if I try to open a file that is not even existent we need to be we need to be able to capture this. So, let us say I am going to open a file but there is no file by that name. If that happens we need a mechanism which says there is no file by that name. So, that is an issue that we have to deal with for R. For W you are trying to write to a file you are not going to write read it from there at least in this program as of now. So, if the file already exist and since you are only writing the previous contents of the files does not matter you can as well remove all the contents and start with zero length. So, since you are only writing from the current program if you by mistake open an existing file the previous contents will all be deleted. But normally you would expect your program to create a new file. So, if it is a new file and since you are writing it will automatically create a new file with the name that you have suggested. A stands for append, append means add at the end and this is as the name indicates it is useful for writing only at the end of the file. So, clearly this is similar to write it has some similarity with the write. If the file already exists the initial contents how are unchanged however if the file is not there append is as good as actually opening with a W mode only that all the writes will always happen to the end of the file. So, these are the three modes let us now look at how to open a file. So, we have Fptr1 which says F open my data comma R we are trying to open a file called my data in read only mode and Fptr1 should be file star Fptr1. In this example Fptr2 is F open results comma W we are trying to write something into results file and so both of these once they are open you have essentially it is like opening a gate through which a stream can flow. So, once you open a file you can now start reading and writing so you can either read from the stream or you can write to the stream and these files will remain open until you explicitly close them. So, if you do not explicitly close them the files will remain open till the end of the program. So, let us look at how do you test for successful open I mentioned this as a problem right. So, I try to read a file and the file is not existent what do I do now. So, let us see this example file star Fptr1 and you try to open my data. So, it will try and open it from the directory in which the program is running from and if the file does not exist Fptr1 will be supplied with the value called null. So, if F open fails it will return null however, if F open succeeds will be a valid pointer. So, you can use this information and go and check if Fptr1 is null or not. If it is null you know that the file open fail for whatever reason maybe the file was not there that is the most common reason it failed and you can say that file my my data did not open and you have to tell the user to input another file name or some such thing. So, unsuccessful open for read is a problem because you cannot proceed from there if the file is not even there. Whereas, for write F open may not work because you do not have enough space in your disk and so on. So, there could be other reasons why F open may fail if you open it in write mode. So, now let us look at the second step. So, we said we will open the file now we know how to check the error if the file cannot open. Let us look at the second step reading from the files. So, second step is either reading or writing let us start with reading. So, int a comma b these are two integers and we have a pointer Fptr1 which is of type file star. Let us look at this line here. We have opened the file in this example there is no check on whether Fptr1 is null or not. But let us see how to read two integers from the file. Let us assume that Fptr1 has two integers or the file my data has two integers saved in it. So, this line here is trying to do a scan and you can see some similarity with scan of that you have seen before. We have been using this all along. So, let us look at this. So, it is similar to scan of except that there seems to be three different sets of parameters. So, this is the format that you give to F scan of. So, this is the format in which you are going to read. This is the set of pointers that we are passing. So, this is very similar to scan of except that you also pass the file pointer Fptr1. So, F scan of takes three parameters one which is the file pointer two which is the format three which is a set of variables in which you have to read. So, in scan of all we have done is we got rid of the Fptr1 because scan of by default always reads from STD in. So, F scan of once this is over it would have read two integers from the file my data. So, when you read a file you could be writing a loop to read one line after the other. Let us say I have a file in which I have ten lines of two integers each. I keep reading at some point I have to find out that I have reached the end of the file because once I reach the end of the file for the program there is probably no processing to do anymore. So, it has processed the file and maybe all the work that needs to be done is already done. So, there could be some other file in which there are thirty lines, another file in which there are hundred lines and so on. You need a mechanism by which you do not have to know the number of lines in the file for your program to operate. So, you keep processing one line after the other and at some point you realize that you have to find out that you have reached the end of the file and that is done by C using this function called FeoF. So, if you do a scan of and let us say you are expecting something from the input stream and if you have already reached the end of the file then if you check on this thing FeoF of FPTR1. So, this EoF stands for end of file. So, in your file stream if you have reached the end of file of the pointer FPTR1 it means that whatever that file that you are reading using FPTR1 you have reached that end of the file there is no more processing to do. So, this is one way to find out if you have reached the end of the file. There is also another way in which you can check whether you have reached the end of the file. You keep reading one line at a time at some point if you reach the end of the file let us say you do this F scan F FPTR1 percentage D ampersand var that is exactly what we had earlier we do a scan F. Interestingly scan F also returns an return value. So, we never bothered checking the return of scan F but F scan F returns a value which can be used to check whether you have reached the end of input stream or not. So, there is a special character called special value called EoF. So, this capital E capital O capital F. So, that is a special value if F scan F returns this special value then it means there was some problem in scanning which. So, it actually indicates that you have reached the end of the file. Otherwise F scan F would return a value which is not EoF. So, if F scan F returns EoF you know that you have reached the end of the file. So, either you call F EoF of FPTR1 or you call you copy the value return value from F scan F and you check against EoF and it will tell you that the end of file has encoder has been encoder. So, that is one of the things that you can do in the second step. The other thing that you can do is you can actually go and write to files. So, for example, if you look at this code as you can expect this is a variation of print F. So, as before we have two integers and we have a file pointer called FPTR2 we open the results file in write mode which means if the file exists it will overwrite it if it does not exist it opens a new file with the name results and now this F print F is similar to print F. So, you have the format specifier you have the parameters that are supposed to be printed but you also pass the file pointer as the first parameter. So, this line will actually write a comma b the values a comma b into the file pointed by FPTR2 and you keep writing and it will keep writing one line after the other till the when you can so you can stop writing. So, for example, if you have another F print F FPTR2 percentage D percentage D backslash N let us say 5 comma 10 right. So, that will write one line of 5 comma 20 and another line would be 5 comma 10 you will see two lines in your file. The third and final step having file I have done is closing the file. So, F close of FPTR1 and F close of FPTR2 will close the file associated with the stream FPTR1 and FPTR2. So, and whatever extra work that it has been doing it will release all of that back to the system. So, it is important that you actually close the files because if you have actually open a reading stream maybe it is not that big an issue but if you have if you have been writing to a file and if you did not close you can run into problems. So, closing a file is important because usually output is buffered. So, what what we mean by that is let us say I want to print F to a screen I want to do print F it may not appear in the screen immediately right. So, what can happen is whatever is supposed to be written could get written to the buffer and eventually the buffer gets flushed to the actual device. So, the flushing could be to the hard disk or the flushing could be to your monitor and so on. So, the best example that I can give is if you use USB sticks many times they tell you to remove the USB sticks especially if you have written something on a USB memory drive they ask you to eject it carefully right. So, you would go in click on something and you would say safely remove the device and so on right. If you have wondered what you have been doing what it actually does is when you remove the if you have written anything to the anything anything to a device it is possible that the actual entries have not been written the actual bits and bytes have not been written they are still in a buffer sitting in the RAM and only when you ask the system to be flushed then there will be a commit to the device. So, this happens for various reasons which we cannot get into now, but if that buffering happened and if you plugged out a USB memory stick your USB memory stick is not guaranteed to have all the data. However, if you go through your operating system and say safely eject the device it will flush all the buffers to your device and then you can remove it. So, F close essentially forces all the buffers to be flushed and the device the all the contents that you wrote from the program is guaranteed to be written into the file. So, there are several other modes that you can use. So, there is a mode called R plus there is a mode called W plus and another called A plus. So, the plus indicates something. So, this is the reason why we have been passing it as a string it is not just one character at times may have to pass more than one character. So, in this case R plus W plus R A plus. So, R plus is it indicates that you want to be able to read, but you want something more from this mode. So, you open an existing file for both reading and writing because this is also something that you may need once in a while. So, what happens is because you are opening in R it will not delete the file it will not delete the contents the initial contents of the file are unchanged and the initial position at which you can start doing your operations will be at the beginning of the file. So, if you want to overwrite only part of the file right you can use R plus you open it with R and R plus and you can start writing overwriting from the top and you can stop at some point instead of deleting all the contents. W plus is also in some sense similar to what you are doing in R plus, but there is a key difference. So, both of them open a file for both reading and writing, but W plus being this notion that you destroy the file when you open something in W mode it does exactly that. If the file already exists it is truncated to 0 length otherwise the new file is created and on this you will be able to do both reading and writing. Finally, A plus is distinct from W plus it this also opens the file for both reading and writing, but if the file exists its initial contents are unchanged in that sense it is similar to R plus otherwise it will create a new file in that sense it is similar to W plus. So, these are three other modes in which you can open a file. So, what we will do now is we will do a quick I will show you a quick demo of file IO I have written some small programs to show you file IO. So, there is this file called file 1.c in which I have done something. So, I am going to open a file called my.1.text in read only mode and this file is expected to have a bunch of integers and what I am going to do is I am going to sort the numbers which are in the file and I am going to write it to this file called sortin.text. So, I am going to do three things open a file called my.1.text into an array sort the array in your program and write the sorted results to your another file called sortin.text that is what this program achieves let us see how this is done. So, there are two file pointers FP1 and FP2. FP1 opens my.1.text in read only mode and I also assume that the number of entries in the file is not more than 10. So, I assume that at most 10 integers are stored and nothing more. So, what I have done is I have declared an array called A of 10 in size which means it can store up to 10 integers and look at this line line 21 through 24 if you will sorry 24 if you look at it while F scan F of FP1 percentage D ampersand temp. What does F scan up do? Given a file pointer it will try and use the format and read from the input stream in this case from my.1 into this variable called temp. So, when you read it is possible that you have 10 integers but at some point you will hit the end of the file right. So, F scan F you go and check it will do this work F scan FP1 percentage D ampersand temp. So, this line actually reads, tries and reads from a file but if it is unsuccessful and if it returns EOF the while loop will terminate otherwise it keeps reading the contents into A and as long as there is 10 or less lines A will not be overrun it will have 10 entry so up to 10 integers from this file my.1 is ok. Then I am calling this function short numbs A comma C and T. I will not worry about short numbs now. So, I have written a small program small piece of code which does insertion short. So, I will not worry about that I will assume that A gets sorted and I am going to write things to a file and how do I do it? I open FP2 which is opening the sorted.text in W mode if FP2 is null it cannot file the open for writing otherwise you do F print of FP2 percentage D A of I it takes 1 A at a time and it writes it to FP2 in the format integer and one thing you can notice is line number 25 and line number 36 closes the two files. So, this file you are done with reading at line number 24 you do not have anything more to read. So, you can close the first file my.1.text at line number 25 and since you are done with all the writing of all the variables that you of all the values you can close this file at line number 36. So, I will compile this and I will show how it is going to run. So, I have compiled it let me show what the file has. So, I am going to show you what my.1.text has. So, it has a bunch of integers. So, 20, 80, 30, 50, 70, 60, 10, 40 there are 80 integers clearly less than 10. So, I am good. So, I have already compiled it earlier. So, the executable is called file1.exe that is what I call the file as file1.c when it compiles it gets file1.exe and when I run it by now what you to have done is it would have written something called sorted.text. You can see that the numbers tend to 80 where all here in un sorted order and they are all in sorted order now. So, just to show that this was actually created by the program let me delete the sorted.text because it is a file that you are supposed to write every time the program is run. You can see that sorted.text there is no file by that name and if I run the program again and see what is in sorted.text you can see that the file got new entries now. So, I deleted the file and when I run the program it created the file called sorted.text. So, for while let us assume that this my.1.text did not exist I will instead call it my..text this was expected by the program my.1 I renamed it. Now, if I run file1. So, I printed this error called file0 percent this file which is not present as my.1.text it would not change the sorted.text because I exited from the program. So, this is a small piece of code that I wanted to show. I have another piece of code which is also interesting. So, it is possible that I have two files which are both sorted entries. Now, I want to merge these two files together. So, in the previous case one thing that happened was I actually knew that the contents of the file had only 10 entries but I may not know that upfront. I need a mechanism by which I do not want to depend on any count. So, in this program what it does is it takes two files it assumes that both these files are sorted and it will try and merge these two into one single sorted file. So, we are going to take two input sorted 1.text and 2.text and we are going to write a file called sorted.text. So, you can see that sorted.text gets opened in right only mode. And if either fp1 or fp2 file failed you know that you cannot read. So, it is not present. Otherwise you scan one integer from each one of these streams. So, you have one integer in stream 1 and one integer in stream 2 you read that. And then I have written a piece of program from line number 25 to 37 right. There is a piece of program which runs on a while loop. So, what does it do? So, I have two files which are of differing lengths. It is possible that I will end up consuming everything from one stream before I even finish the other stream. So, what I am going to check is have I not reached the end of stream 1 or stream 2. If I have not reached the end of stream 1 and not of stream 2 either. As long as I have not reached the end of any of the streams then I can always read 2 integers and I will be able to compare them and do something with it right. So, at this point I have 2 integers that I have read. I have not reached the end of the stream which means I should be able to compare and write the results path. So, the first stream you read into temp 1 the second stream is reading into temp 2. So, you are comparing temp 1 and temp 2. If temp 1 is less than temp 2 then write temp 1 into the output file and read one more integer from file 1. Otherwise if temp 1 is greater than temp 2 or equal to temp 2 you write temp 2 into the file and you read one more integer from file 2. So, you can see what is happening here. So, either the entry in file 1 or the entry in file 2 will be one of them will be the larger than the other. You write that and move one step in that stream. And what could happen is when you exit this loop you may not have exhausted both the streams. One stream could end prematurely and the other one has more numbers. But remember that the numbers are sorted. So, I can do something like what you did in merge sort that is what I have been trying to do here line number 25 to 37 is merging two streams instead of merging two arrays. But if the arrays are of different size then you have to just concatenate whatever is left out at the end of the resultant array and that is what this loop does. So, line number 47 to 50 what it does is it. So, this 39 to 46 finds out with stream got over. So, FP1 got over FP2 should be copied. If FP2 got over FP1 and to the end should be copied and what line number 47 to 50 does is it just copies whatever is left out in whichever file it is and it keeps canning and keeps copying till the whole that file is also exhausted. And once that is over we can close all the streams FP1213 and you can return this 0. So, let me again compile it and there are no compilation errors. So, let us look at sorted dot text because that is the output we are going to write. So, it has 10 to 80 now. But let us look at sorted 1 dot text which is one of the input files it has 10 to 70 and sorted 2 dot text I created with more values than sorted 1 dot text it has 5 15 25 all the way up to 105. So, there are 7 values here but there are 11 values here. So, your program will finish this stream before it finishes this stream. So, you will have more work to do after this stream is processed. So, I will run file 2 now. So, I run file 2 and it was printing various things on the screen. Now, let us go and look at sorted dot text. So, it got overwritten first sorted dot text was earlier written by file 1 dot c. Now, I have file 2 dot c file this is the second program and it overwrote the sorted dot text. Now, we can see that the entries of the resultant file are in sorted order. So, we read 2 files the key thing I want you to see is this FeoF is another way to look at end of file and in this case I am simultaneously forwarding both the file pointers by. So, I am trying to see if either one of them reach the end, but one of the file pointers will move inside the loop either this or this will move depending on which one was slower. Let us get back to the presentation. So, we looked at 2 examples in which we read and wrote to files. The other key thing that I want you to learn is the notion of what are called command line arguments. So, if you notice the things that I have been doing here. So, let us say I want to copy file 1 dot c to another dot c. So, I wrote this thing called so I should it is called copy. So, copy is a Windows command to copy one file to another, but copy itself is a program. Somehow I am able to pass values file 1 dot c and another dot c here and I am able to get copy to do some work. I did not say copy and then I type file 1 dot c in keyboard and another dot c in the keyboard and so on. When I launch the program itself, I was able to give the parameters that it is needed and the copying got done. So, this is called command line parameter. So, we are in a command line, we are calling an executable and we have given 2 parameters file 1 dot c and another dot c. I want we want to be able to process command line parameters. That is your that is the next part of this video. So, command line arguments work like this. You can pass arguments to see programs by passing them right when the program is executed. So, you can sit in the command line and type along with the parameters that you want. You do not have to type them in later when the program is running. So, for example, if you type echo hello comma world, then you would see hello world printed on the screen. So, echo is actually taking command line parameters hello comma and world and it is processing it and it actually is printing on the screen right. So, this is done using a very sophisticated mechanism. So, you remember the main program does not take arguments by default. So, we never used. So, I even though I said main is a function, we never passed any arguments to it. But you can actually pass 2 arguments in Rc and character star Rv of array. So, Rc is an integer whereas, Rv if you look at it is a pointer to a pointer. So, it is a set of pointers to a character pointers. So, Rv this square bracket means it is a set of pointers and what is it pointing to its character star. So, it is a pointer to pointer. So, you can also think of it as an array of strings. So, Rv of 0 is usually the name of the program. Rv of 1 is the first argument that you passed Rv of 2 is the second and so on. So, Rc is an integer value that takes the number of arguments including the file name itself. So, for example, if I did copy file 1 dot c another dot c, this is the there are 3 arguments copy file 1 dot c and another dot c. So, Rc would be 3. Rv of 0 would be copy, Rv of 1 would be file 1 dot c and Rv of 2 would be another dot c. So, what really happens is you get Rc equal to 3 and Rv is a pointer to a pointer and what do you have? You have 3 pointers which are pointing to echo, hollow and world. Remember these are strings. So, you have a backslash 0 at the end and the 4th pointer actually points to null. So, you have in some sense a 2 dimensional array of characters. Again as before I have written a small program which does something very simple. So, it takes Rc and characters are Rv all it does is it iterates over all the arguments and prints them on the screen. So, it prints what is the argument number and what is the value of the argument. So, I runs from 0 to less than Rc. So, it goes 0 1 2 3 up to Rc minus 1 and it prints i comma Rv of i. So, I have already compiled this program let me run it now. So, I call this program echo. Let us say I typed only echo dot exe I did not pass any parameters. It just gives me the 0th Rv which is echo dot c echo dot exe itself. Let us say now I give echo a, a is one of the parameters. So, this is the 0th Rv and this is the 1th Rv. So, you get those two. I can pass an arbitrary number of inputs. See this. So, you have 0 1 2. So, you have three arguments echo dot exe a and b. I can do this and so on. And it is not necessary that you pass only one variable type. I passed an integer here then I can pass a real value here you can do any of those. So, anything that you pass in the command line will be passed to the program as Rv. So, they are treated as strings inside and I am printing one string after the other. So, this comes in handy whenever you do not want the keyboard input at all from the programmer even to read a file name. Let us say I want to write a program like this copy file 1 dot c to file 2 dot c. So, I do not want the user to type it later. Instead I want that to be given in the command line itself and automatically this file. So, you will read that as a string you have to open the file by that name read it, open the other file in write mode write it and so on all of that is there. But you have passed the file names right in the command line itself. So, these are two things that are very useful the notion of being able to do file IO and the notion of being able to take command line arguments. So, that is the same program that is here and this brings us to the end of this