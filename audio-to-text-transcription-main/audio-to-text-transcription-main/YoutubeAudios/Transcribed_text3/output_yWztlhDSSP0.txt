 Good morning students, this is the course on programming and data structures and Professor Shankar Balchandran has already taught you programming in C and I will be teaching you data structures and algorithms in this part of the course. So, first what we will do is as part of this course, before we go on to data structures, we will first do a basic recap of the building blocks for programs, especially we look at the controlled structures which you have already studied, we just do a recap, we will do a little formally. We will also look at arrays and functions which are where arrays are data structures that are already available in C or C plus plus or Java or whatever and also recursive data structures which are available for you to work with in program programming languages. You already study this but we will just recap that and then once you write a program, we want to see how efficient a program is, how well does it work on a particular kind of input data. So, we will study complexity analysis and here what I will do is I will give some kind of formal way of finding the complexity of programs, there are those square be some rule in the product too which we will learn in great detail, we will also analyze recursive functions. Then we will also recap basic sorting and searching algorithms, we will look at primarily two types of sorting algorithms and two types of searching algorithms. Then once we have done this and by then we are equipped with the ability to analyze programs in a big way, we will start defining what are called abstract data types. What are abstract data types? There are special types of organizations of data structures and programs which make an abstract data type and these abstract data types are actually user defined and why do we do this? Because we define operations and abstract data types which can be done in a very efficient way for problem solving, trees and other abstract data type. For example, if I want to represent by family tree, I would need a different kind of a data structure and we will define operations in the tree, I would define who is a grand parent and who is a grand child and so on and so forth. So, you need a specific structure called tree with operations defined on it. Then we will define what are called priority cues which are similar to the cues that we see originally, but the priority added to them. Then we will do data structures on hash tables where we would like that any operation can be performed very quickly and finally, we will look at graphs. For example, if you look at the internet today, internet is actually a graph of nodes that are connected together. So, if I want to any kind of analysis of the network, I need a graph abstract data and we will talk about that. So, let us look at the recap of basic programming. You already learned problem solving using C. So, you might not have heard or might not have heard of this. So, basically what we talk about is here is when you given a problem to solve, you define what is called an algorithm to solve the problem. When you have an algorithm now, it is a prescription to solve a program problem which provided it is hopefully executed is a result of finite number of steps. That means, what am I going to write? I am going to it is like a recipe to solve a problem and the recipe is such that if it is followed by a pattern, it will solve the problem in a finite number of steps. I like to define programming as borrowing from Gugano. It is a means to translate the sequence of steps that you have written in some kind of English like sentences. You set such instructions that can be understood by the computer. For example, what we are trying to do here is, we are separating algorithm and programming here. And algorithm is written in an English type of statement. Whereas, a programming is done in a particular language C or C plus plus Java, Python, whatever it may be. Here is a functional specification of a program that I have given. This is something that I advise all my students. When you write a program to solve a problem, I would say instead of just going to the computer and start keying in right away, first thing that you have to start looking at is define a name for the program. What is it solve? Give it a name. Then you, it is like making a recipe to bake a cake or whatever it may be. You have to find the ingredients. What are the ingredients here? The declaration of local variables. Then, we to solve the particular problem. Then, you define what are called on the local variables. What are the conditions that must be satisfied by the local variables so that the program as expected that is called a pre-condition. Then, you give the body of the program, which is a gamma set of instructions. Then after the program is executed, what is the post-condition? What are the results or the goal that you expect to reach? So, first you, I would say that give the name of the program, the declaration of local variables, pre-condition and post-condition. And then you start set out to write a program that solves this. So, let us take a specific example now. Let us take, I want to write a program to exchange. I am sure you have already seen this two variables. X and Y. Let us assume. X and Y are integer. So, what is the function specification say? I will write this in C. Although, ideally you should write it in English like statement. So, you give the program a name, program exchange. In the name that is given to be program. And I am writing the main program name and integer. I define the local variables now, X, Y. If I want to effect the six change, I will need a temporary variable unless I want to do a more efficient program, which does not use a temporary variable. Then maybe I want to read the values. X, M percent. Of course, I am assuming that you have included standard IO dot H. Then what do we do? We assign temp equals x and x equals Y and then Y equals temp and that is the end of the program. So, now what do I need now? I need to know what is the precondition on this? X and Y are arbitrary. That means it can take any values. And what you see is the post condition, the values of X and Y are interchange. You have already seen the statement. So, look at the body of the program here, scan F. This is not relevant to the exchange process. We are just reading the variable X and Y. So, this is the main body of the program. And where are these statements? This is a particular control structure that is available in any programming language and it is called the assignment statement. You can write very large programs with simply assignment statements. For example, what is an assignment statement now in general? It is a variable on the left hand side of the equal sign and C. And on the right hand side, it can have an expression and so on. This is an arithmetic expression. I can also have suppose X equal to 0. I can also write Y is equal to 0. And when it becomes a Boolean expression. So, you can write large programs simply writing the assignment statement itself. But there is a bit of a drawback with this because all that I can do is simply expression evaluation whether it is an arithmetic expression, logical expression or whatever. Now, suppose now I want to modify this and say I want to exchange X and Y only if X and Y are both greater than 0. Then what do I have to do? I have to make a change to the body of the program. What do I do to the body of the program? I say X greater than 0 and the sand and the sand Y greater than 0 to flower bracket. Then these statements will be executed. Y equal to n. Then what happens now? My first condition also is staged. So, what is the post condition become here? The post condition will be X and Y are exchanged if both X and Y are greater than 0. So, you need to whereas the input condition on the other hand is still remaining the same. So, this is how I would expect you to do this. And as you keep on increasing the size of programs for this small segment it is nice to put a pre condition and a post condition to show what you will what we expect. Now, what I could do is this is an F statement over here and this is a new type of a control structure which you have already seen. It is called alternative statement sometimes also known as a selection statement. Now, clearly the alternative statement is not, it is not only one alternative. They can be a number of alternatives. I could say X greater than 0, Y greater than 0, do one thing. X greater than 0, Y less than 0, do something else. X equal 0, Y equal to 0, do something. So, one then all these can be written F condition 1 body of program. Let me call it program 1, then L sif condition 2, then you have another body of the program, L sif condition 3 and so on. Can keep on extending this to a large number of alternative statements. So, the alternative statement is a very powerful statement using which you can satisfy a large number of conditions that may be there on the input data. Notice that and every time what I will advise you to do is in every case for every small piece of code, what is the input condition, what is the output condition. So, this is the alternative statement. The next statement which you have already learnt is what is called the repetitive statement. Suppose, we want to perform an operation a number of times, then we use what is called a repetitive statement. Let me give you an example, a simple for block statement that is made up of a for block plus plus let us say n is equal to 10. And I have initialized sum to 0, sum is equal to sum plus i. So, what do we have now, what is it tell me here, this for statement says for i equal to 0 and while i is less than n, that means this is the initial value. And till it reaches the final value of n, just increment i by 1 and compute sum of i plus i, sum plus i. So, what have we done here, we just computing the sum of the first n number starting from 0. So, the simple form of a repetitive statement. Now, whatever you do is, I am going to take you a little further and let us look at this, you already done the latest common divisor and in the programming part of the course. And we will see how you learnt about Euclid's algorithm there and we will put this in the form that I have been talking about. So, what is the greatest common divisor, all of you know what it is, let us just recap again. Suppose, I have two numbers, one is of size 30 and other is of size 80 and let us say I want to find the GCD of 30 and 80. GCD is also the highest common factor between these two numbers. You have done this in school, what did you do in school, you took the number 30 and said let me write it in terms of its prime factors. All of you know what a prime number is, prime number is 1, which is divisible only by itself and 1. I take 18 also, write it in terms of its prime factors to 3. All right, then what would you do, you cross out the common terms in both the numbers, this is to common terms in both the numbers, multiply these two and you will write that 6 is the highest common factor or GCD of the two numbers. Now, what will do is you already done I guess, nuclear solverism, let us just recap it, this is slightly more efficient algorithm. When you put it on the computer, what we normally do is the following, as indicated in this program here, we take 30, we divide by 80, we get the value of 12. So, let me say this is 12, then what do we do, then we divide 18 by 12, this will give me 6 and then I divide 12 by 6 and the remainder becomes 0, that means I have found the latest common divisor. So, to recap again, I take the number 30 divided by 18, then what happens, the remainder is 12, which I have marked here, then I take the smaller two numbers 18 and 12, I divide 18 by 12, then the remainder is 6, then once again I take the smaller of the two three numbers, just 12 and 6, I divide 12 by 6, the remainder becomes 0. So, once the remainder is 0, we are done, this algorithm is called U-clitz algorithm for computing G-cd. So, what have I done here, I have written this in C over here. So, notice that, this is a different form of a repetitious statement, it is saying do until the remainder is m percent n and m is set to n, n is set to the remainder, while the remainder not equal to 0. So, what will be the precondition, m and n have to be non-zero positive integers and the, what is the post condition that is satisfied, that you found the G-cd of m and n. Here, another way of writing this same program, using another type of repetition statement called while n not equal to n, if m greater than n, then you keep on reducing one number by the other until it becomes equal to, until both the numbers become equal, when the two numbers become equal, it will give you the G-cd of the two numbers. So, what have we done here, notice that within this two block, you have a set of, the body of the program consists of a set of assignment statements, here within the by-by block, here for example, there is an alternative statement and within the alternative statement, there is an assignment statement and so on. So, what we have done is, we have looked at the basic building blocks of programs, assignment statements, alternative statements, repetitive statements and what we do, we basically kept on adding complexity to the way we wrote programs such that all these statements were being used. Next, what we will do is, so this is all very fine, what we do now, so basically if you look at your program now, a large program can be written with the assignment, the alternative and the repetitive statement. Now, it will also be very nice, if you can have two things, one is I want to write a program which generates long, long lasting computations. I also want a program which can process arbitrary quantity of data and you have already seen in the programming course, how do you do this, yes you guessed it right, we need a function module and the data must be stored in an array. So, basically what we are looking at is a program segment that refers to a state space of an arbitrary number of dimensions. Using arrays and functions, program segments can be made to process an arbitrary number of dimensions of data. So, here is one example again, you already know what an array is, I want to reverse the elements of an array, so I have written one function here which will, which we already saw the swap for example, here it is done with a function for example, I am taking an argument to characters and I want to reverse the string in place, that is the objective. So, that means I have a string like this, let us say I want write a program of this kind, where I am taking a string, I have a string like this and I want to reverse the string, I want to use this output, I want to do it in the same array, let us say this is the array a, so this is 0, 1, 2, 3, 4, 5 and this again the same array, I want to do this in place. How do we effect this? We simply exchange the first two elements, the next two elements and then the middle two elements and that we give us the string and that is what this piece of code is doing. The exchange operation is being done by this swap over here and you already know why we have to pass it with the, as a point of the simple reason that see does not support pass by reference, it only supports pass by value. So, basically the contents of x location 0.2 by x are exchanged with the contents of y, but basically the addresses is what we return back to the main program. So, what is the program and what have what are we doing here? As I said I come to the divide the array into till the middle for example, until I can I start from here exchange this, here exchange with this, here exchange with this and then once I reach the middle of the array I am done and that is precisely what this program is trying to do and what are we doing till length by 2 I am swapping the two elements, swapping is exchanging the two elements in the array. Now, you have seen in the programming course that you could use arrays or you can also use recursive data structures. What is the recursive data structures now? I can use for example, I want to represent as we said we want to do some long lasting operation. So, I can write it like this S t R I m and j. So, now let us say I want to do the same operation as I did here in this where I reverse the array and so what do I want now? I want to reverse list this I also done in place such that this is the header that I have you know that already you know in recursive data structure it has a header to which points to the starting point in the list in the linked list and now what do I want to do? I want to make this the header and reverse all these arrays and finally, this should point to the tail and that is exactly what is being done in this program which I show you over here. So, what are we doing now? We have three pointers p q and R what are we doing now? We are first setting. So, the point to q let me call it q is a pointer which is set to another that is how we started p is the pointer which is pointing over here. Then what are we doing? We are saying while p does not become null we are putting R so R is pointing over here R is pointing to p point and next then what are we doing? We are saying p point and next now is going to point to q what is q pointing to now? q is pointing to null right then so what are we done now? I have made R point to p point and next and the next element of s is pointing to null next what are we doing? We are setting p is equal to R because I already have a point of q which points to this then we are setting p equal to R before that of course we are setting q equal to p because q is updated over here and we are setting p equal to R. So, R is the so this is the new p pointer now. Then what do I do? So, basically I have a q which is going like this and this no connection over here and p is passing through this. Then what do I do now? Once again I repeat the same process what will I do now? I will put there basically I will put R is p point and next R goes over here then what will I do? I will put p point and next is q then I will update q to the position where p was and then I will make this p again and you keep doing this until you reach the end of the list. So, another implementation of the reverse string which is done in place. So, what we have looked at so far is we looked at basics of programming basic building blocks that we make up a programming language then we looked at the arrays and functions with some examples on reverse string using the array and also reverse string using the building list and these are so now we are kind of equipped with what are called the basic data types what are the basic data types we have. We have the integers we have the floats we have the character and then in addition to that you have structures like this for example recursive the type is represented using a structure and a point of that matter and then you also have the arrays. So, next what we want to do is we have written now. So, basically we have started writing programs which execute a number of times. Now, let us see I have two ways of solving the same program or maybe four ways of solving the same problem. How do we know how well this program runs. So, we need to get some formalism into how you analyze algorithms. So, we will stop here and we will go on to the next lecture on to determine the efficiency