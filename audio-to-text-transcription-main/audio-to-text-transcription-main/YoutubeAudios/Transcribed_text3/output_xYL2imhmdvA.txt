 Hello all, welcome back to this lecture. In this lecture we are going to look at what is called dynamic memory allocation. So, in all this time so far what we have been looking at is we know the size of the arrays or we know the number of different integers we want or the number of floating points we want and so on and that is not always something that you get. So, many times you may want to ask the user how big the number of elements you want and based on that you want to allocate arrays of an appropriate size and such. So, in this lecture module what we are going to look at is the notion of dynamic memory allocation. So, fundamental to various programming languages to be able to allocate memory only on demand, only if the program needs it you allocate memory and whenever you do not need it that memory has to be reclaimed back and so on. So, to come to this lecture you should have a reasonable understanding of what pointers are and if you have not gone through the lecture on pointers. So, is strongly suggest that you go and review the lectures on pointers before you come back here. So, let us go back to the very first set of things that I talked about the notion of allocation of space. So, whenever we declare a variable of any data type there is allocation of space done to that. So, you take the amount of memory that is that and you go and reserve a certain sequence of bytes and say that this is useful for this variable and no other variable can use this location this is what we have been doing so far right. Whenever I have int x or float y and so on we assume that there is a particular set of bytes that is already allocated by the compiler to go on for you to go and use. So, sometimes right when you look at these data types there are two questions that one could ask right and these two are not the same they are related but they are not the same. When do we know the size to allocate? So, if I ask you in if I have int x right do we know the size that we have to allocate? Yes if I specify int x I know that I have to reserve space for an integer right. If I do if I do int of a comma a of 10 I want a to be an array of size 10 elements. So, I do know the size that I want but this is not the same as actually allocating space right. So, if I know the space that has to be allocated I do not have to immediately allocate the space I can allocate it when the program starts running right. So, I could do it at two possible times one is called compile time or static allocation and another is called run time or dynamic allocation right. So, generally if you know the size that has to be allocated which means if you know statically how much has to be allocated you would also do the allocation statically. However, if you do not know the size of the array that you want and so on right you have to wait till the program starts running when the program starts running you may have to ask the user how much you want based on that you need a mechanism by which you make reservation for only as many bytes as the programmer wanted right. So, that is called dynamic memory allocation and let us see what how the process goes. So, let us see this example character C. The moment a compiler looks at it it knows that it needs only one byte because characters require only one byte. However, if you have a declaration of size int array of 10. So, you need an integer is 4 bytes typically and that into 10 times you need at least 40 bytes right. If the size is known it is generally also good to go and allocate the space as soon as the program starts running you will have 41 bytes allocated one byte for character C and another 40 bytes for array of 0 to array of 9. However, sometimes we do not know how much memory to allocate. So, if I have int star array we may not know how big the array is going to be. So, it is a pointer to an integer right now. So, is it pointer to just one integer is it is it a pointer to 10 integers 100 integers 1 million integers we do not know that yet right. But all we know is at this point of time we know that it is a pointer to a pointer to an integer right. So, how do we use this? So, in star array if I have that I could make array 0.2 something that is already allocated. So, I may have something like this. So, let us say I had a declaration of this form int B of 10. So, B is already allocated its space for 10 into 4 40 bytes at least and I could make array 0.2 B. So, I have B which is of 10 integers and I could make array point to that. So, when you make it point to that it will point to the 0th location of B. So, in this case allocation is already done. But there are also places when the declaration is not done in which case you have to go and declare or you have to go and claim memory you have to allocate new memory and claim that space to be yours right now. So, this is something that you have to you probably remember from an earlier lecture. So, when I said something like instar p right p is just a point of variable it does not allocate an integer. It only allocates a pointer which can point to some integer right. But the integer itself is not allocated. So, in star array may have to be pointed to something that is already allocated. But if it is already allocated I should know this size. So, this gets into a loop right this gets into a problem of knowing the size ahead of time. So, what we want is a mechanism by which the size may not be known and during the runtime of the program and the program already starts running only then you get to know the size and you want to allocate sizes appropriately. So, to do that there is a function called malloc or mloc as some people would call it. So, malloc is a function in C and it can take an integer as its input and it returns a pointer as its output. And this function is it is in this library file called sdlib.h. So, it is already given as a library to you you do not have to go and write your version of malloc. So, malloc is a function that is already defined in sdlib for you. What it does is it follows. You pass a size to it you pass a number of bytes that you want. Let us say I want 10 integers right each integer is of 4 bytes I will pass 40 which is 10 times 4 to malloc. What malloc would do is it would go and scan the memory that is there find out if there is a new space. If there is a continuous chunk of unused space of 40 bytes it will claim that as a space that you want now and return it to you. So, if I have a huge array if I have a huge memory it is possible that some portions of the memory are already taken and some portions are not. When malloc is called let us say I called it with 40 bytes I want 40 bytes to be allocated. We will go and look at the first free space and ask is there 40 bytes in this space. If the answer is no it would go and look at the next wide space wherever there is no allocation done is there 40 bytes there. Once it finds out some free space with 40 bytes which are continuous it will return a pointer to the caller. So, in this case in this line here the caller is at this point right the caller called malloc malloc would return a pointer and what pointer does it return it actually returns what is called a wide pointer. So, it returns something called a wide pointer which means the data type is not important I have given you space right and then it is up to you to take that and typecast it to integer pointer or a character pointer and so on. So, in this case we ask for 10 integers 40 bytes you will get a pointer to 40 bytes you make that a pointer to in star. So, you make that a data type in star it now means you have a pointer which is an integer pointer data type. On the left side you have an integer pointer data type and once you typecast the right side is also an integer pointer data type these two are matching. So, you can copy the value of this to the left side. So, now how do we ask for 40 bytes? We did not ask for 40 bytes explicitly instead we said give me number of items into size of an integer. So, this is something which is a common theme that you will see in malloc instead of actually specifying the number of bytes you say the number of elements that you want into size of each element. So, in this case num items is the number of items that we want and what we want we want integers of so many count. So, size of is an operator and see if you pass a variable to it it will return the number of bytes required we have already seen this before. So, this void star in this case is typecast into in star and this is a way to allocate memory. So, again in summary malloc is a function which is in STD lib. If you pass the number of bytes to it it will go and scan the memory and find out if there is an unused space of so many bytes and once it finds out it it tells that this location is free for you to use go ahead and use it and you use it as a contiguous space of memory and contiguous space of memory is usually arrays. So, you get a pointer to an array. So, let us look at this small example here. So, we have two pointers namely star i and star array. So, i is a pointer of integer type and array is also a pointer to integers. So, in this line here we have i equals star malloc of size of int. So, we are claiming space only for one integer and i is going to point to it. So, i is a pointer to an integer whereas, here we had asked for number of items into size of int we are asking for more than one integer depending on numby num items. You get a pointer to so many bytes which can occupy num items integers and you get a pointer to that that goes into array. So, both i and array are pointers to integers only that i is pointing only to one integer whereas, array is pointing to a series of locations right in this case num items locations. So, num array sorry array is pointing to num items integers. So, you can do star i equals 3. So, that will change the contents of the memory location pointed to by i to 3 and you can do things like array of 3 is 5. So, array of 3 is 5 is valid because if num items is greater than 4 then array of 3 is valid. So, array of 3 will point to the third location in the array and that is change to 5. i and array are interchangeable just because I have one integer allocated here and 4 integers or 5 integers allocated here it does not mean that i and array are incompatible. If you go back to the definition both are integer pointers right. So, i and array are interchangeable. So, arrays can be thought of as pointers to the 0th element we have been doing this for a long time whenever I have an array I have been saying that we can abuse the notion of an array and say that is actually pointed to the 0th location. So, i could also point to an array as well. So, in fact, I can do i equals array and I would start pointing to the array which array was pointing to earlier and these things can be changed over time both the variables i and array can change over course of the program. So, one thing that you have to be careful about is I said if maloch goes and finds out a chunk of space if that is free it will return the pointer to the chunk of space. What if maloch does not find any free space? You wrote a program which is supposed to have process a lot of data and you want more memory allocated to the program you called maloch maloch went and looked at the memory and what if there was no more memory available. In this case actually maloch does not return a valid location in the memory it returns the special case called null. We have seen this before this NUL in capital letters is a special symbol it this cannot be any valid pointer right. Because it is not any valid pointer and maloch if it returns that you know that there is some error that happened maloch tried to find out your 40 bytes or 100 bytes or 1 million bytes or whatever and if it was not able to find out continuous chunk of space of so many bytes it returns with null. So, it is your duty to go and check if maloch returned null or not. If it returned null it means some problem happened in memory allocation you can print to the user that you actually ran out of the memory and you can do exit. So, this exit of 1 is again a function call which indicates some kind of an error. So, the moment some problem happens you may want to exit from the program and say I did not have enough space I could not have continued running the program. But however, if A is not null you will not print anything on the screen you will not call exit. So, A is successful successfully pointing to some allocation that you did and you can use the A you want it right. So, this is something that you have to keep in mind even though I am not going to show this thing in all the subsequent code. So, I will not have maloch followed by this check every time it is something that you have to do every time you have to go and check whenever you do a maloch it is possible that there is something that maloch cannot allocate therefore, you have to check whether it return null or not. It is not it is also not enough to just allocate memory you also have to think about what is called deallocation of memory. So, let us go and look at this piece of code here. I have a function f which has int y and array of 10 these are local variables within the function f and I could so, I know this from functions that since these are local variables they become alive only when the function is called and they are automatically killed and returned when the function returns they are automatically destroyed. So, we talked about this when we dealt with functions. So, local variables are good because when you call the function they become alive and when you return from the function they become dead. So, when you go to the end of this line f here y is an integer is deallocated array which is an array of 10 integers is also deallocated. You cannot refer to y or you cannot refer to array the variable array anywhere outside f this is something that we know already. So, all automatic variables are created automatically and destroyed automatically that is why they are called automatic variables whereas, if you do call something with malloc you are getting a pointer to the memory that was pointed to and it is your duty now you claim the memory you wanted some memory and you have to free it up. So, it has to be done using this function called free and forgetting to deallocate. So, let us say I claim some memory and I do not have use for it anymore I have to deallocate it and for that I will use free. So, for example, here in star a is malloc so many bytes as nummitem integers demands and I use that if I do not have any use for it I should go and free up a. So, if you do not do that what might happen is that this chunk that you allocated may remain as somebody claimed it and somebody made a reservation and it is still being used that is how the compiler would treat it. So, this is like you go to a hotel let us say you go to a restaurant you make a phone call and you reserve a table right you reserve the table but you never turned up. Then the restaurant would have to know at some point whether somebody is going to turn up and use the table or not right and if you are not going to call if you are not going to go to the restaurant it is good for you to call the restaurant and tell them I even though I called I made a reservation I do not want it anymore. So, that is equivalent to free or you actually went to the restaurant you had your meal you return back at that point it is not reserved anymore. So, you have to say that this table is not reserved anymore it has to be freed again. So, this is the equivalent or analogy that I can give you for maloch and free whenever you claim some space that is your duty to go back and tell the system to reclaim it you do not need a you do not need this anymore so, once you free it you cannot use a anymore below this line. So, once I have freed a I do not have space reserved for a anymore a is not pointing to anything therefore, I cannot say a of i equals 5 and so on I cannot do that I should either go and do new allocation or I should make a point to something that is already allocated. So, I could do something like a equals b if b was declared as int b of 10 or I could do new allocation as it was given here. So, you must not use a freed pointer unless it is reassigned or reallocated. So, keep this in mind. So, space allocated by maloch is freed when the program terminates. So, if you do not free up memory ever so, you use allocate some memory you use it, but let us say you do not do free and you keep doing that. So, slowly and steadily your memory will get used up at some point of time your memory might become full. So, in any of these cases right if you do not do explicit memory deallocation when the program exits your program is done with its work you do not need to claim the space anymore automatically everything gets deallocated by your operating system right. So, you can wait for your program to terminate and free up all memory that you that your program claimed. So, some people do that, but that is not good practice. So, the good practice is as and when your program does not need some memory as well deallocated because your own program may need more memory for doing some more work later. So, let us look at a small function called create date it is going to take three integers month day and year and it is supposed to return a date right. So, let us say I did this date start d. So, d is a pointer of the type date and remember it does not allocate memory to it does not allocate three things for month day and year right. It only this it declars a pointer to type date. So, you have space for a pointer, but the actual members are not allocated yet and let us say you did this d is month is supposed to be the month that you passed on d is day is supposed to be the day that you passed on and d is year is supposed to be the year that you passed on and return the pointer d. Let us say we did this right. So, this would be this would be wrong because d is not allocated any memory right. So, the correct way to do that is as follows d is a pointer first allocate space and how much space do you want to allocate? I want to allocate space for one date type and what does this date type have? It has one month field one day field and one year field right we need three things. So, when you see size of date size of date is three integers one for month one for day and one for year and when you do malloc of size of date that returns a pointer that is assigned to d. So, now d is actually pointing to an allocated space. Once it is pointing to allocated space it is okay to do d arrow month d arrow day and d arrow year and when you return d you are actually returning a pointer to the result space. So, the result space still exists and you are returning a pointer to the result space. So, the function on the right side is correct whereas, the function on the left side is not because you do not allocate space on the left side you explicitly allocated space on the right side. So, one thing we have to do is even though the space is explicitly allocated remember create date is not responsible for deallocating it right you are not explicitly deallocating it yet. You have only explicitly allocated it that somebody is job to come and deallocated later we will see who the somebody must be later. Let us see a small thing here right. So, date start today today is create date 9 1 2005 and do return. So, I want to do let us say 9th of January 2005. I created a variable called today. So, today is a pointer to the date type called date create date in turn returns a pointer to data type called date I use today and then I returned it. So, at this point create date allocated some memory and you got that in today. So, let us look at the sequence of things right. So, inside this function called FU so, today is a local variable and what is today? It is actually a pointer it is supposed to point to a point to a date data type and when you called create date. So, inside create date you allocated space 1 for date 1 for month and 1 for year you allocated space for the structure you return the pointer to this. So, at this point your today field is pointing to the location that you gave for the structure and let us say we used today and we return we came to the end of it. At this point we return from FU what would happen now since today is a local variable within FU today gets destroyed it is an automatic variable right the automatic variable gets destroyed. So, whoever called FU cannot access today because today is a local variable within FU and because today is lost you also lost a pointer to some reserved space that you had. You reserved space for a structure but today which was holding the pointer to the structure was destroyed. Therefore, you lost the trail to go back to the memory that you allocated. So, this is a problem. So, whenever you have something that is allocated from a function and if you put that in the local variable and if you did not explicitly deallocate it that thing is still going to lurk around this structure that you had is still going to lurk around and you will have no way to free it this will get freed only when the program gets done. So, you have to be careful about it. So, there are various possible solutions and the cleanest solution is let us say I did create date I did whatever I want to do with date I know that I do not need date anymore and I am returning from the function as well free today. So, that so, when you say free today the function will go and look at the space allocated or reserved for it and remove the reservation. So, that space can be used by the program some other part of the program. So, this free takes care of that and when you return it you have already taken care of whatever allocation you have done you have removed your reservation. So, now I am good to see show you sequence of various things and I want to argue about why something is correct or why something is incorrect. So, let us look at the function on the left side. So, in star f so, f is a function and I is a local variable within the function and you are returning address to the local variable right. So, that is what this in star does. So, in star means you are returning pointer to an integer is this something that you can do this is not possible because when the function gets returned I is a local variable I gets destroyed it is not correct to track the address of I anymore. So, this is not correct it is deallocate in I you cannot track it anymore. Let us look at this function on the right side it is also supposed to return an integer star it is it is returning a pointer to an integer. So, here you have a local variable called array which is an array of 10 integers and you return array which means you are returning the location of the zeroth element of array. But again you this return array is supposed to return a pointer to the zeroth location, but since array is local to make array array gets destroyed when you return from make array. So, you are having a pointer that is actually pointing to a location that you cannot claim to be yours anymore. So, this is a problem. So, if you do this sometimes it will look like this whole thing is actually working. So, this might work because when you return back from this make array maybe the space is still containing all the values nobody reclaimed it. So, when you go back to that location you still see the values, but if you are unfortunate this memory location that you did not want anymore got used up somewhere else and now you are actually accessing something that is not supposed to be used by you. So, the space if it is reallocated this becomes unpredictable, but if the space is not reallocated to anyone else it might work. In general you should not rely on the space to be unallocated you should not believe that oh I am hoping that it is unallocated let me go and use it that is not correct you should treat it should be conservative and you should say that I will assume that it is going to be reallocated therefore, I will free it up here and I will not pass pointers back to local variables. So, if you want to really pass pointers to local variables or anything that you allocate inside if you first of all do dynamic allocation and you pass on a pointer this is correct. Similarly, here you did dynamic allocation. So, these 10 integers are not going to be deallocated when the function returns and because of that it is ok to return a pointer to that. So, you allocate with malloc and return the pointer. So, this is allowed. So, now let us go and look at how to allocate multi-dimensional arrays. It is not just that we look for single-dimensional arrays or an array of integers array of characters and so on many times you want to build matrices or 3D matrices and so on how do we do it. So, we start with in star star p. So, the meaning of that is p is a pointer to a pointer to an integer. So, let us see what that means. So, p is not pointing to an integer. P in turn is pointing to another pointer which is in turn pointing to a some integer. So, that is the meaning of in star star p. So, p is supposed to be pointing to another pointer which is in turn pointing to an integer. And int is a so int i is declaring space for an integer i. Now, let us see how to allocate a multi-dimensional array. So, the first thing you do is let us say I want m rows and n columns. So, the first thing you do is allocate m pointers first. So, we have m pointers that are being allocated and this is not going to get pointed to anything. So, you have m pointers. We do that first and then each pointer variable you now make an allocation of n integers. So, you allocate m pointers to integers and then you allocate n integers at a time and this will suppose this is supposed to give you n integers. So, each row you get from a malloc and you have m rows that gives you a m cross n matrix. So, let us break this down. The first thing we have done is a malloc of size of in star. So, size of in star is size of integer pointer not size of integer it is size of integer pointer and we want m integer pointers. Let us say you got them you got m integer pointers and they are not going to point to anything because malloc does not initialize. So, what do you get in return? malloc will return a pointer to 10 let us say 10 rows you will get pointers to an array of pointers and these are pointing to 10 integer arrays. So, an in star star tells you that the left side is expecting a pointer to a pointer it is not a pointer to an integer it is a pointer to a pointer to an integer. And once you have that you have all these pointers which can which are ready to now point to the 10 different rows, but you have not allocated space for the rows yet and that is done inside a loop. So, this loop goes from i equals 0 to m minus 1 and you are allocating one row at a time and each row is of size n integers. So, that is what you have here. So, this is a very basic way in which m rows by n columns is allocated at the end you actually have m and elements. In fact, once you have this you can use p of i j to access the elements. So, just like you would access array of i comma j to dimensional array of i comma j, p is a pointer to a pointer to an integer you can use p of i comma j to get to the basic elements. So, it would be incorrect to access p of i j if you have not done this or if you have not done this. You should have done both these mallocs. So, you have you should have done a malloc for 10 pointers to integers and you should have allocated for each pointer to point to a row of n numbers. So, that will give us 10 rows by n columns. So, let us look at how to de-allocate multi-dimensional arrays. So, right now you have let us say 10 pointers pointing to one row each and each row is of size n elements. So, you have m of these and you have n of those. What you do is you first go and do free of p of i and you iterate i from 0 to m minus 1. So, when you say free p of i you start with p of 0, p of 0 free p of 0 will de-allocate that free p of 1 will de-allocate this row p of 2 being freed will de-allocate this row and so on free p of m minus 1 will de-allocate this row. So, you have done with deallocating all the integers, but you still have all these pointers that you allocated, right. And the way you allocated that was p was pointing to all these 10 things as though they were an array of pointers. And when you do free of p it also de-allocates all the pointers. At this point the point of p is not pointing to anything valid you make p equals null. So, essentially what you have is you have a sequence of steps. When you want to allocate two dimensional arrays you first go and allocate a pointer to a pointer to the basic data type and you iterate over that one at a time and allocate rows. When you de-allocate you de-allocate all the rows one at a time and then you de-allocate the array of pointers itself. So, this is the way you allocate and de-allocate pointers. So, first free all the rows, free the array of pointers make p point to the null and you are done. So, this is you keep p will keep pointing to null until there is new allocation. So, with this we are end of at this lecture about pointers and how to use dynamic memory allocation for not just one de arrays it can also be two de arrays. The basic element that you store in an array can be an integer can be a float it can be a character it can also be structures. You can have a 2D matrix of structures where each element could be an integer containing x and integer containing y maybe you have a 2D array of pointers that is possible. So, to summarize what we have is we have a mechanism a general mechanism by which as long as I know the size of the basic data type that I want I will allocate bytes as many as I need I will get a pointer done by returned by malloc I should point it to the appropriate data type and whenever this memory is not needed anymore you should be really careful and de-allocate the memory. So, that your memory is not hogged your program itself further down may need more memory. If you did not free up something that you do not need you may get stuck. So, this brings us to the end of the lecture. Thank you.