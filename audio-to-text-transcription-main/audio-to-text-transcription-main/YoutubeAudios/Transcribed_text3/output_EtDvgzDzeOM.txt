 Welcome to the very last video for this course for this MOOC. So, you have stuck with the course for so long and so this is a place when I do not want to teach something completely new. So, this is something that you have done you have already done the programming, but when you write large pieces of software you may have to do a few things to be just careful and so that it becomes usable even later. So, one thing that happens with software is that lot of people start contributing to code and you want your code that you wrote to be able to read by others and maybe they want to change it later or you may even go and change your own code to do a few other things later and so on. So, you need to follow a few principles to do this and one major thing that you have to do is take a problem and divide that into smaller subproblems so that you can solve each of these subproblems separately and put them in different places. So, instead of so maybe you have not seen this or you have not done it so far because you are writing smaller programs so far, but this can really become a problem if you write lots of code. So, to motivate this whole thing I am going to give a small programming assignment to you. It is not a very hard assignment so I want you to go and write a program to print these figures. So, there is a hexagon looking thing at the left and then there is something like a cup, there is a stop sign and we will call this the hat. So, let us say this we will call this the egg, the cup, the stop sign and the hat. Let us say you want to draw these things. So, I am asking you to write a program which will draw you could do something very easy. So, in the first line draw dashes in the second line draw this forward slash give some space draw the draw backward slash. You can do a lot of things so let us look at the very first crack at this problem. The first version is an unstructured program. We will create an empty program and a main function. We will just copy the expected output, but surround each line with printf and run it to verify the output. We can do that very well. So, your program would look something like this. In main void printf you have a series of printf in each one you can see what you are trying to print. So, only thing that is slightly different than what you will see in the output is for every back slash you have to use this escape character called back slash itself. So, every back slash is actually supported by another back slash. The other thing that is missing is a series of new lines that I have not explicitly added, but otherwise your program would look something like this. So, this is what I will call an unstructured program. So, you have not put too much thought into it. You are asked to print something like this. You have just write a series of printf statements and this will print some it will print what you want, but it is not a very nice thing to do. So, the first thing that you do in any engineering step is take a problem and divide that into sub problems right. The same thing applies to writing software. Can you take this problem and divide that into sub problems. So, the main thing that comes with this is what is called decomposition. Can you take the problem and decompose that into smallest sub problems and identify if there is any structure to the problem itself. So, let us go and look at this. So, there is some a structure. So, there is so, the first figure will call that the egg, the second figure will call that the teacup, the third figure is we will call that the stop sign and the fourth figure will call it a hat. So, now I can think of this problem as draw an egg, draw a teacup, draw a stop sign, draw a hat. That is slightly better than draw some line and draw some other line and draw some other line and so on. So, this is slightly better. Let us see how this might look like. In your main program, you will have four function calls draw egg, draw teacup, draw stop sign, draw a hat and you would have to write four functions for each one of them, egg, teacup, stop and hat. So, this is something that you can do and it is something that you can write at this level anyway. So, you have these four things. So, main depends on the function would depend on the function egg, would depend on the function teacup, stop sign and hat. So, that is another way to write the program, but this is still not the best thing. So, let us go and look at what is happening. Your main program becomes much simpler. The task that you are doing in main is I have to do these four tasks in this order. That is all you care about. But you do not care about how exactly egg is drawn, how teacup is drawn and so on because you have delegated this to a function. Remember when we did functions, I talked about delegations and we did exactly that now. So, when you call this function egg, this function egg has all the print of statements. Of course, new lines are missing. I did not intentionally added because you can see the structure of the output here clearly. So, series of print of statements, this is slightly better. What you have is from the main program, the intent is clear. You want to draw egg, draw teacup, draw stop sign and draw a hat, but the functions are themselves still ugly. You have only the series of print of statements. So, this is one level of decomposition. From something which is just a sequence of print of statements, you have four function calls. The main program is clear or the main method is clear, but the internal functions are still a bit ugly. So, now, let us see whether we can decompose the problem a little further. So, this is actually just finishes the program with all these four egg teacup stop sign and hat. Let us see if there is something better that we can do about this whole thing. Is there some other structure to drawing this or should I be drawing, writing a series of print of statements for each one of these functions. So, let us look at the egg to begin with. So, the egg, there is something in the top half and something in the bottom half. You cannot really draw the top half with the bottom half, code or anything like that. There is no reuse that you can do. So, the top half has to be drawn and the bottom half has to be done separately. So, this will require a print of a line followed by forward slash and a back slash and forward by another line with a forward slash and back slash. And in this it would be the reverse. So, you cannot reuse anything. So, let us assume that there is a function which can draw the top half of the egg. There is another function that can draw the bottom half of the egg. So, we will call those functions egg top and egg bottom. Let us see if we have identified this. Now, let us go and look at this next one which is supposed to be for drawing a cup. If you notice cup has something which is similar to the bottom of the egg but there is something else also the saucer here right is just a line. We need something to do there right. So, if you want that so, so, so, the cup actually can reuse the egg bottom, drawing the egg bottom. So, if you draw the egg bottom and if you draw a line with the pluses on both ends that is actually okay right. So, if you know how to draw bottom of an egg you can actually draw a t cup. Only thing you have to do is draw the bottom of the egg and draw a line underneath. So, t cup requires how you to know how to draw the bottom of the egg and bottom of the line. If you have already written that as a function you can call the same function once more from t cup there is no harm. Now, let us go and look at the stop sign. The stop sign is also interesting because the top half of the stop sign looks like the top half of the egg. The bottom part of the stop sign looks like the bottom half the egg and also the top of the cup and there is a line in between which has this stop right. So, for drawing a stop sign if you draw an egg top and if you print this line and if you draw egg bottom you have a stop sign right. So, we will call this line the stop line. So, this is called just a line this is called stop line and for drawing a stop sign you need egg top then you need to draw stop line and you need to do egg bottom right you have that. Then let us look at the last one which I call the hat the hat seems to be the top of the egg and the bottom of the t cup right. So, I already wrote those two things I have let us say I have functions to do those I have top of the egg and bottom of the t cups I have these two. So, I do not have to rewrite code anymore right. So, we have these two and I already have the methods. So, now if you look at this whole structure main program requires you to know how to draw an egg t cup stop sign and hat because those are the four function calls you are doing egg in turn will call egg top and egg bottom in that order t cup will call egg bottom and line in that in that order stop sign will call egg top stop line and egg bottom in that order and hat will call egg top and line in that order. So, for for writing egg all you have to do is write egg top and egg bottom and two and make two function calls. But somebody has to still write egg top and egg bottom and line and stop line and so on. So, now there are two questions one can ask what are the methods we should be defining and what is a good order in which we are to implement and test these methods. So, clearly main depends on these four and these four depend on these four it dictates that we we have to know how to implement these four without building this there is no point in building these and without building these you cannot build your overall diagram which is on the left side this egg followed by cup followed by stop followed by hat you cannot draw that unless you have drawn you know how to draw these four structures. So, we will stop start with each one of them. So, main requires a call to egg t cup stop sign and hat this is just like what we had in the version two of the program only that we have a version which draws top of the egg and we draw a version which draws bottom of the egg if we have these two I am ready to draw the egg itself what does the egg need you need top of the egg you need bottom of the egg and you need to draw the egg by calling egg top and egg bottom. So, forget this print up for a while now it is actually a mistake it should have a backslash n there. So, print up backslash n it will draw a line after the egg is drawn. So, if you look at the sequence egg main calls egg egg calls egg top which will draw this then it calls egg bottom which will draw this and it is supposed to be printing a new line again in these places the new lines are intentionally left out so that it does not clutter the program right now. Then let us look at how to draw a line so you do a plus followed by dashes followed by a plus this is for our saucer to draw a t cup we need the egg bottom and the line and so that will give us the cup and saucer to draw a stop sign we need the egg top and egg bottom but we need a stop line in between. So, this stop line is needed only for the stop sign it is not needed anywhere else. So, instead of calling a function I could just put the print up statement here itself because it is not used by more than one function. So, stop sign is required the stop line is required only for the stop sign nothing else hat you do not need to do anything new at all. Egg top you have already drawn you know how to draw a line you do these. So, you now look at the structure of the program is much cleaner you have reused the code that you have written for egg top and egg bottom in several places. So, egg top is used in drawing egg under hat egg bottom is useful in drawing the egg and the t cup and egg top and egg bottom are useful in stop sign. So, now this is a much nicely structured and nicely decompose program. So, for instance if you make one small mistake in the space in the egg top right you if you had cut and pasted these two the this structure multiple times you have to go and change this multiple times in your program. But if there is a small mistake in egg top all you have to do is fix it here automatically all the functions which call it will have the fixed version. So, this is the setup. So, even though I said this is what you should do there is some more things that you have to do. So, first thing is taking a problem and dividing dividing that into subproblems and writing functions for each one one of them we have already done that right we need to do something more. The thing is we have the so called basic shapes. So, I am going to call egg top egg bottom and line I am going to call these things as basic shapes using basic shapes you build the shapes and using the shapes you draw your complete picture this is the complete picture. So, these are basic shapes these are shapes and this is the complete picture and how do we do that? So, I want to be able to separate the concern of each one of them. Drawing the basic shapes and being able to do something that is different from being able to draw the shapes and being able to draw shapes is different from being able to draw the picture. So, I am going to do this in a bottom up fashion. So, you go look at this we will go and develop this in a bottom up fashion. We will try and write these things first methods for these things and then write methods for these things and then this but we are also going to do something more which you have not seen so far right. So, the first thing we are going to do is so far we have been using the so called header file we have not really developed our own header files. So, we use stdao.h and string.h and so on. So, you need to separate the concerns this is a term that people use in software engineering separate concerns right. So, one you are mixing the program what the program is supposed to be doing with what the interface of the functions are. So, the implementation and the declaration are all in the same file so far but we can separate these concerns. So, use the code.h or give a file name.h to do all the prototypes and so on and write file name.c to write the program. So, the implementation usually goes into .c and the declarations go into .h files. Let us say we adopt that right and we are going to do something with the header files. So, for every problem there is some solving the problem itself and all the functions and other things that you need for it. So, we will see how to do that. So, the header files usually have this format. So, there is a hash if not depth of code name then define code name put all your structures and prototypes and so on and if. So, let us not worry about this if not depth define an end if but all the declarations go within these three structures hash if not depth hash define hash end if. So, what it tells you is if something called code name is not defined define it now define all these things and end it. So, let us see how this might look like for basic shapes. I am creating a file called basic shapes.h This takes care of only the declarations for all the functions which are for basic shapes. H top, H bottom and line are three functions. So, I have the declarations for these three functions in a file called basic shapes and so whenever I use a file name I will use the same thing for the if not depth if not depth basic shapes h define basic shapes h if this has not been defined so far define this variable now define all these function prototypes end it. So, this is the declaration for the basic shapes the description so will come later. So, if you want to use that dot h file you do hash include basic shapes dot h this is like hash include stdiot dot h. So, put your header file in the same folder as same folder as your c files and use hash include for example in std lib. So, I will show you how to write basic shapes dot c. So, basic shapes dot c will be a c program this has the implementation this includes a cdiot and also include basic shape and it has the function descriptions for a top, a bottom and line. So, with basic basic shapes dot h and basic shapes dot c you have something that can draw basic shapes and nothing else. Now, we want to be able to draw shapes with it right. So, let us move up I am going to write a file called dots shapes dot h which has all the things required for drawing the shapes. So, the declarations for drawing the shapes and this is the description of those functions. So, shapes dot c has shapes dot h because it needs those descriptions and how is egg implemented the implementation is in this file egg top egg bottom and print f t cup egg bottom line and print f and so on right. This is what you need for drawing the shapes. So, now we have four files basic shapes dot h basic shapes dot c shapes dot h and shapes dot c right. So, shapes dot h has only the declarations it also includes basic shapes dot h and so on. So, now we have four files you cannot compile just one file now you have to create what is called a project I will show you how the project is done in the demo. Finally, the top most thing I am going to call that draw figures dot c draw figures need shapes dot h and it need. So, now egg t cup stop sign hat are all provided by shapes dot c shapes dot c in turn depends on basic basic shapes dot c. So, this is the overall structure we have five files draw figures basic shapes dot h and c shapes h and c. So, I will I have already written this here so you can see basic shapes dot h which has it has the declarations basic shapes dot c which has the description shapes dot c shapes dot h which has the declarations shapes dot c which has the description and draw shapes dot c which has the description for the main program. I have included all of this into a project called draw shapes. So, you can do that by saying file new project. So, I did file new project I created a file by name draw shapes I included these five files into the project. Now, I can compile the project and what it does is it takes all these files and compile them together and when I run it right it actually runs the main program. So, if you notice right the individual ones do not have main routines right we do not have main routines in any of these the main routine is only in this one right. So, for drawing shapes dot c and basic shapes dot c and shapes dot c they are also compiled and they are compiled along with draw shapes dot c you can see the result of the printout here. So, you can see the egg the t cup the stop sign and this and that came from actually having taken the problem and dividing that into sub problems file it identifying the structure which is common and re being able to reuse and so on. So, for whatever reason if I want two cups tomorrow right I can actually call the cups twice. So, I can call cup t cup and t cup it will draw two t cups one below the other so, this idea of being able to taking a problem dividing that into sub problems is a necessary skill you probably did that with functions itself, but separating the concerns of implementation from the so called interface or just the declaration is another thing. So, once you have something if you divide that into multiple files you can quickly go and see which file has the basic issue and which file has a problem and so on. So, for example, tomorrow I may not want to draw egg and stop sign and so on, but I want to draw two cups or three cups I can write a different program which will take the cups and draw them explicitly. So, this notion of dividing the problem is decomposition and organizing them into multiple header files and c files is a very necessary skill when you build larger and larger pieces of software right. So, I want to end this course with one small piece of advice. So, there are lots of things that we did in the course, but we never wrote or explicitly used libraries for many of them c comes with a lot of libraries these are standard libraries that come with any standard c package right. So, your compiler's package these things for you things to operate on strings things to operate on characters for example, you can take a lower character and convert it to uppercase, you can check whether a character's lowercase or uppercase things like that. There are math libraries included from map.h, trigonometric functions, floor, absolute value, power and things like that are all available from math libraries. It is not just that these are the functions that are there even some algorithmic things are available. For example, from STD lib, you learnt binary search, you do not have to write binary search yourself, you can call the binary search function available from STD lib. So, you learnt how to do various sorting algorithms. So, Q sort for instance is an algorithm which does something called quick sort. So, you can call Q sort on an array of integers for instance. So, you have to learn how to do it I am simplifying a few things here. But for there are sorting, searching functions, mathematical libraries and other things that are already available out there. If it is available as part of your package learn how to use it. So, at some point all you have to do is make appropriate function calls include appropriate header files, make appropriate function calls and compile with appropriate flags. So, I am simplifying a lot of things but learn how to use the basic libraries and not write things from scratch every time you write a program. So, this brings us to the end of this module and in fact to the end of this course. And I hope you enjoyed the course as much as we enjoyed creating it. And this has been probably a rough and tough 9 or 10 weeks that you have been through with lots of programming assignments and assessments and so on. But we hope that this course helped you in some way or the other to learn either from scratch or at least be able to if you have already done see programming at least cleared a lot of concepts for you and taught you a few new things like data structures and algorithms and so on. So, in for doing this course we took help from quite a few people. So, of course, we three were the faces that you saw but there is a big team that was behind it. We had 10 TAs who are all behind this. So, they were actually responding to you on the forums. There is a team from Google which was which created the platform and there is also this local team, the NPTEL team in charge of video recording, scheduling and so many other things. So, there are probably 30 or 40 people who got involved in creating the contents for this course and delivering it to you. So, I personally want place on record that V3 tank each and every one of them. So, we cannot possibly list all of them by name, but I want to thank all of them to make this course the success it is now. And I am hoping that you guys will tune in later for other courses that NPTEL has to offer. So, all the best for your exams and I hope to see you in some other course at a later point of time. Bye bye.