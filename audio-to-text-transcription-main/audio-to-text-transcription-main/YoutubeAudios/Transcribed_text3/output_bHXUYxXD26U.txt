 Ok, good morning. In the last class, we try to motivate you on different types of problems, which can be solved very nicely when they converted to graph problems. Remember, we saw this problem on designing a traffic signal for this five point intersection, assuming that all traffic goes from left to is on the left hand side of the road like what it is in India. And we found it all over this looks like very, looks like a very domatable task designing a signal for this. We found that as soon as we abstracted information from this and transformed this to a graph problem, where we made the nodes the directions and the edges correspond to two nodes that are connected, are connected such that these two directions cannot happen simultaneously. We found that it was very easy to design a naive algorithm, which is called the coloring problem. And all that we had to do was we start with a particular node and let us say start with AC and then I say for this if this is green, then it cannot be green for BA and BD whenever it is directly connected by two edges, then you cannot have assuming left hand side traffic as in India. So, we found that we could easily solve this problem by a very naive coloring algorithm and make sure that directions which intersect are not colored the same at the same time. And once all the nodes are exhausted in the graph with this coloring problem, every node has been colored, then we have a design of a traffic signal. So, I guess this was a very nice motivating example to show why when you abstract to a graph problem, then solving becomes easy, then we looked at representation of graphs, we defined what graphs were and so on. Today, what I am going to do is I am going to take one particular problem on two problems actually, one on the shortest paths problem which is given a node and nodes and a set of vertices. Let us say these are the nodes that we have a set of vertices and given a set of edges, sorry and objective is you have this is a directed graph let us say and we are given weights on the edges to say how expensive it is to go via that particular edge to take that particular path. And our objective is let us say let me put some weights on this, let us say I have 8 here, 2 here, 15 here and 3 here and 2 here and let us say 12 here. And our objective is starting with some vertex, let us say this is the source vertex S, I want to go to all these destinations B C D and E, my objective is to minimize the cost. What is the cost now? The cost of a particular path for example, from A to C I can go either via the direct path or I can go via B to C and the total cost of the path here is 8 plus to 10, where is the direct path cost you 15. So, the idea is to find parts of the sky, for example, if is a path from A to C via something else which is so cheaper than the direct path, then we should find those parts which are lower in cost. So, the objective is of this algorithm is called a single source shortest path problem, the single node which is identified as source and you need to find the parts to from A to B, A to C, A to D and A to D, A to E such that the total cost of the path is minimized that is the length of the particular path. So, for example, if I am going from A to D, I can go A, B, C, D or I can do A, C, D and notice that 8 plus to 10 plus 3 13, whereas this is 15 plus 3, 18 therefore, this path is shorter from A to D than going from via C. Let us see how this algorithm works and then most importantly this algorithm assumes it is important for this algorithm to be able that no edge has a negative label. That is very important to assume and the algorithm uses, we already talked you already learnt about the greedy paradigm and the dynamic programming paradigm. Here this algorithm uses what is called a greedy paradigm as you already learnt greedy is what we make local decisions which are optimal, we do not worry about the global optimum, but interestingly what happens is in this algorithm even though the decisions are made locally, these also scale for the global case. So, even when you know all the notes. So, what we do is in this algorithm, we start off with a particular vertex A and say that I have what is called a source vertex list and a total vertex list. Then what I do is I initialize let me say these vertices are numbered in the particular algorithm 1, 2, 3, 4, 5. So, initially I say include the vertex A in the given list. In the algorithm for example, I have said s equal to 1 because I am using an integer here to map the vertex name to this. So, basically this is equal to 1 over here and then what we do is we try to find the shortest paths to all the other nodes. So, what we do is for this we do a very simple algorithm, we maintain what is called a distance matrix distance vector sorry and we maintain the distances to the other vertices. Let us say this is d c d and e. So, first we using the adjacency matrix that we have, we fill up this for example, this information is given. We assume that the graph is the first completely known the graph is static. So, what we do is we have the direct edges. So, I have from A to B the distances 8, A to C the direct distance is 15, A to B I do not have a direct path. So, I market as infinity and then A to E there is a direct path I market as 12. So, initially I make a distance vector like this. Then what we do is from the set of vertices we include in the set S the vertex that is closest to it. So, if you look at 8, 15, 12, 8 is the closest. So, what we do is to the vertex A in the directly connected edges. So, we include in the vertex list the list B and then what we do is we see whether there is a path to C that is y or B which is short and similarly I do this for the vertex D for the y or B and similarly we also look for vertex E y or B if there is a shorter path. So, what we do is if you look at it here. So, what is it that we have? We have a direct connection from A to C which is cost 15 and then 8 y or B to C is 10. Therefore, this is shorter. So, what we do is we update this path and call this 10 here and there is no path still from B y or B there is no path to D. So, we leave it as it is there is no path y or B to E. So, we leave it as it is. So, we have this updated matrix and interestingly the vertex B is part of the source list. Next what do we do? We again take the next vertex which is closest for example, with from A using this distance matrix. Then we find it I include C here and then from C now some some we remove it from the distance matrix. We know that the cost of the path from A to C is 10 is there a shorter path from C to D such that the distance from A to D can be minimized and that is obvious A to D our original distance was infinite A to C the distance A plus to 10 10 plus 3 13. Therefore, we update this distance to 13 there is no path to E so, we leave it as it is. Next what do we do? We choose the next vertex which is again closest to this list and then we get E over here E is smaller in distance from A. So, then we see if this there is a shorter path from A to D there is no other path here and now we are done. So, what do we have now finally, we include the vertex E to the source list. So, this is essentially what the algorithm is and now what do we have if you backtrack you can get all the distances from the vertex A to each one of these vertices. That is what this algorithm is trying to do if you notice V in V minus S it tries to keep updating this particular distance. So, once we have finally, your matrix D will contain the list of vertices with the list of the distances from the source vertex one or as in this case A to all the other vertices. The time complexity of this algorithm notice that if you look at this over here the cost of the to find the minimum over here it is going to take you order n and this is running n times therefore, the time complexity is about n squared for this algorithm you already seen complexity analysis sometime back and this can be much better to order E log n if the number of edges in the graph is much less than n squared with appropriate use of data structures and organization of graph for example, if you used an adjacency list representation and then organize the edges in an appropriate data structure you will find that the time complexity can be brought down to order E log n. So, this is the single source shortest path problem of Daikstra by the way I forgot to mention this algorithm is due to Daikstra one of the founding fathers of computer science it is not pronounced as digicstra it is pronounced as Daikstra basically he is Dutch and that is why this dyke st re ok. The pronunciation is this ij is pronounced as i in Dutch ok. So, this is the complexity of the algorithm it is most important to note is that the edges cannot have negative weight. Why do I say that because it is possible that once one so particular vertex has already been included into the graph let us say you know I had I had let me change this path over here and suppose I had included this vertex into my list and the let me this not a good idea see if it has this and there is a dc d here and let us say I already included e into this graph here at some point and at that time the problem is I cannot have negative edges because if you look at this issue over here as soon as the edge becomes negative that negative edge gets included much later let us say this is 8 plus 2 10 and this was let us say this was minus 10 over here and the let us say I had another vertex here c 2 let us say f which was 5 or something and then I could go back to b like this and so we have said that path length from a to b is a to over here and suppose this was minus 10 and I already included being the source vertex list therefore I am not going to consider it again but when you see here minus 10 plus 7 minus 3 right. So, it is possible that from c there is a shorter path to the vertex b suppose this was already there at 15 here and then let us say this was minus 10 plus 2 and I would have a shorter path to b via c and this is precisely why we cannot have negative edges on the given graph. So, 15 minus 10 is 5 5 plus 2 7 therefore you have a shorter path via b via c to b c and f to b whereas the original path that we have included is of length 8. So, this is the this why this algorithm only works with positive edges. Why is this algorithm important especially today in the day of networks for example, we have a dynamically changing network and for example, what called the cos b the cos could be cos of let us say in the example that I could take that I have taken it is possible that these cars this is i i t madras and you are going to central station and which is the cheaper path is what you are looking at this could be taking a taxi whereas this could be taking a let us know graph if you remember is taking a bus for that matter and whereas, in network today it is becoming very important because when you look at congestion that is there in the network you can model the congestion as a weightage or the graph it is a dynamically changing scenario and you are constantly looking for better paths to transfer packets from one node to another on the network ok. So, the next problem that I am going to take up is what is called the minimum spanning tree algorithm and if you notice here the idea is given a particular graph of this kind the objective is to find a tree which connects all the nodes in the graph of minimum cost again the cost could be congestion as in a network or the cost of a link for example, the here if I want to send something very fast then if this is a fiber optic link then the cost is very less and things like that. This algorithm is again based on the greedy paradigm and what do we do in this here the nodes are named 1 2 3 4 5 and 6. So, what we do is let say without loss of generality I can take any node as this source vertex let us say I am taking one as the node then what we do is we incremently keep on including we we basically partition the graph into 2 sets of nodes 1 set of nodes which have already been included in the spanning tree and other which have not been included into the spanning tree. So, what do I do I start with 1 and initially I at the lowest cost edge into the tree ok. Then what happens I have 1 and 3 in one part of the in the in the which correspond to the one corresponds to the tree edge and 1 and 3 are the nodes which connect this tree edge and they belong to one set then you have 2 5 6 and 4 which belong to the second set. Then what we do is given this 1 and 3 are connected I try to find from the original gaps which is the lowest cost edge which connects it to the rest of the graph. So, here you find it all 3 are 5 over here and this one is 6 from 1 to 2 the cost is 6 3 to 2 the cost is 5 3 to 4 the cost is 5 and therefore, the 3 to 6 the cost is 4 and 3 to 5 the cost is 6. So, what we do is amongst all these edges which connect 4 is the cheapest edge so we chose the 4 edge ok and now what happens you have 1 3 and 6 belonging to one set and 2 5 and 4 belonging to the other set. Now, once again what you do is you find out the lowest cost edge which will connect 1 3 and 6 to 2 5 and 4 which means this is the lowest what is the lowest cost that we have here notice this 1 3 and 6 have been connected right. Now, when you look at it here you find the low the 4 is connected 6 is connected to the vertex 4 with a weight of 2 6 is connected to 5 with a weight of 4 weight of 6 and 3 is connected to 2 with 5 3 is connected to 4 with 5 and 1 is connected to 2 with 6 therefore, this is the lowest cost edge. So, we take this lowest cost edge in and finally, let me choose this last vertex to be connected once all the vertices are exhausted your the algorithm is done this algorithm is what is due to print and ideas initially what we do we have 2 sets of vertices use a set of vertices you and v is a vertex t is an empty set initially use initialize to 1 and while v is let us say the original vertex set of the graph until all the vertices have been included in that u list you exhaust every one of them. So, what are we doing now if v is original vertex set that is given while we be used not equal to v let u v be the lowest cost edge such that use in u and v is in v minus u then you make a tree with t union u come away then you include v into the u list just like we did over here we started with 1 we included 3 and repeat this process until all the vertices are included in the u edge list in u vertex list which is the same as v now the time complexity of prime algorithm is also order n squared but if you use a priority q with when e is much much less than n squared and a appropriate data structure for representing the graph you can get a better algorithm of order e log e where is the number of edges in the graph.