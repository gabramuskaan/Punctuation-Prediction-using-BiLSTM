 Welcome to this online course on programming. I am Shankar Balachandran from the Computer Science Engineering Department at IIT Madras. This course is designed in such a way that it can be spread across five weeks and you are going to have about two lectures every week. So, a total of 10 lectures and this course is designed also designed in such a way that you can take this in 15 minute chunks called modules and you would be given a small practice test right after every module. So, let us jump right into the course. So, before getting into programming we need to understand a little bit of what computers are about. What you are seeing in this picture here is Eniac the so called first digital computer which was built in the 1940s and you can see how huge it is. It is almost like house in size. It was massive compared to the modern personal computer standards by no means Eniac can be called a personal computer. It had 17,000 vacuum tubes, 5 million joints, hands-holded joints, it weighed quite a bit and it used to consume 150 kilowatts of power. No way this would be a personal computer. However, zoom to 2000 what you are seeing in this picture is a micro photograph of Pentium 4 and it was designed in the year 2000 and deployed in the market. It could run at 1.5 gigahertz that means it can do 1.5 billion operations per second. It had 42 million transistors as opposed to this puny Eniac and it was built in this technology called 0.18 micron technology which means the transistors and the gates that were used to design are as small as 0.18 micron. So, in the 40 or 50 years computers have moved quite far away from the first notion of digital computer. In this picture you can see Google's data center. It is one of the data centers that they have across the world and what you are seeing is racks and racks of machines crunching data, running algorithms and running programs various kinds of software that we use on a daily basis and this is just one of their data centers and this requires enormous organization of the equipment power systems, cooling systems and so forth. But all of this is basically a computing machine. All we see in the Pentium 4 or these data centers are all built of what are called computing machines and the basic abstraction is what we see here. We have a processor and we have memory and this is what makes any computer. You have a processor and memory. You can think of the memory as a series of locations to store information. Let us say for example, we have 256 megabytes of RAM and you would be laid out in some in some order and you can address them as location 0 location 1. So, 1 up to 256 megabytes just like how your houses would be numbered in a if they were all lined up in a line and processor is the heart or the brain of the computing system. So, typically memory is divided into two portions. There is some portion dedicated for programs and some portion dedicated for data. A program is essentially a sequence of instructions as able to do some task. So, it could be a game, it could be a piece of software that you write for this course, it could be a search engine, it could be a browser, it could be anything and most of these instructions actually operate on data and the data is something that you store in the memory as well. There are instructions which could also control the flow of operations. It is not that all the programs have what is called a straight line sequence, they do task a task, we task c and so on up to land. Based on the conditions that come through some branch operations could happen and because of which the control could change. We will see these in more details later anyway. But the basic setup behind a processor is given in this picture here. We have an input system, the input system could be a keyboard, a mouse or any other device. You have an output system, this could be a monitor, some gears that are shifting, it depends on the computer that you are building and most systems have a reasonable amount of memory. Nowadays you probably have two gigabytes or four gigabytes of RAM on your desktop and laptops. There is the central processing unit, the central processing unit consists of two things. One is called the control unit, the other one is called the ALU or the arithmetic and logic unit. Arithmetic and logic unit is it consists of various circuitry or it can do things like additions, subtractions, comparisons and so on. And control unit in some sense is the overall master. So, it controls what happens in each of these units and how data gets processed in each of these units and when data moves in, when data moves out and so on. So, let us look at the basic operations of a CPU. CPU can fetch an instruction from memory, it can execute the instruction based on whatever instruction is given to it, it can actually execute it. This could be addition, subtraction, multiplication, comparison, it could be anything. It can also store the result back in memory. So, when you write a program, it is going to be translated into sequence of instructions and a basic machine instruction would have this following setup. You have an operation, you have all the operands or the data on which the operation is going to be done and where is the result going to be stored, also called the destination. A simple operation could be of this kind, add a comma b, it adds the contents of memory locations a and b and it could be storing the result back in a itself. So, sometimes you may, somewhere down the line, you may learn a language called the assembly language and we are seeing some small example here. An x 8 6 Intel 32 processor can execute the following binary instruction. So, you have 1011400114001, this is a binary code for moving 61 in hexadecimal to an internal memory called a register of the name AL. So, AL is a register which is an internal memory inside the CPU. So, the meaning of this instruction is move number 61 in hexadecimal to AL and this is something that you and I may not know, you and I may not even understand if you are just given the binary, binary bits. However, for the CPU, everything is translated into these bits. Operating in these bits at this level is very, very hard for us humans. Therefore, we use so called high level languages, but sometimes you also have this intermediate language called the assembly language which is a human understandable, but at the same time it is more detailed. For example, we have MVI AL comma value. So, this could mean move the value to AL and such instructions are called mnemonics. So, mnemonics are essentially easy to remember and this binary sequence, we could write them as MVI AL comma value. This could be given to an assembler which would translate that into this binary code. But even operating at this assembly level is quite hard. This does not capture the kind of problems that we want to solve directly. They get too detailed. Instead, we used so called high level languages and a single high level statement could have more than one assembly instruction in it. So, let us take a small example. Let us say I want to add z to y and the result has to be stored in x. So, I would write this as x equals y plus z and it could require the following sequence of operations. You may have to fetch y from the memory, store it in an internal memory location or a register called r1. You fetch z also from the memory, you store it in another register called r2 and the AL you would then add r1 and r2 store the result back in r1 itself and it may require a move from r1 to the memory location named x. So, a single operation x equals y plus z has resulted in four smaller operations and these operations could be written in assembly language if you would like to. However, this becomes too tedious. So, we would like to operate at a level which is much higher than what the processor can understand and something that is easier for the human beings to program with and that is how the evolution of high level languages started and in this course, we are going to learn one such high level language namely C. Once you have a high level, once you have a program written in high level and you need a set of tools to convert them into the machine level and typically the programs that we write are called source code. They are called source because that captures the intention of the programmer and a set of tools will convert the source code into machine code. You may have more than one such source program available and you give this to a tool called a compiler. The compiler is essentially a piece of software which can convert this high level code into assembly code and in turn an assembler can take this assembly code and generate machine code. At runtime, you have a linker and a loader which will actually execute the program. Even if you do not understand these details now slowly and steadily we will build up an understanding towards all these ideas. We will also see software demonstrated along the way. So, as of now just remember that you have a high level program which gets converted by a compiler into assembly code and assembly code downwards is taken care by assembler, linker and loader. What we bother about is at the high level namely the high level language. So, when we write programs we are actually looking at solutions. We are trying to solve things. From the CPU's perspective a program is nothing but a sequence of instructions. You have instruction 1, 2, 3, 4 instruction 5 could be a condition based on whatever the result of instruction 5 is. You may execute instruction 6 or instruction 10 and so on. However, this is not the way we think about solving a problem. For us a program is a solution to a problem and sometimes it is a frozen solution. By frozen what we mean is we have written the program it is already compiled and it is ready to execute and at this time the solution is frozen. You cannot change the solution unless you go and change the program and compile it once more. So, from the perspective of a human being a program is the representation of a solution device by a human being and the nice thing about a program is that it can be compiled and stored and it is ready for execution from there on. You can also distribute the programs to others for them to read, understand or even comment and change. You could distribute the machine version or machine code for others to execute but not be able to see the program. You can do lots of things and you write the program once you can run the program as many times as you want. Let us get into what programming is about. A program is essentially a piece of software that you write and programming however is problem solving. This is what we really want to do. In this course we will learn how to solve problems but in the process we will also learn this language called C with which we can take problems, break them down and write them using a program use tools to compile and run them. We will learn this whole cycle. Any software development process starts with understanding the problem. You should first of all understand what the problem is. Typically the problem is stated in English. So that is called requirements analysis. From there you get a precise specification of the problem usually mathematically specified and you devise the solution. So given a problem you go and devise the solution or design the solution and once you have the design for the problem then you go and write it in a program. You could write it in any program programming language. This is also called coding and finally once the coding is done we have to test it before we deploy it. So we start with requirements analysis and get the specifications out. Design the solution for the problem. Go and model it and program it using a language. Compile it, run it and test it before it is ready for use. However the most crucial part of this whole process is actually the solution design. So you have to solve the problem and analyze the steps and ensure that this problem is captured properly and you have a solution that is indeed correct. Any ambiguity in the specification can result in program that does not behave as expected. So you have to be careful about understanding the specification. You should also understand the nuances of the programming language itself so that the intent is captured carefully and you use a programming language for that. Finally you test it. So as I mentioned earlier we are going to use this language called C. C is a very old language. It has been there for almost 4 decades now very widely used in the industry even now. Even now. So there are other languages like C++ and Java and so on. However learning C well and understanding C thoroughly is a basic requirement in the industry even now. C is a general purpose language. It is not for any specialized purpose unlike a language like HTML and so on. It is extremely effective and expressive. You will see this in a short while. It has a finally compact syntax. The language is not too big. It has a rich set of operators pretty much every arithmetic logic operation that you think about is already available as an operator. C also has an extensive collection of libraries. So you do not have to really write every single thing down. You can call library functions whenever you need them and C comes with a rich set of libraries and that is one of the basic reasons why we pick C. Let us look at a tiny C program. So you may not understand it right away but it is really tiny. It has only six lines of code. The first line is actually a comment. It says a first program in C and the next line says hash include stdi.h. There is this so-called function by name main and there is exactly one statement inside this main. So watch the most pointer. We have a function called main and within the braces we have a single statement called printf and printf seems to be taking this hollow world. So this has been a custom for a while now. Almost every programming language book that you go to will teach you how to printf hollow world. So let us see or let us break down what this program is about. So as I mentioned the first line is just a comment. It is for us to understand it does not really result in anything that is executable. So the program has it but the machine code will not have these comments. It is not an instruction for the CPU to do anything. It is just for us to understand and let us look at the next line. It says hash include it means include something which is already built. I mentioned earlier that C has several library calls that you can make and stdi.h is one such library with which you can do standard input and output. So if I want to type something on a keyboard and if I want to see something on a screen that is what you get from stdi.h. Every C program will have something called a main function and the very first instruction that is executed will be from main. And within this body of these curly braces you have a single statement here called printf. You can see that this printf is a function. We will see what a function is in more detail later. It seems to take an argument or a parameter. So you can say printf hollow world and it will printf hollow world on the screen. You can say print hollow your name it will print hollow and your name on the screen and so on. But every statement is terminated with a semicolon and the body of the function is usually within the braces. So this is a fairly simple program. If we compile it and run it it will print hollow world on the screen. So with this we are at the end of module 1. In the next module we will see how we will take a small problem and we will see how to solve the problem and we will also see how to write it as a program.