 In the last class, we looked at the list ADT and we talked about a generic list ADT where we said insert any element anywhere and then we talked about two other flavors of the list ADT. One is the stack, the last in first out and the other is the phi 4 which is the first in first out or the q ADT. Now the generic list ADT, what it consists of? It consists of a sequence of items. So, it had a set of elements and if you want you could have completely an ordered set of items as a generic list or in the last in first out of the stack ADT, you had a particular flavor where you said you could only insert at the top and delete from the top and in the first in first out, this is the q ADT, we inserted at the end and we deleted from the first. So, it is like you know, when you look at the generic ADT, it is like a vanilla is cream when you know, whereas the stack ADT is like chocolate and if you like chocolate, then it is like chocolate ADT which does something very special and on the list ADT. And the first in first out is perhaps like butter scotch which does something else special. So, depending upon what you like, I know these are some of the most favored flavors in ice creams. So, it is something like that. So, either a stack or a q still qualifies as a generic list. Now, there is one problem with the stack or the q and the problem is the following. What we see is that whether directly or indirectly, there is some kind of ordering in the list. The items either are pushed onto the stack and popped from the stack in one end or they are you know, pushed at one end removed from the other end as in the q ADT. Now, today what I want to talk about is, let us say I want to represent the family tree. Suppose, I want to represent my family tree, let us say a is a parent has a p a set of children. Let me say that p are the parents does not matter with the mother or father and let us say you have four children and these are your siblings. Now, let us clearly the older generation and this generation now for example, generally has the generation one above you guys has had perhaps only two children, f and so on. And suppose you want to find out who is the grandparent of whom and so on. Then if you want to traverse, if you had to represented all of this using a list, then the problem would have been, this would have been number one in your list two, three, four, five, six, seven, eight, nine assuming that six came after five. You have put them in this particular list and you have access an element at 10, let us say or to access the element, the element for that matter, you have to go to the end of the list. So, this would have, but at the same time the reason why I am talking about this is when I am using a list to represent something like this, then the what kind of a list will I use, I will use a generic list because there is nothing like when you look at siblings for example, there is nothing like a priority of one sibling over the other, but just the representation by itself, because whoever came first you put them in and so on and so forth. You know deletion for example, somebody dies in the family, it can happen at any point in the list and almost all operations will become very expensive because you have to traverse mostly the entire list. So, the idea is can we can we represent these kind of structures in a better way. So, one of the most popular representations, what do we want from this, if I want to access the node corresponding to j, then I would like some information right, what would I like to say, I want to look at the then I would like j to say who is his or her parent, who is this one's parent, who is this one's parent, if I want to find the G lineage of j. So, how easy or how difficult is this depends upon the kind of representation that we are going to use. So, a tree is a tree data structure kind of suits this kind of data very well. So, what we are going to talk about is, we are going to talk about a general tree something like this and then as I already said the major objective is to be able to traverse this particular tree, see if a particular element is present in the tree based on certain criteria that can be satisfied and so on. We will come back after we do all this to the general tree, but this is in general tree. Now, representation of the tree can be done in a number of ways, you can use an array representation in the or you can use what is called any general tree is represented by what is called the left most child right symbol representation. What this means is P A B C D is the representation for this and this is represented like this and we have I B C D E B C D E B C D E B C D E B E which is represented like this, sorry this has two children F and this one has a left most child J. I will explain in a minute what this representation is all about. So, what is done is notice that we take this particular tree over here and convert it to this format. What would I do if I was representing an array? I would say here 0, this is P, let us say this is this node corresponds to P and I will keep some information 0 over here. Then the indices go from 1 to 2, I would say A comma 1, B comma 1, C comma 1, D comma 1 and I would say E comma 2, F comma 2, F comma 2, F comma 2, F comma 2, F comma 2, F comma 3, I will tell you in a minute what I am representing over here, H comma 3 and I comma 6 and J comma 7. What I am storing here if I am this is an array implementation and this is a linked list implementation. What is a linked list now? It is a recursive state structure. What is the problem with the tree? If I want to represent the tree then using a linked list then at every node I must be able to say if I was representing it by saying that node has some max number of pointers n. To avoid that I could have a list of elements on the other hand that is exactly what we are doing here. See we look at it over here, what is it that we are doing? We are saying here P is a root node and it has children A B C D. Let us say A is the leftmost child or the oldest child then to make our representation more convenient if this is the root node within that it has a pointer to the leftmost child which who is right sibling point to all the other nodes. Similarly it will also have a pointer to its leftmost child so the tree is like this. The pointers are all pointing forward. On the other hand the array implementation why are we doing this? Because I said one of the fundamental problems is we want parent information or from the parent I would like to go to the child. One of these two information is required. So if you look at this the array implementation on the other hand what do we do? We say that I store the parent in this particular let us say let me call it the index of the node is 1 2 3 4 5 6 7 8 9 10 and 11. Suppose I was storing it in an array. Then what we do is we store a pointer to the nodes parent and now I have put the index 0. Index 0 means what? This particular node is the root node. Next what I do is the element A. Now element A is stored here and who is its parent? Its parent is P whose index is 1. Similarly the node B is stored in index 3 and its parent is in node 1 and I keep that index. Now for C what happens? C A B C D is like that. When I come to E what do I do? I keep the index of its parent which is 2 because A is the parent of E therefore I store E and 2 over here. Similarly for F what do I do? I store F and 2 over here because for F the parent is again A. So you repeat like this and you can get use the array representation for any general tree. In the linked list representation this representation is basically this is array representation where we use pointers to the parent to parent in every node. On the other hand in the linked list representation what does every node have? Every node has a pointer to its left most child and the right sibling. So notice that P is the parent right is the root of this particular tree. Therefore it has only pointer to its left most child. Its right sibling is pointing into null because the root has no siblings. And here what is it that is happening here? A is the left most child and it is pointing to the its right sibling, this is right sibling, this is right sibling. This is the right barber left most child, right sibling martyrs Moto right msoft child, right sibling left msoft child, right sibling, left noibh So, what I have done now in all the arrows now I have put the which corresponds to the point of which corresponds to that of the leftmost child and right sibling for the RS. So, we make these pointers like this. Now, that means what is nice about the structure in every node we are having only two pointers the leftmost child and the right sibling. But so basically you have two pointers in every node, but you are able to represent any general tree. Now, this tree is useful if you want to look at any arbitrary tree. For the time being we will kind of postpone this and we will talk about this a little later, but remember that this is one such representation of a tree. What is the meaning of the leftmost child? Leftmost child is molded sibling and right, the right sibling corresponds to it next sibling at that particular level. We will come back to this tree a little later where we have either array representation or this. What we will look at is we will look at some special trees today in particular we will look at the binary tree. What is the binary tree now? Here is an example where we have the root and it also has two pointers one to the left child and the right child. There is no hierarchy here that is the fundamental difference. It is similar to this where you have a node has two pointers leftmost child and right sibling. The difference between the binary tree node and the general tree node is that the left child and right child there is no hierarchy. What do we mean by that? Here a points to be to a node at the same level whereas the leftmost child points to a node at the one level lower. So, basically what we are talking about here is one level higher sorry or here in the other hand we are saying leftmost child and right child left child and right child are at the same level. Now, what are the use of such trees we will see in a minute. Now, how do you define a binary tree? A binary tree is defined like this. What is it? It is a finite set of nodes that is either empty or consists of a root and two disjoint binary trees called the left and right sub trees. What is it telling me that this is a binary tree? It can also be empty and it has left and right sub trees which are again binary trees. Again going back to this example if you started from this node this is a tree still and this is also a tree. This is also a tree that has only one node. But basically what we are saying is every at every level the same structure follows again from every node leftmost child right subling. That is what we said. Similarly, in the binary tree here also every node can have optionally two sub trees it can also have one of the sub trees or it need not have any sub tree at all. If it does not have the root even an empty tree is a binary tree. So, this is a skewed binary tree the picture is given here in the slide skewed means skewed to the left and then I have drawn another binary tree just called a full binary tree the nodes are full like this. Then you also have another variant of it called the complete binary tree. We will come back to this what we mean by this is when you fill this tree for example, notice that I have filled the nodes at the first level nodes at the second level nodes at third level when I am filling them I go from left to right. This is a complete binary tree while this one is not. This one is not a complete binary tree while it is mirror image this is a complete binary tree. Such binary trees have lot of applications in building what are called priority cubes we will talk about that little data. Now first let us see why do we want a binary tree in the first place and is there any use of this and what are the operations that you will perform on a binary tree. So, you need something so what is it that we do these are the so now what is the binary tree now the binary tree is also an abstract data type like we saw the stacks, queues and lists or lists, queues and stacks and so we have the binary tree a d t and abstract data type. Therefore, you have a representation the reference says there is a root node and the left child and a right child that is the representation. binary tree node so essentially a recursive data structure and then you have operations which can be performed and what are the operations that you perform because a rad t is like a mathematical model and we perform various operations on it. So, what do you want to do you want to create a binary tree first create an empty binary tree or create a binary tree with a particular node because you have to start from somewhere then you want to find left child or right child or right sub tree then you want to find a parent of a given node and right child left child or tree talked about and of course, we need a create empty tree always that is required parent and not always sometimes they ask for the root of a tree. So, creation of empty tree tree and sometimes get root this is not good to have but since some of the books talk about it I kept this particular operation because get root if you have it tells you what the implementation of the binary tree is. So, now what we will do is we will take one application there lots of applications of binary trees can represent sets can do half-man coding you can represent heaps and dictionaries