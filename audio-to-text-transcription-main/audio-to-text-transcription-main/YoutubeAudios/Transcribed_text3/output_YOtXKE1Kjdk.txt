 There are many other applications like constructing the expression tree from the post order expression. I will leave you with an idea as to how to go over it. Suppose, I have A, B, C plus and star, what we do is, when we have symbols, first we have again a forest of trees, pointing to A, this pointing to B, this point, as you traverse from the left to right of this expression, as you move from left to right of this expression, what you do, you just create pointers to trees in a forest. Then, what you do is, you come across plus, then you create a new node with plus and then you take the topmost two, it is like a stack, this is actually like a stack, then you, this is actually a stack of trees, what we do is, now I put this from left to right, I put the trees, A, B, and C and then as you come across the operator, what do I do, I pop the most recent two trees, then I create a new tree with a plus and I make the first tree, the left child, the most recently popped out tree, the left child and the previously popped out tree, the right child. Now, again I have one more symbol left, I come across the star, so I pop out these trees and I create, put on to the stack, the star and the two popped trees become the, the most recently popped tree becomes the right child and the most recently popped tree becomes the left and the previously popped tree becomes the right child and as soon as until you get a single tree which exists on the stack. So, there is another application of binary trees and stacks, both of them can be used quite efficiently to build what are called expression trees. So, this is a very, very useful application of binary trees, now there is another thing that we always like to do when we build binary trees, let us take this expression tree itself, let us to cut an expression, let say we have something like this, then we have what are we doing when an expression is evaluated, it is evaluated from the left. So, let say I have this, here plus star, we see actually you go over this from the right and let me, let say I form an expression tree, I do not know how many of you are familiar, we use this kind of a expression parsing to do this expression term or expression and term is factor or factor and let say factor is a name as in this example, what is name let say this a b so on over here. Suppose I use this grammar, let say factor is a name as in this example, what is name let say this a b so on over here. Suppose I use this grammar to generate this expression, you have already done a course on compilance, let see this is completely an unambiguous grammar, the add of here is plus or minus, melt off is star or slash let say. So, how do we parse this given expression, so start from the root over here, expression is defined as expression add operator term, so I stop it, start it over here plus then what do we have, then on the left hand side, another plus again at the plus, then I will get a here, I will get star b c and star d plus e f, this is how you will get a binary tree, what have I done now all this exercise that I have done is to this show that an expression, harmless expression that is written like this can be written as a binary tree. Now, what we will do is we will talk about other things now, we will talk about traversal of these trees of this tree, let say what it gives us, there are three types of traversals, pre order, post order and in order, okay. Now, the definitions are given over here, how to traverse these trees, so pre order traversals says visit the root, then what do you do, you visit the left child in pre order recursively, visit the right child in pre order recursively means what now, let us take the, then the in order traversals says visit the left child in in order recursively, visit the root, visit the right child in in order recursively, okay. Then post order traversals says visit the left child in post order and visit the right child in post order recursively visit the root, okay. Alright, let us see what this gives, so everything has to be done recursively, what is the meaning of this, okay, let us look at in order traversal, visit the left child in in order recursively, okay. Let us say I want to do this traversal of the tree, okay, traversal means simply walking around the tree, okay. That is the way the list of notes is what changes. Now, what does it say, let us look at in order traversal, it says first we look at in order because it will become clear to you what we are doing, visit left child recursively, visit root and visit right child recursively is what you are in order traversal, so let us look at the tree what would we do, that means I am starting from the root here and I am going to recursively keep on going down to this until I reach the leaf note. Then what do we do, so let us look at the tree what would we do, so that means I am starting from the root here and I am going to recursively keep on going down to this until I reach the leaf note. Then what do I do, I display the leaf note, so I keep going down because I have to visit the left most children, then what happens I go up, okay, then I visit the root and get plus, then again I go to the right child and again after recursively do the same thing, that means what free order in order all these are recursive traversals, okay, so I go to the right child, then again I will do left child recursively root, then then right child and then go back up, then what happens here, so I come down this plus go down here, this becomes B star C, okay and then what happens, this is node has already been visited, so I go back up to the root of the tree, give me plus, then again I come to the right node star, again I have to do recursively left child, right, so I do D, I come to the leaf node star, then I have to have E plus F, the bracket has to come because it is one level lower, so in order traversal essentially gives me the expression back, so what does it tell me now, when I look at the in order traversal of the tree I get the infix expression of the given tree, okay, there is one extra information that we have used here, we use the fact that star is done after plus because it is one level lower in the tree, okay, so I get the infix expression, so let us look at what post order expression, post order traversal of the tree will give you, what does post order traversal say, post order traversal say, visit left child post order, post order recursively, then visit right child in post order recursively, visit root and the same thing keeps on getting repeated again and again, so I take the left child recursively visit in post order, let me just explain this over here, let us see what this will give us, what does it give you, so I visit the left child, I come came down there are no more leaf nodes, so I display A, then I have to go to the right child, go back, right, left child, right child and then root is what it is, go to the right child, then right child again I have to recursively go down do post order, right left child, right child, then root, so what will happen, I get A, B, C, star, then what do I get, now all of them have been visited, I go back up, so left child, right child, then root, plus here and then what happens, so the left child of this root tree is completed, now so I go to the right tree over here, then what do I get now, what do I get here, now I get D, then again this is the left child is the leaf node, there is nothing else to see, therefore I display the leaf node, then I go to its right child, again I have to look at post order over there, therefore I get E F plus, because E left child post order, right child post order root, then I put the plus over here, that is how it comes here and then finally the star and then finally the plus, the last plus sign, let me have, sorry, may be mistake here, this plus should not be here, see A, B, C, star, then I have to do the right child, D, F plus star plus, so what did we get now, we got A, B, C, star plus correct, D, E, F correct, sorry, plus is there, correct, D, F plus star plus, how many are there, 1, 2, 1, 2, 1, 2, 1, 3, correct, so this is what we get as the expression, what is this expression now, this is nothing but the post fix expression, which all of us have already been done, where we talked about stacked, we talked about generating a post fix expression from an infix expression, so what is interesting here is, once it is represented as a binary tree, if I do in order to the traversal, I get the infix expression, where I do post order traversal, I get the post fix expression and obviously if I do pre order traversal, I will get the prefix expression, so this is also a very big application of binary trees, now once this expression is given like this, I can use this stack of trees to evaluate this particular expression, so I hope you are with me here and you have understood what I have said, so what is it that we are doing, notice that, another way of looking at these various traversals, to make it simpler is pre order traversal can be thought of as, you display the node the first time you visited, in order traversal you display the node the second time you visited, remember I have drawn this path over here, which goes around the tree and in post order traversal, you display the node the last time you visited, so these are simple traversal schemes, so now the next question that we would like to ask is, suppose you are given only the traversals, only the traversals are given, can we construct the tree exactly, let us look at only with respect to binary trees and see if I am given the, what is it that we have, you have two traversals now, in order traversal and we have the post order traversal, we can also do the pre order, I encourage you to do the pre order traversal of the tree, now given the in order traversal can I construct the tree uniquely, without any other information and given the post order traversal can I construct the tree uniquely, let us see how we will do this in the next lecture.