 Hello, welcome to this module on C++. I promised earlier that we will see a quick introduction to C++ and this material is done in such a way that it will give you just enough material to understand what is happening in the rest of the course. So, I will start with a disclaimer, this module is not a complete treatment on C++. C++ is a vast ocean and this next 15 or 20 minutes is not going to give enough justice to C++. So, it is not a complete exhaustive treatment of C++. Also do not expect a lot of object oriented programming skills to be learnt in this 15 minute module. There is going to be just enough material to appreciate the syntax of C++ and by no means it is complete. So, the basic material is based on true strips slides. So, he teaches this course on C++ and he is actually the inventor of C++. So, in some sense this is from the horse's mouth. So, let us look at the notion of classes and objects. So, if you are in slightly senior year in your class in the second year or 30 or maybe you have done some C++ programming. So, the notion of classes and objects are probably familiar to you, but I am not going to assume anything like that. So, I am going to assume that you do not know what classes and objects are. Let us start with this basic declaration called int x. We can think of int as a class. So, it is a basic data type and the moment you say something is int or an integer, you know that there are certain operations that you can do on it and there are certain properties of integers. So, for example integers can have only values like 1, 2, 3, 0, minus 1, minus 2, minus 3 and so on. You cannot have a valid value 1.6. So, we know some of these properties about int. So, anytime when you have something called a class, you know that there are certain types. So, there are certain properties of a class and there are only certain operations that you can do on the data type. So, for the basic data types, the language itself tells you that these are the basic set of values that you can take and these are the valid operations that you can do. So, that is the notion of a class. Here, if you look at x, x is actually an object. So, what we mean by an object is it is not something abstract when I say integer right, when I say int and I am describing only the properties that int integers have and the operations. Only when I say int x, we get a location allocated to it and on this location, we can do various operations. So, the operations of whatever on x, whatever operations are allowed or only those operations that are allowed on integers. So, x is an object of the type integer. So, the class name is int and the object name is x. I can have more objects of the same type. So, for example, when I say int y, y is another object of the same type integer. So, at some level, you can think of types as classes and actual variables are objects. So, here y is another object of the data type integer. So, this is all okay for basic data types. So, for basic data types, you really do not need classes and objects. This distinction is not really necessary because the language itself gives you all of that. So, the notion of operations that you do on integers and so on also already given by the language. Whereas, if you have a user defined data type, then it becomes useful and necessary to define what is allowed and what is not allowed and to define what operations can be done. So, let us look at the basic idea of classes. A class is actually a user defined data type that specifies how objects of its type can be created and used. How do you create an object of a certain class and how to use it is described in the class. So, it directly represents some kind of a concept in a program. So, whenever you think of it, so it is it so this notion of a it as an entity, it is possible that it is a class or it is an object. So, let us see things like this. So, I have the notion of a vector, a matrix, a string and so on. So, these are probably classes. Whereas, I have a matrix which contains all my students names and let us say records, their marks and so on, then that is a specific object. I may have a matrix which contains all these integers and I want to do multiplication of integers and so on. That is also a matrix, but it is a matrix of integers. So, the objects are of a particular class. So, it is a physical entity or it is a abstract notion and C++ gives you this basic notion of create defining classes. You can define what the basic data structure is or the data type is and you can also have instances of that particular data type and classes form the basic building block for building a large scale program. So, let us take a small example here. We have class x followed by left and right flower braces and a semicolon and we are going to put in data members and function members inside this. So, the data members are supposed to store the information and the function members are supposed to tell you how to manipulate the data members. So, this resembles how you did it for structures. So, there also we had something called struct type x and followed by braces and we had members inside. Only difference is that we not only have data members here, we also have function members. So, let us see a small example here class x and class x has int m which is a data member and int mf of int v which is a function or a method. So, we have a basic data type inside it and we have a method inside it. So, that is a class. So, x has x is a class and it has a variable m or the member m and it has a function mf. So, this function mf is supposed to take an integer v and it takes the value of v puts it in m, but the old value that was there before the old value that was there before the function is called is supposed to be returned. So, that is the functions member. So, this is something called get and set. So, you are getting the previous value which is stored, but you are also setting it to the new value that you supply. So, v is the new value that you supply and the old value of m is supposed to be retrieved. So, let us say that is the class description. We will get to this notion of public in a little while. So, let us see how this class can be used. We have x bar. So, remember x is a data type. So, instead of class x bar which we did for structures, wherever we had structures we said struct x and so on. For classes you do not have to do that in c plus plus. x bar so, where is an object of the type x or the class x. Now, if you want to access the member m in it, we can say where dot m. So, this is just like the structure. We saw this before where dot m is 7 will change the data member to 7. Interestingly you can do something like this. We can do where dot m f of 9. What this will do is, we will take the value 9 and supply that to this class. So, if the previous value that you contain is 7, you will get this small case x to be the value 7, but you set it to 9. So, here if you go and print where dot m after this line, this would have the value 9. So, basically the nice thing about this class is that we have the members access with dot m, the methods are also access with dot. So, both the methods and the data members are access using dot operator. So, now let us go and look at what is this notion of public versus private. So, again if you are exposed to c plus plus you probably know this already, but in c plus plus you can have members and functions that are of two types, public or private. So, if it is public these members can be accessed by anyone outside whereas, if it is private then both if a member is private only the classes methods can access it. If a function is private, only this function cannot be called from outside. So, private members are supposed to have implementation details that are hidden from the outside world and public methods and members are directly accessible from the outside world. We will see specific examples in a little while. So, what is the difference between struct and the class? So, let us see class x, let us say I put int m f by default all members are private in a class. So, if I did something like this class x int m f, it means that m f is a method that you cannot call from outside. So, let us say I did class x object x and y is x dot m f, this would be invalid because m f is a private method it cannot be called from the external world. Whereas, if this had been a structure struct x int m by default that means, it is actually equivalent to a class x with m being a public variable and structs are primarily used for data structures where the members can take any value. Whereas, you use classes whenever you want something hidden from the programmer. So, the programmer should get clean interfaces like insert delete and so on and whatever manipulation is happening internally need not be exposed to the programmer. So, let us see a small example which explain this in a little more detail. Let us say I have a struct called date which has year month and day and I have date my birthday. So, let us say it is tracking a birthday. If you do this there is nothing which will stop you from writing something like this my birthday dot y is 12, my birthday dot m is 30, my birthday dot d is 19, 19, 150. So, if you look at the right side they are all integers and the left side data types are all integers. So, you are setting y to 12 m to 30 and d to 1 9 5 0. So, as 3 separate integers use assign 3 separate values which is all ok, but there is a problem. If you go and deal with this as a date there is a small problem. You are looking at year 12 maybe it is 12 AD but the month is 30 and the day is 19 5 0 this does not make sense. So, maybe it was a mistake it should have been year 1950 and day must have been 30 and probably the month must have been 12 where we are talking about 30th December 1950 right. So, maybe it was a mistake, but if you have a structure from the outside by mistake if you do this there is nothing which will stop you from doing it. Whereas, if it is a class then I can put some check and protect invalid values from not being taken. So, let us look at some other additional things right. Let us say I want to initialize the day I have y m and d which are passed as 3 integers and I want to set up this dd which is a pointer to the date data type. So, I want dd's y m and d to be the values y m and d that are passed on. So, maybe I want to function like this initialize the members of this structure to certain values or I may want to add a certain number of days to the type. So, let us say the current date is 30th December 1950 and I want to add 2 days to it and move to January 1 1951. Let us say I want to do that I should be able to do it add a few days and have a mechanism by which I not only recognize that 2 days from 30th December is not 30 second December. In fact, it is not even in December it is in January and it is not even in January of this year it is actually moving to the next year. So, if I add 2 days to 30th December 1950 internally I want this to automatically move to January 1 1951. In fact, I may want to handle cases like leap year and so on also appropriately. All these details I do not want to expose it to the programmer. So, this becomes very cumbersome all I want to give to the programmers add day as an interface with structures it is not easily doable because you can always come and manipulate these values without going through these methods you may go and increment d directly without realizing that the tuple d comma m comma y is not valid you may do that. But if you are forced to go through add day as a function always then add day can be implemented in a much cleaner way and all the errors can be checked and the function can be implemented so that it is always correct. So, let us look at this small example I have int y comma m comma d I always want some valid value for the dates. So, I want what is called a constructor. So, any time this object called date is going to be created it has to be supplied valid values otherwise it would be incorrect and I want to be supporting add day. So, even though it is given with struck date this is not valid syntax. So, we would want class date here and class date will have 3 members y m and d and it will have 2 methods date which will take the 3 initial values and add days which will add the certain number of days to the current date. So, the moment you do this if you do date my birthday this would be incorrect because it is not initialized. If you do date my birthday of 12 comma 30 comma 1950 the year is 12 the month is 30 and days 1950 add day can be written in such a way that this can be recognized as an error and this can be indicated. However, if you do date my day of 1950 comma 12 comma 30 this would be recognized as a valid day and later if I do my birthday dot add day of 2 the birthday moves from 30 December 1952 first January 1951. So, this is clean however if I do my birthday dot m is 14 this would be invalid because you are accessing the member m directly and this is not correct. So, if you do classes the way to do that is you have y m and d as private and you have the all the methods as public. So, date is public add day will actually change the contents of y m and d and we have 3 methods called month day and year and these 3 methods actually return the current month the current day and current year. So, these 3 methods give you only read access to the data date is supposed to give write access you can change the contents of y m and d and add day can also change the contents of y m and d. So, date my birthday of 1950 12 30 will change y m and d to be these 3 values and I can do print F percentage d my birthday dot month and my birthday dot month is a method if you go and look at that method it returns m and what is the value of m it is supposed to be 12. So, it will print 12 here however if I do my birthday dot m is 14 the compiler will catch it even when you compile it the compiler will catch it and say that m is a private attribute it cannot be manipulated directly. So, if you want to manipulate m you can either go and create a new variable and access through it or you can only add days to it you cannot manipulate it directly. So, the notion of a valid date is a very important special case and you want to do this and you want to try and design of a data type so that there is always some guarantee that the underlying data is valid. So, for example, maybe I want to design a class that is supposed to represent a point in the first quadrant. First quadrant is anything including 0 comma 0 or origin. So, the first quadrant is anything including 0 comma 0 and if I move to the right or I move up that would be the first quadrant in a plane. I want to be able to ensure that at no point of time this point gets out of the first quadrant. I do not want to do manipulations or I do not want to allow manipulations to go out of the first quadrant. If I want to do things like that then I will do operations and always check whether the data is still in the first quadrant or not and report an error if it gets out of the first quadrant for things like this. So, to check validity it is always useful to do this to allow classes to be defined and the classes can also go and check for the validity. So, let us see how this whole thing would look like. So, I was talking about this function called date. This date is a special function which carries the same name as the classes name. So, you can see that the blue and the red one they have the same name. The constructors always take the same name as the class. In this case the constructor is a method which takes three integers y, y, m, m, dd and what it does is it assigns your local variable y to y, y and the local variable m is assigned the value m and the local variable d is assigned the value dd. So, if you create an object of the type date and if you put date of 12 comma 30 comma 1950 internally you can write code within the constructor which will go and check that and say that it is invalid. However, if it is valid it initializes it and this check that you do inside the code may just leave it as it is. So, if I end up define let us say I design a function called int date colon colon season. This is supposed to return 0, 1, 2 or 3 depending on whether it is winter spring, summer and autumn. Let us say that is what we want to do. If you do int date colon colon season it means you are looking at a function called season which is a method inside this class called date. However, the class called date does not have a method called season the compiler will catch it and tell you that it is an error. So, this notion of public and private is a useful distinction to make. We do not make everything public by default because by keeping things private we can provide a very clean interface and we can also maintain things which are supposed to be invariance. What is the validity of the data inside we can maintain the invariance? This can also help in debugging programs because if you manipulated something and if something went wrong it could have happened only through functions that can manipulate the variables. It could not have happened through something else which is outside. So, you can go and round up the usual suspects essentially and say that if manipulations happened it happened only through these methods and there is something in these methods which is incorrect. And you will also see that it allows you to change the internal representation. The notion of a class allows you to change the internal representation. This is something that you will see in a lot of detail in a later class when we talk about the notion of ADT and data structures. So, as an ADT for a list could use a linked list internally or it could use an array internally. The notion of a list is just a sequence of elements. I could have used an array internally or I could have used a linked list internally. This kind of implementation detail can be hidden from somebody who just wants to use a list. And this is possible if you use classes. So, many times we go and look at what makes a good interface. So, we define classes in such a way that an interface is minimal. It should be as small as possible. At the same time it has to be complete. So, it has to be small. It has to be small enough to do all the basic things but not any smaller than that. It has to be the smallest and elegant set of things that you want to expose to the external world. I mean and it has to be safe. So, you do not want to have the arguments passed in a different manner and so on. You ensure that it is type safe. So, let us see how to define the linked list in a C plus plus way. This is what I was promising earlier. So, to define linked list in a C plus plus way you would do something like this. We define a class called node. This is very similar to a structure. So, we had struck node data and next. Here we have class node where the private members are data and next. We also provide public methods. Let us look at the public methods. You have set data and set next which will let data and next to be changed and we have data and next which will do the get. So, these two methods give you get and these two methods give you put access to node. So, you are allowed to change with these two and you are allowed to read using these two. And there is another method called node which is the constructor for class node. This is not doing anything. So, it is not changing anything at all. So, it is not setting up anything. So, this is the basic class and we are going to use this class inside the linked list. So, what is the linked list have? The linked list has a node called the first node. So, the linked list has a first node and it supports various operations like print, append, delete and so on. And it has a constructor called list. If I want an initially empty list, all it is supposed to do is ensure that there is no valid node that is pointed to from it. So, first equals null that is it. So, now you can see that the notion of a linked list becomes much cleaner. So, if you want to manipulate anything in the list, you have to go through these functions here append, delete and print. You cannot go and access first directly because by default first is private. You cannot access first directly. You can only go through the interface functions namely print, append and delete. Let us see how a print method would look like. So, the implementation of print would look like this. So, node start temp equals first. If temp itself is null which means it is an empty list, you may want to print empty on the screen. If temp if there is only one node in the list, then the first node's next will be null. We actually do this not using the next field, but we call the method called next temp's next. If that returns null, then print the character which is contained in temp data and then followed by aronull. Otherwise, we run a do-by loop which prints one character at a time. And the way we do that is we do not access the data element or the next pointer of the node directly. We call the methods temp data and temp next to do that and we keep doing this till we hit the end of the list. So, this basic loop takes care of reading one element at a time from the nodes and printing them based on whether there is only zero element or one element or more than one element. So, this is clean because anyone who calls print does not have to worry whether it's an empty list or does it contain one element or more. So, the print itself takes care of the implementation. The detail is hidden from the user. So, the user can just call print and be done with it. Let us see append to the list. So, for appending to the list, we are trying to add an element to the end of the list. So, we create a new node. We set its data to the data that is past. So, append is supposed to take a data and it sets the data to the last and sets the next pointer to null. So, you create a new object of the type node and you start with a temporary variable here which points to first. If the list is empty, then you just make first equals new node because there is nothing else to do. You created a new node and the first pointer will point to that. However, if it is not an empty list, then we keep moving the pointer till we hit the end of the list at that point, we insert it. So, this kind of a setup where we traverse the list and so on is completely hidden from the outside world. So, let me explain what I mean by hidden from the outside world. By showing how the program will look like. Let me write a small program which shows how clean this notion of classes make the whole program. So, I want to create a new link list and I want to add elements A, B, C and D and maybe at a later point of time, I want to even delete the element B in the list. So, here I declare a variable called list or an object list, which is of the data type list and this append A, B, C and D is going to add these characters A, B and C and D to the list. Let us see how this syntax is. So, list is an object. When I say object.upend, this object is of the data type list. So, it is going to find out if there is a method by the name append and what does it take append takes the data type character. So, we are passing a character and list dot append will add A to the list. At this point of time, this list is empty. We do not have to worry about that. We just said list dot append of A and the first time append is called inside here, you would create a node. This would be not true. You would just change the first point of the new node and maybe we can print it even. As soon as you create a list with one node, you can print it. And then we do list dot append of B. At this point, the list already contains A and now the method will look at this is not the first node. So, it will go through the list find out that the null is pointed from A. At that point, it will add it. So, A will now point to B. If you do this, B will point to C. And when you print, you start from the first pointer, print A, print B, print C and so on and go to the end. Now, you can append D. So, the list will have ABCD. And finally, if you call list dot delete of B, if there is a function implemented by the name delete, we assume that programmer has already taken care of that. The class's designer has taken care of print append and delete as a user of the class. So, when I said user and programmer and so on till now, I am talking about user of the class. So, the user of the class, as a user, I want the link list, I do not want to worry about how the list is implemented, how the append is implemented, delete is implemented and so on. I leave it to the designer of the class. And this delete of B, if there is a function defined by the name delete, I will assume that that gets done and list dot print, I will expect it to print AC and D. So, what did we get? The details of the implementation of append, delete and creation of the list and so on are not exposed to the user of the class. The main program became much cleaner. See this, this is much cleaner than making function calls to append and checking whether this is the first and second and so on. We did not do any of that. This becomes much cleaner here. And we trust the implementation of the class list to be correct and complete. This is something that we get from the implementation of a class. This is the reason why we use C++ in the data structures lectures that are following. So, in the lectures on data structures, you will see syntax of C++. So, do not be bogged down by the syntax of C++. Just remember that you have individual members that are going to get operated around or manipulated. You will either change the values of the members or you are going to read the values of the members. You will see that there are public methods that are used to manipulate the individual members. And you may also see private methods which are only called by public methods. And you will see that the methods are actually invoked using the dot operator. For example, the linked list append would do my list dot append of X or you have my birthday dot month and so on. So, do not be surprised by functions being called with the dot operator. So, all you need is the basic syntax of C++ which shows that there are classes which has internal members and internal methods. And they may have public members and public methods. And the members and methods are going to be used just like you do it for structures using the dot operator. So, beyond this you probably do not need much of C++. And as I mentioned earlier, we are not going to do anything more than that in this lecture. So, I said this is not a completely justified introduction to C++. I have done just enough so that you can appreciate the slides that are following or the lectures that are following on data structures. So, if you need C++, this is actually a completely new course that you have to do where you start with the syntax and semantics of C++ and also understand how to do object oriented design. Since this course is objective is basic programming and data structures and algorithms, we will not touch upon C++ in any further detail. So, thank you and this brings me to the end of this lecture.