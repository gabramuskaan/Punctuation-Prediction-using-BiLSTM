 This lecture on functions, this is a very important aspect of C that one has to learn and it also makes programming much more easier and fun. So what is a function? A function is essentially a self-contained unit of program. It is a piece of code that is designed in such a way that you can accomplish a particular task. So it is a very specific task that you want to do and you rub that up in what is called a function. And one way to look at function is you can treat them as black boxes. So for example, let us say I have a function called sqrt which supposedly does square root of a variable. You pass a variable to it and it is supposed to give you a square root. So this kind of thing happens in the mathematical world often, right? So I want to find out f of x and so on. So let us say I as a programmer have very carefully written a program to do square root and let us say you do not know how to do it. So what I do is I write the program for square root and I put it in what is called a function. I give it as a black box to you and you have to give it inputs, I will compute square root for you and I will give you outputs. So the program or the subprogram that I wrote will compute the square root for the inputs and you will get output. So this is the notion of a function. So you may not want to know the internal details of square root. For all practical purposes you can think of the square root as a black box that is given to you and as long as it is done correctly you can give inputs, you can expect it to give outputs and you can use that in your calculations. So this notion of putting things in a black box is nice because what happens inside the function can be hidden from what happens outside it. So what happens inside the black box is not of concern. Of course you have to be careful. So if I say that I have given you a program to write square root and let us say that subprogram is incorrect then you are in soup. So you have to be careful. If the functions are written carefully and implemented correctly then it lets you take a big task and divide that into smaller sub tasks. And we have seen several examples of functions and there are three things that I can immediately point you to main for instance it is a little for function even though we will talk about main in a little more detail later. The two functions that we have been using repeatedly are print-off and scan-off. Print-off was used to print things on the screen and scan-off was used to scan things off a keyboard. So these two are functions. So clearly you did not write print-off and scan-off. These were written by someone else and you are using it as a black box. You did not worry about how things go to the screen nor worry about how the keyboard the key press that is done is taken to the internal variables. So this kind of hiding the functionality of what a function does is very useful because you do not have to worry about the inner details of functions as long as the interface is clean. So you can think of functions as giving inputs and getting outputs from there. So let us see what outputs to the function means. So not all functions actually give outputs. So there are functions which compute something and are expected to return a value. For example if I am looking for square root, I give it, so I want square root of x, x is the value that square root will take and in return I should expect a value because it has to do some work and return a value. Similarly there is a mathematical function called POW which transfer power. Even to floating point values m, n it can calculate m raised to the power of n. So clearly m raised to the power of n is a very useful thing in various aspects and I expect a value more importantly. So if I give m, n it can do the action but I want to use that. Let us say I want to do a squared plus b squared I can do power of a, 2 but that a squared should be returned as a value. So there are functions which return values. There are also functions which do not return any values explicitly or at least not return any useful values but perform actions. For example printf as a function does something to do on the screen. It does not return a value to the program where printf is called. So at least it does not return a useful value for all practical purposes. So you can write functions which does a sequence of actions or you can write functions which does a sequence of actions compute something and also returns a value. So the notion of functions is essentially equivalent to outsourcing. Let us say you are a busy programmer, you are doing something, you do not want to spend time on writing square root function. You outsource it to me. I write the square root function. I am good with numerical methods. I go and write the square root function and I give it to you and that way you can outsource your work. So you can take a big problem, divide that into smaller problems and compose the smallest subtasks together. This is very useful when you want to build large programs. You can build on top of what you have done earlier or you can also build on top of what others have done. So this is a very nice thing about using functions. So most languages give you what is called a library. See also has a very rich set of libraries and very common things. Most common things that most programmers would need are all put in in the library. So imagine every single user or every single programmer having to know how to write things on the screen, having to know how to read from the keyboard and so on. Instead the C as a language gives you print offence can of. Similarly there are several mathematical functions including P, W and square root and so on, which are all packaged in what is called a library. As engineers you will actually either develop these libraries for others or you may actually end up using libraries that others have written. So one thing that you get from using functions is what is called modular programming. So you take a task, divide that into subtasks, sub-programs and these sub-programs can either be things that do some work or things that do some work and return a value. If you have been exposed to languages like Pascal, in Pascal they call them procedures and functions. Procedures do not return values whereas functions return values. In C and C++ everything is called a function. If a particular function does not return any value, it does not have a special name for it. It facilitates modular programming. You can take this sub-program or the function that you have and you can invoke it at several points. So I will show a simple example later on how this becomes modular and as I said it hides the implementation and if you want to make any change to the program it makes it much more easier. So what kind of functions are there in C? There are several functions available in C for string manipulation. This is a very common thing. How do you take a sequence of characters forming a string and manipulate strings? So we will look at strings in a later lecture. There are also several mathematical functions that are available as standard libraries in C. So if you are coming from other engineering disciplines, so you develop your own things. For example mechanical engineers, civil engineers, aerospace engineers and so on may use finite element methods very often and there are libraries that are available. Not as standard libraries but there are vendors who provide these libraries. Many of these libraries are usually domain specific. So what I mean by that is somebody uses specialist in an area, requires a specific kind of computation. This may not be useful to people outside the domain. For example finite element methods are useful to certain class of engineers whereas somebody in electrical engineering or computer science may not really need finite element methods or libraries doing that in any of their regular routine job. So as a programmer what you will do is you will learn to use existing libraries and you may also identify scope for building new libraries and you may even make money by building these libraries and selling them later. So let us take a small problem of racing a particular base to the power of N. So this is a very common thing. So A power or base power N is something that you want to do and this is a very common thing that you have in various programs. So you can write that in a very fairly simple way. So let us start with this program int i and p equals 1. So I have two variables i and p and I have a very simple loop which takes care of it. So we have a for loop for i equals 1 for i less than or equal to n i plus plus p is p times base. So it is going to take p and multiply it with itself. So it starts with 1 and you multiply that with p n times. So that takes care of raising p to the power of N. So one aspect that you have to probably be careful about here is I am assuming that both p and base are actually integers. Particularly I depend on p to the N to be n integer. The power that you are raising to this is only for such things. Let us look at the motivation for functions. Let us say a programmer needs 3 power 5 and minus 4 power 3 in the same program. So as a programmer one could write this. So I have i and p and base and n. These are supposed to be 4 variables which take care of base n i and p. So i is for running the loop, p is for collecting the product and base and n are the two numbers. You are doing base power n. So the base and n are two integers. And the result is supposed to be gathered in num1 and num2. num1 is supposed to be 3 power 5 and num2 is supposed to be minus 4 power 3. Let us say this is the setup that you have. You have to write a program of this kind. So you set up p equals 1, set up base equals 3 and n equals 5 and you write a loop which takes care of raising 3 to the power of 5 and you make num1 equals p. So num1 at this point has 3 power 5. Then you have to again change p to 1, set up the base to minus 4 and set up n equals 3. In this case you are ready to do minus 4 power 3. And again you have repeated the same loop that you have earlier. So you look at this loop here and this loop here are exactly the same. The result is accumulated in p and you copy the value of p to num2. So this is the correct program as in num1 and num2 would get 3 power 5 and minus 4 power 3. But let us look at a few things. First of all we have duplicated effort. So there is a for loop that is written here. There is also a for loop that is written here. Let us say for some reason I made a small mistake here, this mistake could also come here. Even if I have written the program correctly, it is just that the same task that I am doing, I see it in my program over and over and over. That is one thing. So this is something very subtle and you may not catch it if you are not careful. So even though this code, this for loop is repeated. Let us say I even let you do that and let us say it is not a problem right now. Let us look at base and n. Anyway these are things that are supposed to change. So I have set up base and I have set up n. So this is okay. But let us look at p. So I have p equals 1 and then we do the set of computations. It gives us 3 power 5. If I forget to do this p equals 1 here. What can happen is I have 3 power 5 that goes to p and then let us say I forget to do p equals 1. I have base equals minus 4 and 3, n equals 3. So if I forget to initialize p to 1 then p will start with 3 power 5 and to that you are going to multiply minus 4 3 times. So you are not really calculating minus 4 power 3 anymore and the result would have been for num 2 3 power 5 into minus 4 power 3. This is a disaster. So every time you want to do this you also have to remember that p has to be initialized to 1. Because you would have done change the base and number because you are computing for something new but you may forget initializing p to 1 and this can be a recipe for disaster. So you have to be careful and this is not a very good way of doing it. It is definitely sounds clumsy and we have to change this. It would be really nice to do something like this. Would it not? So int i num 1 num 2 3 integers num 1 is power of 3 comma 4 num 2 is power of minus 4 comma 3. So this is nice for multiple reasons. 1 it is definitely more readable. Instead of that screen full of code that you saw earlier you now have 3 lines of code. In num 1 int i num 1 num 2 is for declarations and num 1 and num 2 gets 3 power 4 and minus 4 power 3. It is almost like writing mathematical equations on a piece of paper. So you have taken 3 power 4 put it to num 1 minus 4 power 3 put it to num 2 and so on. It is definitely more readable. It is less error prone because if somebody you have essentially outsourced the work of doing this power. It is computing power to someone else or some other functionality. You have made a subtask which is supposed to be computing power of base comma n and when you do that you are not going to run into this problem. So every time the function is going to be called we will assume that all the initializations are properly taken care of. The computation is done carefully and you actually get work done and you get the return value. So if power is a function if it takes these two things and if it returns a value then you have essentially delegated the duty of computation to either someone else or to some other region of the code. Definitely this looks much less clumsy. So the only thing is somebody still has to write this power of base comma n. So you are outsourcing it but then somebody has to write it. So let us see how this power of base comma n can be written as a function. I said when you use it you can think of it as a black box. So power is a black box. You get base and then as inputs if you give these as inputs you are supposed to get some result back which is supposed to be base power n. So let us start with this black box. So what I am going to do is I define a body. So I have this body with this left and right flower braces and I have a name for a function called power. This is the name that I am going to use for power. It takes two integers as parameters in base and int n. This takes care of the inputs and I am supposed to be getting a result back and whatever is returned from a function is what you have here. So the way to look at this line is the function is called power. It takes two inputs base and n and it returns an integer. So the return does not have a name. It just has these type. You take two integers as inputs, one integer is called base, another integer is called n and you get an integer as a result. So that is what you have so far. So this is what the black box setup is. So clearly we have to write the program for it. We did this earlier. So we already had it. So P equals 1 for i equals 1 i less than or equal to n i plus plus P equals P times base. So this actually does the computation. So we already have this program written up and let us say I just did cut and paste of this into this block of code. So I have this. Having this is not sufficient. So if I look at this as a sequence of steps, I have variable P, variable i, but these variables are never declared. So there is no declaration for P and i and I mentioned earlier that every variable has to be declared so that you can get a location in memory. So P and i are not declared yet. So let us do that first. In i, p you have that. So this is not the end of it. You have declared int i and p. At the end of this for loop, P will actually have the final result. But if you look at this function, there is a variable i, there is a variable P. There are also these two inputs that you took base and n. So I want a result back, but which one of these variables is the result? No way a compiler can figure out which one of these things should be returned as a result. So for that we use the skewered called return. So this return, r, e, t, u, r n is a keyword. So it is a reserved word in the C language. And what it does is of the various variables that and various calculations that you have done, the final result is stored in P. Please take that and return it to whoever called it. So if you have base comma n as inputs, there are lots of local variables inside power. There are variables like P, i and so on and of these you are expecting P to be returned and return P takes care of that. So essentially if you look at the whole program, the whole function, this is how it is. Int power of int base comma int n. So by looking at this I know that it is expecting two inputs and both are supposed to be integers and it is going to give one output which is also an integer. And which integer does it return? It is going to return P after doing this set of calculations. So now let us see how this is nice. So since P equals 1 is an initialization done here. The key thing is every time this function is going to be called, this variable P is going to get initialized to 1. So therefore you do not have to remember to initialize P every time. You have given the task to somebody else. So you have delegated the task and that task or the sub task here called power is supposed to take care of whatever is required to compute power of base comma n. So to put this whole thing in one package, let us see a complete program which uses the power function. So what you see on the right side is the function. You have in power, in base and in n and we have written this function and let us see how this can be used. So we have two integers, number one and number two and I said would it not be nice to have number one is power of 3 comma 5 and number two is power of minus 4 comma 3. We have exactly that. So this is an actual program. We have these set of lines followed by this set of lines let us say. So even though it is all supposed to be in one place, one after the other, I am showing it right and left. So let us say I have these set of lines followed by this set of lines. So let us see. So we have number one is power of 3 comma 5, number two is power of minus 4 comma 3. So at this point, power of 3 comma 5, so that would be 243. I would expect number one to have 243 and power of minus 4 comma 3 is minus 64, negative 64, so that is supposed to be number two. So once I have computed it, I can actually print it. So in this case, it is only printing. You may want to use it in other calculations later also and we have completely delegated the work of power. So this whole thing is very clean and readable. So in this context, I want to give some names. So at this point, we say that the power function is being called at this point and this point and power is a function here. So this is called the caller. So the main function here is called the caller. The caller calls power function twice and power is the call E. So you have a caller which is main and you have a call E which is power and the caller can call call E multiple times. So that is what I said earlier. So you may have some task which is repeatedly done. So as long as you have written up the call E function and it is cleaned up, it is correct and you have verified it and so on, you can call it as many times as you want in any caller. So we will see more details of functions in the subsequent modules.