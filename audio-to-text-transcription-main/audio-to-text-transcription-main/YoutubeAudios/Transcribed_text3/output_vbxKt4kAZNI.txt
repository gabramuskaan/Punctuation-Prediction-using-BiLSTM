 So, far we talked about different types of binary trees. We looked at the construction of Huffman code using the binary tree ADT and then we also looked at another special type of binary tree called the binary search tree and then we also looked at how to construct a binary tree from the pre-order and in order traverses given the pre-order and in order traverses. Now, I am going to give you one more application of binary trees which is very important called the heaps or priority queues. Now, in the first few classes when we did lists for example, we talked about queue as a special type of list where we said insertions happen at one end and deletions happen at the other end and it was a first in first out queue. You got into the queue first, you got served first that was the idea. But now, sometimes it is possible that you want to have queues where you give some priority treatment. For example, if I am a computer center in charge and there are large number of programs that are running, I would like to ensure that those programs or those processes which take very less time should be executed first rather than processes that take a lot of time. So, I would like to give some kind of a priority or you know if you have your internet service provider, if you request is very small, you get higher priority compared to request where you are downloading huge videos. So, now how do we implement priority queues that is the idea. Suppose we implemented a priority queue using an array like this or a link list like this and we also stored at every node the priority. Let us say this was 387650. You know something like this and same numbers over here 6 of 15 remember in a queue you always deleted and this pointed to the front and this pointed to the rear and this pointed to the front and this pointed to the rear. Now, if you want to serve the jobs based on priority then what do you have to do? You keep on moving down front until you come to the rear and for example, because that was the where the highest priorities and then serve that job. Similarly, in this linked list example you start from the front, keep moving down till you reach the priority with the largest value and serve that. So, basically what happens is whether it is the array implementation or the linked list implementation remember this is an abstract data type. So, everything is hidden from the user you have to use only the front keep moving down until you come find out which is the largest priority and you will know that only if you have reach the end of the queue. Therefore, the time complexity of implementing a priority queue can be as largest order n where n is the number of elements in the queue. The question is can we do better and that is what we are going to answer using what are called priority queues. Let us see how we can use priority queues to do this. The definition of a priority queue comes from the definition of a maximum tree. What is a maximum tree? A maximum tree is a tree in which the key value in each node is no smaller than the key value in its children if n. A max heap look at the definition over here is a complete binary tree that is also a max tree. What we remember is sometime back we saw the definition of a complete binary tree and we said that complete binary trees look like this remember. We said this is complete binary tree while this is not a complete binary tree. So, this what we are saying is we not really have to have this max tree satisfied. It is no smaller than this children that means this can be 8, 7, 6, 4 and this is a heap. This is what is a definition of a max heap and it is a complete binary tree not a full binary tree it is a complete binary tree. So, the question is so what is this complete binary tree is a binary tree the structure of this tree being a complete binary tree is very important for the implementation of operations on heaps. We already saw in the context of queues we inserted into the queue we deleted from the queue. So, in much the same way where we look at operations on heaps it is a priority queue but a create an empty priority queue you want to insert a queue element into a priority queue and you want to delete the largest element from the priority queue. By the same thing can be done for minimum also it does not matter you can use a min tree or a max tree. The difference between a max tree and a max heap is that the max heap is a max tree which is also a complete binary tree. So, now let us see how we can perform these operations of insertion into a max heap. So, what is what is claimed is that when you implement priority queues using heaps the time complexity is order log in for both insertion and deletion and we already talked about the if you use a normal queue it would be very expensive but priority queues have to be implemented as complete binary tree is using arrays that is what gives it this property of log in. Let us take an example here is an example let us say I want to I will go through this example completely let us say I want to insert the elements in the first let us say 6, 7 and 15, 3, 2 and 5 into a priority queue. Let us see how this is done. It is implemented as an array in this example here the root node corresponds to the index of the array 1 and the next level for example corresponds to the index of the first left child corresponds to the index of the array 2. So, for example in this particular tree what we are saying is 15 has index suppose if there is an array implementation the a is the array that we are using then 7 is at index 2 and 2 is at index 3 this is very very important and see it go essentially if you look at it the array indices go through something like a level order this is the first level second level third level and so on. And 3 is at near 5 and so on let us see now how we insert these elements into the heap. Let us say this is what was given to us. So, you start with initially there is an empty heap. So, you create a node with the number 6 where is the stored now this is stored at a of 1 how many elements are there in the heap there is only one element in the heap. So, you keep track of a variable called last and say last is pointing to 1. Last is being pointing to the newest element that has been inserted into the heap. Next I want to insert 7. So, what do I do I insert it at a of 2 initially then I find that because now what is happening now if I insert it here 7 and 6 when I compare what is happening the heap property is violated. So, what I do is I exchange these numbers I bring here 6 and 7. Next what do we have we have 15 right. So, now I insert initially 15 at this position I compare 15 and 7 I find that 15 is larger than 7. So, I exchange 15 and 7. Next I want to insert 3. So, where will I insert 3 initially this is a 1 a 2 a 3 suppose is the array implementation and at a 4 I will first insert this element then what do I do I compare this node with its parent and you find that it is in the correct order. So, I leave it as it is next I insert 2. Now, 2 is also in the correct place with respect to its parent and next I insert 5 which will be in the correct place. In the example that is given in the slide I give a slightly different example suppose I had inserted 2 earlier suppose it was there at this position in the tree then if I was inserting 5 then what will happen I will compare 5 with 2 its parent I find that 2 is smaller than 5 therefore, I will move them and get this new tree. So, basically this is the idea of insertion into a heap. Now, let us see how long we took to insert a new element into the heap. First when we inserted the element 6 there was only one element to be inserted therefore, constant time is it then when we came to the second element we had to go one level down and so on how many elements were there in the heap at that time there were only 2 elements in the heap and we had to go height of 1. Now, when I came to inserting the let us say I wanted to insert 3 for example, then what happened now clearly what do I do I am initially putting it over here and comparing it suppose let us say instead of 3 I had to insert 25 or something in that let us say these were non-thing. So, I put 5 in the original position which is at the position of last. So, this is last this was last this was last this was last and finally, now last is equal to 4 then what I do is I compare it with its parent then what do I do I move it to its position depending upon I keep comparing with this for example this is clearly larger than this therefore, this should be above this then I compare with its parent I keep doing this until I reach the root in this particular case what will happen we will find at 6 will move here 15 will move here and 25 will move here. So, this is the idea of insertion into a heap how long did it take now there were 4 nodes and we had to go only 2 levels down or we had to basically do log in operations to insert an element into a heap it really makes a lot of difference when you have huge heaps especially jobs in a priority queue here is an implementation of the heap I have defined a class heap and I have given insertion into the heap notice that I have defined a priority heaps size basically an array of heaps size the heaps size can be fixed let us say can reallocate if you want there is insertion of element x as usual element type is defined by the user and delete root you always only the priority queue we only have to delete the root. So, now let us see what will be do if you have to delete this root because the highest priority element has to be served first then what will happen it will root less now. So, what we do is we take this put it over here so 3 will come here once 15 has been deleted and then what do we do we compare with its children clearly 3 is greater than 7 and it is also greater than 6 so 3 will come here 6 will come here and 7 will go here and this will be the new structure of the heaps. So, when you delete a particular element again how many elements did we do we took this last element moved it here moved to steps down so again the complexity of delete is also only log n. So, here is a C plus plus implementation and insertion what are we doing we incrementing the position last by 1 and what are we doing here we are checking where the priority of the given node is greater than the priority of I by 2. So, greater than I by 2 wherever it is for example, we put it in that particular position and moving all the other elements appropriately how are you finding the indices if this is I clearly if this is the notice that the index of the parent is 2 the index of the root this one index of its child is either 2 or 3 and index of 2 children is what now 4 or 5 and so on. So, given the index of the parent I can find the index of the child children and given the index of the children we can find the index of the parent this is possible only because I am implementing the priority queue as an array otherwise it will not be possible. So, what is the piece of code is simply doing is while I dot equal to 1 while looking at it is we are starting from last element and we are continuously checking trying to move up the tree depending upon where that particular node has to be inserted notice that we are starting from last. So, we are assigning to I priority I by 2 that means, the element at I by 2 is replaced. So, basically if you are here if this one is smaller than what has been recently inserted you may move it one down the example I already talked about in the concept context of insertion and this is and you repeat that until you have reached the root node. Now, this is the deletion again what are we doing we are looking at basically first what we do is here we once again deletion means what the number of element is going to reduce by 1. First of course, what we do is start with the parent as the root child as to the left child of root and we take the last element from the root and then perculate it that is what I said go back to the root and perculate it. So, what are we doing over here we first check which of the two children has higher priority and switch them because you want a higher priority node to move up to the root that is what we are saying is if I have 15 here and I have deleted 15 and this was 17 this was 14 this was let us say this was 12 and this was 14 then what I do is I want to make sure that 14 goes on top. So, that is the first thing that I do because this is being deleted so, next element that must become root is 14 and that is what this step is doing over here it is comparing which of the two children have higher priority and then afterwards what does it do it keeps on finding out the child by taking parent times 2 because it is parent is i by 2 which we saw in the insertion case in the deletion case parent is at child is at parent start 2. So, what we do is we essentially what are we doing over here we are essentially repeating this same process over here and we do the deletion of the given node again percolator is take the last element from the heap put it to the root and percolator down. So, that is all the rest 2 heaps and what is interesting is the complexity of the heap whether insertion or deletion is only a log n operation. Now, I want to think of some nice problems let us say I am giving you a heap and I want to do and let us look at some problems on heaps which I would like you to do think about this heap you are given a heap that is already there let us call it a max heap. Now, what I want you to do is I give you the index of a node given the index of a node problem 1 how do I change the priority priority of the node. I want to give you one more problem let say I am given k sorted list I want to create 1 more. 1 sorted list and I want you to use a priority queue to do this priority queue to do this let see how you can do these 2 problems.