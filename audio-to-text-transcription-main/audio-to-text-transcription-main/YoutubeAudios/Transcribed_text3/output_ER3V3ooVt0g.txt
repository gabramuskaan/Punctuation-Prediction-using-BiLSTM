 And compare the current minimum to the new data that is entered into the sub problem. In other words in the second iteration, where we consider the second element and compare it with the minimum, which was the first element. If indeed the second element is smaller than the current minimum then it indeed becomes the minimum among the array, which consists of the elements A of 1 and A of 2. So this is an iterative procedure, where one scans the array from the element index by the smallest value up to the element index by the largest value in this case 1 to n and start off with the an estimate of the minimum value to be the first element and update the estimate by a comparison by one comparison in each iteration. It is very clear that we will have to perform n minus 1 comparisons. It is not possible to perform anything less than n minus 1 comparisons in this approach, unless we know something else about the array. Therefore, this algorithm that we have just discussed is an optimal algorithm with respect to the number of comparisons. So, the number of comparisons is you need n minus 1 comparisons in the algorithm above performs exactly n minus 1 comparisons. Therefore, this is an optimal algorithm. It is a very interesting exercise to ask if one can compute both the minimum and the maximum elements in the array by efficiently, but more importantly by in a simultaneous fashion. That is, we want the algorithm at every point of time to keep estimates of both the min and the max in the array and update both these estimates and finally conclude that min and the max have been found. Here is one way of doing it. Use n minus 1 comparisons for each of them. That is, can the elements from the first element to the last element assume that the first element is both the minimum and the maximum and compare the current minimum and the maximum in every iteration with the current element. This is two comparisons per element. There are n minus 1. There are n minus 1 elements that are compared against the minimum and the maximum values. And therefore, we were formed 2 n minus 2 comparisons. We are interested in coming up with a better algorithm which uses strictly smaller than 2 n minus 2 comparisons and we present an algorithm which uses at most 3 n by 2 comparisons. So, let us just understand how this can be done. In the straightforward approach which is listed at the first item, we have estimates of min and max and we compare both min and max with the next element in the array. That is in the I th iteration we compare the I th element with both min and max to check if the I th element replaces the minimum value or the maximum value. Of course, one can use the fact that we have computed 2 values which are min and max and if we compare min and max with a pair of values, then min needs to be compared only with the smaller of the 2 and max needs to be compared only with the larger of the 2. And therefore, you can compute the min and max among these 4 elements with 3 comparisons. This is the whole idea. So, the whole idea is to process the elements in the array in pairs and maintain the minimum and the maximum values in each iteration that have been calculated so far and compare the minimum element with the smaller element of a pair and compare the maximum to the maximum element in the pair. Observe that the in a pair the smaller element can be identified with 1 comparison and after that we count only 2 comparisons therefore, among 4 elements we are able to compute the minimum and maximum using just 3 comparisons and this is a trick that we generalize to reduce the total number of comparisons. So, here is the algorithm which is described. See the values when n is odd min and max are taken to be the first element and when n is even min and max are taken to be the first 2 elements. This takes 1 comparison min is taken to be the smaller of the first 2 elements and max is taken to be the larger of the first 2 elements. This is done at the cost of 1 comparison. And then based on this algorithm that we have outlined there will be a total of n by 2 comparisons or if n is odd there will be n minus 1 by 2 comparisons and if n is even there will be n minus 2 by 2 comparisons comparison pairs and each of them requires 3 comparisons to identify or update the minimum and maximum. Therefore, the total number of comparisons which are made are 3 times n minus 1 by 2 plus the first comparison and 3 times n minus 2 by 2 plus the first comparison. This is the total number of comparisons which are made. So, this is the whole idea and let us run it on a single example where there are 5 elements in the array. The array has elements 2713 and 4 and we just illustrate how the simultaneous min and max calculation happens. Initially because n is odd min and max are taken to be 2 then we compare the elements by considering the pairs 1 and 7 and the pair 3 and 4. In one iteration we consider the pair 1 and 7, 1 is smaller than 7. This involves 1 comparison and after that 1 is compared with the current minimum and 7 is compared with the current maximum. As you can see this is sufficient for us to very easily extract the minimum and maximum among the elements 271. Now min and max are updated to be 1 and 7 respectively they are different from their earlier estimates which was both 2 and we have now used 3 addition 3 comparisons. Then 3 and 4 are brought into the whole exercise. Now 3 is compared with the current minimum because it is smaller of the 2 and 4 is compared with the current maximum because it is larger of 3 and 4. Already 1 comparison is used to identify which of 3 and 4 is smaller. Therefore we use 3 more comparisons at total of 6 comparisons are used which is 3 times n minus 1 by 2 comparisons. Similarly when n is even we use 1 more comparison to identify the smaller of the first 2 elements and subsequently we have 3 times n minus 2 by 2 comparisons. In this case it is very easy to see that there are 7 comparisons that have been made. So this is the whole idea and let us run it on a single example where there are 5 elements in the array. The array has elements 271, 3 and 4 and we just illustrate how the simultaneous min and max calculation happens. Initially because n is odd min and max are taken to be 2 then we compare the elements by considering the pairs 1 and 7 and the pair 3 and 4. In one iteration we consider the pair 1 and 7, 1 is smaller than 7. This involves 1 comparison and after that 1 is compared with the current minimum and 7 is compared with the current maximum. As you can see this is sufficient for us to very easily extract the minimum and maximum among the elements 271. Now min and max are updated to be 1 and 7 respectively they are different from their earlier estimates which was both 2 and we have now used 3 addition 3 comparisons. Then 3 and 4 are brought into the whole exercise. Now 3 is compared with the current minimum because it is smaller of the 2 and 4 is compared with the current maximum because it is larger of 3 and 4. Already 1 comparison is used to identify which of 3 and 4 is smaller. Therefore we use 3 more comparisons at total of 6 comparisons are used which is 3 times n minus 1 by 2 comparisons. Finally when n is even we use 1 more comparison to identify the smaller of the first 2 elements and subsequently we have 3 times n minus 2 by 2 comparisons. In this case it is very easy to see that there are 7 comparisons that have been made.