 So, today let us continue our study of algorithms with exploration of this area of searching as most of us know searching is actually a fairly common word now associated with computer science because of search engines which are accessible to most of us. And let us start off with the simplest of searching exercises where we want to search a data structure for a key which is given as input. So, in this lecture we are going to look at this issue of searching an array of course, one could consider the problem of searching other data structures. We will come to it as we progress. So, if you look at the question of searching searching is a process that is used to find the location of a given key or a target among the list of objects. So, when you search an array the search algorithm is expected to return the first element in the array that contains the given key. In this picture we can see that the target key that is been given is the key 62 and it occurs in the location 4 and we want to design an algorithm which efficiently gives us the value 4. The approach to achieve this particular task is given to us in the coming slide. So, now let us explore the procedure for the search of the given key 62 which we know from this visual is at location 4 or it is in the array index with the number 4. And it is important to note that the indices of the arrays are from index 0 all the way up to index 11 that is there are 12 elements in this array and we want to search for a given key which is 62. Let us look at the basic steps that are to be done. We start by comparing with the element which is at index 0 and the element there is 4 the comparison of 62 and 4 definitely results in the fact that they are not equal and the next comparison would be with the element at index 1 which is 21 and so on till we come to the third element for example, where again a comparison with 62 is made with the value which is there which is 14 and after 5 iterations the element 62 is found for the first time in the array index 4 and this is considered as a discovery or a successful search where the search key has been found. It is apt to indeed call such a search procedure a linear search because in every iteration the queried index in the array increases by 1. If you plot the indices of the locations which have been probed or searched you will find that this plot against iteration number that is the x axis being the iteration number and y axis be the index of the location search you will see that this plot is a straight line and it is natural to call this a linear search. This is very important to understand why this is called linear search the array indices are searched in a linear fashion you start of a 0 then 1 then 2 and 3 and so on and so forth. Let us consider the running time to search for a key which is 72 which as you can see does not occur in this array and there are 12 elements in this array and we do not show all the comparisons this is definitely not necessary. As you can see all the comparisons will fail in this linear search till the index value exceeds 11 that is it becomes 12 at which point of time you have an exit condition that is you have searched the array. Search every compared every element of the array with a given key and you have exceeded the total number of elements that are there in the array and therefore the element is not present in the array and the algorithm at this point of time can report that the given key is not present in the array. It is very important to note that we have observed 2 of the exit conditions of this algorithm when the key is found and when the key is not found the key is not found when you have compared it with all the elements in the array and when the first time the key is found in the array the algorithm exits these are 2 exit conditions and this can be encoded. In the following algorithm and to make a distinction with something that we are going to study we call this unordered linear search. The algorithm is linear search and it is unordered linear search because the algorithm does not use any structure of the data elements which are present in the array for example the data elements in the array could be sorted but the description of the algorithm does not use that fact and therefore this is called an unordered linear search. In other words unordered linear search is applicable when you are searching for a given key in an array in which you have no a priori information about the organization of the data elements. The data elements could be in a sorted order or they could not be in an unsorted order and we have seen the conditions under which a straightforward linear search algorithm will exit and this is encoded in this pseudo code which is described. It says that while there are some more elements in the array if the value is found at the current index then you return the index of the current location otherwise you increment the index and continue in the loop. At the end if the value is not found at all a return value of minus 1 is given of course one has to if one programs is one has to be very careful and ensure that the array indices are between are at least as large as 0 and minus 1 is not an array index. In a programming language like C this is definitely the case where the array indices started 0. So this is a snapshot of a C program which is included in the slide to to understand the complexity or the amount of time that is spent in executing this particular algorithm which is unordered linear search. So the function that we have written here that you see here is called the search function the arguments to this function is an array which is called elements and the size of the array is given as an additional argument just for the cases of just to illustrate this example and the key the desired key that is being searched for in elements is also passed as an argument to search. The for loop there initializes an index to 0 and searches up to the size of the array and in every iteration in every loop the element access at a particular index is compared with a given key and if a successful match is made then the index is returned as the location where the key is present. If the key is not present in the whole array which is discovered after the loop has run for as many steps as the size of the array the control exits from the loop and a minus 1 value is returned by the search function which informs the calling function that the key has not been found. The use of this C program mainly is for us to understand where the effort in computation is for us to be able to say something about the running time of this algorithm. Here is the analysis if the key is at an index i then clearly i comparisons are executed one in every loop. So in other words if the key is at index 0 then one comparison is definitely executed that is in the first loop. In the worst case if the key is not present in the array then the loop is executed as many times as the size of the array which we have said. Therefore the worst case running time of this algorithm is order of size of the array. Note that we have one arithmetic operation also which increases the value of the variable called index. The natural question now is the following. Can we reduce the number of comparisons in the number of arithmetic operations performed by a search algorithm to find a key in a set. And we also consider cases in which the data in the array is in a sorted order and then we see if it is possible to design better algorithms better in the sense that the number of comparisons in the number of arithmetic operations is reduced. Here is an exercise at this point of time. So what happens if one does a linear search in a linked list. And what is linear search? In this case as you can see linear search involves incrementing the array index starting from the smallest index value to the largest possible index value in the array and searching or comparing for the presence of a key. So it is important as an exercise to understand what linear search in a linked list is. That is an exercise and let us move ahead and explore this question of what ordered linear searches. In other words what is linear search when the data is ordered in the given array. In other words the array contains the data elements in say sorted order. Let us say in this case as you can see it is an ascending order and how much time does it take or how good an algorithm can be designed to be able to find a target key in this particular array. And of course if the key is not found in the array we should return a value minus 1 and we make assumptions as we have been making so far that all the data items are in the range sorry all the indices are at least as large as 0. So one of the properties of ordered linear search is that linear search can stop immediately when it has passed the possible position of the search value. For example if you see this slide if the queried value is the value 8 then one can perform a linear search up to the value 5 up to the value 10 which is found in the location index by the number 5 that is the element a of 5 in this array a and we find that 10 is larger than the queried value 8 and we already know that the array is sorted in ascending order. Therefore we are not going to ever find 8 after the array index 5 because 10 is the value which is sitting in that location. So this is one way in which we can use the fact that the array the data elements in the array are in sorted order. So this is exactly the algorithm that is implemented observe that there is one another check which is there which is done first inside the while loop. If the value is at the current index is greater than the value that we are searching for then the value will not be found and you can return a minus 1 immediately. Now while this is one way of using the fact that the elements of the array are ordered in this case in ascending order and this is indeed the pseudo code for this sorry the C code for this. Let us perform an analysis what is the worst case running time of linear search on ordered data. In the worst case as we can construct by an example no matter what the array is if one considered the target key to be a value which is larger than the element which is present in the largest index. In this example consider the key 18. 18 is larger than 17 which is the value which is present in the index 7. Therefore an execution of linear search to look for 18 in the array will compare 18 with each of the 8 elements which are present in the array and it is the same for loop as we have seen in the previous slide. Therefore there is an arithmetic operation in every iteration in the worst case and there is also a comparison that happens in the worst case. Therefore in the worst case the running time is the order of the number of elements in the array. Therefore there is really no change in the worst case analysis. Therefore how does one use the fact that the array is ordered to get better algorithms? Is it possible at all? That is the focus of the next search algorithm that we explore which is very well known as the binary search approach and we will see why this is called the binary search approach. And here the most important principle is that the search key does not have to search or does not have to be compared with every element in the array. In other words by making certain comparisons we can judiciously discard certain parts of the array from the effort that we have to put into compare the given key with the elements. For example if the given key is 18 if we end up checking comparing 18 with the element 5 which is presented the array location 3 if 18 is present in the array then it would be present only among the indices 4, 5, 6 and 7. We can see that the search region is kind of reduced by half or approximately by half. This is exactly what we are going to encode into our algorithmic procedure and let us look at one run of this algorithm. So A is the array here and the target key is 22 and there are 12 elements in this array. As you can see 22 is present in this array it is in the array location index by the values 6. So the algorithm is very simple it keeps track of 3 values which are called first, mid and last. First and last are extremely important they keep track of the sub array that we want to search. The sub array that we want to search is in this example the unshaded part. The shaded part is the part that we do not want to search. So let us see this run of this algorithm initially first is the value 0, last is the largest array index which is 11 and mid is the mid point which is the first plus last divided by 2 and we take the flow of the division right in this case the flow would be 5. So 11 plus 0 divided by 2 is 5 and a half and we take the value 5. A comparison of the given key is made with the data item which is located at the array index 5 which is 21 and 22 is greater than 21 and because the array is sorted in ascending order it is clear that 22 must be present only in the array indices 6 through 11 and definitely is not present in the array indices 0 through 5. The array indices 0 through 5 are now shaded gray and first and last are now used to encode the first and last index values of the relevant part of this array A which is now 6 to 11 and the mid point is now you can do the calculation is 8 it is 6 plus 11 by 2 which is 17 by 2 the flow of it is 8 and the algorithm repeats this step of comparison comparing 22 with 62 which is the value in the array index 8 and of course 22 is smaller than 62 and therefore 22 cannot be present in the indices 9, 10 and 11 it is not present in the array index 8 as our comparison is shown therefore it can only be present among the array indices 6 and 7 that is among the array indices first and mid minus 1 this is the most important thing that it is present in the array indices first and mid minus 1 in this case and as you can see now first and last have become 6 and 7 respectively and mid is now 6 22 is successfully found and the algorithm terminates reporting the index of the location where 22 has been found which in this case is 6. Let us see the condition under which this algorithm exits and reports that the key is not present in this case the target value is 11 and as you can see 11 is not present in the array and again the gray shaded part is the irrelevant part of the array for the search algorithm and the unshaded part is the relevant part first and last as usual end code have do encode the relevant part of the array keeps track of the indices initially it is 0 and 11 a comparison is made with mid 11 is smaller than 21 therefore if 11 is to be found it can be found only to the left of the index 5 that is among the array indices 0 to 4 which is now captured by the modified value of last which has now become 4 mid is now recalculated in the next iteration to be 2 a comparison is made with the value which is sitting in the array index 2 which is 8. 8 indeed is not larger than 11 therefore 11 has to be to the right of 8 if it is at all present in the array therefore now in this case 11 should be present if at all in the present if at all in the array indices last and mid minus 1 sorry last and mid plus 1 so mid was the value 2 and now observe that the value of first is now 3 that is mid plus 1 and last as you can see that in one more query it is discovered that the search key is 11 is not present in the array and at termination condition you can see that first has become larger than last and this is the termination condition for the algorithm. So this is very important the termination condition for the algorithm is when first exceeds the value of last at which point of time you can report that the key has not been found and the key is found the value of mid the location where the key has been found will be as a return value of the algorithm these are the two invariants which precisely map the presence or absence of a key from the array. So in generic terms binary search is a paradigm of solving a problem by what is called the divide and conquer strategy in this divide and conquer strategy the search space in this case the array is repeatedly divided into smaller and smaller portions with the guarantee that the search value would be present in the region that is being searched at every level or in every iteration as we have seen in with every comparison the size of the array has been reduced by a factor of 2 in other words the array size becomes smaller and smaller by is halved in every iteration and this kind of gives us a clear handle on an understanding of the binary search algorithm. Let us see the pseudo code and the pseudo code is very important because it tells us how the first mid and last have to be modified. So initially first and last have said to be the bound I said to take the values of the boundary of the array the mid value is calculated the search value or the key is compared with the element in the mid value if it is indeed present the mid element is returned as the value if it is not present a comparison is made whether the value was if indeed the mid value does not contain but first is more than last. Then the mid value does not contain but first is more than last then the value is returned first is at least as large as last then the return value is minus 1 saying that the key has not been found otherwise if the value is smaller than that of the middle element last is now made to take the index which is mid element position minus 1 and if value is larger and if value is larger then first is taken to be the mid element plus 1 that is in other words one would visualize the search to be moving either to the left or to the right of the mid point in the array provided the key is not found. Here is the pseudo code for this function which is binary search it is actually cut and paste from a C program. Now the arguments are as usual element an array which contains a sorted set of elements the size of the array is given and key is also given as part of the input and first is taken to be the value 0 and last is taken to be the value size minus 1 and you can check the integer division which is middle takes the value of first plus last divided by 2 and whatever comparisons we have discussed so far are made. The value of this particular piece of code is that it gives us an idea as to the number of operations that are performed in a run of this particular algorithm. So, let us just go through this example of binary search in this case where the array has the elements 8 elements in a sending order and the search key is 14 is present in the array index 6 and one can see the conditions under which the algorithm exits. So, the first value that is searched is the array index 3 and array index by the value 3 which is 0 plus 7 divided by 2 and the flow of it gives you the value 3 and the search value is 14 and clearly 14 is to the right of 5 and first is the one whose value is updated to take the value 4 last remains unchanged in the next iteration mid becomes 5 7 plus 4 divided by 2 and this search succeeds by computing the mid value 6. As you can see the order of the elements in the array guides the choice of the array locations which are probed by the algorithm. So, here is an unsuccessful binary search and the unsuccessful binary search can terminate in two conditions where first and last are the same and the middle value does not contain the search key. This is very important there are three cases here. The first case we have already seen which is a successful search here is an unsuccessful search where the exit condition is because the key is not present and first and last have the same value here 8 is a search key and it is clear that the sequence of searches finally queries the element 4 which has the value 7 but first and last take the same value at this point of time and because 7 is not equal to 8 and there is nothing else to be searched the search returns a failure. Here is the case where first exceeds the value last in the next iteration and the key is not present. So, this can also be checked the focus now is to analyze binary search which is the algorithm that whose analysis we postponed to the end. Let us look at the analysis of binary search where our goal is to estimate the total number of comparisons of the binary search algorithm. So, let us write the formula for binary search by T of n where T stands for time and N stands for the array size. For the moment let us assume that N is a power of 2. The simplifies the analysis and therefore we use N to be a power of 2. Let us look at the case when T of n is a power of 2. Let us look at the case when T of n is a power of 2 and the is a power of 2. The simplifies the analysis and therefore we use N to be a power of 2. Let us look at the case when T of n for N is equal to 2. So, let us just focus on the array it just has two elements and let us assume that the arrayments are 1 and 3 in sorted order. And let us count the number of steps that it takes to check for a query element. So, this is the array index with 0. This is the array index by 1 and it is key to the array and we have that a query element can be resolved for whether it is present or not in the array in two comparisons in a maximum of two comparisons. So, for example what would happen is that if the search is for a value half then the array index which we compared is half would be compared with 1. Half is compared with 1 and then the first mid and last are updated and half will not be found. So, that takes only one comparison. If the value is 3 then in two comparisons it would be found and if the value is larger than 3 then again the value would be found it would be found that the value is absent in at most two comparisons. Therefore, T of n for n is equal to 2 is written as T of 2 which is just two comparisons. So, let us consider the case when n is a power of 2 and let us look at the array indices. The array indices are a of 0 that is sorry the index the indices are 0 2 power k minus 1 and the value of the array index that is taken to be relevant is the value 2 power k minus 1 divided by 2 which will be 2 power k minus 1 minus 1 that is the floor of this is 2 power k minus 1 minus 1 which would be the value that would be compared. Therefore, as you can see after the first comparison the relevant part of the array would be the range a of 0 to a of 2 power k minus 1 or sorry a of 2 power k minus 1. 1 minus 1 or a of 2 power k minus 1 to a of 2 power k minus 1 there are only two possibilities for the rest of the search space after one comparison. So, after the first comparison with a given key these are the two range of values as you can see that the range of values is now down by a factor of 2. We can write this we can include this using the following recurrence which is T of n is T of n by 2 the time taken to search for the key in an array or size n by 2 plus 1 and the boundary condition is given by T of 2 is equal to 2 and the solution for this recurrence is T of n is order of log n indeed it is log n to the base 2 but the constants in the order take care of it. So, this is the analysis of binary search and observe that we have used the fact that the array is sorted to come up with an algorithm which just uses order of log n comparisons as opposed to ordered search which in the worst case was using linear number of comparisons or order of the size of the array number of comparisons and in the case when the array is unordered we were already using a linear number of comparisons which are unavoidable. So, with this we stop this discussion on search and we will continue in the next lecture.