 Good morning. In the last class we looked at binary trees and we looked at two applications. One is constructing of a Huffman code using binary trees and we also talked about the construction of an expression tree from a post-fix expression using both binary trees and stacks. Today and then I talked about the different types of traversals of a binary tree and we saw that when we take the expression tree and traverses in order we got the infix expression and when we traversed post order we got the post-fix expression and pre-order we did not do but you will get the pre-fix expression. So today what I am going to talk about is I am going to and so just to recap what is pre-order traversal, pre-order traversal is visit the root and visit the left child in pre-order look recursively and then visit the right child in pre-order recursively. In order is visit the left child in in order recursively then visit the root then visit the right child in in order recursively. Now and what is post-order visit left child in post-order recursively visit right child in post-order recursively visit root and post-order is what gives you your post-fix expression. Now what we will do is suppose now we are given the traversal of the trees. Given the traversal of this trees can we construct a unique tree. So here we have a binary tree which is given to you and let me go through this example for you. So what do we have? We have a here b c d e f and g and h some arbitrary binary tree. What is it that I am assuming? I have given binary tree like this and given this binary tree we want to construct it is determine its pre-order in post-order traversals. Let us look at the pre-order traversal. What a pre-order traversal tell me visit root then visit left child and right child recursively. That means what am I going to do? I am going to do the left child first they find b then this has to be done recursively. Remember in any recursion what do we have to do? If you go down till the recursion terminates and only then you can backtrack. So I visit b then I go down this is the next node which I will display and d g then we will come back because this left sub tree is completely over now. Remember we started with a we came down to b we came down to d this has no child. Therefore we then look at the right sub tree then again we go back up then all the sub trees of d are covered then we go to the node b go back one level up just as it would happen in recursion and then you look at the right sub tree and it has no other children. Again this has to be traversed in pre-order therefore you do not have since it has no children e is the last symbol that will be output and then what happens all these nodes have been visited you go back to go back here and go to the right sub tree and visit this in pre-order. So you will get c f and h I think that is what is said over here. So pre-order traversal will give me this. So this pre-order. Now let us look at in order traversal what is in order traversal visit the left child recursively then root and then d right child recursively. So what happens now I go down a go down to b visit its left child left child left child because first the first node to be displayed will be the left child then the root and then d right sub tree. So if I keep going down what do I do I come up to d d has no left child then I display the root so I display root over here d where it is right sub tree g then I go back one level up we have b where it is right sub tree e if for example if this one had then we would again done this in in order everything has to be done in order. Then we go back then now we display the root a we come down here again now you go to the right sub tree which has to be again traversed recursively the in order recursively in in order. So it goes to its left child right. So now this will get displayed because this one has no left child then it this root f h and c this is what will be displayed f if something wrong in that the instead of g there it should be h over there f h and c. Now this is the in order traversal I encourage you to check this you need at least in order and pre order or in order and post order constructed tree uniquely. So let us look at this particular example and see how we can get this corrected. What we will do is the following now clearly in the pre order traversal the root is the node which is displayed first. So now I look at this particular root node okay this thing is given wrongly so let me go with this only. So what I will do is we know that the root node is always displayed first. So now this must correspond to the root then what we do is we go to the in order traversal find out where that root node exists this is where the root node exists. So what happens is in order traversal the left sub tree nodes are before the root and the right sub tree nodes are after the root. So what do we have now we have now that d g b e correspond to the left sub tree and f h c correspond to the right sub tree. We will left sub tree and this is right sub tree we know this information. So I go back to the pre order traversal. So this corresponds to these four nodes that means now I have b d g e and d g b e as the this is pre order traversal of left sub tree and this is the in order traversal of left sub tree. Now again what do we have the first node in the pre order traversal must correspond to the root of the left sub tree. So I mark this okay. So what does this mean now d g here belongs to the left sub tree e belongs to the right sub tree. So once again I mark this okay in the pre order traversal. Now what do we have we just doing the left subtree now. So it has d g as the pre order and we have d g also as the in order traversal okay. So we know that d has to be root right and it is in the same order therefore this is the root that means in the in order traversal what does it mean now g is part of the right sub tree. Therefore now we can claim what is it that we have done we had a here then we had b which was the root of the left sub tree then we had d and g which were part of the left sub tree of a okay. So what have we done now we were essentially constructed this part of the tree. Similarly here what do we have now if you look at the right sub tree of denoted traversal it is only e and there is only one node therefore it has to come over here. So in much the same you can go ahead and construct the entire binary tree and now you can kind of convince you can convince yourself that given the pre order and in order traversals of a right sub tree of the right sub tree. Given tree given binary tree the tree can be uniquely constructed okay can convince yourself about this all right I would like you to go back and see how you get constructed unique tree from do this as a homework from in order and post order okay. Now those of you want to be more challenge can you derive a proof? So in order to do this you have to show that this proof can be done by construction and using induction that pre order in order will give you a unique tree okay. So let us next what we will look at is so we have looked at the binary tree where binary tree is one where every node has two children and both the children are binary trees it may also optionally have only one child or it may absolutely have no children even an empty binary there also exists empty binary trees this is what we have already see. Now today what I am going to talk about is I am going to talk about another type of application of binary trees called the binary search tree. Now what is a binary search tree a binary search tree is it is also a binary tree it may be empty if it is not empty then it satisfies the following properties every node every element or node has a key and node two elements have the same key what is the meaning of it that means the keys are all unique and there is another property the keys in a non empty left subtree must be smaller than the key on the root okay. The key in a non empty right subtree must be larger than the key at the root the left end right subtree are also binary search trees. Now let us take an example and see how this will look like. Let us take the same letters of the alphabet let us say I have notice that all the keys are unique let us say each one of the letters of the alphabet is a key then the key is the number this is a binary search tree. Notice that all nodes on the left subtree have a key which is smaller than the root I am assuming lexicographic ordering here and all the nodes on the right subtree have a key which is greater than the root and that is true of every node for example if you take the node B here left subtree a smaller key values then B right subtree has larger key values then B here again smaller than G and right subtree has larger value than the given node interestingly this is also a binary tree. And by the same token we also have that this is also a binary search tree and this is also a binary search tree. Now what we will do is we look at the subtree so basically why is this also a binary search tree and this is also a binary search tree by definition what do we have a binary search tree has keys that are unique node out about it all the keys are unique and what did we say elements on the left subtree binary search tree can also be empty and elements of the left subtree should be smaller than the root which is smaller than the elements of the right subtree and this is true for this tree and it is also true for this tree these two trees are what we call skewed binary search trees. What is the application of this binary search tree for example you can put the role numbers in a class in a binary search tree and search for a particular if you want to find a marks of a particular student you can find the marks of a particular student using a binary search tree. How would I search now this corresponds to the root suppose I find out what was the marks that a obtained in this tree then I would give the key and say key is a go back let us say there is additional information along with here only given the key here marks and other things are stored it stored over here I compare a with d it does not match then clearly but a is less than d so go down the left subtree compare with b a and b again is not match but a is less than b therefore I go down it is left subtree and I find this particular node and I can retrieve all the information corresponding to the given node this is about searching the operation of search if I want to perform. Now if I want to insert a node what happens now let us say I want to insert f okay in e g h is what I have suppose I want to insert the node f okay then I compare with the root where should it go now compare with the root then clearly it is not matched but f is larger than d so I go down the subtree then I compare with g g and f are again unmatched but clearly g is larger than f if I go down it is left subtree I compare with e e and f are again not matched but f is clearly larger than e therefore I go down here and I insert f over here okay now suppose I wanted to insert e can this be done I compare e with d again starting from the root clearly e is larger than d therefore go down the right subtree I compare with g g is larger than e therefore I go down it is left subtree I found a match but since already the binary search tree has a key e clearly I cannot insert the node e okay because the keys in a binary search tree must be unique okay this is a very very important property keys in a binary search tree must be unique this has to be satisfied now suppose I want to delete the node g so what are the operations we are looking at search we are looking at insertion we are looking at deletion this is also common right a student leaves a program and you want to delete the particular name from the list okay suppose you want to delete the particular node g then what should I replace it I should replace it with some node such that the binary search tree property is not satisfied we can do one of two things we can replace suppose I want to delete g I can replace g with either the largest node on the left subtree or the smallest node on the right subtree why do we do that because then we can guarantee that the tree will still remain to be a binary search tree so this is exactly what we do so I put f over here largest node on the left subtree so I find out so I go to the right most node on the left subtree find that and put that node over here delete it but what might happen is this node might have some left children but since clearly this in this particular case f did not have any left children but suppose f had some left children then what do I do I take these left children make it the right children of e because that is okay because all of them have to be larger than this given node okay so this is the operation of deletion so the operations on the binary search tree that we would like to perform are insertion search insertion and deletion okay so these are the three operations that we would like to perform okay here is one same example I have done it with numbers in the slide over here to show the operation of insertion notice how the now let us see how do you get these skewed binary trees basically if I start out with let us look at the insertion over here let us say I have been given 8 5 7 the keys 8 7 8 5 7 4 and 6 14 let us say 13 18 and 16 okay suppose these keys are given and we want to insert them into a binary search tree this will give us an idea how why these trees become because we are always inserting it just let us go through this example the I given a partial example in the nodes so I 8 here so I there is initially an empty tree okay so into the empty tree I insert the node 8 then next I come across the node 5 8 5 is smaller than 8 therefore I make it the left sub tree notice that again it is being inserted as the leaf node then 7 for example becomes the again you compare with 8 7 smaller than 8 greater than 5 therefore this has to become the right sub tree of this 4 compare with 8 smaller but smaller than 5 therefore 4 go over here 6 compare with 8 compare with 5 compare with 7 and then it comes over here I am going to use a little here compare 14 and 13 18 and 16 okay always what we have seen is in this process all the nodes simply get inserted at the leaf node at every stage now suppose instead giving this sequence I had given you this sequence 1 2 3 4 5 then initially there is an empty tree I insert 1 then I insert 2 right slotted in this then 3 then 4 and then 5 so this is how a binary search tree can become very cute so let us do some analysis of the complexity of this binary search tree what is the cost of search now how expensive can search me okay so clearly in the worst case what is it going to be I may have to traverse down the height of the tree now what is the height of the tree now basically you come compute the path from length of the path from root to the leaf node 1 2 3 okay all right so the worst that you have to do suppose I want to compare with 6 if I if the key that I am searching for is 6 therefore the complexity becomes the the height of this tree is 1 2 3 but after make 1 2 3 4 order height plus 1 so I have introduced a new concept today the height of the tree okay so the height of the tree is the number of comparisons plus 1 is the 2 maximum number of comparisons that you may have to perform if you want to search for a given node and this is also true for deletion right because I want to delete or insert for example I have to come down and then move back up in deletion whereas in insertion again insertion happens at the leaf therefore I have to go down to the height of the tree what can the height be inì¹œ the worst case height what can be in the worst case the worst case what can be in the worst case in the worst case what can happen is you can have a completely is q 3 and the height can be n minus 1. If n is the number of nodes in the tree, nodes then the height of the binary search tree can be as to all as n minus 1. So, when you talking about order of h plus 1 comparisons in the worst case, you have to do order n comparisons in the binary search. So, this kind of completes the and I have just let me give you a small implementation of insertion. Here is a small segment of C code, C plus C code sorry which is given here. So, let us say that you have a pointer to tree as we add in the half-man tree. So, what we are doing over here is if tree is equal to null, then what are we doing? We are creating a new symbol in this particular case, I am assuming a binary search tree which only has numbers. Otherwise, what am I doing? I am comparing if the if it is not a empty tree, I compare with tree symbol and then what do we do? Be inserted if it is I go if it is smaller, then you go to the left sub tree and then do the insertion again insertion is called recursively over here. Similarly, otherwise if letter is greater than v given node, then what are we doing? We are inserting in the right sub tree. Notice that we are not doing anything if the symbol is already present in the tree. So, this is a very important point in binary search trees. So, this is something that is a small segment of code over here, a recursive implementation of the insertion into a binary search tree. There should be a correction here, this letter should read number, please correct this, it is else if number less than tree symbol, number less greater than tree symbol. So, this is about binary search trees.