 So, in the last class we looked at what an abstract data type is and what is an abstract data type now we said the idea is to use data structures, use a defined data structures and not even if you have user defined data structures, you also define operations on these data structures and just like when you write procedures for example, to find the sum of n elements as we did some time back, we basically have a procedure that operates on an array and gives you the result. So, next thing we have what we can do is we can have that is called the abstract data type or something like this. I can define it as an ADT let us say abstract data type and let us say I want to define complex which is the example that I am going to take now. I can define some private data here and this data organization is depending upon our convenience we will see this example whether I want to use the here basically we use the basic data types like the integer float and character and array for that matter pointers to describe the private data then we have a set of operations and these operations are what is visible to the outside world and these operations operate on this private data. So, this is how a ADT is defined. So, basically when you looking at an abstract data type we are talking about something like this. I have a mathematical model and an informal algorithm that operates in the mathematical model as we saw in the context of sets and this becomes an abstract data type with a civil language program operating on the data that is within the abstract data and it finally, it goes to higher level language you are going to use the basic data structures that are there make them you are user defined data structures and you operate higher level language program. So, let us take an example I am using C++ over here notice that we have switched from C to C++ we have already gone through a basic overview what C++ is and here I have defined what is called a class the equivalent of an abstract data type is the definition of a class we have a class complex here and remember that in C or C++ it does not support data structure called complex. So, I define a complex data structure notice this over here there are two private variables implicitly if you do not say private colon or whatever it means that it is by default private that means these variables are not accessible to the outside world flow trail comma imaginary then what do we have we have the public a set of functions which can operate on this data complex this is like an initialize over here for example, they are called constructors basically I can pass argument a real and imaginary value which are both the flow type and it will create a object of type complex is also called objects. Then notice that what I have done I have taken the operator plus and side this operator now should mean what do you mean of this operator this operator takes this particular object which is notice that real here is being defined and this real is added to the argument that is being passed which is also of type complex. So, it adds that particular argument and returns the sum of the two complex numbers similarly you have something which is the operator minus when it is complex should mean this. So, what we are saying here is we know that by the definition of plus and minus you know with respect to integer x n let us say x equal to 4 comma y equal to 5 then if I say let us say in z and z is equal to x plus y x plus y then you know z equal to the value of z will be 9. So, it knows that when this plus is used here that when both are integer this what we will do suppose I had in u v u equal to 2.5 and v equal to 1 times 0 or something like that then when I say when I say w I am sorry float here not in float here and I had a float w and I say w is equal to u plus v and the value that w will hold is 3.5. So, clearly what is happening is notice that already the plus operator in C or C plus plus is already overloaded what you mean by overloaded here in this context it notes that the operands are integer and in this case it knows that the operands are float. So, now what we will be doing here in this example is that it is already overloaded we are overloading it one more type of operand and what is this type of operand complex that is what we have done here. So, another one for multiplication multiplication of two numbers here is something for scalar division and there is a operator for division and notice that one is for scalar division and one is for division by complex number itself. So, basically depending upon the context it figures out whether this is a this operator overload or this operator overload. So, basically if I pass number which is a float then it will know that it has to do scalar division but whereas here when I pass a number which is complex it knows that it has to perform complex division. So, this is something that you can define now some we have written a whole lot of things over here we also wrote a print function which is print real plus I b and here is a main program what have we done notice the way we have defined complex a of 0.5 comma 0.5 let us go back to this example we had a constructor here complex of float real comma float imaginary complex bracket whatever is the default values what will take here here in the hand we are assigning the real here to whatever has been passed and imaginary to what has been passed as argument. So, that is exactly what we do in here. So, when I am defining here in the main program I am defining complex a of 0.5 comma 0.5 b of 2.5 comma 2.5 c is equal to 0 c is this like initializing I have int x y and z I have written a simple small snippet of a program here c is equal to a plus b x is equal to 4 y equal to 6 there is equal to x plus y notice that x and y are integer here here a and b are complex. So, here it will perform complex addition, but here it will perform integer addition. So, let us try to run this program let me just run this program for you. I hope you can see it I have already written this program here I will just cat this I put an extension. So, this is the same program which you saw in the slides here the same program which has been written and you see that the classes been defined here just like what I showed you there is a private variable and then there is operator overloading that happens. Then I compile this in the usual way what do I do to compile. See I am writing the output to a bin directed this is the source directly here this one advise that it is always good to put all your source programs in the source directly and execute to pulse in the binary directory bin directory and object files in the OBG directory documentation and a doc directory and so on. So, I am doing this. So, it compiled the program let me run this now. So, what is it do here notice that it is giving you 3 plus I 3 because we had 2.5 plus 0.5. So, that was the addition that was being this Z is equal to for example, C is equal to A plus B and Z is equal to X plus Y when I am getting the output from C what are we doing we have C dot print this what we are doing over here. So, it prints the value of C and that is 3 plus I 3 and then we also we also see out this is a standard output function in C plus plus and you find that Z is given the value of 10. What is important to notice the plus here is done with respect to complex here is plus which is done with integer these are already available to us from the C plus plus compiler here is this operator here plus being overloaded is what we defined in this piece of code over here where we define the entire complex ADT. So, this is the point of using complex using abstract data types the big benefit of using abstract data types is that now I can write you know if you are a electrical engineer for that matter you may want write an FFT program which uses complex to do your FFT algorithm and you can treat it each one of those you can do the addition using in much the same addition subtraction and so on and so forth. So, this is about how we what I have shown to you so far is simply a way of creating a new user defined data type with operations defined on it you already had the compiler already provide for you integer and float with operations defined on it and what we have done is to this we have added the complex data type on which we are defining a set of operations. So, this is the big thing about abstract data types with operations defined on them. There is another big very big advantage that we also see as we said here when we say class complex here we have this private data and what is interesting is that we can the operations are actually defined only on the private data the implementation of the ADT and what I mean is that how complex has been stored inside that data structure is completely hidden from the user and the data cannot be accessed directly the implementation of the so what is interesting is that the way we are implementing the data type the private data type for example today we are used an array tomorrow I am using a link list as long as a key the operations should be the same without changing the very operations access the elements you can change this at a user will not even know that you actually change the implementation inside. So, let us look at some standard abstract data type the first thing is what is called a list do not confuse with the link list is just a list list of elements will worry about how the implementation is done later the ADT stack and the ADT queue so let us look at this list what is a list now the defined the ADT list as a sequence of 0 more 0 or more elements of a given element type. So, it consists of elements a 1 a 2 a 3 up to n n is greater than or equal to 0 and a i is of a particular element type n is the length of the list n greater than or equal to n 1 first element is a 1 and last is a n this is the definition of a list. So, notice we are not talked about anything about the implementation how are going to represent this list we are not going to talk about it all that we are saying is is a list of elements which I need to represent and they are for example, they can be list of jobs it can be list of grocery items it can be a list of items in a set or it can be you know something that I want to use for if I want to do something like infinite precision arithmetic each one of them might correspond to a digit list of the list is used to represent a very long number and each element of the list corresponds to a digit in the number. So, you can do anything with that for that matter how we want to represent these list. So, let us look at what are the operations that you may like to perform. So, let us take look at what are the problems you have a list of jobs list of grocery items representation of sets list can be used to perform infinite precision arithmetic as we say the operations that you would like to do is we say suppose p is a particular position in the list. So, when you talking about a list here we just said I have a list a 1 a 2 up to a n. Now, a new element comes along let us say b or something I want to insert it into the list. So, I want to insert it let us see after some a l l is the position and I want to put it here and then make this list this will become a n plus 1. So, I might want to insert an element at a particular position in the list. I want to go to the end of the list where is the end of the list after n plus 1 I want to go to the end of the list or I want to locate an element in the list I want to find the where a particular element is formed let us say I am looking for some x is it where is it in this list I want to find the position maybe it is at 8 and I want to return the position to then I may want to retrieve an element at a particular position. I want to look at let us say a k and I want to say what is there at the kth position in the list what is the value that is there at the kth position. Then I want to delete a particular position in the list delete an element at a particular position and I may say delete the kth element. Then you want to go to the next element what is the position of the next element in the list what is the position of the previous element in the list so on. I want to create an empty list what is the first element in the list and so on. So, these are all operations that I have defined on list I can write or I can also have an operator which prints all the elements in the list prints the element at a particular position in the list. So, if you look at this here drawn this pictorially here this is an ADT list. So, what are we doing things that go into the list it creates an empty list elements are inserted in through the list and here what are we doing we remove elements from the list and delete in locate we find there a particular element x is present the tree element at a particular position p and so on. So, there is how you represent the list ADT. So, there is some internal representation we are not talking about what it is you can either create an empty list or you can insert an element to this. So, these are the operations which become visible to the outside world. So, let us look at an implementation of this now how do I represent the list. So, now we have already seen when we have large we assume that list list is made up of a set of elements of the same element type that is our definition if you go back to this definition over here even A 2 A 3 are all belonging to the same type is grocery items it is a list of jobs it is a representation of elementary set of the same type or as an infinite position arithmetic it corresponds to the digits that make up a given number. So, let us see this what we have in terms of representation. So, I need something which will I need a data structure that will it is available in the programming language which will enable be to represent elements of the same type. So, we have already seen two such data structures one of these two data structures that we have seen one is the array and the other recursive implementation which is the linked list at distinguish between linked list and the list is a simply a list of items. So, but we have here for second third so this is where you find the list and this points to last which is the last element in the list rest of it is empty. So, you fix have some fixed array size and say this cannot grow more larger than this and then you keep putting element into this particular list. But the important thing is the list is accessible any element at any position should be accessible that is what all these operations that we have defined help us to do. So, then what we have is we have a header here the if I am using a linked list representation on the other hand the access is where the header, but as far as the user is concerned he should not be able to he should not know how the implementation is done he does not have to go through the header or whatever. So, locate the element at a particular position p it should return the element at the particular position p. So, let us see so what I am saying is when you are looking at this position p over here that I am using an array representation the position p corresponds to an index in the array whereas here when I am talking about a position p here that is let me give a slightly better example. So, there is a header and this header let us say points to a 1 a 2 and so on and let us say this is a n. Now, here I might have a position p when p points to a particular element in the list we will see how this both is implementation certain in one case it is a pointer and this in other case it is an index into the array but the way we will write the we will implement the ADT is the user does not know he knows there is a type called position just like you know there is a data type called in which are there is a data type called card there is a data type called float here you have a data type called position and that is what he will use in the program. So, let us look at this implementation I have used a linked list representation in this particular in this particular representation of this particular list ADT here. So, what am I doing here I am saying cell pointers cell type is defined here which has an element type which is a type value and what is element type I am using integer elements for the timing and then what we say is that we have a type therefore here which says pointer to the cell type is a type position that is all and here what have we done here element type which is a type integer here is value and so element type is something that the user will define. The user will say you as the designer of the ADT will say it is a list of element type element type definition comes from the user. So, you will have a separate dot h file which will tell you how the element type is represented and position corresponds to the next again because the next element is again a pointer is what we do. So, let us look at this so what do we have now when I look at a private data I have a position which points to the list head then we have something that creates an empty list insert list element x at position p delete list element at position p delete whatever is there at position p what is the position of the first element what is the position of the last element what is the position of the next to the position p print the entire list if this is a partial implementation that we have. So, what are we doing here I do something clever in this to reduce the computation time that is required let us see what I am doing here I am creating a list head creating an empty list with one element this what this means new cell type and then I am saying list head next points to not so it is what I have done is I create a empty head node without anything and this is the head up I create a empty node I do not have anything in that. Then what I do is when I am looking at element type to be inserted I do something clever what I do is here if you notice what are we doing we are saying we are the notice that there is an assignment here temp is assigned to p point next p point next I am creating a new element here then what are we doing we are saying p point next point next equal temp and p point next is equal to x. So, what are we doing here let us go through this if I want to do it pictorially what I am doing is I want to there is an insert here x at position p stilling. So, what we are doing is we are saying so let us say this is position p what we do is we assign temp as store in this p point next then what we do is we create here so that means what this is a list which was like this and so on some set of elements I wanted to insert it over here. So, when we do is I create here a new element and put that element here and connect this back. So, this is the new way which I am adding although I said insert the element here what we do is we keep it as the next position we will see by this is useful by we not inserting it at that particular position itself this reason for doing this because what happens is if I do this then if I want to delete at position p means what I have to take this pointer here now notice that I have inserted this element. Now, if I want to delete an element at position p means what lose the element that has to be removed therefore, all that I have to do is point p to p point next point next. So, it is a very single operation of here notice I do not have to do any more bookkeeping. So, these are clever things that we do so what did I do I wasted one position here when I created the make null created the empty list I made one wasted position and then what happens when I am inserting I am always inserting for example, p here a here for example, I insert it over here then I take this temp and then point this is pointing to this guy then I correct all the pointers the advantages when I am doing deletion here I do not have to do any bookkeeping I know that actual location of the element where I have inserted is p point next. So, I just have to do this I just spent of pointers over here. So, that the list looks like what we want to have. So, let me example this exactly what is showing over here. So, this is something which is very nice about doing your own implementation why is this ok you know what happens to the user of the program because you are not giving access to the data structures which is defined within the class you just do not have to worry about it you know that the you are doing the bookkeeping and as long as the operations which you have defined within which operate on the ADT are consistent with each other you do not have to worry about it. Similarly, here going to the end of the list means this is go still the position is null ok then move one print list and so on ok. Now, what I am going to do is I am going to show you again the running of this program let us go to this here. So, I have here a program let us say list at two different I want to show you this let me see we can increase the terminal preferences ok. So, let me just increase the font a bit so that you can see bit better ok yeah now this is better all right. So, let us look at this let me do the less I have two different implementations list ptr dot c and this is the one which I have just put in the notes over here. So, I have all these operations make null insert, retrieve print list and so on ok. Now, I want you to look at these two here there is a main over here notice that this is a main function I want you to look at this main function here it knows that there is a abstract data type of type list. If you notice this piece of code here we create an empty list then I am initializing the elements in the list I am just saying keep on inserting elements at the end of the list print the list, divide the element at the first item in the list print the list delete it and so on ok. Now, I show you another implementation of this this is list array not c and here what we have done is notice that the position then becomes an index of type integer then notice that the functions look exactly identical I have not changed anything here all right. Then what I do in make null I am creating an array of size 100 which is of that type cell node there and then what am I doing insertion operation is different but it takes the same arguments ok the position as far as the user is concerned like when you define type int x do you know how int is represented you do not worry about it. So, in much the same way here here the position is an index into the array a load it was a pointer into the list and all the operations are defined. Now, I wanted to look at this main program this main program is identical to the earlier main program where I had list implemented as a pointer in terms of linked list here I have implemented using the array if these are identical programs let me see if I can put them in the same. So, what did you do initialize is the list so 0 1 2 3 9 deleted the first element in the list then again we deleted the second element in the list and you get this result. So, what do we expect when we run the list pointer representation it should give me identical results and notice that it is not changed ok. So, there is the fun part of actually using ADTs the fun part is that this representation that you have you can change the way the functions are implemented can be changed by the define of the ADT. But the user of the ADT need not be aware of it. So, for example, suppose you are a you know you are writing code for a you are writing some code to define and so initially you can come up with a poor definition of an ADT the algorithms need not be very efficient. But after we can make your algorithms which operate on ADT is so much so much more efficient and the user need not to be aware that you actually change the representation totally. So, this is the fun part about the defining abstract data types. So, what we did so far was we defined an ADT called list and we talked about two different implementations of the list and we wrote a main program which operates on the list and we saw that the main program is actually independent of the implementation of the list ok. So, this is the big advantage of ADTs as I have already mentioned. Now, I only take some homework back there are some list problems here. Now, suppose we use this list to store sets we already said it can be used to store sets. I want you to think about performing union, intershared section, set A minus set B and then I also talked about infinite precision arithmetic let me say what I mean by that. So, suppose I have very large number of digits you know is beyond the precision of the computer. Then can you perform use the list to perform the something like this let us say two very very large numbers can you perform arithmetic that is each element is stored as a digit in the list. So, every list element is a digit and I want you to add these two then take the carry add these two and so on addition subtraction division multiplication and now the thing is suppose I have a list with something like this there is already list this kind I want you to remove all the duplicates and give me a list of this ok that is this is this is the existing list that I have and notice it you do not have access to the way the list has been represented just using the list operations here also just using the list operations from given that these are the elements in the list I want you to come up with this. Similarly, from this I have two lists which are given like this and I want you to perform the arithmetic. So, let see how you can do this ok and also converting an on an order list to an order list. So, we kind of complete this first in this introduction what did we do here. The introduce you to abstractly types we talked about an example on complex and then what did we do we talked about the standard data type list which can be with a large number of operations and we finally, conclude with one example where we had implemented a list two different implementations where the same main program which operates on both these implementation of the list is what we had looked at. So, next we will talk about stacks and we will stop here ok that will be the next lecture. Stack is another abstract data type. So, we will stop here for now.