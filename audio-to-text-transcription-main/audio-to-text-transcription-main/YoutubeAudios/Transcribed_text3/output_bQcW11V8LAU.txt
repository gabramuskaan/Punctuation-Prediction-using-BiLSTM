 In this lecture, we are going to learn about traversal of graphs. And you know, you remember when we talked about trees, we talked about, you know, a tree was given like this and we said there is a pre-order, there is a post-order and there is an in-order traversal of the tree. And then we said pre-orders when you mark the node the first time you see it, in order is the second time you see it and post-orders the last time you see a node when you are walking around tree from left to right. If you remember, this is what we talked about different traversal of trees. We also talked about a level order traversal of the tree. All this was not discussed in great detail for example, if I have a tree like this, then let us say 1, 2, 3, 4, 5 and 6 would correspond to the level order traversal of the tree. The tree was in a sense a little easier for the simple reason that we had a designated node which was called root and from the root we try to access the other nodes in the graph. There is only one node through which you can access the other nodes. But in the graph as we said, there is nothing like hierarchy of nodes. But nevertheless my objective may be to see what are all the nodes that are connected in this graph. And somehow reach all these nodes in the graph. How do I go about reaching it? When I started a particular node, how far can I go? How deep can I go? So there are two types of traversals and graphs. One is called the depth first search and the other is called the breadth first search. Basically the idea is to visit the vertices and oxafagraph in a systematic fashion. That is the objective of these two traversals. What do we mean by systematic fashion? We will see in a little while. The depth first search is a kind of a generalization of the pre-order traversal of a tree and it forms the foundation for a large number of problems which we will see. So what I am going to do is I am going to take an example graph here which is a directed graph. Let us say these are the nodes that we have A, B, C, D, E, F, G which are connected by directed edges. So let us say it does not matter which node I start the traversal from. In depth first search we try to start with this particular node let us say it what are the edges that are connected. Let us assume lexicographic ordering. A is connected to B and A is also connected to D. This is what my adjacency matrix or adjacency list will tell me. Similarly B is connected to D and B is also connected to C. C is connected to A and D. All this information will come from your graph representation. So I start with this particular node and we try to go as deep as possible. Let me see that we try to explain what this means. I start with A let us say the first node that was listed in the graph. Assuming lexicographic ordering was B. So I go to the node B and then from B what I do is I try to reach the node that it is basically the ideal D. Start from A go to B, from B go one level down, go to C, then from C I go to D, then from D notice that all the arcs are only towards D and it is not possible to go any further. But I want all the vertices in the graph to be visited. So what do I do? I go to the next vertex that is there. I start with E, E is connected to F and from F is not possible to reach G which is the last node in the graph and all these other nodes have already been visited. So I then I finished with F, I go to G from E and then the graph traversal is complete. So what does it give me? It gives me what is called a depth first spanning forest. Starting at the node A, I have A, B, C, D, one tree here and you know I notice that E, F and G are two trees which are not connected. They are only connected by what are called back arcs and so basically what does it tell me? That going forward from A, I cannot reach the nodes E and F via the other nodes B, C, D, start separately for that. So this gives some kind of an idea of the reachability of nodes from one node to the entire set of nodes in the graph and there are some definitions that coming. You call for example the arcs that connect between a pair of nodes at the same level or across the forest as cross arcs and then edges that go from a level that is deeper to a level higher are called back arcs. Then edges that go from a level from a node that is at a higher level to a lower level when assuming higher level is 1 and 2, 1, 2, 3 for example is a forward arc. So you get some nice definitions of graphs. So this depth first traversal is an important algorithm and this is how this depth first traversal works. So what do we do for every node? Notice that it is very similar to pre-order traversal that you have done with trees. What are we doing? As soon as you see a node you mark it as specific. Then what we do is for if mark of i is unvisited then what are we doing once again? We are restarting DFS at the node which has been marked visit. And so what are we doing now? We keep going through this again and again and we call this depth first search algorithm again. So this is DFS of v for w equal to vertex mark v for each w in l of v which is adjacent to the vertex v. If mark of w is unvisited then you call DFS of w that is the most important point. You try to go as deep as possible. This is the algorithm for depth first search. So initially what are we doing here? We are marking all the vertices as unvisited and for each unvisited vertex we try to go as deep as possible in the depth first search algorithm and we just saw an example in this particular graph. So starting from the vertex a we go to b from b you can see from c you can reach d assuming that we have represented the graph in a lexicographic order. And after d we notice that all the arcs are only coming into the vertex t and you cannot do anything more. Therefore you start with the next unvisited vertex in the graph which is the vertex e and then try to reach as far as possible. What are the applications of first of course the complexity analysis it takes about order e time I am sure you guessed it because sometimes you can have arcs which are number of edges can be less than the number of vertices is generally less than the number of edges and therefore the time complexity is can be as large as the number of edges in the graph. What you get the result is a depth first spanning for us. What are the applications of this there are some interesting applications. Let us say you want to how can you use in what application can I use depth first search that is the question that I want to ask. Let us say you know you have you know all of you register for courses from semester to semester and let us say these are the courses c 1 and c 2 and c 3 means c 1 and c 2 are prerequisites for c 3 and c 4 has a prerequisite of c 2 and c 5 has a prerequisite of c 3 and c 4 which means you must have done c 1 and c 2. So somehow is it possible that when you try to register for a course it looks at the list of courses that you have registered and can come back and tell you whether you are eligible to register or not. So we need some kind of a ordering this ordering is what is called the topological sort and here what am I saying. So c 5 this is one topological order c 5 requires c 3 and c 4 and c 4 requires c 2 and c 1. So c 4 tells gives me an ordering telling something must be done before this particular task. So what we can do is we can go back to the use the depth first search and instead of outputting a given node as soon as you see it you can give it in the reverse order of the depth first search. Same depth first search algorithm. So what we do over here is that so this gives you that particular order if you use this particular algorithm here. So what are we doing here this topological sort algorithm mark the particular vertex is visited. Then for each vertex w and l of v if m of w is unvisited then top sort of this notice that v is output last that is the most important point. I might have started the topological sort from either of these two vertices and then you print them in reverse order the last vertex that is going to be listed as c 5. Once the c 5 and then finally, it prints all of these and notice what does it tell me here. It says c 3 and c 1 must have been completed before c 5 and c 4 and c 2 must have been completed before c 5. Therefore, if you want to register for the core c 5 you must have completed the prerequisites which is c 3 c 1 c 4 and c 2. That is the most important. That is one application of depth first search. Now, I am going to leave you with another application of depth first search. These are called the articulation points on a graph. An articulation point of a graph is a vertex such that when we remove v all the edges incident upon v the graph g is broken into two or more pieces. So we want to find what are the articulation points on the graph. How do you go about doing it? If I remove the node a the graph gets disconnected. I am using an undirected graph here. Similarly if I remove the node c the graph gets disconnected. If I remove the node b nothing happens because the rest of the graph is still connected as one piece. So, how do you find that? There is a nice dfs using depth first search. There is again another algorithm that you can develop and what we do is suppose I am starting the depth first search here. I give it a number one. This is called dfs numbering. Then b is given a number two. d is given number three. E is given number four and so on and five six and whatever. So, what we try to do is once we have done the depth first search and we got depth first spanning for us. We also keep track of another number. We say using the graphs which are not the tree graphs. What is the lowest dfs number that I can reach? So, what is the tell me here? If I look at dfn of b here is two. But using a back arc I can go up to the vertex a. Similarly for d its df number is three but I can reach I can go back to one using the back arc. Similarly for the vertex E its df number is four but I can reach one. The df number of a if you notice is one and it can only reach up to one. Similarly for c and n and so on. See you notice it is five. So what we do is it is once you have done this you found the df numbers based on the way the vertex is accessed to the dfs call and you have kept track of low here and you have formed this particular graph with all these additional information. You look at a particular node and then check whether from that particular node you can reach a node with a lower df number. If you can reach a node with a lower df number that node is not an articulation point. Whereas it is equal to that for example I can see over here and a over here, a and c correspond to the articulation points in the graph. So this is another application of depth first search and you will find strongly connected components. There are lots of nice problems which can be done with depth first search finding cycles and so on. Bread first search is another algorithm where we try to search as broadly as possible. So let us look at this graph again here. So let us say this is the graph that I have. I have taken an undirected graph because for the depth first search we took a directed graph. So what do we do now as widely means again if you assume lexocographic ordering in your vertices. So let us say I am starting with a then as wide means I go to b then I go to d then I go to e then I go to c. Then once I have exhausted all these vertices I start from b and check if there are some vertices which is disconnected to that are not part of this bread first spanning tray or spanning forest. And then I try to again connect them notice that is the end year already completed but only from c I can reach fng so again I do as by d is possible. So now depth first search indirectly when you remember in depth first search we meant as deep as possible. Therefore it is a recursive function call if you remember here. Therefore it uses a stack implicitly to solve this problem. Here on the other hand what is it that I want to do going back to this particular graph. I visit the node a then I do as broad as possible then I have to come back to b and check which are the nodes that are easily b d c for that matter. So basically I need to keep track of the nodes that have been visited. So what we do is in breadth first search we use a q data structure. So we put all the starting with the node a for example we initially of course we assume that all the vertices are unvisited. We mark the given work vertex is visited on q in particular vertex. And then while the q is not empty we take the first element in the q. So what are we doing again going back to this example I am taking the first vertex putting it in the q. Then after putting it in the q then what do we do? We d q the element for each vertex y that is adjacent to the vertex x we are if mark of y is unvisited then you make it visited and then make that edge part of the tree. Then you keep then you unq the vertex y repeat this process and you repeat this until the q becomes empty that is the most important point. So what are we doing once the q is empty what is that once. So what do we do we take a is unq then d q a then you put b d c in the q then we look at d here there are no adjacent vertices which are not as part of the breadth first search. So I do not need to worry about it similar with d similar with e and finally come to c. Then I unq fng and then I make these edges as part of the tree and we are done. So what is the advantage of this there are many application breadth first search you can build what is called a breadth first spanning forest then we cross edges actually correspond to cycles. So we are going to find the closest ancestor and that will give you a cycle. A breadth first search is also useful for designing finding out what is the diameter of graph the longest path between a pair of nodes. So this is kind of the these are the so what we have looked at in this lecture is a set of algorithms which use depth first and breadth first traversal on graph. So that and you notice that these are just algorithms by which I can reach as far as possible all the nodes in the graph I can also find the path between a pair of nodes in the graph and once I have things like a breadth first search spanning forest and I want to send information from one node to another then I can find out what is the total path length to reach these various nodes in the graph. So the references for this course I have essentially used all these references various parts from all these references and I hope you enjoy doing the assignments and the problems. Thank you.