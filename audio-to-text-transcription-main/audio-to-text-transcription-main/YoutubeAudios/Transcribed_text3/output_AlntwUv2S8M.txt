 Welcome to this module on structures. In this module we are going to look at how do we use structures and how do we use pointers to structures because this is something that comes in handy in many places. Even in the course later you will be looking at the notion of link list and so on and for that you need not just structures but also pointers to structures. So, in this lecture we will go and look at this basic data structure, basic structure called complex numbers. So, C does not give you a data type for complex numbers. There are a few languages which give you that but C does not provide you that and one way to get complex numbers is by faking it. What we will do is we will define a structure called complex and the complex structure it has two fields or two members namely real and imaginary. So, we are going to keep this as our complex number. So, a complex number is going to have a real real member and an imaginary number and from now on complex is a data type that I can use. I can take this data type, pass it on to functions, pass them back from functions and so on. So, I am going to write a function called sum which takes two complex numbers m and n and returns a complex number and we are also going to write a function called product which again takes two complex numbers and returns a complex number. So, this in some sense is similar to passing two basic data types and getting a value out of it. So, C does not prevent you from passing structures to or back from a function. So, let us look at how this might be done. So, in the first line here we do declaration for four complex numbers a, b, c and d and we are going to take the complex number c as the sum of the complex numbers a and b and the complex number d is supposed to be the product of the complex numbers a and b. So, we first go ahead and scan the real and imaginary parts of a and b and once that is done I would like to do something like this c equals sum of a comma b. It should add up the corresponding real values and put it as c's real value take the imaginary values of b add it up and put it to be put it to the imaginary value of c and so on and I may also want to do things like product of a comma b print sum and product. So, this is something that I want to do let us go and see how the sum function and product function are going to get written up. So, the sum function is supposed to take two complex numbers m and n. So, inside we have a local variable called complex p. So, p is a local variable the p's real value gets m dot real and n dot real added up and p's imaginary value gets m dot imaginary and n dot imaginary added up and you return that to the caller. So, if you notice p is returned to the caller here. So, you can see that here p is returned to the caller if you go back to the caller the caller is expecting something of the type complex numbers the left side is a complex number. So, everything is good there. Similarly, if I want the product so we know that product of two complex numbers is given as follows. So, the real part comes from the product of the real part minus product of the imaginary part and the imaginary part is the product of the real and imaginary combinations added up together. So, this gives you the real part and this is the imaginary part again we have a local variable of the type p and you compute what should go into p dot real and p dot imaginary and you return p. So, you are returning a complex number and when you return on this side the products complex number. So, this is a complex number that you get gotten return the real part will get copy to D's real part and the imaginary part that you return will get copy to the D's imaginary part. So, this is the way to pass on structure variables to functions and get back structures from functions. So, as of now we do not have a mechanism to I did not show you a mechanism to pass on pointers to it. So, we will do that now let us look at this basic thing right. So, what we have is we are going to have point type p t 1. So, point type point 1 and star p t r. So, let us take this a little slowly. So, we already know point type is defined to be struck point. So, point 1 is a variable of the data type struck point and star p t r on the other hand is a pointer to the structure of the type point. So, it is a pointer to point type data type right. So, here this is like a basic variable and this is only a pointer. So, when we say point 1 we actually allocate two members x and y and give it to point 1. Whereas, when we say point type star p t r we do not do allocation for star we do not do an allocation for a structure. We just allocate space for a pointer that can point to a structure we do not allocate a structure yet. So, point 1 is make point of 3, 4 this will give you a point whose x coordinate is 3 and y coordinate is 4. Now, you can do things that you did on basic data types. So, p t r is ampersent of point 1 takes the address of the structure point 1 and assigns it to p t r. Remember it is not taking the address of the members of point 1. It is taking the address of the whole structure point 1 and it is passing that as the value to p t r. So, at this point p t r is going to point to the structure. So, if point 1 let say point 1 is of this type. So, this is point 1 it has some x and y coordinate and this whole thing is going to sit inside some memory it is going to sit somewhere. When we say p t r p t r is also going to get one memory location and as of now it is not pointing anywhere. The moment you say p t r is ampersent of point 1 it would start pointing to the structure here. Actually technically it points to the first byte of the first member of the structure it goes to that location. Now, we want to know how to dereference this like we did for pointers in basic data types and the way to do that is use what is called a star operator. So, in star operator so, let us see what this is doing. So, print f percentage d percentage d star of p t r dot x. So, p t r is of the data type pointer to a structure. If I do star p t r I get structure and therefore, if I do structure dot x I get to a member. So, this thing what you see in the blue circle here is correct because you started with p t r which is a pointer to a structure when you do star p t r it actually dereferences the pointer and gets the structure and you are looking at structure dot x. So, it looking at the member x and member y here respectively. So, the parenthesis here is actually crucial. So, the star and parenthesis have different precedents. Therefore, you have to put this whole thing inside the star and p t r should be within the parenthesis but this is sometimes very laborious. So, c gives you another shortcut to look at the member that is pointed to by a pointer of a structure. So, I will repeat that I want to get to a member that is pointed to by pointer of a structure. So, the pointer of a structure is p t r here and I want to get to this member called x. So, one way to do that is use p t r arrow x. So, it is not a arrow symbol you do not see a arrow symbol on the keyboard it is actually a dash followed by the greater than symbol or a minus sign followed by the greater than symbol. So, it is two characters. So, when you say p t r arrow x if you see as if you see something like that what it means is p t r is expected to be of a pointer data type. It is not just any pointer it is a pointer to a structure and when you use arrow you actually get to the member. So, p t r arrow x takes you to the x member of the structure which p t r is pointing to and p t r arrow y will take you to the y member of the structure that p t r is pointing to. So, this is one way to pass on this is one way to refer to the contents pointed by p t r. You can always do star p t r dot x but be caution that you have to use parenthesis around star p t r. So, now let us look at the notion of precedence in association. If I have a combination of various operators what gets precedence and how do I interpret do I have left to right association or right to left association for the combination of operators we look at that. So, both dot and arrow are actually at the top of precedence hierarchy. So, if you have an expression which has a dot and an arrow along with plus and minus and so on dot and arrow gets highest precedence over everything else right. So, let us see a small example here we have a rectangle called r and we have a pointer to a rectangle which is called r p and r p is made to point to rectangle r itself. So, remember rectangle r is supposed to have so let us say this is the space allocated for rectangle r rectangle r itself had something called p t 1 and something called p t 2 and p t 1 in turn had x and y p t 2 in turn had x and y. So, this would be the layout for r r is a variable struct rect is the data type. So, this is the layout for r not for rect and r p the moment you say struct rect star r p r p will get a memory location which is supposed to point somewhere and what is it pointing is it pointing to a percent r which means is pointing to the first bite of the first member of r. So, it is actually going to point to the address where p t 1 x is present inside the inside the rectangle r. So, if I say r dot p t 1 dot x I am referring to the p t 1 p t 1 x member I can also say r p r o p t 1 dot x. So, in this case the weight interpret that is r p r o p t 1 is a structure and you want the member x of that structure. So, this is where the precedence and association comes in both r o and dot r of the same precedence and they go from left to right. So, therefore, the way to read that is first do de referencing with respect to r p that gives us a structure and that structure dot x gives us the member. So, what this does not do is it is not interpreted as I will first take p t 1 dot x. So, p t 1 dot x what is the data ripe for it p t 1 is a structure of the point data type and p t 1 dot x is actually an integer right. And if I say r p r o something there is no r p r o integer because r p is a pointer to a rectangle and rectangle has only points inside it does not have integers inside. So, the association went from left to right and the precedence also went from left to right this is the correct interpretation it is not interpreted as r p r o p t 1 dot x. And you can also put arrows if you are in doubt if you are not very careful if you do not really know what it is doing and if you want to be sure what it is supposed to do you can always put arrows around them. So, in this case by you can always put parenthesis around them in this case you have put parenthesis. So, that r dot p t 1 is supposed to give a structure of the type point and when you do dot x it gives you the x member of that point. And similarly r p r o p t 1 will give you a structure of the data type point and it is now okay to take the data type to do a dot x whereas it would have been incorrect to do r p r o p t 1 dot x right. So, this brings us to the end of module on the structures and how to use pointers along with it there are also lot of things that you have to be careful when you use operators like plus and minus and so on when especially when you have the dot operator and the precedence and the arrow operators. So, remember that dot and arrow has higher precedence over various other things like plus and plus and minus and so on just keep that in mind and when you are in doubt always put parenthesis around the structures that you want. So, this brings us to the end of module and thanks for watching.