 Welcome to this first lecture of the Algorithms course and I am Naren's Fermi from IIT MIRRUS. So, the course is about designing and analyzing algorithms and it is instructive to actually start off with what an algorithm is. Algorithm is a finite sequence of steps that holds on all inputs. We are familiar with algorithms. If you think of it a recipe to cook a dish is an algorithm. The multiplication the sequence of steps to multiply two numbers is an algorithm. And if you look at any program written in any programming language it is desired that it encodes an algorithm. I say it is desired because it is a fairly challenging exercise to ensure that it holds on a finite sequence of steps, holds on finite number of holds in a finite number of steps on all inputs. Now, the question that we address in this course is how do we design algorithms, how do we ensure that algorithms are correct and how do we also ensure that it holds on all inputs in a finite number of steps. And for those of few who may already know some programming it should not have infinite loops for example, and we also address the issue of minimizing the number of steps on every input. This is not a very well stated goal and this is one of the things that we will formalize as we go through this course. These are the main four side of this course. Outland of the course is that we are going to have 10 one hour lectures every week there will be two of them and every lecture will be broken into approximately four modules each of 15 minutes. And at the end of each module there will be some exercise for the learner to go out and try before the next module. The contents of the course are as follows during the first week we will focus on fast arithmetic. During the second week we will work on algorithms for searching and sorting. The third week we will work on greedy algorithms. During the fourth week we will move slowly towards advance techniques for designing algorithms and one of them to address quite a few problems is the dynamic programming approach to design algorithms. And finally we will come to challenging exercises which have immense practical applications like string matching and identifying shortest paths in a network like a road network or any transportation network for example. So, let us start off with the contents of the first lecture which is all about fast arithmetic. Now in these issues we make some minor assumptions which are often verifiable as being satisfied by most processors. We assume that multiplication and addition of two integers can be done in unit time. On most processors this is not a completely valid assumption because it is either a 32 bit integer or a 64 bit integer addition or 128 bit integer addition or a finite number of bits addition that happens in unit time. But for the purposes of understanding the challenge of designing algorithms to do fast arithmetic we relax assumption and we assume that any two integers can be multiplied or added in unit time. So, now here is the simplest of the exercises which we can do very efficiently as human beings and let us see how to convert this into a computer program. To convert it into a computer program we need to ensure that we understand the underlying mathematics first we come up with an algorithm and then you can choose your favorite programming language to convert the algorithm into a program. This is how algorithms and programming are very closely connected. So, whenever you want to solve a problem when you want to write a program to solve a problem we go out and try to design an algorithm. When we try to design an algorithm we try to go out and understand the kind of inputs that we process and identify the appropriate mathematical logical steps to that part of that play an important role in the algorithm and then ensure that the algorithm is a good algorithm in the sense that it terminates on all inputs and it uses as few steps as possible it uses as few resources as possible. These are all the parameters that we will try to quantify as we progress through this course. So, coming back to fast arithmetic let's consider the simplest of problems let us consider the question where the input to a program is two positive integers x and n and the goal is to design an algorithm that will calculate x to the power of n that is the nth power of the given integer x. Now, let's look at a bit of mathematics very simple mathematics which all of us are very familiar with that the definition of x to the power of n is x to the power of n minus 1 that is the n minus 1 with power of x multiplied by x and there is always a boundary condition that x to the power of n is 1 if n equals 0. So, this requires a bit of correction there is an error there this must be 1. So, this is the number 1 and not not 0. This mathematical definition of x power n gives us the desired algorithmic idea and this is implemented in any programming language using a loop control structure whichever programming language it is we can use a counter control loop as in this case where we use an almost C like syntax where you see a variable called counter which is of integer type and we initialize the value which is going to store the variable value to contain the value 1 and then here is a loop which has an initial value which sets counter to be equal to 0 and runs for n iterations at the end of each iteration it increases counter by 1 and value is multiplied by x at the end of it value is returned. Now, this is quite a simple program and let us run a small example. So, for example, let us say I want to evaluate 4 to the power of 3 right. So, this is done in 3 iterations initially value is equal to 1 value is equal to 1 and counter takes a range of values which is 0, 1 and 2 right. Now, when control enters the iteration for the first time counter is equal to 0 and then so, this is a table of values value becomes 4 at the end of this counter is incremented by 1 then value becomes 16 and value becomes 64 in the third iteration that is when counter is equal to 2 at the end of this counter becomes 3 control exits from the loop and the final value is returned and that is 64 right. As you can see the correctness of this algorithm comes from this formal mathematical definition which is exactly what is implemented in the loop in the program and it is clear that this algorithm is indeed correct. However, we are not interested just in the correctness, but we are also interested in how many arithmetic operations are performed and that is really the focus of the next part on this small example right. As we just mentioned the algorithm is correct because of the mathematical formulation of power of a particular number as one is efficiency goes we measure efficiency as the number of arithmetic operations which are performed and in this case there are only multiplications and it is quite easy to see that every iteration there is a single multiplication that is performed therefore, for n iterations there are n operations right. So, let us just go back to our program you look at this there are n iterations every iteration has an iteration number which is captured by counter counter takes a range of values between 0 to n minus 1 and in every iteration the value is updated by a single arithmetic operation which is a multiplication. Therefore, the number of multiplications are associated with this program is exactly n where n is the power of x that we want to compute. There are also a couple of additions which happen. So, where counter gets increased at every step that is one addition that happens in every iteration but we do not interested in counting that because that is more structural exercise and we are interested just counting interesting counting the number of multiplications. Let us address the question as to how to reduce the number of arithmetic operations which are performed in computing the power. So, here is the next approach which is very interesting and this is a technique that you can use even to compute the higher powers of matrices not just numbers. So, in this case we want to compute the nth power of x in other words we want to compute x power n and the observation that we make is that x power n is given by x square raise to the power of n minus 1 by 2 if n is odd and multiplied by x. It is very easy to do the arithmetic 2 times n minus 1 by 2 is equal to n minus 1 that is what happens in the exponent and then there is a multiplication by x. Observe that when n is odd n minus 1 is even therefore, n minus 1 is then divisible by 2. So, therefore, the left hand side is an integer you get the value n minus 1 and then you multiply by x. So, this is basically x power n minus 1 multiplied by x when n is odd and n is even it is very clear it is x square whole power n by 2. So, here is a trick which is recursive repeated squaring it is repeated squaring of what let us see that now. Remember that initially we have the value x and earlier in the first iteration we computed in the iteration number 1. Then we computed the value x square and remember that in the next iteration we computed the value x cube instead we do something which is slightly cleverer and compute x power 4 which is x square whole power 2 which is x power 4 and then we compute we square the value of x power 4 in the 4th iteration. That is the iteration number 3 there is 0 the first iteration the second iteration and the third iteration we compute x power 8. The fourth iteration we square the value computed to the previous iteration so we get x power 16 and so on. So, what is the whole idea the whole idea is very simple we compute the square of the previous term. In other words the kth term in the sequences x power 2 power k so let us write this down in the kth iteration we would have computed x power 2 power k and for what value of k is so what we want to compute is x square. So, what we do is we compute we perform this operation of repeated square of the value computed in the previous iteration till 2 power k and n by 2 are 1 and the same at which point of time starting from x square we would have computed x square to the power of n by 2 that is we calculate the value of x power n by repeated square and the termination condition is when 2 power k where k is the iteration number becomes equal to n by 2 assuming that we start with x square. For what value of k is true for what value of k is this equation satisfy that 2 power k becomes equal to n by 2. So, for k equals log n to the base 2 minus 1 for the value k equals log n to the base 2 minus 1 k equals n by 2 and let us do a small exercise here to get an idea as to what we are talking about consider the case when n is a power of 2. So, let us assume that the number that is given is x consider the case when the number is x and we want to compute say x to the power of 64. So, let us write down the sequence we start off with x square then we compute x power 4 then we compute x power 8 then we compute x power 16 we compute x power 32 and finally we compute x power 64. To observe that every step the exponent keeps getting doubled. So, the most important concept here is that the exponent doubles at every step in each iteration and we start off with x square and we wanted to get the exponent double at every step. In each iteration and we started off with x square and we wanted x to the 64 x to the power of 64 and observe that the number of iterations is 1 the second iteration the third iteration the fourth iteration and the fifth iteration. And it is very clear that log 64 to the base 2 is 6 because 2 power 6 is 64 minus 1 because we started off with x square and minus 1 this is 5. Therefore, there are 5 iterations in the 0th iteration its x square in the iteration number 1 x power 4 the iteration number 2 its x power 8 iteration number 3 its x power 16 iteration number 4 it is 35 iteration number 5 64 x power 64 is calculated at the end of it for powers of 2 in log n to the base 2 minus 1 steps the correct number 4. So, this value is calculated when very importantly n is a power of 2. So, this brings us to the exercise here as a student it is very instructive to write a C program to implement the repeated squaring algorithm. In particular the challenge here is to write down the loop when n is not a power of 2 and this is very interesting. So, let me give you a hint as to how to go about this let us assume that n is instead of 64 let us assume that n is 65 and let us write 65 in binary. It would be 1 0 0 0 0 followed by 1 65. So, this is contributes to value 1 this is 2 power 0 2 power 1 2 power 2 2 power 3 2 power 4 2 power 5 2 power 6. So, this is 64 plus 1 in binary this is 65. What we want to do is we want to compute x power 65 and if you write this carefully this is equal to x power 64 plus 1 this is x power 64 multiplied by x power 1. And we already know how to handle the case when the exponent is a power of 2 here also the exponent is a power of 2 recall that 1 is 2 power 0 and we know how to handle this and this is a hint for you to complete the algorithm when n is not a power of 2 and implemented in the C programming language.