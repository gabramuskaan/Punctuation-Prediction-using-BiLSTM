 Welcome back. Earlier I promised that we will look at pass by reference in a lot more detail. So in this module we will look at pass by reference and we will also see the case for passing arrays as parameters to functions and how do you program something like that. So let us start with a very basic example. So let us say I want to exchange the values of two variables. So I have two variables A and B and I want to exchange the values of A and B. So one way to do that is this follows. So A equals B and B equals A. This is a very common thing that beginners do. Take A equals B and B equals A. Unfortunately this is something that won't work. So let us just take a small example. Let us say A was, let us say A is a variable. So in memory it has a value of 5, B is a variable in memory it has value 3. Then if you do A equals B, it takes 3 and overrides the value here. It becomes 3. So because of this the value of A is lost. So both A and B will have the same value. Instead what will actually work is something like this. So this is a very basic template for swapping two variables. This is something that you will see very often and you will also use it very often to swap two variables. So this is a very straightforward way of doing it. So instead of two variables just A and B which we already have. So let us say we start with that A equals 5, B equals 3. We also have a new variable called temp in memory. And what we are going to do is since we are losing A, we will take A and copy it onto temp. And now if I copy B to A, I lose 5 and I have 3. However I have remembered the value 5. So it is not a problem. Now what I will do is to compute B, I will copy back the value from temp. So from temp I copy it to B that becomes 5. So at the end we have A equals 3 and B equals 5. So this is a basic piece of code. So if I want to swap two variables in the body of a program I could do this. So now I want to take this and write a function instead. So I want to take two variables and I want to write a function called swap which will exchange the variables. It looks like it is straightforward. So we write a function. We take two variables A1 and B1 and this is a body of code. Let us say I just copied and paste it from the previous slide. Instead of A and B I call them A1 and B1. So clearly if I start with A1 and B1 at the end of this A1 and B1 would be swapped. So if A1 was 3 and B1 was 5, sorry if A1 was 5 and B1 was 3 as I had in the example earlier I would get A1 to B3 and B1 to B5. So that is guaranteed. Let us go and look at how the function call would be. So I have A equals 5 and B equals 6. I am calling this function swap 1 of A comma B. And then I am going to print. So since this is calling the function I would expect A and B to be swapped. I would expect the printout to give me 6 and 5. Unfortunately this one gives the result 5 and 6 itself. So A is 5 and B is 6 before the function call. Even after the function call A and B seems to be 5 and 6 itself. So we need to think about why this is really happening. So to do that we will have to go back to the basic premise in function parameters and C. So let us look at what is going to happen. So I am in the main function let us say. So this is for explaining swap 1. So we had A which was 5 and B which was 6. And let us say at some point I called swap 1. So when swap 1 comes you are going to get an activation record for all the new variables. So what are the new variables? We had A1, B1 and 10. So A1 and B1 were actually formal parameters. And temp was actually declared within the program. So if you go back we see that temp is a variable that is declared within the program. A1 and B1 are actually formal parameters. And the thing with C is we take whenever I have a function call we copy the formal parameters. So I make a copy of the formal parameters. 5 gets copy to A1 because we call swap 1 of A comma B. A gets copy to A1 and B gets copy to B1. So I have 5 and 6. Now the function is ready to execute. I have the variables A1 and B1. And what is it that we did there? We took 5 made a copy on temp. So it got copied. And then we took 6 and then copied it to 5. So A1 got 6 and we took temp and copied it to B1 that got 5. So clearly at the end of this A1 and B1 got 6 and 5. So I already mentioned this. So it swaps A1 and B1. Let us say now you are done with this the function returns to the caller. And the function returns to the caller what would happen? So this side is the caller and this side is the call E. This is swap 1. So when the call E returns all the local variables get destroyed. You do not have them anymore. You cannot access them anymore. And when you came back did it really change A and B? No. We made copies of A and B on A1 and B1. 1 and B1 got swapped but they do not change A and B. So this is a common rookie mistake that people make that use call by value here because we called A1 and B1 by value we pass 5 and 6 within the function it is swap but when you return from the function it has not swapped. Now how do we fix this problem? So clearly this does not work. We need to think about something else. We will write this swap function using references. So as before we will start with the function. So we have A equals 5 and B equals 6. And what I am going to do is instead of swap 1 I am going to write a new function called swap 2. So clearly there was a problem. We should not have used pass by value. I am going to use pass by reference. So the way it is going to work is this follows. So I am going to write how to swap using references. I am going to call this function swap 2. So let us see how I could have done this. I have A which was 5 and B which was 6 and if I had passed values it would have been a problem. So instead what I am going to do is I am going to take the pointer of A and pass it on. So let us say I have pointer of A that would have been ampersand of A. We already know that. And pointer of B is ampersand of B. So the address of A and address of B. I can always get it. What I am going to do is I am going to pass that to the function. The function is going to take two pointers now and what it is going to do is follows. So let us say I have these two pointers. So I have a pointer now. I am going to call that A1. So this actually is now going to 0.25 and I am going to have another pointer called B1 and that is going to 0.26. So I copied ampersand of A into A1 and ampersand of B into B1. So A1 and B1 are not integers. They are pointer to integers. So we have them. Now what I am going to do is I am going to have another local variable called temp because we already know that we cannot swap two variables without this extra thing. So not so easy. There are ways to do that using only the two variables. But in the method that we saw, we declared another variable called temp. And now what I am going to do is I want to swap the not the contents of A1 and B1. I want to swap the contents pointed to by A1 with the contents pointed to by B1. So what is A1 pointing to? It is pointing to 5 and B1 is pointing to 6. I want to swap the contents of that. In essence, I want to change the contents of A and B. Now how I am going to do that is I will keep a copy of the contents pointed to by A1. What is A1 pointing to? It is 5. I will keep a copy of contents of the memory location pointed to by A1. Then what I will do is I will take the contents pointed to by B1. So I want to take the contents pointed to by B1 and move it to a location pointed by A1. So what is B1 pointing to? It is pointing to 6. I am going to take that and move it to the location pointed to by A1. Where is A1 pointing to? A1 is pointing to this location. I will move it here. And finally, I still have to get the values of wherever A1 was pointing to that has to. So that has changed. We have to see what contents of B1 must be. So B1 is pointing to this location which had a value 6. So I have to take this value 5 and copy it into that. So that would change the values of this memory location. And when I return as before A1 gets destroyed. So it was a pointer but it was a formal parameter. It gets destroyed. B1 was a formal parameter. It gets destroyed. Tempest a formal parameter that gets destroyed. So I return from the callee back to the caller but at that point already A and B are 6 and 5. So the key thing was instead of passing the values 5 and 6, if we pass the pointers to A and pointers to B, I can use the dereferencing operator that we talked about earlier and get back to the values and use them. So that is what we are going to do. So I am going to pass address of A and address of B and I am going to try and print. So this is the function call. And let us think about how the function should look like. So swap 2 is not returning any value. It is not returning any value. And you have two pointers that are being passed on. So we need some mechanism by which we will take two pointers and I do not expect any return value so I will not have any return. So the function would look something like this. So I have void because it is not returning anything. I have swap 2 as the function name and as I said earlier we are passing pointers and the way to receive the pointers is instar A1 and instar B1. So we have two pointers to integers one called A1 and one called B1 now. And I was talking about a new variable called temp. So this is actually local to swap 2. It is an automatic local variable. And what I am going to do is I am going to take A1. Look at the contents of whatever is pointed to by A1. So that is done by using star. The A1 is a pointer. Star A1 gives the contents of the location pointed to by A1. I am going to keep a copy of that. Then I am going to take B1. Look at the contents of the location pointed to by B1 and make that the value of the contents of the location pointed by A1. And finally take temp which is a local variable and make a copy of that onto contents of location pointed by B1. And when you return back from here A1, B1 and temp are destroyed. So we made copies of the pointer. So it is not really destroying A and B. It is only destroying the copies of the pointers that we had for A and B. It is not even destroying copies of A and B. It is destroying the copies of the pointers for A and B. And it destroyed temp which was a local variable. It did not matter because by now we actually changed the contents of 5 and 6. So A would have become 6 and B would have become 5. So at this point if you print these two things you would get 6, 5. So this is called swap using references. So what we have actually done is we have taken the two variables and we want the values of the variables to change. We are not going to work on just the copies. We want actual contents of the variables to change. And whenever you have anything of this sort where you want the contents of some variables to change and if you want a function which is delegated to doing that you have to pass pointers. So I will reiterate that. Let us say I have some variables and instead of doing the work on the variables locally let us say I want to work on it by doing some delegation to a function. I want to pass it on to a function. But I expect this piece of code to actually change the contents of the variable. If I am going to only print them on the screen right it did not matter. I could have just printed using a function I do not need pointers. But I want A and B to exchange their values. The moment you write a function for that you have to use pointers to do it. You cannot just copy the contents and do operations on that because whatever you do on the copies will not reflect on the original variables that you had. Now let us look at this larger picture. So I showed you how to do pass by reference for the small thing. We also did this earlier for quotient and reminder. There are several cases where we need functions to work on arrays. So let us say I give a list of numbers in an array and I want you to find out the largest of the numbers or I give you list of numbers in an array. I want to put it in decreasing order or increasing order and so on and I want a function to do that. So I can always go and write the whole thing in the main program itself. But if I am going to delegate duty and if I want to make it readable I am going to write functions. In that case we also need to understand how to pass arrays as parameters to functions. Not just individual variables we also need to learn how to pass arrays. So let us see a simple example. So we will start with things which are only reading the arrays but not changing the contents of the arrays. So let us look at this simple example called print1. So it is a function which is going to take an array and print the values. That is all. Nothing more. So I have two arrays in the main function A and B. So A is an array of size 5 and B is an array of size 7 and this function takes an array and the number of elements in the array. It prints all of it. So if you forget this part right now let us look at the body of the loop. The body of the loop if I have n for i equals 0 i less than n i plus plus print tab of i. So if I have some one dimensional table I want to print the contents of that I can do it definitely. So not a problem. Now what I want to point out is the mechanics or how to do this. So if you look at the function call it has print1 a comma 5. So this point you are passing a which is the variable name that we use for the array. What it really does is it sends a pointer to the first element of a. So to print one the caller sends a pointer to the first element of a. And this on the other side in tab of so we have this int tab of left and right bracket. So what this does is it receives the pointer and we can do tab of i because you have received a pointer and from there on if I say i equals 0. So it is that pointer plus 0 steps away from it. Then when you do when i becomes 1 it is that pointer plus one more step away from it and then two steps away from it and so on. So that is what we are going to do. So we get a copy of the pointer to this and then if you know how to access the contents of this I can print it. Then I will get one step away from it so tab of 1 is one step away from tab of 0. I can look at the contents and print it then tab of 2 is one step away from that I can print it and so on. So this is a one way of passing arrays to functions. So what we have is we have two arrays a and b. So at this point you are passing pointer to a or pointer to a of 0 to print 1. In this line you pass pointer of b. So you pass pointer of b of 0 to the print 1. So tab is a local variable. Tag is a formal parameter and n is also a formal parameter. So the formal parameter receives pointer of a of 0 the first time and it takes n equals 5. So it will print 5 entries. The second time it will this formal parameter tab takes the value which is the address of b of 0 and it will take n which is 7 and print 7 times. So this is one way of doing it. So there is another way of doing the same thing. So in all these examples the main function there is no change. You watch out for what is happening in the print alone. So this is the second version of print. So the first change we have is we have in star tab. So instead of in tab, so in the previous example we had in tab of a re index like right. So instead we have in star tab in n. So this is as it was before and we have in star pointer ptr. What we are going to do is we are going to take ptr equals tab which means so tab the first invocation of print 2 will have a pointer to a of a of 0. You make a copy of that to ptr. So let us look at the sequence of things. So in print 2 a comma 5 when you call this the caller passes the pointer to a of 0. So a of 0, a of 1 and so on. So let us say that is the pointer. It passes that to tab. So you make a copy of that to tab right. And in this loop you have another variable called ptr which is also of pointer data type. And this pointer data type makes another copy of that. It ptr makes another copy of tab. Now if you do star ptr where is it going to point? So tab had a copy of pointer to a of 0. Ptr is a copy of tab. So ptr also points to a of 0 right. So star ptr will print a of 0. Then we come back and look at ptr plus plus. So since the this is an integer pointer this is supposed to point to the next valid integer. So ptr would have been pointing to a of 0. Now ptr will point to a of 1 right. Then star ptr will print a of 1 and we keep doing this till ptr is less than tab plus n right. So this is one way of doing the same thing. So I already talked here about this notion of arithmetic in tab right. So tab plus n means take n steps away from wherever tab was. Tab is pointing to a of 0. So we are looking at a of and if I walk five steps away from it so tab would be pointing to something beyond a of 4. So as long as you are less than that you are good you can keep printing. So this is print 2. Let us look at print 3. In print 3 we do not use this ptr anymore. In fact if you look at this print 2 all we did was we made a copy of tab to ptr. So tab itself was a copy of pointer to a of 0 and we made a copy of that and we use that for the iteration. We do not have to do that. Instead what we are going to do is we have tab which is pointing to a of 0. So as before so we have a and this is a of 0 and a pointer to that is copied to tab when you call the function. So tab actually is also going to point to a of 0 and star tab would be a of 0 first and then this is actually running a loop n times right. So this is not using any pointer arithmetic for stopping the loop. Instead we know that we want to print n of these variables on the screen. So just run the loop n times. So this check is actually on an integer right. So I equals 0, I less than n, I plus plus will run this loop n times starting from I equal to 0 to I equal to n minus 1. And each time what you are doing is the first time when I equal to 0 star tab will be starting to a of 0. So tab is pointing to a of 0, star tab will actually print a of 0 and then you do tab plus plus which means you are actually pointing to the next location. The next time when you come around star tab would be a of 1, you print that and you increment tab to go here and so on. So that increment is happening here. So there is pointer arithmetic. This tab plus plus is actually saying wherever you are pointing to, start pointing to the next location, wherever you are. So it starts with a of 0 next time to point to a of 1 and so on right. And once a is printed when you come back here tab gets destroyed and n gets destroyed because these are in the colors they get destroyed. I also gets destroyed. Now you start with b, b, 7. At that point you have this array called b which has 7 entries and you are actually passing the pointer of b to tab. So this is in the collared side, in the collied side you have tab which starts with the copy of b of 0 right. So this is the setup right. So we saw three ways of doing this in the, so this is one most likely way in which you will do things. This print of 3, the print 3 is the most likely way in which you will actually do things. So now let us go back to looking at how to use arrays and do some simple things. So in this example we have a small function which takes care of swapping right. So we have swap 3, we had two versions of swap earlier, swap 1 which was actually incorrect, swap 2 which was taking two pointers and swap the contents of the locations where the pointers were pointing to. Here what we are going to do is we are going to take an array and 2 indices i and j. What we want is a of i and a of j to be swapped. So that is the goal of this. So the way to do that is very similar to what we did earlier. We have this new thing called temp. Temp keeps a copy of array of i, array of i copies, array of j and array of j copies temp and this I claim is correct right. So even though it looks like it is very, so if I replace array of i by a and array of a by b it is looking like it is swapping local variables but you are actually passing the pointer to the local variables. Array of i is not the simple value right. It actually goes to what was pointed to by the thing called array. It will take the contents of that put it in temp right. So this is very similar to pass by reference only that the two pointers are the pointer to the ith location and pointer to the jth location. So you are accessing the contents of the location pointed to by what is happening in the ith location and j you can think of it as the index which gives you the pointer to the jth location of the array. You get that pointer, you access the contents and so on. So this is a very simple way of swapping the contents of two variables in an array. So we have passed array by reference. We are actually passing pointers here. We didn't copy the contents of arrays onto the formal parameter list. We only passed a pointer to the beginning of the array and if you have i comma j right these are two indices. So array of i will go i steps away from the beginning of array. Array of j will go j steps from the beginning of array and you are swapping the contents of these two locations. So this is how you get to swap two elements. So something like this is very useful if you want to do some things like order the elements in an array or find out the largest or smallest values in an array and so on. So this brings us to the end of this module as well. So we will see how to look at using the swap function to do finding out the end element in an array or the largest element in an array and see how to do swapping. Thank you very much.