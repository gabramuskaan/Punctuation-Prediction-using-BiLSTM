 So, we now study the analysis of merge sort and also learn a new algorithm for sorting which under special cases is better than merge sort called radic sort. So, all merge sort it was it is an algorithm implemented on an array of elements. If the array size is just a single element it is done otherwise we sort the array of elements in the indices 1 to n by 2 the floor of n by 2 and then the second half of the array whose indices are in the range floor of n by 2 plus 1 to n and then we merge these sorted list. We did see that the effort involved in merging two sorted list is linear in the size of the data that is to be merged. In other words if we merge an array of size L with an array of size m then the total number of comparisons taken is L plus m. The recurrence of merge sort is T of n is equal to 1 if n is 1 and it is 2 times T of n by 2 plus n if n is more than 1. The 2 times T of n by 2 comes from the two recursive sub problems that are generated from a given problem and the additional term of n comes for the effort spent in merging two arrays of size n by 2 sorted arrays of size n by 2. We now complete the analysis of this recurrence and for these of presentation we analyze the case when n is a power of 2. There are many ways to find good upper bounds on T of n for n in general however we expose the way by which T of n is solved when n is a power of 2 because it is an extremely instructive presentation. The recursion tree for the recurrence is T of n is equal to 2 times T of n by 2 plus n this is the recurrence and the recursion tree is constructed as follows. At the root of the tree is the function that we want to compute which is T of n. It is two children are T of n by 2 and T of n by 2 now the root is now replaced by the value n which is added to the sum of T of n by 2 and T of n by 2. The tree is further expanded using the same rule where n by 2 replaces the element T of n by 2 and its two children become the values T of n by 4 and T of n by 4. One branch of this whole recursion tree right up to the leaf one can note that the values are in the range n n by 2 n by 4 all the way down to 1. In other words as the depth of the tree increases from the root the size of the sub problems being solved falls by a ratio of 2 falls by a fraction of 2 it becomes n n by 2 and then n by 4 and goes down all the way to 1. Therefore, the height of this tree is log n to the base 2 the contribution to the whole recursion which is essentially the summation of the values at all the nodes now at the root the contribution is n because the value is just n at the level 1 depth 1 the contribution is again n because there are two nodes of value n by 2 at the next level 2 there are two nodes 4 nodes of value n by 4 and the contribution is the value n and so on all the way up to the leaves and it is clear that the number of leaves is exactly equal to n because every leaf node contributes a value 1 and therefore, the number of leaf nodes is n therefore, the contribution from the leaf level is also n. Consequently the solution to this recurrence is n log n now we have placed an upper bound on the total number of comparisons made by merge sort which is an algorithm which uses the divide and conquer approach and clearly n log n grows more slowly than n square this is very easily visible to us observe the n log n and n square the common term is n and log n and n n is exponentially larger than log n and therefore, n log n grows much more slowly than n square therefore, merge sort has a better asymptotic running time than the algorithm insertion sort we go forward with the very natural question of can we beat the n log n bound it is indeed possible to sort linear time when the data that we are sorting has some very special properties. In this case we study an algorithm called counting sort counting sort is a very special algorithm it does not have any comparisons among the elements the input array is an n element array which contains the values to be sorted in this case we assume that the values come from a range 1 2 to k and we make an assumption that the values are all numbers the output is presented in an array b which is also an n element array and the output is sorted the algorithm uses an auxiliary array called c which has k elements recall that k is the total number of distinct elements that one c is in the input array from the range 1 to k and c is an array of size k elements in essence every value of the value of the value which is in the array a can be an index into the array c and this is an idea that we use to obtain a linear time sorting algorithm in this special case. So, let us just look at counting sort counting sort basically has four loops the first loop is the initialization loop where the count array or the array c is initialized to take the value 0 in the next iteration in the next for loop we count the number of occurrences of each element of the array a by making one pass of the array a observe what the for loop does the shape it inside the for loop say for example, the first element c of a of j if the first element is a one then the array index 1 in the array c is incremented by one. So, every time we see a value in the array a the corresponding index location corresponding location and c index by the value is incremented by one at the end of the first for loop every array location in particular the i th array location counts the number of occurrences of the key i in array a in the third for loop the consecutive elements of the array c are added to ensure that the array element i keeps track of the number of elements of value lesser or equal to i in the given array a and finally, these count information are used to rearrange and obtain the sorted array b which is as follows the key at the element j the key at the index j in array a is moved to its rank and the value of the value of the value of the array in array b in other words if the key at array index j has 4 occurrences in the array a then c of a of j would be 4 and the value a of j would be kept in the array location b of 4 and then the number of occurrences of the value at a of j at the index j is reduced by 1. Let us run one example of this algorithm the array a has the values 4 1 3 4 3 in the 5 locations and let us see how the initial array c looks like its initialize to 0 and since the distinct keys are on the range 1 to 4 in the array a all the the array size c has only 4 elements array c has only 4 elements to keep track of the counts of the values 1 2 3 and 4 respectively. The first element in array a is the value 4 and the second loop increments c of 4 then the value c of 1 is incremented by 1 then the value c of 3 is incremented by 1 then the value c of 4 is incremented by 1 and it becomes 2 now and the value c of 3 is incremented by 1 now which becomes 2. It is easy to observe the following invariant that the sum of the array element c is the total number of elements in the array a in this case it is 5. In the next iteration we modify and store c and let us see how we do this observe that we now keep track of the number of elements whose values less than or equal to 2 in the array a and in the location c of 2 that is obtained by adding c of 1 and c of 2 to get the value 1 which is a count of the number of elements whose values less than or equal to 2. In the next iteration the number of elements less than or equal to the value 3 is kept track of and we can see that the value should be 3 and let us see this that is what it becomes and then the number of elements of value less than or equal to 4 is indeed 5 elements all of them are of value less than or equal to 4 and c of 4 is now updated to the value 5. Now comes the phase when the sorted elements are output and this is the loop that runs in the reverse order. Let us look at the last element in the array a it is a value 3. Now there are 3 occurrences of elements less than or equal to 3 in the array a that is the element 1 3 and 3. Now the element 3 should definitely be in the third position in the sorted array and therefore 3 is now placed into the third position and the number of relevant occurrences of 3 is now reduced by the number of elements smaller than 3 is now reduced by 1. Then 4 is considered and the number of elements of value less than or equal to 4 is 5 and therefore this 4 should occur in the fifth location in the sorted array. In other words 4 is the largest element and it must occur in the fifth location in the sorted array and then the value of c of 4 is reduced by 1. Next element considered as 3 and the number of elements less than or equal to 3 in the given array a which have not been considered so far is 2 and therefore 3 goes into the second location and then naturally 1 goes into the first location and the number of elements less than or equal to 1 is reduced to 0 and then the last element is considered 4 and the number of elements less than or equal to 4 in the sorted array the number of elements less than or equal to 4 in the sorted array is reduced by 4 and 4 goes into the fourth location and the algorithm terminates when the loop comes to an end. One of the most interesting properties of this algorithm is that counting sort is a stable sorting algorithm. What is the meaning of a stable sorting algorithm? If 2 elements have the same value if 2 array indices have the same value then in the sorted array the order in which the occur is preserved. For example if you see the 2 occurrences of 4 in the array indices 1 and 4 respectively observe that the occurrence of 4 in the array location 1 in a goes to b of 4 and the occurrence of 4 in the fourth location goes to b of 5. Same is true with 3 therefore not only is the array sorted but interestingly the array also maintains a certain stability in other words it guarantees that the input order among elements of the same value is respected in the sorted output. It is interesting to ask this question as to which other algorithms that we have seen have this property. Based on this algorithm we present this approach to sort numbers which is called the erratic sort. The idea of the erratic sort is to sort numbers digit by digit and the idea is to sort the numbers based on the first digit and use a stable sorting algorithm to sort the numbers based on the first digit. In other words we will come up with an approach where we just sort the first digit of all the numbers and we will use a stable sorting algorithm to do this and iterate over all the digits. This is very nicely pictorially represented. So let us consider the numbers which are given to be sorted which are the numbers 3, 29, 457, 657, 8, 39, 4, 36, 7, 20 and 355. Let us consider the least significant digit in each number and visualize this as the array that should be sorted by counting sort which is the stable sorting algorithm that we have just seen. On sorting the array consisting of the least significant digits the sorted array would look like this which is natural the least significant digits are when they are sorted occur in the order 0, 5, 6, 7, 7 and 9 and because counting sort was a stable sorting algorithm observe that the remaining two digits have also been moved to the appropriate location along with the least significant digit. For example the number 720 has the smallest least significant digit among these and however it is the second largest number but at the end of the first call to counting sort on the least significant digit 720 occupies the first position and the whole number 720 goes to the first place and 0 is at the correct position. Now the second least significant digit is the number 720 and the number 720 goes to the right and the number 1080. As we have seen it the number is at the correct place of the digit is picked up and now this array is sorted again using counting sort and the remaining numbers in some sense are tied to the digit that is being sorted and as a consequence of using a stable sorting algorithm one can observe that the number of the If you focus just on the numbers in the first two digits, they occur in the sorted order. And this is an inductive invariant that will be used to argue the correctness of the radixot algorithm. Finally, we pick up the third digit and perform a stable sorting and in this case, we use a counting sort, counting sort which we have just discussed. And now we can observe that all the numbers are in sorted order. And observe that the stability of counting sort is very crucial in the correctness of the algorithm. And when a certain array is being sorted, the remaining numbers are visualized as being tied to this particular number. So the correctness of radixot is argued by induction on the digit position. So clearly, after the first call to counting sort, that is after sorting the least significant digit, the number whose lower order digits, the array of least significant digits are sorted. So let us assume that the numbers are sorted by the lower order t minus 1 digits after sorting the first t minus 1, sorting, applying counting sort on the first t minus 1 digits. Now when we sort on digit t, now when we sort on digit t, the array is now sorted. It is a stable sorting algorithm. And let us look at two elements which are in the opposite order. In other words, 720 and 329, the first two elements, observe that they have exchanged their places and 329 is smaller than 720 and 720 has gone to its correct location in the sorted array. Therefore, the numbers that digit, that different digit t are correctly sorted. And two numbers which have the same digit, two indices which have the same value at digit t are also correctly sorted because we are using a stable sorting algorithm. Therefore, we have the correct order among the t digits and this completes the inductive argument. Let us complete the analysis of. So, the first two elements, counting sort, the loop 1 which was initializing the count array, performed K operations because every there are K indices and each of them was initialized to 0. Loop 2 performs a computation by looking at every element of the input array A exactly once and then increasing an appropriate index in the count array C by 1. So, this takes n time that is it takes a constant number of operations, constant number of arithmetic operations per step and loop 3 then gets upper bounds on the values at most on the number of terms whose values are at most each index in C and this again takes K time and loop 4 which writes out the output array B also takes n time and therefore, the total time taken is order of n plus K. In this case it is 2 n plus 2 K arithmetic operations. Now, if the key set the smallest in the largest value differ by a linear amount by at most n then counting sort takes order of n time. It is also clear that counting sort does not perform any arithmetic does not perform any comparison operations and it is completely an arithmetic operation based sorting algorithm and it takes linear time in some special cases.