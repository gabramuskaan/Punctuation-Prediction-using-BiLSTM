 In the last class, we just studied about the stack erity. Today, I will talk about another kind of list erity, just called the Q-adity. Q is what, now Q does not require too much of an introduction. Stack, for example, you had already list, you already know, you already used this all the time in your life. And stack, for example, I mean once I gave you the example of stacking plates on a cupboard or stacking books on a desk, you know that immediately that the stack erity is to be lost in first-out kind of a data structure. Now, Q is something that you all know, you start in India, we always stand in Q's for almost everything, whether it is railway station, the bus stand or you know getting your registration done in your college, getting your ID card. Wherever you have a whole lot of Q's and the grocery store for that matter, if you go to a big bus or something that you are standing in the Q for a long time. And that is what a Q-adity is all about. What is the property of the Q-adity? It is just that the person who is at the beginning of the Q is served first and then the next person and so on. So, this data structure is somewhat different. Unlike the original list erity way, we said you can insert anywhere and delete anywhere. And the stack erity way, we said the last person gets priority, gets deleted first. This Q-adity is one which is of the type what is called first in first-out. First in first out, you also known as Fee-Four. I was first in the Q and therefore, MSB served first. In India of course, in some places when you have a lot of unruly population, it behaves like a normal list. But in a civilized society, you will have that, you follow the Q-prints, first in first out. So, what are the various operations that we perform? We want to perform on Q, DQ, empty and front. You want to find out who is there in the front of the Q. These are the four operations that you would like to perform. Basically, let why would I want to look at on Q? Of course, a particular job has to be on Q and DQ when you want to remove an element from the Q. MTQ, you want to find whether the Q is empty or not. For example, if I want to close the counter, I may decide that if I have multiple counters, let us let us say, you are waiting at the passport office or whatever. I have multiple counters. I would like to check whether the Q has become empty so that I can close a particular counter. And front of the Q to check who is there in the front of the Q. For example, if you go to the passport office, there is a facility, Thatkal versus ordinary or whatever. So, I would like to move this person to a different Q and say, do not be in this Q. If you are asking for some of the priority based, because this is for non-priority people. Everybody has the same preference and if you come in first, you get first. So, let us see how we can operate on this. And clearly, since the Q is also a special type of a list, we can again use the list ADT to perform the operations. So, what will it, what will on Q become now? If I have a list ADT, it will say L dot insert at L dot end. We are always inserting at the end of the Q. And dQ would be L dot delete L dot front and empty will be L dot front just like in the stack equal to L dot end would be an empty Q. Front would be L dot retrieve of L dot first. So, what I am, what I have shown here, I have shown you that the all the operations that you want on the list can be on the Q can be implemented using the list. So, what I could do is in my ADT, I can say L is of type list and define operations on list to perform these operations on the Q. So, this is the first thing that I always advise any student to do. If you have one ADT, which you have implemented, which is completely debugged, then my advises you just use the reuse that ADT again. So, that is what I am doing again here, just like we did for the stack. I define the ADT Q in terms of the list and do operations on list to mimic the operations of the Q. That is all, then what happens you very quickly have a Q ADT. Let us see on the other hand I want to implement my own ADT Q, that is what I am going to talk about now. So, what is it that we have the operations which remove elements are DQ front and empty, which gets from the Q and things that put elements onto the Q. First you of course, you always have to create a empty Q, this is make null operation and an on Q, which puts elements onto the Q. In my implementation, which I am where you see plus plus, what I do is to make deletion easy, I have done a linked list implementation here, we will talk about array implementation a little later. So, in a linked list implementation as shown here, you have a point of which points to the front of the Q and another point of which points to the end of the Q. In this example here that I have done, what I do is in addition to that, these are things by the way, because you are hiding the implementation from the user of your ADT, you can do some clever things in your implementation to make some of the operations easy. What I have done in this implementation over here is, if you notice here, my make null operation create an empty Q, I create a dummy cell, I did this for the list also if you remember, I create a dummy cell. Then my on Q becomes insertion at the end of the dummy cell. What is the advantage of this? I do not have to check whether the Q is empty and then insert. I know that as soon as I have created an empty Q, there is one dummy cell and therefore, insertion becomes simply inserting at the end of this dummy cell. Then, I let us say I have on Qed one more element. So, what do I do? I go to the end of the Q and put another element over here. That is, I have a front pointer and I have a rear pointer. Please look at this here, there are two pointers pointing to the Q, front points to the same location and rear points to the same location when it is empty. But what is nice is, because I have created a dummy cell, what happens is, when I create a dummy cell, the advantage is that there is always one element where both the front and rear are pointing to. It is not pointing to somewhere, there is no way. So, then what I do is, when I am doing the on Q, I am inserting X over here. So, what is interesting is, now, front is pointing to the dummy cell, rear is pointing to the element. Now, I am on Qing one more element, then what happens? Rear is updated and Y is on Qed after X and rear is updated over here. So, now, what am I going to do when I do DQ? I just, when I DQ, I remove this element. So, I keep the dummy cell as it is and DQ the element next to the dummy cell. This is the fundamental advantage of using a dummy cell and rear is pointing to Y. So, this is the advantage of implementing, when I am doing a linked list expression, sorry, when I do a linked list implementation of Qs, this is the big advantage of using a dummy cell to implement, when you create an empty Q, this is the big advantage of it. And here is a implementation over here and I have just given you the C plus plus implementation over here. So, you have a recursive data structure just as before and notice that again, I have what you call type depth position. So, for example, I have said type depth structs cell star position, we will see how we do this in the case of the array. In the case of the array, when I do a type depth, it will be integer, which will be type depth to this. Basically, the user is simply going to use this type depth position, just like you use a type integer, care, float for that matter, we create a new type called position. And how the implementation of positions in this case, it is a pointer to a recursive data structure. In the case of arrays, it will be an index to an index in the element in the array. And of course, you need two positions front end rear because we have two pointers for this. And we have a creation of the empty Q, then you have the on Q, then you have a D Q and then you have a, some an operation it tells you what is there in the front of the Q, another one which tells you whether the Q is empty or not. And here is a simple implementation of how the rear is done, rear is done, rear pointer next you. And then basically that wherever the rear is, you create a new element in the at the end of create a cell type of new element and put this element over here. D Q what are we doing? This is the fundamental advantage. If it is empty, then you say Q is empty. Otherwise, what do we do? We just simply update the front to point to the next element. What is interesting? The time complexity of all these operations, what is that there is no loop in any one of them, there is no going from the beginning to the list to the end of the list. Therefore, all these operations, this is if you let us take on Q for that matter, this is order 1, this is order 1, this is order 1, this is order 1. So, this is the form of P 1 plus P 2 plus P 3 plus whatever, if you take each one of these as sub programs over here, then what is the time complexity of the segment? It is basically the max of all of this. Therefore, the time complexity of the on Q operation is order 1. Similarly, we can argue that the time complexity of the D Q operation is also order 1 and creating an empty Q, every one of these is order 1. So, this particular list implementation is not difficult, it only takes order 1 time. Now, initially sometimes for example, there is also another operation that you would like to perform, have which is called the Q length which will return value which tells you how long the Q is. Some ADTs also of the implementation of the Q also have Q length. What is the advantage of this? For example, if I am again a grocery store like you know food world or something like that, I may decide looking at the length of the Q, whether I want to increase the number of counters. So, it is a big advantage to do something like this too. You can also have an extra function called length. Now, if I am looking at an extra function called length, how expensive will this operation be? If you keep, so basically you will need another variable called length which maintains the length of the Q and then what will happen is you just keep on incrementing it when it is on Qs and decrementing it when it D Qs. So, again that operation is not going to cost you more than order 1 in terms of time complexity. So, we talked about a linked list implementation of the Q. I would like to talk about an array implementation. So, what will you do with an array implementation of Qs? So, let us say this is my front, this is a rear, let us say I have an array of some particular size. Let me call it some max size. I am going to leave you this, I am not going to give you the complete implementation of this. So, this is my front, the rear. Now, I D Q, then what happens? Front moves over here, this becomes front. Again I D Q, this becomes front. Then let us say on Q, then maybe your moves here. Let us say I have E and then now I reach the end again I rear. So, what happens is the problem is that the Qs found somewhere between front and rear in the array. Let me say this is the, so that means if I am looking at it, if I am looking at the pink colors over here, the Q is found between front and rear. If I am looking at blue, the Q is found between front and rear and similarly the whites give me the Q between front and rear. But the basic problem with this is this kind of an implementation, array implementation of Q, what will happen? Very quickly you will exhaust the size of the array. What will happen is suppose I keep on DQing elements, then the front comes over here and then I cannot add any more elements. This is not a good idea. So, what we normally do is that we convert this array implementation to a circular Q. Let us say this is 1, 2, 3, 4, 5, 6 and so on and this is the max size. There is still a array implementation, but we do what you call a logical tying of the front and the rear of the Q. So, what is the meaning now? If this is front here, this could be rear here and it could also happen that this is front and this is rear. How do I perform this kind of arithmetic now? That means I have a circular array and somewhere going clockwise, I will find the front and the rear of the Q. So, how do I perform these operations? You guessed it right, you have to do modulo operations. Modulo based on what? Max size to find the location of the element. So, what happens if we all the time we are taking when we keep incrementing right, the array for example, initially let us say both front and rear are pointing to the first element or let us say front is pointing to the first element and rear is pointing to max size. So, whatever to show that it is an empty Q. I will tell you this is going to become a problem, but we will talk about it in a little later. Then what are we doing? When I am going to on Q, then what am I going to do now? I am going to move put the rear over here and I will put the element over here. This is front, let us say I keep on Q. This is the front, this is the rear. Then what happens? I am always doing modulo size arithmetic. So, when it exceeds it over here, then what will happen? The rear will start overflowing onto the beginning of the array. There is a problem with this implementation, I want you to think about it. I said I start with front pointing here and rear pointing here to indicate that it is an empty Q. Now, how do we distinguish between an empty and a full Q? This becomes a problem. So, we will need another variable or alternatively you can think of something more clever and I would like you to think about this particular problem. So, circular Q, the advantage is that the Q is found anywhere between two indices front and rear. How are these indices computed? The indices are computed using modulo arithmetic and modulo is based on. For example, I will say rear is instead of saying rear plus 1, we will do rear plus 1 mod max size. We have to do a little more bookkeeping as I already said when we are to distinguish between a full and an empty Q. There are two ways of doing it. You can introduce an extra variable. So, the point is if I am using an array implementation, what is happening? The linear array, the array size gets exhausted very quickly, but the circular array whatever is available in this, it will the Q can be basically the Q moves like this. That is the fundamental property of the circular course, nice data structure and I want you to implement all of this. Interestingly, again all the operations on the Q can be implemented in order of one time. Let me leave you with this. As I already said, implementation is a circular Q in an array. There are issues you need to find out how to fix this, definitely a distinction between empty and a full Q. Then I want you to do this as an assignment. It is nice to, simulation is a very good way of learning about ADTs and I would like you to simulate a petrol pump. I have a petrol pump, it serves petrol for various people. Let us say you have two different petrol pumps, pumps one for the four wheelers and one for the two wheelers and for each one of them you can have arrivals that happen to the particular system. To give you an example, let us say the two wheelers arrive very frequently. I almost have a two wheeler in every minute whereas I may have one four wheeler every five minutes or something like that. Simulate this, put it in a Q and then on Q and DQ and just give statistics of how long the Q is at different intervals of time. Another very interesting implementation of Q is using the circularly linked list. I am having a linked list over here and I tied the back to the front and I am giving you only one point of P, no two point. We are not going to have front 10 rear. I want you to implement the Q. All operations on Q must be all-dermented. I want you to do this. I am giving you only one point of no front 10 rear. There is only one point of P. So, now where should P point? Should it point to the front? Should it point to the rear? I want you to think about it. It is a circularly linked list. Now, there is one more problem which is not listed there. How do you implement a Q? See, we saw in the beginning of the class, how to implement a Q using a list edd. The question that I want to ask you is how do you implement a Q using stacks? I want to use a stack edd. Remember, we reuse the linked list edd to build the Q edd. Can I do the same thing? After all Q is also a list type of list. Stack is also a type of list. Now, can I use the stack edd to implement a Q edd? What would I require? I want you to ponder about this particular problem.