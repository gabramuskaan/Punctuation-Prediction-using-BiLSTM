 In today's lecture, we are going to look at algorithms for finding the I th smallest number in a given data set. The specialty about the problem that we are going to look at is that it is a recursive algorithm and it is very efficient compared to the most simplest algorithm to answer this question. The problem in question is given n distinct numbers, you can imagine it to be presented in an array. The goal of the problem is to find the I th smallest element which is also given as part of the input, the value I is also given as part of the input. In other words, we want to find an element which is larger than exactly I minus 1 elements in the given data set. One natural approach to solve the question needs to sort the given n distinct elements in ascending order and one can use an algorithm like merge sort which is known to run in order of n log in time and then we return the I th element in the sorted array. This definitely does solve the problem. The focus of this lecture is to see if we can design better selection algorithms. In other words, our aim is to design selection algorithms which run in time order of n in the worst case. The main idea behind the algorithm that we are going to look at is the concept of a median. Let us just recall the definition of a median. Median is the middle rank element in a given set of numbers. If there are n distinct odd numbers in the data set, then the middle rank element is the unique element. If n is indeed even, then there are two medians, the elements rank n by 2 and the elements rank n by 2 plus 1. We define the median to be the element whose rank is floor of n plus 1 by 2. If n is odd, this is a single element and if n is even, this is the n by 2th rank element. The idea for identifying the I th rank element is that we use the power of recursion and given the elements in an array, we aim to partition the elements of the array into two parts based on an index r, the elements a of 1 to a of r, that is the first r elements in the array are of values smaller than the r plus 1 the element in the array and the remaining elements, that is the elements with indices r plus 2 to n are of value more than a of r plus 1. Indeed, if r has the value i, then we have indeed found the I th rank element. This is very clear because the first I minus 1 elements are smaller than the I th element and therefore, a of r is the I th rank element for r is equal to i. We are going to do this for some carefully chosen r so that we can get our desired efficient algorithm. The way to do this is if r is not equal to i, then we ensure that we have recursively smaller sub problems to solve so that we can get to the I th rank element as quickly as possible. So, now we set up the recursion. If indeed i is smaller than r, then we find the I th rank element in the set a of 1 to a of r. This is indeed the most natural thing r is larger than i and all the elements below r, all the elements whose indices are in the range 1 to r and the array a are indeed smaller than r and therefore, the I th rank element would also have an index smaller than r. Therefore, it is natural to search for the elements in the range a of 1 to a of r, the I th rank element in the range a of 1 to a of r. I is more than r clear that we look for the i minus r th rank element in the range a of r plus 2 to n. In either case, it is clear that we have smaller recursive sub problems, but to get our efficient running time, we will see that it is desirable to have the two parts in the partition to be of almost same size. And we will try to ensure this. So, let us just go to the design of this whole algorithm. We refer to this algorithm as the select procedure. The procedure has two arguments and an array a and a rank i. The output of this select function is to return the value of the I th rank element in the array a. Select a of i is a recursive function. Let us just recall recursive function. It is a function which makes calls to itself with of course, different parameters. So, what we now do is we try to partition. We come up with a procedure to partition the array based on an index r. To do this, what we do? We do not have a function is to take the n elements and divide it into n by 5 groups. The n by 5 groups are the elements with index 1 to 5, the elements a of 6 to a of 11 and so on up to a of n minus 5 to a of n. It is important to notice here that the last group could be of value smaller than 5. For example, if n is not a multiple of 5, then clearly the last group will be smaller than 5. In each of these groups, we find the median element. We call that in each group, there are 5 elements except for the last one. For the purposes of this discussion, let us assume that the last one also has 5 elements. And we pick the median element in each of these n by 5 groups. And for this, we can use insertion sort and sort the 5 elements and pick the median. In other words, this will be the third-rand element in each group. What we do is we visualize these median elements from each of these groups in an array m. Now, here is the first use of recursion. We look at the array m and ask for the median of the n by 5 elements in the array m. So, the recursive call is described here. If there are m elements in the array, then the recursive call is select on the array m, the median element which we know is floor of m plus 1 by 2. Let the return value be x. Now, what we do is to partition the array a into 2 parts around the element x. We will see how to do this. But before that, let us also analyze how good this partition is. What do we mean by a good partition? We analyze what properties of this partition are there, which could give us a linear time algorithm to find the i-th-rand element. So, let us see how good this partition is. And let us make some observations. Let us ask in the array a how many elements are greater than x. We call that x comes from the array m and indeed it is a median element of the array m. M has n by 5 elements in it. Therefore, x has n by 10 elements larger than it. That is half the elements in the array m are larger than x, x being the median element in the array m. Let us also recall that x is each element in m is a median element in those n by 5 groups. And there are 3 elements which are at least as large as each element of m in the array a. I repeat this for each element in the array m. There are definitely 3 elements in the array a which are at least as large as that particular element. Therefore, there will be at least 3 and by 10 elements which are at least larger than x in a. Therefore, at least half the groups have 3 elements smaller than or equal to x. This is except for the group containing x which has 2 elements and the last group which may contain only one element. Therefore, the number of elements which are smaller than x in a is at least 3 and by 10 minus 6. So, let us complete this. Let us complete this discussion of how good this partition is. Using the symmetric argument, the number of values at most x in a is also at least 3 and by 10 minus 6. As a consequence of this argument, it follows that the 2 arrays a of 1 to a of r and a of r plus 1 to a of n. After the partition step have size at most 7 by 7 and by 10 plus 6. This is because the array has a total of n elements and therefore, the number of elements in the 2 parties at 2 arrays a of 1 to a of r and a of r plus 1 to n is at most 7 and by 10 plus 6. Therefore, by making a recursive select call on one of these 2 arrays, we get a running time which is given here which is t of n the time taken to find the i th rant element in the given array a is equal to t of n by 5 which is to find the median element in the array m plus t of 7 and by 10 plus 6 which is the time taken to solve the recursive subproblems plus the time taken to create the partition which is also a linear time procedure. Finally, if the array has a single element to find the i th rant element is extremely easy. So, it just is so t of 1 is taken to be 1. It is easy to see that t of n is order of n for this recurrence. We do not evaluate the recurrence here, but this is a recurrence which evaluates to order of n. What are the remaining steps of the algorithm? We partition the input array around the element x to do this is the following steps have to be done. We identify the position of x in the array a. This can be done in order of n time by scanning the element, scanning the array a for the element x and then we perform a partition procedure, linear time partition procedure which identifies an index r such that a of r has x and the elements 1 to r minus 1. The elements in the indices 1 to r minus 1 are smaller than x and the elements in the indices r plus 1 to n are more than x. This is exactly what we want. There are r minus 1 elements on the low side of the partition and n minus r elements on the high side of the partition. So, the algorithm is almost complete now. If i is equal to k then we return the value x. Otherwise we use select recursively and the recursive calls are made as follows. We find the i th smallest element in the low side if i is smaller than r and we find the i minus r th smallest element in the high side if i is more than r. Let us run through an example of this algorithm. In the given array of 28 elements we want to find the 11th rank element. In the first step we divide the array into 5 groups of 5 elements each which counts for 25 elements and one group the last group of 3 elements. We sort the groups and then find the median element in the 6 groups and the median elements are marked in red. Observe that in the groups of size 5 the median element is a third element and the last group the median element is the second element. In the third step we find the median of the medians and this is our array a this is our array m and one can see that there are 6 elements and the median element is the element 17. We partition the array around 17 and in the first part we have all the elements which are smaller than 17 and 17 is the 11th rank element and the algorithm terminates and returns the value 17 as the 11th rank element. If for example we wanted to find the 6th smallest element then we would have to request our search in the first part which is the values which are smaller than 17 and similarly if we want to find an element of rank 15 then we would have to find the element of rank 4 in the second part. This completes the description of the algorithm to find the i s smallest element in a given array a.