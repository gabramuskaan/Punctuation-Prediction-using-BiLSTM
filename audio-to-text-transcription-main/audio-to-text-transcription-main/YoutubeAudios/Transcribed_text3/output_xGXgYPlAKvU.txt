 So, good morning class in the last class we did the A D T called list and just recap what is the A D T list list is a sequence of items unordered items for that matter and then we defined a whole lot of operations on list. We also looked at the implementation of list. What did we talk about? We talked about two different implementations although I showed you only the linked list implementation both the A A and the linked list and I showed you a linked list implementation of the list I encourage you to do the A A implementation of the list. Now, I just have some problems over here. I would like you to work on storing sets. I gave you an example of storing sets using lists and basically you want to perform operations on set union intersection and set A minus set B. I also want you to look at another application of list is to is what we call infinite precision arithmetic. There is if you want to do let us say you have a 64 bit machine and you want a higher precision than 64 bit then you can use the list as a structure to perform arithmetic on it. So, basically what we are talking about is in the list here your A 1 A 2 A n up to n corresponds to different parts of a given number and then you define operations to perform arithmetic operations on this number represented as a list of elements. What I mean by that is your the numbers represented in parts in terms of A 1 A 2 A n and you want to perform arithmetic operations on them. So, I would like you to try these problems. I also have a few assignment problems. We talked about this a little the last class, but I would like you to write a function to remove duplicates in a given list using only list operations and basically a function which takes a list and returns the perj list and I also want you to convert a given unordered list into an ordered list again it should be done in place. I would like you to do these two problems on this. Now, next what we are going to talk about is a different type of ADT called a stack. What is a stack now? Stack is also a list also a list, but it has a fundamental difference. It is a special type of a list ADT and the difference in the stack is that it operates on this principle of what is called last in first out. What is the meaning of this? That is the last element which enters into the list is removed first this is called a stack. Now, let me give you some example when you are putting books on your table then you put the top most the most recent book will be the top most book. And then when you remove for example, if you want to remove this particular book you remove the top two books before you can remove this book. Another example let us talk about plates that are stacked in a cupboard. So, you put your plates over here and like this and you remove the top most plate. The most recent plate is what is first removed. If you want to remove the third plate from the top here you have to remove the first two before you can remove the third plate. So, stack has a lot of nice applications and we will talk about a specific application of stack. The operations that are supported by the stack are you can push, you can pop and you can find what is the top most element in the stack can also check whether the given stack is empty or not. So, these are the four operations that are normally supported by the stack. Now, since stack is a special type of list I want to show you one example here where since you know now the way we look at it is I have already implemented the list ADT. And since I have already implemented the list ADT I would like that I would like to use the list itself to represent a stack. So, how do I go about doing that? The way I would do that is since the list ADT has been you know you already debugged it you have tested it and so on and so forth. So, what we could do is we could do is the list ADT itself as a stack. So, how would I do that then then what I will do is I will restrict my operation. So, what I will say is the push operation. So, within my I can write an ADT stack here and say that stack or a class stack and I will say that I have L which is of type list which I have already defined. This is my private data then I will define a set of operations on stack. And what are the operations that I want? I want push, I want pop, I want top and I want empty. So, what will I do for push now? I will say push x comma what do I do L dot first? What is L dot first return? It returns the position right or the first element. So, insert at the first position then I can pop I can pop L dot first because this was the most recent element that was inserted. Top will also give me L dot first. Pop will be L dot first comma L dot delete L dot first and top is L dot first and what should be empty is if the L dot first equals L dot end then I can say that the stack is empty. So, what have we done in this process here now? We have all these operations over here right and sorry this should be retrieve of top should be L dot I will return to here, tree of L dot first. This is what we how you would implement all these four operations of the stack using a list. So, you can use the list ADT in its present form which you have implemented well as a stack ADT and perform the four operations which are required for the stack. Now, what we will do is once I have this so, the one of the things that I am trying to encourage you to do is that basically that if I already have a ADT which is implemented I try to reuse the abstract ADT type as much as possible because why do I want to do that? The primary reason I want to do that is the list ADT which we implemented in the last class is let us say nicely debugged there are errors in it. So, what I will do is I will quickly define a stack using the list and then I will use the stack to perform various operations. What I am going to do right now is I am going to take give you one application of stacks and then we will look at the implementation of the stack a little later. Let us say I want to convert an infx expression to a postfix expression to postfix. Let us see why we want to do this. Let us say I have an expression which is given like this something like this. Let us say I have given an expression like this a minus b star c plus d star f plus c by d and suppose we know that star and slash have higher precedence then minus n plus and the all operators are left associated with a minus b plus c. What do we mean by this is that a minus b plus c is equal to a minus b plus c rather than a minus of b plus c. Let us assume that all the operators associate to the left. This is the meaning of it. If I give an expression like this I do not know whether I have to perform a minus b plus c or should I perform a minus of b plus c that is where b that is where the associativity matters. What is interesting is that when I am given an expression like this and I do not know the associativity of the operators it is difficult to evaluate this expression. So, what is done is given a particular expression the expression is converted to a form called the post fix expression. So, let us see what this post fix expression is all about. Let me just take only a partial expression a minus b star c let us say this will be written as a b c star minus. What is the meaning of it? We take the top most operator then you come to the next operator and the next one is still an operator. So, you push it somewhere take the next operator again you use a stack for this then you take that then you find under top there are two operators over here. So, operands over here you compute this b star c the idea is that what happens is that the operator associate with the binary operator associates with the nearest operands that are there. So, what is nice is the advantage of this expression when you write it in this form there is no issue about the evaluation why is there no issue about the evaluation because you look at the operator you just for example, if I keep moving along this as soon as I come across the first operator all that I will do is I will take this operator operate it on these two operands get the result and put it there and let me call it d then I have a d n minus then it means I have to find I must do a minus t. So, this there is absolutely no ambiguity when a given expression is given in force fix the order of the operations whereas, if I give the expression in this form which is called in fix I do not know whether I must perform a minus b star c I do not know the associativity I do not know the precedence of the operators everything is assumed in the post fix expression given a post fix expression all that I have to do is I traverse that post fix expression from left to right as soon as I come across an operator I take the nearest two operands perform the computation then you can put it back on stack there is a way of evaluating again using the stack then once again the result I have a d n minus on the particular stack then again when I traverse this for example, next I see another operand over here and as soon as I see this I see another operator over here then I take the most nearest two operands perform this operation and I get the result. So, the evaluation of expressions is normally done using the post fix expression you take an infix infix expression is very convenient for us to write, but what we do is we take the infix expression convert the infix expression to a post fix expression and then perform the computation. So, now what I am going to show you is the evaluation also can be done using stacks, but we will take one application we look at conversion of infix to post fix using the stack that see how this gets done. So, what is it done here when an operand is read that is I am getting this expression here as soon as I find an operand what am I going to do I am just going to simply place it on the output then when an operator is read what do I do I take this operator. So, that means let us go back to this particular expression take this expression now I see an operand I put it this is my output this is my input then what do I do I put it on the I put it to the output when an operator is read what I do is I look at the element I have a stack here right now my stack is empty look at the element which is there on the top of the stack. If the top of the stack has higher presidents then I keep popping all the elements from the top of the stack. So, this part is not there because it is empty so what am I going to do I am going to simply stack the current operator I put minus on it then I have b here then what do I see then I have another I see another operator over here. So, now I look at the top of the stack there is a minus sign here minus sign has lower presidents so what I do I just simply stack star also onto it then again I see an operand move it to the output next what do I see I see a plus where I see a plus what I do is the following I look at the content of the top of the stack. So, star is the content on the top of the stack so since star is a content on the top of the stack I output and star as higher presidents so the president is like the star comma slash and plus comma minus and of course above this you have the brackets. So, what I do is I pop the star then once since I pop the star what do I have I only have minus on top of the stack what is the current operator that I am looking at plus now clearly plus and minus have same president. So, what I do I also pop the minus then what I do I put this plus over here onto the stack and we proceed this is how this whole operation goes about all right. So, basically this is what we do and now I have done up till this part of the expression now let us look at the next one what do I have now the plus is gone it is gone to the stack I get t I push this onto the stack then what do I have I have a left bracket I put the left bracket also onto the stack then what do I have I have F right then I put the plus on the stack then I have c d then I have the slash over here a compare with what is there put it on the top of the stack then what happens I come across the right bracket. So, as soon as I come across the right bracket I pop everything off until I see the left bracket that means I put the slash here I put the plus here and then what do I do I have come to the end of the expression star and plus. So, this is how I complete the expression. So, this is the conversion from infix to postfix. So, what we have done we took the infix expression then we converted it to postfix expression using a stack now let us see if it will give us a evaluation correct what did I say I just keep this as it is then as soon as I see an operator I find the nearest two operands and compute the computation let me call this b prime that is a computer d store and let us say this is the result is p prime then what do I have I have a b minus now clearly there are two operators and an there are two operands and there is an operator. So, I compute this let me call this a prime. So, what do I what do I have now I have already computed this now I have d f c d slash plus star plus. So, what do I do now I keep moving from left this is computed let me call it c prime then I have f c prime d a prime. So, what do I do I compute this let me call this f prime. So, I have a prime d f prime plus and sorry plus is already gone d prime plus yeah f plus c d right. So, c d let me call this c prime plus is already gone I already computed this sum over here and then I have a star over here and a minus. So, next what do I do I compute a prime d f prime let me call it d prime after the multiplication because I see the multiplication here multiply these two put the result in d prime I have a minus and now finally, get the result which is essentially what the so, basically what it tells me is if I follow the rules of arithmetic for a post-piscuous expression what is the rules say I take the whenever I see an operator I take the nearest two operands perform the computation and store it. Then what happens that becomes a new operand now b prime then a times b prime a and b prime and there is an operator here minus. So, I compute the difference of a and b prime again put it back on top. So, then I call it an a prime then what happens I have d f c d I just put them all together then I see a slash when I see a slash what do I do I take the nearest two operands multi divide then here the operator is slash. So, I divide c by d I call it c prime then I have a prime d f c prime then what happens I have f and c prime. So, this is this part so, I add them then what do I have a prime d f prime let me call it then d f prime star this star is here. So, I perform this computation and after because that is the that is the the first operator that I am saying I take the nearest two operands perform the computation then finally, I will get a new let me call it I get a new operator operand called d prime and a prime d prime and I subtract one from the other and the post-piscuous expression can be evaluated. So, clearly what it tells me is using the algorithm that I have given here the conversion to in fixed to post-pictus correct so, basically I can use a stack to take this input convert it to post-pictus. So, what are we doing when we are doing this we are taking all the operators stacking the operators including brackets and when do we pop as soon as we come across an operator which has lower precedence than what is there on the stack I pop all the operators from the stack which have higher precedence and the operators which have the same precedence to and put this operator onto the stack that is exactly what we did let me illustrate this with the pictorial example again. So, let us say we have the same I have the same almost the same expression which I have already gone through over here and I have realized it. So, the same expression that is there and here is a pictorial description of what is exactly happening stack the plus this is the top of the stack then a is kept outside and then you get a b c then you put a b c star pop this and so on. So, this is how your output gets generated as soon as you see a bracket you just push everything out. So, this is how you convert and so, basically this is the first thing what is it the the stack is a stack of operators. So, what is happening now plus and star a stack then as soon as the next plus comes you pop both plus and star just as I already told you and then you see the bracket you put the bracket on top of the stack then repeat the same process again. So, this is essentially how stack can be used. Now, let us look at the implementation of the stack and what are the operations now I am looking at a separate implementation let us say that I am not going to use the list I want to implement my own stack. Before that what are the time complexity of these operations when look at L dot insert L dot delete L dot retrieve what will be the time complexity of all of this. If you can say if you look at the it depends upon the kind of implementation if the implementation is a linked list does not matter for in this particular case if I am inserting at the first all these operations can also be done in order to one time even when I am using the list. But we can do a cleaner implementation I can we can implement a stack. So, since I in this particular example I am using the operators I have created a stack which is I am using an array implementation here this is your static array. So, basically the stack size here so you would also like to have a stock stack full perhaps. So, I create or you resize the stack if you wanted to be transparent you can always resize the stack then you create an empty stack which is make null then you push a character onto the stack character pop returns the top most element on the stack pop deletes the element from the top of the stack empty tells you when the stack is empty. So, here is how the various operations can be performed and basically what is interesting is all the operands operations here if you look at this if you look at the analysis of this I want you to go through this over here make null it simply creates the top of stack to be stack size. Then we just putting from pushing from the stack what are we doing with here in push for example, I am making the stack size post the top of stack initially it mapped to the largest element in the array possible in the array largest index possible in the array then what do we do we decrement the top of stack and then push the element and then when we so this is again an order one operation if you notice this is an order one operation this is an order one operation then when then what are we doing if the top of stack is less than stack size is returning the top of the stack that means otherwise what is happening you performing a top operation with no elements on the stack that is the meaning of this return 0 over here then if top of stack greater than stack size return 0 again otherwise what are we doing you popping the particular element on the stack that is you are trying to pop more elements than there are otherwise if there is an element on the stack it it pops this then if stack is empty it is greater than top of stack top of stack greater than stack size then you say return greater than or equal to stack size then you say that the stack is so the time complexity of all the operations that are performed on stacks using arrays is order one now what I want you to do is I want you to go back and implement the stack I have given you a array implementation of stacks I want you to do a linked list implementation of stacks and a mission of stacks and all operations must cost only order one so I want you to go back and experiment with this now what I will do is I will just close this with some applications now I want you to do this right now when we looked at operations we only operators we only looked at left associative operators what happens if an operator associates to the right let me give you an example if I have an example like this x to the power of y to the power of z then what is this this is essentially right to the power of z whole x to the power of so I want you to think of this how do you use the stack how do you modify the infix to post fixed converter if you to work with operators which are right associative another function that I would like you to write is determine whether the parenthesis are balanced in a c program I want you to look at all these types of parenthesis I also want you to write a function that uses a stack we already talked about it to evaluate a post fixed expression.