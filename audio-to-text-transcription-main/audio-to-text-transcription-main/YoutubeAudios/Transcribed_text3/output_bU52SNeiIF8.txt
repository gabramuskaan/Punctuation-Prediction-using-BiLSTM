 Hello, welcome students. So, in this session solving problems, I thought I will show you the solution to this problem on printing the matrix in a spiral. So, we have given a matrix and we have to traverse it in a spiral order and print the elements. So, Baratmi for today I have a terrible sore throat. So, they say here from the horses mouth, today you are going to hear from the horse itself. So, let us look at this matrix here. It is a 4 cross 4 matrix which is given as a public test case for you and when we say traverse this in spiral manner, what we are going to do is we want to go in this order. So, we want to traverse the top row first and after the top row, we traverse the rightmost column. He traverse the bottommost row and traverse the leftmost column. At this point, we have reached the, we have done with all the outer layer and now we are supposed to go to the inner layer and do things inside and so on. So, I am going to define something called peeling. So, think of it as what you do with an onion. So, you take an onion and you remove one layer completely, what you have done with this, you have removed one layer and you are still left with an onion which is similar to what you had earlier. Just like that, if you take the elements from the top row, then strip of elements in the right, strip of elements in the bottom and strip of elements on the left, you would be if you start with the rectangle, you would you would be left with another rectangle. In this case, you would be left with the rectangle 4, 3, 2 and 8 if you remove the outer ones. So, you peeled one layer and you are left with another rectangle and on this rectangle, again I can start at the left top and move one step at a time and print all these elements. So, now I am done with one layer. So, of course, this arrow must not be there. I am done with another layer inside and so on. So, if I keep peeling one layer after another, I will be left with a sub problem which is similar to the original problem itself. So, this is a nice structure to this whole setup. So, now the question is how long do I keep peeling and what are the corner cases? So, to show that I have a small grid which is 10 rows cross 7 columns here. I want to see how many times we can actually do this operation of going on the top, traversing on the right, being in the bottom and then again traversing on the left, how many times we can do that. So, just follow my marker carefully. So, I start with the left left left most cell on the top, I do one traversal, then in some sense I turn right, then turn right and then go all the way here. So, that takes care of one layer of peel. So, that is my green line here is the first peel. Once I am done with that, I am left with a sub problem which is not a 10 cross 7 anymore. So, let us go and count what we have. So, we have 1, 2, 3, 4, 5, 6, 7, 8 rows and 1, 2, 3, 4, 5 columns. So, this is not a surprise because we started with some m cross n which is 10 cross 7 and from there we remove 2 rows and 2 columns. So, now we start with a 8 cross 5. So, now let us peel the outermost layer of the 8 cross 5. So, that is the second peel. Once we remove it as you can expect, we will have 4 rows, sorry 6 rows and 3 columns. So, that will be the third layer. So, let us look at the third layer, we will have 6 rows and 3 columns. So, on that again I can peel once more. So, that is the third peel and once the third peel is over, now it looks like I have a corner case. So, I do not have a proper rectangle anymore, it is not 2 rows or 2 columns anymore. In fact, I have just 1 row here. So, I will mark that with this color. So, I have just one column here that I need to traverse. So, in all the other ones, I can start at the left top of the rectangle and move right towards the right here and then move bottom, move left and move up. So, essentially what we are doing is on the topmost row, we traverse from left to right. Then on the rightmost column, we traverse from top to bottom. On the bottommost column, you traverse from right to left and in the leftmost column, you traverse from bottom to top. So, and this is a process that you keep repeating, only that what is your top, right, bottom and left keeps changing as you go along. So, initially your top is row number 0 and the bottom is row number 9 initially, but as we go along. So, and in that case, the left would be 0 and the right would be 6 because we have a 10 cross 7 system, that will be a first layer. Once you have that, your top will become, so this is the left after one round of peeling, this is the right after one round of peeling, this line will be the top after one round of peeling and this will be the bottom of after one round of peeling. So, and we are going to do this repeatedly. So, I am going to take this and see how to how to translate that into a program. So, to do that, I am opening up my local editor. So, what I am going to do is as before, I will go and scan the matrix first and what are the things that I need. So, your problem specification said, you should support something for a 5 cross 5 matrix. So, I am going to declare into a of 5 comma 5 and you need to scan coordinates of the rectangle, what is the size of the rectangle. I am going to assume that rows is m and columns is n and I am going to declare two variables called int n j, int i and j will declare other things as we go along. So, for now, what I am going to do is for i equals 0, i less than m i plus plus for j equals 0, j less than n j plus plus scan of two integers, sorry scan of one integer which is a of i comma j. So, before doing that, I need m and n itself. So, I will do that outside scan of m and m and m and m. So, assuming that I have read the rows of number of rows and columns and both of them being less than equal to 5. So, then I am going to read m cross n matrix inside this system. So, I want to imitate what I did earlier in the graphics. So, I know that the top most row is actually row number 0 and bottom most row is row m minus 1. So, I have the top and bottom and I need the left hand right. I will start with left most being the 0th column and right most being the n minus 1th column. So, this takes care of c style of indexing. So, only that I have not declared top, bottom and so on, I will declare that now in top, bottom, right and left. Now, what I am going to do? So, let us let us write code for one layer, peeling one layer, let us write code for that. So, what I am going to do is I am going to start at the top and I am going to traverse from left to right. So, from left to right one element at a time, let us say if I access a of top comma i, right, I am going to do something to a of top comma i, but that will take care of doing everything on the top most row because my row index is top, I keep changing it goes from top comma left in one step to top comma right. So, it goes one step after the other and what work I am going to do? I am going to show later, right. Then I need to start at one row below the top most row. So, I will start with that row below the top most row. Then I will go up to the bottom most row again, I am increasing i. Here what I am going to do is I am going to access a of i which is the row number and write most column. I am going to do something on that later. So, now I have taken care of traversing on the top and traversing on the right. Then what I am going to do is I am going to start from right minus one and go up to left, but I am going in the reverse direction. So, I am going to do i minus minus and in this case we are accessing a of bottom comma i. And finally, I can go from the bottom most, so I will go from bottom minus one. Then I want to go up to top plus one i minus minus. Again, I am going to access a of i comma left. So, you can see what is happening here. So, this part, this part line numbers 19, 20 and 21, you are accessing a of top comma i, where i goes from left to right. Then line numbers 20, 20, 23 and 24 is accessing a of i comma right. So, since right is fixed, you are accessing a column and which rows are you accessing, you are accessing from the top plus one through to the bottom most row. And line numbers 25, 26 and 27, you are accessing the bottom most row, but you are going from right side to left side. You are starting with right minus one, because you have already touched the right bottom cell and you go greater than equal to left. And finally, go from bottom minus one greater than equal to top plus one and i minus minus. So, the first two loops move in the left and bottom direction and the second, the bottom two loops moving in, moving the left and above direction. So, this is what we have. Now, we have to do a few things. So, one thing I am going to do first is I am not going to assume that this is printed directly, because so many of you run into problems with presentation errors, I am going to show a technique of how to avoid presentation errors. So, instead of actually printing right here, what I am going to do is I am going to store in a matrix called B that I accessed A. So, I am going to declare B and other things appropriately. What I am going to do is I am going to do B of C and T plus plus. So, count as a variable I am going to run and I am going to ensure that this records what I visited and not printed and I am going to do that on all of them. So, I do it on all of them. So, now all I need is I should ensure that B is also declared properly. So, A is of size 25, I could not visit more than 25 elements. So, I am going to keep B of 25 and since count is a variable that is counting the elements, I am going to put in count equals 0. So, now what I have is I have peeled exactly one layer. So, I have moved from left to right, top plus 1 to bottom, right minus 1 to left and bottom minus 1 to top plus 1 and at the end of this, I would have peeled exactly one layer. So, let us go back to this picture, let us see what we would do after peeling one layer. So, in this picture after we peeled one layer, top can actually be incremented by 1 because this was the earlier top. Now, the top most row is this row and bottom can be reduced by one layer. So, this was earlier bottom and now it is going up, this will be the row which is bottom. Similarly, left moves to the right side by one column and the right can move to the left by one column, right. So, I will put that in. So, top can move up, it can move down by one step, bottom can move up by one step, left can move to the right by one step and right can move left move to the left by one step, right. Now, the second question arises, this takes care of one peeling but we need to see how many times we can peel, right. So, let us go back to the picture and if I give you m cross n, right, if I give you a general m cross n, right, how many times can you really peel? So, let us see after the first peel, so before the first peel you have m cross n. After the first peel what do you get, you will have a m minus 2 cross, m minus 2 rectangle system. After the second peel, you will have m minus 4 cross, m minus 4 because you remove 2 columns, 2 rows from here and you remove 2 columns from there and we can keep doing this but how many times can you keep doing this? You cannot do it forever, right. You can do it at most m by 2 times or m by 2 times whichever is smaller, right. So, let me repeat this, you are removing 2 columns at a time and simultaneously you are removing 2 rows, right. So, which will peel the outer layer of the rectangle and how many times can you do this? You cannot do it more than m by 2 times or m by 2 times. So, that is the first thing I am going to do. So, I am going to ensure that this process of peeling. So, the code that you are seeing is for peeling, right, from line number 22 to line number 35 is what you are seeing for peeling except that I have not said how many times you can peel. So, I am going to declare another variable called count 1 and I am going to say count 1 must be less than or equal to both m by 2 and m by 2, right. What this takes care of is is that it ensures that peeling happens exactly either m by 2 times or m by 2 times whichever is lesser. So, now this takes care of peeling various things but then sometimes we are left with the current case, right. So, let us see one of those current cases. For example, if I have a 3 cross 3, if I have a 3 cross 3 system like this. So, m equals 3 and n equals 3. So, I said we can peel at most 3 by 2 times or 3 by 2 times whichever is smaller. So, 3 by 2 happens to be 1, this is integer division, 3 by 2 happens to be 1 also. Minimum of 1, 1 is 1 time. So, it can be peeled exactly 1 time. So, you do this, you can peel it exactly 1 time, right. So, let us take another small example which is a 3 cross 4 system. So, the claim is that you can either peel it minimum of 1 time or 2 times whichever is smaller. So, minimum of 1, 2 is 1 itself. So, I can peel it exactly once. Let us verify that claim. So, I have 3 rows and 4 columns. How many time can I peel it completely? I will start from here, go up here and so on. These 2 cells are part of inner one which I cannot peel. So, I have peeled it once, right. So, in general I said we can peel it minimum of m by 2 times or m by 2 times and that is exactly what this check task, right. So, CNT1 is less than or equal to m by 2 and CNT1 is less than or equal to m by 2. So, of course, I need to declare CNT1 itself. So, I am going to declare it here. CNT1 is also equal to 0. So, now I have the various things except for the fact I have not taken care of what the corner cases, the final case, right. So, before I do that let me take one more example. Let me take a 4 cross 4 system. So, this is a 4 cross 4 system. If I start peeling I will start from here and end up here with 1 peel and the second peel would start from here and end up here. In this case it does not leave anything to me traversed at all, actually traverses everything. So, in general if you have a m cross n which are both even what would happen is you can actually do peels which is minimum of m by 2 times or n by 2 times you will actually touch all the elements. But if one of them is odd let us say m is odd and n is even for example 4 cross 3 then you would peel but you would be left with either 1 row or 1 column. So, we saw that example here right in a 3 cross 4 system with 3 rows and 4 columns, 3 is odd we can do 1 peeling but then we will be left with 1 row. But if you do a 4 cross 3 system you will be left with 1 column and if you start with something like a 3 cross 3 system where both are odd both m and n are odd you will traverse this exactly once and then you will be left with 1 element in between. So, I am going to use this idea and write the rest of the program. So, at the end of it if you are done with everything and let us say both your top and bottom coincide and left and right coincide it means that you are left with exactly one element. So, I am going to do I am going to traverse that. So, A of left. So, what this does it takes care of touching that exactly one element that you left out. Else let us say top is still less than bottom it means you have a column that you have to traverse from top to bottom but it is just one single column and which is that column it is either left or right. In fact, left and right should both be same at this point of time. So, what I am going to do is I am going to traverse from the top up to the bottom and what is the element that I am going to access? I am going to access A of rho which is i and column which is either left or right it does not matter at this point actually left should be equal to right. Else if you get this condition that left is actually less than right which means they have not coincided yet. Now, you are actually ready to go from left most column to the right most column but it is just one single row and which row is that it is either the bottom or the top row. In fact both should be the same at this point of time. So, I am going to traverse that A of I am going to take top but even if you put bottom here it is not wrong. I do that and at this point at the end of line 51 now the whole traversal is over. So, the final thing that we need to do is just be able to print. So, what I am going to do is I am going to start from i equal 0 which is the 0th element of B and I am going to traverse overall there are M times N minus 1 elements I am going to print all of them with a space. So, percentage D B of I right. So, this takes care of printing M cross N elements. For the last element we do not want a space. So, I will just print it directly and this is my whole program right. So, I am going to save this as spiral dot C. Let me compile it. So, there is a small problem here. So, this time there is no compilation error let me run it. I am going to test it on some of the public test cases. The first public test case is this 3 comma 3 system and it has 0, 1, 2 and so on. There is a small problem I think I forgot to put a scan of with the ampersand. Let me go and check. Yeah. So, this problem the scan of was without the ampersand it was a mistake. So, let me save it and compile it once more. I am running it now. So, 0, 1, 2 and 7, 8, 3 and finally, 6, 5, 4 and this seems to give the output 0, 1, 2, 3, 4, 5, 6, 7, 8 which is what is expected. Let us try it on some of the kernel cases. What if I have only a 1 cross 1 system and that is the last test case? 1 cross 1 the output is supposed to be 20. So, this seems to be okay right. So, let me take this and put it in the system. So, as before I have this saved in my setup like last week. So, I have opened it up, I just copied and pasted it. So, I will save and compile and run. So, let me see hopefully this is okay. So, all the 4 test cases have passed which is a good good thing to get and finally, I do a submit. So, under got 100 and 100. So, this program seems to be correct right. So, the key thing that I did was not just traversal, I want you to look at what I did with B. So, instead of printing a as and when I saw the elements, I started collecting them in B right. If you notice, I started collecting them in B right from line 24 onwards, I started collecting them in B. So, at the end of all the traversal, my B, the array B would have M times N elements index from 0 to M into N minus 1 right. What I did here is I printed elements from 0 to M into N minus 2 with a space and printed the M into N minus 1 element without the space because that is the last one. So, I did not do any printing before this. So, this is a nice way to do things because you are done with all your work, you just have to concentrate on printing now, you just have to do this one step right. So, this is a common way in which you can solve several presentation problems that you have been seeing so far. Always go and record what your output must be and take care of the printing as the last thing in the program. So, this is something that did not touch the logic of the program ever. So, I believe that many of you had trouble in putting the logic for printing appropriately inside the loop itself, but I wanted to show that you can do all of this without worrying about the logic. All I did was I saved all of them in an array called B and finally, I printed them outside right. So, this is a technique that you can use for many problems in week 3 onwards right. I hope you actually adopt this technique from now on. So, thank you very much and I hope that you enjoyed this session as much as I did. So, there are lots of interesting things that happened here. I did some mathematical derivations to show that you can only run m by 2 times or n by 2 times whichever is smaller and I will leave it to you to think how I how do I know for sure that either I have only one row left or one column left or exactly one element left. So, go and think about that it is a very interesting and challenging problem to think about. So, I knew that I had of time because of the way because of the way I was doing things. So, maybe you should go and practice yourself on how to prove something like that and proceed with it. So, thank you very much and see you next week. Bye bye.