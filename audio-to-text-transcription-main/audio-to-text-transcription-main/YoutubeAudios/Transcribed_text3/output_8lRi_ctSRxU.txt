 So, let us move ahead to a very closely related topic, which is polynomial evaluation where we need similar tricks to improve the efficiency of evaluating polynomials. What are the polynomial, which you see here, which is P of x, which suggests that the name of the polynomial is P and x is a variable and the polynomial is a n x power n plus a n minus 1 x to the power of n minus 1 all the way up to a 2 x square plus a 1 x plus a naught. So, this is a polynomial of degree n, which means that the variable x occurs as x power n and a 0 a 1 to a n are coefficients. As you can see there is an example here, the example is a quadratic polynomial. In other words, a polynomial of, it is a quadratic polynomial, which means the polynomial of degree 2 and the algorithmic exercise is an extensively used algorithmic exercise, though it looks extremely simple. Input a polynomial given a polynomial P of x as input and a value v for x, x is given a value v, the challenge is to output the value P of v. So, for example, let us take the given polynomial and let us say v equals 2, in which case we have to compute 2 multiplied by 2 square minus 3 multiplied by 2 plus 1. And this is 8 minus 6 plus 1, which is equal to 1. Observe that there are many ways of evaluating this polynomial and the most simple way of evaluating this polynomial is the following, iterate a algorithm where you evaluate the formula, evaluate the polynomial from right to left. You have to evaluate the polynomial from right to left. What do I mean by right to left? You start off in the i th iteration for i is equal to 0, you take the value a 0. And this is the value that you have computed. For i is equal to 1, you take the value x multiplied by the value a 1 and perform an addition. In the iteration number 2, you take the value x, you multiply it by x again, which is gives you x square, store this and keep it with you or store it in a temporary variable, multiply it this by a 2 and add the value that you have computed so far. And in iteration number 3, you take the value of x square that has been computed in the previous iteration, multiply it by x, you compute x cube, multiply it by a 3 and perform an addition. This is what I mean by evaluate from right to left. In other words, you can think of it as the polynomial being evaluated from the element of least degree to the element of highest degree. Note that a 0 is a constant, the multiplier is x power 0, that is 1 right. And you evaluate this all the way up to a n x power n. Let us evaluate this algorithm, indeed the algorithm is correct because it is quite clear that in every iteration, one part of the polynomial is being calculated on the given value v. So, in every iteration you calculate v power i from v power i minus 1, you multiplied by a i, this costs a total of 2 multiplication operations. Then you add the result to the current value which gives you the value of the polynomial on the degree i polynomial, that is a i x power i all the way up to the term a 0. The total number of arithmetic operations that we have performed is 2 in multiplications, that is in every iteration you perform 2 multiplications and 1 addition. And this counts for 2 in multiplications plus n minus 1 additions, this is a total of 3 and minus 1 arithmetic operations which are performed. Let us know see if there is a way of improving this. And this improvement is a very clever trick which is a very important trick which is called the Horna's method for evaluating the algorithm. To understand the Horna's method of evaluating the algorithm, it is extremely important for us to visualize the polynomial which we are interested in evaluating in a slightly different form. In other words we rewrite the polynomial. And how do we rewrite the polynomial? Let us just look at p of x, we rewrite it as a 0, the constant term in the polynomial. And in the remaining terms x is a common factor. If you look at all the other terms x is a common factor, that x is factored out. And the remaining polynomial is called p 1 of x. In other words p 1 of x is a n x power n minus 1 all the way down up to a 2 x plus a 1. Observe that p 1 of x is obtained by taking the first n terms of p of x and taking out the factor x from them. For example, if you go back and look at p of x, if you look at p of x, it has the first n terms have x as a factor, you just take that out and consider the remaining polynomial and what we get is p 1 of x. So, we have already seen that the Harners method is an optimal method for evaluating a given polynomial given as the set of its coefficients in the sense that it uses exactly the required number of arithmetic operations. In other words, to evaluate a polynomial of degree n at a given point for the variable x, we need definitely n multiplication operations followed by n addition operations and observe that we are not counting the number of operations which are required to compute the higher powers of the value v that has been given. What we have just seen is that the Harners method uses exactly the minimum number of operations. In other words, it is an optimal algorithm for evaluating a given polynomial at a given point or a given value for the variable x. So, let us move on and ask some questions about efficient algorithms for the most simplest looking exercise of multiplying n digit numbers. Here is the exercise, we have to write a program to multiply two n digit numbers and here we deviate slightly from the model that we have been looking at so far when we assume that any two numbers can be multiplied in any two positive integers can be multiplied in unit time. And we do not we discard that assumption and now explore the challenge of multiplying two n digit numbers. In other words, the two numbers have n digits and we want to count the total number of single digit multiplications that are required to multiply the two given numbers. So, let us look at this example which we see here which is multiplying the numbers 1, 2, 3, 4 and 5, 6, 7, 8 both of them as we can see are four digit numbers and the straight forward high school multiplication approach is to write down 1, 2, 3, 4, 5, 6, 7, 8 and now observe that eight has to be multiplied to each of these four digits. And then seven has to be multiplied with each of these four digits, six has to be multiplied with each four digits and five has to be multiplied with each of four digits. In other words each digit and one must be multiplied with all the digits and the other in the straight forward multiplication method which we are all very familiar with and therefore if the two numbers have end digits each we essentially are performing n square multiplication operations single digit multiplication operations. This example it is of course 16 multiplication operations the question now is can we come up with an algorithm which uses a lesser number of single digit multiplication operations. Let us try to post this question very clearly and that is exactly what has been written as the question at the end of the slide can we come up with an algorithm and along with the algorithm we must write down a formula for the number of multiplication operations performed by that algorithm and that formula must be smaller than n square for all values of n except for some finite number of n. I repeat this the exercise now is to come up with an improved algorithm. What do we mean by an improved algorithm? We want to come up a design and come up with or design an algorithm not just design the algorithm but we also want to analyze the algorithm and come up with a formula for the number of operations which are performed by the algorithm. What property do we desire from such a formula? We desire that the formula must be smaller than n square at all values of n except for a few small values of n meaning maybe for the first 10 numbers n that is for up to 10 digit numbers maybe n square is smaller than the formula that we have come up with but beyond 10 it must be larger than the formula that we come up with and other words our formula must be smaller or the formula associated with our algorithm must be smaller. So, there are two tasks here one to design the algorithm and two to analyze the algorithm and write down a formula for the number of single digit multiplication operations that it performs. So, we have already seen a very straightforward method let us do something more sophisticated and interesting and exciting and this is the Karat Subhaz method. So, let us just recall the whole exercise we want to multiply x and y which are 2 n digit integers. These are 2 n digit integers and the way we do this is to look at x and y in a slightly different way. So, what we do is we consider x to be in the form x 1 multiplied by 10 to the power of n by 2 plus x naught and y to be y 1 to the power of 10 to the n by 2 plus y naught. So, let us do a small exercise. So, let us consider x let us consider x to be equal to 3 4 5 6 and y to be equal to 6 7 8 6 7 8 9 1 4. So, the total number of digits in both these cases is 6 we write x to be 123 multiplied by 10 to the power of 3 plus 456. Clearly, this can be very easily done 6 is divisible by 2 that gives an exponent value of 3 and therefore, you can write this as 123 into 1000 plus 456. Similarly, we can write down y to be equal to 678 multiplied by 1000 plus 914. What are we interested in? We are interested in the value x multiplied by y which is this term multiplied by this term. This is a product of the right hand sides. I hope the approach is clear. So, the most important thing is that 123 multiplied by 1000 and 678 multiplied by 1000 are very easy to evaluate and they do not require multiplication operations. 123 multiplied by 1000 just involves us writing down 123 followed by 3 0s. Similarly, 678 multiplied by 1000 just requires us writing down 678 followed by 3 0s. If one wants to compute the product of 123,678,000 then one only needs to evaluate 193 multiplied by 678. Once we have computed this number, we pad it with 6 0s. Let me write this just for the purposes of visualization in this form that we just need to evaluate 193 multiplied by 678. Observe that we wanted to multiply 2 6 digit numbers and because we know that we can pad these 6 0s, this is the multiplication of 3 digit numbers. This is the multiplication of 2 3 digit numbers. This is the whole idea that we have reduced the size of the problem and this is extremely important. We have reduced the size of the multiplication problem in one step by rewriting the number in this form from a 6 digit multiplication to a 3 digit multiplication. But of course, there are some tricks involved. It is not so straightforward. As you can see, there are some more multiplications to be done. So, let us go back to our slide and look at it in the formal way. As we have just seen, we have seen that x can be written in this form and y can be written. In this form, we did see this through an example. We saw this through this example. Now, let us just focus on the values of y0, y1, x1 and x0. We have already seen that x0 and y0 are smaller than 10 to the power of n by 2. Now, let us just look at xy, the product that we are interested in and see how this can be rewritten. This can be rewritten by just expanding this term out. When you try to expand this term out, let us assume that the coefficients that one gets are z2 multiplied by 10 power n. That is the product of x1 and y1 is written down as z2. Then, there is a term where the exponent is 10 to the power of n by 2. This is the product of x1 into y0 plus x0 into y1 and then there is a product of x0 and y0 which we have written as z0. We have already seen that multiplication by powers of 10 is adding least significant 0s. Now, is this going to help in reducing the total number of multiplication operations, single digit multiplication operations? Let us just focus on z2 which we have already seen that is x1 multiplied by y1, z1 which is x1 into y0 plus x0 into y1 and z0 which is x0 multiplied by y0. The most important thing is that this value, this is 10 to the power of n by 2. This is selected so that in the sub-problems, there are just n by 2 digits that need to be multiplied. In every number that needs to be multiplied, there are just n by 2 digits. Now, let us just look at the second term which is the most important thing. Observe that as of now, there are 4 multiplications to be done. That is, this is a single multiplication. It looks here that this is one multiplication and this is a second multiplication and then this is the fourth multiplication. However, a small trick of rewriting z1 into x1 plus x0 into y1 plus y0 minus z2 minus z0. So, let us just see this. z2 is x1 minus x1 y1, z0 is x0 multiplied by y0. If you evaluate this and subtract out z2 and z0, we get exactly what we want which is the value of z1. Now, observe that this is a single multiplication operation and what we are going to see is that all these multiplication operations involve just n by 2 digits. So, let us just go to the example. So, remember that we wanted to multiply these two six digit numbers. We wrote the number down as 123 into 1000. How many digits are left now? Half the digits are left. If you notice here, there are n by 2 digits. There are just 3 digits here. Similarly, there are also 3 digits here. Further, observe that these two numbers are obtained by looking at the 3 digits of x. The first is the least significant 3 digits of x and the least significant 3 digits of y. Therefore, those two values have to be lesser than 1000. They cannot be 1000. They have to be lesser than 1000 because they involve only 3 digits. Same with this term. Therefore, what is the conclusion? The conclusion is that we now have 4 3 digit numbers. We started off wanting to multiply 2 6 digit numbers. We have broken it down into 4 3 digit numbers and going back to our previous slide. We are now wanting to evaluate. We have now observed that x1, y1, y0, y1 all are n by 2 digits. In that example, they have 3 digits. Now, let us just look at the reduction in the number of multiplication operations. Both x1 and y1 as we have seen are smaller than 10 to the n by 2. That is, they have less than n by 2 digits. Same with y0 and y1. Secondly, let us just look at the sum of the 2 of them. This is just 2 n by 2 digit, 1 n by 2 digit multiplication, z0 which is x0 into y0, both are smaller than n by 2. This is again 1 n by 2 digit multiplication. We only have to worry about and reason about this multiplication operation. This multiplication operation. Let us just observe that x1 and x0 both are numbers smaller than 10 to the n by 2, 10 to the power of n by 2. When you add both of them, how many digits can you get? That is, you have two values which are 10 to the power of n by 2 and when you add the two of them, how many digits can you have? You can have a maximum of n by 2 digits because both of them are smaller than n by 2. Let us just go back to our example. Observe that 456 and 914 are 3 digit numbers. When you add both of them, at the most, you can get a 4 digit number. Let us just see this. You can have 99. You can have 99, a 3 digit number. Add it with another 99, which is another 3 digit number. This is 1998. Observe that it is a 4 digit number. Therefore, the most important point that is being made is that if you add 914 with 678, you can at most get another 4 digit number and not a 6 digit number. That is the most important thing. You do not get a 6 digit number. Let us just see what the gain in the arithmetic is. The gain in the arithmetic is we have three multiplications of n by 2 digit numbers. We have four additions and two subtractions. We have one multiplication by 10 power n and one multiplication by 10 power n by 2. And the last two do not are not counted as multiplications. They are just shifting operations or adding zeros, least significant zeros. Let us just go back and calculate this. You see one subtraction, a second subtraction. Then you see two additions here. Then there is a third addition and a fourth addition and there are three multiplication operations. So, therefore, let us formally analyze the gain in arithmetic. The running time of the algorithm that we have just written, where we want to calculate the total number of multiplications. That is our measure of running time. Let us not count the number of additions and the shift operations. Let us just count the number of multiplications. The number of multiplications on two n digit numbers is given by three multiplications on two n by 2 digit numbers. And if you multiply two two digit numbers, we take this to be equal to four. This is easy to check. This is called a boundary condition for this recurrence equation. What is a recurrence equation? The value for multiplying two n digit numbers. A number of multiplications, single digit multiplications to multiply two n digit numbers is given by three times the number of multiplications to multiply two n by two digit numbers. The solution for this, the solution for this is given by n to the power of log 3 by 2. The solution for this is given by the value n to the power of log 3 by 2. And observe that log 3 base 2 into the power of log 3 to the base 2 and observe that log 3 base 2 is smaller than 2. Therefore, n cube into the log 3 base 2 is smaller than n square. And n square is a total number of single digit multiplications in the simple method. This brings us to the last module here, which is the concept called a big o notation, where the focus is how do we compare a pair of algorithms? Observe that we have done analysis of running time of these algorithms by different methods. We use simple methods and sophisticated methods. So, let us just look at the Karachubha's method. We know that the Karachubha's method uses n to the power of log 3 base 2 multiplications and this is smaller than n square. This is smaller than n square. How does one capture this? We capture this using the big o notation, which will be the focus of the next lecture. Thank you.