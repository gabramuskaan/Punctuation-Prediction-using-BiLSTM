 So, in the last class we learnt how to analyze the complexity of algorithms. Now, we will take some somewhat more serious examples. We will take the problems of sorting and searching, you may have already learnt that selection sort, bubble sort, insertion sort in your college and quick sort and merge sort or faster algorithms. So, what we will do is we will take one linear sorting algorithm which is selection sort and then we will look at quick sort first and then we look at some searching algorithms also. So, actually I have given an array here what is the objective you have an array which is unsorted and the objective is to produce an array that is sorted. I just started the indices from 1 to a 8 here just to in although you can see it starts from 0 through 7 just for when you look at the represented as a set of numbers in pseudo code you write it starting from index 1 and you want this output. Whereas, in searching what do I want to do I have given a sorted array and given a key 12 let us say and I want to find out whether the key is present in the array or not. It should return the location where the particular key is present in this example for example, when I have given key 12 here it should return the index 4 on the searching example. So, the selection sort algorithm is a very simple algorithm and I have used again the swap to do this it is not required though but nevertheless it is not very efficient. Let us say I have an array like this I am just taking some arbitrary array what you do in selection start let us say this was 10 or 25 26 12 28 and 7. I have written it a little inefficiently in the piece of code here does not really matter. So, start with this and then I compare this element with all the elements in the array. So, I have a pointer I here a pointer j goes to the entire array then I find out which is the most minimum element and I put that element in the first position. So, 2 goes here and 25 10 6 12 13 8 7. I have written a slightly inefficient version in the nodes because whenever I see 2 numbers which are the smaller number is seen I just exchange them that is not required actually you just need to find the location of the smallest element. So, now I know that the most minimum element in this is the first position next what do I do I start with this element. So, this is my pointer I have the pointer j which again goes to the length of the array finds the most element element this is 6 over here put 6 here and 25 this here. So, you get the idea. So, repeat this process until what happens finally, the last 2 elements for example. So, initially it is being this j loop for example goes from let us say index 1 2 3 4 5 6 7 8 the first time the j loop is executed 7 times next time it is executed 6 times and so 1 until it for example for j equal to until it becomes the size of the array which we need to process becomes 1 we have to keep repeating this. So, basically if you look at depth for example next after this 2 and 6 have been processed we are starting here and then I compare with these elements and I find 8 is the smallest element 2 6 8 to be here 25 to well 13 10 and 7 is what you will have. So, 3 elements are already sorted and then you look at this part of the array again j goes from this point until n I keep repeating this process. So, what happens is the size of the array which needs to be sorted keeps on decreasing from iteration to iteration and the size of the sorted array also it gets incremented by 1. But notice that the time that I am going to take the first time I am making n minus 1 comparisons then I am making n minus 2 comparisons n minus 3 comparisons and if I count through all of them until finally, I make 1 comparison the time complexity of this algorithm is going to become order n squared where n is the size of the input what is the size of the input here is the length of the array. So, I just given this program in C over here. So, notice this is comparison assignment and increment I say order 1 this is order 1 all these are order 1. But what happens is this slope for example, if you write it in terms of time complexity it is order n again here I have 2 program segments this assignment takes order 1 and this takes order n therefore, it is like a sum rule it becomes order n and then this for loop is executed order n times. So, therefore, it becomes order n squared. So, this is the program of the form p 1 into p 2 into p 3 out of most for loop is p 1, in more for loop is p 2 and then within that there is a program p 3. So, this is how you compute the time complexity of selection sort this is a bit inefficient. So, what we do is we do a slightly different algorithm called the cubic sort algorithm and what we do in the quics sort algorithm is the following we do it a little differently start out with this and what we say is let us start with 2 points we define what is called some pivot element just for convenience I am going to take the fourth element as the pivot element let me call it the pivot element then you have 2 pointers i and j. Then what do we expect the pivot element is 6. So, what you do is you keep moving the pointers i and j until you come across an element which is larger than the pivot element on the left hand side and on the right hand side you come across with until you find an element which is smaller than the pivot element. So, initially itself you are having this then what you do is you simply exchange them. When I exchange these 2 I will get here 7 25 26 12 13 8 and 10. Next what do I do I move forward 25 is still larger than is larger than 6 and 8 is the same size is larger than 6. So, I ignore this I keep moving forward and what do I find here actually 6 for example, it is not smaller than 6, but it is not larger than 6 either. So, what I do is 25 will move here and 6 will come here then I come across this and clearly this is smaller than 6. So, I leave it as it is now what this does is divides the array into 2 parts where 1 part consists of elements which are less than or equal to 6 and another part consists of elements which are larger than 6. Then on each part again I repeat the same process find the pivot element again and then move the make the movements for example, here again pivot will be 6 then notice that 7 is larger than 6 and 2 smaller than 6. So, 2 comes here 7 goes here I repeat this then again what happens the array will get divided into 2 parts then again I stop when the array size becomes 1. That is what the or the pointers cross for that matter and it is exactly what is being done every time over here. So, what we are doing is left is less than j. So, basically we have 2 parts here left and right of the array are past us argument to the quick sort algorithm. I is assigned to left j is assigned to right you we are choosing the pivot element as a middle element here this need not necessarily be true. Now, what are we doing when array I less than x I am incrementing the array I then while x less than array j I am decrementing it then if I is less than or equal to the 2 pointers of not crossed then what are you doing we are performing an exchange over here then we decrement and this and what are we doing until the 2 pointers I and j cross because once you cross that means, I have processed the entire array once then what do we do if left is less than j that means, the number of elements is more than 1 then I call quick sort again with the new left value a new j value similarly I call quick sort again with the new I value and the new right value. So, when I keep doing this if the array is very if the quick sort algorithm is very good then what you will find is the array here for example, of size 8 will get divided into 2 parts of size 4 which will get divided into 2 parts of size 2 which will finally, get divided into 1 element arrays and the algorithm will terminate. So, what you see is that this other the selection sort was an n squared algorithm, but here what you are going to see is the this quick sort algorithm is order n into log n let us see why this happens in each this let us see the first time I am looking at the array this is a second time the third time the fourth time assume that it is an array of size 8. So, first time I am looking at the array I am looking at an elements then it divided into 2 parts 4 and 4 then again for example, these 4 elements of the process these 4 elements also have to be processed the next 2 elements again all the 8 elements have to be processed and here finally, all the 8 elements. So, when you look at what is happening is that the depth of this recursion how many times the recursive call is going to be executed is only log n and every recursive call means I am processing all the n elements therefore, the time complexity is order n log n of this quick sort algorithm. There are other sorts like the merge sort quick sort of course, has a worst case type grompless t of order n squared will see why. So, for example, what we do is just as we saw the recurrence equation we write the recurrence equation let us say the best case t of n is divided into 2 t n by 2 plus c n because all the n elements of process t of 1 is equal to d. So, in general the quick sort analysis it divides into 2 parts t of i and t plus n and t of n minus i remember in the example we had one array of size 3 and another array of size 5 this is what it will be. So, where is case what can happen the depth can become every time it divides the array into 2 parts such that the only it divides into 2 parts as there are n minus 1 elements and 1 element and this again let us say it divides into 1 element n and minus 2 elements then this depth will go down up to n and the time complexity instead of being order n log n will become order n squared. So, this is about the sorting algorithms that we have looked at now we look at searching we look at simple linear search and binary search what are linear search now we have an array which is already circuit going back to this example that we have here we have a sorted array we are giving a key and we have to find the location of the key in the array. So, let us do linear search. So, what are we what am I going to do while I less than n and not found if I are if I equal to key found equals 1 else I plus plus return I return found basically telling you the key is found or not found. So, the this is a very easy program of course, it is not capclizing on the fact that the array is already sorted because I could have also checked if I the array is greater than key and you could have also existed, but nevertheless in the worst case if I am using this called a linear search algorithm I have to search through all the elements in the array let us even if it sorted 2 10 15 16 30 35 and 40 let us say and I am looking for the element 40 then you have to process you to check with every one of these elements whether the key for keys there or not. Therefore, the time complexity in this case notice that there is a while block I less than n order 1 order 1 all these are comparisons are order 1 assignment is order 1 increment is order 1, but the while block for example, this is a program of the kind p 1 into p 2 and this runs n times therefore, the complexity is order m. All right the there is another better way of doing it if the array is already sorted and this is the binary search algorithm and the idea is basically the following what we do is let us say I have sorted array like this what we do is we divide the array into 2 parts let us say this is 1 2 3 4 5 6 7 and 8 find index of the milling element this is 1 plus 8 by 2 which is equal to 4 and then let us say I have given the key 12 I compare it with this middle element clear it is less than 12 that means, it is not likely to be found in the right of the array it is likely to be found only in the left of the array. So, what we do is that means, I can restrict my search to only this part. So, what do we do next now we divide this part again team 16 into 2 parts what is the middle part now 10 I compare it with 10 it is larger than 10 therefore, it must be only in this part and what is this now this indices are 3 and 4 therefore, where is the middle element now I compare it with 15 and clearly the number is less than 15 and it is not there in this part therefore, the key is not found in this array. So, how many times did we execute it now the first time I divided into half then again we divided into half and we divided it a third time. So, what happens is in this particular example we find that binary search is executed actually only log in times let us see this. So, here again remember how we get complexity analysis order 1 here comparison is order 1 is 3 is greater than the adder of the middle element when we doing binary search this is going to take order log in time and here this again is going to take order log in time k equal to lower than I am just returning back location and so on and so on. So, each recursive call divides the order into 2 this recursion is what makes it log in because going to be executed log in times the recursion terminates when the array size becomes 1 and the number of recursive calls is log in therefore, time complexity is order log in to the base 2 as I said best is to draw the recursion tree whenever you have recursive algorithms to solve for. So, basically what did we see here array got so I started out with 8 then it goes to 4 then it goes to 2 this comes 1. So, basically 1 2 3 4 my n is 8 therefore, it is order of log of 8 to the base 2. So, this is the number of computations. So, this is how you solve the time complexity of programs we looked at recursion we looked at sorting we looked at searching algorithms and we have analyzed the time complexities. So, we are now ready basically that we have also learnt the basic data types and the basic control structures that are there on programs you did it in the c programming part and I just reinforced it in this part of the course of quick reinforcement and basically now next what we are ready to do is how do I combine all these small data types like float integer, car, array and functions to solve better problems. Can I think of a nice data organization which will enable me to solve the problems better and that is the part on abstract data types which we will talk about. So, we will start with this in the next class.