 So, in module 3 we will look at repetitive statements. So, so far we have seen conditional statements both if and select using a switch statements and we will look at repetitive statements. So, repetitive statements are also called loops. It is a it forms a very important class of statements because you get to iterate or repeat over a set of operations. This is useful in lots of algorithms and it is a very basic construct. So, see offers three different kinds of repetitive statements namely the force statement, the wild statement and the do wild statement. We will see each one of them and see motivating examples for each one of them. So, in any loop construct no matter what language you pick there are two different kinds of loops that you can run. You can either have them counter controlled or what is called sentinel controlled. So, in counter controlled what you have is you have a set of operations and you want to repeat that a certain number of times and this number of times you have to repeat it is already known to you. Whereas, in sentinel controlled you keep looping until a certain condition is met. So, for example, you may wait till the user inputs minus 1 and you want to do a repeated set of actions still the user inputs minus 1. Maybe you want to find the factors of a number, but the user could keep on giving these numbers. At some point of time if the user inputs minus 1 you want to stop the program. So, if you want something like that upfront you do not know how many inputs the user is going to give. In such cases the sentinel controlled structures are useful and this structure is usually used when the number of iterations is dependent on the input and not on the problem being solved. So, let us start with the first one namely the for loops. So, for loops is actually the for loop construct is a counter controlled repetition structure. What you have is you start with an initial value of some counter and you modify the counter as we go along till you reach a final value. So, maybe I start with number 1 go in steps of 2 and let us say I stop at 43. In that case I would be using all the odd numbers. So, I am going in steps of 2 from 1. So, I would go 1, 3, 5, 7 and so on up till 43 or I may say just for 20 times print hello. In that case I would start the initial value at 1 the counter would go by increments of 1 and it stops at 20. So, this for for loop the way C does it it lets the programmer specify an initial value a modification to the counter as well as a final value and on top of that it also lets you put in a body or what you really want to do so many times. So, let us look at the basic expression you have a for loop and it starts it works like this. So, you have for which is a keyword and you have these 2 parenthesis and you have 3 expressions 1, expression 2 and expression 3 and the body of the loop goes inside this statement here. So, the meaning of this is you evaluate expression 1. So, expression 1 is just the initialization and you repeat something and what you repeat you evaluate expression 2 if it is true you execute statement if it is false you exit the loop. So, when you execute the statement you check if the expression 2 is true if it is true you execute the statement and evaluate expression 3 if it is false exit from the loop. Typically the statement that you have is a block of code therefore, usually you have to put this within braces. So, you have you need braces here and here typically because that makes a code of that makes a code block. So, let us take this small example computing the sum of first 20 odd numbers. So, to do so what we are going to do is we are going to have a variable called sum which is initialized to 0 and to that we are going to add k repeatedly and k is just going to be a sequence of odd numbers starting at 1. So, let us see the loop structure in place if you notice the structure of the for loop the for loop runs from i equals 1 i less than equal to 20 i plus plus which means this body that you are seeing here is going to be executed exactly 20 times. So, let us check what the overall structure of the program is we set k to be the first odd number which is 1 and i is the loop iterator or the loop control variable and i less than equal to 20 is the termination condition. Since we are incrementing i in terms of 1 using i plus plus this loop will run exactly 20 times and the body of the loop is in such a way that k tracks the i th odd number the very first iteration k is 1 the second iteration k is supposed to be 3 and so on it tracks the i th odd number and we are adding that to sum and we are incrementing k in increments of 2 which means from 1 we will go 3 5 7 9 and so on and this is the whole setup let us say we want to mentally simulate this. So, initially sum would be 0 and initially sum is 0 and k is 1 we start the loop when we start the loop i equals 1 and we are going to check if i is less than equal to 20 this is actually true. So, therefore sum plus equal to k so this plus equal to is essentially a shortcut for sum equal sum plus k so sum is 0 now we are adding 1 to it so sum becomes 1 and k we are adding 2 to it so k becomes 3 at the end of it we go and evaluate expression 3 which is i plus plus so now i becomes 2 so this is 1 body of the loop at this point we again go and check is i less than equal to 20 or what it is true so now we add sum plus equal to k so we add 1 and 3 sum becomes 4 and k is incremented by 2 so k becomes 5 and finally at this end of this iteration i becomes 2 and so on so from so essentially what we are doing is we are incrementing i and we will do this exactly 20 times so we will go from number 1 3 5 7 and so on 20 times so it is a fairly simple program but it shows you the basic structure of a for loop. So, let us take a small detour and look at what are the different kinds of operators that you can use we already saw equal to equal to in an earlier lecture we also saw greater than in the lecture where we are looking at largest of the numbers and so on there are other operators namely not equal to or less than or equal to greater than and so on so these are the 6 operators that you can use on numbers so you can use them on both integers and floating point numbers but more importantly we also need to understand this notion of what are called logical operators so in all these things that we have seen so far we have only one condition for the expression that we are evaluating sometimes we need more than a few conditions so let us look at this example where let us say if age is less than equal to 45 and salaries greater than equal to 5000 I want to do some work so I cannot so I want to combine this into one condition and you can do this using this operator called and the and operator when you type you type ampersand ampersand be careful it is twice it is not a mistake we have to type ampersand twice that is a logical logical and operation sometimes I may need something like a logical or condition either condition A is true or condition B is true in which case we want logical or operation and you get that using what is called the pipe operator so you press you have this pipe twice you usually see this pipe on top of the backslash symbol so backslash symbol and pipe are in the same key usually and for example if I want to see if a number is a multiple of 2 or a multiple of 3 then I could use this condition num percentage 2 equals 0 checks whether it is a multiple of 2 num percentage 3 equal to equal to 0 checks whether the number is a multiple of 3 and by sticking in this or operator in between I am checking if a number is either a multiple of 2 or a multiple of 3 so this is a very useful thing and we may use it in the next few lectures. So I want to give another example of a for loop let us say I want to print the nth triangular number so in the previous example the number of iterations was actually known in the program itself so we had i equal to 1 i less than equal to 20 so I said whenever we know the number of iterations it is better to use a for loop I want to show an example here where we really do not know the number of iterations because the user is going to input it but we still know that once the number of iterations once the user gives n the number of iterations is fixed so let us see this small example find the nth triangular number a triangular number is defined as the sum of integers from 1 to n so I am showing a small segment of a code here let us say I as before the iterator and number is the number of the nth triangular number that the user is asking for and some is the result that we want to give to the user so we start with prompting the user what is the triangular number that you want and we are going to scan it from the user we will start with sum equal to 0 so at this point I want to run it as many times as the number that the user wanted so now what we have is we have for i equals 1 i less than equal to number for i equals 1 i less than equal to number i plus plus the key thing that I want you to notice is that this number is not a constant in the previous example we had it as a constant now it is not a constant but the moment this is received from the user the number of iterations is fixed and that makes it suitable for a for loop so for i equals 1 i less than equal to number i plus plus sum plus equals i so the way this is going to work is you are going to check if i which is equal to 1 is less than equal to the number or not let us say I the number that the user inputs is 5 1 is less than equal to 5 you will add 1 to sum then i gets incremented to 2 2 is less than equal to 5 then 2 is added to sum and so on so you will add numbers 1 2 3 4 and 5 and the result would be 15 so that the fifth triangular number is 15 that would be the printout of this program let us look at another example where the user is going to ask for this multiple times so the user is going to ask for some nth triangular number but he wants 5 such numbers so one way in which you can do this is you can ask the user to run the program 5 times but that is not the most desired way to do it instead if we know upfront that the user wants 5 triangular numbers but each time the user may ask for a different triangular number and that is what we have here so we have a for loop here and this for loop is going to take care of the fact that we are going to ask for 5 at 5 numbers from the user and within each body of this loop outside we have this finding the nth triangular number so we are doing 5 iterations of asking n from the user and finding the nth triangular number and printing it and if you notice we have this blue body which is on this outer for loop and this orange body which is the inner for loop so what we have done is we have nested a for loop inside another for loop and this is also a very useful thing to do so we are having this outermost loop running on counter and the inner most loop running on i so we have two iterators and what this program does or what this code segment does is it is going to ask the user 5 times for what is the triangular number that they want and each time once the number is entered it will find the triangular number and print it out so I suggest that you go and write this code and see what happens so let us move on to the next construct which is the while construct so the general form of the while construct is while expression statement and as before the statement is a block of code so typically you put that within braces the semantics is that you repeat this following process you evaluate the expression first if the expression is true then you execute the statement if the expression is false you exit the loop so in the for loop exiting the loop is known up front you run it for a certain number of iterations and you exit the loop whereas in while loop you exit once the expression becomes false which means the expression must change inside the loop if the expression does not change inside the loop you would end up with an infinite loop because the expression would always be true will keep executing the body of the loop infinitely let us see a small example let us say I want to just print the 5 integers the first 5 integers a first 5 positive numbers so I can do this with a far loop running from 1 to 5 and printing it I am showing a small code segment which does something different so I have int count equals 1 so right when we declare we initialize count equal to 1 this is possible in C then while count is less than or equal to 5 print count and count plus plus so the key thing that you have to notice is that this count that we have here is actually changing right if we don't have this count would be 1 forever while 1 is less than or equal to 5 print count we would be printing 1 in an infinite loop however this count plus plus is changing the value of count so the next time you would check if 2 is less than or equal to 5 then you would check if 3 is less than or equal to 5 and so on at some point count would become 6 6 less than or equal to 5 would become false at that point you exit the loop and you move to this location you exit the while loop so this is a natural use for a while loop so this can be written using a for loop but this is a simple example to show how the while loop works let us see a more concrete example where the number of iterations is actually not known so the problem that I am going to post is finding the greatest common divisor of 2 positive numbers let us say the user gives 2 positive numbers let us also assume that m is greater than n there are 2 numbers m and n that are given and let us assume that m is actually greater than n if it is not you can ask the user to give it in that order or you could change m and n so that m actually becomes greater than n that is not the crux but I want you to look at this notion of GCD we are going to use an algorithm called the Euclitz algorithm and this dates back to 300 years before BC so it is a very old algorithm and it is a very neat algorithm so if I want to find out GCD of 2 positive numbers then GCD of m comma n is the same as GCD of n comma m percentage n where percentage transfer modelo and so I have 2 examples below to show that so let us say I want to find out GCD of 43 and 13 see in this case m is 43 and n is 13 and m is actually greater than 13 so the condition that we want to satisfy we start with 43 percentage 13 so 43 percentage 13 is 4 because 13 times 13 times 3 is 39 so 43 divided by 13 gives a reminder of 4 and now you take 13 and the reminder 4 you do 13 percentage 4 that is 1 and then you take 4 percentage 1 this is 0 so at this point you stop and you report this as the GCD right so 43 and 13 are both prime numbers there is no common factor so the common factor is indeed 1 therefore 1 is the GCD let us look at a different example let us say m equals 96 and n equals 28 we start with 96 percentage 28 so 28 3 28 times 3 is 84 therefore 12 is the reminder then you take 28 modelo the reminder that you got in the previous iteration 28 percentage 12 is 4 and 12 percentage 4 is 0 and therefore 4 is the GCD so even though in both these examples we do know that the number of iterations is 3 because we have worked it out up front you may not know what is the number of iterations that is required right so given 2 numbers you do not know the number of iterations that is required up front in such cases the while loop is a natural choice so let us see these basic code we start with if m is greater than n if m is greater than n GCD of m comma n is GCD of n comma m percentage n this is what we want to do and the code segment is as follows so if V is already 0 then there is nothing to do however otherwise what we do is we have a temporary variable called temp we find out U percentage V which is U modelo V that goes as temp and once you do that U becomes V itself and V becomes temp which is what we did here so it is called m and n here it is called U and V in the program so what we did was we took the reminder and called it we will call it V and take the previous divisor call it U and we repeat this at the end of it we will become 0 at some point of time and you report U as the GCD so now let us pay attention to the construct itself and not the logic of the program so what we have is we have while V is not equal to 0 so we keep doing this till we violate this condition and we have two braces here indicating that this is a body of the loop and this body of the loop up front we know we do not know the number of iterations you can see that there is nothing which is doing a iteration count however we are hoping that V will become 0 at some point of time so V does not become 0 at any point of time this while loop will become an infinite loop but because of the property of the numbers and the operations that we are doing here we will indeed become 0 at some point of time and use the GCD of two numbers so again I suggest that you go and try to different examples and ensure that this is actually correct go and verify that this algorithm is actually correct so finally I go one last example for a while loop so again in this at this point we do not know the number of iterations that we are going to execute so the problem is finding the reverse of a positive number so if I want the reverse of the number 234 it is 432 so I need three iterations to find out the reverse but I could give a number which is 19574 and this would be a five digit number you need five iterations in general if I give you a n digit number you need n iterations up front you do not know the number of digits that the user is going to give so the algorithm that we are going to follow is as follows so till the number becomes 0 extract the last digit of the number by doing number is by finding out the number model O 10 so you take a number find number model O 10 that gives you the last digit make it the next digit of the result by multiplying the result by 10 and adding the current digit so I will show you a simple example to make this clear let us say I want to let x be the given number and y be the number that is being computed let us say the user input five six three four two as the number which has to be reversed so 2 is the first digit of the resultant number we want 2 to be the first digit of the resultant number the way we do that is we take five six three four two and do model O 10 right that will get the remainder 2 allow it will extract only the last digit you take that multiply the previous one by 10 and add this to it that will result in 2 and what you do is you take five six three four two divide that by 10 to get five six three four what I mean by divide is you get only the quotient and not the fractional part so five six three four divided by 10 the quotient is five six three four at this point you do percentage 10 again you will get only four you take four and add it to two times 10 the number is 24 so so far we have taken the last two digits and reversed it then you take five six three four itself and again divided by 10 to get five six three and so on if you keep doing this at some point you get two four three six five which is the reverse of five six three four two but at that point x becomes 0 and it is a termination condition so you will keep doing this till x becomes 0 and this is a natural way of using a while loop so let us look at the program itself we have x equals 0 and y equals 0 and you expect the user to give a input number so input and integer and you scan it from the user if the user input 0 itself you check the condition while x is greater than 0 let's say the user gives 0 as the input then the while loop is not even executed once you can directly go and print y equals 0 so we also assume that the user inputs only positive numbers or 0 so if the user inputs 0 this while will not be executed therefore the reverse number is 0 itself however if the user inputs any number greater than 0 then we have y equals 10 times y plus x mod 10 so you remember the evaluation order we have parentheses here this will be evaluated first and that is doing modulo 10 of x that extracts the last digit but it adds it to 10 times y and x itself is diminished by a factor of 10 remember x being an integer the integer division you have integer divided by integer that gives you only the quotient and it truncates the decimal the fractional part so if you so x keeps diminishing by a factor of 10 every time at the end of it you have x equals 0 at that point this while condition is not true anymore when it becomes false you come to the end of the loop and you print the reverse number so this is a full program segment if you type it in your in your editor and compile it it should work let's move to the third construct which is a do while construct and the general form is do statement while expression the semantics is as follows execute the statements and then evaluate the expression so the key key concept is that you executed once and then you evaluate the expression if the expression is true you re-execute the statement otherwise exit the loop so this do while construct is different from the foreign while construct the foreign while constructs both check the condition once even before executing the body of the loop even once however in do while you execute the loop body at least once before you go into checking the condition so let's look at a specific example where do while is natural let's say I want the input numbers to be of a specific kind so I showed you an example earlier where we were checking if the number that is input by the user is a multiple of three or not if it is not we scan the we prompted the user to give this input once more and we scanned it but we had no guarantee that the user actually input a number which is a multiple of three so which means we have to repeatedly keep asking the user till the user actually inputs a multiple of three so this is a natural thing to do with a do while construct so let's see what is happening in this setup here let's as before look at the logic first and then we look at the structure itself so the very first time you have a do there is nothing to check you prompt the user by printing this on the screen and the user is expected to enter a number let's say the user input minus 5 then after this you go and check the loop so now we see an example of ampersand ampersand or the logical and so while x is greater than 0 and x percentage 3 not equal to 0 so the user let's say entered minus 5 minus 5 is not greater than 0 so this condition evaluates to false and this condition also is actually true so minus 5 mod 3 is not equal to 0 however since this evaluates to false and that evaluates to true the overall expression evaluates to false therefore the user has to enter another number at this point you go back here and there is nothing to check you go and print this on the screen once more you scan the users input once more let's say the user now input 9 if the input is 9 x greater than 0 would be true however x mod 3 would still be 0 therefore this while condition is still false you would go back and do the print up statement let's say now the user inputs 5 so we did minus 5 first we did 9 next let's say the user input 5 inputs 5 now and at this point 5 is greater than 0 is true and 5 mod 3 is not equal to 0 is also true therefore 5 is a valid user input at this point you the condition evaluates to true and therefore you stop here so you keep doing this till a certain condition is satisfied so let's look at the construct itself we have the keyword do followed by a block of code and the body of the loop is this one so that is the overall structure for the setup here right so let's look at this in summary in the for loop what we have is we start with an initialization condition we first check an expression if it's true you evaluate the body you do some loop increment and go back right and when you go back you have to evaluate the expression once more at some point this loop increment that you are doing will violate the expression at that point you exit and that's the false branch if you look at the while loop the while loop starts with some body and it checks the expression first if it is true you execute the loop body and come back and evaluate the expression if it is false you exit the loop so the key thing to notice is that this body that you have here must contain something that will change the evaluation of the expression if it doesn't change the evaluation of the expression you will keep doing this loop forever which we want to avoid and this picture clearly shows how do while is different from both these we have a body of the loop that is executed even before the expression is checked once so once you execute the body you then check expression if it is true you go back and execute the body once more if it is false you exit the loop and these are the three basic constructs that is available and see and depending on the problem you need to pick one appropriately so in summary for loops are used whenever you know the number of iterations in which number of iterations that you have to run the body of the loop a while loop is used if you want to check on a condition at least once even before you get to the body but you don't know the number of iterations that you need upfront and do while is used if you want to execute the body at least once even before you check the expression but you don't know the number of times the body is supposed to be executed so there are two ways to change the loop behavior there are two keywords namely break and continue I am not talking about this in this module we will see this later as we see the need for them so far I have been using devc++ to show you program segments I promised earlier that I will actually point out where you can get this devc++ it can be found at sourceforge website at sourceforge.net slash projects slash or well devcpp it is roughly about 42 megabytes in size you need to download the compiler the debugger the graphical environment and so on it takes about 42 MP in size I suggest that you download and start using that and it takes a few minutes to set up and not more so it is a very useful thing to download so of course there are several other development development environments if you are already using some IDE go ahead and use it if you are coming from the Linux world you are probably used to the shell and you very likely have a GCC or some such compiler installed already you can go ahead and use those also if you are familiar with them but since I am showing a demo using devc++ it may make sense to actually use it so that you can track what you are doing so this is especially useful if you are new to programming I suggest that you actually practice the problems that I have given so far at times I have given complete problem statements at times I am giving only code segments but you have to go and write a complete program you write complete programs whenever you can and whenever it is needed run the programs test with your own inputs and ensure that the programs that I have written so far are indeed correct so it is possible that made some mistakes somewhere along so it is better that you go and check these answers once before you move on to the next lecture so far in this week we have seen basics of programming in C we saw the notions of variables we saw the if statement we saw the switch statement and we saw for while and do while statements we also saw basic operators and how to print and scan inputs from next week onwards we will see more sophisticated uses of these constructs in solving different kinds of problems so we are at the end of lecture 2 thank you.