 Welcome to this module. In this module we are going to learn something called strings. This is something that happens in the real world very often. A name, your name and my name, college is name, things like that are all strings. C does not actually give you direct support for strings and this is why I wanted to have one small lecture on what strings are and how to manipulate strings, how to read, how to print and so on. So, a string is essentially a sequence of characters and the way C handles this is it handles it as a sequence of characters stored in an array and it is not just the characters that you want. It also has a special symbol backslash 0 or the null character. So, if you see this picture here, we have these five characters H E L L and O and so you can see that this H E L L and O are the five letters that I need, but there is an extra character called backslash 0 and the whole six characters is called a string. So, we have a string which actually contains five letters and the beginning of the string is H, the end of the string is actually backslash 0 which is a special character that C uses. We will in a little while we will see why that special character is needed. Let us say I have an array S T R of length 11. You can see that in this example, the string even though it has 11 bytes of storage allocated to it, it only has the contents good space day followed by the special character backslash 0. So, remember that is going to be part of every string. There are two characters or two bytes that are not used by the program. So, this character S T R of 11, it has four characters G O O D of space that is the fifth character. Then, 6 seventh eighth are characters of day and the ninth character is backslash 0. So, there are two characters that the string could take. So, this array can take two more characters, but the string ends at backslash 0. The other things the last two bytes are not part of the string. So, let us see the basic difference between what a character is and what a string is. So, let us say I say that there is a character H. So, let us say there is a character called H. It is a single byte representation. So, it stores H and nothing else. Whereas, if you store string H, it actually requires two bytes. So, it stores the letter H followed by backslash 0. So, this is why I said every string has at least this character backslash 0. See, even an empty string, a string that has no valid characters at all will still need backslash 0 or 1 byte to store it. So, to reiterate these points, a string is a sequence of characters enclosed in double quotes. So, in this example on the top S 1 of 2 is declared to be a character array. So, S 1 is a character array of size 2 and equals within double quotes a means the right side is a string expression. And in the string expression, remember a is a character and because it is a string, backslash 0 is always part of it. So, this will require two bytes of storage. On the other hand, if you do it character S 2 equals within single quote a, a is a single character and character they require only one byte. So, S 2 will allocate only one byte and you will store the letter a in it. So, this character S 2 is a single character, it is not an array and S 1, however, is an array of size 2 and it can store a as well as backslash 0. So, there is a difference between the storage that is given to both of these. So, let us take a few other examples. Let us say there is this message 1 and message 2 I have in this example here. So, message 1 is declared as an array of size 12 and we have initialized this to the string called hollow world. So, hollow space world. If you look at the length of it, hollow requires 5 characters and world requires 5 characters. So, that is 10 plus space requires 1 character. So, that is 11 bytes. On the left side we have allocated 12. So, the reason for message 1 of size 12, the message 1 being size 12 is that hollow and world requires 5 bytes each plus space is 1 byte, 11 bytes and remember there is always an implicit backslash 0. You do not have to put it explicitly. Backslash 0 is something that if you have as a string backslash 0 is assumed to be added automatically. So, the internal representation of message 1 would look like what you see here. So, you see hollow space WORLD followed by backslash 0. So, it is actually using all the 12 bytes that is allocated to message 1. So, it is not that you always want to initialize it and so, declare an array and initialize it. Sometimes you want to read things from the user. For instance, let us say I want to read the message from the user. So, I have message 2 which is of size 12 and I scan the message. So, the specify for scanning a string is percentage S. So, we have seen how to scan integers and characters and so on before. Percentage S is the specify for scanning a string. So, S stands for string. So, message 2 and let us say I typed hollow as input. Then H e L L O will go as the first 5 characters in message 2 and I said see automatically puts in a backslash 0 at the end of the strings if you scan them from the user. So, backslash 0 is the sixth character. So, that happens in the fifth location. So, 0th location has H, 1th location has E, 2th location has L and so on. The sixth location will fifth location would have backslash 0. And in this case, there are only 6 bytes that are required. The bytes following that even though message 2 has space for 12 bytes, it has only 6 valid bytes that are useful for the string. The other 6 are unknown. We have already seen this when we talked about the notion of arrays and what if we not initialize them. So, let us look at another example where we have initialization on the left side. We see character star message 3. So, message 3 is a pointer to a character or it could be a pointer to a character array. On the right side we have a hollow world. So, what happens here is this hollow world again as I said before requires 12 bytes. And if you print message 3, it will print hollow world with a space in between. But message 3 here is actually a pointer to an array of characters. So, one thing that happens is if you notice the left side, there is no explicit storage allocated for message 3. So, unlike message 2 or message 1 where you see that there are 12 bytes allocated, message 3 does not have any storage allocated to it. So, the way C handles this is the right side, what you see as hollow world is treated as a constant string. What that means is this is a string that cannot be changed. And this string is put into what is called the read only memory of the process or the program before the program starts running. So, there is a portion of the memory for every program which is marked as read only and this hollow world as a string is put into the read only program of the read only portion of the program. And message 3 is just a pointer to this read only portion of the program. So, we already saw the notion of pointers. So, message 3 is just a pointer to the beginning of this array which has hello followed by space, followed by world followed by backslash 0. So, the reason why this is critical is message 3 is not allocated space. You do not have space allocated for it, it is done in the beginning of the program and you do not even have control over it explicitly. So, if you do message 3 of 1 equals A and since hollow world here is saved in a read only memory location, this changing any contents of message 3 since you did not allocate space explicitly for it would result in undefined behavior. So, this is a common mistake that programmers make. So, if you allocate space like what you see in message 1 or message 2 which is ok to go and change the contents of it, you can read the characters as characters that you allocated, we saw integer arrays and so on earlier. So, this is just character arrays. But if you did not explicitly allocate a space like in message 3 now, see allocate space for the strings and you cannot touch it, you cannot change the contents of it. So, let us look at a small example. In this case we have character star A1 which is hollow world. So, what we have is we have a pointer to a constant string. So, what I mean by that is the string itself is constant, it cannot change and A1 is a pointer to it. Character A2 of square brackets is hollow world. What this does is it allocates space for A2 as much as it is required. So, let us look at the right side. The right side requires 11 characters for a hollow space world plus remember one character for backslash 0. So, A2 size will be 12 bytes and character A3 of 6, we have explicitly said A3 is supposed to be allocated with 6 bytes. On the right side, as long as we have 5 or less characters everything will be okay. So, if I said world, it is okay. But if I put worlds for instance, worlds itself will require 6 characters WO or LDS and there will be no more space for backslash 0. So, this example A2, this character A2 is called a constant pointer to string. So, I want to make this small distinction. So, A1 is a pointer to constant string and A2 is a constant pointer to string. So, let us see what this difference is. So, A1 is a pointer and it is pointing to a constant string. What that means is you cannot change the string. Whereas, character A2 is a constant pointer. What that means is you cannot change it. You cannot make it point to something else. But wherever it is pointing to the contents of it can be changed. So, I will explain this in a little while. But before that, let us look at line 4. So, I want to show the distinction between how A1 is handled versus how A2 is handled by C. So, if I go and use the size of operator, size of is supposed to tell me the size in the number of bytes of the data type that is passed to it. So, if you look at size of A1, A1 is a pointer character and a pointer to character is the same, will have the same size as pointer to an integer and so on. So, size of all the data types could be different, but size of the pointers in a specific machine will all be the same. So, size of A1 will be the size of the pointer. So, in my machine the size of pointers is all 8 bytes. So, size of A1 will print 8. Whereas, size of A2, so A2 being a constant pointer to a string is actually going to look at not the size of the pointer itself, but the size of what is pointer to. In this case, A2 is pointing to hello world that requires 12 bytes. So, size of A2 would be 12. So, if I took this program and ran it on my machine, I would get 8 for the size of A1 and 12 for the size of A2. So, this distinction happens because even though pointers and arrays are treated as something which can be interchanged, it is not always true. So, this is a classical example of a place where pointers and arrays do not really mean the same thing. Now, I said A1 is a pointer to a constant string. Therefore, if you make A1 of 1 equals U, you are trying to change a constant string. The string is supposed to be not changing through the program, but you are making A1 of 1 is U that will result in undefined behavior. So, you may have A1 even changing to HU LLO, but you cannot always expect that this will work. Sometimes when you run the program, this can even result in an error. Let us look at the next line A1 equals A2. So, A1 is a pointer, you can make it 0.2 anything else. So, here A1. So, if you look at A1, A1 is a pointer, it is pointing to something which is constant, but it itself can point to something else. So, in this place, we are making A1 0.2 A2. So, this is acceptable, this is not a problem. However, changing the contents of A1 is not acceptable. A1 can start pointing to something else. So, if you see what happens after this print of statement, you will see that A2, so A1 is pointing to A2. So, it will still print hollow world because A2 is also hollow world. Let us look at the last line, A2 equals A3. So, this is where this notion of constant pointer comes through. So, you can change the contents of A2. So, I can make A2 of 1 equals U that is acceptable. However, A2 is a constant pointer. What that means is you cannot make it point to something else. And therefore, A2 equal to A3 will result in an error and this error will be caught by the compiler itself. So, if you take this program and type it up, your compiler will come and tell you that there is an error in this line. So, again I will reiterate this. So, A1 is a pointer to a constant string. You can make A1 point to something else, but you cannot change the contents of A1. A2 is a constant pointer to a string. You can change the contents of A2, but you cannot make A2 point to anything else. So, let us go and look at how strings can be read. We saw how strings can be printed. Let us see how strings can be read. So, for example, scanf takes this percentage s as a specifier and you can give a pointer to the character array as a parameter to it. So, let us assume that there are two strings A underscore string and E underscore string. And let us assume that both of them have 80 characters in them, which means they can take 79 valid characters and you have to reserve at least one byte for the backslash 0. So, let us say I end up some typing something which is 7 terrain characters. The 7 terrain characters will go into location 0 to 78 and automatically backslash 0 will be put in as the 7 terrain character. So, let us say I did printf enter some words in a string, I prompt you and I scanf A string and E string and if I print it, so that is what the program is doing. So, this line is prompting the user to type something, this line is expecting the user to type something in the keyboard and finally, it is printing whatever is read in the keyboard. And let us say when this program ran, I typed this line, this is a test, let us say I typed that this space is space A space test followed by a dot. So, what happens is that the scanf percentage s starts from a particular location and keeps reading letters till it finds a white space. So, in this case E string when scanf works, it starts with t and then it reads h reads i reads s and it reads space. The moment it sees space, it says that ok. So, scanf the way it works is space is not scanned into the A string, it stops here, it puts t h i s followed by backslash 0 into A string. And subsequently when you are reading E string, what happens is it ignores the space goes to the next location which is not a space which is i here and it starts reading from there till it finds another space. In this case, it is the space in after i s. So, it keeps reading till it finds a space. So, it found the characters i and s. So, A string would have in the memory, it would have t h i s and backslash 0, this will be the five letters in A string. And if you look at E underscore string, the variable name E underscore string, it would have i s followed by backslash 0. So, it will have three characters. Even though you have space for 80 characters, it has only three characters of which only two are really valiant. This is how you read strings.