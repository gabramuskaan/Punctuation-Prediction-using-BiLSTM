 Hi, welcome back. We looked at functions and we looked at functions being called by the main program and so on. So, there is nothing which actually stops functions being called by other functions also. But there is an important and interesting class of functions which are called recursive functions. So, these are functions which actually call themselves and this is actually a natural thing that happens in lots of mathematical equations and so on. So, it is an interesting thing to learn. So, I want to talk about the notion of recursion in this module. So, let us start with a very simple example. Let us look at this notion of factorial of n. So, n factorial is defined as the product of the first n terms. So, formally n factorial is 1 times 2 times 3 times so on up till n. So, for example, 3 factorial is 1 times 2 times 3 which is 6. 5 factorial would be 1 times 2 times 3 times 4 times 5 that is 120 and so on. So, if you want to write a small program to calculate factorial of a number that is not very hard. So, you have seen loops and you know how to do it. So, let us look at this little function here called fact. It takes 1 parameter n and it has a result variable which is initialized to 1 and there is a loop iterator called i. So, the loop iterator runs from 1 to n. You can see that and the result is just multiplied by itself. So, you take 1 and then multiply with 1. So, that is in the result in iteration 1 then i becomes 2. You take 1 times 2 that is temporarily stored in result and so on. So, at the end of n iterations this loop will terminate and the variable result will have the corresponding factorial at that point you are ready to return it. So, there is a fairly straightforward and simple code and so we have seen this notion of function name the formal parameter n the return type int and actual return result and so on. So, one small issue this is result can only accommodate a certain value. So, integers in the real world are unbounded whereas, integers in c programming is bounded to a certain large value. So, if you give a large enough n this program may actually give you incorrect result. So, I suggest that you go and try something like 40 factorial and 50 factorial and so on and see what the result is. So, you will be surprised at the result that you get but this is because the variable integer variables cannot accommodate results of indefinite size. So, there is one way in which you can look at this program which this problem you can look at n factorial as the product of n times n minus 1 factorial. So, this is a very natural and recursive way of defining n factorial. So, this is something that you might have seen in your school days. So, n factorial is defined as n times n minus 1 factorial for appropriate n. So, clearly n cannot be if n goes to negative. So, this thing keeps going on forever and so on. So, we will have to be careful about it but for positive numbers for positive integers n this seems to be working nice. So, let us say I want to take this idea and convert that to a program as the idea shows. So, I would like to do something like this return n times factor of n minus 1. So, whenever I am going to call this factorial with variable n I am going to return n times factorial of n minus 1. So, that seems to faithfully do what this mathematical description wants. However, as I said we cannot go on doing this indefinitely because at some point let us say I start with 5. 5 will go down to 4, 4 to 3, 3 to 2, 2 to 1 and so on and at some point it will become negative and then what do we do. So, we have this extra check if n equals 1 we return 1. So, that is the base case for the recursion right even here you need a base case which defines 1 factorial as 1. So, this is clearly very short and if you understand how functions can call themselves it is easy to understand also and it definitely uses fewer variables. So, the nice thing about that is it becomes very readable. But the slightly messy thing here is that so you have fact and we looked at the control flow of programs. So, if main called fact we know what it does but then there seems to be a call to fact within fact itself. So, we need to understand how this is going to happen. So, let us look at this setup first. So, I have this program on the right side just for clarity sake and let us see we want to look at how this is going to work. So, I want to do factorial of 4. Let us say the main function called fact with 4. So, this local this formal parameter n will copy the value 4. So, n is now 4. So, factorial of 4 you go and check if n equals 1 at this point n equals 4. So, this condition is not true. So, it you have to return n times factorial of n minus 1 right. However, you have 4 which is n factorial of n minus 1 is not known yet. So, at this point you have to calculate factorial of n minus 1 which is factorial of 3 and then do this product 4 times that and only then you will be able to return the value right. So, it seems logical we we have 4 times some value that we need but we have not computed that yet. But once it is computed I can multiply that with 4 and I will have the result of factorial of 4. I will be able to return the value right. So, but now that I have this fact of n minus 1 let us see how to do that. So, fact of 4 in in turn calls fact with the parameter 3. At that point factorial of 3 again you cook. So, n takes the value 3 now and this multiplication is pending and this value 4 has to be remembered. So, we will look at that in little more detail later but remember that this star this multiplication is pending as of now we cannot do it yet. So, we by by that time we get the factorial of 3 we can then multiply it. So, to find out factorial of 3 we call fact with within fact itself and again you check if n equals 1 at that point n equals 3. So, 3 times factorial of 2 is required. So, we want fact of 2 again at that point I should remember that n is 3 and I need to do multiplication. So, there is a pending calculation and there is a value with which you have to do it. But right now I am going to just go and look at how to compute fact of 2. So, again if we go one step further it says take 2 and multiply with factorial of 1. But finally, when you call this with factorial of 1 at that point n equals 1 and this condition is true if n equals 1 return 1 which means you are actually going to return from the function. This else clause will not be looked at anyway because it is n equals 1. You are now ready to return from the function and what are you returning you are returning the value 1. So, factorial of 1 is 1. So, we have touched the base case of recursion at this point we know fact of 1. So, there was this pending multiplication it was waiting on this factorial of 1 to be calculated. So, we return the value 1 and this 1 when you multiply by 2 factorial of 2 is 2. So, what are all the pending things at factorial of 2 it has to it was remembering 2 and then this product was pending once the product is ready. So, once the other factor is ready. So, you have n time factor of n minus 1 let us say n equals 2 once factorial of 1 is ready you have to compute this product and that product remember has to be returned. So, now we have computed the product as 2 and this once that is computed as 2 you are now ready to return it and there was this version of fact where n was 3 it was waiting on factorial of 2 to be returned back. So, factorial of 2 is now 2 you are now ready to do the product which is 6 and you are now ready to return it back. So, if we continue doing this at some point we will go back to the very first function call that was made to fact. So, we called with 4 so 4 times now I have factorial of 3 ready which is 6 so 4 times 6 is 24 we do the product and we are now ready to return the so 24 actually gets returned back to the caller of fact of 4. So, this is how this works. So, this may look like a little bit of magic right now but we will see in the next slide in detail how this actually works. So, the calling version whenever it has spending work right it will just as though it will suspend itself and it makes a so it passes the control to the new function once the return value comes back it will do the pending computation. But during that time the caller needs to remember the values so once the return happens you get a value from there you have to remember what computation has to be done and on what value you have to do this computation. So, this is something we will look at in detail in the next slide. So, let us see how recursive function calls actually implemented. So, we already know with respect to functions that all automatic local variables and formal parameters are created every time you call a function. So, we saw this in in an earlier module that every time a function is called you have a new avatar of the variables they get used up during the function and when you return from the function all these actual actual parameters and automatic local variables are all destroyed also. So, this is not just true of non recursive functions it is also true of recursive functions. So, even for functions like fact this notion is true let us see what the implication of that is right. So, whenever you have these automatic variables and formal variables they are actually stored in an area called stack. So, this is something which is actually a region in memory and every function call will push what is called an activation record on the stack. So, the activation record contains what are the different variables that are local to the function and so on and the activation record gets pushed onto the stack you pass the control to the caller passes the control to the call E and the call E does various calculations and when a function called returns the activation record is removed from the top of the stack. So, all this may sound like theoretical mumbo jumbo let us see a pictorially what it is doing. So, let us say I called factorial for n equals 3 right. So, I called fact of 3 and the fact as a function creates an activation record right. So, at that point we have n equals 3 and we do not know the result yet right. So, this is the state in the beginning. Now, we call n times fact of n minus 1. So, n is already saved so that is there in your record result is unknown we will have to come and update the result later. But now you make a call to fact of 2. So, to do that it actually creates another activation record with n equals 2. So, remember it is not overwriting the value 3 here in the current activation record. It creates a new record and for the new record you know the value of n because fact of 3 called fact of 2. So, n equals 2 but fact of 2 the result is unknown so it is pending. Let us say at some point you called fact of 1 you create another activation record. So, you have this activation record n equals 1 and at this point the result is known right. So, this actually this activation record assumes that we go all the way down to 0. 0 factorial is also 1. So, instead of n equal to 1 if you are checked n equal to 0 and return 1 this example shows that. So, n equals 0 returns 1 and when that returns n equals 1 times whatever return from the previous activation record the result was 1. So, 1 times 1 is saved as the result for fact of 1 and this returns to its collar. Its collar is expecting to compute its result this collar is expecting the result from the collar and it has this variable 2 it has to multiply the result from the collar and the 2 and put that here. So, you have that and now the collar is going to return 2 the collar is waiting with another variable n which is having a value of 3 it will take that multiply it and put it in the result and finally, whoever called fact of 3 will return with a value of 6. So, that is how it works right. So, the basic premise in this thing is you have what are called activation records. So, the activation records are just copies of all the variables that are local to a function. If a function calls itself the activation record is kept and then you create a new activation record with new variables n and result and you compute things there and when you return you destroy the activation record and the result the return value is the only thing that is passed on to the collar. So, I hope this setup was clear. So, we will use this notion of recursion in solving this other problem. So, I want to look at a recursive way of solving power of m comma n we have already done this using an iterative setup let us say I want to think about it recursively. So, let us do this on a piece of paper. So, what we are going to do is we are going to look at a recursive way of doing power of m comma n. So, we called this base and n earlier so, I am going to call it m for now. So, earlier what we did was this. So, to compute m power n we did something like this we did m times m times m times so, on m and this you need n of those. So, actually what you are doing is you are doing n minus 1 multiplications. So, this is the key thing you are actually doing n minus 1 multiplications. So, let us take a little while and think about whether we really need n minus 1 multiplications. So, that is this nice recursive way of doing power of m comma n. So, I will take a specific example and show how this thing works. So, let us say I want to compute 3 raised to the power of 13. So, I could always look at computing 3 power 12 and then multiply by 3 or 3 power 11 and then multiply by 3 twice and so on. But one nice way to do this is take 3 power 13 and split half split 13 into half. So, 13 by 2 is 6.5. Let us look at the smallest integer so, the integer which is lesser than n by 2. So, n is 13 let us look at the integer that is just less than n by 2. If n by 2 is an integer we will keep that itself. So, what is that 13 by 2 is 6.5 the integer that is smaller than that is 6 let us start with 6. Let us say I am able to compute 3 power 6 right. I have to do some computation it is not going to come jump right into our lap. We need to compute 3 power 6, but then if I have 3 power 6 and I can multiply that with another copy of 3 power 6 and if I now multiply that by 3 this is actually 3 power 13. So, this is correct right. So, 3 power 13 is 3 power 6 into 3 power 6 into 3. So, what have we really done? We still have 2 multiplications. So, and instead of looking at 3 power 12 into 3 3 power 1 right we have it as 3 power 6 into 3 power 6 into 3. So, what is the big deal? So, what we are going to do is we are going to compute 3 power 6 right, but if I am going to compute 3 power 6 this product we can think of it as a pending calculation that we have to do. So, I am going to compute 3 power 6 somehow when I get that computed I still have to multiply that by something else. So, there is pending computation right. So, we will do the pending computation later. So, we have 3 power 6. Now, how do you compute 3 power 6? So, to compute 3 power 6 I am going to write it as 3 power 3 into 3 power 3 right. So, I have used the same idea I have taken 6 divided that into 2 divided that by 2. So, I have 6 by 2 which is 3 and I am going to calculate 3 power 6 as the product of 3 power 3 and 3 power 3. Now, again I do not have 3 power 3. So, I will keep this as a pending calculation right. I am going to compute 3 power 3. So, to do that I will have 3 power 1. So, 3 so this exponent here 3 if I divide that by 2 which is 1.5 I look at then it is just smaller than that which is 1 3 power 1 into 3 power 1 and this time the exponent is odd. So, it is not so you have to take care of the fractional part also. So, remember 3 by 2 is 1.5 if I only do 3 power 1 by 3 power 1 I get 3 squared not 3 cube. So, I still need to do a multiplication by 3 and to compute 3 power 1 I am going to look at how to do that. So, we know that any number raised to the power 1 is n itself. So, m raised to the power 1 is m therefore, we have 3 right. So, now this gives us in some sense a very nice and recursive way of doing it right. So, that is the recursion here. So, the recursion comes from the fact that if I have 3 power 6 I am going to call. So, for computing 3 power 13 I am going to call 3 power 6 to compute 3 power 6 I am going to call 3 power 3 to compute 3 power 3 I am going to call 3 power 1 to compute 3 power 1 I am like it is just any number raised to the 1 I do not have to call the same function once more instead I can have this base case that m power 1 is m that is what we have used here. Now, let us say we actually did that. So, to compute 3 power 3 we wanted 3 power 1 but we got that by making another function called to factorial it returned 3 right. So, we got 3 now. Now, what do we do this 3 we got 3 power 1 we still have some pending work right. At this point what is the pending work I have to calculate 3 power 1 and 3 need not be calculated. So, 3 power 1 and 3 I have to take a product of that multiply that with the current product that I got which is 3 itself. But one nice thing is that instead of making a function call to compute 3 power 1 we just got 3 power 1 right. We just got 3 power 1 by we made a function call for 3 power 1 we got the return result as 3 why do not we actually use that right. So, what happens now is instead of making another call to compute 3 power 1 since we just got the value 3 for 3 power 1 I will not use 3 power 1 I will instead use a copy of this right which is 3 itself now I have to do 3 times 3 times 3 the result is 27 and this 27 gets returned back to its caller right. So, 3 power 3 becomes 27 and I have to do some pending computation the pending computation is compute 3 power 3 and multiply that with whatever value I get right. But I just computed 3 power 3 now I will not call the function once more to get it I will just use a copy of this which is 27. I still have to do this pending multiplication. So, I have 27 times 27 that would be 729 right and that gets returned here right. So, 3 power 6 is now 729 I want 3 power 6 again but again I will do some computation I will just I just computed 3 power 6 I will use 729 here and I still have these pending multiplications this and this to be done. So, eventually I will do 729 times 729 times 3 right and that is the value of 3 power 13. So, let us look at the number of multiplications that we did right. So, to do 3 power 13 we did 3 power 6 into 3 power 6 into 3. So, that requires 2 multiplications right if I know 3 power 6 I have to do only 2 multiplications. To do 3 power 6 we did 3 power 3 into 3 power 3. So, that required only 1 multiplication to do 3 power 3 we did 3 power 1 into 3 power 1 into 3. So, that required 2 multiplications and to do 3 power 1 we do not have to do any multiplication we will use the base case of recursion that m power 1 is m we will use that directly. So, that requires actually 0 multiplications. So, if you add all of this up 2 plus 1 plus 2 right that is actually 5 we only did 5 multiplications as opposed to doing it as 3 power 13 if I had done it as 3 into 3 and so on right this would have required 12 multiplications. So, clearly 5 multiplications is better than 12 multiplications. So, I want you to go and think about what is really happening here if it is instead of 13 if I had used 20 if I use 25 and so on. I want you to think about what number of multiplications you will need if you did it using this way versus what number of multiplications you would need if you have done something like this. So, go and think about it you will also see how to write a so how to analyze this algorithm and how many steps it takes and so on in a later lecture. But let us get back to how to write a program for this because that is the thing that we wanted now how do you write a program to compute power of m comma n. So, I have written this simple program here to take care of this I have written a function called power it takes base and n as the 2 parameters as it was before and we have in p we had this earlier also right. So, instead of writing an iterative way of doing this we have a recursive way of doing this if n equals 1 return base right. So, this base case takes care of the fact that m power 1 is m right otherwise what I am going to do is I am going to compute p as power of base comma n by 2 right and if n is odd for example, in 13 n is odd. So, I need to take 3 power 6 and 3 power 6 and multiply that by 3 once more that is what you get here. So, this is p times p times num if n is even then you have only p times p for example, in here for to compute 3 power 6 it is enough to have computed 3 power 3 and reuse the 3 power 3 you would get 3 power 6 right. So, one thing that you have to probably recollect is that n by 2 if n is an integer will truncate the decimal value it returns only an integer. So, 13 by 2 is only 6 it is not 6.5. So, 13 integer divided by 2 integer is 6 it is not 6.5. So, now let us see how this whole thing would have worked power of 3 comma 13 right. So, n equals 13. So, this check would not have been true p would get power of 3 power 30 3 power 6 because n by 2 is 6 you call power of 3 power 3 comma 6 power of 3 comma 6 would transfer control to power again with n equal to 3 sorry n equal to 6. So, for n equal to 6 n is not equal to 1 that would have called power of 3 comma 3 power of 3 comma 3 would have called power of 3 comma 1. So, when n equals to 1 you have this return base so, it would have just returned 3. So, that is going to come back where n equals where n was 3 it will come back here right. So, you would have computed 3 power 1. Now, you check if 3 percentage 2 is 0 3 percentage 2 is not 0 it is odd number. So, we are looking at this exponent for this exponent it is an odd exponent. So, I have to take 3 times 3 power 1 times 3 power 1 times 3. So, that gives 27 it returns back here p becomes 27 for the case where n equal to 6 right. So, 6 percentage 2 is actually equal to 0. So, you do 3 power 3 into 3 power 3 which is 729 right and then you return to the case where actually n was like 13 for when n was 13 we called any power of base comma 6. So, you would have received 3 power 6 you take that as p multiply that by p and by 1 more value of num that gives you 159 4323. So, this is the basic idea of recursion. So, clearly for every recursive function at some point you should not call the function anymore. So, you have if n equals to 1 you return just the base without calling the function anymore. However, if n is greater than 1 you will call the function at least once more right. So, this is the basic idea behind recursion. So, you can think of it as in some sense even for induction we do this right for proof by induction we say this is the base case for induction and from there on we keep building things you can think of recursion in a similar way right. So, there is this base case and then you are building something on top of it. If you do not have a base case this program would be incorrect. So, we saw 2 kinds of recursive functions namely factorial and power and this is a very powerful setup because once you know recursion right there are several things that you can do very easily and you can write programs very easily you do not have to think about doing them in an iterative manner. But you have to remember a few things about recursion. The first thing is recursion must end at some point of time. If function f calls itself and it calls itself and so on it cannot go on forever. If you if you do that then the program is never going to terminate. So, it can be a problem. So, you should have some condition inside any recursive function to terminate recursion you should not call the function once more from the base case. So, for that go and think about what would happen if the check for n equal to 1 was not there for factorial we just did return n times fact of n minus 1 if you have done that see where you will stop. So, it is not that recursion is a silver bullet it is not going to be useful every time sometimes loops are very straightforward to use. So, you should see where to use loops and where to use recursion. So, in general what you have is recursive recursive functions are actually quite elegant it is very simple to write you can take any mathematical formula it is usually recursive you take that and write it down right it is very elegant. But in general it is less efficient. So, it recursive functions you should take more time and if you are not careful it can take a lot more time that this writing loops to do the same thing. And of course, in recursive functions you have to take care of the base case. So, there are several other things that you can write using recursion. So, one classical example is you can do what is called n choose r. So, let us say I want to do n choose r recursively I can use n choose r minus 1 plus n minus 1 choose r minus 1 right this is a recursive definition for n choose r. So, out of n objects if you want to choose r objects what are the number of ways in which you can choose them right. So, this is clearly recursive right. So, n choose r uses n choose r minus 1 plus n minus 1 choose r r minus 1. So, all these different things can be actually done with recursion. So, that brings us to the end of this module. Thank you very much.