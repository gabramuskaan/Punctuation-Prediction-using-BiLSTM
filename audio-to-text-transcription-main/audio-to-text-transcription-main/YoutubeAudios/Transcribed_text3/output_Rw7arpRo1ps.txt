 In the previous module we saw the basics of functions and how it is nice and how it makes it readable and so on. In this module we will go and look at this notion of functions in lots of gore detail. So, what is a function? Function is essentially a part of your program. So, one thing that you have to be careful about is it cannot be part of any other function. A function cannot be part of any other function. So, in the previous module we saw that there was a function called main which is the caller and there was a function called power which was the call e. We cannot go and take the program for power and completely put it within the caller. So, function cannot be completely written up inside another function. So, there are some languages to allow you to do that. C does not allow you to do it. I mentioned this earlier that main itself is a function. It is the main function. So, whenever you have multiple sub tasks, somebody has to know what is the very first task that you have to start with. So, usually it is the main. So, you start with main, main will have a sequence of steps. If there is any delegation of duty that you want from main, the main program should have that. The main function should have the delegation of duty. So, we had delegation of duty to power from the main function. So, execution starts from the main function. The control flow starts there. From there, the control flow can move to one function or another and return back and so on. So, every time you call a new function from a caller, you are essentially transferring the control to the callee. So, with the function call, you usually pass some parameters. So, in our case, we passed base and n and these parameters are used within the function. You compute some value, the value is returned to the caller and the caller could use it in some other computation. The caller can also choose to ignore the value that is produced. In fact, printf to be technically correct actually produces a return value. Only that generally, we choose to ignore the return value from printf. It does some work. It prints things on the screen. It actually returns a value also. Only that we usually do not care about the return value. It is not useful for most programmers. Let us look at the template of a function. We have a function name. We have all the argument declarations and we have a return type. And you may want more declarations inside your program itself. You have further declarations and statements and finally, you have a return expression. So, the function name identifies the name by which you are going to have the subtask called. It may have a set of arguments. The arguments will have their names and the order in which the arguments have to be given. So, for example, power of base comma n, if you pass 3 comma 5, it will do 3 power 5. Instead, if you say power of 5 comma 3, it will actually raise 5 to 3. You will get 125 as the result. So, you have to be careful in figuring out what the arguments are and in what order the arguments are passed. And you have various declarations that are within the functions. For example, we needed int i and int p, which were useful in running the loop and so on. And finally, we had a return expression written p earlier and there is a return type in our power function. It was an integer. So, one thing that you have to remember is in the body of a function, it is a basic block of code and in the body of the function, you cannot have other function declarations. So, it is simply not allowed to have other functions, which are completely declared and described within another function. And the arguments essentially form the inputs, you need both the types and the order. Sometimes the return expression is optional. So, the keyword return can take an expression. It can also not take any expression and just say return or if you do not even have return, your program will come to the final closing brace of subtask and automatically it will go back to the caller. So, invoking a function is usually done using this function name and you have the set of all the parameters that are passed. There is this notion of what is called a prototype of a function. So, we will see this in a little while. So, I had that in the program, but I did not go into the details earlier. But we will see what a prototype is. The prototype essentially defines the number of parameters and the type of each parameter. It also defines the return value of a function. So, a prototype essentially gives you a black box description. So, when every function has a prototype followed by the actual definition of the function. So, the prototype just tells you what is the black box description, what are the inputs and what are the outputs and so on. And somewhere you have to write the program to do the function itself and that is the function implementation. So, the prototype is a necessary thing. The compiler is usually check whether a prototype is present or not. And if you give a prototype, a compiler can actually indicate warnings if you have if you have messed up something. Let us say you have written a function and it takes three parameters and let us say everywhere you called it, you have only two parameters that are passed. A compiler can spot it and tell you that this function expects three parameters and you have passed only two. So, the prototype here is for power is as follows, int power of int comma int. So, in this place we have actually not named the parameters at all. Power does take two parameters, but the names are not mentioned. So, a compiler when it looks at this prototype knows that power is supposed to be a function which takes two integers returns another integer. At this point, the compiler would not know whether base is the first parameter and n is the second parameter or n is the first parameter and base is the second parameter. Actually it does not care at this point of time. However, later we actually put the variables base and n here and write a program appropriately. Typically function programs are function prototypes are given in the beginning of the program. So, let us see this. I am showing the same piece of code that we had earlier. We have this power function. So, what you see on the right side is called the function definition or function description and what you see in this line here on the left side is called the function prototype. So, we have function prototype and function definition. So, the function prototype by itself is not very interesting, but it is necessary to tell the compiler as well as tell the other programmers that power actually expects two variables and it will return only an integer. It is not going to return a character. It is not going to return a floating point value and so on. So, so that anyone who uses the function knows what they are getting into. So, this is called the function prototype and this is called the function invocation. So, whenever we call the function, we call that function invocation or calling the function. So, earlier I said I want to touch upon what is called the control flow. I said flows the program flows starts with the main program and whenever it calls a function it goes there and so on. So, I want to make that slightly more clear now. So, let us look at this piece of program and let us see how this function how this program is going to get executed. So, as I said earlier all executions start with main right you start with main. So, at this point you have two declarations number one and number two. So, as with any variables the compiler would have allocated memory for number one and number two. So, I am ready to execute this line number one is power of 3 comma 5. At that point what happens is instead of getting to the next line here which is what happens usually right. So, when we looked at programs so far for loops and other things we always recent how this sequence of code that you see on the screen how will get how will it get executed internally. So, if you have no loops or branches you start from line one you go to line two line three line four up to line nine and you return. If you have iftinal branches either if condition is true or else condition is true and only one of them works if you have a for loop you have a repeated body and so on right. All those were examples of control flow this is one another example of control flow. So, at this point if you are in line number two within main the control gets transferred to line number one of power and then you go and actually do this sequence of operations and once this sequence of operations is done you return back to this line when you return back what happens is you have computed the value power of 3 comma 5 it should have computed number 243 as the result and that is assigned to number one. Now, you are again back in the caller in the caller you will by default go to the next line right. So, the next line is also a function invocation or a function call again the control is transferred to the call e the call e it goes through the sequence of code here at the end of it you return back to the caller in this case minus 4 comma 3 would have computed minus 64 that value is assigned to number two. So, it returns to this location and then you are ready to do printing off both these numbers. So, the control flow for this program is you start with main at this line you call this site. So, remember for every assignment operation you evaluate the right side and you assign it to the left side right. So, there is evaluation on the right side. So, power of 3 comma 5 would transfer the control to the power function and you do the sequence of steps the control comes back here you do this assignment the control falls to the next line by default again the next line on the right side it it makes a function call you do this you come back here do the assignment and you have a printf followed by another printf and so on. In fact, technically printf is another function. So, when you come here printf is a function which takes two parameters a format and a value here these two are the parameters that are passed to printf in fact, what is hidden is what is happening inside printf. So, the control actually gets transferred to printf printf does whatever it has to do to print things on the screen it comes back to this line and the next line it moves to the caller next line again it is a call to printf you go to the internals of printf whatever it does to print on the screen it does it comes back here and then it comes here and returns comes to this line with the return and the last line in the caller is in the main function is return 0 it returns 0. So, if you notice main is a function this is the function name that is the return value and this is the return statement and main is a function which has not taken any parameters. So, there are ways in which you can take inputs to main also we will probably cover that in a later class. So, main is a function and so is power and so is printf and scanf and so on. So, I want to show a slightly different example where we use the same power function inside a loop. So, we have int power int int so this says that this is a prototype which takes two integers and returns an integer and what we have done is inside main we have a loop for int i equals 0 i less than 20 i plus plus we are printing i 3 power i and minus 4 power i. So, and we have this function for computing power. So, this is a slightly more complicated control flow. So, we start with here main the first line after that is a for loop the for loop will initialize i equal to 0 it will check if i is less than 20 or not. So, when it is 0 it is actually less than 20 and it comes to this line. So, when you go to printf it actually requires i 3 power i and minus 4 power i only if you know the values you can print them. So, when you see power of 3 comma i it actually makes a function call to 3 power i. It makes a function call to 3 power i it computes the result you get the result back and then you have my power of minus 4 power i this power function computes the result it comes back. So, you have i which comes from the loop 3 power i would have come from the power function minus 4 power i would have come from the power function printf has all the values that it requires it would print things on the screen and then the control comes to this location. At this point it says it is the time to check go to the end of this for loop which is i plus plus. So, you are supposed to do the post loop function which is i plus plus check again whether i is less than 20. So, i would have become 1 it is still less than 20 again it comes to this line which has printf. At this point it makes two function calls get its arguments prints things on the screen comes back to the end of this for statement at that point you do increment of i again and so on. So, this is a slightly more complicated control flow. So, you have loops and you have various function calls here. So, let us take this example where i equals 3 is done. So, let us say for at some point i would have been 3 in the loop let us see how that would have done how that would have happened. So, when i equals 3 the printf would see that there is a call to power so power of 3 comma 5 3 comma i at that point that transfer goes to this segment and since you are returning 3 power i which is in this case 3 power 3 which is 27 the result comes back and that is a temporary place holder. So, 27 comes back you have i which is already present and you have 27. So, you have two parameters ready printf still needs one more parameter for it to print. So, at that point you see that it is power of minus 4 comma i that gets evaluated the result is minus 64 that comes back as a value to the printf. So, at this point you have 3 27 and minus 64 printf has everything that it needs to print. So, printf function will be called at that point you have you will print 3 comma 27. So, 3 space 27 space minus 64 on the screen and then you are ready to go to the next iteration in i.