 Welcome to lecture 4. We have a bunch of modules which are all related to arrays and what are called pointers. So, the first module is about multi-dimensional arrays. So, multi-dimensional arrays they appear many times in the form of tables. So, I am sure you have seen spreadsheets or matrices and so on. These are all very common things in several engineering disciplines and you can think of them as a two-dimensional array. So, you have one dimension which is the set of rows, another dimension which is the set of columns and you can have rows and columns which form a table. This could be a 2D array. You could also have arrays which are more than one more than two dimensions. For instance, if you look at graphics 3D graphics will require x, y, and z. So, you have three dimensions and so on. So, we need a mechanism by which we can not only store, but also be able to access them and manipulate them as variables and so on. So, let us look at what a 2D array would be. So, in this example what we have is we have an array called a which says int a of 4, 2. So, that is the declaration. So, just like what we have for basic variables int a of 4, 2 tells you that you want 8 integers arranged as 4 rows and 2 columns. And as with 1D array one thing that you lot remember is that you have 4 rows numbered 0, 1, 2 and 3 and 2 columns numbered 0 and 1. So, the rows get numbered from 0 and the columns get numbered from 0 as well. This is something that you have to remember this has to be drilled into you. And the storage in the memory is actually what is called a row major order. So, what I mean by that is as follows. So, even though you have two dimensions as a pictorial representation here, remember memory is just a sequence of memory locations right it is actually one dimensional. And the way things are going to be stored as follows. You take the first row that is the 0th row and you take the first column that is the 0th column. The entry a of 0, 0 goes into one location then a of 0 comma 1 which is the next column in the same row gets into the next location. And then you can think of this as folding down and you have the first row and the 0th column that goes into the next location and so on. So, you can see that the order in which things are listed are you have started with 0, 0 then you have 0, 1 and then you have 1, 0 and 1, 1 and so on up till 3, 1. So, you have 8 memory locations of the type integer and they are all contiguous. So, this is called row major order. You can initialize 2D arrays as you did for 1D arrays also. So, for example, here we have a 2D array called b which has 2 rows and 3 columns. So, this set of set braces tell you that you want an array. And within and within this you have two such curly braces, two sets of curly braces and list of values there. So, the 0th row will contain 45 and 6 and the 1th row will contain 0, 3 and 5. So, we have two different things and the entries are again going to be laid out in row major order. You can go and design or use arrays which are more than 2 dimensions. So, for example, here we have flow b of 243. So, you can now think of this as 2 planes, each plane having 4 rows and 3 columns. So, you have the 0th plane and the 1th plane. So, I will call it 1th just so that I can say ith later. This is the 0th plane and 1th plane and within that I have 0th row, 1th row, 2th row and 3th row. And similarly, I have 0th column, 1th column and so on. So, essentially you can access ith row of this plane by accessing b of 0, i. And if I want to access ith row and jth column of this plane, I can say b of 0, i, j. If I want to access something in here, I have to use b of 1, i, j and so on. And see you can actually have dimensions more than 3 also, but for most practical purposes, you will need 1d 2d and 3d arrays. So, let us look at the most common use of 2d arrays. These are usually for matrices. Let us look at a matrix called m, let it have m rows and n columns. So, the rows are going to be numbered from 0 to m minus 1 and columns are going to be numbered from 0 to n minus 1. So, you have m rows and n columns. And if you want to access the ith row and jth column, element in the ith row and jth column, you access it as m of i, j. So, m of i, j is ith row and jth column. Just as you have for arrays, i should be less than m and it starts from 0, j should be less than n and it starts from 0 as well. So, this is just an extension of what you did for 1d arrays. So, let us write a small program in which we are going to fill up values and print a 2d array just to show you how access to an array works. So, I have this small program written up. So, let us look at this program here. So, I have m which is defined to be 3 and n which is defined to be 4 and what I have is I have int a of m comma n. So, this is going to allocate an array of 3 rows by 4 columns. So, total of 12 elements and you can access an individual element using a of i comma j. So, we have this loop running from 9 to 13 which is going to fill up the array and the loop running from line number 14 to 20 which is going to print the array. So, in this case these are a is the 2 dimensional array is being filled up in this form. So, a of i comma j is going to have the value i plus j. So, a of 0 0 will have 0 0 1 will have 1 0 2 will have 2 and so on. So, the first the 0th row will have 0 1 2 3 as its elements. Row number 1 will have 1 2 3 4 as its elements and so on and we want to be able to print it. So, that is there in this loop. You can see that it is a nested for loop that is used here. So, this loop starting at line number 9 ending at 13 is the outer loop and this loop is hydrating over the rows and this is the inner loop and that is hydrating over the columns. And this you are accessing a of i comma j. So, you are accessing each element in a row and you go to the next row and so on and you have the same order in which you are printing this. So, let us save this and compile and run it. So, I am going to run that and as I mentioned earlier, there is row 0 which has 0 1 2 3 row 1 which has 1 2 3 4 row 2 which has 2 3 4 5 and so on. So, the basic idea is that you can access these arrays as though you are accessing the 1D array except that you have 1 dimension which is called the major dimension and 1 which is called the minor dimension. So, the rows are the major dimensions and columns are the minor dimension. If you have a 3D array, the plane would be the major dimension, row will be the intermediate dimension and columns will be the minor dimension. So, what can we do with these 2D matrices? Let us see what we can do with it. So, I am going to talk about how to write a small program to do matrix multiplication. So, I am going to assume that there is an array, there is a 2D array or a matrix called A. So, we have a 2 we have a matrix called A and we have another matrix called B. Let us assume that A has A rows number of rows and A calls number of columns and let us assume that B has B rows number of rows and B calls number of columns. So, if you are going to multiply A with B, we are doing A times B, the number of columns of A and the number of rows of B should match otherwise the matrix product would be incompatible and however we are going to do this computation. So, you can see that the number of rows of C are the same as the number of rows of A and the number of columns of C is the same as the number of columns of B. So, that is the first thing that you have to do, you have to see. You can see that this size is the same as this size and this size is the same as this size. So, given that how do we now find out the actual entries of the final matrix C. So, the way you do that is follows. So, you take one element from A and you take a corresponding element from B and you multiply that. So, I took one element from A, I took a corresponding element from B. So, let us say that I pick the I throw from A and I pick the jth column from B. So, I throw will have A calls number of elements and jth column will also have B rows equal to A columns number of elements. So, this and this dimension should match. So, the number of entries in the rows here and the number of entries in this column here should be the same. So, what I am going to do is I am going to take one pair at a time like this, multiply these two elements and put it in the location here. Then I am going to multiply these two elements. So, in the column one here and row one here and this has to be added to the location at C and so on. So, I can proceed taking one pair of elements at a time, one element from A and another element from B and I have to keep adding it to the elements in C of i comma j. So, essentially the bottom line is if you take the I throw of A and the jth column of B, you get the I jth entry of C and you do this by hydrating over all the elements I throw of A and jth column of B simultaneously, you have to do this together and take one pair at a time and multiply add it to C of i comma j. So, this is the basic logic. So, let us see how to write a program for this. So, as before we have three matrices, let us assume that these three matrices can accommodate up to 10 cross 10 elements. So, each of these matrices can take up to 100 elements. However, I am going to use not all the 100 elements, I may not want all the 100 elements to be filled up. I allow for a row and a set of rows and columns that is lesser than 10. I am going to take it from the user. So, the user is going to give A rows and A calls, which is the number of rows of A and number of columns of A. So, clearly A rows and A columns should both be less than 10, less than or equal to 10. And what I am going to do is, I am going to iterate over the number of rows for in A and the number of columns in A and fill up A of i comma j. Similarly, I iterate over the number of rows of, so I scan the number of rows from the user and columns from the user. I iterate over the set of values and end up with B filled up. And once I have A and B filled up, I am ready to do matrix multiplication. So, the key thing is the number of rows in C is the same as the number of rows in A and the number of columns in C is the same as number of columns in B. So, let us see how this program would run. So, you would need these two loops, the i-th loop and the j-th loop. So, the outermost loop and the intermediate loop will iterate over all the elements C of ij. So, this is evident from looking at this. So, if I want i comma j-th entry, I will take this row vector here and this column vector here. I will do a dot product essentially and I will put it here. Then I have to go and fill up this, then I have to go and fill up this and so on. So, I will start from this location and I am going to start filling up elements in this order. So, this is the order in which we are going to fill up elements. So, these two loops take care of that i equal to 0 to less than 0, j equal to 0, j less than C columns will iterate over all the entries of C of ij. So, the first thing we do is initialize C of ij to 0 and once you have that, then we are now ready to do the actual dot product. The actual dot product is done here. I am going to look at i comma kth entry of A and k comma jth entry of B and I multiply that added to the current value of C of ij. So, that is what the plus equal to does. You take i comma kth value of A, k comma jth value of B, multiply it and add it to the current value of C and when you do that, you see that C of i comma j will is actually accumulating the value. You initialize to 0 and it is accumulating the value. At the end of this, C of ij will get the final dot product of those two vectors and you are iterating over all the values of i comma j that are permissible for C. So, at the end of it, you have all the entries in C filled up. So, this is a basic program in to do matrix multiplication and this loop is printing the entries. So, this is a fairly simple program. So, the key thing for 2D arrays is that you have to remember it is always rows followed by columns or planes followed by rows followed by columns and you use square bracket to access the row or column and all the numbering for the planes for the rows and columns start with 0. So, all the basic rules related to 1D array also applies here. So, if you have A of, if your array A is of size m cross n, the largest entry you can access is A of m minus 1 n minus 1.