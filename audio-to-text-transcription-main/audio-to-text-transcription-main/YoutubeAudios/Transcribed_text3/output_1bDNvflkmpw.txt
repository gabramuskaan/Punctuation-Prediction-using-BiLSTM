 In this module, we will see a little bit more of details on pointers itself. So, let us go back to the code that we saw earlier. So, we have int k equals 38 in star p and p is ampersand of k star p equals 5. So, one thing that I did not emphasize earlier is this notion of asterisk, what is it used for? So, it is you can see that it is used in two places in one place as int star p and the other place we have star p equals 5. So, there are related to pointers this asterisk symbol is used in two connotations. First time when you declare a pointer you say in star p at that point you are saying that p is a variable of type pointer to integer and later when you say star p equals to 5 the meaning is slightly different. What you are doing is you are doing what is called dereferencing the pointer. So, at this point this is not telling the compiler to allocate space for the variable p or anything like that. Here, actually you are dealing with the r value of p. So, one small thing that you will see in the the course as well as elsewhere is that we usually say p is pointing to k. So, in this case p is ampersand of k. So, instead of using this technical term that p equals ampersand of k p usually say that p points to k or p is pointing to k and so on. So, let us look at the dereferencing operator. So, it is the asterisk symbol and when you say star p equals to 7 it takes the value 7 and copies it to the address pointed to by p. So, the so we saw this if p points to k then the above statement will actually change the contents of k also to 7 and this dereferencing is something that you will see as a technical term that is used later in the lecture also. There is a special pointer called the null pointer and generally we use pointers to point to some specific variable. So, if I have in star p then I do I did p equals ampersand k in that in that case p started pointing to k. But there are several cases where you explicitly want the pointer not to point at anything at all and C provides you a special way of doing that and that is called the null pointer. So, one key thing about the null pointer is that no other valid pointer. So, by that I mean no other pointer that is actually storing some value or which is going to get point which is an address of a variable and so on will ever compare equal to the null pointer. So, let us see what it means. So, first of all C gives something called a predefined constant called null and this is defined in a cdi o dot h. So, just like print affants can have this constant null is also defined in a cdi o dot h. So, generally it is a good practice to check whether a pointer is null or not before you use it and we will see this in lot more detail when we do what is called dynamic memory allocation. But let us look at this code for right now. So, what we have is we have hash include cdi o dot h and we have in star ip equals null. So, this is generally considered a very good programming practice. You not only said you want a pointer variable of type integer pointer the variable name is ip and the pointer is of an integer type. You also said here that it is pointing it is not pointing to any valid location. So, if you do this then we never run into this problem of ip pointing at an unknown location and what happens in this unknown location and so on. So, the moment you have null it means that it is a it is not valid location and you want to you will probably come back and change it later. So, you may do ip equals address of something later and this is what I was talking about earlier. So, this tip says if ip is not equal to null printf star ip or if ip printf star ip and so on. So, what this does is it actually checks whether ip is null or not. If I know that it was initialize to null and at this point if ip is not equal to null then there was a valid assignment to ip that happened here. If there is no valid assignment ip will still remain at null and you will not print the value. So, this is a check that is done usually in practice again we will see how this is useful when we do what is called dynamic memory allocation. So, we have not done that yet but when we do malloc we will use this template later. So, another subtle thing with the C is that it provides pointer of type void. So, void is so you declare it by saying void star vptr and this void pointer is actually a generic pointer what I mean by that is it can be made to point at anything. So, so far we saw integer star pointer. So, you could also have float star ptr 1 and so on but this void star vptr is a generic pointer you can make it point to a integer you can make it point to a floating point you can make it point to a character or you can actually make it point to a pointer itself and so on. So, this is another thing that comes very handy and this is just for you to notice now we will see this in detail later. So, let us let us look at a small code segment using pointers. So, here we have two integer variables m and k and we have a variable ptr which is actually of the type integer pointer. So, one thing you can notice is that in this single line right we have done a few things we have initialized declare and initialized two variables m and k we have also declared a pointer variable of integer pointer type. So, you can combine declarations in one line and this is the way to declare both integer variables and pointers to integers in the same line. So, in this case ptr is made to point at k so ptr equals 1 percent k is made to point so you are making ptr to point at k. So, let us look at these four lines of code. So, it is so the first line says m has the value percentage d and stored at percentage p and we give two parameters as inputs to print f. So, the first thing you notice is this percentage p is a format specifier for pointers. So, just like we have percentage d for integers, percentage f for floating point and so on for pointers it is recommended that you use percentage p and so let us see what happens in this line. You have percentage d as a specifier that will attach it to m. So, here you want m printed as percentage d format which means print m as an integer and the second argument is void star ampersand of m. So, this is the case of what is called type casting. So, ampersand of m is of pointer type and it is an integer pointer type you type cast that into what is called void star. So, you can take a pointer which is of integer type and make it a generic pointer. So, if you look at the data type of void star ampersand m it is actually a void pointer now it is not integer pointer anymore and you are printing that using format specifier for called percentage p. So, in the second line k has the value percentage d and stored at location whatever is the address of k. So, I already showed something very similar. So, ptr itself is a variable which means ptr is given space or it is given some memory in it is given a memory location. So, ptr has the value percentage p and distorted percentage p. So, in this case this one the first argument itself is a pointer and the second argument is taking the address of ptr and casting that to void star and finally, the last line says the value of the integer pointer 2 by ptr is percentage d. So, star ptr as I said is dereferencing ptr. So, see here we are not declaring ptr. So, that has already happened in this line here we are doing dereferencing of ptr. So, this is what I was pointing to earlier. So, there are two ways in which you can use the star associated with the pointer one is for declaration the other one we are seeing here it is useful for dereferencing. So, it is getting the r value of k and it will print the value of k. So, the key thing to notice in this slide is there is percentage p specifier for pointers and we did what is called type casting. So, we took integer pointer ampersand m and we converted that to void pointer using this bracket void star. So, I suggest that you actually take this piece of program and try it out to understand what is happening there. So, one key use of pointers is that it is something that is used for manipulating arrays. So, in C there is a very very strong relationship between pointers and arrays and without pointers you cannot do a few things in C when you actually want to use arrays. So, we will see this again in more detail when we look at functions. So, but so, take it for now that there is a strong relationship between pointers and arrays and anything that you do using array subscripts can actually be done using pointers. So, pointers in that sense is more powerful and more generic way of dealing with either continuous set of locations or something that is not continuous. So, let us see this small example we have int a of 12 as I said earlier right int a of 12 will declare space for a and let us say that is the top set of boxes that you are seeing and we know that a of 0 is the very first location a of 1 is the second location and so on and a of 11 would be the last location. So, indices go from 0 to 11 12 is not a valid index for a. So, if I have int star ptr this will give me a memory location called ptr and if I do either of these two right if I say ptr equals ampersand of a of 0 or ptr of a then ptr starts pointing to so, let us see what really happens here. So, let us look at this statement first. So, if I look at the statement ptr is ampersand of a of 0 right. So, let us see what this does. So, a of 0 is a value right it is not a pointer a of 0 is actually a value. So, we have seen this in array so far right but the moment you put ampersand in front of it it means do not get the value that is stored in a of 0 instead give me the pointer to the 0th element. So, the left side is asking for a pointer and the right side actually gives a pointer. So, this is valid. So, what this is really doing is ptr begins to point at the 0th element of a. You can also achieve the same thing by a sliders shortcut which says ptr equals a. So, this is also something that you will see good programmers doing. So, experience programmers do not use this format instead they use ptr equals a. So, what this is doing is ptr is now going to contain the address of the 0th element of a. So, in some sense the name of the array a is actually only a synonym to the 0th element to the address of the 0th element. So, when we say a right a is an integer array of size 12 but the variable a is actually just a synonym for the address of the 0th element of this array. Let us see what all this means. So, if I do in star ptr equals a. So, in this place in this piece of code we are declaring a pointer integer pointer called ptr. So, this says we are declaring an integer pointer and the variable name is ptr and right when we are declaring we are also initializing it to a. So, if a is this array that we have here then ptr starts pointing at the 0th location. So, this is something that comes from the using a as a synonym for the address but the nice thing you can do with ptr is that you can do something like this. ptr is ptr plus 1. So, let us see what this means. On the right side we actually have a pointer variable and we are adding one to it. So, what that means is instead of making ptr point at a of 0 now you actually point it to the next element after the current one. So, at this point ptr was pointing at a of 0 right. So, you can see that here but the moment you do ptr is ptr plus 1 it starts pointing to the next element. So, clearly you can see that if you do ptr is if you do another ptr equals ptr plus 1 it will start pointing to the 2th location and so on. So, it starts with 0th. So, like I said I abuse this abuse English language I say 0th 1th and 2th and so on. So, right now it is pointing at 0th location and if you do ptr is ptr plus 1 it will start pointing at 1th location and if you do one more ptr equals ptr plus 1 it will start pointing at 2th location and so on. So, we can use like arithmetic like you would do on integers and so on but there are certain rules. We will see this in a little more detail in a little while. So, one thing I would want you to think about is what does star ptr equals star ptr plus 1 do. So, clearly there is a difference between saying ptr equals ptr plus 1 versus star ptr equals star ptr plus 1. So, take some time and think about it. So, it will be useful to think about what this statement ptr equals ptr plus 1 does versus star ptr equals star ptr plus 1 does. Take a while to think about it. So, let us go back to arrays. So, in some sense arrays I said are less flexible than pointers. So, arrays are what are actually called constant pointers. So, let us look at p's of code on the left side. We have int a of 10 and we have int star p a. So, p a is an integer pointer and when we say p a equals a now p a starts pointing at the 0th location of a and if you do p a plus plus we are incrementing p a what this does is it makes p a point at a of 1 instead. So, this is actually okay to do because pointers are variables and here you did one assignment to p a and you change the assignment to p a here which is perfectly fine for p a because p a is a variable. Let us do something which is slightly different here. We have in on the right side in the red box we have int a of 10 we have in star p a and we say a equals p a right. So, the first thing is that a equals p a is not permitted at all. So, this is not permitted. The reason is that when you do a equals p a a is supposed to point at some 10 locations and you are now asking a to point at some other location as indicated by p a. So, this is not allowed nor is a plus plus allowed. So, even though a is a synonym for the 0th location it is not valid to take the variable name that is used for the array and do any kind of arithmetic on it. You cannot do a plus plus you cannot do a equals p a or anything of that sort. So, to summarize a cannot appear in the left side of any expression. So, a plus plus is actually just a equals a plus 1 right. So, a cannot appear in the left side of any manipulation at all of any expression at all whereas, p a being a variable can appear freely on the left side. So, the a the variable the variable a is actually an array and it is called a constant pointer. So, what I mean by constant pointer is that a of 10 is actually a set of 10 locations. So, we have 10 locations and a is actually pointing to a of 0 technically and it cannot point at anything other than a of 0 that is what it means by that is what I mean by constant pointer a can point at a of 0 and nothing else the moment you say in a of 10.