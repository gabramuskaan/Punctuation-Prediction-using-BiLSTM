 Let us see what I meant by pointers being a replacement for arrays. So, let us look at the small piece of code here. So, we have int my array equals this. So, let us think about what it really is doing. So, int my array there is a left and right square bracket equals a list of values. So, what this does is it takes the set of values on the right side. So, we have 123, 17, 4, minus 500. There are six values. So, int my array is actually an array, which can take six values. So, size of my array is six values. Then we have star ptr and i. So, instead of explicitly saying my array should be an array of size six, we let the compiler figure out how many values are there on the right side based on that appropriately take the size of my array. So, in this case the size of my array is six. So, following that we have star ptr and i. So, what we have in this line is we have two integers. So, sorry, one integer called i, one integer array called my array and one integer pointer called ptr. So, that is what you have in line one. And in the next line we have ptr equals ampersand of my array of zero. So, ptr is now pointing at the zeroth location of my array. You can also replace this with ptr equals my array that is also valid and it does the same thing. So, let us look at this loop here. So, print f my array of percentage d equals percentage d. So, it is saying that print my array of some integer equals some integer i, my array of i. So, I am going to call this line a and in the next line we have contents in address ptr plus percentage d equals percentage d and for the first percentage d we give i and for the second percentage d we give star of ptr plus i as the variable to be printed. So, let us see what this means. So, in the first line it is straightforward you are printing the index of the array as well as the value contained in the index for i equals zero through five. So, my array has six values and it goes from zero to five and this next line contents in address ptr plus. So, if you see the loop it will take i will take zero one two three and so on. You will see contents of ptr plus zero contents of ptr plus one contents of ptr plus two and so on all the way up to ptr plus five. So, that is what you are seeing on this and star of ptr plus i means take ptr plus i which means move it by appropriate number of locations from the base and dereference it using the star operator. And I am going to call this line B. So, I will tell you quickly why I want the lines to be named A and B, but let us take this program and run it. So, I have already taken this program and copied it into my editor and let me compile it and run it. So, let us see what is happening in the output. So, take some let us take some time to see what is printed in the output. So, the first line is my array of zero equals one contents in address ptr plus zero equals one that is what it says. So, let us see my array in the program. So, my array is one twenty three seventeen four minus five and hundred. So, my array of zero is indeed one and ptr plus zero which means the contents of ptr plus zero is star of ptr plus zero. So, ptr plus zero is ptr itself and star of ptr is pointing to one. So, it is printing one. Then my array of one is twenty three and ptr plus one is supposed to point at the location one step away from ptr. So, remember ptr is only pointing at my array of zero. So, one element away from that is A of one. So, ptr plus one is the address of A of one and when you do star of ptr plus one you are asking for the value contained in one location of A which means you are asking for the value of A of one. And this goes on. So, ptr plus five is asking for the value. So, star of ptr plus five will get the value which is at A of five and it happens to be hundred and that is what you see here. So, let us do a small change to the program and I want to show that my array is something that cannot change. So, let us say I do this my array plus plus. So, what I want my array to do is point two twenty three. So, I want my array of zero to be twenty three my array of one to be seventeen and so on. Therefore, I am trying to increment my array by one. So, I do not it will not point to one anymore it will it is supposed to be pointing at twenty three. So, let us try and compile this. Let us try and compile that and let us look at this error that happens. So, in fact, the compiler stops and points at points error at line number thirteen. It says L value is required as increment operand. So, it is not a very useful error to see but many compilers for see actually give you errors that are slightly cryptic. In this case, what it is saying is so let us change this a little bit. Like I said this is equivalent to saying my array is my array plus one. So, let us compile this you still see the same error. So, on the right side so it says error incompatible types when assigning to type int of six from type int star. So, on the right side it is doing my array plus one which means you are asking for one location away from my array and in the left side you are assigning it to my array even this is a comp it gives a compilation so based on what you write right. So, it is changing the error but the basic point is it is not letting you change what my array should be pointing to. Whereas, if I had done this let us say I did PTR right equals my array if I did that. So, let us look at line number 13. So, if I compile it it is technically not a problem because so PTR so even in this line even this line PTR equals my array of 0 is actually equivalent to this line PTR equals my array. So, I said these are lines A and B let us see why this is useful. So, I want to use it for to illustrate something now. So, both plus plus PTR and PTR plus plus are actually equivalent to saying PTR plus 1 right you you are incrementing PTR by 1 though at different times. So, there is a difference between saying plus plus PTR and PTR plus plus plus plus PTR is called the pre increment operator. So, it means increment the value of PTR and then use it and PTR plus plus is post increment operator use the current value of PTR and then later increment the value of PTR. But I wanted to do this little exercise. So, change the line B. So, if you look at line B it is saying contents in address PTR plus percentage D is i comma star of PTR plus i. So, change that to star PTR plus plus and run it again and once more change that line to star plus plus PTR and run it once more. So, you take this piece of program which is in this slide but make changes to line B using either this line or this line compile and run it and try and reason why whatever is happening why it is happening. So, try and reason about that so let us move forward. There is another useful thing in C which is called the size of operator. So, it is not directly relevant to pointers but this is something that I want to talk about now and I can use the size of operator to explain a few things later. So, in this program we have three integers called in size CHR size and float size FLT size and we are going to do this. In size is size of N, CHR size is size of car and FLT size is size of float. So, as the name might indicate to you you are looking at the size of an integer or size of a character and size of a floating point and so on. What does it mean by asking for size of an integer? So, integer is so it is a set of values right integer is actually a set of values and this can be so if you look go and look at the real world the set of integers is unbounded in size. So, you have all the way from minus infinity to plus infinity. It is not something that a C language supports though. So, you cannot store every possible integer that is out there. C instead restricts it to be at least four bytes in size. So, if you say size of int it is actually giving you the number of bytes that is used to represent an integer. Similarly, size of character is will give you the number of bytes required to store a character and size of float is going to give you number of bytes to give you to for storing a floating point number and so on. So, these things can vary across different machines and so on. But the basic point is whenever you do size of int for the machine that you are running on it will tell you how many bytes are required to store an integer. So, in most modern machines the size of integer is either four bytes or it can be even eight bytes. So, let us look at a few things related to pointer arithmetic. So, I am going back to pointer arithmetic. You can do a lot of things with pointers and arithmetic related to pointers. So, you can assign between pointers of the same type. You can do addition and subtraction between a pointer and an integer. We already saw this example we did ptr plus 1 and ptr plus plus and so on. So, ptr was of type pointer and plus 1 is actually adding an integer 1 to ptr. So, however see allows you to do that. You can compare two pointers that point to elements of the same array. You can even subtract two pointers. We will see a small example at the end of this module and you can assign and compare. So, these are several things that you can do with pointers. Let us see each one one after the other. The first one is increment decrement. So, if p is a pointer to type t. So, in this so there is actually no data type called t in c. So, I am using this as a template. Let us say I have a data type called t and p is a pointer to t. So, t could be an integer character floating point could be anything. p plus plus will increase the value of p by size of t steps. So, I already mentioned this. If you say size of data type it tells you what is the number of bytes required to store the data type. So, when you do p plus plus it is not incrementing p to point to the next byte. It is going to make it make p point to the next valid element of the data type t. So, let us say my integer is actually four bytes. So, I have an integer called a and let us say it is occupying four bytes. This is not an array of size 5. So, I am drawing a memory footprint and let us say variable a is stored in four bytes. Let us say location 100 101 102 100 103 and let us say location 104 5 6 and 7 are the next set of locations. If p tr is made to point a and if you do p tr plus plus p tr will not point 101 because the data type p tr is pointing to is integer. The next valid integer is four steps away from 100. So, p tr plus plus will make it point to the integer at location 104. So, let us look go back to the slide. So, we have if we have data type t tab of n and if you have a declaration t star p. So, you can substitute t with int, care, float whatever you want. So, t itself is not a valid data type and let us say int i equals 4. If I do p equals ampersand of tab of i. So, i is 4. So, ampersand of tab of 4 will make me point to the fourth entry in tab. So, remember the entry started 0. So, we are talking about 0, 1, 2, 3 and 4. So, the ith entry is the fourth entry starting from 0. So, p is going to point at the fourth entry in tab and when you do p plus plus it actually starts pointing at the next entry in tab. So, this is an example of pointer arithmetic where you mix pointer and integer operations on it. You can also do add and subtract from pointers. You do not have to do just increment and decrement. You can also add. So, in this example what we have done is we have made p point at the zeroth location of tab and we are adding phi to it which means it will start pointing to tab of phi. It will start pointing to tab of phi. You can compare pointers if p and q are pointers of the same, if they are pointing to members of the same array then you can do things like equal to equal to not equal to less than and so on. So, let us say I have an integer array and so, in this case I am drawing an array not memory I am drawing an array. Let us say I have an array A and let us say this is A of 0 and this is A of 4. If I make p point at this location and if I make q point at this location then I can actually ask a question is p less than q. So, the meaning of that is is p pointing to a location that is earlier in the array than what q is pointing to. In this case p is less than q is actually true. So, you can also do is p not equal to q. So, in this case p is actually not equal to q. p is pointing to the zeroth location q is pointing to A of 4. So, p is actually not equal to q. So, you can meaningfully compare pointers which are pointing to the same array. You can ask is this the same is this earlier than the other pointer is it later than the other pointer and so on. So, you can make pointers point at different locations in an array. You can ask questions whether one pointer is lesser than the other and so on. And you can also compare it for inequality is 0. So, you can ask a question is p equal to null. So, let us say p is pointing to A of 0 and I can ask a question if p equal to equal to null. If I ask this question this will actually evaluate to false because p is actually pointing to A of 0. So, you can do comparisons of this kind. So, we looked at increment decrement and adding an integer or subtracting an integer from a pointer. One final beautiful thing about pointers is that you can also do subtraction of pointers. So, there is a small piece of code here which actually tries to show that. So, it is this one is slightly loaded but let us see what it is doing. So, there are two pointers here one called s and one called p and this is actually a function which is called string length strln. So, given a string it tries to find out what is the length of the string. So, let us see what a string is in c. I will anyway do this in more detail later but a string in c is actually just a sequence of characters followed by a special character called backslash 0. So, for instance let us say I have a string called hello it will be stored in this form. You have hech elol so this is letter o and on top of that in c there is a special character called backslash 0. So, in this case it is actually 0 or what is called the null character. So, a string called hello it is supposed to be of length 5 but in reality it actually takes 6 bytes. So, let us say I want to find out what is the length of this string. So, I can keep checking starting from the zeroth location of this string. I can keep checking for one character after the other and I will look for the special character called backslash 0. The moment I see a backslash 0 it means that this is the end of the string and this is a convention used in c. So, like I said a wheel again see this in more detail later but as of now let us look at this example. So, let us say I want to find out what the length of the string is. So, I have written a small function which does that. So, character star s and character star p. So, at this point p is initialized to s. So, s is supposed to be a character array. So, s is a pointer to a character array that is what you see here. So, s is pointing to a character array and character star p equals s. So, p also points at the zeroth location of s. So, s is the string for which we want to find out the length. So, there is a while loop here that keeps checking if the contents of the memory location pointed by p is it backslash 0 or not. So, there is a special character backslash 0. I am going to start from location h. So, where h is stored all the way till I see a backslash 0. So, initially p is pointing at h and star p is not equal to backslash 0. We do a p plus plus. So, p will start pointing here. So, p is already moved by location, moved by one location. It has started pointing at s of 1. s of 1 is e and it is not backslash 0. So, the while loop will continue will start pointing at l and this will keep happening and it will stop when p points at backslash 0. So, let us assume that this is at location 100, this is at 101 and so on. This will be at location 105. So, when the while loop stops, the while loop will stop when star p is equal to 0. When this star p equal to 0, when p is 105 star p is backslash 0 and which means when p equals 105 the loop will stop. So, at that point if you go and ask for p minus s. So, p is 105 and s is memory location 100, 105 minus 100 is 5 that actually gives us the correct length of hello. So, this is a very neat and beautiful trick to show with the pointer arithmetic. So, let us not worry about what this return statement is and what is this strange looking in test here L E and so on is later. But as of now, I just wanted to pay attention to the while loop. So, it iterated over the elements of s and it stopped at backslash 0 at that point p got value 105 and if you do p minus s that actually gives you 105 minus 100 which is so, when you do arithmetic over pointers if you do subtraction of pointers you actually get an integer back and this is something that is very handy. We will see cases for use cases for this in a lot more detail later. So, we have now come to the end of this module. In the subsequent modules, we will see how to use pointers for manipulating arrays and we will also see how pointers are useful in the context of what are called functions. So, we will start looking at functions and when we visit functions we will revisit how pointers are handled when we pass them on to functions. Thank you very much.