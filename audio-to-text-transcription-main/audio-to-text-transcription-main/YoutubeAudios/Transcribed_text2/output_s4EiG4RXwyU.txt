 In the last lecture, we were introduced to the precedence among the operators and we had seen that parenthesis has got the highest precedence followed by unary minus then multiplication division and modulus have got the same priority, addition and subtraction are having the next priority and for operators of the same priority in an expression, there are more than one operators which are of the same priority then evaluation is done from left to right. Only one thing we did not mention and that is if we want to change the precedence of the evaluation then we can always do it using parenthesis, okay, using parenthesis because we know parenthesis is the highest priority one and its overriding scenario, all right. So, let us look at some examples for this which will make the idea clear. Here are some example arithmetic expressions, here you can see A plus B times C minus D divided by E. Now according to my precedence rule, this is equivalent to A plus as if I had done it by hand computation, if I had done by hand computation, how would I have done? There is a chance of confusion, somebody could have done A plus B and the whole thing multiplied by C, etc. To you know even in school level in order to avoid such confusions we use parenthesis and this is equivalent to this scenario that A, this B and C are parenthesis and D divided by E are parenthesis. So, first this will be done, then this will be done, why B into B times C first because it is left and this is right, right. So, first this then this then addition and some, so let us see how will it break it down again, we will have first B times C will be done followed by D times E, then we have got suppose this result is x and this result is y. Then my expression is A plus x minus y. Now out of these again these two, they are of the same precedence. So, first this will be done, suppose this is z minus y, that is how the computation will go on. Here what is the significance of this, the critical point to note here is this part. Here there is an unary operator, therefore during computation what it means the computer will automatically assume that these parenthesis are there, all right. If you had not wanted that, then you better write it in some other way, put it in some other way so that the confusion is not there. The computer will not allow, the compiler will generate the code in a way that it will be treated as this A times first minus B will be done, then this one is the highest precedence, next highest precedence. So, this will be done, then multiplication between these two will be done, now I am sorry, I am sorry. Here normally say if I had done this, what would have happened? First of all I would be doing minus B and by capital letter I am writing some constant value, say B is right now say 5. So, first after computing this it would be A times minus 5 because B was 5 plus, suppose D was 100 and E was 100 and E was 9. So, what is my modulus 1, right. So, then I will be now at this point I have got D modulus E minus F. Now, at this point which one has got the higher priority this and this, now since I have put a parenthesis here, therefore if I put a parenthesis here then this will be done first. Otherwise, otherwise this would be would have been done first because this multiplication has got the same priority as this and it is all left to right. Now, so similarly here A minus B plus C plus D, now here these are having the same priority left to right. Now, I want it to be done in a particular order. Therefore, I have put the parenthesis in such a way that A minus B should be done first, then A minus B plus C will be done first then D will be added to that. That would have been done anyway why because since these are the same priority that would be done left to right. So, first this would be done then this would have been done then this would have been done, either way. Here also the same I can write it in this way but that is the the precedence is being shown in the form of bracket. But here this is an example where I have used parenthesis to override the precedence. The precedence between this multiplication and this modulus was the but just by putting this parenthesis there I have forced this to be computed first. Similarly here now normally given this this would be done first then this would have been done, then this would have then the additions would have been done. But I have overwritten that by saying that first you do A plus B then you multiply C and D multiply by E that is there anyway and then you do the addition. But this is actually overriding the normal precedence. So, you should you will with a little bit of practice will initially you will make some mistakes but then gradually with practice that will go away and all of you will be able to write it fine. Now, we are coming to a very important concept of this arithmetic expression evaluation. Integer arithmetic what does it mean? It means that when the operands and in arithmetic expression are integers then the expression is called an integer expression and the operation is called the integer arithmetic. Integer arithmetic always yields integer values. It will always yield I am sorry it will always yield integer values. So, it will be clearer when we take some examples. On the other hand real arithmetic is arithmetic operations involving only real of floating point values. For example, here you can see this expression 1.0 divided by 3.0 multiplied by 3.0. Now, all these are operands. Now, here is I would like to introduce a term when I say A plus B then this plus I call it as an operator and these I call as operand on which the operation is being done. Now, in real arithmetic all the operands are floating point numbers. Now, sometimes the floating point values are rounded to the number of significant digits because it may be 7.5976 like that you can go on. It is often rounded to the number of significant digits permissible in a particular machine. We get an approximation of the results. Now, one thing that we have to remember is that the modulus operation is not defined over real operands. So, I am not allowed to do 3.5 modulus 2.1 that is not allowed. The modulus operation is allowed only for integer arithmetic. Now, we can also have mixed mode arithmetic where some of the operands are integers and some are float or real. In that case we call it a mixed mode arithmetic expression. If any of the operand is of real type then only real arithmetic is performed and the result is a real number. This example will make it clear. Now, you see here look at the first one. 25 divided by 10 both the operands this operand and this operand both these operands are integers. Therefore, when I divide them I get an integer quotient or integer result. Whereas, if one of the operands was integer and one was real, if at least if even one is real then the result will be real. So, what is happening here? This is becoming like 25.0 divided by 10.0. So, that will become 2.5. Now, here on the other hand since both are integers the result will be integer. So, let me just put in one twist on this. Suppose now here 25 divided by 10 is actually what? It is the if I divide it is also 2.5 right? 2.5. But since this operator is nothing but an integer division. So, it will find out the quotient and the quotient is an integer. The quotient is 2. If I had done 25, modulus 10, what would my result be? The result would be 5 another integer all right. So, we could understand what is meant by mixed mode, real mode and integer mode of arithmetic. We will see some more things later. Now, there are some problems for value assignment. For example, in assignment operation we actually take the expression value and assign it to a variable or we assign a particular variable to another variable. For example, we could have as we have done say something V is U plus F times T. This is an expression value is going first it will be computed and the value will go to V. So, the value is going there right? On the other hand, I could have done V assigned U. That means, the value of U is going to the this variable. Here also the value is going. Here the value of an expression here just a value of a variable. But the most important point is that the data type of the right hand side should be compatible with that of the left hand side. Now, if for example, I say V assigned U and U is a float and V is an int, then I may have problem. What type of problem can I have? Suppose U is 25.7. I assign this to V. So, V can only take an integer value. So, in most of the cases you will get an error. Why? Because you know that depending on the computers depending on the different architectures, integers are often given two bytes and floats are given four bytes. So, you are trying to pack in a large number I mean a four byte number into a two byte space. The space is not there. So, the errors can come. In some cases maybe they will cut it out and represent it as ignored this part and you will not understand it will just assign 25 to V. That is also an error that is creeping in. Now, this is this error will go unnoticed. If the compiler catches it which is most of the case in that case you will the compilation error will occur and will understand that it is not working. For example, as I said the four byte floating point number is not allowed to be assigned to a two byte integer value. So, sometimes what we do this is a new concept called type casting. Look at this example. Here we have defined x to be integer. So, x has got two bytes. Suppose I have I show two bytes for x and r is a floating point number which has been represented through four bytes. Now, sometimes what we do we type cast this thing two times r will be what two times r will be a float because r is real and so if one of the operators are real then this part will be a real arithmetic. But then that result I am casting back to int. So, this operation is called the type casting operation. That means, whatever I have I have casting that to fit in in a way so that it can fit in as an integer. Here is another example say perimeter has been defined as double. That means, it can have twice the floating point space pi is a float 3.14. Now, here you see this pi we are encountered pi earlier. But here this pi is not the constant which has been defined as defined. But pi is a variable which has been initialized at the time of declaration and r is an integer. Therefore, when I am computing perimeter is twice pi r. So, what what am I actually doing I am trying to compute two pi r the circumference of a certain. So, twice two is real. Now, pi r perimeter is double. So, I want to have perimeter with a larger accuracy. Therefore, I first make r to be double I type cast this integer to a double type. I type cast this float to a double type then I multiply and get the perimeter. So, this is another very powerful operation which we often need for scientific computation. So, type casting of a floating point expression to an integer variable as is shown here and the type casting to double has been shown here. We have already explained that. Now, we have till now looked at arithmetic expressions how to form arithmetic expressions and arithmetic expressions are formed using arithmetic operators. Besides arithmetic operators there is another very important type of operator called the relational operator. A relational operator is used to compare two quantities. Let us see. For example, this symbol very familiar denotes is less than. This symbol which is also familiar shows is greater than. This symbol is less than or equal to this. Sometimes in our normal course we write it in this way, but in a computer we cannot write in this way we have to write it less than equal to. Similarly greater than equal to unlike the greater than equal to that we used to write in this way we have to write here greater than or equal to. Now, this means greater than or equal to that is well known to us. Next here is another operator this requires some discussion is equal to. Now, earlier this is very important to note and this is a way source of a very common error and common mistake. Typically when we say in our normal arithmetic x equals y we meant that the value of x and the value of y are the same. But we have seen that in C language this actually means the variable x is being assigned the value of y. So, how do I compare whether this two variables are equal or not? For that C provides this technique of using two consecutive equality sign to show x whether x is equal to y. We will come to this in a moment. There is another operator that is not equal to. Again let us compare to what we had in school we used to write something like this in C we have to write it with this exclamation mark followed by equality. This means it is not equal to all right. Now, a very important thing comes into the play. Whenever I am using these relational operators what do I get? If I write x less than y in an now we know that what are these x and y? These are two operands and what is this? This is an operator. So, when I carry out some operation I will be getting some result. So, if I had done x plus y and suppose x was 5 and y was 7 then x plus y would have given me what? 12 would have resulted into 12? 5 plus 7. Now, if I do this x less than y that means 5 less than 7 what will this give me? It will any relational operator gives me only true or false 1 or 0. So, when I say x less than y and x is 5 y is 7 it is true therefore x less than y in this case will return 1. If I write y less than x if I write y less than x it will return me false because y is 7 and x is 5 then this will be false this would return 0. Similarly, for greater than y greater than x will return me in this case in for this particular value set y greater than x will give me true 1 or in conceptually we can say true, but this true cannot be represented as T R U E in a computer it is written in C it is represented as 1. Less than equal to in this case what would be what would have happened? Why less than equal to x? Is it true or false? Is it true or false? Less than or equal to in this case is is y less than x? No is y equal to x? No therefore it will be false why greater than or equal to x? What would have happened? Why is not greater than is greater than x not equal to x? Therefore it immediately becomes true y is y equal to x in this case no so it will return false y is not equal to x is it true or false? It is true therefore it will be 1. So, what we could observe is we can form expressions using relational operators, but these expressions only return the values true and false. We will see that these relational operators if you recall in our flow chart discussions we often had some decision boxes shown as diamonds and in that decision box we used to say x greater than 10 or say we used to write something like n equal to 3, yes or no? We had taken one path for yes, one path for no and that can be captured very easily using such relational operators as we will see. Now here are some other examples I have already given you enough examples 10 greater than 20 true or false it is false ok 25 less than 35.5 yes it is true 12 greater than 7 plus 5 now here if one of the operands is an expression that will first be evaluated so the arithmetic operators and expression have higher priority over relational operators all right. So, here what will happen? 7 plus 5 will be first computed so that is 12 is 12 greater than 12? No so it is false ok. So, when arithmetic expressions are used on either side of a relational operator the arithmetic expressions will be evaluated first and the arithmetic expressions will be evaluated in accordance with the precedence that we have already defined. So, if there be something like this a plus b greater than c minus d that is equivalent to first I will compute a plus b then I will compute c plus d and then suppose a plus b is 10 and c plus d is 17 then this will lead to false ok. First these will be computed then the relational operator will be computed. So, here is a quick look at a at an application of this. Suppose I want to implement the flow chart something like this I have read x and y and I want to do x greater than y if so yes I will be say I will print x is larger otherwise I will print y is sorry. Otherwise I will print y is larger right. So, that sort of situation how will that translate into c language here you see this part we have not discussed but it is very intuitive we can understand if x is greater than y I print what is larger dash is larger than what will come here the value of x. So, I will print say x is 10 and y is 15 this is x and this is y then what will be printed here 10 is not greater than 15. So, this part will not be executed will come to here because x is not greater than y. So, we are taking this no path and we will print dash is larger and in dash what will come the value of y that is 15. So, what will be printed is 15 is larger. So, that is how we can implement this sort of decision box and when I have got a choice between paths based on the decision that is being that condition is being computed using relational operators which this conditions are telling me which path I will take is the situation true if so I will take this path otherwise I will take this path this is known as the this is a purpose of the relational operators. So, next class we will start with logical operators today we have discussed about arithmetic expressions how arithmetic expressions are formed using arithmetic operators and what are the very important thing that we have discussed today is in the earlier lecture also in lecture that what is the precedence till now what you have discussed is that what is the precedence of the operators in an arithmetic expression and what is a relational operator. And we have seen that relational operators have got lower priority than arithmetic expressions. So, if on either side of the relational operator there are arithmetic expressions those will be evaluated first in accordance to the arithmetic operation priority. Next we will come to another very important concept that is logical operators. Thank you.