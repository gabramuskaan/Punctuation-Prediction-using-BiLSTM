 So, we were discussing about pointers and we have seen that pointer is a variable. So, since it is a variable, but a variable that points to some other variable. But naturally the question that can arise is since pointers are variables, we should be able to do some sort of operations like arithmetic operations on them. So, the answer is yes, we can do that and in today's lecture we will look at exactly that pointer expressions. Now, this concept of pointers is a very strong component of the C language and it is not the case that in all languages this pointer is there, but we are discussing pointers specifically because it will give you a very good idea about what indirection is. We had mentioned about indirection right. So, for example, I am just before moving into the actual discussion, let me come to this that what is an indirection. Somebody asks you the address of Tom's house. You can do two things. You can either give him the address of Tom's house or you can give him the address of John's house. So, that he goes to John's house and asks John to get the address of Tom's house. So, I do not know Tom's address, but I know John who knows Tom's address. This is indirection, one level of indirection. Another level of indirection could be that second level of indirection. You can go to Ram and Ram will know the address of John who knows the address of Tom. So, that is second level of indirection. So, in our case we have got a particular variable P. Let me just call this variable x and that x has got some value. I am not saying and x has also got an address, but I am not saying what is the value of x? What is x? That is my question. And instead of answering that, I am giving you a pointer to x and I am asking that I tell you, I give you the answer go to P and find x. So, then P must be assigned the address of x. So, I go to this, then I come to P and get the value of x as I want to have that in some other variable V, where I want to have star P. So, indirectly I could have done simply V assigned x, this two are equivalent. That is what we discussed in the last class. That is why this is an indirection that often comes in very handy, very useful when we carry out many computations. So, like other variables, pointer variables can also be used in expressions. If P 1 and P 2 are two pointers, the following statements are valid. Star P 1 plus star P 2. So, what is being meant by that? Suppose P 1 is pointing to something where there is 50 and P 2 is pointing to something, which is stored as 60. Then what is some? Some becomes 50 plus 60. So, this is star P 1 plus star P 2, 50 plus 60. So, that should be 110. Next, similarly I can have this, but here it is a little, it will be nicer if I had, it will be easier nicer to read, if I had put parenthesis, so that I am not confused about this asterisk and this asterisk. These have got completely different significance. This is a multiplication and this is saying, this asterisk is saying, it is a content of a particular pointer. Similarly, these two are equivalent of course, I have already shown that. Now, this is also possible. Star P 1, so in my earlier drawing, P 1 was 50, 50 plus 2, that is being coming over here. So, this one looks like that. Whenever you are finding difficulty, as I suggested, just draw a simple diagram. P 1, P 1 is pointing to some other variable, which has got the value 40. So, P 1, star P 1 is what? Star P 1 is that particular variable X and plus 2, that is equivalent to X plus 2, which is 42. And so, that is coming to, so this one is being modified to 42. Similarly, I can do other operations like this, where you must understand that this is actually talk just like another variable that an integer variable or whatever type P 1 is, that type of variable. And it is simple, no other complications in that. Now, what are allowed in C? The certain things are allowed in C and some things are not allowed in C. I can add an integer to a pointer. I can subtract an integer from a pointer. I can subtract one pointer from another. And say if P 1 and P 2 are both pointers to the same array, then P 2 minus P 1 gives the number of elements between P 1 and P 2. For example, suppose here there is an array. So, P 1 is pointing here and P 2 is pointing here. Then the number of elements P 2 minus P 1 will be just the subtraction of these addresses. Suppose this was 5500, 5 and 1 if it be a character, 5 and 1, 5 and 2, 5 and 3. So, I have got three elements in between. So, these are all allowed. I can subtract an integer from a pointer. I can add an integer to a pointer. So, if I add an integer to a pointer, that is P 1, P 1 plus 1. So, that means it will point to this point, this element. What are not allowed? The things that are not allowed are you cannot add two pointers. The reason is obvious. P 1 is a pointer and P 2 is a pointer. Now, these two are two different locations. So, say P 1 is in location 7000 pointing to some variable and P 2 is in location 10000 pointing to some other variable. So, what does P 1 plus P 2 mean? 7000 plus 10000, 17000 that does not mean anything. That can be a point to some garbage value or something else. So, that is not allowed. Compiler we hold you for that. Multiply or divide a pointer in an expression. That is also not allowed. You cannot multiply. You can just add an integer, subtract an integer or subtract one pointer from another. These three you can do. And here is something which is known as a scale factor. Let us see whether you understand this or not. We have seen that an integer value can be added or subtracted. So, here let us look at this. P 1 and P 2 are two pointers of type integer. I mean P 1 is pointing to an integer. P 2 is also pointing to an integer. Now, I j are two integer variables. P 1 is P 1 plus 1. That means what? P 1 was pointing somewhere. But I am just adding some constant to that. Here is a MA location. And say P 1 is pointing to this. And suppose it is an integer. So, this pointing to an integer. Now, P 1 plus 1 means this will point to the next integer. Now, I am not saying whether if an integer takes two bytes, each of them are of two bytes. So, it just comes to the next integers. The pointer arithmetic is that is why the type is important. Depending on the type, it is updating either by 2 or by 1. But P 1 plus 1 means I am going to the next. I am P 2 plus P 2 is assigned P 1 plus j, where j can be something. So, it goes to the so P 2 was pointing somewhere here. I am upgrading that with the j value going to the jth next. Similarly, P 2 plus plus P 2 assigned any arithmetic operation I can do. Next, in reality it is not the integer value which is added or subtracted. But rather the scale factor times the value. That is one means one times the size of the integer. So, j times the size of an integer, two bytes, four bytes, that is what. That is why it is called the scale factor. So, this is not this one, but next, one next, two next, here jth next like that. So, for character the scale factor is one, integer is four, a four bytes take one integer, float, four. Now, this could be two, that depends on what the scale factor is depends on the particular machine. So, if I write a for an integer pointer assuming the my computer is actually doing this, that each of them is four, then P 1 plus plus is adding P 1 by four. That is going to the next integer, going to the next integer. Now, in between there are four bytes. So, I am going to the next integer. So, there is one quick way of finding out how we can find out what is my representation in my system. There is a nice inbuilt function called size of. So, if I give size of int, the system returns me the value four or two depending on how much, how many bytes does int consume. Similarly, I could have given size of float that will tell me how many bytes does the float consume so and so forth. So, that is one way to find the scale factors. So, number of bytes occupied by float is size of float. If you give that the system will give you the size of returns that one that value. The number of bytes required for that representation. So, in the system you would run this and you find that it is float is four, int is four, then you know what my scale factor is. Now, just like for every case we are thinking of how do we pass an array to a function, how do we pass a structure to a function. Here again we look at how do we pass a pointer to a function. Pointers are often passed as parameters to a function and if you have thought about it you must have already discovered. Now, always it allows the data items within the calling programs to be accessed by the function altered and then return to the calling function in the altered form. This is the calling by reference. Normally arguments are passed to a function by value. We have discussed this. Now, this is called as call by reference or call by address. Now, you can see this how this is done. Because in call by value we have seen that in the swap function for example it was swapped within the function. But that x y and the main function x y were two different entities. Therefore, whatever change was there that was lost. Therefore, here but if I had just passed on the pointer then whatever change I do in the pointer in that particular location I simply pass on the address and make a change over there then the change is reflected. Because it is the same location that is known as call by reference. Now, here is an example of you have seen this passing by value. I am repeating this a was 5 and b was 20. I call swap a b here what happened it took x was 5, b was 20. I changed it. Now, x was therefore now x was 20 and b was 5. But when I returned and printed this a and b they were completely different. So, swapping was not reflected. Therefore, here x and y were swapped a and b do not swap but instead so the output would be the same 5 and 20. But if I had done through reference here you see how I pass it on. Here what I am passing you have must have thought about it. So, up instead of sending that value what I am sending is the address of a and address of b and here inside the function what am I accepting I am accepting the pointer. So, here x and y I know that what is coming to me is a pointer. So, what happened here it was 5 we discussed it earlier also but let me repeat because it is a very fundamental idea b is 20 and now I swap. So, here I have got do I have x no I have got this x which is nothing but and a and I have got this y which is nothing but and b. Therefore, they are pointing to this points. Now when I swap I am actually swapping the content of x. So, the content of x that means here that is going to t and then content of y in direction I go from here follow my cursor I go here and that one is going as the content of a content of x. So, here it is becoming 20 and then t is coming as the content of y what is y. Y is here. So, this is coming as 5. So, when I come out and print here a and b as you can see has changed. So, you see how did I pass on the parameter look at this I have passed on the address and I have accepted them in my function as the pointer. So, with this we will get the correct answer x and y swap a and b also swap. So, the answer is that is correct one as we expected. So, now let us skip this a little bit and let us go to something else as pointers and addies. When an array is declared when an array is declared the compiler allocates a base address and sufficient amount of storage. You know that when I declare something an array int a 10 and if I say that int I have discovered using size of that int takes 4 bytes then for every element 4 bytes are kept and 40 such locations are allocated. For me means for the array a. Now, this is alright. Now, when I refer to this array a because we saw that we pass on an array by reference to a function when we pass an array we call it by reference the reason behind that is that this name array a is the same as a pointer to the first location of that. So, it is as if equivalent to a is a pointer that is pointing to the first location of this array a alright they are equivalent. So, the base address is the location of the first element of the array the compiler also defines the array name as a constant pointer to the first element constant pointer. When I declared the compiler also keeps a constant pointer that pointer you cannot change for example, when I say x 5 1 2 3 4 5 then suppose the base addresses 2500 each integer requires 4 bytes then the elements will be x 0 will be 2500 x 1 will be 2500 so and so forth. And the pointer will be 2500 if you go up 2500 so there is a pointer x means and address of x 0 which is 2500 alright. So, p assigned x and p assigned end of x 0 are equivalent. So, we can access successive values of x by using p plus plus or p minus minus to move from one element to another. So, I have got the p I have got this pointer is pointing to the array I cannot change that pointer but if I do p plus plus this point in the first element then I go to the next element of the array accord by the scale factor. So, this is if I do p plus plus I am actually doing p plus 4 set in that way I can move across. So, the relationships should be clear here so p plus 1 is the next one p plus 2 is the next one that we have already explained. So, here is a function to find average here you see we have got and a main program where I have got an array 100 elements for k assigned k to n for k 0 to n. So, I am reading k and then I am calling this average x I am calling average x n. Now, here what goes average x n you have seen this now you am passing the pointer when I am saying I am just passing the array actually I have passed on the pointer. So, whatever I do I am doing here I am taking another star p which is local which is pointing to the array. So, my array was here and I am putting another pointer p which is pointing to this array and array means what? array means the first location of the array then I carry on the sum here I carry on with p I here you see what I do I take p and then I change p sum assigns star p plus I. So, I am p plus 1 p plus 2 p plus 3 and star p plus 1 p plus 2 means the content of this these contents. So, here in this way I am getting the sum and returning what do I return return float sum by size. So, I get sum obviously the array was integer but now this is something called type casting that I can make it although it was float I put it in a bracket that means whatever is coming here I am converting that to float. Sum will be the array sum of all integers will be any integer but when I divide by that although I did not declare sum to be floating point number just by this sort of type casting I can make it I will first do this and convert it make it a floating point number and then how do I return it? Yes you might have guessed correctly that I do not need to return it because whatever I have done here when I passed an array whatever was done that is being done here and this sum what I am returning I am returning this to the average so I will get this value. So, this should be clear so clarified now next thing that I will be discussing a little bit is on dynamic memory allocation I will take little time to explain that that is a very important concept and after that we will move to some discussion. So, let us discuss some basic discussions on file.