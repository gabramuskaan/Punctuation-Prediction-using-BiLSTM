 So, in the last lecture we have seen how we can write a program to find out whether it is prime or not. Now, this program that you see that we have we are discussed in the last class will certainly give us correct result. Now, our job is not only to write a correct program, it is also very stimulating intellectually to think of how we can make it a more efficient program. Often the program can be correct, but it is not very efficient. What do I mean by this efficiency? See if we look at this program and again I take the earlier example that suppose I have my n is 13. Now, and I start with the value of i to be 2, i is 2 and n is 13. And since it is prime, I am checking this condition time and again and since this is third prime number, how many times it will never come here, it will never succeed. So, I will have to carry on this loop and ultimately when I exhaust all the possibilities, then only I will come to this point. So, how many times do I have to do this? Let us see I am starting with 2 checking once, then start incrementing and making it 3, then 4, then testing with 5, then testing with 6, testing with 7, testing with 8, testing with 9, 10, 11, 12. So, how many times did I check it? 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 times. I had checked it with 11 times. Now, do I really need to check it with 11 times? If you think a little bit, if this number is n, then I need not check it and I am starting with 2. So, n minus 2 times I am checking, do I really need to check n minus 2 times? If I do not find it divisible by square within square root of n times. So, square root of 13 as an integer, what would it be? 13 would be 3 point something. So, 4 times within 4, if it is not divisible, it will not be divisible by the future numbers also. So, if I just apply, if I do not find it, this knowledge that if it is not divisible within square root of n, then it will not be divisible later. I can make this program much more efficient. So, now, let us go to another example. This is again finding the sum of some of the digits of a number. Now, this one we did not do, some of the digits of a number, what is meant by this? Suppose, I have got a number 123, some of the digits of a number means 1 plus 2 plus 3 6. If my number is 243, then the sum of the digits will be 2 plus 4 plus 3 6 and 3 9. This is what I want to find out. So, how do you go about doing that? How do I find out the digits? Say 1, 2, 3 from there, how do I extract out 1, 2 and 3? Just think over, if I have got 1, 2 and 3 and I divide it by 10, I will get a quotient 12 and the remainder. So, the remainder is 1 digit. Now, I take the quotient divided by 10, I will get a remainder, I will get a quotient 12 and the remainder. So, the remainder is 1 digit. Now, I take the quotient divided by 10, I will get a remainder, sorry, a quotient and a remainder. The remainder is another digit and then I go on till it is the number is not equal to 0. So, next I take 1 and divided by 10, the quotient is 0 and the remainder is another digit. And then I go on till it is the number is not equal to 0. So, next I take 1 and divide it by 10, the quotient is 0 and the remaining there is 1. So, you see I have got all the digits from the right hand side, one after another, so I can add them. That is my basic way. So, let us keep it on the side and see what we have done in this program. I have got a number n. Now, this number that has been given initially, 1, 23, I do not need to preserve that number. So, I can play with that and I have to make a sum of this, 1, 2 and 3. So, I keep a sum to be initially 0. I keep a variable sum which is initialized to 0 as we saw in the earlier examples and sum is also an integer. Then I read the number that is say 1, 23 has come. Now, while the number n that is 1, 23, 1, 23 is not 0. Then I take add n modulus 10, n modulus 10 will give me what the remainder 3 and add it to the sum. So, my sum now becomes 3 and then I want to find out this thing also. I make my n to be n divided by 10. Now, this operation gives you the quotient, this operation gives you the remainder. So, now I get n by 10 means now 12 and I go back to this loop. I check that 12 is not 0. So, I will again do that. Sum will be sum what was that 3 plus n modulus 10. So, I again divide it by 10 and take the remainder and that remainder is added some plus this. So, 3 plus 2 will be 5 and then I divide n by 10. So, now I find out 1. Still I go back 1 is not I go back actually here 1 is not 0. So, I again divide it by I take the remainder divided by 10 and take the remainder. So, the remainder is 1, I add it to the sum. So, it will be 6. And then I divide I find the quotient and that is 0. I go back again here and find that n is not equal to 0 condition is not true. So, I come out of the loop and I apply this primitive statement. What is the primitive statement doing? The sum of digits of the given number I cannot say given number n because n has already changed. I will come to that in a moment. Now, is sum. So, I have got the sum. So, this is another example of a while loop. Now, my question is if I have understood it. I want the output to come as printf the sum of digits of the number 123 is 6. How can I do what modification should I do in this program? What I want to be printed is the sum of digits of 123 is 6. What should I modify? Of course, I should modify this statement. This statement should be the sum of the digits of the number percentage d is 6. d is percentage d and here before sum what should I do? My n that was provided by the user has already been destroyed in this loop. So, what because every time I am dividing it by 10 and making a new number 123 is becoming 12 and then it is becoming 1 then it is becoming 0. So, I have to save it somewhere this 123. So, what I can do here? After this reading this I can save it in another variable norm as n and here I will put norm comma. Now, because I am destroying n here but I am not touching norm. So, norm will remain intact only another thing that I have to do I have to add this norm here. I must declare it norm as an integer otherwise it will give you syntax error. So, this is another nice example of while using which we can find the number of digits the sum of the number of digits of a number. With that we move to another example decimal to binary conversion. Some of you may know it and some of you may not be very very conversant with that we know that we have got the binary number system where the base is 2. So, everything is expressed using 0 and 1. So, if I have a binary digit sorry decimal digit 4 its binary equivalent is 1 0 0. If we have 5 that is 1 0 1 if it is 1 then it is 0 0 1 or just 1 if it is 2 it is 0 1 0 like that. The question is that given our decimal digit how can I convert it to binary what is the algorithm? The algorithm is something like this. Let us take the number 4 and I want to find out what is the binary equivalent of this the algorithm goes like this I first divide it by 2 because 2 is the base of any binary system. I divide it by 2 so I get the quotient as 2 and remainder as 0. Next I divide it again by 2 so my quotient is 1 and remainder is 0. Next I divide it again by 2 my quotient is 0 and remainder is 1. So, I go on dividing till I get a quotient to be 0 and I have remembered all the remainder that I got. Now I can get the binary if I did it in this direction so it is 1 0 0. Let us take another example suppose I want to have the number 15. Now what is the binary of 15 to understand that let us look at the weights of the different positions in binary this one is with 2 to the power 0 2 to the power 1 2 to the power 2 2 to the power 3 that means this is 8 4 2 1. Now 15 if I have to have I must have a 1 here and 7 more so 1 here 8 and 4 12 and 1 here 12 13 14 and 15 all this should be 1. So can we find out find this out let us see 15 I divide by 2 my quotient is 7 and remainder is 1. I again divided by 2 my quotient is 3 and remainder is 1. I divide it by 2 again my quotient is 1, remainder is 1. I divide it by 2 again my quotient is 0 and the remainder is 1. I did it in this direction and we get 1111. Let us take another example again the weights of this system are 1 2 4 8 2 to the power 0 2 to the power 1 2 to the power 3 2 to the power 2 2 to the power 3. 1 will be 16 is 2 to the power 4. Now let us take a number 23 what will be the binary representation of that let us see here 16 will be there of course it is higher greater than 16. So 23 16 and 6 and 7 more so this should be 0 I cannot put a 1 here because that be 16 and 8 will be 24. So 1 here 20 this this so my binary is 1 0 1 1 1. Let us try in our algorithm divided by 2 my quotient is 11 I have got a remainder 1 I divide by 2 my quotient is 5, remainder is 1, I divide by 2, quotient is 2, remainder is 1, divided by 2, it is 1 and 0. And 0 and divided by 2 is 0 and 1. So I reach a 0 I stop and this is the pattern 1 0 1 1 1 1 1 0 1 1 1. Now let us see how this algorithm that we are talking of can be encoded in C program you see here. I have declared one variable as dash that means the decimal number that I will be reading. So I am reading that number here. Now in the earlier example we did it while do now here we will that is also very interesting and known to us that is finding the greatest common divisor of 2 numbers. What is the algorithm? The algorithm is shown here. Suppose I have got a number 45 and 12 I am to find out the greatest common divisor or the 8 shape of these 2 numbers. What I do is I divide the bigger number with the smaller number and get a remainder. You see the remainder are becoming so important we come to the remainder. And then if the remainder is not 0 I divide now the smaller number this one with the remainder and then I get again a remainder which is non 0. Then I take the divisor current divisor and divided by this until we get 0 that is what we used to do in school. So ultimately when I get 0 whatever is the divisor currently current divisor that is our 8 shape or GCD. Here you see how the code is written. Let us look at the code a little bit and try to understand it. A and B are 2 numbers. Now I do not know as yet which one is smaller and which one is bigger. Here in our example we can see 1 is 12, 1 is 45 but 1 is 12, 1 is 45 but I am going to try this. Here the computer does not know which one is 12 which one is 45 and I am taking another variable temp. I am reading the numbers a and b. Now if a is greater than b that means I am taking the greater number and moving that in temp. Out of this 1245 which one is greater than 45 so temp becomes 45 and b becomes a. B is the smaller number so 12 becomes a and b becomes temp. Now you see I have written this 3 in one short so let us see here what is happening after this. First temp is 45, a is 12 and b is 45. Now what I am doing here I am keeping this temp, what I am doing here I am dividing b by a. So 45 is being divided by a 12 and I am checking the remainder. The remainder is not 0 you can see that. Since it is not 0 I am taking temp to be the modulus of 12 sorry b was 45. So here b was 45 and a was 12 by this point. So then and temp was 45 I try this it is not 0. So then I take this remainder 9 and again make that to be b. So now b becomes 9 and a becomes the temp which was this number. And I go on dividing this and I go on carrying out this loop what till this becomes 0. As soon as this becomes 0 then I have got my gcd stored in a because every time I am taking the a in a I am storing the temp. And what is temp temp is after I divide I get the remainder and that I am storing in temp and that temp is coming in a is being stored in a and that is also copied in b. But in the next loop that is being divided by so here you are having 3 9 and here 3. So look at this iteration 1 here looking at this picture first temp will become 9 b is 12 and a is 9. Next time temp is becoming 3 b is 9 this 9 and a is becoming temp and whenever I find that b divided by a this part is 0, remainder is 0 then that is my gcd a is my gcd I get the 3. This is another very interesting example of computing using this while loop and repeatedly I am doing this till I find the remainder to be 0. So there are many such nice examples and will give you some more during for assignments which you will have to solve and get more confidence about it. So next we will look we will come to some of the pitfalls of loop and then move to something more useful something very useful that is the concept of arrays.