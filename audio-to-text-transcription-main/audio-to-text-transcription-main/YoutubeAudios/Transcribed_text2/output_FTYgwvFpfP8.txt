 In the earlier lecture, we have seen how we can search in a list of items, maybe list of integers, or maybe list of names, or list of real numbers in a linear way. That means, we start from one end of the list and we have got a key and we check for every element, whether the element in the list matches the key or not. In that way, we go on from top to bottom and ultimately, if we get the match of the key to an element of the list, we declare it is found and we also say where it is found. Otherwise, if we exhaust the list and still do not find the element, then we say that the list is not found. And the way in which we are searching from the top to bottom, that process is known as linear search. We have also seen that the time that is required to search for an element, in the best case, it would be of order 1, that means, at the very beginning, we can find the element. Otherwise, we have to come in a comparison. So, we have to do the minimum is 1, if we get a match at the beginning of the top of the list. Otherwise, we may have to exhaust all the elements and whether it is found or not found, we can say only after we have compared all the elements. So, if there is a list of n elements, then the maximum number of comparisons that I may have to do will be n. Therefore, on an average, it will be n plus 1 by 2, that we say in complexity of algorithms, parlance in that parlance, in that terminology, we call it order of n. That is not the main issue with us, but we can say, therefore, that in a list of elements, if I have got n elements and the list is not sorted. So, maybe 5, 2, 7, 9, 11, 1, say this is a list and I want to search for a key. So, this in this case, it is 6, but in general, I can say that there are n elements, in general, I can say, number of elements is n. So, the best case, I can get a match here, the number of comparisons I require is 1. In the worst case, I have to come up to this and compare all these n elements. So, the number of comparisons on an average, will be n plus 1 by 2, that is the average number of comparisons that we denote in computer parlance as of the order of n. This O has got a name called Bgo, I am sorry, let me write it in this way. This is called Bgo notation, Bgo notation. So, where it just denotes the how much time a computer can a program will take to run in terms of the input size. What is this n? This is the size of the input data, we call it input size. So, obviously, you can see that as this list increases, if it becomes 100, then the average time that will be taken, average, this is the average. Complexity will be more than this, if it will be 1000, it will be even more and as increases, the time will increase in a linear fashion, as n increases, the time will increase in a linear fashion. However, the way we are searching is known as linear search. One thing to note is that in this case, we are not making any assumption, this is time. We are not making any assumption about the way in which the data items are organized. Now, in an endeavor to see, if we can make it better, we today discuss another very important type of search algorithm, which is known as binary search. Why the name binary is coming, you will be very clear in a moment. But the important thing to note is that in this case, the list or the array must be sorted. That means, it is organized in some particular way either in an ascending order or in the descending order. Why is it called binary? Let me just try to explain it with an example. Say, I have got the array, but in a sorted way. So, I have got one, two, the elements were there in the earlier case, one, two, five, seven, nine, 11, one, two, five, seven, nine, 11. So, one, two, five, seven, nine, 11. Now, suppose my key is, well, let the key be two. Now, we will start at the middle of this array. First, we look at the middle. Now, since this is an even number, even sized array, six elements, the middle can be somewhere here. So, let me take this. This is the midpoint. Now, I compare the key with the middle element, two and seven are being compared. Two things can happen either to the key. I will rather say either the key is less than the mid element or the key is equal to the mid element or the key is greater than the mid element. Three things can happen. Now, if the key is equal to the middle element, then my search immediately stops. Yes, I have found it. And where did I find it? The index is mid. If the key is less than the mid element as is the case here, then what can I say? I can immediately say that the I still do not know whether the key is there in this area or not, whether the key is here or not, I do not know as here. But the thing that I can say is that the key, since it is less than the mid, it cannot be on this side. It cannot be on this side. Not possible. It must be if at all on this side, because the key is less than the mid. Therefore, I can restrict my search within this period, suppose within this zone. Now, what I will do? I will again take the middle point of this area. So, here it is becoming very simple. So, the middle point of this part is suppose 5. I could have had it from 1 to 5, but I am just taking from 1 to 7. I come at this point and again now I compare this element with the key. And still it is less. Therefore, I am sure that it is not in this area, it must be in this zone. Now, I again only for this part, I apply again, I find the mid element and this is here. And I find that the key and the element are matching. So, it is found. So, how many comparisons I needed here? In this case, I needed 1 to 3 comparisons. In the case of linear search, of course, you could have got it luckily here in 2 comparisons. But what would have happened if my key was 9? In the case of linear search, suppose the key was 9. In that case, in the case of linear search, what would have happened? I would have started from here, 1 comparison, 2 comparison, 3 comparison, 4 comparison and the 5th comparison, I would have got it. On the 5th comparison, I would have got it. But let us see what would have happened in the case of the new search technique that we are looking at, 1, 2, 1. So, again I have 1, 2, 5, 7, 9, 11 and my key is 9. I know that in case of linear search, I needed 5 comparisons. What will happen here? I will come to the middle point here. I find that the key is greater than mid. This is mid. The key is greater than mid. Therefore, I know that the key, if at all, cannot remain in this zone. This part is ruled out. This part is ruled out. It must be in this zone. So, again within this, I find the new mid. So, the new mid comes here and I find this new mid, new. I check this. Now, I find that the key is equal to mid. Therefore, I find my search completes here with this index as the output. Now, how many comparisons I needed here? 1, 2. Only 2 comparisons. So, 2 comparisons versus 1, 2, 3, 4, 5 comparisons in the case of linear search. Now, why was it reduced? The same thing would have happened with if my key was 11. Let us have a look. If the key was 11, in that case, suppose the key was 11. In the case of linear search, I would have required 6 comparisons here to reach at 11. However, in this case, I would be sure if key is greater than this, then my next iteration will be between these two and would have found the mid, new mid and I would have got it within 3 comparisons. Now, why is it becoming so? Why is the number of comparisons being reduced? The reason is we have got this array and at every stage, what I am doing is, I am looking at the key and depending on whether the key is greater than the mid, I am concentrating on only one half of the array either this array or this array. Then, depending on the key value, I take, suppose it is greater than I will concentrate on this zone. If it is less, I will concentrate on this zone and iteratively, I will be reducing my search to a smaller array. Let us have another example. Let us have another example. Let us have it a little bigger. Let us have 17, 19, 20, 21, 25, 32, 38, 40. Now, I have got, again, even number, let me have 42. Say odd number, that is, 1, 2, 3, 4. Now, I have got 9 elements. Now, I will start with the mid element. What is the mid element? Here, between this, the mid element is this. And suppose my key is 19. Then, I know that my key cannot lie, since it is less than 19, it cannot lie in this part of the array. If at all, it will lie on this part of the why, why do I say that? I can say that because this array is sorted. Otherwise, I could not have said, since it is in an increasing order, I can say that since the key is less than the mid element, therefore, it must be in this zone. And so, I come to this zone and find out the mid element again, maybe in this zone or up to this. Say, I come here and find out the mid element to this. Again, so, I am looking, I am immediately reduced my list to half. This half, it could have been if my key was say, 38, then I would have restricted to this half, not this half. But for 19, I am restricted to this half. Now, again, 19 is less than 20. So, immediately, I will restrict myself to this half. And I will not consider this part. So, gradually, I am going to the lower half or the higher half at every stage. So, what is happening is something like this. I am starting with the whole array. Then, I am concentrating either on the left half or on the right half. Then, again, depending on that either on the left half or on the right half. If it is in the right half, then among this, I am coming to left half and right half. So, at every stage, I am dividing the array to half. That is why this is called binary search. Either it is here or it is not here, not in this zone. So, in that way, I carry on. So, consequently, the number of elements that I restrict my search to gets reduced at every iteration. Let us look at this in a little more detail. So, in every stage, we reduce the number of elements by half. I think this is clear now that this statement. Now, if you do not find it, you can ignore the half of the array and repeat the process. So, now, let us look at this. Basic strategy, what do you want? The array is from 0 to n minus 1, n elements. Here, I was showing me only. So, this is the mid M and this is the left end, this is the right end. So, there are two index indices. Now, I am taking the key and I am checking this part, M, the element M, this element. That is xm and depending on whether, if it is greater than the key, if xm, if the key is greater than xm, key is greater than xm is less. Then, I would be concentrating here. If xm is greater than the key, then I will be concentrating on this half, on this half or on this half. That is what I was explaining till now. So, here, if it is no, then I will, if it is xm is less than the key, then I will come to this half. Otherwise, if it is yes, I will come to this half greater than the key. So, we will first, given this a and r, what is my mid element? How will I compute my mid element or M? That is L plus r divided by 2. And then, depending on whether it is less or greater, we will move the left or L or r to the middle, depending on the test. So, again, let me show it with that example that we are showing. So, something like this, 1, 2, 5, 7, 9, 11, what is being said is 9, 11. So, L is L equals 0 and r is equal to 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5. So, R is equal to 5. So, mid is L plus r divided by 2. So, that is 5 divided by 2. So, we can take 2 or or we can take 3, depending on. So, I come to, if I take 2, if I take 3, then I am coming to mid. So, what I will do is, if 3 is my mid point, if I take 5 by 2 is 3, then that means, it will be in case of odd, I will add 1 to that. So, I can move. Now, if the key is suppose key is 9. Suppose the key is 9. So, my mid was the third is 0, 1, 2, 3. Let me, 0, 1, 2, 3, this is my mid. Now, since the key is greater than the element x, m, x mid, since it is, x mid is less, I will be restricting my search in this area. Therefore, what I will do, I will move this L to mid. So, this will be my new L and I will find the mid with, now next mid will be this new L plus r by 2. So, that will be this element. If my search was on the other side, that means, if the key was not 9, but the key was 2 or 1, let us make it 1, then at this point, I find that the key is less than x, then I will be restricting my search in this area. Then, that case, I will move this r, I will shift this r over here and this the mid will be r will be the mid. So, next I will be restricting my search in this half and forget about this half. So, that is how we at every iteration, we break down the entire array into halves. So, if you have understood this, let us proceed, repeat the search operation in the reduced interval. So, what we are doing is, we are looking at this binary search algorithm and we are trying to design a function and binary search is a function whose name I am just keeping as bin search. This is the name of the algorithm and what are the parameters? Let us see, the parameters are one is the array that is being passed, the list that I have to search, I also need the size of the array and I need the key. So, these are the three things. So, bin research is a function, what are its inputs, the list or the array which is x, the size or what we are calling about right now n and the key. And what will the output be? Bin search will tell us whether it has been found or not, but so it will be a 0 or 1 found or not, 0 or 1 or it can return us an index also. So, now if we proceed with this idea, then let us develop the algorithm step by step. Inside this function, I have got the search, I have got the list, the list is given to me, this array is known to me, I declare internally LR and I have to use another index called MEDE. Now, this has got no meaning outside this function. Next step, what should I do? Next step would be while some condition, MEDE I have to find out L plus R by 2. As you know, if this is the array x, if the MEDE element is greater than the key. So, the key say this MEDE is 7 and my key is 9. So, this element is greater, then I know that this element is greater. So, this is 17, this is greater than the key, then I will have to keep my search within this zone. So, this R will be updated and the R will come here. Otherwise, L will be moved here. This much is clear. You think over this and build upon this algorithm, we will take it up in next step again. You have to decide on how to build these things up.