 We have seen how structures are represented, we have also learnt about pointers. So, today we will be looking at the structures once again in a different light. As you can see here, a structure can be declared as as is shown here, a student structure, struct stud is consisting of three members or three fields. So, they are the role, the department code which is the character array and CGPA which is a floating point number and A, B, C are three variables of the type STUD stud. The individual structure elements you know can be accessed by A dot role. So, A is this field or B dot role, C dot CGPA. So, with this dot operator, we can access them. This was known to us. Now, we can also we have seen that we can define an array of structures where class is an array of students, class sizes 100 and each element is a structure of type stud. The structure elements of the individual records can be accessed with this dot operator like class I, any particular element of that. Say for example, here any particular element I take and so this is class I where I is this index. I come over here and get a particular field of this. So, this has got a number of fields. So, I am coming to the role field or the department code field or the CGPA field. This was also known to us. So, here we are trying to apply that through an example sorting by role numbers. So, here we have got a set of students look at the declaration here. Student or struct stud is the structure having role department code and CGPA. Now, in the main function, what are we doing? We are defining struct student class 100. Now, struct stud has been declared. It has been declared globally even before main. That is possible. And here I am saying that class 100 is one array and t and there are some integers t is again a structure t is also a structure of type stud. Now, I am reading the number of students. How many students are there in the class? The array can accommodate at most 100, but I am reading the value n. Now, for each of the elements, look at this. This is our familiar for loop here. For k is equal to k 0 to less n, I am scanning the class the role number of that particular student, the department code and the CGPA. So, in that way, I read here I am reading the array. The array is being read here. Array is read at this point. Now, what I am doing now? Next, let us look at this loop. What are you doing here? For some value of j, if the role of that student, so here I have got my array. I am coming to any particular j, a particular element and looking at the role number field of that, if that is greater than some other value k, if is greater than the role value of k, then I am exchanging them just as we sort. Now, what are we sorting here? In the example earlier that we had done, we are sorting integers or sorting real numbers. Here, what we are doing, we are sorting the entire structure as you can see here. The entire structure, the j is coming to t. So, t is again a structure, k is coming to j and so, this is a swap operation, swapping structures. Swapping the structure structures. And this I am doing for k is the internal variable and j is the external variable. So, my diagram should be a little different, the diagram should be. So, for every j, I am looking at 1 j and I am varying k from here, this is k, k is varying from this point to this point to the end of the structure and comparing with this j value. If this is any element that is less, that is coming over here and it is being swapped. So, we have seen this swap algorithm earlier. So, that is being swapped here and then I update j and I go on doing this. So, this is how I can apply the sorting algorithm that we had learnt, that can be applied for sorting student records. Next, the other thing that we have to look at is the pointer and structures, how they can be intermingled. You may recall that the name of an array stands for the 0th element of the array. So, if this be an array, then if the name of the array is name of the array is a, then the name a and a 0 are synonymous and so, a is also a can be considered to be a pointer that is pointing to a 0. Now, consider the declaration this. This is also true for the names of arrays of structures. So, if I have a declaration like this, you look at the declaration yourself. So, you can see student is a structure and I have declared of the type student an array class 100 and star PTR. Now, what is star PTR? What does it mean? You know by now just as we had done this, keep it side by side in star P. What does it mean? It means that P is a pointer that points to integer data type. Here it means that PTR is a pointer that points to stud type of structures. This type only to this type of structure, PTR points to that. So, now what do I have? I have got an array called class, each element of which is of type student structure and I have got a pointer PTR which can point to such structures. It can point to such structures, any of these. I have not yet initialized this. The name class therefore, represents the address of the zeroth element of the structure array. So, if we go back, so if I have this, then this class means it is a pointer that is pointing to this element class 0. Just like an array. So, and PTR is a pointer to the data objects of type star that we have seen. The assignment class assigned to PTR, what will it make? It will make PTR now to point to the first element of the array. Here is class and PTR is now pointing when I do this assignment, note that they are of the same type. So, when I do this assignment, this is pointing to this element. So, it will assign PTR to class 0 understood. When the pointer PTR is incremented by 1 that is PTR plus plus, you should be able to tell me what will happen. The PTR will be incremented to the next element of the array. So, the actual increment will be by a scale factor and what is that scale factor? That scale factor is size of stud. Size of this structure stud and you know that it has got a roll number, it has got CGPA. So, depending on the different data types that are housed inside that structure, it will vary. So, the value of PTR will point to the next element will be incremented by size of stud fine. This much is clear. So, it is made to point to the next record. Once PTR points to a structure variable, now this is something new. The pointers can be accessed as PTR roll that is possible. So, let us see what is happening. You are being introduced to this operator, the arrow operator. So, here or this only comes if the left side of this operator is a pointer. So, it is if suppose I have got some structure and pointer P or PTR is pointing to this structure and it has got different fields. So, CGPA is a field. If I write PTR arrow CGPA, that means that I am now pointing to this, I am actually accessing this element of the structure. Just as suppose this structure is class, and this element is class one. I could have written class one dot CGPA. And here what I have done is I have already done this that PTR, the pointer PTR was assigned to class 0 and then I did PTR plus plus. That means, now where is PTR pointing to? PTR is pointing to class one. So, I can also do PTR now, PTR arrow CGPA. These two are equivalent, this and this are equivalent. So, here also you can understand this. So, let us move ahead. Similarly, I can go to another field by PTR slash department code. I can go PTR, CGPA, PTR role. The symbol this, this symbol is naturally called the arrow operator. Example, you can read this type def. Now, here I am defining a type. The name of the type is complex. And what is this type complex? It is a structure with real and imaginary parts. This is what we have, what we saw earlier. Next, I have got a function print complex star A. What does it mean? A is a pointer to type complex. So, print F, whatever there are two two placeholders A real A imaginary. So, why is it possible? A is a pointer. So, it is pointing to some complex number. It is pointing to some complex number, some complex number whatever that is. A is a pointer pointing to that and I am going to the real part. I am printing A real and this one, this part is A imaginary. So, this is what is being done by this piece of function code. So, now swap reference. I have got complex A and complex B. That is now I am sorry, it is not being visible here. There are two A and B. There are two pointers in complex. So, there is TMP. I take another structure of named TMP of type complex. And I swap the pointers here. That is why you can you can work it out. That means that A was pointing to some structure and that A is pointing to this structure. And this particular structure is copied to another structure. TMP and B then B was pointing to another structure. B and A are swapped. So, now B is pointing to this and A is pointing to this. Next I am making B to point to this. So, that is how a swap operation can be done and how we passed on the parameter to this. So, the main program can be can define complex X 10 and 3 Y is minus 20 minus 10 because of the resolution it is not visible. So, print X and Y then swap reference print X and Y. Now, can you guess and tell me whether the swapping will work in this case or not? The answer is yes, it will work because it is a call by reference. So, here I by whatever I am swapping here that will be reflected in the main program also. So, here is an example. So, let us move ahead. Now, one warning is there that when using a structure pointers we should take care of the operator precedence because here we have seen the star symbol as well as dot symbol. We have seen the star symbol as well as the dot symbol. Now, this dot has a higher precedence than star. What does it mean? It means that if I have got something like PTR role then and star PTR dot role what will happen? This dot has got a higher precedence. So, these two are the same thing. PTR role PTR is a pointer and the role is that particular field and star PTR is what? star PTR is the star PTR is the that particular structure and I am going to the role field of that structure. So, star PTR dot role that is this one equivalent. But if I had done this that would be an error why that would be an error because this dot operator has got higher precedence than this star operator. So, basically I will try to get the role field from the pointer PTR but that is not the case. I cannot get that there is no role field inside the pointer PTR. The role field is there in the content of the pointer PTR that is star PTR. So, I must make first star PTR within bracket then dot role. So, this is correct to mean this but this is wrong. The and the operator arrow enjoys the highest priority among operators. Among all these operators it has got the highest priority. So, we have learnt. So, here in this case what will happen? Plus plus PTR arrow role as we have said that this has got the highest priority. We will go to where the PTR is and go to the role field of that and after that we will increment this plus plus although it is shown as a pre increment. So, that will not have higher precedence than the arrow operator. So, if I want to first increment the PTR and then get the role then I should do plus plus PTR arrow role will do the intended thing. This will not do the intended thing. I hope this is clear this part. Now structures and functions. Structures can be passed as argument to a function and a function that we have already seen a function can also return a structure. So, we have seen that using two complex numbers how we can do that? So, here again we look at that example that we have got a complex number complex structure with two fields. I have now changed the names flow t re and flow t i m and in the main function I am scanning and a dot re real part of a real imaginary part of a then real part of b then imaginary part of b and then I call the function a d b. What is happening here when I call this a d b? What am I passing a b and here x y? So, it is a call by value. So, here this is copied. Now struct complex x y there is no problem here it is not like so I just want to add. So, I have got two internal variables x and y and t that new structure t is taking x s real part and y is real part then it is I am getting the real part of t and in the imaginary part of t there is nothing here there is an x space. Then the imaginary part of t I take the imaginary part of x and the imaginary part of y then I am returning this t to c where c is also of type complex since the types are matching I can pass it on over there. Now this is one way of adding the complex numbers. Now if this is clear now let us look at an alternative way of using the pointers here I just change this other things are same. What I am doing here is I have called them now passing the address now I am passing the pointers in the earlier case I was passing the value here and now I am passing the pointers I am passing address of a address of b and address of c. Now inside this add function what am I doing? I am taking x and y. So, these are pointers I am taking them and t is real so t is a type pointer so t sorry so t is a pointer that is pointing to another structure of the type complex and t is r e t arrow r e means the real field of this t will be taking the real part of x c x and real part of y. So, here x plus y the sum will come this is the real part of x and real part of y will come here and here the imaginary part here the imaginary part of x and y will be added. Now when here I am not returning any t because this t is nothing but this c. So, this t and c are mapped it is a call by reference. So, c is also actually pointing over here so I get the result here. So, this is another way in which in structures we can use pointers also. So, these are relatively more advanced aspects and you will gradually practice this and we will get familiar. Thank you.