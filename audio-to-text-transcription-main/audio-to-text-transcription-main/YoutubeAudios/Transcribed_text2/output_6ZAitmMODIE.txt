 So, we are looking at recursion and that is a new style of programming where we can express the particular function in terms of itself. Like I can express factorial n in terms of factorial itself, factorial n minus 1 and n into factorial n minus 1. Another very common example of an easy example of recursion is Fibonacci numbers. We have already told you what Fibonacci sequence is. The Fibonacci sequence can be expressed as F 0 Fibonacci 0th Fibonacci number is 0. The next one is all 1 and henceforth all other ones are some of the previous two. So, 0, 1, 1, 2, 3, 5, 8, 13, 21, so and so forth. Therefore, we should be able to define it in terms of a recursive function because you can see this function F and this function F are the same only variations are in this parameters. I am expressing the same function in terms of this parameters. So, the function definition will be very simple F in 10 some integer. If n is less than 2 then return n. If n is less than 2, if it is 0 then 0 if it is 1 then it is 1. Otherwise what you do return? Return F n minus 1 plus F n minus 2 some of the previous two Fibonacci numbers. Now, this is interesting because again if you see how this will be computed it will be first expanding what are the things have to compute and when it meets the stopping condition then it starts collecting back and come back. So, how many times say if I say if I want to compute Fibonacci of 4 how many times will that function be called? Let us look at the expansion of this. So, how will it happen? Fibonacci of 4 will be I want to compute Fibonacci of 4 is Fibonacci of 3 Fibonacci of 2 these two should be added. So, I have not yet found out anything I am just decomposing the problem. This is a very very important concept that in order to solve the problem I want to decompose it in those smaller sub problems. For F 4 I have to solve it by solving F 3 and F 2. Now, for solving F 3 I have to solve F 2 and F 1 I further decomposed it. Now, for solving F 2 I have to solve F 1 and F 0 fortunately and for solve now the even now the entire thing has not been broken down F 2 for that I have to solve F 1 and F 0. Now, I have expanded the whole thing. Now, I know that F 1 is 1 F 0 is 1. So, F 2 will be 1 plus 1 2 this is known all these end points of this structure unknown 1 0 1 1 0 1. So, I go on adding them and ultimately I will get F 4. Now, it is in a way inefficient but because the same thing is being computed repeatedly. But it has it will make for 2 and x to a practiced programmer it will make you programming writing the program much more. I mean less lines of course if you can express it in much better way. So, you can see here how many times the condition was called 1 2 3 4 5 6 7 8 9 times 9 times the same function was called in order to compute F 4. So, the code for the Fibonacci sequence will be if now the stopping condition of the base condition is very very important is very very important. So, if n is 0 all n is 1 then I return 1 this is the base case unless I reach at this point I will not be able to compute the entire solution. Otherwise return Fibonacci of n minus 1 plus Fibonacci of n minus 2 that is the code for the Fibonacci number. Now, I mean this sort of Fibonacci of whenever I will have too many calls in that case I should be should avoid them as much as possible. So, what is the difference between recursion and iteration? In recursion we have the repetition I sorry in iteration it is both in iteration in iteration there is an explicit loop explicit loop for I equals 0 I less than equal to n minus 1 I plus plus. So, there is an explicit loop whereas, in case of recursion it is a repeated function calls. Termination iteration if the loop condition is no longer satisfied while this condition do if that condition fails then we come out of the loop. In the case of recursion the base condition must be recognized whenever we are getting the base condition factorial 1 or factorial 0 Fibonacci of 0 or Fibonacci of 1. So, those are the base conditions both can have a wrongly programmed both can have infinite loop. So, the performance wise iteration often gives faster result, but it is a good software engineering practice to gradually get accustomed to recursion as you do more and more programming you will see that you will be able to express the things in a much subtler way. So, whenever there is a performance issue try to avoid recursion it will require additional memory also there is a particular type of storage that is required in recursion that is known as stack stack is a last in first type of structure. So, those things briefly let me tell you how this thing is done because stack is nothing but a structure where we can push in data from one side say I put say 5 I push so 5 comes here then I push 4 then I do n minus 1 3 is a plus 1 plus 1 plus pushed then 2 is pushed then n minus 1 again and 1 is pushed. Now, when I take out the data the data will come out as 1 then 2 then 3 then 4 then 5 in the reverse order. So, the two operations are push and pop popping out from the stack and pushing inside the stack. So, this stack data structure becomes very handy for implementation of function recursive functions will show some examples like here for example, I want to compute the GCD of AB. Now, typically what happens is I call this GCD is computed I read it in the description. Now, here when I call something I call something all the say here was I was here my program flow was here I went in and when I went in all the local variables and everything here were stored and I had to remember where I will be turning back. So, all those things are stored in the stack and without a stack data structure it is very difficult to implement recursion and for that matter any function call. So, you see here is a function and so all those return address is stored before call this stack was empty. Now, after when it is returning it is taking out from the top of the stack and again I come to know where I was. So, that is similarly you see here it is an N 2 R AB that means NCR what we compute N 2 R if I compute then you know N 2 R is factorial R divided by factorial of N minus R divided by factorial of N minus R or some people write it in this way by factorial of N minus R. So, how do I do that? So, how can I implement it? So, here NCR has been called from here factorial has been called and then where do I return I return I have to come here ultimately I have to return here. So, I should not lose the path. So, what the stack does is when I make the call first call then when I make the call ins here then the local variables here will be stored on the stack and again I make another call from here. So, local variables are there I am calling fact as I go in here the local variables here are stacked up and then when I return this part this part this part will be taken out and passed on to this. So, what happens is this part is as it returns this part is taken out and I am here it can again continue and then it returns when it returns here this part will be taken out this part will be taken out this part will be taken out and so that is for normal function call how the stack remembers where I should go back. In the case of recursive calls what happens what we have seen is this is the case activation record gets pushed into the stack when a functional call is made in recursion of function calls itself. So, several function calls are going on with none of the calls are getting back so all the activation records are collected. So, you need not delve into that too much let us see I will show it by an example of computing factorial. So, this and activation record is the local variables and the return value what the function should return and where it should return. So, with that say the main function is calling fact 3 alright fact 10 and here is the fact 10 if n equal to 0 return 1 otherwise n times fact n minus 1. So, main calls fact so when it calls the function is the function is the value is n equal to 3 there is no return value return address is in main I am remembering that next again fact is calling itself. So, now fact is calling fact 3 is calling fact 2 and my return address is fact so you see it has been stacked up next fact 2 will call fact 1. So, that is what the stack is going and return is in fact alright now next time it will be fact 0 now the return value till now there was no return value now the return value is 1 return address is fact. So, as I do that I return then I have got a return value because now I have come to this point so 1 into 1 will be 1 and I am returning to fact as I return the stack will contract and what is the return result 2 times 1 that is 2 that is the factorial 2 and return I am returning to fact. So, I return again now I am coming to the last time in the fact with n equal to 3 that started here so and the result is 6 now I return to main so at every stage look at this I have I know I remember from where I started and from where I am returning back nothing is lost using this stack so stack is a very interesting data structure that helps us in many ways especially in implementing things like recursion and all those. So, one assignment that I am living to you do it yourself, press the activation record for the following version of even an axis please note down the code include stdi.h in depth f is the few an axis function a and b if n is less than 2 return n if it is 0 then return 0 if it is 1 return 1 otherwise a is f n minus 1 b is f n minus 2 I have done it in a different way f n minus 1 and f n minus 2 so f n minus 1 has to be solved separately and f n minus 2 should be solved separately then will return a plus b and then the main will be so just as a fun you try to draw the activation record of this version of the function please note it down take some time and note down this function and you see on this side have shown how the activation record will look like local variables you can see n a and b return value you have to keep whether it is in Fibonacci or in main either in main or in x or y where is x and what is y this is is x and this sorry this there is a problem in this I am drawing it again so you see this this is x this is x and this is y all right not these two these are not these are not aligned properly all right so either where do I return and here is the return to the main either I return to main or to x or to y and what is the return value draw the activation record of this and then we will see how much you could do it I am sure you will be able to do it and recurs so today we have learnt a new style of programming that is recursion and also we discussed in the last class so recursion is a type of writing functions where the function calls itself and that makes many functions to be written much more secondly much more subtly and that is a very good software engineering practice although at the beginner if you find difficulty in that you need not bother too much about you you have got iteration at your disposal and you can solve most of the problems with iteration practically all the problems you can do may be in some cases it may be a little more difficult to write but ultimately it is possible. So, if you find difficulty with recursion you can set it aside for the time being but we have to discuss it because that is a very nice way of writing functions will continue with the concept of structures in the next lecture a new thing will be introduced that is called structure. Thank you.