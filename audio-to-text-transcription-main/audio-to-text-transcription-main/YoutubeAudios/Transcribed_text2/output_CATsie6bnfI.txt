 So, you were discussing about the bubble sort algorithm and the approach as was discussed in the last class was that every element, every iteration pushes the heavier element at the bottom and that is what we had and the lighter elements therefore, goes up. So, we had shown an example a couple of examples by which we can show that the heavier elements go down and the other lighter elements go up for a we had given a number of examples to that effect. So, if there be 50 here I do not know this visible let me write it here 50 here and 6 here then and say 12 here and 7 here then what will happen is 50 will be swapped with 6 because 50 is heavier than 6 or larger than 6. So, first it will be 6 and 50 and then 50 will be compared with 12 again they will be a swap. So, there will be 12 50 50 will be compared with 7 so, it will be 750 in that way ultimately the 50 if it is the heaviest will come at the bottom. So, we swap only if the element at the top is heavier. Thereby the heaviest element is coming to the top and the others which are less than this I mean less than this heaviest element will be going at the top the bottom moves upward. Now, we are going to write the algorithm for this or the program for this. Now, before writing the program we need to understand a very interesting and fundamental concept of C programming that is pointers will not formally introduce pointers here, but we will be talking about pointers in a different way in the context of this bubble sort. Now, what is a pointer? Pointer is something that points right. Now, suppose there is a variable here. Suppose the variable is named V and till now we have seen that we can write declare the variable as int V. Now, suppose I do not so, V has got a particular address maybe that address is 1000. 1000 is the address of V. Now, if instead so, if I say int V equals 50 that means in the address 1000 50 is written, but now suppose we have got this address V and which is an integer, but I am not declaring V as such, but there is another variable P which will always point to some integers. So, P will point to this V right P is pointing to this V. In that case, I can say P is a pointer to V. Now, so therefore, what did I say? I said that V is stored in the location 1000. Now, pointer P this variable P therefore, stores the value 1000. Now, this V is of type integer. So, V is of type integer. So, P is a pointer to an integer V. That we know because V I have earlier said that V is an integer, but say so, I can I can variable say int V, but what is the type of P? P is a pointer to V which is an integer. So, we write that as int star P, what does it mean? It means that P is a is a pointer to an integer. If I write it, it is not concerned with V only. It says that P is a pointer to an integer. So, what is the value of P now? Value of P is 1000. We need to say and what is the address of P? The address of P now this, where is this P? This is in location 1000 and where is this? This might be in location 2000. Therefore, what is the address of P? And of P is 2000. We know that this and operator gives us the address. We have encountered this during scan F when we are discussing about scan F. So, let us have this diagram. To understand the concept of pointer, suppose there are different things written in different pages of the book. This is one page, this is another page, this is another page and this is another page. Each of these pages have got a page number. Now, what I have? I have got a table where suppose this has got some content A. This has got some other story B. This has got some other story C. This has got some other story D. Therefore, the content of each of these pages are the stories A, B, C or B. But which page I am looking at? Suppose, here is a page number table table of page numbers. So, I have got there are four pages. So, the pages are 1, 2, 3, 4. Now, suppose I want to, I just want to come to this page number. So, this page number does not tell me, what story is there? But this page number tells me that I have to go to this page. This entry is telling me, this particular page number is telling me that I have to go to this page. This is telling me that I have to go to this page and this is telling me that I have to go to this page. So, what are these? What are these? What are these? What are these? These are nothing but pointers to pages and what is a? A is a content of the page. So, a or C or D is a is content of page 4. And these are pointers to the pages that means, if I want to go to page 4, where should I go? Because this page may be located at some other table, maybe. Suppose, these pages of a book are torn out and have been kept on different tables. So, page number 1 is giving me the table address. So, that it is on this particular table. So, it can be on table T 1, this can be on table T 2. Maybe, the third page is on table, the third page is on table T 4 and this is on table T 5. It's possible. So, the first table, I have to if I want to read the first page, I have to go. I will come here, the first entry. This is a pointing to table T 1. So, and I go to table T 1 and find this particular page and read the content of that. So, these are pointers to pages. But these pointers also have to be in some memory location. Let me draw the diagram in a different way now. Suppose, this is my memory and I have got 4 variables. Suppose, I have got 4 integer variables and each integer variable takes 2 bytes. I am showing 2 bytes here, one of another. This is the variable V 1. This is the variable V 2. This is the variable V 3 and this is the variable V 4. Similarly, let me just change the color. So, these are suppose in locations. Sorry, let this be in locations. V 1 is in location 1000, assuming that an integer takes 2 bytes. This one is in location 1000, 2. This one is in location 1000, 4000, 2000, 2004 and this is in location 1000, 2006. And let me extend my table a bit. Now, suppose I have got here, again 4 integers. This is, this is, so this is, sorry. I will say mixed up a little bit. I want to come to this. So, here I have got P 1 is a pointer variable with again since it is an integer. Let me say P 2, P 3 and P 4. If they are integer pointers, I am not bothering about that. I am not bothering about how many locations it is taking. Now, this P 1 is actually, I am not bothering about this division here, 2 bytes. I am just showing those 2 bytes together. That will be easier for me to write. All right. So, here the P 1 is storing the value 1000. Why? P 1 is a pointer to this variable. So, this P 1 tells me not the value of V 1, but it tells me where is V 1 located. So, 1000 is a position where V 1 is located. So, P 1 is storing that pointer. And P 2 is say, 1000 to P 3 is 1000 to P 4 and P 4 is 1000 to P 6. Now, these locations also have got address. Suppose, these addresses are 5000, 5000 to 5000, 4 and 5000 to 6. This is 5000 to 6. So, please try to understand. When I say P 1, what is P 1? P 1 is a pointer to an integer. So, int star P 1. That means, that P 1 is an integer. And P 1 is an integer, sorry, P 1 is a pointer to an integer variable. It could be a floating point variable also. Had it been a floating point number, then suppose this V 1, V 2, V 3, V 4, I am just for the sake of, I am just for the sake of clarity. I am just not bothered about how many locations variable is taking. I am just seriously this. Whatever it requires depending on the machine that is taken. Now, suppose each of them is a float. So, float V 1. So, V 1 is a floating point number. Right? V 1 is a floating point number. So, then and if P 1 points to V 1, then I should write float star P 1. That means, P 1 is pointing to a floating point number. So, since it is a floating point number, if so, if I say now and P 1, what will I get? What is the address of P 1? If I try to get this not an assignment, what what is and P 1? What is the address of P 1? Address of P 1 is 5000. And what is star P 1? What is the meaning of this? Please do not be confused. This star and this star has got two different meanings. This star means it is just saying that P 1 is a pointer to pointer to what type of variable? Pointer to a floating point type of variable. So, for V 1, I am just writing float V 1. So, that means that V 1 is purely a floating point number not a pointer. But when I say float star P 1, then P 1 is a pointer to some floating point number. Now, if I just what is star P 1 in this case? What is the content of P 1? Content of P 1? Content of P 1 is 1000. All right? Content of P 1 is 1000. So, let me just repeat it once again. So, we have seen in declaration something like int star P 1 int V 1. All right? Now, that means P 1 is a pointer. P 1 is a pointer. Suppose located at location 5000 and P 1 is a pointer to a variable V 1, which is also an integer. V 1 located at location 1000. All right? These two lines are just meaning these two things, these two pictures. This 5000 or 1000, this part is not known to us because that is known by the compiler not by us. But logically to us, this is the picture. Leave us out leave us at this 5000 and 1000. Only these two parts are declared by this. Now, if I say star P 1, that means the content of P 1, what is the content of P 1? Whatever is the content of P 1? Now, if I make P 1 to point to V 1, in that case, if I make P 1 point to V 1. So, what will that be? Content of P 1 should be assigned to end of V 1. End of V 1 will give me the address of this and the content of P 1 will get that. So, therefore, this 1000 will be written over here. That means, this pointer is pointing to this V 1. I will not go into further details of this right now. We will come to this as and when the context comes later. Right now, with this in mind, let us go back to the algorithm of bubble sort. What is being done in the algorithm of bubble sort? Let us try to understand each of the functions. First thing is, we have got the standard declaration, fine no issue. Now, first let us start with this function void bubble sort. Bubble sort is void because it is not returning any value any value. It is just sorting some array. What array? X array and the size of the array is n. In Taij, they are two local variables because they are usually used as indexes of these two loops. In this loop, what is happening? For i assigned n minus 1 to 0 i minus minus that means what? That means, if I have an array here, this is my array, I have got i pointing here because that is the size of the array minus 1. So, i is pointing here and it will go up to 0. So, gradually it will go in this direction up. That is what the first for loop is saying. First for loop is saying that i is starting from the bottom and going up to 0 as long as it is greater than 0. And then for j equal to 0, j minus j equal to 0 to j less than i j plus plus. If x j is greater than x j plus 1, that means what? If x j is greater than x j plus 1. So, let us again go back to this. j is starting from 0 and I am comparing this value 50 with the value 2 with j plus 1. This is j plus 1. If x j is greater than x j plus 1, what would I do? I will swap. Let us go to here. If x j is greater than x j plus 1, I am swapping x j and x j plus 1. I will come to the swap function later. I am assuming that the swap is working correctly. That means it is swapping them. So, what is happening? So, this loop will go on j equal to 0, then j will be 1 and that way it will go on. So, let us see. Again. So, next when I swap it, it becomes 2 and 50. Now, I have got other values. Now, j is being incremented. So, now this is becoming j and this is becoming j plus 1. In that way, this swapping will be done. Suppose, this is 70. So, there will be no swap. So, let us see here. If this condition does not hold, swap is not taking place. I am going back to this loop. So, now 70 remains here. And then suppose the next one. So, now j changes and j plus 1 is pointing here. Now, there will be a swap here. So, this is 12. Say, 12 and 70 will be swapped. So, 250, 12, 70. In this way, I will go on up to this point. And next. So, ultimately in this iteration, ultimately I will have this heaviest element. So, 70 is the heaviest element coming over here. Then I will be decremented and I will come here. And then for this zone again, I will do the same thing as I did till now. Exactly that is being done here. So, I will be doing this and then I will increment, I will decrement n a little bit and I will go on doing this. I will be then looping doing the same loop again for one level less. I mean, the last element is already having the heaviest element. So, I will do it among the remaining part. So, this part, this part is already covered. So, I have decremented it. So, I will be now playing in this zone. And once that is done, this part will also be covered. I will be playing in this zone. I will be playing in this zone. And in every zone, so once every time I am deciding on the zone, n, n minus 1, n minus 2 like that it is going on. And every time I am doing this loop for each of the pair wise element comparison and thereby I am pushing the heaviest element at the bottom. That is the code for bubble shot. However, this swap keeps, I have not yet explained this swap. Earlier we have seen that if we do swap in any arbitrary way, for example, if I want to swap two variables, say I write swap in T in B. Let me do it here. Let me do it here. If I do it like this in T, sorry. If I just do swap in T in B and inside, I use another variable temp. Then temp gets A, I sorry, B gets A and A gets sorry, sorry sorry sorry. A is stored here, A gets B and then temp has been remembered there. So, B gets temp. And so this was my function return. So, here suppose A was when it came, it was called with x and y. So, main program called swap with x and y and x was 5, y was 7. So, x was a location here, 5 and y was a location 7. Now, when it came here, A was a local location and I know that the functions are called by value. So, 5 was copied in A and 7 was copied in B. 7 was copied in B and then by this temp became 5, B became 5 and A became, very 7. B was stored in A, sorry, this was stored in this, this became 7 and this became 5. That is how it was done. So, 7, A was 5. So, temp was 5, 7 went over here to A and here 5 was copied again here. This was fine. So, the swapping was done by A by B and then when I returned, no changes reflected in x and y. That was the problem. So, we will now see how the swap function can be implemented. But and again another point is, here I have just done returned. I and a function can return only one value. I could not return A and B to the main function. So, how can the thing be managed? So, that after the swapping, the result is reflected back in the main function. We will see that in the next lecture.