 Welcome, in the last lecture we had looked at the nested Eiffel structure. Today we will continue with that discussion. So, here is an example that uses the nested Eiffel structure. Here you can see again let us come to the programming fundamentals in C. We have got just for revision. We start with an include stdi.h and then we have got the main function. Inside the main function we declare three variables A, B and C and probably you might have guessed now that we are again trying to find out our I mean the maximum of the three integers A, B and C. So, what are we doing next? We are first reading the three numbers from the keyboard. scanf percentage d, percentage d, percentage d, then A, B and C preceded with an ampere sand. And you know why this ampere sand is used? That is the address of the location A, B and C. Now comes the main logic. Here if A is greater than equal to B, A is 25, B is 20. So, if A is greater than equal to B, then I check whether C A is greater than C. So, this is passed then I check this. So, if A is greater than B, then I proceed to do if A is greater than equal to C. If that is also true, then we print the largest number is A. Otherwise, what we do not know as yet. So, if A is greater than B, A is 25, B is 20, C is 15. In that case, A is greater. But suppose C is 30, then what happens? A is greater than B true. Then I come and compare A is greater than C, this part. No, false. Therefore, this L is with respect to this nearest if that we learnt in the earlier lecture. So, if this fails, then we print the largest number is C, because A was greater than B, but A is not greater than C. Therefore, C must be the largest. Now, if A is not greater than B, suppose A is 20 and B is 25. Then A greater than B, this fails, then I am not entering this block at all. I am straight way going to this else. Then I am checking A is not greater than B, but therefore, B must be greater than or equal to A or not even equal to B must be greater than A. Then I check if B is greater than C. Suppose, B is greater than C, then the largest number is B. Otherwise, if that is not so, B is not greater than C. Suppose C was 30, then this else will come, because this if will fail. Therefore, I will print again the largest number is C. So, I suggest you to work it out yourself. And I can also write the same thing if you consider that this, if A is greater than B, then if A is greater than equal to C. Tell me, if I write it in this way, if A is greater than equal to C and and that means, and A is sorry here, I write A is greater than equal to B and A is greater than equal to C, print F this line. Largest is E, else print F largest is C. So, do you think that these two are equivalent? These two nested F's and this logical operator. Now, here I should have put a parenthesis here. Please note, I need a parenthesis here. It is better that if I put it, it becomes much clearer. Are these two equivalent? If you just think of while, you will find yes, they are equivalent, because I am computing this and then I am computing this. If this any one of this is false, I will not be executing this statement. So, this is an example of nested F. We can have many such examples. Let me give you one example. Let us work out right now. Suppose, I am trying to see if a figure is a triangle or a square, order rectangle, or a 4 sided figure, whether it is a triangular figure or a quadrilateral figure. And if it is a triangular figure, then I want to see whether it is isosceles, that means, two sides are equal or it is not isosceles. Suppose, that is what I want to do. So, how can I proceed to do that? Why would I write the logic? Let me just only write the relevant part. I have done some the declarations are here. And then I have done scan F, percentage the number of sides. Number of sides is a variable. And then I also, then what I can do? I check if it is a number of sides is equal to 3, then I will be doing something. Because, in that case it will be a triangle. Then what do I do? I then read that is scan F. The three sides of the triangle, percentage D and suppose all the sides are integer has got all the sides have integer values. Five, six, five something of that sort. That is why I am putting percentage D. Then I am reading the three sides and B and C. Same equal to. If A is same as B or you remember this is the logical or or A is the same equal to C or B is equal to C. Then what can I say print F? EAT is ISO cellless. Backslash end as our common practices. If any of these conditions are true, either this is equal to this or this is equal to this or this is equal to this. Then it is ISO cellless. Else, I will print I am writing in brief. Not ISO cellless. You can write in a much better way. Remember this double course. We complete this. Now, that is the complete this. Now, this is the if part. If the number of sides is three. If the number of sides is not three, then I do not do anything. I will come at this point because this if you will fail, I will come at this point. I can say here. Can I write here print F? Not a triangle. Can I do this? Just think because here I have checked that the number of sides is three. If it is number of sides is three, I will do this and print. Otherwise, I write it here. Is it all right? If you look at it, you will see that there is a problem here. If the number of sides is three and then it takes whether it is ISO cellless or not, and then it comes out and again prints is not a triangle. I do not want that. So, what should I do? How can I avoid this problem? Here, you must have guessed now. Here, I have to put an else that goes with this if. And then if this is not true, then only this will be executed. Otherwise, some point down the line here will be executed. Another thing that I would like to mention in this case. Look at the use of this parenthesis. Why was this parenthesis required? Because I had more than one statements for this if condition. If this condition is true, then there are more than one statements. Now, here is a puzzle. How many statements are there? Inside this block, how many statements are there? One, two, three, four. Let us see. Here is one statement, scan F. So, one. And then this if statement, you see, goes up to this. So, that is one statement, but here I am using, I said that E fells is a structure. So, this entire thing is a statement. So, actually I have got two statements. Since I have got more than one statement, I had to put this braces. Now, suppose of course, then the program will not work here. Suppose, I had not written this statement. This statement was not there. This statement was not there. In that case, I could have done away with this braces. Because then, within this if statement, there is one statement only. This brace was not essential. So, you could see this. And you can practice and in the assignment, we will also give few programs that you have to do using this sort of if else type of structure. So, now, here is the example that we did. Now, there is a problem here. There is a danger, I would rather say. You have seen earlier, when I was writing, I was writing if if A is equal to B. Then, I was doing something. Now, this is very important that is a common point of source of common source of error that often because we have learnt to say equal to like this, it will we can write in this way. Now, the problem is if I write it in this way, when a compiler looks at this, what will it assume? It will see that is an if. Often, you will not find that it will cause an error. Because what the compiler will think is, well, what is the meaning of this? A, this means A is assigned the value of B. So, it will try to successfully, it will try to transfer, copy the value of B to A. And, this operation will be executed successfully. Now, if the expression is computed successfully, what does it return? If you recall, it returns of 1 and 1 means 2. That means, this condition will evaluate to 2. I once again repeat. Now, we can use any expression that produces a value in the control structure. Now, if it be a non-zero value, then it is true and 0 value is false. So, if I write if a plus b plus c, printf a else printf b, what will happen? A plus b plus c is, if they will be just be added, but there will be no assignment. Suppose, I make it more meaningful. Suppose, I make it z, z assigned, I make it this. I write z assigned a plus b plus c. Then, this, there is a problem here, because there is no semicolon here. So, this will be, suppose I do this. Now, this will be computed, and this assignment will be done successfully. So, anything that is done successfully, will return this will be equivalent to f 1. If 1 means it is true and so, what will be printed? Printf a will be executed, this will be printed. Now, similarly, I can say, let us see, I just write if there and something. What does this mean? Semicolon, nothing before this, we call it a null statement. That means, I have not said anything meaningful, but it is still a statement, remaining silent is sometimes a set statement. Now, this means that this is always true, this will always be true. So, this is equivalent to f 1. This, that means always you do this statement, whatever is here, you do it always. So, this is a interesting thing in C. However, sometimes you know, it varies with the compilers also. Some compilers take care of such situations and may give you a warning. Some very few compilers can also give an error. Now, let us look at this example. Sorry, this example, if pay code is equal to 4, what does this mean? This means if the pay code is 4, this is a logical equality. If this is true, then you will print, you will get a bonus. Now, instead of, so, I want to do like this, this means that I am coming here, I am checking pay code in non-sea language is pay code 4. Yes, I do something, no, I do something else. But, if I had written it in this way, what would it mean? If pay code assigned 4, now pay code, being a, suppose pay code is an integer type of variable, then this can be assigned the value 4 successfully. And anything that is done successfully, this will result in if done successfully, one do this. That means, it will be successfully executed, it is not doing what you are intending. So, sometimes we are saved by the compiler, when it points out that ok, note here, here is something, some syntax error that you are committing. But, there are situations when we unintentionally can do such mistakes, which will go unnoticed by the compiler and the result that we will be getting may not be what we desire. So, this is a very critical point, you should keep it in mind. For all programming languages, you will find there are such nuances, some specialties which you will have to keep in mind. We are just mentioning here the ones for C. But, if I had done it in this way, it will be ok. So, generalization of expression evaluation in C is, assignment operator is also a part of expression that we know. Now, let us see here, i is assigned 3. So, typically some compilers, what they do? Till now, I was saying that if an instruction is executed correctly, it will return a 1. But, generally speaking, it will return the value that has been assigned. So, typically, here i assigned 3 will return the value 3 after assigning it to it. But, for us, when we do, what we are bothered about if the condition, this part is sorry, I would rather now say, this part is 0 or non-zero. If it is non-zero, then it is true. I was saying, if 1, then it is true, if 3, that is also true. The only false it will come if it is 0. So, this returns the value 3 after assigning it to i. And then, so, let us look at this code. I give you 1 minute, they look at this code and think, what this code will do, what will be the result of this? Look at this code carefully, then we will analyze it. You can see that here, we have initialized a variable i to 4 and j has just been declared, but not initialized. So, here the picture is something like this, i has been initialized to 4 and j can have something, but I have not initialized it. Now, here if this statement, what will this statement do? First, the condition part, that means, within the bracket, this part will be evaluated and what will happen? What is this? i is being assigned 3, so this will be 3. And the value that will be returned by this execution of this statement will be 3, then j will be 0, then j will be 0. Else j equal to 1, that will never come because this will be done successfully, this will never come. So, the output will be, output I have not given in the print F here, but this j value of j will be 0. So, what will be the value of j? Whatever be the value of i, j will be 0. Now, instead if I had written it correctly, correctly means if my intention was that if i is equal to 3, j should be 0, otherwise j should be 1, then I should have written it in this way. So, that if i is equal to 3, then j will be 0, otherwise j will be 1. So, this is a very important point that you have to keep in mind and gradually with practice, it will be okay with this. So, here, so more about expression. Now, here we introduce two new expressions. Typically, when we write, suppose, suppose there is a variable i. And the variable i has got a value 5. Now, if I want to implement the value 5, if I want to implement the value of i, I will write i assigned i plus 1. But, c allows us or gives us one special increment and another special decrement operation. So, this thing I could have written also as instead of this part, I could have simply written i plus plus. i plus plus means i is assigned i plus 1 and this one will be i minus minus. So, this is known as the decrement operator, this is known as the increment operator. Sometimes, it becomes handy to write it in this way, but if you are new in programming, I personally would discourage you because you should not get ground in the special features of a language initially, okay. Better you go by the standard features because these features have got some more complications which will come to later. But, you may know that this is an increment operator which is equivalent to this and this is a decrement operator which is equivalent to this. All right. So, this is I can write it in two ways, sorry i plus plus or plus plus i. The reason why I discourage you to get into the usage of this initially will be evident soon. If I write i plus plus, it means this is called post operation, this means pre operation or prefix operation, okay. We will soon see what that means. So, I can have plus plus i or minus minus i, that is a prefix operation, all right. And, post-fix operation is i plus plus and i minus minus. Now, plus plus i means first increment or decrement depending on whether it is plus or minus and then use it in the evaluation, for example. Suppose, I have got the value i here as 5 and I write x as sin plus plus i plus z or let me make it a constant. Let us say z is 5. Then, what will happen? This is what? This is a pre increment, i first increment, i and then do the operation. Now, this has got a precedence of course, over this. So, first i will be i will be incremented. So, i will be 6 and z was 5. So, the result will be z x will be 11. But, if I had done written it x assigned i plus plus plus z, here I will here also I will first increment this 6 and then z will be added to that. But, there are situations where we will do it after computation of the whole thing. I think I will need a separate session for you to explain this clearly. We will do that in a more careful manner. Let us look at this. Here, int t is an integer and the value of m is 1. T assigned plus plus m, that means, what m was 1 and m is first incremented and assigned to t. Therefore, t will be 2. Again, if we do it like this here, then yes, here it makes the difference very clear. I am sorry. T, here you see m was 1 and what I have done? I have put the assignment of, I have done a post operation post post fix operation. That means, first I will be doing the assignment, first I will be doing the assignment and then I will increment. So, what will happen? m was 1 here. So, the first this 1 will go over here. So, t will become 1. Then, before I complete this operation, I increment m. So, m becomes 2. So, we will see more examples of such things in the subsequent lectures.