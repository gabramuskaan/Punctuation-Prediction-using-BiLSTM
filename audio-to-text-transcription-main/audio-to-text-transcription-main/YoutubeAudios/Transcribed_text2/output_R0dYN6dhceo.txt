 So, we were discussing about bubble sort and we had looked at some notion of pointers. So, we have now got the preliminary idea about pointers. Now, let us on this segment we have seen this part of the code, this part of the code we have seen, this part we have seen, this side is the bubble sort function. On this side we have got a function which is swapping two variables. I want to swap x and y. So, this swap function is taking x and y. So, we have seen earlier that in the normal case if we swap in a function suppose I have got a void swap x, y then we had shown and we used another variable int term. This was also int, this was also int. So, we had seen that whatever swapping I am doing here that is not being reflected in the main function that we saw. Now, what we are doing here let us see here I am writing void swap instead of writing x and y. I am writing int star x comma int star sorry this should be space here although not necessary but int star y that means what what I am passing here is my swap function. Here is my swap function and it has got two input parameters. A function has got always one output there can be a number of input parameters. Earlier it was x and y. So, some variables x and y were having the actual parameters being copied into them. But now I have not used x and y instead I am using pointer to x and pointer to y. So, what is being sent here now is let me do it a fresh is faster void swap in star x in star y and that means now I am in my main function here is my main function or the calling function not necessarily the main function. In this case it was called from bubble sort. So, the calling function I should not say main it should the calling function the calling function has got two variables x and y. Now, when I am calling this function void swap it is here void swap it is already written here. So, I am actually having the function here the swap function. I am not passing the values of x and y. Let me to be more natural let us make this actual parameters are a and b a and b. So, somehow I am calling here swap in my calling function I am calling swap a comma b. If I had done this then this value of a and the value of b would have been copied there. But instead what I am doing now I will not write this instead I will write in star a and in star b. So, I can I can say here I am passing star a comma star b that means what I am passing the pointers let us I will do it again let us look at this. Say here I am passing the address. So, again let me do it in a nicer way. So, here is the calling function and the calling function has got the variables a and b and inside the calling function I am saying swap what should I pass on. I will instead of saying a and b I am saying and a comma and b and you know what is and a and b and a means the address of a and b means address of b. So, I am actually passing the addresses of a and b. So, the address of a was say 1000 and this was maybe 1500 to addresses. Now, here is my called function void swap in now a and b have been declared in star x comma in star y. So, what is happening whatever I am doing here what is being passed here and a is being passed and here and b is being passed that means this address and this address are being passed 1500 are being passed and also I know here that what I am getting are the pointers to the variables that are to be swapped it was not int x or int y. Let us go back to this once again. So, here you see I am calling x j and x j plus 1 in my bubble sort algorithm in my bubble sort algorithm I had the array and j was here and j plus 1 was here this was already failed something and I am comparing. So, here is my I soil working this zone and I am looking at two elements j and j plus 1 and I want to swap them. So, what I am doing is I am passing on the address of this here. So, suppose this address was 1000 and this address was 1000 2. So, this is being passed here. So, this is 1000 and this is 1000 2. Now, what is happening here? 10 is a local variable see 10 is not a pointer 10 is a local variable. Suppose here the point was this was 50 and this was 2. So, 10 is getting the content of x. So, 1000s content 1000s content was 50 content of the pointer content of x. So, the 50 is being copied here and then what is happening? Content of y is coming to content of x. So, content of y is coming to content of x. So, this is becoming 2. This is being swapped and it is becoming 2 and 10 is coming as the content of y. So, this is becoming 50. So, what is happening? All the changes were reflected here in the main body of the data. So, that is how we could really reflect the change on to the calling function. So, stated in another way it would be like this. Let us say I have got a data here and here is my calling function. And here is my called function. Now, there is some variable that is being used by the calling function say a. That means, this a is somewhere here. This a has been referred here. So, let me it is not proper to show it here again. So, the calling function is using the variable A somewhere here. So, when this variable is being used as a parameter to this called function, instead of sending the variable say some other function I call and in that I pass on the address of that variable A. So, that address whatever this address is this is 1000 that is being passed on to this called function. So, the called function on the other hand knows that its input parameter is say called function is F is int, what I am getting is in star x. That means, what I am accepting? That is called function is accepting is nothing, but a pointer to an integer variable. Now, so the pointer to the integer variable 1000 comes up and here suppose it does something with the content. Now, here when I take this say star x that means, x is a pointer x is a pointer to an integer. And when I take star x asterisk x that means, is a content of this and suppose I do it star x plus 1. That means, this the content of this address same address x was 1000 and the content of that 1000 is being added. So, here it was 50. So, that is being added where it is being added here. So, this is becoming changing to 51. So, this if you recall we had talked about two things when the functions are called we said that usually C always calls by value except for the case of areas. But here is an example where I can also say this has been called by value of the pointer. So, in this case it is an example call by value of the pointer. That means, what I have copied is only the pointer. Therefore, the change that is being reflected is being reflected in the main program. So, in that way this also call by reference. So, in that way we can reflect the change of the function. So, if you ever phase the crisis that well I am writing a function, but I know a function can only return one value, but I have got multiple values to return. This is a nice way in which you can do it. So, this is this we have a new concept we have learnt the use of pointers, the notion of pointers and how it can be used in the context of just learning another language that is the bubble sort. So, the bubble sort once again we revise let us go to the next one and we will come back. So, the main program is taking a main function is reading an array. This array is being read x i is an integer i is an integer. Now, for i 0 to less than 12 they have a 12 elements here print the array then it is calling bubble sort. Sorry when it is calling bubble sort it is calling bubble sort with the array being passed and the size of the array being passed here. Now, we go to bubble sort that means I go to the earlier slide. So, what I had seen earlier. So, there we go and call the bubble sort and the bubble sort in turn calls the swap ultimately the swapping is done inside the bubble sort and then we print the ultimate data. So, what will be the time complexity? We have seen the time complexity in terms of the big o notation at times. So, what is the worst case? If you think of let us once again recapitulate think of the algorithm that for something like this. First I had this size n. So, initially the number of comparisons were one then worst case two. I first compare between these two then I compare between these two then I compare between these two. Now, depending on the comparison I may or may not exchange all right may not swap but I have to do n minus 1 comparisons. So, first I do n minus 1 comparisons and if the along with that I have done the swapping. So, the first position is now filled up with the largest element. Then again I have to start from here compare again twice, thrice in that way I go on comparing the second time and by now this number of comparisons is n minus 2. So, the second one will also be filled up with the heaviest element and in that way I will go on ultimately last time is 1. So, the overall if I add them the number of comparisons is this and that is of the order of n square because it breaks down to n square minus n etcetera. What is the best case? What will be the best case? Best case is if you do not have to do any swap it is already sorted but still you do not know that it is sorted. You will have to compare them anyway and therefore the best case will be the same. Best case will be the same. Can you make the best case with n minus 1 comparisons only that we can think of later but now with this next let us move to. So, all these searching and sorting we are doing was using arrays. Now just word of caution about some common pitfalls with arrays in C is that often we can exceed the array bound without really noting of that. For example, array size has been declared to be 10 that means my indices are from 0 to 9. So, if I write a for loop like this then it will and I try to initialize it. So, it will initialize to 1 0 then 1 then 2 then 3 till it is less than equal to 10. So, the 10th element is here that will also be put to 0 but that may be destroying some other memory location. Therefore, that check is not there and C does not support array declarations with very variable expressions. So, quickly if we summarize what we learnt here is let us we are not talking about this in this course but what we have learnt here is searching we have seen. And we have seen two very efficient methods of searching. One is the linear linear search is simple another better method is binary search but binary search is effective when the array is already sorted. We have learnt about how to sort an array we have particularly looked at two sorting algorithms. One is selection sort another is the bubble sort and while discussing about bubble sort we have also looked at very interesting way of communicating between a function and a call call or function and the call function. When I have to communicate or pass on return more than one variable to the calling function. There we are using the pointers so we introduce the concept of pointers pointers and nothing but the addresses of the variables. So, instead of passing on the value I am passing on the address and whatever I am doing I am doing on the address. So, that is another important thing that we have covered in this lecture. Next I think we will go to some other concepts of arrays itself. Now, just to mention that there are two different two more there are I mean here we have seen that the complexity of these algorithms are of order of n square. Both for selection sort and for bubble sort but can we have it better. We have got two very nice sorting algorithms. One is known as the quick sort another is known as the merge sort quick sort and merge sort which reduces the complexity of sorting. And a very popular algorithms but we are not discussing it in this course for those of you interested can learn it later. Next we will be moving in the next lecture to discuss about how arrays can handle I mean strings can be handled as arrays. That is that we will do in a separate lecture. So, up to this for now and we will continue in the next lecture.