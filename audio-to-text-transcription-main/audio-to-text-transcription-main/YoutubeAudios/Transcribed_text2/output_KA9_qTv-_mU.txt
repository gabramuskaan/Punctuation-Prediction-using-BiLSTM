 In the earlier lectures, we have looked at functions and we will still be looking at functions. We have also looked at the library functions and just to recapitulate that whenever we are using some library functions in our program, then we have to some mathematical library functions, then we have to ashrineclude math.h. And while we link it, while we compile it, we will also have to link it with the math library with the option minus lm as you have seen. Now today, since now we have got an idea of what functions are, let us have a relook at our old friends, Scanef and Printf, which we were using a number of times. Now Scanef and Printf are nothing but functions. These are also some library functions and those are included whenever we use include stti.h. Now you see Scanef and Printf being functions, when we enter data, let us look at this structure. We write Scanef followed by some parameters. We have also seen that a function is a function is nothing but something like f, say function name followed by some parameters. Here this Scanef is that function name and the parameters are the control string. That means say for Scanef you have got something like percentage d and then x. This is the control string and these are the arguments. Both of these are arguments to the function Scanef. Scanef is nothing but a function. Whenever in my program, suppose I am writing a program and here I use Scanef with some parameters like this, then it is nothing but a call to a system function which actually does the task of reading the data from the input device. So a control string refers to typically the data types of the arguments. They have seen percentage d, percentage f etcetera and the arguments are pointers to data items in memory. These arguments in Scanef are what are the typical arguments in Scanef? They are say whenever I use Scanef say percentage d, then and d or something like that. So this AND is nothing but an address of the variable A. So in my memory wherever the variable A is, the variable A, the compiler has allocated this memory location for the variable A and I am passing the address of that. So that means it is a pointer pointing to some address or a pointer that is pointing to this particular location in the case of Scanef. So that is why it is said that the arguments, these arguments are one or two again are representing nothing but pointers to data items in the memory. So the typical example is say percentage d, percentage f, percentage c which is nothing but the control string it is designating that AND A is an integer and AND is a pointer to A and average is a floating point number and AND average is a pointer to average. And type is a character type variable and AND type is why is type a character type variable because I have put in here and C since I have put in here and C that tells me that this type is a character type variable and AND type and type is a pointer to the variable type. The control string consists of individual groups of characters with one character group for each input data item. So this is one character group for this set item. So percentage we have seen that percentage sign means it is a conversion character. Now commonly used conversion characters we have already seen some of them, these are known to us percentage d is for decimal or integers, percentage f of floating point numbers, percentage c for single character, percentage s is a string whenever I am reading something variable as a string we have discussed that. In that case we are reading that string using percentage s and that is a string is always terminated by null character. Similarly percentage x denotes that the number that I am reading is a hexadecimal character hexadecimal means decimal is with a base 10 that means 0 to 9 are my elements. So all the numbers I am describing using 0 to 9 that is my alphabet set whereas in the case of hexadecimal the base is 16 and so a base being 16 I have got 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 these 10 numbers followed by a for the base 10. So this is the base 10. So this is the for 10 b for 11 c 12 d 13 e 14 and f 15. So up to that 0 to 15 I can have so in a 16 when I work with a base 16 and that is null and as hexadecimal. So you can just establishing a similarity analogy with our binary number system that we have seen we can have say a number a b. Now a b is a string. So the position string is a position weights are first position is 16 to the power 0 second position is 16 to the power can have say a number A B. Now, A B is a string. So, the position string a position weights are first position is 16 to the power 0, second position is 16 to the power 1, third position is 16 to the power 2 like that. In the case of binary we had the first position weight was 2 to the power 0, 2 to the power 1, 2 to the power 2 like that. Now, and each of these positions can be filled up in the case of binary by 0 and 1, but here in the case of hexadecimal it can be filled up with any of the 0 to A, 0 to F. So, A B when I say that means B is what in decimal B is 11 12. So, 12 times what is the weight of this position 16 to the power 0 plus A is 11. Sorry, sorry, sorry, sorry, I am sorry, this is 10, 10, sorry, let me correct that A is 10 and B is 11. So, it is 11 into 16 to the power 0 and 10 times 16 to the power 1. So, how much is that coming to 160 plus 11. So, that is the number 171 now, if I had to represent 171 in binary I would have required much more number of bits. And since it is hexadecimal another, so here we using hexadecimal I am being able to do that using two hexadecimal bits which we can call exits, but let us see A B, A being 10 and B being 11 in binary what would that B B is 11 that means 8 to 1 this is 11 and 10 is 8 to that is all. So, I would have required 4 bits for representing 171 which I am representing using two hexates. So, that is a hexadecimal integer. So, if I print something in hex in this format then it will be printed like 171 will be printed as A B, otherwise it will be printed as in the binary number or in the decimal number if I do it with percentage it will be printed like this. So, it was a brief introduction to hexadecimal numbers, but that you can read up yourself. So, let us proceed. We can also specify the maximum field width of a data item. Now, this is something I had purposefully evaded till now just to not to make the things complicated I want that you first get accustomed to the normal features of C. Now, but now we are now I think you have you are in a position where you can write programs here I am introducing the notion of field width. A data will be printed within a width. So, many positions will be given to that number data item the number indicating the field width before the conversion character. For example, let us make it clear. For example, percentage 3 D percentage 5 D for A and B that means, A will be expected to be of 3 positions say it is 3 D decimal 171 whereas, B will be 5 D. So, there will be 5 positions for this 1 2 3 4 5. So, may be 5 127 be 5D, so there will be 5 positions for this. So, maybe 52732. Now, if I want to print 171 or D in 171 using the format 5D, then what should I print? I should print, sorry, I should provide the data for the 5 fields, I should put it blank blank or 00, then 171, assuming it is right justified. So, this is the width, this is the width that we are talking about, we can specify how many, what is the when I am reading, what is the format of the data, how many width, how many positions it is taking as the data. So, say for example, if I have 171, 532, then 7, then if I read it, the first data field is this, I type through the keyboard and if it is in percentage 3D, it will be fine. So, I will read that. Again, now coming to writing, now this printf is also a system function, just like scanf, printf is also a system function and here also since you know already how do you write printf, I write printf using a control string within the double code and then followed by this number of arguments. So, the same thing will hold here, control string refers to the string containing formatting information and data types of the arguments to be output. So, now here, while printing the arg1, arg2, these are the representing the individual data items. In the case of scanf, they were pointers to their data items. Here, they are individual data items that I have told you earlier, that is why we use m pairs and a, m pairs and b in this case of scanf, but in the case of printf, we just write a, b because this a, b are directly referring to the variables, the data items. The conversion characters are the same as scanf. So, let us look at some examples. Printf, the average of a and b is a, bg and that a, bg is percentage f, you can see that, so a, bg is a float. Now, I could have also done this, so this is nothing, but just the control string. Here, you see, I have said that 3d, 3d, 5d. So, a will be printed, so when will be printed, a will be printed. There is no new line here, you can see. So, a, b and a times b plus 2 will be printed side by side. So, a will be printed on 3 fields, like say, 1, 7, 1, b will be printed on the same. So, this is the value of printed on 3, next 3, there is no space given. So, this will be 632 and the expression here, a times b plus 2 will have 5 spaces, 5 positions given. Now, obviously, if my data for result for a was 1, 7, 1, 2, then only this much will be printed and the rest will be left out. So, here you see, for the percentage f. Now, for this, I think it is not very difficult to understand. You can read them in any textbook. It is clearly discussed in most of the textbook. So, I recommend you to go through these formats and as you practice, you will keep that in order. But, just to tell you this, sub-floating point number, we will have 2 parts. One is the integer part and other is the decimal part. So, suppose here, when I say 7.2 f, x is a floating point number, which is being printed in the format 7.2 f. So, this entire width is 7 positions and the 2 positions here are kept for the decimal. So, these 2 are kept for the decimal and we imagine we will have a decimal point here and the rest 5 will be 5 will be for the integer part. For y, what will happen? For y, the total field is 5 out of which, so total field is 5 out of which only 1 position is kept after the fraction. So, here I assume this point and so there are 4 positions to represent an integer and 1 position to represent a fraction. So, if my result was 101.52 in this field, in this format, if I print that, then I will get 0101 or this 0 can be may not be printed. So, 101.5 because I did not have the space for this. Many more options are available, you can read from the book and we will do this later. Now, coming to a very important concept, that is function prototypes. This is possibly a new name that you are getting, what are this prototypes? Now, we are going to write functions and those functions, one of the functions which must be there is the main function. Typically, people write first the main function and then the first the functions and then the main function, but you are free not to do that also. So, usually a function is defined before it is called. So, typically what we do is when our main our program starts, so we start the program starts from here, we define if we write a function with some parameters here and the body of the function is here and then we write say main and inside main I call f 1 this assigned to some variable x like that. So, this is the typically some what we do after I did this include stdi iu dot h, I started with the function first that is one option. Now, but always that is not done. So, main in that case if I define the functions first the functions that I I am going to use I have thought about that I have designed them. So, first I write those functions and after that I write the main function in that case the main is the last function in the program. So, in that case the compiler, so I have got my program here entire program here and I have defined the function f 1 here I have defined function f 2 here and when I write main here and in main I refer to f 1 f 2 whichever whenever is this required. Now, let us look at the compiler think of yourself to be the compiler. Now, if you had started compiling the main first and you would have come to f 1 and f 2 then you would wonder what is that f 1 and f 2 no variables are defined right you would have taken just like if you had written x in the main some function f 1 some function like f 1 a b right. Then, this f 1 is not recognized I mean you do not know about that here, but if you write it before the compiler will actually start looking from the beginning of the page or beginning of the program he will understand a function has been defined here I understand that function. So, I know that and I know what this function does it compiles and f 2 also. So, when it comes to in this direction when it comes to the main and finds f 1 and f 2 it already knows that. So, there is no problem. So, easy for the compiler to identify the functions when it scans through the file this is the file right the whole thing is the file. However, always that is not done many programmers prefer a top down approach that I will first define main and then I will put the functions, but then what will happen to the compiler the compiler if it starts with main it is starting from the beginning and if it encounters f 1 or f 2 in the body of the main function then it will get confused what is it just like if I had got a variable x being used and it is not defined there been error because I do not know what this x is what type it is right. So, I have to declared that beforehand. Similarly, for functions there must be some way to tell the compiler that is the function and for that function pro two types are used function pro types are used. Let us look at this needed if the function comes later. So, function pro types let us look at this needed if the function comes later. So, function pro types let us look at are usually written at the beginning of the program ahead of any other functions including main say for example, this is a prototype. So, this is a prototype int g c d int a int b. So, a and b are the parameters and g c d is a function of return type int. So, I know just by this prototype by this I know the basic parameters are the whatever is the body whatever is the body of g c d I know its interface I know its input output what is its input output there will be some a coming some parameter there two parameters internally they are named as a and b. I also know that this is an integer and this is also an integer and I know that its name is g c d and I also know that its output is an integer. Whatever is in between I am not bothered about right now this much I know. So, I will expect whenever g c d will come I will allocate two integer space for that and one return facility should be there. Similarly, let us look at the second one give 7 int number. So, the prototype tells that it is a function its name is d 7 you can guess d 7 means is testing the divisibility by 7 and there is one integer that being fed and that integers name is number and void is a type that means it is not returning anything maybe it is printing something from here it just checks takes a number it sees whether it is divisible by 7 and prints it here divisible by 7 not divisible by 7 whatever you know how to find divisibility by 7. So, you take the number and find the mod of that with 7 and if this is equal to 0 then divisible by 7 otherwise not. So, that is in the body of the function and here we just do the printing. So, I am not returning anything to the calling function that is why this is known as void void is a valid type. Note the semicolon now here this is very important whenever for hash include a stdi.io.hti did not give a semicolon but whenever I am declaring a function a function prototype I have to give a semicolon just as I had given a semicolon when I declared something like int x semicolon. Similarly, here this semicolon is very important it is just like a declaration so the argument names can be different but it is you I mean it is a good practice to use the same names in the function now. So, what is being said here is that the argument although I am using here showing that a and b but when I am actually writing the function later say sorry when I am writing the function later when I write later on int gcd I can make it is a sorry I can write int gcd int x comma int y that is also possible because my prototype just said that two integer places now actually I can change the name change the name of the place but that is not that important I mean that is not I mean usually it is better if we can keep both of them. So, here is a function of int gcd int y and then it is a function of int x comma int y that is also possible because my prototype just say that two integer places now actually I can change the name change the name of the place but that is not that important I mean that is not I mean usually it is better if we can so here is a function prototype example I will continue with this in the next lecture I will discuss this and we will move to some other important important feature of function like parameter passing in the next lecture onwards.