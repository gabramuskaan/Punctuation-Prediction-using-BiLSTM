 So, we were discussing about sorting and in particular we were discussing about one sorting technique which is a selection sort. So, in selection sort what do we do? We have got an array and of size size. So, that means, the index is 0 to size minus 1. So, what we do? We some parts we assume that some parts are sorted. So, first thing that we do is find the smallest element. So, if from 0 to k is sorted already in the order then my job is to sort from k to size minus 1. So, what we do? The step is that we find the smallest element minimum value in the list x from k to size minus 1. I find the minimum value and then swap that minimum value with the kth position. That means, this position with this position I carry out here in this position I bring the minimum value and this goes on and then increase k. k will be increased to the next position and in this way I will be going on. So, the sub problem is to find the minimum element. So, if I go here as we are seen in the I mean in this array my task is to find the minimum position. So, where is say this part this part is already sorted I am sitting here and this is my kth position right this is my kth position and I want to find the minimum where is the minimum value where is the minimum value where. So, for that this is the function find the minimum location in the array x and starting from this location k up to the location size minus 1. So, I need to need no size I need to need need to know k that is how we are giving the parameters as we had explained in functions. So, at every point you look at how the functions are written that will help you in revising this. Now, the body of the function. So, x pass x pass will be the smallest element found so far. So, initially I am making pause to be k. So, x pass is this point. Now, from k plus 1 to up to size I go on checking whether this x j this position is less than this position. So, I find out in this way I here I find the minimum right just see if you can understand the code. I am find the minimum in between k plus 1 to size minus 1 in between this I am trying to find the minimum. So, whenever I get the minimum I will be returning that particular position. So, this is the position that I will be returning this position. So, what would be my full algorithm therefore, so I have got a function I have got this function mean log which will return me the minimum location. Now, so it will yield me the location of the smallest element. So, now you see the selection sort main sorting function will be this it takes the array and the size. So, this is my array x and this is the size. So, I will have to work between 0 to size minus 1. I have got two intermediate variables k and m for k equal to 0 to k size minus 1 what am I doing first I am starting with this this element that is k equal to 0 and what am I doing I am finding out from k in the array x up to size I am finding the minimum location. So, suppose here is the minimum then I am what am I doing here temp is going to a k. So, this k is going to temp and this a k is being written by a m this is the minimum is coming here and then this temp is going here. So, here what am I doing is I am swapping x my array was internally I called the here there is a small mistake I can find it should be x k all these would be x. Because, I am dealing with x so x k will get x minimum m because and vice versa and this y. So, what is happening here let us see suppose my array was something like this 50, 20, 70, 10, 100. So, I am first this is my k equal to 1 I want to bring the minimum at this position. So, what I do I from here I start searching for the minimum I find 10 to be the minimum then I swap here in this piece of code I swap I bring 10 here and 20, 70 remains and 50 I take here and then what do I do k is incremented. So, now k is here now I find mean lock if what is the minimum here compare less than this or not there is none so fine next. So, this remains next I increment this so this is also in position this is in position because it need not be exchanged. Next my k is increased here at this step k plus plus it has been increased here I find the minimum in this area I find this to be the minimum. So, what is happening 10 was in place 20 was in place I swap 50 and 70 here. So, 50 comes here I find the minimum 70 remains here 100 remains here now I change my k and see if there is any minimum left here the mean location is not returning me anything. So, therefore, I get this to be my sorted array. So, this is what so you can see that so in this way we can sorry here is an example now you see here the example you see here I start with this so 3 is the minimum I can see here 12 minus 5 6 etcetera I can see minus 17 is the minimum. So, I find out minus 17 here I swap that so minus 17 comes here and 3 goes to the place of minus 70. So, these to now 12 12 and I find the minimum from 12 onwards I find minus 5 to be the minimum so that one will come here so minus 5 comes here and 12 is swapped there now within this part I find the minimum minimum is 3 so 3 will be swapped with 12 and 12 goes there in the place of 3 you see now. So, I start with 6 I start finding the minimum 6 is the minimum fine so it remains I increase k so now 142 in this way I go on from here with the minimum starting from 142 12 is the minimum so 12 and 142 will be swapped 12 and 142 has been swapped next 21 21 within this 21 142 45 21 is the minimum therefore, I keep it in place next is I take 142 and 145 I find that 45 is minimum I swap that and 142 goes there next is 142 is the that is the sort it added that we get this is what is known as selection sort. So, the philosophy of selection sort is that I am selecting the minimum element among the unsorted elements and placing it in the position proper position where that minimum element should be that is why we are selecting and putting it so that is why it is known as selection sort. So, how many steps are needed to sort n things here if I do this how many steps am I taking you see how many steps am I taking all through here if you look at this how many steps am I taking if the list size of the list was n then the total number of steps that required is proportional to n square because for every element why it is why it is so let us try to understand this. The reason is that for every position how many positions are there 1 2 3 like that there are n positions now for every position for this position how many comparisons I need to find out the minimum n minus 1 compare n comparisons for all these next I implement it here. So, how many do I need I need for each of these for n for n such elements for each of them I need n comparisons then n plus for this I need n minus 1 comparisons then I need n minus 2 comparisons then I need n minus 3 comparisons in this way for example for this this n 1 2 3 so n minus 4 comparisons I need in this part I have to compare between these things so in that way I go on so for every so for each of them I need to compare this for n such things I have to do this n plus n plus so n minus 1 plus n minus 2 times n so that will be of the order of n square if I find the product right and number of compare total number of steps and number of comparisons is again n into n minus 1 by 2 like as I said n minus 1 comparisons plus n minus 2 comparisons last one is one comparison so if you add this 1 to n minus 1 is n into n minus 1 by 2 you know that and that is of the order of n square if I break it up it will be n square minus n by 2 so that is again of the order of n square of the order of we write it as of the order of n square all right now next we come to another sorting algorithm which is known as insertion sort what is the general situation again just like the selection sort we have got the smallest elements sorted from 0 to this point is sorted the remaining is unsorted all right now what we do is compare and shift till x i is larger okay I go on shifting so what I do is I start with this element and I put this in the proper position I insert this in the proper position I so I move this in this side or in this side and I will come to the proper position of this element this element is being put since it is smaller the smallest elements are sorted so I am taking this and I am putting it in the place where it should belong because I have not seen up to this okay so so insert sort is something like this let us see if I can show you an example first so what I am doing is I am comparing and shifting till x i is larger I am continuously shifting the elements in this way I go on shifting this ultimately x i will be larger than all these elements so therefore my sorted position will be up to this this is larger right so I am sorry I just went the other side other way so let us study this algorithm this algorithm is void white's void because it is not returning anything it is taking the array and is sorting this is taking this array and it is sorting this so its type is void is taking a list and its size now for i equal to 1 to size I am taking item to be the least i so I have got elements like say 12 7 5 17 9 so first I am taking i is 1 so I am taking this element this item for j's now I am looking at you see j equals i minus 1 and j is greater than 0 and list so it is not I am not going into this side I will have to go in this direction what does this mean I start with j i minus 1 and go till j is greater than equal to 0 and the list is greater than i so my i is here that means I am not I am going till the end of this array on the other side I am going on the other side and I shift what was my j here j plus 1 and the list are being swapped so now it will become 7 12 5 17 9 now and then in that way I go on shifting all right so now if I come here I increment i after one item so I will come 5 and 5 I will go on checking what is the proper place of 5 so it will be 5 will be swapped with this 12 7 17 9 in that we will try to find out for every each of these is proper position okay so I think we can go for a more popular sort let us go to the more popular sort I think that will be better selection sort you have learnt insertion sort is another form but let us learn the more popular one that is the bubble sort bubble sort as the name implies it starts from the bottom and the minimum element is pushed up to the top how is that done just as a bubble floats up from the bottom and goes to the top the minimum element should be pushed up or the minimum element should be pushed up to the top so let us see how it happens so I first compare between these two elements then these two elements and in this way I go on comparing between each of them and push it up okay in every iteration the heaviest element drops at the bottom so what is happening is so if I go here from the top I try to find out if this element if this particular element I am sorry this particular element is heavier than this particular element then this particular element should go at the top and this should come down here alright next I compare sorry next I compare what is happening next I compare between this so this was a heavy element and I find that this is not an heavy element this is heavier than this so this may be more heavy much heavier than this so this is not pushed up okay remains now next I compare between and every time I am making the same mistake maybe this is a heavier lighter element so this lighter element will go up and this heavier element will come down so it will be something like this alright so in this way in one direction ultimately what I will do I will have the heaviest element at the bottom and all the elements here are lighter than this this element lighter than this element but these elements are not sorted so what I will do I will restrict my next iteration within this zone and again start between these elements and see whichever is heavier that will be pushed down am I clear you see every time I am comparing between these and I am pushing that down I think it will be clearer in a moment every iteration the heaviest element drops at the and the bottom this part is done and the bottom moves upward so next time onwards my my search will be restricted between this zone this zone to the top and the heaviest will come here next time my search will be restricted to this zone like that so the heaviest here next heaviest here next heaviest here heaviest here next heaviest here next heaviest here like that it will go on so I want to see if I can give an example first yeah so what is happening here is say this was an unsorted array the heaviest one has been first pushed down this 89 was the heaviest one so by piece by piece comparison I have pushed it down next time I was restricted to this part of the array 89 has been pushed down so and let me try to show you that say suppose I have gotten an array like this 50 16 20 30 40 so first I compare between these two 60 50 is heavier so I come here next I compare between these two 50 and 20 50 is heavier so 20 comes here 50 comes here now 50 and 30 50 is heavier so 30 50 and then 50 and 40 so I compare this so it becomes 40 50 so in one turn what do I get now I get 16 20 30 40 50 now it is such that many things were sorted only one was in out of order so that has been done but suppose this was let me just change it it becomes it became too easy so suppose it is 25 then after this swap this became 25 and 50 so I have this array now I again check between these two heavier is in place I check between these two no issue heavier in place I check between these so now what will happen 25 will come here and 30 being heavier will come here and 30 and I need not compare any further I can because this is this I know is the heaviest so what do I have now 16 20 30 not 30 30 has been swapped 25 30 I again compare between these two so there is no change as soon as I find that there is no interchange that means all these things are in order this is the idea of the selection sorry the bubble sort every time the minimum is shifting going to the bottom or I could have done it in the other way that would have justified the name of the bubble sort if I had taken the lowest element and pushed it up okay so quickly if you look at the algorithm a little bit so we have got this is a bubble sort algorithm let us see now in order to explain this I will need some time because here we are using some new ideas star x and star y I think I will take it up in a separate lecture and discuss this separately alright but just as I had explained now the way the bubble sort works I will just give you one more example to show how a bubble sort works and then in the next lecture I will show you the algorithm because that will some more explanation let us say I have got this 30 20 5 16 2 so what will be happening in the first iteration 30 will be compared with 20 30 is heavier so it will be 20 30 55 16 2 now 30 will be compared with 5 so what will happen and will be swapped 30 16 2 30 will be compared with 16 so what will happen 20 5 16 32 and 30 is again greater than 2 so 25 16 to 30 so 25 16 to 30 so 25 16 to 30 by that I get this 30 at the bottom so now I start with again 25 16 to right so now I have got 30 is at the bottom 25 16 to and 30 is already in proper place here I will swap so what will happen 5 20 16 to then 20 will and 16 so it will be 5 16 22 then 5 16 to 20 20 is in the proper place so 30 and 20 are in proper place and 5 16 to I will have to handle so what will be there 5 16 to so 5 16 to and here I have got 20 and 30 already in the proper place sorted so here 5 and 16 no change 16 and 2 there will be some change so 5 to 16 so 16 is in the proper place so now between 5 and 2 so my thing will be 16 20 30 are in place 16 20 30 are in place and 5 and 2 I have to deal with these are fine so my pointers are changing right between these two now 5 is heavier so it will be 2 5 5 is in the proper place so 2 5 in the proper place 16 proper place 20 proper place 30 proper place so only 2 there is no question of swapping so I get the complete sorted file okay so this is the principle of bubble sort I will be explaining the algorithm the code in the next class in the meanwhile you can think of you can read books and you can try to see look at this code and the algorithm yourself I will discuss it in the next week's lecture thank you