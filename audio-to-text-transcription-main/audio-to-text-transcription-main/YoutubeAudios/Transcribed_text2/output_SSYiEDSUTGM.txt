 We were discussing about the binary search function or binary search procedure. So, here we can see that binary search is of type integer is a function of type integer that will be returning an integer. And it has got the parameters the list or the array which is being designated as x here the size of the array and the key. Now, if the key appears say the array is here the array is this or the list is this this is called x and it starts with 0 and the last one is therefore, whatever is the size minus 1. So, if the key there is a key and if the key appears anywhere here it will return the position of the point where the key is if this be the position that will be returned. And if not found it will return minus 1. So, either it will find the position send the position. So, that is also integer or minus 1 hence the type is integer. Now, we have got two pointers one is L the left pointer I mean left index and the right index of this and from there we are finding out the middle. So, we are finding out the meet point by this line. Now, if the key is smaller than the middle element if the key is smaller than this middle element then obviously, our search will be on this side therefore, this R will removed to this point L will remain here and my search will be restricted in this zone. Otherwise L will be moved here R will not be disturbed and the search will be restricted to this zone. This much has been achieved by this piece of code what else do we need what else do we need to do. Now, how long will this go on how long will this go on. So, in this way in this way what will happen is I will move either L or R either this or this and when will this be completed how long will this loop go on if you think a little bit will find that it will go on as long as L and R are not crossing over. So, if I shift and search this part R is here suppose I so I initially start with L to be minus 1 and R to be the size. So, I am shifting from so here is my array and L value of L is minus 1 so it is here and R is equal to size that means, pointing here size plus 1 that means, sorry this point is size minus 1. So, that is actually here and while as I shift I shift L and I shift between this part etcetera then I shift L R is here but as soon as L and R crosses over if R moves on this side then also L and R can cross over if the cross over then that is the that is my point where I should stop. So, I initialize this and I go on shifting this depending on either L or R that is exactly what we are doing when we took the say 1, 2, 5, 7, 9, 13 like that 15. So, I started with the middle number and when the key was suppose my key is 16 all right or say say let me raise this my key is say 8 12 suppose my key is 12 what will happen my L is here this L this is R I start with mean minus 7. So, key is greater than this so I have to restrict my search in this zone I take the middle of this so R becomes this this becomes the R and I am sorry I am sorry R remains the same I have to search between this zone. So, what I do I shift L I have to search between this zone so what I do I shift L I have to search between this zone so I shift L to this so this is my new L and this is R I have to search in between this I find this to be the mid find and I find that the key is less than the mid so I will restrict my search within this zone within this zone since it is less so then what should I do if since I am moving on this zone I will shift R keeping L fixed I will shift R here so this will be R now now between this L and R I find mid this is my mid I find 9 to be less than 12 that means it should be on this side so I move L as I move L L is crossing R that means now I have come to a position where I have exhausted everything and I could not find the key all right. So, if L is greater than 0 and x L is equal to key L is greater than equal to 0 and x L is the is the key then I return the pointer is the key then I return the pointer otherwise return minus 1 so that is the binary search algorithm this is how I am carrying out the algorithm through a C code so here is an example I am writing down an array suppose sorry I am writing down a sorted array suppose it is minus 17 minus 5 36 12 21 45 63 and 50 63 it cannot be 50 say this one is say this brush step 3 is fixed by changing D D this one is 65 6 easy up to 65 6 пох and D VERY less than 16 etc that means if I move V, say this one is say this up to 63 that is my array. Now, if I carry out so the size is 1, 2, 3, 4, 5, 6, 7, 8 I must have one another one. So, let me have 75 and if 3 be my key this is the key. So, what will happen I will start L here, R here and I will find the midpoint here. So, the midpoint will be here 12 and 12 is greater than the key. So, my search will be within this zone. So, this R will be shifted here. So, this is my now my R and this is L I will find out the midpoint 3 here. Now, as soon as I come to this mid and I find that this mid is matching the key my search is found. I get my key in a particular position. So, you can write it in different ways. So, in this way if I do that then I will get different results. So, minus 17 I just missed out minus 5, 3, 6, 12, 21, 45, 63 and 75. So, if for this my L was at minus 1 R was at 9 and my mid was this X 4 12. So, then X 1 is minus 5 I carry on doing this L is still 1 R is 4 R has been shifted to here and X 2 is 3 I have found it. So, that is my result in that way I will carry out and you can find out that L and R and then I return L I go on shifting. So, that is what it has happened I have got the mid value and I have got the value, but then still I am going on shifting. You can you can also what I was suggesting is it is also possible to check the equality with the X mid as soon as I find that the element has matched with the mid then it is found. I think you have understood it you can try writing out the algorithm yourself. This is a binary search we will see later that it can be also done through recursion. Now, while doing so much earlier linear search was very much simple right here suppose we had 1000 elements if we had 1000 elements then an ordinary search if a key is a member of X it would on an average required on an average it would have required 500 comparisons on an average, but what will happen in the case of binary search after the first compare 1000 elements. So, we are left with only 500 elements because I started from I started with an array and then based on that I have either gone on this half of the array or this half of the array depending on whether the key is less than or greater than the mid point is the mid. So, on an average first compare I am left with 500 elements next compare this part is again divided if it is on this side I am left with 250 elements right. After at most 10 steps we are done in that way I go on dividing it and after at most 10 steps I am done. So, I had 1000 elements so I can so in that way I get 250 elements and 125, 125 then half of that 65 or something like that in that way number of steps that I will be following will be around 10. In general if there are any elements in the array the number of searches required is 2 to the power k should be n where k is the number of steps. For n if there be 64 initially the list is 64 the size is 64 after first comparison the list is 32 after second it is 16 then 8 then 4 then 2 and then 1 so 6 steps. So, basically at every step I am breaking it down into half therefore, if I need the k steps then if I need k steps then 2 to the power k should be equal to n that means how many steps are there how many what is k if I take log then k log log k log 2 is equal to n therefore, k will be log 2 n to the base of log 2. So, log 2 log 64 to the base 2 is 6 so we will be completing in 6 steps. Whereas, in the worst case I would have needed 64 comparisons in the case of linear search. Now, given this idea of binary search so what have we seen we have seen binary search is a search algorithm that enables us to search for an element much faster than linear search the approach being that we divide the array to be searched in half every time. So, we divide it into half and restrict our search in half and in the next step I further divide it to half and restrict to even a smaller step. So, every time I am having whatever array I am checking so 2 raise to the power k times I have did where k times I have have did 2 raise to the power k should cover the entire n and so from there we get the complexity to be of log of log 2 log n to the base 2 log n to the base 2 log n to the base 2 in general it will be log if 64 is replaced with n it should be log n to the base 2 that is my time complexity compared to so I can say this order of log n to the base 2 compared to order of n that was the case in the case of a in the case of linear search. Now, we will move to another very fundamental problem in programming we often need that see for example, here we have done one thing that is I had an array like say 2 3 7 6 1 9 now this was an array on which I cannot run binary search why I cannot run binary search because binary search can be done only on sorted array. So, if I sort it either in increasing or decreasing order say for example, it becomes 1 2 3 6 7 9 this is a sorted array or the other thing could be 9 7 6 3 2 1 this is also a sorted array in the other direction it is descending order this ascending order so now another problem is to arrange the things arrange the objects suppose they are number of numbers like this you have to arrange them sorted or arranged in a particular way the question is how to do sorting how to sort. So, suppose I have given this array to my program this is the input then if I want to apply binary search then I cannot directly apply it apply binary search on this. So, what I can do I can first take the array say I read the array let me write then sort the array and then read key apply binary search now binary search takes for n number of elements it will be faster but how do we sort the array so it is faster than linear search but is it advisable to approach in this way if the array is not sorted is it advisable to sort the array and then apply binary search in order to understand this we have to first see how an array can be sorted how an array can be arranged in either increasing or decreasing order that is also a very important problem that is called the sorting problem and this has got a very important I mean application in many of many objects whenever I sub for example for example you have got the marks of the students all right the you have got on marks array say you have got two dimensional matrix maybe where let us take one dimensional one dimensional array where the roll numbers are here every row is corresponding to a roll number and here I think I will I will just do it again I have got the marks here 56 50 65 70 etc etc now I want to find what is the highest marks one thing is that I can find that out or I want to attribute ranks first second third like that in that case I can sort this array and from here I want to have an array like this where the first element will be 70 second element will be 65 then 56 then 50 this is also sorting the marks in a decreasing order and along with that I can also sort the roll numbers and can publish which roll number got what marks right so what we want to see next is sorting let us define the basic problem first sorting means given an array like 0 to some size minus 1 reorder the entries so that they are in this way that x1 is greater than equal to x0 x2 is greater than equal to x1 so if it be this sorry why is this greater than equal to coming up say for example 2556679 this is also sorted early so both these elements could have taken any order but since they are same they can be assumed to be sorted that is why this greater than equal to think that is coming up okay the list here it is is in non decreasing order non decreasing I cannot say increasing order because it is not increasing to 255667 so here of course there was an increase but here there is no increase so this is rather instead of calling it increasing order we can call it non decreasing order we can also sort a list of elements in non increasing order it is non decreasing order so I can also sort it in the other way as we had shown earlier okay so here is an example this is sorted in non decreasing order you can see this at a 1030 now this is original list now if I sort them in non decreasing order it will be 10 minus 10 10 20 30 40 60 70 70 270 80 and if I do it in a non increasing order then minus 8770 70 in this way this is not increasing in this way here it is not increasing all right here it is not decreasing if I go in this direction so these are the two possibilities so the sorting problem is if we have an array from 0 to size minus 1 I want to sort it and get a sorted list all right that is what I want to have so the first algorithm that we will be talking about is selection sort selection sort is something like this that suppose we have got a list here and this part of the array is already sorted this part of the array sorted in a non decreasing order this already the smallest element is here the smallest element very minus 10 then 10 then 20 this part is somehow has been sorted now I am less left with sorting this part only this remainder what should I do I am going to select the candidate for this position right I am going to select the candidate for this position for that what shall I do I will start since this part is sorted all the elements on this side are either equal to this sort less than this so I will have to look at this part and find out the minimum element that is here this element that is minimum since this part is sorted this element this element must be greater than these elements so among these only for these people this one is the smallest so I select that I select that and put it in this position I swap how do I do that suppose here it was it was minus 10 10 20 30 and here it was 50 this point this part is sorted 50 32 72 31 now I remember this position and search from here and find out the minimum the minimum is 31 so this 31 comes I swap it here so what happens to my array this part let see what will happen it will now become from here it was 30 it will be 31 32 72 50 so up to this part it is sorted now now from here I will try to find out the minimum element I find this is a minimum element and I sort out the minimum element I swap this minimum element with itself so up to this is sorted now out of these now I have to find out the candidate for this position so I find out the minimum I come here and swap this so it becomes 50 72 so here in this selection sort the approach is that we have to we are going position by position and I am selecting the element that belongs to that particular position so whenever I am starting with the search then at the beginning I am having I am starting with the if this be my array then I am first searching for this position and this position will have will be the minimum of all these I search all through here and find the minimum suppose the minimum minus 10 was here so I take and bring this minus 10 here so it becomes minus 10 I know this is the minimum now I am sorting I am now looking for this position I select the element minimum element in this zone I find here something 10 so this part is done so now 10 is swapped here so 10 10 and then this part is unsorted this part I will sort in this way we go on this is one of the sorting approaches we will deal with it further in the next lecture.