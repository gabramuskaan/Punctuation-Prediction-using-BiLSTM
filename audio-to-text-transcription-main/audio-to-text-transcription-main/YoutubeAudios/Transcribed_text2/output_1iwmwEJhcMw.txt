 So, in the last lecture we have discussed about function prototype before moving to some other topic. Let us look at an example of function prototype and so that we can understand it better. Here you see here is a program where I have got a function NCR, N choose R and another function fact. Now, the functions are actually written later. Here you see N choose R is like the standard N choose R that we do. Here that is a factorial N by factorial R. So, factorial N divided by factorial R into factorial N minus R that we know from our school. So, that is one function that is one function. The other function is the factorial. So, here is another function. This is one function, this is another function. Now, look at the beauty of this function. This function is in a simple one return statement I have written everything. So, here you see the body of the function is merely a computation of an expression factor divided by factor divided by and factor minus R. And this will be computed and that will be returned as an integer. Now, what will be the input? The input will be the N and the R both of them are integers. Another point to note here is this function itself, this function itself when it is running. First say I get into this function and I try to compute the return value. First I find fact N and from here I am calling another function that is the factorial function. And the factorial function is taking only one input, one integer N and based on that it is computing the factorial. Computing the factorial you must be remembering by now or knowing by now that is I am starting with 1 and 1 times 2 times 3 etcetera I am going on doing and that is what is being done here. Temp is 1 and temp is equal to temp times I. This is wrong, this should be small I. Temp is temp times I whatever the I value is 1 times 2, 1 times 3 it goes on till I reaches N and then I return temp. So, the point to that you know this thing you know. So, what is being done here is when I am computing this function then I come to this I call this function return temp I return here and then I move here. And again I find again a call to this fact again this time with a different parameter R. And so again fact R is computed after this is computed. Second time I return back here and then I again call this fact using N minus R. So, just to make the things clear. So, the first time I am calling this from here and returning back here second time I am calling this from here the same thing and returning back here and third time I am calling from here and returning back here. Now, for the third call I am so here is 1 N and so here is 1 N and that this N and here what I am passing I am passing N minus R I am first computing this and that is being passed here and that is being computed. So, here you see it is an example of nested call. This was called from the main and this in turns call another function and in this way it goes on that is about the beauty of these two functions. But now here is my main function here is my main function. So, the compilers comes from in this way and recognizes at this point that NCR is a function how does it know it looks at end. But how does it recognize that it is a function it recognizes NCR to a function because of this parameter argument list. Here it is said there are two integers coming in as parameters next it understands that fact is also a function. So, it is expecting to encounter NCR and fact somewhere down the line and it proceeds here it takes M and N reads M and N then it is in a loop where it is calling NCR. It is a series you can understand NCR is computing some with some value I initially one. So, it is basically N C 1 plus N C 2 plus N C 3 plus etcetera it will go up to M. So, that is what is being computed here and so from here a call is made to this and as we have seen earlier while this is being executed this one is calling here this is returning back here then again this one now we are making a journey in this line. So, this one is calling this and we are returning back here as we have seen just now now ultimately when this entire thing is computed then we will come to this last bracket here sorry I should not this bracket here that means it is the end of NCR. So, I had called NCR from here so I will return back here and will whatever NCR value is that will be added to some and that will go to this some and then will proceed in this way. I hope this clear now here I have not written NCRs I could have I could have written this earlier in that case this prototype would not be needed but since I decided that I will be writing it later. So, I decided to just introduce them as prototypes here now you should be very careful about the syntax of the of writing the prototypes it should have the function type just like a function name and the parameters now you will see later that it is also possible that I could have written something like NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, NCR, it also mean that this NCR takes two integers as very I mean arguments that will also that is also allowed but it is nice to write this in this way. Now, next we will move to a very important concept. So, let us quickly have a look at this the prototype declaration and the function definitions are actually here. Now, we are moving to a very important concept of passing the parameters how do we pass the parameters from the calling function to the called function. There are two distinct ways in which it can be done one is calling by value as this calling by reference. So, right now let us think of calling by value. Now, let us try to understand it in a simple way. See here is my mean function, let us call it mean function as we have seen there can be nested functions. So, this is the calling function. Now, in the function, we have seen the function of the calling function. Inside the calling function, I have got some variable x and which may have the value say somewhere 5 it is an integer. Now, somewhere here I am calling a function let us call a simple function decrement or not decrement add 2 or say say add 2. So, I am going to say that means, whatever is the value will add 2 to that simple thing. So, here I say y is add to x and then semicolon and I go on and here is my function. Add 2 in A and add 2 is also type integer. Now, so A we know is of local variable to the function. So, here I will take so what will happen suppose it was 5. So, this will result in A will get 5 and here may be here I declare another variable say B. So, here I declare another although it was not necessary, but I am just saying B is A plus 2 because it is task is to add 2 and then I say return B. So, this B which is an integer is being returned. So, B which will be in this case it was 5 it will be going back here. I hope this is clear. Now, when you know the scope of variables that B is a variable or A or B whatever the value of those are restricted only during the life of this function. So, but however, in the case of looking from the point of view of compiler I have got a variable A and I have got another variable B and here I have another variable X. Now, this variable X was having the value 5. So, here in X I had 5 by this statement this statement made it 5 now since X is 5 and this one is expecting the value A in Y area. Now, this 5 will be copied in A, what is being copied? Not X, but the value of X. So, this one will be getting 5. So, the copy value is being copied. The value is copied in this variable 5. Now, it takes B was something, but here so B becomes 5 plus 2, B becomes 7, 7 comes out. Now, suppose I change this program a little bit, I erase this B and make it, so this B is no longer there, this is not required. This variable has not been defined, I say that this line is also not there. In T and I just do A plus, A assigned A plus 2. So, now, when it was called add X, then from here, from here this X was copied here and A will be incremented to 7. So, this will be incremented to 7 and obviously, this will be returned A, not return B, because B is not there anymore. So, 7 that 7 will be returned here, but you see if here now 7 has been returned and 7 will be Y. Now, suppose if I say I am not following the syntax, I am just saying because there is no space here, print if something X, what would be printed for X, what would be printed? 5 will be printed because X is still 5, X has not changed. I have simply copied the value to the argument variable and have played with that, changed it, whatever I wanted to do, I have done. So, take a little time to understand this, this means that the variable that I have in the calling function, the value of that will be copied to the argument of the called function. So, there are several advantages to this, one is, so it passes the value of the argument, execution of the function does not change the actual parameter, like the actual parameter was X, which was 5, it remains as 5, although the function added 2 to that and it came back, all changes to a parameter done inside the function are done on a copy of the actual parameter, not the original parameter. The copy is removed when the function returns to the caller, that entire variable location that was given for the variable A in our example, is returned back to the pool of memory locations. The value of the actual parameters in the caller is not affected, consequently it also saves us from some accidental changes programming that can come, copying due to programming errors. On the other hand, the other thing that is another type of parameter passing is known as call by reference, call by reference. Here, we are not copying the variable, we are passing the address of the original argument. So, let us take the earlier example again, if I had my main function here and I had similarly, in text and here y was 0, 0, 0, 0, 0, 0, 0, 0, add to x here, print f something x. Here, I had that function add to int a and here in the body, I did assign a plus 2 and returning returning. Now, here is a variable x, this is the variable and that has got an address, say that address is whatever 5000. Now, its value here somewhere, x was 5, so its value is 5. Here, what I am in the case of reference, I am not copying the value of 5 to a. Instead, in the parameter passing, I will write it in a different way, not in this way, which I will discuss later. If I assume that this one a is not taking the value, but the address is of the parameter, address of the parameter means what means that this time, this a, here I am passing not the value 5, but I am just simply saying that whatever data you want to work with, that is the data is in this location 5000. And it accepts that reference, that the data that I am working on, my a is actually staying in 5000. So, what it does, it takes the when it computes a assigned a plus 2, this is not looking nice. So, this is the data that I am working on, let me write it a, a assigned a plus 2, it now knows that it is not the value a is here, I have to get the value from this location. So, it gets the value from this location, but no other variable location has been allocated, because I know where there is only one common place, only one common place, you have done given something here and you have told me where you have kept the data and I am also working in that vessel itself. So, what is happening here is this 5 will be changed to 7, here only and return I need not return 8, it was just return to be sufficient. So, changes have been done here, so in this case when I come to this print FX, what will happen, what will be printed, 7 will be printed, because the actual data has changed here. Let me show it with another example, here is my calling function and I think this vessel analogy will be fine. Now, it says that here is the data where I have pulled, it only tells you where it has pulled, the name of the vessel, suppose the name of the vessel is a, there are many other vessels, a, b, c and only this vessel name has been passed. And when this one is doing something, it knows the vessel name a, so it comes here and takes the data from here, does something and returns the data from here. And here this program when it is computing, when it returns and then ultimately it returns there and while it returns, it takes this value, this value, the change value and continues. So, in the case of calling by reference, we are not copying the value, on the other hand what would have happened in the case of call by value using the same vessel analogy. Say this program was running, the value was in a vessel, the value was there in a vessel, but my function do not bother about the interchange of colors. The my function was also having its own vessel and when the function has been called, the main function calls this, a calls or say, x calls y, then also x copies y copies the value of the variable, suppose that was a, that is copied in the vessel that is belonging to the function, it may be b. So, this one does whatever it does here and returns this value over here. So, this one is not disturbed, whatever changes are being done, are done here. So, that is a very fundamental concept in parameter passing, there are two types of parameter passing, one is called by value and another is called by reference. Now, so here you see, execution of the function may affect the originals because I am sharing the same vessel. Now, this in C, in C we actually we are, in C we actually carry out only call by value, only call by value. Except for the case of arrays, except for the case of arrays, there is a reason for that you will understand and for arrays we are not passing the values, we are passing by reference. Otherwise, it is always called by value. So, let us have a look at some of the examples here, first example, we have got the main, let us see what is happening, A has been initialized to 10 and B is not initialized, print F initially A. So, what will be printed, look at this, this will print this first line, initially A equals the value of A which is 10. So, here there is a variable A which has got the value 10. Then B is being assigned, change A, what is change A, change A is a function. So, one mistake is here, I should have declared this change prototype here. However, I should have, the function prototype should have been defined earlier. Now, I come here, print F before, what does the function do, prints before x, x. So, before, so this point, before x equal to x, whatever x was, it has got the copy of that x, it has got the copy of that x. So, this, it was A and that has been copied here for its own x. X is also 10, copied because when it called, you actually copied this. When this call was made, when this call was made first, then before that, it was also copied here and then only this was done. So, it was printed, then x divided by 2. So, x becomes 5 by this statement. So, what is being printed? After here, this line is being printed here, after x equals x. So, what will be printed? I am still inside the function, please remember, I am still inside the function. So, 5 will be printed and then I return, return x. So, what is being returned? 5 is being returned. Where it is being returned? Here, x has been, A has been changed and that is going to be print F, A assigned. So, this print F is, this print F, A, sorry, A equals here, I am printing A, A is A. So, A is not changed. So, it is being printed as 10 and B is being printed as 5. So, you see, A has not been changed. The reflection of the change has been reflected in this function and is being assigned to B. Now, let us take another example and you will yourself try to look at this example and a little change has been done. Let us all together try to follow this example. So, starting again, a mistake is, I should have declared the function prototype here. So, those things I have not shown here. So, but you should do it. Now, let us see. Here again, int x equals 10. So, x is a variable to the main function. So, x is having 10. Print F M here, main function. Printing initially x is 10. Then, it is calling the function. So, here the function is being called. And whenever this function is being called, there is a local to the function. There is an argument x where this 10 is being copied. Now, print F here, this print F in the function. It prints before x was x, before changing. So, x was x. So, what will you printed? 10 will be printed. Then, I change x here. So, at this point, x is becoming 5. Then, I am saying print after the change. This is this print out. After that change, x is what? It has been changed 5. And then, I return to the main function with the change value of x. So, b gets 5. Now, I am printing in the main function x is 10 and b is 5. So, it has been changed. That is being reflected in this print F. And b is also 5. b was here. b is in the main function. So, that b has been assigned after this change. And that is also 5. Now, the distinction, I think will be clear. So, these are the two cases that we have shown. So, now, here let us see. Here, the slight change that has been done is, that the change value I am keeping in x. Now, this was x and x was 10. Now, note, x was 10. So, initially x is 10, fine from this line. Now, this is the change value of x. Now, this is the change value of x. Now, this is the change value of x. Now, note, x was 10. So, initially x is 10, fine from this line. Now, I have called change x. So, it is coming here. But, its parameter is also x. But, that really does not matter. This x from here, I will create another x. This, who is the owner of this x? The owner of this x is only this function. As long as this function is running, this x has got a meaning. It is existing, after that it is not there. But, since I called it, the value 10 was copied in this. But, you see these two are two different memory locations. Consequently, what is happening? When I printed here before x was 10. Now, see which x is being printed? This x is being printed because this x is not known to this function. This function only knows its own x. Then, x is changed to 5. That is also done locally here. And, it is being said here, after that the x is 5. Because, this x is known. Then, I return x. So, 5 is returned. And 5 is assigned to x. Now, whenever I have gone out of this function, this x is no longer existing. Vanishes. That means, the compiler returns it to the memory pool. Now, which x is this x? This x. So, this value that is 5, that is being changed. We will come here. Now, here I am doing print f x x. That means, both b is. So, x will be printed as 5. And, b equals x. So, x is also 5. Here, you see that the same value is the variable is x. So, both will be 5. So, I hope you could understand this difference. Let us take the another example. Or, we will come back to this in the next class. And, we will start with a new example and continue with parameter passing. So, what we learnt in today's lecture is a very important concept of call by value and call by reference. And, we could see that in C, in general call by value is adopted except for arrays. And, what is call by value? Call by value means the calling function copies the value of the parameter to the variable. Corresponding to the argument. Whatever change is done is done locally inside that argument. And, when it is returned, it goes back to the main function. The value goes back to the main function. Whereas, in case of call by reference, there is only one vessel, one variable. And, I am not creating another variable. I am simply passing the address of that variable to the called function and the call function changes in that particular variable. And, whatever changes are happening, they are reflected in the main function, a calling function as well. We will continue with this.