 So, we had looked at parameter passing and we have looked we have seen the difference between call by value and call by difference and we have seen quite a few examples to be specific three examples on call by value. How and also another thing that was supposed to be noted I hope you have noted that is the scope of variables that whenever there is an x in the main function and the x in the called function then these two x is a different the x that is defined in the called function is a separate location than the x in the main function and that the life of that variable ends with the end of the function. Now let us look at this example you yourself will be able to trace this. So, I give you some time to trace this through and then we will continue look at this function carefully and do not look at this green part do not look at the green part yourself and try to without looking at that try to find out what the values will be for the different print statements. Let us start. So, we have got x assigned to 10 and y assigned to 5 x and y. Now, so when I print f do this print f x is printed to be 10 y is printed to be 5 fine no issue then I call a function interchange x y look at this the type of this function interchange the type of this function interchange is void because that immediately tells us that it is not going to return anything it is going to do something as the name implies it is going to interchange x and y and what are the parameters parameters are x and y this is the argument. So here I have got another set of x and y again note that this x and y are different. Now, initialize temp. So, temp is another variable here temp. Now, what I am doing here the first print f what is being done here print f x equal to x and y equal to y which x and which y the x this x and this y. Now, when I entered this function these values have been copied here. So, the print f will simply print 10 and 5 no issue. Now, temp is getting x x was 10. So, I put 10 here and then x assigned y sorry y assigned x that means the value of y I am still within the function I am within the function. So, this value is being assigned. So, by this statement what happens this becomes 5 and this remains 5 right and then what is being done here y assigned temp that means this temp is becoming 5 right temp is becoming sorry I am sorry I am sorry I am sorry this was 10. Now, for this statement temp is going to y that means y will be changed to 10. So, here I find 5 and 10. So, it is when it entered here I could see 10 and 5 and so, when I come and print from here x will be 5 and y will be 10 I come out of the program and print f x and y what will be printed my God. What I find is x is being printed as 10 and y is being printed as 5 as it was here. So, no change has actually taken place why did it happen like this you can immediately see the reason that whatever change took place took place here inside the function and this actually tells you the importance of the scope of variables these variables scope ended with this function and their change was not reflected in the main here that is why although I did it here it would not change. However, suppose suppose let us do some intellectual exercise here suppose x was 10 and y was 5 and there was a temp now temp is inside the function. So, I will use different colors for that. Now, although I I I remind you that C does not allow call by reference, but just to see whether you have understood call by reference properly. Suppose we are allowed to use call by reference then my main program has got this x and y. So, it comes here prints say prints x and y. So, 10 and 5 are printed x equal to 10, y is equal to 5 and it calls interchange. It calls interchange and suppose just suppose that this call has been done by call by reference. So, what has been passed here the address of this and the address of this not the values. So, no other copies have been made. So, now I have got the local variable temp and the value of the value of the value of the value of the value of the values not the values. So, no other copies have been made. So, now I have got the local variable temp and here I do temp is assigned x. So, temp gets 10 then x assigned y. So, this is the now what is my x and what is my y. The content of this address which have been passed will go to the content of x. So, this will be 5 and then y will be assigned temp. What will happen? This temp this value will go to the suppose I can make call by reference then this will go to this address. But if I just simply write in this way that does not mean it really does not tell me whether I am saying that I am copying the from the address or actually copying the value. But I am just taking telling a hypothetical case. So, this 10 will go there and this 5 would be changed. In that case when I come back from here and I print here then I would have got the change scenario reflected. But the mechanism writing simply like this in C means it is called by value not called by reference. So, what is being passed is actually the value. So, if I could if I could do that then it was possible to have that interchange. And there is a mechanism for passing the addresses and not the actual values by using a concept called I mean structure called pointers which are nothing but addresses. We will have to we will see that later if time permits. But in general remember that this interchange has not been possible by call by value in the way we wrote the program. So, with this we complete our discussion on parameter passing normally one of distinction between parameter passing by call by value and call by reference. And we now start another very important point that is passing arrays to functions. Now, let us try to think here when we were having a variable x another variable y in the called function in the color function. And I was having in my called function two other variables a and b in the value of this would be copied here and the value of this was copied here. But suppose x is not an integer x is an array of 20 elements. Then all those 20 elements I have to copy here and suppose this is an array of another 20 elements. So, another 20 elements I have to copy here right C allows only for arrays the parameter passing by reference. Now, in order to understand that let us try to look at the structure of an array. Suppose I have got an array A 10. Now, I am not making a distinction between the size of the array actual size of the array and the dimension of the array. I am assuming that the array A has got 10 elements. So, I have got 1 2 3 4 5 6 7 8 9 10. And these are A 0 A 1 A 2 up to A 9 right these are the locations we know that we also know that an array is allocated contiguous memory locations by the compiler. So, all these are contiguous therefore, it is sufficient to know the address of the starting location. Suppose this is 1000. If this is 1000 and if it been integer and I assume that an integer integer takes 2 bytes say 16 bits and then this will be 1000 2 this will be 1000 4 etcetera I can compute any particular address any particular address of this. So, if I say A 5 the address of this A 5 can be easily computed as the starting address 1000 whatever is the starting address plus the index is 5 that means and the size of integer which I know in a particular machine say 2 bytes times how much will be 106 108. So, what will be 2 into whatever is the index minus 1 sorry A 5 A 5 will be the 6th element right. So, 5 times whatever this is suppose this I I times I right size of the integer times I. So, it will be 1000 plus 2 times 5 1010. So, this is A 0 A 1 A 3 will be 1000 6 A 4 will be 1000 8 and A 5 will be 1000 10 since it is contiguous it is sufficient for me to know the starting address of the array. Therefore, it is good enough to establish the correspondence between the name of the array and the starting point of the array. What I mean by that is again I draw this now I name the array differently A and suppose it has got 5 elements all right. Now, A and A 0 are treated to be synonymous when I say A that means I am actually referring to this element this address not this element this address and since I know that therefore, A i depending on the value of i I can compute where the actual location will be this is the fundamental concept we need to understand all right. Therefore, we can pass the an array array to a function as ordinary arguments for example is factor whether x i is a factor of x 0 suppose I want to do that. So, you see is factor earlier I did x or y here I am writing x i x 0. So, x i is what suppose x is an integer array. So, x i is an integer x 0 is another integer. So, I can simply pass this sign of a particular angle where is that angle in an array x an array x is there and in that the fifth or sixth element I am taking. So, this element is coming as the parameter. So, that is procedure little further. Now, that is for the individual elements x i or x 5 x 0 I am just passing an element and if it is an integer array then an integer is being passed if it is a floating array floating point array then a flow to the past but what if I want to pass the entire array to a function that is what I just now explained that is an array name like a can be used as an argument to a function because a essentially means a 0 and if I can pass a 0 that dress of a 0 is known then all the elements are known because they are contiguous. Now, the way it is passed differs from that of the ordinary variables why here when I have got an array an array a with a 0 when I am passing the array suppose somewhere in my function f I am passing the array a and just to see that it is an array I just do something like this this is not the correct syntax I will show you the syntax a little later. Now, you see I write it in this way all right now that means I am passing a 0 but if I pass the value of a 0 which might be 50 I have got no clue about the other values I am not passing all the values. So, what do I have to pass? I if I pass the address of a 0 address of a 0. So, this is what is being passed is address of a 0 then I can get access to all these elements a i a 1 a 2 anything because I can compute the address very easily as I have shown just now all right I can do that. So, this is an example this is a case where we call by reference we actually will pass the address and not the value of a 0 we are passing the address of a 0 and the address of a 0 is the same as the name a this is a very fundamental concept let us try to understand this how is it pass the array name must appear by itself. So, now we are talking about the some syntaxes the array name must appear by itself as argument without brackets or subscripts the corresponding formal argument is written in the same manner let us look at an example say here I am going to pass the whole array as a parameter. So, I have declared constant int a size 5. So, something some variable a size is assigned 5 now float average average is a function which will which is taking as parameter sorry which is taking as parameter an array b all right just the name of the b only array name or address of b is passed now this symbol is mentioned to indicate that this is an array right now let us see what is happening in tie total 0 for i equals 0 i less than a size that means less than 5 i plus plus total equals total plus b i. So, what is happening so here is an array b here is an array b a size the array size is 5 and all these elements are being added. Now, all these elements are being added in this loop so b i only b 1 b 2 b 0 b 1 b 2 b 3 b 4 they are being added to total and then I am returning what I am returning I am returning total divided by a size now there is a new thing here also it is better to look into that. Now, the array now average will be a floating point number and b is an integer array. So, sometimes so when I what has been done here is float a size when we do this float some variable x that means this variable is being type-casted is being made to be represented as a float. So, if it was 5 5 suppose then float a size so since is 5 float a size will make it 5.0 and suppose the array was 1 2 0 4 5 so 9 to 11 12 total was 12 so float total will make it 12.0. So, I am casting 12 forcing it to be represented as a float. So, then 12.0 is being divided by 5 with divided by 5.0 and I am getting the average and that average is being returned here. So, that is that was not our main contention here that is the purpose of this float but the main contention here is that I have passed this array b but who passed it the main function let us study the main function the main function x is an array of size a size that is 5 and x average is of some variable and x has been assigned as 10 20 30 40 50 x average I will compute but I am calling this function average from here and I am passing x what is x x is an array and that is appearing just as a variable here and that is being accepted as b. So, what is the correspondence between x and b? x is somewhere suppose starting with location 5000 and there are 5 elements as has been said here 10 20 30 40 50. Now, when this x is passed to b this function now knows that b is an array because it had this thing and this 5000 is passed to b. So, now b knows where is b? b is the same array now whatever change I do here suppose in this function instead of computing the total if I had written this function in a different way for example, let us do that and suppose suppose I have got this function x I have got this function x this array sorry I am sorry x where 10 20 30 40 50 are there and in my function change I can also say void change in b this and in the body of the function what I do is for please try to understand I assign 0 to this I less than equal to a size or 5 whatever it is I plus plus b i plus plus say this what will happen inside this function change I will take the first one change it to 11 this one will be 21 this one will be 31 this only 41 this only 51 and when I return I made a change in b but b and x are the same because this address 5000 was passed to the function change and this b got 5000 and so whatever change has been done here will be reflected in the main function when I return clear so that is the importance so here I have called it with the actual array name here of course, I computed a total and returned some other value but if I had just change it inside this function I could have made it void function and the change would have been automatically reflected in the main function. So, here you see we do not need to write the array size it works with arrays of any size for example, here void this etcetera where list is an array of 100 elements and average I am calling a float average in a is an integer and float x is mapped to list x is an array because here how is the correspondence done this list list is being mapped to this same address is being passed and n is being passed to a how many elements are there all right. So, I need not specify the size because the size is already specified here I have got 100 element added this is my list this is list right. So, I have got 100 element here I know what I passed to x is just the address so whatever it is 100 or 150 that we true for x also right. So, we do not need to write the size of the array. Now, similarly arrays use as output parameters. So, suppose I am going to do vector sum that means I have got 2 arrays a and b. So, what I am doing here I have got 2 arrays a an integer array another integer array b and I am adding them. So, I will add this element say 5 with this 7 and I have got another array v sum v sum where the sum will be stored. So, this will be 12 if it was 6 and this was 5 here will store I will add these 2 and I will store 11. So, let us see how the vector sum now vector sum will be void you know because it is doing the addition and the addition is remaining in this vector sum. So, I have got let us start with the main function x is an array. So, this is actually x a or let me say let me put the main function first. So, it will be x in the main function and a in the this function y slash b I am writing slash b because this was the same because the address is here alright and vector sum will be z. So, z or vector sum now. So, x is 1 2 3 y is 4 5 6 and z z has not been initialized because. So, let me let me let me let me so that you are not confused let me do it like this. I have got an array that is x having values 1 2 3 another array y having values 4 5 6 and another another array another array z which will have the final value and z alright it is 3 elements, but we do not know the value. Now, I am calling vector sum and what I am passing x is being passed to this x goes to this. So, this is known as a for the function y goes to this. So, this is known as b. So, x and a locations are shared z and v sum the locations are shared alright. Now, I am calling vector sum. So, all these are being added in a look 5 7 9 then I come out I come out now you see when I come out of this function these are already reflected because it was passed by reference. Now, let us look at the print printed vector what is happening here void print vector that is another function that is I am calling here z 3 that means, 3 elements will be printed from that z array the z array was here which had that elements like 5 7 and 9. Now, with that print vector it is just in a loop I equal to 0 I less than length what is length length is 3 and what is the array z is a. Now, this a and this are different again this a and this a are different this a this a was this function say and this a is this function say. So, they are different. So, here they are printing 5 7 9. So, that is as an output parameter. So, you see actually whenever I am reflecting on an array I need not pass it because essentially automatically passed right. So, that is what is very important. So, I hope you have understood this the actual mechanism is when an array is passed it is the array elements are not passed but what is passed is an address and the argument becomes a pointer to the first element or I a pointer to the first element that means, the address of the first element. And when an array element is accessed inside the function the address is calculated I have already explained the formula that is used for finding the array. So, this is known as call by reference. So, I think you have understood this will continue our discussions in the future lectures on some other important issues.