 In the earlier lecture, we had seen that we start with an algorithm, we start with an algorithm and convert that algorithm into some sort of high level program, some high level program. We convert it to some high level program and that high level program is fed to a compiler and the compiler prepares the machine level program. Now, this machine level program is fed, is stored in the memory of the computer and from this memory stored in the memory of the computer. Now, from the memory the CPU, CPU executes it and we get the desired result. So, that is the overall flow of the whole thing. Now, we will now come back to some of the statements that we used in the earlier example programs, we will come back to that. Say, we had statements like sum is equal to sum plus number 1. Yesterday we encountered such statements sum equal to sum plus number 1. Now, also say for example, max assigned number 2, max assigned number. Now, the question is, what are these things, max number or for example, if I write area is assigned 5.2, what is this area and what is this 5.2? Now, this is some very fundamental concept that we will be discussing today. These are known as the variables and these are known as the values. Now, we must be very clear before we start translating or writing a program in any high level language, it is imperative to know very clearly what is a variable and what is a value. So, today's lecture will be devoted to explaining the difference between variables and values and what is the significance of these variables. Now, let us look at this diagram. The memory can be considered to be a number of racks in a book rack sort of thing or you can think of a number of dryers in a chest of dryers. Essentially, these are specific places as is being shown here. Now, each of these places is known as a memory location. Now, here you can see that each of these locations have been marked with each of these locations have been marked with a particular address. So, these are the addresses. These are the addresses and each address of every memory location. So, think of a scenario that in a locality, there are a number of houses each of this house is a location. So, these are location. Now, I want to reach a particular house that means a particular location. How can I identify where I should go? For that we need some address. So, similarly, in the case of memory for every location there is an address. So, here we can we are showing 1, 2, 3, 4, 5, 6, 7, 8, 9. Actually, there are more locations which have not been shown. So, we are showing n locations, n number of locations, n locations are being shown. And each of these have got some address. There is a peculiarity here. The reason of that will be clear later. Let us for the time being accept that we are starting our journey with the number 0. So, the first address is address 0 and so, the nth address will be address n minus 1. Because the second address will be address 1. So, the nth address will be n minus 1. Now, recall that we had the scenario that we had a high level program, high level program or if you remember we call it also the source code. And from the source code the compiler converts them into a machine code, machine language. Now, in my high level source code I have a statement like sum equals 25. Now, when I say that sum is equal to 25 the compiler will look at this and will assign these variable. Now, this sum is a variable. Variable means what? It is a variable because it can be loaded with different values of variable can have different values. For example, here I am making sum equal to 25. After a while I can make sum equal to 37. Therefore, sum is a variable and it can have different values. So, say in a program I have got here sum equals to 25 x equal to 56 and sum equals to sum plus x something of that sort. So, here how many variables do you see and how many values do you see? We find that sum is a variable and x is a variable and these variables have been repeated here. And what are the how many values do you see? 25 is a value 56 is another value. Now, when the compiler takes the high level program and it looks at the compiler looks at all the variables and assigns or allocates distinct locations to each variable. For the sake of simplicity let us say that it assigns distinct locations to each variable. Sometimes advanced compilers also share variable share locations but that is not our concern right now. Therefore, let us come back to the slide once again. You can see if I have a number of variables then every variable is mapped to a particular memory address. For example, here if I write sum equals 56 x equal to 27 and y is equal to 3.5. The compiler will look at this piece of program and we will allocate some location to each of these variables. Maybe sum can be located here, x is allocated here, y is allocated here. See, therefore, sum can be identified now by the computer or the CPU when it will run the program, it can look at whenever sum appears in the program the compiler will convert it to the corresponding address of sum. Sum has got the address 3, x has got the address 6 and y has got the address 7. Therefore, this thing is converted to a scenario where I am actually writing 56 into address 3. So, as if 56 is being written here I will explain it later, x is being written at 27 is being written here and 3.5 is being written here. Because while the computer executes the program, it will take the data from the memory location only and the memory location see it no longer understands whatever name you gave to this particular variable where that is sum or any other name. But it is identified uniquely by the address that the compiler has given it. The compiler can depending on the availability of the memory locations allocate different addresses to different variables. Once that is done, there is a table for example, there is a table like this a record that is kept that you can think of that we have got the variables here, the variable and the address. So, some table of that sort is prepared, some is address 3, x is address 27 etcetera. So, sorry x is address 5, is address 5 and y is address 7. Now, the CPU whenever it so the program in the machine language is converted in terms of these addresses in terms of these addresses in terms of these addresses, these variables will no longer appear in the machine language. So, now let us look at this in a little more detail. Now, suppose look at this instruction, there is a program. Now, one thing to mention here is typically a program consists of a sequence of instructions that we know that one instruction after another will be executed. So, this is usually done in a sequence, where is an exception from that sequence? We are seen in the flow charts that whenever there is a loop, I am repeating an instruction time and again we have seen when we are trying to find the maximum of n numbers or average of n numbers. We are repeating some instructions time and again, in that case we go back to the earlier instruction. Otherwise, one instruction is executed after another. So, as time passes, we have got some instruction here, not doing any meaningful computation, just to illustrate x equals 10. Now, here is another point. What does this equal mean? This is something that we should understand. In our school, we often do say x equal to y. That means, x, the value of x is equal to the value of y. So, if x is 5, then y is 5. But here, this symbol whenever we are using now is this symbol actually means assignment. Now, this is something which you should understand and this is fundamental to any programming language that we use. When I write x here, I am writing x this symbol y, I will read it as x is assigned y. What does it mean? x is getting the value of y. Now, so often it is therefore, in order to avoid this confusion, we write it in this way. That the value of y is assigned to x. Now, here is something to really understand. What is x? x is is it a value? No, x is a variable. Therefore, x is a memory location. The compiler has allocated some memory location with a specific address. So, this x is nothing but a memory location with some distinct address. Is it readable? Memory location with some distinct address address that is x and y is also a memory location with distinct address. But this assignment means it is getting the value that is in y. So, let us think of like this that here is a memory location that has that is x. So, x when I am writing x that is means that it is actually the address of x. That has been address of this memory location and y is also a memory location. And when I am writing y this variable name y just for ease of our understanding. Otherwise, I would have to write the address here and the address in a computer system in the machine language will be a string of binary bits, I mean a bits, bit string. So, that will be really complicated. So, for the sake of understanding we are just writing x and y, but you must understand that this x or this y means the address the address address of x. And who has allocated the address of x or the address of y? The compiler. Now, when I am doing assignment this x is assigned the value of y. Suppose y had 5. The value was 5. Now, this 5 is then written over here and this also becomes 5. This is the meaning of assignment. It is not exactly meaning equal to y. Essentially after this what happened is the value of x is actually equal to the value of y, but this sin typically means assignment. In order to show this equality we have got other symbols we will come across that later. So, now let us move to this. So, here we are executing an instruction one instruction after another. So, here in the first instruction we find that x has been assigned the value 10. It is not once again let me come here. This means x is assigned the value of y. If I write this x assigned 10 this means x has been assigned 10 that means x is assigned the value 10. Because here I had some value in y whatever it is and that was being transferred to x. But here it is not this side the right hand side is no longer a variable, but a value right the right hand side is a value. Therefore, x is a memory location for this example for this example x is a memory location which is having the value 10. After execution of this instruction this will be the situation in the memory. This will be the situation in the memory after the execution of this instruction right. So, now here let us now you will understand as I assign 10 to x and this is the same memory location this is the memory location for x the same memory location see how the picture is changing. Here that memory location x is getting the value 10 on this side I am showing the memory location allocated to the variable x ok. So, 10 next step I assign 20. So, this location gets 20. So, this 10 that was then in same location 10 was there 10 is being overwritten by 20 here. So, when this is being executed then this 10 is being overwritten and 20 is being written. So, I am getting here 20. Now, x has got 20 what is x now? x is 20. Now, I do another arithmetic operation here what how do you explain this x assigned x plus 1. Let us go back one moment to this x was this x it was 20 and I have come across an instruction which says x equal to x plus 1 what does it mean? It means assign to x what x plus 1 that means after computation of this expression whatever value you get whatever value you get after computation of the expression will be assigned to x. So, how will it be done? Right now what is the value of x 20? So, the CPU will have doing some addition operation will take read this value 20 here and some implementation by 1. So, that these two will be added the value from the location x will be taken it will be added with 1 or incremented with 1. So, here I will be getting after addition I will be getting 21. Now, this assignment means whatever value you get after computation will be assigned to this why this because on the left hand side I have got the same location x. So, this will be changed to 21. Now, suppose if instead I had the situation like this x at 20 and I write y assigned x plus 1 what does it mean? It means that this y is another memory location and what is being told over here you take x take the content of x and so, you will take 20 and have 1 added add them you will get 21 and assign it to y. In that case you see the picture the content of the memory location the value of the memory location x remains unchanged and another location gets the value 21. Unlike the earlier case when we had written x assigned x plus 1 when I do that then in this case this value will be over written this 20 will be over written, but in this case it is not being over written it is remaining all right. Now, let us go back to the slide here. So, when I therefore, you now you understand x was 20 assigned 20 then next step x is assigned x plus 1. So, it becomes 21 the same location x is becoming 21. Now, I am doing x assigned x multiplied by 5. So, again what I am doing I am again doing the same thing x assigned x times 5. So, I had x and x was 21 here I took that value and this time instead of adding the CPU is doing some multiplication and with this constant value 5 and is getting the value 105. Now, this 105 is again written back to x. So, it is going over there and it will override this 21 and we will write 105. Clear? Therefore, here we will have the result as 105. I hope you have been able to understand the difference between the variables and values here and the variables the fact that variables are nothing but memory locations. So, I will continue with this in the next class. So, quickly let us have a look at this. So, let us see let us revise here another situation another program segment a part of the program x is assigned 20, y is assigned 15 next step y is assigned 15, x is assigned y plus 3 y is assigned x plus x divided by 6. Now, obviously, since there are two variables in this program there will be two memory locations assigned two memory locations assigned. Now, here in the first instruction x is being assigned 20. Therefore, this location has got 20 written in it. What is there in y? I do not know anything sorry anything that anything that was earlier from the beginning was remaining that is there I do not care. Next step I am writing 15 to y I am assigning sorry I am assigning 15 to y. Therefore, now x remains as it is 20 and y becomes 15. Now, what am I doing in the third step? I am doing x assigned y plus 3 just as I had explained in the last slide just now that I will be actually taking I will be actually taking the content of y content of y whatever y was it was 15 or something I take it and add something to this and store it back to x. That is what I am doing. So, here you see sorry next yeah so x assigned y plus 3. So, y was 15 so that is taken 3 is added to that the result is 18 and where is that loaded that is loaded into x. So, it becomes 18 and what happens to y? Why is not disturbed because here at this point at this sorry at this point why has just been read at this at this point why has just been read? It has not been written into y has been just read I read from this location I did not disturb it I disturbed x. So, I added 3 and made it 18. Here what I am doing I am now disturbing y how I am reading the value of x dividing it by 6. So, 18 divided by 6 will be 3 I am writing that to y. Therefore, now I am disturbing y and y has got a new value. So, now my result now if I had written here print x and y then my result would be 18 and 3 right. So, that is how the variables are handled by a program and I try to explain to you the difference between variables and values. So, you please look at the pseudo code of the examples that we did in the last lecture and see what are the variables and what are the values and try to draw a diagram as I have done today just to have a clearer conception for that.