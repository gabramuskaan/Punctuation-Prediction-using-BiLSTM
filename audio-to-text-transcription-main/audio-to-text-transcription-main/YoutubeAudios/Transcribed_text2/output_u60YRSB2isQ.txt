 We have looked at pointers and structures in detail and we have also seen how structures can also utilize pointers or in other words our pointers can be used in conjunction with structures. Now, we look at another very interesting use of pointers, but in general let me say that it is a very fundamental concept from the memory allocation point of view, dynamic memory allocation is what we will be discussing now. Now, what is when we say that is dynamic memory allocation then obviously there must be something called the static memory allocation. Now, what is static memory allocation? When we declare an array say int a20 you know that the compiler will allocate 20 locations, 20 locations locations to house 20 integers to you and that will be named as A or you can also consider that there is a pointer A which is pointing to the first element of the array, but you have got space for 20 locations, 20 integers allocated to you. So, now you know size of so how many bytes will be required? You can say 20 times size of int so size of int will return you how many bytes your particular system allocates for an integer and 20 such allocations. So, so many bytes will be allocated to you. Now, when that is statically allocated that is allocated at compile time. So, when we say static allocation that means allocation at compile time right. Now, if for some reason you need more than 20 integers to be stored in this array A that you will need to redefine this whole thing or in some cases we do not know we do not have an idea of what will be the how many data items will come. For example, you are actually storing student data student records in an array class and you do not know how many students will join that class beforehand. If you have if you know that beforehand it is fine or if you have an idea that what is the maximum amount maximum number of students that can come then it is fine you can allocate it in the form of static allocation as we do in an array. However, when we do not know and the information comes at run time that means, when is being executed that will lead to what we call dynamic allocation of memory that is dynamic allocation. So, let us look at how we can handle it. So, the basic idea is I have already explained that the amount of data we cannot predict beforehand. So, we will use effective use dynamic memory management memory allocation technique to do that. Now, C language requires the number of elements to be specified in compile time when we define in an array we need to specify that in compile time. Now, often that leads to wastage of memory or program failure. Why program failure program failure because if we exceed the amount of space that has been allocated there will be a failure the program will give an error or it will exit abnormally. However, if we take recourse to dynamic memory allocation we can solve this problem. How memory space required can be specified at the time of execution how can we do that how can we specify the amount of memory required at the time of execution. If while running the program just like the instructions and operators if we had some special means some special command some special operator by which we can grab memory. Now, here you should understand that who allocates memory to us it is the operating system who allocates the memory to us. So, this like the printf scanf all those things are system calls we are calling the we are making calls to the operating system which is doing the required thing for us. Similarly, there is a function called call of memory allocator malloc using which we can grab memory from the operating system. How let us look at this say in memory in C I have got different types of variables I that is not so much relevant right now. What is needed is part this global variables and instructions are there always stored, but the local variables are kept the local variables are there and there is some free memory we can take from this free memory and put it use them as our local variables. Will free region has got a name here. Now, the most important thing is that we need some functions which will give the memory gave my program some memory addresses or memory blocks from the operating system storage of memory which is known as if from there it will come be allocated to my program all right. So, for that we have got four different functions one is malloc. What does malloc do? Malloc allocates the requested number of bytes and returns a pointer to the first byte of the allocated space. So, what it does is something like this. We can break code of the, we can break code of the, could I mean. Malloc allocates a requested number of bytes and returns a pointer to the first byte of the allocated space. So, let us try to explain this. So, when I do malloc malloc is just like a function will return me some memory bytes all right some memory bytes. How many memory bytes? Will depend on what I am, what I am requesting for it is a requested number of bytes. So, malloc will have some parameters which we will show later. So, it will give some, give me some amount of memory and how do I know. Now, the operating system has got some free memory spread here and there. So, from there it is giving me some piece of memory. But how do I know where is that piece of memory? For that it is returning me a pointer say pointer p which is telling me that ok. Then if you follow this pointer you will get this piece of memory location all right. So, let us proceed a little bit. Now, similarly now when this is given that memory block is given in response to malloc request the actual memory is not initialized to some value. It can have any garbage value. But if I apply caloc C aloc then it allocates space for the area of elements, area of elements and initializes them to 0 and returns a pointer. So, in this case if I want to have a chunk of memory where everything has been initialized to 0 then I should use caloc. On the other hand this free what it does the free function call will return this amount of memory that was given to me in request to malloc it will be returned back to the heap return back to the operating system. So, that it can be utilized by somebody else in future all right. So, and realoc modifies the size of the previously allocated space. So, I have got some allocation and then I think that allocation is not enough I want to change it I can use realoc. However, will be mostly concerned with malloc and free in our discussion. So, a block of memory can be allocated using the function malloc and it reserves a block of memory and returns a pointer of type void. You know every pointer has got some type but in this case when malloc returns some memory block the pointer that it is returned is of type void but then we have to do something what do we need to do. I know why I needed this memory I need so accordingly I left to do that type casting all right. So, now the return once it returns me of type void but that return pointer can be assigned to any pointer type. So, here you see. So, here please note malloc has got a parameter byte size how much memory I want how many bytes I want. Now, this malloc has returned me up to this it has returned me a pointer and pointer is of type void but I type suppose if this amount of memory I want for the purpose of storing integer array then this type will be int star that means I am casting this what is malloc returning. Malloc is returning a pointer some pointer but that pointer was of type void of type void. Now, when I am type casting it to int star then this void is no longer it is of type is becoming of type int and then I am assigning it to another variable PTR. So, think of two things first of all you have to decide on how many bytes you want accordingly you do malloc and then what type of data you want to store there. So, accordingly you do this type casting like int star float star, cad star whatever you do and then you assign it to a particular pointer. Let us see how it will work. So, let us look an example here how do I know how many bytes I need suppose I need to store an element an array of 100 integers. So, what I do here is I ask for malloc 100 times size of int size of int if it is 4 if int is 4 then I am getting 400 bytes. Now, these 400 bytes that have been given to me is being pointed by some pointer of type void. So, next I make it in star and put it to P. So, P is now an integer pointer that is pointing to this entire block of 400 integers. So, a memory space equivalent to 100 times the size we have got. So, here 400 bytes of space and P is a pointer pointing to the beginning of this. So, I have sorry I have got this just using malloc it was not declared beforehand. Now, so this 100 can also be a variable n if I read a particular variable n. Now, how many students are there scan F and n. So, I read the number of students then I can multiply that with n as well. Next you see here I am initializing to I am seeking memory for 20 characters I do malloc 20 because I know a character takes 1 byte and then the pointer is of type void I am type casting it to type character, character star and assigning it to Cptr. Now, it is actually wrong it is allocating 20 bytes of space for the pointer. So, structure start now for example, I now need so integer character was simple. Now, I want to have for space for the entire structure students. Now, that size is larger. So, I do not know. So, I just employ this function size of structured. So, I get how many bytes it requires say 40 bytes and say tens as for tens as students or n such students I multiply with that I get so much memory. Now, I have to type cos that to struct start star and that goes to a as a structure pointer. Now, malloc always allocates a block of contiguous bytes. Now, it may be that sufficient suppose you are asking for 100 bytes and 100 bytes are not available then malloc will not be able to allocate you the space in that case malloc will return n null that is a null pointer. That is a special character special value it will return that shows that I could not allocate a space. So, I could not allocate to you a valid pointer. So, it is a null pointer meaning thereby that I could not I failed in allocating you memory. So, here is an example here you can see let us look at from one side I n float is a point height is a pointer of type float some is 0 an average. So, what I am trying to do probably I am trying to find the average height of the class. So, input the number of students and I am reading amperes and so this one is amperes and n. So, this is n number of students. Now, see I did not know how many students are there. So, I am getting this number of students here I am getting n number of students here. Now, I want to have so many spaces for the height. So, what I am doing I am allocating n number of spaces n is a variable here and some size of float whatever size of float is 4 bytes. So, n times 4 bytes so much space is being allocated and the pointer is height height is a pointer of type float. So, this pointer is being type casted to float. Then I get the inputs can if in a loop I am getting the inputs can if in a loop I am getting the heights one after another in an array and I am finding the sum of the heights finding the average of the heights where I am dividing sum which is a floating point number with float n here is another example of type casting. So, you see I am dividing by n, but this is a floating point real number n was an integer. So, I convert it to float and convert it divided. So, this is how maloch works now. So, we have explained that. So, now how do we we are allocating space? Similarly, the general format for freeing space is using by using the free function. So, general for now suppose I have got a space allocated to me some space is allocated to me and that space the only handle to that space is to the pointer p. So, I free that pointer I free p. So, that pointer is free that means, this pointer is free means this location this amount of memory goes back to the storage of the operating system and that is the heap. So, we whatever we got in maloch so that gives us some idea about how we can get space and reallocate space. Now, briefly we will be talking for the next 5 or 10 minutes on file handling there is not much to understand about file handling this you will learn as you do. Now, what is a file that is something you have to understand file is something where wherever I want to write something write or read from. So, I want to store something I I will take a particular file all right I will take a particular file and I will open that file and then I will write into that file then close that file and then whenever I need in that way I may have 10 files. Now, at a particular point of time I want to read a particular thing. So, I choose the particular file what do I do next open the file and read the file. Now, some files may be allowed to be read by others some files can only be written into and not read from some files can have the option of read or write both. So, file is some space where I will be writing or reading from some storage. So, this is there in the secondary memory and what till now whatever variables we are talking about those were all in the primary memory. So, if I store it in a file it goes into the secondary memory. So, let us have a little idea of how files are handled. So, now again now we have learnt pointers. So, any file can be accessed using a pointer just as if I have the file of income tax. So, I will have a pointer that there is the file of income tax here there is some file of road tax it will be here some file of your salary it will be somewhere here some file of your expenses it will be somewhere else. So, there will be pointers. So, we use in C the sorry we use file star we use file star and we will use the file star to represent pointer to a file and if open is the command for opening a file if a file cannot be opened then it will return a null just as in the case of malloc we saw if nothing could be returned it was returning a null. So, here for example, you see F p tr is a pointer of type file that means F p tr will be pointing to file. Now, I have got a character file name is an array file 2 dot that it is a data file. So, F p tr is F open file name and here when I do F open I give the file name as well as the mode in which it can be opened the mode in which it can be opened and this w means it is in the right mode. So, what have I done here I have called F open. So, I am trying to open the file if the F so this F open will return a file pointer now if this file pointer is null that means, there was some error in file creation otherwise it will go on doing something. So, quickly let us look at this when I do F open it will open a file and you will open it in a particular mode read or write whatever I specify and it will return me a pointer if a file is created successfully it will return me a non null pointer. The second argument of F open is the mode and there are three modes where a three modes are is the file is open for reading w means it creates a file for writing and writes writes over all the previous content. So, if I open it in the write mode whatever content was in that file is erased and a opens a file for appending that means, whatever is there after that it will be added. So, if you have got something already stored and you do not want to destroy that and you want to add something mode to that you will open it in the form in the mode a and R b reads a binary file robots we did not bother about that and there is a function called exit which you have seen that exit for sometimes in the emergency we can put exit minus 1 that means, it tells that I have exited in the function without success. Now, here you see use of exit file F pointer character file name is an added file to that I try to do something so, the file pointer was null. So, if it be null then what can I do I will have to exit because of some reason the file could not be created. So, that apart so, F open we have seen F print is a very important command F print works just like print F and F print F except that the first argument is a file pointer. So, we will see how it works. So, F PTR is again the file pointer and I have opened the file file dot that in the write mode. Now, F print F means now I am printing where am I printing a file called file dot that has been opened the name of the file is file dot that and how do I identify it I identify with the F PTR the file pointer. So, I am writing it is open in the write mode so, everything whatever was there has been erased. So, I am writing just as you have done print F then automatically by default it goes to the screen here it is not default here I have said F PTR so, whatever I write hello world it will be written in this file not in the screen. Screen is another file but that is a default file reading data similarly we printed using F print F reading we can do using F scan F forget about that part look at this F PTR I am reading from not from the keyboard now I am now not reading from the keyboard I am reading X and Y to integers from a file which is pointed out by F PTR and what is that file F PTR I have opened the file input dot that. So, you see in that file input dot that 20 and 30 was written and so, F scan F I have read that that was input dot that from I have opened that in the read mode in the read mode and I am reading from there so, I am getting X to be 20 and Y to be 30 not from the keyboard but from the file. So, in that way we can now here are some powerful commands just to know we can read a string using F gets from a file I can read a string. So, here you see a file is F PTR and a line a file is F PTR and a line is of size 1000 while F gets line is not null that means, I am getting from F PTR I am getting a value and if it is not null that means, it is not the end of the line I mean I have got the file is open I am reading the line using F gets I am getting the line F gets takes three arguments what are the three arguments it is taking a string a maximum number of characters 1000 and a pointer from it returns if there is an error such as end of F end of file U F is end of file. Now, this I think you can understand much better when you use now when we open a file after that we must close that file we can simply to use the command F close and the file is closed and closed. So, here you see F PTR I opened a file in the right mode I have print written hello world over here F print F means I am printing in the file and then I am F close I am doing F closing the file by F close F PTR. So, here it is opening and here is access and here is closing we have got you have seen that F is closed and here STD in STD out where two special cases of files which are default files and STD error was the printing of the error. So, here is an example program you can see that main F print F STD out give value of I that means, where am I printing this I am printing into the standard output I am reading I from the standard input. Now, F print F I am writing that the value of I is whatever value of I read. So, and there is no error. So, give value of I it will first be give value of I you give 15 then F print F that I then it will say value of I is 50 is equal to 15 and there no error but an example to show error message. So, if you do this STD error then you can if there is an error. So, for example, I am return I am being returned a null pointer in that case I can use some output a STD error and say the file fail to open the file that sort of message. So, now another thing I will just talk about here that will come in very handy to you that is say for example, must have you must be running the programs and after you compile the program and link them you are creating an executable file which is a dot out dot slash a dot out. Now, usually what you do you have got the dollar those of you using Linux shell a dot out and return. Now, this a dot out in that case dot slash a dot out what it is expecting the input from the keyboard STD N and the output is going to STD out but I do not want that I want that I have got a file I have got a file where my input data is there and I call that in dot that and I have got another file that is known as out dot that I want that the input be taken from this. So, I want a dot out to read the data from here and the result should be written here. I can do that in the Unix environment very simply by this redirection operation you see a dot out will run taking data from in dot that and sending the output data to out dot that. So, say for example, in dot that has got 15. So, I do that and the program runs and says give the value of I think of the earlier example earlier program that we are thinking of give the value of and it means the it reads from here and it means the value of I is 15. So, that is coming this whole thing is coming in out dot I. So, let us once again look at this thing here instead of STD out dot here I am asking them to give the value of I the value of I is being given and that is being scanned from the input file and this is being written on the output file. So, in the output file both these things are being written. Consequently, you see what am I getting is. I will be getting this output this is my output out dot that and in dot that there are two files. So, this in this way you can use files for storing data you have to open the file let me summarize a little bit you will have to open the file if you want to read in the read mode read the file from there read the data from that file do the operation open another file in the write mode and write the data into that file thereby whenever you require some file operations you can easily do that and this is one example that we have shown which is very common when you during running your programs if you store some data in a particular file and read from there and write into another file you can utilize this sort of structures this sort of commands. So, thank you very much I think you have got an overall idea of how to write C programs and programs and solve problems using programs because our the essence of our course was to solve problems through C programming. So, you should choose different problems and you should try to write commands sorry I will try to write programs for solving those problems. So, first you have to find out the proper algorithm and then write the C code for that you have learnt everything about basic things about the C programming I have not touched upon some special features which you can also learn from the book like static variables and all those I have left out intentionally. So, that you are not overloaded you can solve it you can the more you run the programs using the basic concepts that has been taught it will be a good programmer and most importantly you will be able to think logically like a programmer you will be able to think of an algorithm and you will be able to translate that into a program. Thank you very much.