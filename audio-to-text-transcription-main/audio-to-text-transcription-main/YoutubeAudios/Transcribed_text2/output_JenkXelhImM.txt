 In the earlier lectures, we had discussed about one dimensional array as well as two dimensional we have seen how one dimensional array can be stored, read and printed and as well as we saw how a linear search can be applied over one dimensional array. Similarly, we have seen for two dimensional arrays how it can be read, it can be stored, it is stored in a row major form and how it can be printed. Now, today we will start discussing on a very important and vital component of programming and also a part and parcel of the C language that is functions. The concept of functions is very general and we will have to first look at it from the general angle why it is required what is a function and then we can look at some of the details of this, the implementation of this concept in the C language. So, first let us start with functions. So, we will start to visualize a task, suppose I have got a big task, which I have to implement by programming. Now, any task this is one task, this task may be too complicated and for any human programmer or any human being to solve this task from the beginning till end in one shot may be difficult. Often what we do we break up this task into a set of smaller subtasks, different subtasks and each of these subtasks are smaller enough, small enough so that we can manage it better. Each of these are possibly better managed. We can say if you think of a program segment, a part of a program, if the task is broken big task is broken down into a small task, a number of small tasks then it is easier to write the program for each of these smaller tasks and each of these tasks can be independently tested for its correctness whether it is working properly or not. Each of these can be separately tested and then if all these are connected together, if all these are connected together one after another and then I can ultimately get this entire task done. So, instead of addressing the whole task in to execute the whole task or implement the whole task as a single task it is often advisable to break it down into a number of subtasks. Now, let us talk about programming. Now, if we want to now what is a when we say the term function, function if we take the English meaning of that function is means doing something. So, it is a also a task therefore this entire function can be broken down into smaller functions and each of these functions can be implemented independently. So, the advantage that we get by this means is that we can divide the problem into smaller parts and thereby we can conquer the small we can conquer the smaller subsegment and in the process we in the process we achieve the complete task that is the first thing. So, by this it is easier to implement and also easier to test or verify. We can check whether each of these components are working correctly or not. Now, when we find that all the components are working correctly and if they are connected together correctly then we will have the entire problem solved correctly. That is the first advantage of writing a complex program broken down into smaller functions. Now, the other advantage is suppose I had to implement one task and in order to implement this big task I had to write a number of functions smaller functions say three smaller functions together implement this big function. So, let us call them F 1 function 1 F 2 for function 2 and F 3 for function 3. Now, suppose I have now this problem has been solved by solving each of these three functions, each of these three functions have been written and tested and consequently they have been connected together and we have got the complete function. Now, suppose another friend of yours wants to write another task solve another task say this was this was also a task. So, this is also a function I am writing that as capital F 1 and there is another friend of yours who is trying to complete another task which we are naming as F 2. Now, in order to develop F 2 he finds that okay I have to solve some problems which are solved by F 1 and another problem which is solved by F 3. Might be that this sub problem requires F 1 F 3 and say another function which was not written by anybody till now F 4. Now, obviously since F 1 has been written and tested he the writer of F 2 did not write F 1 again because that F 1 this F 1 can be used for this purpose. Similarly, this F 3 can be used for this purpose and only effort that he has to spend is to write F 4 thus the functions which are written already right can be reused. So, this reusability is another very important advantage of writing functions. Now, we have said that in order to solve F 1 or F 2 we have to write we will have to independently write and test smallest functions and connect them together. What do I mean by connecting them together? Let us try to understand that. So, say we have a function that is to be done developed and we find that okay this part has to be this part this task has to be solved by some function. So, I write a function here for this part let me let me let me let me do it again. This is my whole problem that I have to solve and so I am solving some things here some steps I am solving and then I find here there is some thing that has to be done which is not very easy so for that I came at this point and for this I need to write a function or might be there is a function already existing in my library which has been written by somebody else which I can reuse. Now, in that case and also say here after doing that here I can do a couple of simpler tasks and then here I come to another point which requires it to be independently solved and written. So, I need a function for that and then after that I will do some more simple things and my task will be over say this is the situation. So, when I come here I will have to I means this program which is the main tasks main task that I have to solve. So, since we have seen the name main in our description for C earlier let me also name this to be main. And I am just for nothing I am just putting some parenthesis here. So, main is the main task that I have to do and at this point I am doing some things and here I need the help of this. Now, remember that this function whose name is say F F 1 that can be used by my main function or somebody else's main function also. Therefore, when I need this to be executed with my data then I must whatever data I have prepared here that some of that I will have to pass on to this here. And this will solve this sub task and then I will have to that means that this must give back whatever it computed to the main task and the main task will continue doing simple things here. So, you see that there are two links one is going in the function another is coming out or some data that is being returned by this function. This is being returned by this function. Then I carry out some task simpler task here and at this point I find no I need help. So, some part of the data from here will be used by the function F 2 and that has to come to F 2 here and F 2 will carry out the task and will return to the point here. Now, about this return you should observe one thing that the function was called from this point. We call this thing to be a function call function call with some data being passed on to this and function call or function invocation and after invocation this function works and it returns where does it return? It returns to the point in the main task just after the point from where it was called it was called from here. So, it comes here and then returns to the next point just after the after this call. So, this is the calling point and this is the return point. Similarly, for here you see that it is executing and at this point it is being called and after execution the control is returning to the point immediately after the point from where it was called. So, this is one important thing to understand. The other important thing is that let me draw it again. Here I have got my main task and this is my main and here is another main task, some other main task not written by me but somebody else this is of Mr A and this is of Mr B for Mr B there is he has written another main. Now, Mr A or Mr B both will require this function f. Now, the task the purpose of what this task does is same. For example, this task is computes the average of some numbers 10 numbers 5 numbers whatever it is or maybe floating point numbers integer numbers whatever it is it computes the average. So, let me quickly rename it not keeping it vague any longer. Let me call it average or for a specific purpose I want to write it inside the region will be clear immediately this computes the average. Now, Mr A wants to use this average function for some data for 3 data he wants to compute the average of 3 integers. Suppose this one computes the average of 3 integers but the integers can vary. So, this also wants to find the average of 3 integers to make it simple but the in numbers for which A wants to compute the average is different from the numbers that B will compute the average for but this AVG is common to both therefore. Suppose the numbers that some integers say are A B and C and here this person wants to find the average of 3 integers which are P Q and R 3 variable names. Now, this average cannot remember P Q R or A B C it will simply just like think of a box with 3 pipes coming in and data will come in through there. So, he just names this average for he names these pipes as X this is Y and this is Z. So, when this function main wants to compute the average of A B C he must send A through the pipe X B through the pipe Y and C through the pipe Z and he will get the average computed and the average will be returned from the point where it was called it was called from this point immediately after that it will go back clear. Now, when let me change the color now when the function main B B wants to compute the average he wants to compute the average of P Q R so P will be sent to the pipe X Q will be sent to the pipe Y and R will be sent to the pipe Z and the average will be computed suppose it was called from this point from this point this average was called. So, then it will return the to this point with the value of the average with the value of the average whatever is computed here therefore, so if this is clear then let us come to two more terms they are that this function main A A is main was sending A B C to the function as parameters we call it as parameters and this function which is our average function is not biased to A right it has got it knows that it needs three inputs and there are three input pipes three input positions. So, this X Y Z are arguments this we call as arguments all right that means this average when it is written it has got three input pipes. So, we can write simply like this function name average with three arguments X Y and Z now whoever calls it we will have to establish the mapping between the parameters that it wants to pass the parameters it wants to pass through the to the arguments. So, the connection that we had shown in the earlier diagram which was where both the programs were both the programs were accessing it. So, each of these parameters should the parameters should be matching with this arguments let us come to this once again say. So, now so here is main of A and here is main of B I repeat what I was saying till now and this has got P Q R now you must be must have realized now what are these P Q R's when I use this function average which has got three arguments X Y Z which are nothing but three pipes which are arguments and when I call from some point when I call this function average then I have to pass these parameters P Q R to these arguments X Y Z. So, P will go to X Q will go to Y and Z R will go to Z on the other hand when A is calling when A is calling what is happening when A is calling then A had the A B C to be passed on to this. So, A goes to X B goes to Y and C goes to Z. Now, since now if you just think these are three pipes now the pipes are every pipe has got a width. So, if I want to fit a smaller pipe into a bigger pipe that own fit right. So, the width of diameter of both the pipes must fit together what I mean by that what I mean by that is that whatever arguments are whatever are the types of the arguments that must match the types of the parameters or in other words the types of the parameters also must match the types of the arguments so that the pipes fit there should not be any mismatch over there. So, let us take a little more deeper look here. So, suppose I have got a main function here I am not so much bothered about the syntax now and the main main function is running and here I want to say say result is average of A B C and etcetera etcetera etcetera and the end here and let us assume that here I have declared in A B C both of them are integers now we have got the function which is average. Now, this average of three integers can be a float so I just write I will explain it a little later float average x y z and I can say in x y z and whatever I am computing average here and so thus this is simple you can have int sum and sum equals x plus y plus z and average is equal to x plus y plus z by 3 then I write return y divided return I will come to that now look at the two things A I will talk about this part a little later here I have declared A B C to be integers. So, in the memory for A B and C two bytes or four bytes as the system may demand that type of that much memory has been given ok. Now, when I write here A V G that means I am invoking or calling this function A V G and I am passing on A V G requires three parameters x y z and x y z are all integers and I could have written there is another way of writing it that I could have written here int x into I in z that is also possible but later we will see that now. So, A B C there is a correspondence between A B and C with x y and z and they are matching in the type then this computation so we come here then follow my blue line this is being computed and ultimately the value of average is computed. Look that the value is being computed in A V G which is also the name of the function. So, in a way you can say that the name of the function is just like a variable that is holding the value that is holding the value. So, that average any variable that is holding a value must have a type that is why since average of three integers can be a float therefore, we have to assign a type to the name of the function designating what type of value it is returning. So, here we can see that it will compute average and then there is a statement new statement that you are encountering here is return where is it returning it is returning to the point from where it is called at is this point and so the average suppose if the values are 1 2 and 3 then the average is 2. So, then 2 goes to this A V G and that A V G is being transferred to result. Now, if I do print result here 2 will be printed. So, this is to give you an idea of what is meant by in calling a function in working a function what is meant by returning from a function and water parameters and arguments. We will see more of this in the subsequent lectures, but you should also understand why we do this the reasons are 2 fold as I said one is to divide or break down a complex problem into manageable sub problems and the second and test them independently and the other issue is other advanced big advantages that once we make a thing a function which is tested we can keep it for being reused that is a very very important thing and this concept is general over different languages like we have got class etcetera which we can reuse a number of times and this is this idea the implementations are varying from language to language, but the concept is common and is used in different languages. Thank you and we will continue with functions this subsequent lectures.