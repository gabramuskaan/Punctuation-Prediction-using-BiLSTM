 So, in the earlier lecture we have seen how a function can be invoked and it returns the values. As we had mentioned that it is not the case that always a function will return a value. Here is an example. You look at this function, D7 which says that means the purpose of this function is to find out whether a particular number that is passed on to it as a parameter or a parameter whether that is divisible by 7 or not. So, the program the code is very simple. What should we do? If n is divisible by 7 that means if n modulus 7 is equal to 0 then we say printf n is divisible by 7 otherwise we print n is not divisible by 7. Now, in this case we are just printing from here straight the printout is coming printing is coming out from here. The main function is only passing on the value reading some value of n and passing on that value of n here or maybe here it is n is the argument. So, might be the main program is reading a value num and passing that value num here. Now, this num is also type integer and the rest of the things are being done by the function. It is testing whether it is divisible by 7 if it is divisible by 7 is printing like that otherwise it is printing the other message. Now, in this case putting this return is optional because if n if I did not put the return because even if I did not put the return when I would have met this parenthesis this n bracket it would automatically return to the calling point. However, there is no harm if I put the return. So, returning control we have seen that how the thing is invoked by parameter passing. Now, returning control if nothing is returned then you can simply write return semicolon or we can skip that and until it comes to the right brace that is last right brace that is automatically taken as the return. But if something is to be returned if something is to be returned then we must put the return statement with say may be return a times b some expression or it could be return c or it could be something. Like return 0 or return 1 whatever we have to do something some expression and expression automatically or I mean you know will also capture the constants. So, now let us look at this example here you see the layout is also important here we are first writing the function the function declaration is coming first square of x square of an integer x and square of an integer x will also be an integer. Therefore, the type of the function is int as you can see here. So, that is this whole thing is the function declaration then starts the body of the function. So, here the function declaration consists of the name of the function and the parameter that is x of type integer and this int here is a return data type the type of the data type that will be returned. So, these three together make the function declaration next we are coming to the body of the function int y what is that that is a temporary variable. Temporary variable why I am calling it temporary because it leaves as long as this function is active as soon as the function is function ends the role the definition of this y is also lost. So, here you see will come to that later but here you see that this is an internal variable here I am computing the square y assigned x times x and I am returning y and after return that y vanishes. Why where is y returning to wherever the square has been called now here you see here is a sum of square what is mean doing now let us come to mean mean has got some variables a b and sum of square is another variable. So, print f g v and b I am reading a and b now I am calling this function twice first with the parameter a next with the parameter b and a and b how I mean in sequence goes to this argument x and the square of a is computed. So, return y will return first here a square so we get a square here then this is called and y is returned here so we get b square and then these two are added and we get sum of square. So, you need to you can also try to see what is a flow of data in such cases let us move ahead. So, these are the parameters past and here are the here is the argument you can see that now invoking a function call here the same thing what is happening when the thing that I just now explain when I am saying now let us see what happens the variables assume that the value of a that is been read here is 10 then square of a mean square of 10 so 10 goes to x. So, a is 10 here that goes to x so x becomes 10 now we compute y which is 10 times 10 I am getting y y is becoming 100 right now this 100 is coming here actually actually the saddle is a little wrong here so it will be actually coming to this point clear. So, in that case similarly it will be for b if b was some value that is how then x suppose b was 7 then x will get 7 and then y will be 49 and 49 will come to that square of b. So, 100 plus 49 will now be added and will be kept as the sum of square. So, in the earlier example you could see that in the earlier example the first the function was written and then the mean. Now, let us look at go ahead function definition so we have seen that a function name preceded by a return value type and declaration statement and then the function body I am repeating certain things variables can be declared declared inside the blocks the blocks can be nested that means they can be multiple blocks function cannot be defined inside another function. This must be clearly understood a function cannot be defined within another function and returning of control the control will have to be returned as we have seen if nothing returned then return we have already seen that if something is returned then return that expression here again another example of function the more examples you do the better you will understand. Here the function as the name implies you see it is always better to use meaningful names for functions some of digits of n. So, if there be number like 125 then I am trying to extract this digits 1 plus 2 plus 5 so that will be 8 that is what my program wants to do. So, initially some is equal to 0 while n is not equal to 0 some is some plus remainder so 125 if I divide by 10 then I will have 12 here and remainder is 5 so some plus 5 so some becomes 5. Now, then we find out the device dividend that is 12 and again divide that by 10 we get 2 to be the remainder so we take some to be 5 plus 2 and so on so forth ultimately I am getting the sum so return some this another example of a function here you can see that we have to be given the number of digits. You can see that this n is coming as a parameter all this sum sum is an internal variable and will not have life beyond the body of the program. So, here you see some of digits is a function name int is a return data type parameter list is that local variable is some some is a local variable and return statement is return some clear all this we have already discussed this is merely a division and here you can see that the return can have an expression here only a variable is an expression. Now, we come to a very important concept which I was mentioning in the passing that the life of an intern variable internal to a function exists as long as the function is live as long as the function is active. Now, that formally is known is called the scope of the variable or the variable scope. So, let us look here there is an interesting program. Now, here you see my entry point is the main but even before that I have declared a variable int a that means this a is a global variable. That means it is there always suppose it is a value 100 then it remains that this is retained. So, let us keep this and let us see what happens. Now, I am entering main and I have assigned a to 1 now that means now inside this function inside this main I have got mains a which is another a let me write it in is it visible let me let me do it in a better way. So, there is 1 a I am calling that a g that is this a is a g that is the globally and suppose that is 100. Now, this is another a which is defined in the main so the function this will be live inside main so let me call it a m. So, now a becomes 1 here as I come here a 1 then I am calling my proc a function my proc from here it comes to my proc and suppose my proc has got another a here. So, let me call that to be a x just for understanding that it is of my proc or let me call it let me call it of the function. Now, that is initialize to 2 now you see how many different a's I have multiple a's now inside this block I initialize another a to be 3. So, that is another a that means this one is not being disturbed a is to when while a is to I am making another a because here I am declaring you see this is a pure declaration in t. If I had just written a if I had just written a assign 3 then this a would be assign 3 but here I have declared another a in t therefore, there is another a coming within this while block that I am calling a b and that is becoming 3. Now, I am printing a which a will be printed the inner most the current a that means 3 will be printed then I break break means what I come out of the while loop we have learnt break so we come out of the while loop and then I print a which is so as soon as I break out of this this is gone no longer live. So, I am coming here now which a is in my scope which a is in my scope my scope is this I am within this function so these say so that will be printed here so 2. So, there is some backstation I am ignoring them that will come one of another and then I come out of this it is over so I go to this main fun go back sorry not here I am sorry I am sorry it should go back to this point that means I will now execute print which a is in my scope now I have come out of this. From out of this function so the its scope is also gone so the scope of this function main is now live so what is the value one so that will be printed that is how the things will be printed so we will repeat it if necessary but let us try to see the execution now. So, if I first do it then this one will be printed a assign 3 next that is gone so here a will be this will be assigned a assign 2 then I will go up there and the a that is in the scope of this function that will be assigned and then so that will be assigned. You see although I declared a global a internally when I declare some other a this global a I have look here a point has to be seen I declared a a global a here a global a was here a g that was declared. Here I have assigned to a I have not declared another a I have not written in the I have simply written a assigned one that means the a that was there is already existing globally that has been assigned one. But when I come here and I am declaring int a internally inside this process another a is created which is the a of the function and that is assigned by with to 2 not this one they are two distinct entities now again here I have declared another a. So, since I have declared another a this is the a of this while loop might be and that is becoming 3 and accordingly the corresponding whenever I say print which one will be printed which one will be printed will be the one that is within its scope this a is in the scope of this so that was printed this and gone this a was in the scope of this. So, this is so printed and gone and this a is in the scope of this and this is so this is known as the scope of variables. So, if we summarize functions you can see this I do not know how much is visible. So, main function I am calling a function factorial and we have already seen that and then the function is having different it is a self contained program which has got its definite named function definition. Where the type of the argument is also specified now main is a function and here I am calling a function I am actually calling a function by name calling by name and is a return data type repeating that the function name is there the parameter is there and the return statement. And the other variables like temp and all those are local variables we have repeated now some point is a function cannot be defined within another function which we have told but I am repeating it again all function definitions must be disjoint that means I cannot define one function within another nested function calls are allowed what is meant by nested function called nested function. nested function called means that suppose here is a main program going on I call a function this is function say f 1 and this was my main from some point in the function in order to solve this problem f 1 I may call another function f 2 this is nesting calling but not defined they are defined separately f 1 defined separately f 2 defined separately m defined separately now from f 2 I may call another function f 3 and f 3 completes f 2 has called f 3 because of some reason. So, that reason is answered I mean for some value or for some computation that computation has been done from here it returns to the point from where it was called so this is a return point. So, is it clear or should I use some other color for the return point is it necessary. So, I am not getting the color so let me let me use the existing color whatever was there so where did not go. So, from here now the color has come so I can show the return here I am returning but then again I am continuing with this function and when f 2 is over then I again return to f 1. So, it was called f 1 called f 2 for some purpose that purpose is solved so I return here and then f 1 continues again in its whatever it was doing and f 1 was called by mean for some particular reason when that purpose is served then we return to this point and then main continues and ultimately main ends with this function. Now, here this is known as nesting that means I nesting of calls so I have made a call and from that call I can make another call from there I can make another call but the point to point to note is that all these functions must be independently and separately defined. They cannot be defined one among the other so nested function calls are allowed a calls b b calls c as I have shown m calls f 1 f 1 calls f 2 f 2 calls f 3 like that it can happen. The function called last will be the first return obviously we have seen that in our earlier slide that we go back to the f 4 from f 4 I return to f 2 and like that and so a function can call also call itself either directly or in a cycle we will see this separately what is made by that a calls b this is this function is called as f 2. This can mean two ways one is that say a calls b b calls c calls back a that is possible like say here if we see that mean was running it called f 1 called f 1 f 1 called f 2. And then f 2 can again call f 1 and then this call ultimately for this call the return has to come here and ultimately it will have to return here etcetera. So, this part will have to see separately that is it is a function one function is calling another and that can mean a cycle f 1 calling f 2 calling f 1 it can happen or recursion means say a particular function f 1 calling itself f 1 is calling itself a number of times that requires a special attention and a special discussion that we have to carry out. We will do that in the subsequently but right now just let us remember that this calls can be in a cycle or it can be called to itself which is a recursion. Now, we have got some math library functions which perform common mathematical calculations and I do not remember whether in an earlier class I mistakenly said that I had mistakenly I do not remember exactly whether I did that or not that you need to include just as we include math dot STDIO dot H. Similarly, we have to include math dot H. So, just as we include STDIO dot H if we use some mathematical functions which are already available in the C library we have to include math dot H. I do not remember whether while first introducing the square root function I have might be mistakenly mistakenly I wrote math dot lib that is library function. So, dot lib if I had said that you should ignore it is math dot H include math dot H and so here there is an important thing. When I compile you know any function that we any program that we write we have to compile it in order to get an executable code. Now, in your exercises you must have done by now that typically you compile a C program like this C C myproc dot C. But if you use some mathematical library in your function then you should write C C minus L M myproc dot C or that means link to the mathematical library. You compile first you compile now you see what is happening is the mathematical libraries are here say some square root function somebody has written for you and that is in the C library. Maybe some other function like two upper which converts from lower case to upper case all these things are there. Now, two upper is a separate library where square root is a math library. So, if in your function you if in your program you write you refer to the square root some mathematical library then you must do this why because purely myproc dot C will generate some object code. Now, the code for this has to be linked to this has to be linked so that your ultimate is a full executable code also takes this into account this code linked to this code will be forming your executable code because the square root will need anyway at the time of running it. So, here it has is shown minus element the later also C C program name and then link with the mathematical library format for calling the functions. So, forget about this let us make it for the time being ignored this just say percentage F function name. So, this is point number one there are many mathematical library functions in order to include in order to use them we have to include immediately after a studio dot H hash include math dot H and we must use this give this linking command. Now, when we call the function the function name argument if multiple arguments then we can use a comma separated list say for example, if some format the square root 9 there is only one argument not much arguments may be constant variables or expressions all math now this is important all math functions all math functions return the data type double this is important you should keep in mind this for C. All the math functions are returning the data type double so in order to make it compatible with the variable where you accept the value return by the math function that should also be double arguments may be constants or variables. So, here are some examples of math library function like finding the cost of some angle x finding the sign that all these functions are known as assign a cause a tan inverse tan arc tan ceiling function flow or function flow or function means it finds the greatest largest integral value that is less than x suppose some is 200.56 so the largest integral value is 200 that is the flow or function. So, a cause is finding the cost of an angle in degree whereas a cause sorry cause is for finding the cosine of an angle in radian now there is no point in memorizing them as and when you need them look at the manual look at the book and very soon you will get a custom to the different library which are available for C. And we will come back to this in the next lecture about some more well known functions which you have already encountered with and then we will proceed further with recursion. Thank you.