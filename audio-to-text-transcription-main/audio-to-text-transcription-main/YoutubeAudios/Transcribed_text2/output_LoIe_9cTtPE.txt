 Today, we will be discussing on a new concept of programming, which is very interesting, but possibly not very much familiar to you, that is known as recursion. You know repetitions, how they are implemented in C programming. For example, whenever I want to do a particular work, for example, I want to add 10 numbers, then I add the sum with sum plus sum a i with i equal to 1 and then I repeat it i plus plus and I go on repeating it and this repetition is done in the form of a for loop or while loop, you know that. Now, recursion is a different way of doing this when a function calls itself. That means, a function, a particular function will have some inputs and will deliver one output. Now, a function has been, now you know nesting of functions that in order to achieve this objective of taking these inputs and delivering these output, a function could call other functions from there another function and then ultimately return to this function, return back here in that way it could be done. This was known as nesting, but recursion is a little different. It is that here there is a function, which is supposed to be to deliver some output. Now, in order to do this, it is actually repeating itself. That means, let me give you an example. Suppose, I have a machine which can generate one apple, it can generate one apple, produce one apple or maybe say apple, let us say it produces a vending machine which can deliver one coke, one piece of coke, one can of coke. So, you put in some input, some commands and it gives you one coke. Now, it has been asked to deliver five coaks, five coaks. So, how can you deliver five coaks? It can deliver only one coke at a time. So, as we know in our knowledge of iteration, so this is some function, function is delivering coke. So, it can be repeated, this switch can be pressed, there is a switch, it can be pressed five times. So, first one coke comes out, second coke comes out. So, that means, this is being repeated five times. That is the conventional one coke. So, that is the conventional way of iterating, repeating the same thing in order to get the five coaks. Let us try to do it in another way. Let us assume that this machine can deliver one coke at a time, but it can also clone itself. So, let us see how it looks like. So, I need five coaks. So, five, but I can deliver only one. So, I saw that, I can deliver only one coke. All right, I will deliver one coke, but I will not deliver it till I am ensured that all the five coaks are deliverable. So, what it does? It clones itself makes another one copy of itself. And activates this with I can deliver one coke. So, I ask him to deliver four coaks. Now, this one can also deliver only one coke and finds that, I cannot deliver everything. So, I keep one coke ready what I can, but I clone myself and another copy, I activate him this machine and say, please deliver three coaks, but it cannot also deliver three coaks. It can deliver only one. So, nothing is being delivered, but only kept noted. So, it puts somebody, another another clone, please deliver two coaks. I have got one. So, it is also not delivering because it is not being able to satisfy the request of two coaks, which was posed to it by this machine. So, it now comes to another clone. So, asks this clone, please deliver one coke. Now, as you know, this machine can deliver one coke. So, now, it delivers one coke and tells, I have delivered. Now, this one then, okay, since it has delivered, it delivers the other coke, which it could do. It also tells the, it is requested, it is earlier, I mean of the earlier version, that I have done my thing. Now, you do yours. So, what it will do? It can only, each can, remember, each can only deliver one coke at a time. So, it will deliver another coke. It passes on to the, again, tells its collar or its generator that deliver another coke, I have delivered. So, it delivers the other coke and ultimately, this one also knows that, its child has delivered the coke. So, ultimately, we get five coaks. So, you can very easily see that, if I had, this was one, this is one way in which, each of this function, each of this blocks is the same function, but it is being activated with different requests and they are waiting till the request can be fulfilled, but in the meanwhile, passing on the request to another one. And as soon as this could fulfill it, it passes it on and then it goes back. In the case of iteration, what would have happened? This would not be done, this same thing, one coke and again, call this and another coke, another coke like that. So, if I call each of these as functions, then actually this function and this function, there is no difference between them. Only difference is a value with which it is being called and this process is successful because, ultimately, there will be a situation when this function of this machine will be able to deliver what is has been asked to, one coke, it can deliver. So, that will be done. Therefore, we can go back and have everybody else deliver the same thing. This is the principle of recursion. We will, I just used it as a fun example, but let us now come to a little more serious. Look at this. So, it is a process by which a function calls itself repeatedly, either directly like x is calling x or cyclically in a chain, x is calling x, calling y, y is calling x like that. Use for repetitive computations. The best thing is, you look at this example. Factorial N, all of us know that, factorial 5 is nothing but, 5, 4 times 4 times 3 times 2 times 1. Now, you see the same thing I can say, what is this part? 4 multiplied by 3 multiplied by 2, multiplied by 1, this factorial 4. So, you see I am expressing factorial 5 factorial function in terms of itself, 5 times factorial 4. And factorial 4 can again be expressed as 4 times factorial 3. And factorial 3 can be expressed as 3 times factorial 2. And factorial 2 can be expressed in terms of factorial 1. So, 5, 4, 3, 2 and factorial 1 is the end. So, that is 1. So, I am certainly getting the factorial there without any further expansion. So, this is, so we can write in general factorial of N is N times factorial of N minus 1. And factorial of N minus 1 will be N minus 1 into factorial of N minus 2. factorial of N minus 2 will be N minus 2 into factorial of N minus 3 in that way it will go on. But, it will be successful only if there is a terminating point where which we often call the basis condition. I hope you have understood this. So, two conditions are to be satisfied in order that we can write a recursive formula. One is it should be possible to express the problem in the recursive form just like factorial, factorial N is N times factorial N minus 1. And also there should there is another point that is the problem statement must include a stopping condition. What was my stopping condition in the case of factorial? Factorial 1 is 1. So, that was the stopping condition. What was the stopping condition in the terms in terms of in the example of delivering the coke when the machine was asked to deliver only one coke then it can complete. So, that is the stopping condition and then we go back, go back. So, the stopping factorial N is 1 if N is equal to 0 or N equal to 1. Otherwise, it is N into factorial N minus 1 if N is greater than 0. So, ultimately it will go on and ultimately it will conclude. Example factorial 1 we have seen that another example greatest common divisor. We can express that in a recursive form it is very interesting you can look at it that greatest common divisor of the same number is itself that is the key to the logic. GCD of M and M is M and GCD of M and N is GCD of M minus N and N or the other way. So, for example, GCD of 15 and 5 also 75 and 15 will be GCD of 60 and 15. GCD of 60 and 15 will be for GCD of 45 and 15. GCD of 45, 15 would be GCD of 30 and 15. GCD of 30 and 15 will be GCD of 15 and 15. Now, I have got the stopping condition that GCD of the same number will be 15. So, my result will be 15. Is it clear? So, that is a recursive definition of GCD. So, most of the interesting problems can be expressed in the form or in the recursive form and that helps in writing a very second and tight code. Here is another example of recursion, Fibon-Axis series, a series like this one then one then two. Two is what? The sum of the previous two elements one plus one and three. What is three? Three is the sum of the previous two two and one then five. What is five? Five is the sum of the previous two then eight. What is eight? Eight is the sum of the previous two five and three then 13. What is 13? 13 is the sum of the previous two eight and five then 21. What is 21? 21 is the sum of the previous two 13 and eight. You can see how nice pattern it is. Can you think of how we can write it in a recursive form? How we can express it in a recursive form? If you think a little bit it will be very easy. It will be something like Fibon-Axis number of N is Fibon-Axis of N minus one plus Fibon-Axis N minus two. So N 21 this one is the sum of the earlier two Fibon-Axis sequences. Now Fn minus two will be what? Will be Fn minus three plus Fn minus four. Similarly Fn minus one will be Fn minus one Fn minus two plus Fn minus three. In that it will go on but when will it stop? The stopping condition is that Fibon-Axis of one is one. We will see that. So if we try to express it in the recursive form it turns out to be Fibon-Axis of zero is one. That means the first element is one Fibon-Axis of one is one. That means second element. Then Fibon-Axis of N is Fibon-Axis of N minus one plus Fibon-Axis of N minus two. So now suppose I give you Fibon-Axis of five. How do you write that? It will be Fibon-Axis of five will be Fibon-Axis of four plus Fibon-Axis of three. Fibon-Axis of three will be Fibon-Axis of two plus Fibon-Axis of one. Fibon-Axis of one we know is one. So I know this and then Fibon-Axis of two will be Fibon-Axis of one plus Fibon-Axis of zero. I know that this is one. This is one. So I get this. This is done. Similarly Fibon-Axis once this is done I got this number. So what would that be? This will be two. And so third one will be two. Then Fibon-Axis of four will be four plus two plus three five in that will go on. So if we try to now we see how we can write a function. How we can express this Fibon-Axis or this factorial the recursive expression in the form of a function. Let us see here. I am writing this. You had seen earlier functions written for factorial. So you can see factorial n is if n equal to zero return one otherwise return n times factorial n minus one. So what will happen? How will this be executed? What will it return? While returning it will again call this function. Again this function will start in the same way just by replacing n with n minus one and here it will come out with n minus two. So it will again be called with n minus two and so on so forth. It will go on. Now how is that executed? The function as I said is not executed immediately. Just as when I asked that coke machine to deliver five coaks it did not deliver immediately. It could deliver one coke held it back but created another machine to deliver n minus one coke and that machine held it back and generated another machine to deliver n minus two coaks in this way it went on. They are kept aside on a stack on a stack one after another until the stopping condition is encountered. So it remember that I have to deliver one. So if you look at this I do not know whether that will be visible or not here. Here you see everybody remember that I have to deliver but they did not deliver. When the stopping condition was met after that this back chain started. So they are kept aside but not delivered immediately. The function calls are then executed in reverse order. Again you can see that they are executed in reverse order. Here they are executed in the reverse order here in order to get the solution. Say calculating factorial 4 first the function calls will be processed. factorial 4 is factorial 4 times factorial 3 then factorial 3 is 3 times factorial 2. factorial 2 is 2 times factorial 1. factorial 1 is 1 times factorial 0 and factorial 0 is 1. Therefore now the actual values will return in the reverse order 1 into 1 1. So it fact 1 is complete. So 1 into 2 is 2 that goes a factor is 2 in that way it goes on. So it goes back in this direction. This direction, this direction and this direction. Ultimately we get the result from here. So the actual values return in reverse order. So factorial 0 is 1. factorial 1 is 1 times 1 1. factorial 2 is now the reverse order is being done 2 into 1 2, 3 into 2 6 and 4 into 6 6 24. In that way it is being computed. So if we look at, so here is a stack. Stack is a data structure. Stack is a way of storing data where we stored the data just like whatever comes in first obviously goes out last. Because if I put something here and above that I put something, above that I put something just like a stack of books you cannot you will have to take out in the other way. This one will come out first then this one will come out then this one will come out like that. So let us see how it works. factorial 4. So factor step 0 executes factorial 4 that is executes. Now return 4 times factorial 3. You see here is the recursive call. It is calling itself. Return 4 times factorial 3. What is factorial 3? Oh you do not know what is factorial 3. Return 3 times factorial 2. Oh you do not know what is factorial 2. Then return 2 into factorial 1. Oh you still do not know what is factorial 1. Return 1 into factorial 0 and so now you know factorial 0 is 1. So you get 1 and now you could not answer these questions earlier. I have broken it down and gave you an easier solution and so now you go back here and you return 1 into 1. Then you go back here. Return 1 into 2. Return 2 and you go back here. Go back here. Go back here in that way. This is what is meant by recursion. If we redo it, if we and while we are doing this, so here is computer implementation of that. Factorial if n is less than 0, return 1, return n times factorial n minus 1. So compute 5. So it is again recursively expressing itself. F 4 is being expressed in terms of F 3. Everything is being expressed. F is being expressed in terms of F. F 3 is being expressed in terms of F 2. F 2 is being expressed in terms of F 1. F 1 is being expressed in terms of F 0 and I know what F 0 is. So F 0 is 1. So I go back and I know that now F 0 is 1. Therefore F 1 is 1 into 1 and in this way I go back. Now you see it had expanded in this way. Now you are it is shrinking. 1 into N 1. So now I know factorial 1. So this will shrink. Now I know what is factorial 2. That is 2. So this will shrink. 3 into 2 6. It is shrinking. Coming here 24 and then here 120. That is how as if in a spring it got expanded and then it contracted back. This is recursion. It ultimately turns factorial 5 to be 120. Another example will be if 1 axi number will explain it in the next lecture.