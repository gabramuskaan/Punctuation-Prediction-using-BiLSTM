 In the last lecture we had started looking at the control statements in C and we had talked about the IF, FLs and the SWIT statements. Today we will look at another very important class of control flow statements or control statements which are the statements for implementing loops. We have already used loops in most of the programs that we have written and by now we should already be aware that without loops only the most trivial programs can be written. We need to in many situations postpone the decision as to how many times a certain piece of code will execute till front time that is based on the based on the inputs received by the program. Sometimes we may need to decide how many times a particular piece of code should execute. And for doing that of course, we need a loop without a loop only what we can do is if it is known in advance how many times a piece of code is to be executed and we can replicate that code that many times. But without using a loop we cannot postpone that decision to the runtime or in other words based that decision on the inputs that the program has received. So, here is the first statement for implementing a loop that is a wild statement. We have already used this in many programs that we have written so for the syntax is very simple while and then we have an expression in brackets followed by a single statement. So, this statement again just like if an if else has to be single statement, but if we want to have multiple statements here we can enclose them in basis and form a single compound statement. So, the meaning of this loop is that the expression is evaluated and if it is through the statement is executed and again the expression is evaluated if it is still through the statement is well is executed again and so on so forth and this process continues till the evaluation of expression leads to the value falls. So, this is just explained using a flow chart which we have in the next slide. So, this diagram represents the flow chart for the loop shown on the left hand side which is while E s here E is the loop condition and S is known as the body of the loop. So, in this flow chart the execution begins here and the first thing that happens is that E is evaluated the expression E is evaluated note that again the expression E may have side effects. So, evaluating the expression will mean that those side effects do certainly take place and finally, the evaluation of E results in a value and depending on whether that is through or false again you will recall that in see any non-zero value is taken as true and 0 is taken as false. So, if the value turns out to be true that is any non-zero value then S is executed and after execution of S the control goes back to the beginning of the loop and E is evaluated again and this process continues. When after sometime when E evaluates to false at that time the control takes this part and goes to the statement following the while loop. Note that it is important to understand that E may evaluate to false the first time around itself. If that happens then the body of the loop S will not get executed E 1 1. Let us now see some examples of using the while statement using familiar programs. So, here is a while loop for computing the factorial we have we initialize P 2 1 and while N greater than 0 P star is equal to N minus minus C is the post decrement operator that we are already familiar with and this star equal to as you know is equal into P assigned P star N minus minus. So, the control flow or the flowchart for this particular piece of course would look like the diagram shown on the right hand side of the slide. So, we first compute or execute the statement P assigned 1. Note that this is outside loop body and so this will be executed only once and then the loop execution starts in the loop execution we test N greater than 0 F S execute P star equal to N minus minus and then go back and test the loop condition again. Let us try to trace this loop for some initial value of N let us assume that the initial value of N happens to be 2. So, P assigned 1 and we test whether N is greater than 0 it is because N is 2 at this point in time. So, the answer is true and the control goes to this statement P star is equal to N minus minus what will that do that willultiply P by 2 which is the value of N minus minus remember the initial value of N was 2. So, P will become 1 times 2 which is 2 and N because of the post decrement will become 1 then we go back to the loop we test again whether N is greater than 0 yes indeed it is because N is 1 now so that evaluates true. So, we again do this so P becomes 2 times 1 which is 2 and N becomes 0 and then we go back to the loop and test again whether N is greater than 0 now N has become 0. So, this condition turns out to be false and so therefore, we come out of the loop and the value of P as you know at the end of the slope is the value of the factorial of N. Note that the slope will work correctly even if the value of N initially is 0 as you know by definition 0 factorial is equal to 1. So, let us again look at this slow shot and see what will happen for N is equal to 0 for N is equal to 0 we will get a sign to 1 as usual and then when this loop condition is tested for the first time it will evaluate to false because because N is equal to 0 which is not greater than 0 and so the loop body which is P star is equal to N minus minus does not get executed even 1 and the control goes out out of the loop immediately and the value of P remains 1 which of course is the correct answer for factorial of 0. Now, let us look at another very commonly used kind of loop construct that is a far loop and the syntax is shown here for is the key world and then within bracket there are three expressions even E 2 and E 3 which have to be separated by semicolon. Now, E 1 is the initialization this is what to happen once at the beginning of the loop the expression E 2 is evaluated every time as the loop test that is the loop will continue to run as long as the value of E 2 turns out to be true and E 3 is a step that is done at the end of every loop body execution that is whenever S is executed after that E 3 is evaluated and then the control goes back to the evaluation of the loop test. So, the flow chart for the far loop shown here looks like the one shown on the right hand side of the slide E 1 remember is the initialization. So, this E 1 is an expression which is evaluated only for its side effects for the simple reason that it is value that is the value of the expression E 1 is discarded. So, the expression E 1 would usually have some side effects. So, E 1 is the initialization so that happens one and after that the loop condition which is E 2 is evaluated that again of course, may have side effects and if it happens to be true then the body of the loop S is executed followed by an evaluation of the expression E 3. Now, again the value of E 3 the resulting value of E 3 is discarded. So, E 3 also would usually be an expression with some side effects and once E 3 is evaluated the control goes back to the loop condition note that E 1 is then just one. So, the control goes back and evaluates E 2 again when E 2 evaluates to false the control goes out of the loop and executes the statement after the loop. So, you can see that this fall loop that we have written is entirely equivalent to this while loop. So, imagine that we execute E 1 first as the initialization and then E 2 is the loop condition and then E 3 is something that we execute at the end of S. Now, the reason this E 3 is important is because many times when we are looping over numbers or when when we want to execute a loop a certain given number of times then we need to instrument a counter in every loop iteration. So, those kinds of loops are very neatly captured or implemented using the fall loops let us see some examples. So, here is a loop for computing the factorial again but this time written using the fall statement. So, the E 1 which is initialization is in this case the entire expression fact assigned 1 comma i is equal to 1 or i assigned 1. So, this comma in fact is another operator that we have not seen so far when we have an expression like E 1 comma E 2 as in this case E 1 here is fact is equal to 1 and E 2 is i assigned 1. So, when we have an expression E 1 comma E 2 what happens is that E 1 is evaluated first and its value is discarded then E 2 is evaluated and its value is the value of the overall expression. In this particular case of course, the value of the overall expression is being discarded so that is not really material in this case. So, what will happen is that when expression is evaluated there will be two side effects fact will be assigned to 1 followed by i being assigned to 1 and then this is the expression which represents the loop test i is less than n and then this is the expression that is evaluated at the end of the loop body. So, what is happening here is that we instead of multiplying numbers from n to 1 in the reverse direction in the decreasing order we are now multiplying numbers from 1 to n in the increasing order and we are not modifying n instead of that we are starting with the i value is equal to 1 and we are incrementing it every time so that at the end of the loop it will become n and the loop body simply is the single assignment statement fact star is equal to i which of course means that fact is multiplied by the value of i. Note that we do not need to increment the value of i is here in like in the previous loop simply because that is taken care of by the evaluation of the expression e 3 here. There is another way of using the forward loop for computing the factorial n this is more similar to the while loop that we wrote earlier. So, in this case just for illustration I have said the initialization expression e 1 as m p. So, actually any of the 3 e 1 e 2 e 3 may be missing but the semicolon must still be there. Of course, if the expression e 2 is missing that means that there is no loop test and the loop will go on forever but in that case there must be some other way of breaking out of the loop we will look at one such way later on in the lecture. So, fact assigned one we have done this initialization we could have done this as part of the expression e 1 here but just for illustration I have chosen to keep even empty here and the loop condition is n greater than 0 and the after the loop body and minus minus is evaluated. So, this is exactly the same as while loop for factorial compilation that we wrote earlier. So, the first kind of loop which is possible in C is what is known as a do while loop and this is what the syntax looks like and we have the flow chart on the right hand side of the slide we have the keyword do followed by a statement and then we have while within brackets some expression e which again is the loop test as usual s has to be a single statement. But if we really want to put multiple statements we can put them to whether in braces and form a single compound statement after that as usual. So, the difference between this loop and the while loop is that the loop test that is expression e is evaluated after the execution of the loop body s rather than before. So, in terms of the flow chart this is what it looks like you first execute the statement s and then the expression e is evaluated if it turns out to be false then we break out of the loop because we are going to execute s as long as e is true. So, if e turns out to be true then we go back to the beginning of the loop and execute s once again and then again test e. So, notice that regardless of what the expression e is and whether it turns out to be true or false or whatever s is going to be executed at least one which was not the case in the which was not the case with the while loop because there if the first time the loop test evaluate to false the loop body does not execute even once. So, this kind of loop also has its advantages and we prefer to use the do while loop essentially where where we need to execute the body of the loop at least one. Here is a simple example suppose we are writing a program in which we are expecting or reading some input from the user and we want to check for robustness that the input is indeed valid. For example, in the factorial program we might want to test whether the input number which the user has given is non negative or not if it is a negative integers then the factorial is not defined and so we want to ask for never value. So, we want to keep prompting the user for the input till he supplies a valid input and since we have to prompt the user at least one we must you we should use a do while loop instead of using a while loop. So, here as you can see this is the loop body these two statements and since two statements are not permitted as a loop body we have enclosed them in these braces so that this entire statement from this phrase to this phrase is a single compound statement which can be the loop body. So, this loop body prints a prompt for the user to enter a non negative integer and then reads the value of the integer that has been supplied by the user into the variable n and loop condition is n less than 0. So, we want to continue doing this prompting and reading till the user supplies a non negative integer. So, as long as the supplied integer n is negative we have to keep doing this. Note that again the do while loop can also be all do while loops can also be implemented using only the while loop but it might become cumbersome. So, as an exercise you can try to implement this functionality using a while loop you will find that it can be done but not so elegantly. So, these are the three kind of loop statements that we have in C. We now look at some other statements which are useful in the context of loops. The first is the break statement. So, break is a very simple statement we have already seen it in the context of the switch statement earlier in the last lecture. So, in the switch statement if you recall the break statement causes the execution of the switch statement to finish and go to the next statement that is within the switch statement whenever the break is executed the execution of the switch finishes then in there. So, similarly when used inside a loop the break statement causes the loop to terminate immediately regardless of whether the loop rest condition has become through or false and the control goes to the statement immediately following the loop. Now of course, it is possible that you have a loop within another loop and within that there is a break statement. So, whichever is the inner most loop that contains the break statement that is the one which will be terminated by the execution of the break statement. And the reason we use break statements is that it is often useful for simplifying loop conditions. So, let us look at an example which we have seen earlier. This is the example of finding whether a given number n is prime or not. So, you recall that the way we tested that is by trying out all all possible divisors of n from to up to the floor of square root n and if we find divisor then of course, n is not a prime and if we do not find divisor then n is prime. And the loop that we had written earlier in one of the initial lectures was similar to this particular loop. Although I have changed this slightly and rewritten it as a fall loop instead of writing it as a while loop. So, initialization is i assigned to and found assigned false. Falles remember is a Boolean variable which keeps track of whether we have found a divisor a founded divisor of n yet or not. So, initially found a false to begin with we have not found any divisor and we start looking for divisors from two onwards. The loop condition is i less than equal to square root n. So, I am assuming that this variable square root n is an integer variable which contains the floor of the square root value of n. So, we have to continue the loop as long as i is less than equal to square root of n and not found meaning that if either of these two conditions become false we break out the loop we stop the loop execution because if i becomes greater than square root of n that means, we have tested all divisors up to square root of n and did not find any divisor of n. And if found becomes true that means, we have found some divisor and therefore, we must stop the loop execution. And therefore, we must keep executing the loop as long as i is less than equal to square root of n and we have not found a divisor that is we have not exhausted all the divisors all the potential divisors of n and we have not yet found the actual divisor of n. And every time after the execution of the loop body we increment i because in the next iteration of the loop we want to try the next higher potential divisor. And in the loop body we just test that if i divides n that is n percent i which recall gives the remainder when n is divided by i if n percent i is equal to 0 that means, i is a divisor of n and so we have found a divisor and so we set found equal to true and the next time the loop condition will be evaluated again we will find that found is equal to true so not found is false and therefore, this entire condition is also false and so we break out of the loop. Note that this entire loop has become quite complicated because of the use of this Boolean variable found and the fact that the loop has consist of two independent conditions both of which need to be tested. Instead of that suppose we use a break to break out of the loop when we find a divisor. So, in this version of the same loop the loop body is quite simple and the loop header which contains the expressions e 1 e 2 e 3 are also quite simple the initialization is simply i is sign 2 as before we have done away with the Boolean variable found we are not using it any longer because we will break out of the loop when we find a divisor. So, there is no need to use the Boolean variable and the loop test is simply i less than equal to square root n and of course at the end of the loop body we have to increment i. So, in the so we are no longer testing whether we have already found a divisor. So, that means that if we find a divisor then the loop will not stop and will keep executing because i is still less than or equal to square root n. Therefore, when we find a divisor we have to use some other way of stopping the loop and that we do using the break statement. So, if n percent i is equal to 0 we execute a break statement and this break statement will immediately terminate this loop because this is the inner most loop containing the break statement note that if is not a loop and so this break will not do anything to the execution of the if it is the far which is a loop which is the inner most loop that contains break. So, as soon as break is executed this for loop gets terminated and the control goes to the following instruction. So, of course after the end of the loop we need to find out whether we have found a divisor or not. In the earlier case it was easy because we had this Boolean variable found and at the end of the loop if it was true that means we have found a divisor otherwise we have not found a divisor. Here we do not have this Boolean variable but finding out whether we came out of the loop because of this break or because of this loop test is quite easy. If we check the value of i and we find that it has become greater than square root n that means we must have come out of the loop because of this condition otherwise we must have come out of the loop because of this break in which case we found an actual divisor of n and so therefore, n is not a prime. Okay related to the break statement there is another statement which is called the continuous statement and the functionality of the continuous statement is that within a loop whenever a continuous statement is executed the current iteration of the loop is terminated it stops and the next iteration begins immediately that is within the loop that is the continuous statement is executed then even if there is there are more statements in the loop body those will not get executed and the next iteration of the loop will start again. When we say the next iteration of the loop will start again what we really mean is that in the case of the do while loop and in the case of while loop the control will go back will go to the place where the loop condition is evaluated and is tested whether it is true or false but in the case of the fall loop something slightly different happen that when the continuous statement is executed the control goes back to the increment step that is the E3 which is the step which is the expression which is evaluated after the loop body is evaluated. So essentially the way continuous statement should be thought about is that on execution of the continuous statement the loop body gets terminated and then but the loop itself does not get terminated. So in the case of fall loop the expression E3 is evaluated again and then the control goes back to the loop test and in the case of the other two other two kinds of loops the control goes back directly to the loop test. And the reason we need to use the continuous statement is that it can help in simplifying the loops. For example again here is a simple situation that you might encounter in some programs that you might write. Suppose you want to write a loop which reads 10 integers from the input and processes them one by one in certain fashion now this processing could be very simple or it could be extremely complex and the constraint is that if there is a negative integer in the input that should not be processed that should be ignored. So suppose we are not using a continuous statement for implementing this and what we will need to do is this loop is simple for i is equal to 0 i less than 10 i plus plus so do this loop body 10 time read the value of n and if n is greater than equal to 0 then process n. Now the problem with this kind of structure is that if the processing on n is very complicated and it has several nested control statements one inside the other then the indentation level may become very deep and we are adding to that indentation level by having to indent this entire processing by one extra level because this entire processing is within the body of the if statement. On the other hand suppose we use a continuous statement then what we can do is after reading the value of n in the loop body if n is less than 0 then we put a continuous statement that means whatever is next in the body of the loop does not get executed and we straight away go to the next iteration of the loop remember that for the for loop when we go to the next iteration that is when we execute the continuous statement the control will first go and evaluate the expression E3 which in this case will increment i and then the loop test will be executed again which is of course we want to which is of course what we want to do because we want to read exactly 10 numbers regardless of whether we are positive or not and so if n is less than 0 we continue and otherwise we have the code for processing and note that the control will come to this place only if the value of n is greater than equal to 0 and so therefore we do not need to test whether the value of n is greater than equal to 0 it is guaranteed to be equal to 0 the difference between these two implementations of the same functionality is that the processing of n is at one lesser level of indentation when we have used continuity because this processing of n is not within any if it is directly within the for statement at the next level. So, at the end of the lecture here is an exercise for you and this exercise requires you to write a program to compute what is known as the greatest common divisor or the GCD of two positive integers you probably are aware of the definition of the greatest common divisor of two integers the GCD of two integers is the largest integer which divides both of them. Historically the best known algorithm for GCD is attributed to Euclid who came up with a very efficient algorithm for GCD based on the following properties. So, I will list these properties explain these properties and leave it for you to design the algorithm and then implement that as a program. So, these are the three properties the first properties GCD of A and B is of course, the GCD of B and A that is the arguments can be interchanged the GCD of A and A is the same as A that is if the two numbers are equal then the GCD is equal to the same number that of course, because A is the largest integer that divides A so that is three will it true. The third property is the most interesting is given A and B two number say and B and let us assume that A happens to be larger than B then the GCD of A and B is the same as GCD of A minus B and B that is if you subtract the smaller number from the larger number and GCD of this number resulting number and smaller number is the same as the GCD of the original two numbers. So, you can try and convince yourself that this property indeed holds always based on these three properties you should be able to come up with an efficient algorithm for computing the GCD the naive algorithm for computing the GCD will try to find the largest integer of A which also is a divisor of B but that is inefficient this will this these properties can lead to an Euclid to an efficient algorithm which will compute the same result in much lesser number of iterations. So, that is left as an exercise for today. In the next lecture we will talk about arrays which are a very very important tool in again writing non-trivial programs and allow us to handle large volumes of data rather than small number of data items at a time.