 Today, we will discuss a very important concept in programming and that is the concept of breaking up a large problem into smaller sub problems and then be able to write independent small program fragments for solving these problems and then be being later as able to assemble them to form the solution to the overall problem. In C, this is achieved by using what known as functions. We have already used various library functions in our programs that we have written so far. Today, we will see how we can write and define our own functions which can be used for simplifying the problem by breaking it up into small problems and so on. So the problem is that in contrast to a small program that we have been writing so far, when one is developing very large programs, then we need to make the task of programming much more manageable. Many large programs are needed because many real life problems are very complex and obviously they require complex solutions. But the capabilities of the human mind are limited so the human mind cannot really focus on all the details of a very complex problem all at the same time and therefore to ease the process of programming or developing a program what one needs to do is to divide up the problem into smaller parts and then try to solve the smaller problems individually and then later on assemble the solution to the overall problem from the solutions of these individual smaller problems. Of course, it may turn out that even the smaller sub problems that we identify are still very complex. In that case, we need to further break them up into smaller sub problems yet and then try to solve them at that level and this process has to continue till the problems that we have reached are sufficiently simple that we can focus on solving one problem at a time. So, this entire process in C is accomplished using what are known as function and essentially functions allow us to do the kind of breaking up of problems into smaller problems and then assembling the overall solution from the solutions to the smaller problems in the way that we have been talking about using functions we can focus on solving a sub problem without really worrying too much about how the solution to the problem will be used in the solution to the overall problem and when we are solving or assembling the solutions to the sub problems to form the solution to the entire problem, we should not have to worry about how the individual sub problems were actually solved. So, both these kind of abstraction the functions allow us to perform. So, there are two using using this idea of breaking up and breaking up the problem into smaller problems and so on there are two major ways in which one can design solutions or programs for a given problem and these are fairly intuitive in their nature. So, let us look at one of them first that is the bottom up design approach. So, here essentially what you do is that given a problem we identified the sub problems. So, let us say we have identified these two sub problems and then I will say these sub problems may themselves be still quite complex. So, we do this breaking up still further. So, maybe we have divided both these sub problems into two sub sub problems each and now supposing that the smallest problems that we have identified are small enough or simple enough that we can solve each of it in its entirety. You can think about each of these sub problems in its entirety then we start up solving these problems bottom up. So, we might solve this problem first and then this problem and then using the solution to these sub problems we might assemble the solution so to speak of the larger problem and similarly then we will solve this problem and this problem and then assemble the solution to this problem and having finally solve these two sub problems we assemble the solution to the overall problem. So, the solution the problems are solved in the upward direction while the identification is in the downward direction. In contrast to that one can think about a top down approach where the procedure is slightly different. So, again from the overall problem we identify sub problems and not just identify the sub problems assume at a certain level that the sub problems have already been solved and then assuming the solution to the sub problem exists try to solve the overall problem first. So, here let us say we identify two sub problems and without having solved these problems at this level we assume that the sub problems have already been solved and design a solution to this problem assuming a solution for these smaller sub problems and then of course in the next step we need to solve both of these sub problems. So, if they are still complex enough we again break them up into smaller parts and now this sub problem would be solved assuming that these two smaller sub problems have already been solved and so on so forth. So, that is the top down approach. Let us not take a somewhat more complex program than the ones we have been looking at so far to illustrate the ideas that we have been talking about. So, we will use the top down approach to solve this particular problem which is actually still not very very complex, but it will have to illustrate the points that we are trying to make. So, in this problem we are supposed to write a program that given an input in P j n which is greater than 1 greater than or equal to 1 the program is supposed to print all numbers i which are less than equal to n such that i is equal to the sum of the factorials of its digits. So, let us now take a simple example problem to illustrate the design approaches that we have been talking about will use the top down design approach in the solution to this problem. This problem is still not very complex, but it does have to illustrate the points that we have been trying to make and it will also illustrate how we can define functions in our program and use them and so on so forth. So, the problem is very simple we are supposed to write a program which takes an input in P j n as the input and is supposed to be more than equal to 1 and the program is required to print all integers i which are less than or equal to n such that i is equal to the sum of the factorial of its digits. So, for example, 145 is equal to 1 factorial plus 4 factorial plus 5 factorial you can easily verify that 5 factorial is 120, 4 factorial is 24 and 1 factorial of course is 1. So, 1 factorial plus 4 factorial plus 5 factorial is equal to 145. So, the program is supposed to print all such numbers less than equal to n and n is taken as an input. So, let us use a top known approach to solve this problem and to do that we need to first break up the problem and identify smaller or simpler sub problem. So, the sub problem of this problem that we can immediately identify is given an integer i find the sum of factorial of its digits. Now, in the top known approach instead of going and solving this sub problem first let us assume that the solution to this problem is already available to us. So, let us assume that a library function digit fact sum is already available which given an integer i returns the sum of the factorial of the digits of i. Of course, as we know there is no such library function will have to write that ourselves and that will constitute the solution of the sub problem that we have identified. But at this stage we assume that this solution is available to us in the words there is already one such function that is available to us and all we have to do is to use this function in finding the solution to the overall problem. And you can see that given this useful function the overall problem is quite easy to solve and here is the main what the main program might look like. We have declared three variables n i and r and will be the input integer that will read and i will be used to run a loop from 1 to n to check which number satisfy the given properties. The variable r will use to hold the return value of scan F which we discussed last time. If you recall we said that scan F actually returns the number of items successfully assigned. So, we will use and we should use this return value to check that whatever kind of input we were actually expecting the user did actually give that kind of input. And so here is a familiar do while loop to read an input integer n and we want to make sure that the input integer n is at least 1. So, as long as n is less than equal to 0 we give the prompt to the user and then read the value of n and r is the return value of scan F. So, note that the value of r will be other than 1 if the input was not proper that is something other than digits and the plus minus sign etcetera was entered. So, if r is not 1 that means the user did not give a proper input and therefore, we should ask him to give the input again. So, therefore, this while loop is running as long as r is not equal to 1 which implies that improper input was given by the user or n is less than equal to 0 which means that some integer was entered but it was less than equal to 0 whereas, we want a positive integer which is at least 1 and so therefore, the user is prompt it again. But that is the simpler part this is the main part of the program all we need to do is to run a loop from i equal to 1 to i equal to n and for each i if the sum of the factorial of the digits of i is equal to i then we print that i. Note that we are assuming that this function digit fact sum i is already available to us and we are simply using that function without worrying about how the sum of the factorial of the digits of this number i is being computed. Note also that the call to this function is exactly the same as we have been calling the library functions so far just have to give the name of the function and within bracket we have to give the argument for this function. So that is not the end of the program development because the function digit fact sum is not there in the library so we have to write that ourselves and that is the next step in the development of the program. So how do we solve the problem of finding the fact sum of the factorial of the digits of the given number well you can immediately see that it has a simpler sub problem and that is the finding out the factorial of a given number i. So suppose we have the solution to this problem again in the form of a function which given and i find i factorial so let us assume a factorial i function exists which for a given value of i returns i factorial and given this function finding out the sum of the factorial of the digits is quite straightforward. So this is what the code for that doing that might look like. So let us initialize a variable sum to 0 which is going to hold the sum of the factorial of the digits of the number and let us assume that n is the number for which we have to compute the sum of the factorial. So what we are doing here is that as long as the number is greater than 0 we find the least significant digit of n and that is easily obtained by taking the remainder after dividing n by n by 10 that is given by the expression n percent n. So this n percent n represents the last digit or the least significant digit of the number n and so we take the factorial of that note that we are assuming that the factorial function already exists and whatever is the answer we add that to sum and after that we divide n by 10 and remember this is integer division because n is an integer and n is also an integer. So what this will do is that n will become the same number as previously except that the last digit will get removed. So for example if n was 527 then in the first iteration n percent n would be 7 and we will add 7 factorial to sum and then sum and then n will become n by 10 which is 52. So in the next iteration 2 factorial will be computed and added to sum and n will become 5. In the next iteration 5 factorial we add it to sum and n will become 5 by 0 which is equal to 5 which is equal to 0. So and when that happens this loop will terminate because it will run as long as and if greater than 0 and n has become 0 as a matter of fact. So the writing the code is simple enough and it requires only the knowledge of principles that we have already seen but now what we need to do next is to wrap this code up and make it into a function. So to do that we need to add some more stuff to this already existing code. So this particular thing says that this is a function that we are defining this is the function header as it is called and this has three components. The first component is the name of the function which is digit fact sum the second component is the type of the return value that is what kind of value does this function resultant and in this case that is an integer and so the return type is an int and the last part is what is the name of the parameter and its type. So this function takes one parameter which is being called n and its type is int and the entire code for the function is enclosed in braces and of course this place has to close somewhere so we will do that next but after the sum has been computed we need to somehow say that this sum that we have computed is in fact the result of evaluating this function or in the words this is the return value of this function. So for doing that we need to add a return statement this is a return statement and this has two functions first is that the expression that is given along with the return statement in this case which is simply the variable sum the value of this expression is the return value or the result of a evaluating this function. So in this case we have computed the result in the variable sum and so we are saying that the result to be returned to the caller whoever has whichever function has called this function the result that this function will get will be the value of the variable sum that is what we are saying here and the other thing that return statement does is that whenever the return statement is executed the function immediately terminates the execution of this function immediately terminates and control goes to wherever the function was called form well look at that in more detail with the help of some examples in the later slide and finally this variable sum which we have declared within the definition of this function is called a local variable of the function that we just defined which is the digit fact sum. Okay so having written the digit fact some function we need to now write the factorial function this is a fairly simple function that we already know about and using what we have learnt now this is what the definition of the factorial function will look like this code is very familiar to you from the competition of the factorial which we have been taking as an example in numerous programs. So this loop essentially multiplies numbers from 2 up to n this should be I less than equal to n and the result is told in the variable p and this p is the final result of evaluating this function and that is the return value again the name of the function is factorial the return type of the function is in it has one argument which is called n and whose type is an in. Okay so you might be surprised to know or maybe not so surprised that the main program that we write the main is also a function you might have noticed the similarity between how the main code starts and how a function is defined and that similarity is not coincidental it is because of the fact that main is also the name of a function except it is the same as any other function the only difference is that it is a special function in the sense that execution always starts at this function. Okay let us now talk a little bit about local variables so we have already seen in the functions digit fact I digit fact some and the function factorial that we can declare variables within the within the body of a particular function and these variables are said to be local to that particular function. So what local means is that a function declared within a particular function is not visible outside this function that is known as the scope of the function which we will talk about in more detail in the next lecture and the second important point about local variable is that this variable has existence only while this particular function of which this is a local variable is executing. So while this function is not executing nobody has called this function and this variable does not exist at all there is no space allocated for this variable in the memory of the machine. So this idea is called the lifetime of a variable we will talk about lifetime of variables also in the next lecture. What is important to note is that it is possible that two functions have local variables which have the same name. For example, this function factorial had a variable called i and the function main also had a local variable i. Now these two is have nothing too do with each other the i declared within the function factorial is local to the function factorial and similarly the i declared within the function main is local to the function main. So within main whenever we refer to the variable i what is meant is a reference to be variable i which is declared within the function main whereas within the function factorial when we referred to the to the variable i what is meant is a reference to the variable i declared within be function factorial. Okay, let us now look at parameters and argument. So, we saw that when we declare a function, we have to declare what its parameters are. We have seen so far only functions with one parameter, but in general a function may have more than one parameter. Each of those parameters in the function definition has to be given in name. For example, in the factorial function the parameter was called n and it has to be given a type in the case of the factorial function that was the type was n. When we call a function at that time an actual argument for that function has to be supplied. We will talk about the relationship between parameters and arguments shortly. But the important point to understand at this point in time is that a parameter declared for a function can be used pretty much like a local variable of that function. It behaves like a local variable. In fact, in terms of both scope and lifetime it is similar to local variables. What that means is that this variable is not visible outside this function and comes into existence only when that function gets called. So, for example, in the program that we just developed the factorial function had a parameter called n and the main function had a local variable called n. Now, these two n are again completely independent of each other and have nothing to do with each other. Let us now try to understand what happens when a function is called. So, when a function is called some parameters are supplied some arguments are supplied for that function. So, the arguments are supplied for each parameter that the function has. If the function has two parameters then there must be two arguments. If it has three parameters then there must be three arguments. What happens first is that these arguments are evaluated. These arguments have to be expressions and the evaluation of these expressions results in some value. And then for the function which is being called the compiler creates space in memory for the local variables and parameters of this function. And next step is that the parameter the space that has been created for the parameters of this function. Those parameters are initialized for their given values which are equal to the values of the corresponding argument expressions. So, we will see that as an example and the important point to note is that the value that the parameter gets is a copy of the value of the corresponding argument. So, let us try to understand what is happening when a function is being called and some arguments are being passed to it with the help of an example. I have scribbled here the definitions of the digit fact sum and the main function that we just wrote. So, let us focus on this called from the main function to the digit fact sum function. So, while the main function is executing the variables the local variables of main are in existence. So, let us say this is this is the space created for these local variables and I and R let us assume that at some point in time and happens to be 5 and maybe I happens to be 2. Now, the function digit fact sum is not executing right now and so therefore, the variables of the function digit fact sum do not exist at this point in time. Now, when this function is called from this statement the argument passed to this function is the expression I. So, what is going to happen is that this expression I will be evaluated and that of course, results in the value 2 and now since this function digit fact sum is being called space is created for the variables and parameters of this function. So, there is one parameter n and there is one local variable sum. Note that n is also a local variable of the function main but this n and this n have really nothing to do with each other. So, this box is also called n because the name of this parameter is also n. So, what is going to happen is that the value of this expression which has resulted in the value 2 is going to be copied into the value of n over here and now the digit fact function will start executing and finally, as you will as you know the value of sum will become 2 and the value of n becomes 0 because in every iteration we are dividing n by 10. So, in the first iteration itself n will become 0. So, the value of n is 0. Note that the value of this n which is the parameter of the function digit fact sum which has become 0 the value of I in the main function remains 2 that does not get changed and similarly the value of n in the main function that also does not get changed and it remains 5. Now, when this function is about to return this expression which is the expression corresponding to the return value is evaluated and the value of that expression is 2. So, the value of this expression is what will become the value of this entire expression in the main function. So, when this function returns the control goes back to the main function and execution within the main function continues from the point just after where the digit fact sum function was called. So, this function the main function of continues and the value of this entire expression comes out to be 2 which is the return value of the digit fact sum function and then of course, we check whether it is equal to I or not the value of I is also 2 and so, since we were equal the printf happens and 2 gets printed on the output and so on. So, what we just saw is that when a function is called from another function the arguments for each parameter have to be supplied these arguments are evaluated and result in some values. Then the next step is to create space for each of the parameters and the local variables of the function which is being called and the values of the arguments are copied into the respective parameters and then the function body executes and finally, at the end it returns a value and the value is taken as the value of the call expression that is the call to the function is treated as an expression and the value of that expression is nothing, but the return value that the function returned and the execution starts in the function from which the function had been called at the point just after where the call was made. So, this is the end of this lecture and in the next lecture we will continue our discussion on functions and look at some more details involved with writing of functions.