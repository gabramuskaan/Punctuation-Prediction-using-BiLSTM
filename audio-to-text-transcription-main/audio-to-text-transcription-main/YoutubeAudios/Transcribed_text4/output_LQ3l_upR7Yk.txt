 Hello, in the last lecture we had looked at some C program and without really discussing the season text formally, tried to write some simple C programs and examine them and how they work. As I mentioned in the last class, starting today we will start discussing the season text and the various intricacies of the language from today and today we will first look at variables and types. So, we have already used several variables in the programs that we have written so far, but there are restrictions on what the variable names can be. So far we have been using simple names like A, B, C, I and J, but actually the variable names can be pretty much as long as you like, but the restriction on the variable names is that it can only contain letters, lower or upper case, that is A to Z or numerals, 0 to 9 or the special underscore characters. It cannot contain any other character on the keyboard. In addition, the variable name cannot start with a numeral, that is it cannot start with a digit from 0 to 9. So, let us see some examples of valid and invalid variable names. There are some invalid variable names, CX, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, N, is illegal because of these parentheses, the bracket characters. This one is also никаких, because it has the bracket characters in it, as well as the minus sign, no that the minus sign is different from the under core characters. There are some valid variable names instead of three X, we could have called it X, three. There is an example, where the variable name contains an underscore character f1 to score n or f1 to score fn under score 1. So, this is the restriction imposed by the language on what the variable name can be, but also when we are writing programs as I have said earlier also we must make sure that our programs are readable so that they can be later understood by ourselves and by other people who are reading the programs and one very important aspect of program availability is that we should use descriptive variable name that is the variable name themselves should suggest what the purpose of the variable is. Okay, here are some more constraints on what the variable name cannot be. She has certain what are known as keywords or verb words which cannot be used as variable names because these words are special meaning. We have already seen examples of these keywords they have appeared in our program. If you recall is type integer and so that the keyword cannot be used as a variable name what that means is that we cannot have a variable name and similarly we saw that while if else etc were special words that we use in our program so they cannot be used as variable name either, but any other there are a whole lot of other keywords as well, but other than the keywords any combination of factors containing only alphabet, numerals and not starting with the numerals could be a valid variable name, but it means there is a game that you should choose our variable name carefully so that we represent the purpose of having that variable. Okay, let us now look at types we have already encountered types in the programs that we have been so far we have only seen one type so far which was the integer type represented by the keyword int, but there are other types also available in C large number of them actually. So the types are mostly because our programs as well as the computer can deal with data of really a time integers are just one example it could deal with real numbers it could deal with strings made up of characters and so on so forth and in general the values of different types are stored differently on the computer internally for example integers and real numbers are stored very differently they have already seen in an earlier lecture that integers are stored in their binary representation we shortly see roughly how the real numbers are stored inside the computer and you will see that the way they are stored are very different and as you can imagine different types may have different operations defined on them for example for integers as well as for real numbers we have the arithmetic operations defined like addition and so on but for some other types some other operations may be defined which may not make sense for integers in general even similar operations on different types may be implemented differently internally by the computer for example addition is defined for both real numbers and integers but because the representation of integers and real numbers is very different the computer has to perform addition of integers very differently from the way it performs addition of two real numbers and therefore the compiler leads to know the type of every variable or value that is being manipulated by the program that is because it has to generate the right machine code to manipulate these values or the variables. So, at first discuss integers types and see in more detail we have already seen the type 8 which can be used for storing integers but as we will shortly find out see actually defines a number of flavors of the digit type with slightly different properties. So integers can be either unsigned or signed what that means is that whether negative integers can be stored or not so an unsigned integers variable cannot store the negative integers value whereas a signed integer variable can store both positive as well as negative integer values. The integers can be of different sizes these are the various sizes of integers can see each short long or the regular integers will soon see what the different sizes mean and what is the practical implication of this. So let us first focus our attention on signed and unsigned integers. So if we prefix the word unsigned unsigned infinitely is another keyword it is a new keyword that we are introducing now if we prefix this to an integer type then that is a human integer type but it indicates a type where only non negative integers can be stored that is either 0 or positive integers and if we will unsigned if we use the prefix sign or no prefix at all that indicates that both negative and non negative integers can be stored. So for example unsigned int would denote an integer type which can store only non negative integers on the other hand signed int or simply int would denote an integer type which can store both negative as well as non negative integers. So here are the examples which are just the sign int is the same as just int both negative and non negative integers can be stored unsigned int on the other hand denote some integer type that can only hold non negative integers. So we cannot assign really a negative integer to a variable of type and it will result in some kind of an error. And as we said integers can also be of various sizes apart from being signed or unsigned. So the size of a type here really denotes the number of bits used to store the values of a particular type. If you recall from the earlier lecture we had seen that the integers are stored internally in their binary form and the number of bits available for storing the integers really determine what is the largest integers that can be stored in that particular type. So a type for the bigger size can store a larger range of integers. The different size integers integer types in the care shorting which can be used as just short, int and longing, longing there are same as just long. There are the integer types of various sizes in C we will discuss their sizes in a minute. And in addition each of these can be signed or unsigned. So here is a list of all integer types in C we can have just the plain integer which can be signed in or just in. We can have an unsigned integer which we can write as unsigned or just unsigned. We can have a long integer which is written as longing or just long and unsigned long integer or just unsigned long. A shorting integer is written as shorting or just short and unsigned shorting is signed character which is written as signed care or just care. Do not really get misled by the fact that the name here is care is low fin. This is there for a specific reason which we will discuss later on when we talk about representation of characters inside a computer. We will see that the same type is actually used for representing the characters also but it is actually just another integer type. So this can be just another integer type. So we will just think of it right now as an integer type and the unsigned care type. Let us see what their sizes are and what the size has to do with the smallest and largest integers that can be stored in a variable of a certain type. So if you have a signed integer type with size n bit then it can store integers from minus 2 to the power n minus 1 to plus 2 to the power n minus 1 minus 1 both inclusive. We will just state that and not really show while it is true. On the other hand if we are talking about an unsigned integer type again a size n bit then the largest integers that can be stored is 2 to the power n minus 1 and of course the smallest integer is 0. Remember that in the unsigned integer type you cannot store negative numbers. Now out of the different integers types of various sizes that we have seen so far care, short, int and long the C standard definition, the C language definition defines only the size of the cat type which is 8 bits which is if you recall the same as 1 right a group of 8 bits is called a byte and it does not define the sizes of the other size like short, int and long and so the size of these types may vary from different computer to different computers from one computer to another. So on one kind of the computers the short may be 16 bits on another it might be the state bits and so on but what the language that is getting used is that short is at least as big as care int is at least as big as short and long is at least as big as int. So on a typical PC which is running Linux which is the kind of machine that we are using in this course these are the typical sizes of the various types care as always of course is 8 bits remember that care is 8 bits on every machine and on a PC with Linux short is 16 bits or 2 bytes int and long are both 32 bits or 4 bytes. So on this particular machine it does not really matter whether I declare it variable as int or long because both are 32 bits but remember on a different machine it might make a difference because on a different machine for example int could be 32 bits and long could be 64 bits or maybe int 16 bits and long is 32 bits. Therefore we have to use the correct types choose the correct types of our variables depending on how large we think the value of that variable is likely to be. Now since the sizes of these types can vary from system to system there is a way for C programs to find out what is the size of a given size within the program itself and that is done using the size of operator in C. So if for example if I use the expression size of int then this will have the value 4 on a PC running Linux. So we can let me illustrate this with a small program. Here is a small program which prints the sizes of various integer types. So note that this program has no import it does not print any import from the user. Just print it has a 4 20th statement and each line print the size of a particular type is so many bytes. So this personally if you remember would be replaced by the value of the parameter which in this case would be size of S. which of course as we know is going to be 1 byte and in this case it will be replaced by size of short size of int size of long and so on. Note that the size of unsigned short is the same as short and in this size of unsigned int is the same as the size of int and so on. So we do not really need to find out the sizes of unsigned int and unsigned short separately. So let us compile this program and see what output it is. Okay so this confirms the fact that I just told you that on this particular machine this kind of a machine which is a PC running Linux the care has side 1 byte. This member will have a system but on this system short size 2 byte and int and long have size 4 byte which may be different on different system but remember that the guarantee we have from the C language is that the short will have size at least as much as care int will have size at least as much as short and long will have size at least as much as int. Okay so let us now go back to another type that will be quite useful and that is the type of type of real number. So we have been dealing only with integers in the programs that we have written so far but as you can imagine oftentimes we might need to deal with real numbers especially when you want to do scientific competition and as I said earlier real numbers are represented very differently inside the computer form and integer. So real number is really represented as a sign whether the number is positive or negative and exponent which is some power of 2 and the main piece or the fractional part of the integer we do not really need to know the ideas behind this in great details the point that we are trying to make at this point in time is simply that the representation of integers is very different from that for real number and the implication of this particular kind of representation is that real numbers can only be represented approximately that is we have only a finite number of bits to represent the main piece or the fractional part of the real number and so the accuracy is limited. On the other hand the integers are stored absolutely precisely but the differences that while integers types have a relatively smaller range so for example on the machine that we just saw the size of integer type is 4 by 32 bits so that means that the largest integers that we can store in an int type would be 2 to the power 31 minus 1 the range of real numbers on the other hand is much larger but the precision is restricted. Let us now look at the real number types that are available in C there are two of them really they are called float and double the world float comes from the fact that the representation of real number that we just saw is called the floating point representation and the world double comes from the fact that the double type has about twice the precision as that of the float type. So, you said double has much more precision than the type float but both have about the same range that is the smallest and the largest real number types in the stored are about equal in both these types. The difference remember is in the precision so the double type is typically used in scientific applications that require a high degree of precision. Let us now write a small program to illustrate the float type and this program is to compute the area of the circle fairly simple program given the radius of the circle. So, obviously we want to represent both the radius and the area of the circle by real number. So, here is the program remember that hash include the city I O dot H will be present in pretty much all programs that we write this just says that we are going to use some standard input and standard output library function in the standard I O library. So, here are the variables that we are going to use the variable radius is represent the radius of the circle that the user will input the variable area will represent the computed area of the circle. High of course, is the well known mathematical constant and we are using its value 3.141 9 of course, we could have used a more precise value for phi. So, this program is quite simple as you can see we enter we use the user from to enter the radius and then we have to read the radius from the user. Now, that radius is a floating point variable or a float of a float we cannot use kns percent D to read it. We still use kns to read the value of radius but instead of using D we will use percent F and remember that in kns the variables have to be predicted by the sample send. So, once we know the value of the radius the value of the area is very simple to compute it says phi r square or phi 10 radius 10 radius and then we are printing the output which is the area of the circle with radius so much is so much. So, again note that to print a floating point value or a real value we are using percent F instead of currently as we did for printing integers and we are using the same print statement actually to print 2 real values along with some text. So, we have 2 percent F in the format string and first percent F will be replaced by the value of the radius and second percent F will be replaced by the value of the area. So, let us compile this program. Let us say we gave the radius as 2.56 whatever the radius is and let us give the correct area of the circle which is 2.59 075 size which you can easily verify using a calculator. One more point I would like to make using the same program let us add it again and that is that in this program the variable phi is actually not really a variable in the sense that we will never want to change it once we have given it a value. Note that one more new thing that we have done in this program is that the variable has been utilized at the same time as when it has been declared. This is the first time we have been doing this. So, float phi is equal to 3.1419 so we can mix the initialization of a variable with the declaration as we really do not want to modify the value of phi ever in our program. So, to indicate this we could prefix this declaration by the keyword prompt. The keyword prompt has the compiler that this variable is really constant which will not be modified by the program. So, it can only be initialized along with the declaration it cannot be given a value later on. So, the point of doing this is that if inadvertently by the sake our program happens to modify the value of such a variable the compiler will give us an error message. Let us try to do that actually. Let us say phi 0.46. So, as we will see this is a variable given error. Assignment of the variable phi so this is not permitted. So, that is the advantage of declaring variables as constants and we do not really want to modify the values. So, this program will compile okay and will work the same as before. Very bad answer. Okay. So, let us turn this lecture with a problem for you. The problem is that we will compute the value of phi 0 given the value of x to a certain accuracy. Let us say a epsilon which is also given. The accuracy basically means that the value of phi 0 must not that is computed by the program must not differ from the actual value of phi 0 by more than this amount. Now, the way you are going to do this is to use the dealer expansion for sine x. We call that sine of x is equal to x minus x cube by f factorial plus x to cos phi by f factorial minus x to cos 7 by 7 factorial and so on. So, you have to use the same error series to compute the value of sine x given the value of x and since you have computed for the accuracy of epsilon that means that you should stop adding the terms of the sequence once the absolute difference between the last two terms that have been computed is less than epsilon. So, let us say gn is the last term that we have computed and tn minus epsilon was the term that we computed before that then when the difference is less than epsilon that look different is less than epsilon then we can stop computing and the sum that we have a complicate so far is the value of sine x to the desired accuracy. Also note that you can in every iteration when you want to compute some x to the power 2 k plus 1 by 2 k plus 1 factorial we do not need to raise x again to the power 2 k plus 1 and compute 2 k plus 1 factorial you can use the fact that in the previous iteration use you computed the term x to the power 2 k minus 1 divided by 2 k minus 1 factorial. So, given this value to compute the next term which is this all you need to do is you need to multiply this by x square and divide by 2 k times 2 k plus 1. So, you can see this will become x to the power 2 k plus 1 into 2 k plus 1 factorial and that will give you the value of the next term. So, try to solve this problem and try to see program for computing the value of sine x will see the solution to this problem in the beginning of the next lecture. Thank you. you you you you you