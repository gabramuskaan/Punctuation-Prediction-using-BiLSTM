 In the last lecture we had talked about the Boolean type and the collector type and in this lecture we will start talking a little more formally about the season text we will see what expression in CR and how they were evaluated. So, an expression is essentially a denotation of a simple computation, we are also familiar with expression from our high school arithmetic. In C every expression has a type, the types are the kind of types that we have already seen like integers, long integers, short, care and so on. The type is always determined at compile time by the compiler for any given expression and the expression evaluates to a value that is the value of the expression and that is essentially known only at runtime when the expression gets evaluated. For example, if you look at the expression x plus y where x is the value 3 and y has the value 5, then the value of the expression x plus y will be 8 nothing very unfamiliar about this. So, an expression in general could be simply variable for example, x or y or whatever variable. So, a simple variable is also an expression and expression could also be a constant literal such as the number 10 or the number 3.1417 etc etc. And the more complicated expressions are formed out of these kinds of simpler expressions by using operators. So, we are already familiar with some arithmetic operators like plus minus division, multiplication and so on. Every operator has some operands most of the operators that you have seen so far are binary operators which means that they have two operands. So, in this example x plus y is an expression plus is the operator and x and y are the operands for this expression. Let us talk a little bit more about the constant literal of various kinds. The integer and coding point constant literal service familiar notation will not deliver the syntax of these integer and coding point constants. They are very familiar to you already. There are some examples minus 2 is an integer literal so R 25 and 47 etc. So, an integer literal essentially the sequence of digit optionally followed optionally proceeded with a plus or minus sign and here are some examples of coding point literal 5.0 there can be a sign plus or minus minus 10.45 for example. And we could also use the familiar exponent notation. So, for example 3.0 E minus 12 is same as 3.0 into 10 to power minus 12. These are also coding point literal. By default integer literals of this kind have the type int and coding point literal of these kinds as the type double. But we can say that the particular integer literal or a coding point literal has a different type as follows. So, for an integer literal constant if you suffix the letter L then the type is declared to be long rather than the default type int. Similarly, if you suffix U after the literal then the type becomes unsigned and if you suffix U L then the type becomes unsigned long. So, for example 5 has type int 45 L has the type long and 45 U L would have the type unsigned long. Similarly, for a coding point literal if we use F or L as a suffix after the constant then we are forcing it to be off type float or long double respectively. Remember that the default type for coding point constant literals is double. So, for example just 5.4 has a type double. 5.4 F has a type float and 5.4 L has a type long double. We will be wondering why the type of these constant literals is important as we will see soon the type of the various components of an expression determines the type of the overall expression and in some cases depending on the type even the value of the expression machine and so therefore, it is important to talk about the types of these constant literals as well as any other kinds of components that expression might have. We had talked about the character type or the cat type in the last lecture. You can also have a constant of type cat. Remember that characters are stored by the F key codes inside the machine. So, a character constant is denoted by the character that we wish to use within the single code character. So, for example, the A within the codes or C capital C within the codes etcetera these are all different constant literals of type characters. Note that such a constant literals denotes an integer of type cat and the value of the integer is the C code of the character. Recall that the type cat is actually just an integer type of a byte of size 1 byte or 8 bits. So, these are also actually integers, but the integer that this particular constant denotes has the value which is seen as the ac code of the corresponding character A or capital C or 5 etcetera etcetera. So, therefore, it is important to note that the value of the constant literals 5 within codes is the integer 53 which is the ac code of the character 5 and not 5 itself. So, we had put no codes around the character 5 then it could have the value 5 and of course, all such character literals have the type cat. Now, there are apart from these usual characters there are certain characters which are not printable or for some other reason cannot be easily denoted in this notation that we have seen. So, these are denoted using certain S H sequences as they are called. For example, within code within single code characters that slash followed by N denotes the new line character which is the character corresponding to the enter key on the keyboard. Similarly, backslash T within codes notes the tab character and so on. If you want to use the backslash character itself then you have to use backslash backslash that is two backslashes within codes and the single code character is denoted by a single code followed by backslash and then two single codes. So, in other words within single codes backslash code denotes the single code character and still there is a double code character is denoted by backslash double code within the code character. Okay, let us move on to operators now and let us begin with arithmetic operator. We are already familiar with some of the basic arithmetic operators like plus minus star with strength of multiplication and slash with strength of division etcetera. These are all binary operators that is they have just they have two operands. The operator plus and minus can also be used in the unary form that is with just one operand. So, for example, plus x is in this expression plus x we are using plus as the unary operator plus and similarly minus x is an expression where the unary minus operator is being used. Of these operators all of them can be used for integer as well as floating point operands but the behavior is slightly different especially in the case of the division operation that is the slash operator. In the slash operator with the slash operator the result differs depending on the type of operands. So, if the operands are digitized then the result of doing the division is the quotient obtained by dividing the two numbers whereas if the two numbers are of floating point kind then the exact value is the one that is the result of the expression. So, for example, 5 for 5 slash 2 would be 2 because 5 into 2 are integer and therefore, 5 slash 2 evaluate to the quotient of the division which is 2 and 5 slash 2.0 for example, 5.0 slash 2.0 would result in the value 2.5 because in this case the two operands are floating point operands. There is another operator called the percent operator which applicable only to integer type and this essentially returns the remainder of the division operation. So, for example, the value of the expression 5 percent 2 would be 1 because if you divide 5 by 2 the quotient is 2 and the remainder is 1. So, the 5 percent 2 expression evaluate to the remainder which in this case is 1. So, so far we had been assuming that the two operands involved in a particular expression are of the same type but in general it is possible that the two operands are of different type. So, for example, what is the value and indeed what is the size of the expression 5 slash 2.0 is the result of type floating point with the value 2.5 or is the result an integer with the value 2. So, that is the question that we need to answer and the answer is that in such cases where the two operands for an operator are of different type then the value of the operand of the lower type is promoted to that of the higher type. This is known as implicit type conversion will discuss what the higher and lower types mean in a minute. Essentially the higher of the two types is roughly taking the one which can store a larger set of values. So, for example, the type float would be higher than the type in. So, in this particular example you see that the two operands are 5 and 2.0 as you know by now by default the type of the integer literal 5 is in whereas, that of the floating point literal 2.0 is double. So, now double is a higher type than in and so therefore, what is going to happen is that the value 5 is going to get promoted to a double and that will result in the value 5.0 and the result of the operation therefore, would also be a double since both the operands are now of the type double and of course, the floating point division is going to get used since both the operands are of type double and the answer would be 2.5 of type double. Note that in this implicit type conversion if one of the operands happens to be for example, a variable then it is not the type of the variable that is itself getting changed. So, if you had the in this case instead of 5 divided by 2.0 we had 5 divided by x where x is of type float and the value is 2.0. For example, in this expression 5 divided by 2.0 suppose you had a slightly different expression. Let us say we had an integer variable called x of the value 5 and then we had the expression x divided by 2.0. Then the type of x would not change as a result of the implicit type conversion that is x would continue to have the value 5 and the type int but the value of x as used in this expression that is what is going to get changed. So, the value will become 5.0 and the type will become floating point but let me state it once again. It is not the type of x which is changing it is only the value of x as used in this expression whose type is being changed. So, let us look at this type hierarchy of higher and lower type. So, as we accept the roughly speaking that the higher type is one which can hold a larger range of values. So, you can imagine that the type hierarchy is going to look something like this. Long double is the highest type followed by double then float, then unsigned long, then long, then unsigned it and int. Note that unsigned long does not really hold a larger set of values then long for example, because the only difference is that the unsigned long type does not allow for negative integers whereas long does allow for negative integers. But the largest positive value that can be stored in the type unsigned long is larger than the largest integer that can be stored in type long. But still the language defines the type unsigned long to be higher than the type long. Now, the types which are smaller than int which are these types these are types like short, unsigned, short, care and unsigned care. These are always promoted to type int before being used in an arithmetic operation. So, for example, if you had two short let us say x and y of with values 5 and 2 respectively then x divided by y in the expression x divided by y both the values would actually get promoted to the type int. And so, this expression would be equivalent to integer 5 divided by integer 2 which would result in an integer value of integer value 2. So, in the expression 5 plus 2.5 is the apply these rules 5 has type int 2.5 has type double. So, the 5 gets promoted to double and it becomes double 5.0 divided by double 2.5 and therefore, the result is the value 2.0 which is double. Okay, let us not talk about another important notion associated with expressions and operators that is the notion of precedence and associativity. Now, again this is something that should be familiar to you from your high school arithmetic. As you know in some expression we need to use bracket to unambiguously specify the operands for each operator in the expression. And where brackets are not used as you know some convention is used to determine which operator will be evaluated first. If you recall you had the BODMAS rules from school which trace at the precedences. Brakets are evaluated first followed by division multiplication addition and then subtraction. And within the two operators of the same time the left to right rule applies that is the operator at the left is evaluated first. So, the three language defines similar rules for determining how the expression is to be evaluated when the operands for each operator are not clear. So, also operators that we have seen so far the three operators star, slash and first hand have higher precedence than the other two operators namely plus and minus. Here we are talking only about the binary operator. The unary operator as we will see later later all have higher precedence than all of these binary operators and all as all of these five operators as you see it left to right. What does that mean? Let us take an example to clarify this issue. So, let us consider the expression x minus y into z divided by 10 plus 3. So, the question is what are the operands for these operators which are being used? There are four operators in this expression the minus the star, the slash and slash. To recall that the the precedence of star and slash is higher than that of minus and slash which means that star and slash are going to be evaluated before the minus and slash. But out of these star and slash since the associativity for both of them is left to right. Therefore, the one which efforts on the left will be evaluated first which means that the operator star is the one that will get evaluated first followed by slash and after that minus and then plus because again the associativity of minus and plus is left to right which essentially means that at the same level at the same bread thing level the operator on the left is going to be evaluated first. So, therefore, the evaluation order of these operands is star followed by slash followed by minus followed by plus and so therefore, this expression is going to be treated as equivalent to while star left the whole thing divided by 10 x minus the result of this division and 3 is added to the result of this subtraction. Note that the precedence and associativity rules tell us in what order the different operators within the expression are going to be evaluated. But it does not say in what order the two operands of the particular operator are going to be evaluated. For example, the precedence rules do not tell us whether expression y is going to be evaluated before the expression y before the expression z. Now, of course of the kinds of expressions that we have seen so far this does not really make any difference but when we look at operators with side effects we will see that this sometimes may make a difference and therefore, it is important to be clear about this point. Similarly, its precedence and associativity rules do not say whether x is going to be evaluated before this expression y star z slash 10 it might be either way. So, we will come back to this point later on when we talk about operators with side effects. So, we have seen the arithmetic operators now let us look at different some other kinds of operators. Relational operators are also another important kind of operator. Relational operators essentially compare two quantities and return a Boolean value that is through a fault. We call that there is no Boolean type in C really and any numeric type can be used as a Boolean type. But these operators will always result in the type in in and the result will always be either 0 or 1. Remember that 0 stands for false and any non-zero quantity represents true but with these operators the result will result if the school will always be the integer 1. So, these are the relational operators defined by C less than less than equal to greater than greater than equal to equal to. Now, this is the comparison equality comparison operator which should be distinguished carefully from the single equal operator which is the assignment operator. Note that comparing to quantities in this question does not change any anything it does not result in modification of any variable and so on. Whereas, the assignment operator does result in the modification of the variable on the left hand side. So, this is different from the assignment operator we will talk about the assignment operator in more detail stat later on and this is not equal to operator. So, the meaning of these things should be here for example, x less than y will result in the value 0 if x is not less than y that is x less than y is false and for result in the value 1 if x is indeed less than y. The precedence of all these operators is lower than that of plus and minus and associativity for all these operators is left to right. Flat later on we will look at the precedence and associativity table of all the operator stat here seen so far. So, the relational operators are essentially useful because they compare quantities and they let us change the flow of control of the program depending on the result whether the result is true or false and so on and in some cases and these are used as the condition in the if statements and the while statements and so on. In some cases as we have seen earlier in the example that we saw last time that of computing whether number is prime or not the condition that we might require in an if statement or in a while loop may be more complicated than a single comparison of two quantities. We might want to say that if something holds and something else also then do something then otherwise do something else and so on so forth. So, therefore, we need the so called logical operator and again the logical operator also result in a Boolean value that is two or false and in the three language the result in the value 0 or 1 of the type integer. Remember that 0 stands for false and 1 stands for true and there are three logical operators we have already seen some of them in action in some examples that we saw last time. The logical and operator is denoted by 2 m percent sign without any blank in between. The logical or operator is 2 vertical bars and the logical not operator is the exclamation sign. So, we need to see what these operators really mean and in what cases do they produce the value 0 or 1. So, let us discuss that in detail. So, let us see precisely what the value of expression even and it would be remember that even and it do are any numeric type expression and 0 denotes false and any non-zero quantity denotes true. So, the result of the compression even and it do can be described by what is known as a truth table. So, there are only four possible values for even in D2 in terms of Boolean values even in D2 can be both true or false and so there are four combinations even a true or false E2 is true or false. Note remember that true means any non-zero quantity that is even if it has any non-zero value it is considered as true and if it has value 0 and it is considered as false. So, there are these four combinations possible for the values of even D2 in terms of Boolean values and correspondingly the result of the expression even and E2 is going to be true or false. So, the expression even and E2 is going to be true if and only if both even and E2 are true and recall that the value of the expression if it is true is always one. So, the value of the expression even in D2 is going to be one if both even in E2 are true that is both are non-zero if any of them is false that is any of them has the value 0 then even and E2 is false and so the value of the expression will be 0. Similarly, we can define it to table for the expression even or E2 again the four possibilities. So, in this case the expression even or E2 is going to be true if either E1 is true or E2 is true or if both of them are true. So, it is going to be false in only one here when both E1 and E2 are false and so we have 0 over here and 1 in all the three entries and similarly we can talk about the truth table for the naught of data which is denoted by the exclamation sign. So, if we have an expression not E where is some other expression then we can also define it to table the difference is that naught is a unary operator and therefore, there are only two possibilities for E which are true and false and correspondingly the value of naught E is going to be false and true or respectively that is if E is true then not E is false which means it has the value 0 and if E is false then not E has the value true which means that it is value is 1. Note that if the value of E happens to be 5 that is taken as true and so the value of naught E will be 0 but if E happens to be false that is if the value of E is 0 then the result will always be 1 and not any other non-zero value. For the arithmetic operator set we have seen so far recall that we said that the order in which the two operands are evaluated is not defined by the precedence and associativity rules. In the case of the AND or operators on the other hand the language does define the order in which T2 operands are evaluated. So, for both E1 or E2 and E1 and E2 the first operand is evaluated first. So, for an expression E1 and E2 the program will first evaluate expression E1 and if E1 happens to be false note that regardless of what the value of E2 is the answer is going to be 0. Therefore, in the expression E1 and E2 the expression E1 is going to be evaluated first and if it turns out to be false that is 0 then the expression E2 will not get evaluated at all and the result of the entire expression will be 0 and similarly in E1 or E2 the expression E1 will be evaluated first and if its value turns out to be non-zero that is it is true then regardless of what is the value of E2 the answer of the expression even or E2 is always going to be true that is 1 and so therefore, if E1 evaluates to true that is non-zero then E2 does not get evaluated in this case at all and the value of the entire expression is 1. E2 will get evaluated in this case only if the expression E1 evaluates to false that is 0 and in the case of E1 and E2 the expression E2 will get evaluated only if E1 is evaluated to true that is E1 evaluates to the value true that is any non-zero value only then E2 will get evaluated because this E1 turns out to be false and there is no need to evaluate the second operand of the expression. This fact is not very significant right now but again as I said earlier once we see expressions with side effects then it will make a difference as to whether or not a particular expression is evaluated because that might result in changes to the values of some variable and therefore, this fact is important to remember we will come back to this when we talk about expressions with side effects. So, here is a complete coincidence and associativity table for all the operator's sets we have seen so far and these operators are in the decreasing order of precedence that is the logical knot and the unary plus and the unary minus operators are have the highest coincidence and the associate right to left not left to right next higher coincidence is that of the star flash in percent operators then plus and minus and then the less than greater than etcetera of a relational operators less than less than equal to greater than greater than equal to and below that are the two equality and not equality operators equals and not equals and finally, the logical and followed by the logical or and except for the unary operators in this table of the highest coincidence the rest all associate left to right. So, let us now see some examples of expressions and see how they are interpreted in accordance with this precedence and associativity table. So, here is the first example i less than j minus 1 this is the same as i less than within brackets a minus 1 this is because less than has a lower coincidence than the minus operator which means that minus will be evaluated first which means that the bracketing is like this. Okay, let us look at a slightly more complicated expression this time this expression is x less than equal to 3 and y is equal to 5 minus t or z less than 7. Now, the different operators in this expression are less than equal to here and equal minus or less than so, you go back to the table you will see that minus of these operators the minus operator has a higher coincidence followed by less than and less than equal to followed by equal followed by and followed by or which means that the operator is going to be evaluated in this order that is the minus operator is going to get evaluated first which means that we can straight away put bracket around 5 minus t. Once that is done the next higher coincidence operators are less than equal to in less than of these since the associativity is left to right the less than equal to operator will get evaluated first. So, x less than equal to 3 is bracketed and then z less than 7 is bracketed and after that the next has has the coincidence operator is equal to so it gets bracketed like this and finally, the end operator gets evaluated and after that the or of it gets evaluated. Let us look at a general example this kind of expression is commonly used in mathematics to denote that the quantity y is between the quantities x and z that is x less than y and y is less than z but if you apply the rules that we have just seen so far we will find that in C this is not true and the expression x less than y less than z is actually not the same as the expression x less than y and y less than z. In fact, if you apply the associativity rules it is the same as x less than y and then they are same less than z. So, in this expression this is x less than y will evaluate to either 0 or 1 depending on whether x is or x is not less than y and then we are comparing red against 0 or 1 which is probably not what was intended. So, in this lecture we have talked about operators of various kinds in particular we have talked about arithmetic operators, relational operators and logical operators. They are also seen what is meant by the precedents and associativity rules for these operators. In the next lecture we will start with operators with side effects and then go on to formally describe the control statements in C which you have already been informally introduced to like the if statement and the while is open. you you you you you you