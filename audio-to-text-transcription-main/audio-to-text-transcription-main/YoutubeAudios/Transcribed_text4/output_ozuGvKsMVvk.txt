 In today's lecture we will talk about a very important and useful feature provided by the C programming language and that is notion of structures. So essentially the use of structures is that using structures you can put several pieces of related information at the same place in a single variable instead of spreading them around the program in different variables. And so as you can see a structure is also a composite type because it is a structure is comprised of smaller units of data. However the difference between an array and a structure is the following. An array is also a composite type like structure except that all elements of an array are of the same type whereas with structures we can have different elements of different types. The other difference between array and structure is that in areas the individual elements of the array are accessed using numerical index which is an integer whereas the different elements in structure are accessed by different names. We can give different names to different elements and that makes it very useful. And as I said the other difference is that the different elements of a structure can have different types whereas the elements of an array all have to have the same type. So let us consider a simple example where we might want to use structures. So because we are writing a program that is maintaining student records and so on and so we need to maintain various pieces of information about every student. So we could define a structure for storing the information about the student in the structure declaration might look like this. So this entire declaration defines a new type whose name is Strap Student. The keyword Strap indicates that this is a structure that we are defining and the world student is a name for the structure type and then within the process follow the declarations of the various components of the structure and we can have arbitrary types. So the first element in this case is name that is the name of the element which is store the name of the student and the type of this element is an array of 20 characters. So that shows that can have arbitrary types inside the structure so the elements can really have any other type. The next element of the structure is a field called role number which is of type end so this will probably be used to store the role number of the student and finally we have an array of two integers for storing maybe the exam marks of the particular student. So if we look at such complex structure let us first create some examples involving simpler structure. So suppose we need to write a program that deals with complex numbers. So as you already know the complex number has two parts, a real part and imaginary part and to represent a complex number essentially we need to store both these parts. So the ideal representation of a complex number would be we have a single variable stores both these parts and so therefore we declare a struct complex which defines a new type for complex numbers and we can see that there are two elements or two fields of this structure with name, real and image and both are of type float. So this complex number will have two parts, a real part and imaginary part which are both flotic point numbers. So once you have a declaration like this you can now declare as many variables of this type as we want. So this thing that declaration does not declare any new variables it just declares a new type. This is the first time that you are seeing such a notion. But once you have declared such a type so a tau struct complex is now available to us and we can declare any number of variables of this type. So for example this declaration declares two variables C1 and C2 which are birth of type of complex which means that C1 as well as C2 will birth have their own real parts and their own imaginary parts. Now we use the dot operator to access individual fields of its structure. So obviously we are given a structure we need to be able to manipulate the different fields of the structure. And the dot operator is used to obtain an element of structure given the structure itself. So as an example let's assume the same structure complex declaration. So let's say C1 is available which we have declared to be of type structure complex and now we can access it as well and imaginary parts as shown. So essentially C1 dot real will denote the real part of the structure C1 and C2 C1 dot image will denote the imaginary part of the structure. So essentially C1 is a variable which comprises of two boxes which are large enough to hold an integer. And the names of these boxes you could think of as being C1 dot real and C1 dot image. And as these assignment statements show these expressions can be used on either side of an assignment. So C1 dot real is equal to 10.53 would essentially assign the value of the real part of the structure C1 to 10.53 and C2 dot image assign C1 dot image will copy the value of C1 dot image that is imaginary part of the variable C1 to the imaginary part of the variable C2. So C2 is also let's assume is of a similar type. So this assignment statement will copy the value to this value. So whatever this happened to be at say 5.0 then this also becomes 5.0. And as you can see the types of those expressions will be types declared for these fields. So we had declared real to be of type float and image also to be of type float and therefore C1 dot real will have the type float and C2 dot image will also have the type float. Now structures are full-fledged types and we can do all the usual kinds of operations that we can do with other types. In particular we can pass structures as arguments and we can also write functions which return structures as return values. So as an example for passing structures as arguments and returning structures as return values let's consider a function to add two complex numbers. So we have a function add complex which is supposed to add two complex numbers. There are two parameters C1 and C2 birth of type struct complex and the returns are also struct complex. Now how do you add two complex numbers? Well that's very easy you just have to add up the real parts and the imaginary parts separately. So that's where this function does. It declares a local variable called sum of type struct complex and sum dot real is assigned value C1 dot real plus C2 dot real and sum dot image is assigned value C1 dot image plus C2 dot image and finally the value of sum is returned. So here is a function add complex to add the two complex numbers. It has two parameters C1 and C2 birth are of type struct complex that is C1 and C2 are birth complex numbers and the return type is also struct complex. That is we are going to return another complex number from this function. So it declares local variable called sum which is also of type struct complex and now to add C1 and C2 all we need to do is to separately add the real and imaginary parts and that's what this two lines of code are doing. The variable sum after these two assignments will have the will represent the complex number C1 plus C2. So sum dot real is C1 dot real plus C2 dot real sum dot image is C1 dot image plus C2 dot image and finally function returns the value of sum which is C1 plus C2. Okay now one thing that we need to understand about structure as opposed to arrays are that structures are passed by value. That is when a declared structure variable that variable represents the structure itself and not the address of the structure and therefore when structure is passed as an argument to a function its value is copied to the parameter and its value is nothing but the values of all its components for all of its fields. So the values of all its fields are copied to the corresponding spaces in the parameter and this is different than for arrays as you know when you pass an array what is actually getting passed is starting at the array and not the values of the elements of the array. And therefore the implication of the fact is that if the call function modifies the field of the parameter which happened to be a structure and the fact is not visible in the called function. We will see an example using a variant of the complex function that we just saw and if you remember when structure is returned from a function a copy of its value is made and that copy is what is returned to the calling function. So let us assume an example as the user's left to the different version of the complex function that we just saw so where we do not have a local variable sum and what is going on is the sum is being computed in the parameter 3 on itself. So C1.Ruel plus U2.Ruel that means the value of C2.Ruel is added to the existing value of C1.Ruel and similarly C2.Ruel is added to C1.Ruel and finally the value of C1 is returned. And this is how the function is getting called from the main program. We have three local variables C1, C2, C3 of main and we call add complex C1, C2 and the return value is stored in the variable C3. So let us assume that the function add complex is called this is where the three variable C1, C2, C3 of the main function look like C1 have a real part and imaginary part and similarly C2, C3 and let us say C1, 5 plus 7 i and C2 is 6 plus 3 i and C3 is unvegized. So when the function is called, you know what happens first is that C1 is created for the parameters of the called function which in this case happen to be C1 and C2. So the first parameter C1 and parameter C2 of the function add complex has been created. Next what is going to happen is that the values of the arguments are copied into the corresponding parameters. So the arguments are expression C1 and C2 when C1 is evaluated, it evaluates to the entire structure 5 and 7 and similarly when C2 is evaluated, it evaluates to the structure containing 6 and 3. So when this copy happens, this structure value is copied to C1 of add complex and this value of C2 is copied to the parameter C2 of add complex. So C1 gets the value 5 plus 7 i and C2 all C2 gets the value 6 plus 3 i. Now when this statement is executed, C1 dot real is plus equal to C2 dot real. We are executing within the function add complex and therefore C1 refers to this C1 and not to this C1 and similarly C2 refers to this C2 and not to this C2. So this statement will modify the real part of this C1 which is this value. So this value will become 5 plus 6 at 11 and imaginary part will become 7 plus 3 which is 10. So the next step C1 dot real becomes 11 and in the next step C1 dot imaginary becomes 10 and finally the value of C1 is returned. So when this value of C1 is returned, this value will be copied into the variable which is going to hold the return value in this case C3 and so this copy is made and now the function add complex as returned. So as you know this source for its local variables and parameters will be removed or DL located so these variables will now cease to exist and C3 has become the sum of C1 and C2 but the important point is that these changes to C1 did not affect the value of the variable C1 in the calling function. Now let us look at some other operations on structures and the basic operation that we can do is that a structure can be assigned to a new structure variable of the same type. So let us go in C1 and C2 are variables of type structure complex that is a complex number. So this assignment is valid. Note that the left hand side is a variable which is a structure type and the right hand side is also an expression which has the same structure type. So the C1 assigned C2 is valid and whatever is the value of the complex number C2 that gets copied into the complex number C1. Again contrast goes with the arrows. With arrows an arrow variable cannot appear on the left hand side of an assignment expression because an array variable as an expression denotes the starting address of the array and not the contents of the array itself. And the starting address of an array is safe. It is assigned by the compiler that can't be changed and therefore an array variable cannot appear on the left hand side of an assignment. Therefore in the case of structures a structure variable represents the contents of the structure and not its starting address. And therefore it can appear on the left side of an assignment like this. So if C2 happened to have the value 5 plus 7i then after this assignment statement C1 will also have the value 5 plus 7i and this value gets copied here. So let's now look at some more complex structures and the simple structures that we have seen. So let's recall the student structure that we already saw. Struct student will contain three fields near the student, the role number and the two exam marks and let's assume that we declared a variable S of the abstract students. Now what if S sort exam marks represent? S sort of exam marks represent this component of the structure S which is an array. So therefore S sort of exam marks represent really a pointer to an array of two integers. And so S sort of exam marks 0 and S sort of exam marks 1 will represent the two elements of this array. Note that S sort of exam marks itself is an array and where S sort as for errors it represents the starting address of the array rather than the contents of the array. So if you now happen to pass S sort of exam marks as an argument to a function then it is the starting address of this array which is being passed. So remember look at the structure pictorially. This is where it looks like it has an error S 22 character which is field called name. And then it has a single integer called role number and then it has an array of two integers called exam marks. And S is the name of the entire structure that is a variable. And so therefore S sort of name is an error type it is an array of 20 characters and therefore the variable itself represents the starting address of this array. This expression S sort name represents starting address of this array and again it cannot appear on the left side of an assignment because the starting address of this array is fixed. So S sort of number can assign on the left side of an assignment because this represents just an integer variable this particular variable. And so this could be assigned to the value 123 or whatever as it happens to be. And similarly S sort exam marks represents an array and therefore the starting address of that array. And so the usual rules for arrays will apply whereas for S sort of role number the rules for integers would apply. Okay now we can also have structures inside structure. So we can have one structure type as a field or a component of another more complex structure type. As an example consider a program that deals with geometric objects. So for this program we need to represent we need types to represent points, lines and so on so forth. So we could represent a point by just its xy coordinate. So here is a declaration for a structure which represents a point. Now a line perhaps is represented by two end points or a line segment is represented by two end points which are birth points. So this structure contains two fields P1, P2 which are of type struct point. So therefore if you look at the pictorial representation of your line it will have inside it two structures called P1 and P2 and these in turn contain two fields each so called x and y, x and y. So now if we have declared L as a variable of struct line then L dot P1 represents this entire structure and therefore L dot P1 dot f represents the x part or the x coordinate of this particular point P1 of the line L and similarly L dot P2 dot y will represent the y coordinate of the second end point of the line and so on so forth. We could also have arrows of structure not only could we have structures containing arrows but we could also have arrows of structure and the structure itself in turn could actually have other areas within them. So you can see that using these kinds of building blocks we can build some very complicated data structure. So let us sum that to the student structure that we were talking about earlier. Now suppose a program needs to maintain records of all the students in a particular class. So we probably need to maintain these two in records of the various students in a array. So where we have declared an array called my students which is a self-hundred and the self of each element of the array my students is struct student. So therefore my students is an array each of whose element is a student structure and so for example if I have this expression my students I dot well number. So my students I will be the I have element of the array my students which happens to be a student structure and therefore my students I will dot well number the notes the role number of the I have student in this array and similarly my students I dot name what represent the name of the I have student and so on so forth. We can also of course have pointers to structures like we can have pointers to other kinds of variables and these pointers to structures work in the same way that pointers to other kinds of variables work. So for example suppose we have a variable C1 of type struct complex and what we are declaring here is a variable P which is of type struct complex star and what that means is that P as a type which is a pointer to a struct complex and now what we are doing is star P1 dot well assigns and so what does this mean this should be star P not star P1. So star so P is a pointer to a structure and so therefore star P represents that structure and therefore star P by real represents the real of the field called real of that structure. So in terms of a picture this is what is really happening here the C1 variable C1 is a structure with a real part and an imaginary part and a variable P is a pointer which points to this structure C1 and so star P will represent this structure and where star P dot well will represent this field of this structure and that is getting assigned the value 10. So this assignment statement causes C1 dot real to become sen because P points to the variable C1 and therefore star P dot real represent the same thing as C1 dot real. Now this is a very common operation that I would have do as an pointer to obtain the structure to be the pointer point and then refer to a particular field of that structure. So these two are applied together C provides a shortcut so the operator error will conclude that the operator error will be the same as C1 dot real. So this is what we use it P error will use exactly the same as C1 dot real so we could have written this statement as P error real assign 10 and of course we could also have used it on the right hand side of an assignment and so on so forth. Okay having looked at structures you will wrap up this lecture by briefly talking about input and output from file. So far we have been doing all our input output from the terminal that is all the inputs that the program expected the user had type and the terminal and all the output again went back to a terminal. Now in general when we are writing programs that require large number of inputs and the output is also volume in us we want the program to be able to directly read in right file instead of expecting all the input from the terminal and that of course can be done and there is actually very similar to the way input and output is done from the terminal we will shortly see the library function for doing that but the basic difference between IO from a terminal and IO from a file is that before we can read or write a file from our C program we need to search and it first. And when we open a file what we get is what is known as a file handle, a handle for a file or in C it is also called a file pointer. The type of group file pointer or file handle in C is file star file is a type which is defined by the standard IO library of C and file star is a type for the file handle which is returned to us when we open a file and now once we have once we have opened the file and obtained a file handle for the file then we can read or write to the file depending on how the file was opened and whenever we want to read or write the file we need to specify the file handle for the file instead of the file name for the file in every call. When we open the file that is the only time that we really specify the file handle for the file name for the file and finally when the program is finished reading or writing the file it should close the file again by specifying the file handle we will see the function to do all this in the next slide. So first for opening the file is easy you need to use the F open function of the standard IO library. There are two arguments the first is a string which is the name of the file that we wish to open and the setting is a mode again string which represents the kind of operations that we are going to read do to the file. For example are we going to read the file or write the file and so on so forth and the return type is file star which as we have seen is the name is the type for the file handle. Now the verb should be a string containing the characteristic R if you want to read the file it should be W if the file is to be written. So this the file W as the mode for the file that means that the file will be created automatically if it does not already exist and if it already exists then whatever data it already contain will be deleted and whatever now this program writes will be the only surviving contents of the file. So that means the existing contents of the file will be removed and whatever the data that our program writes to the file that will override the existing contents. And if you don't want to go right if you don't want to delete the existing contents of the file we can open the file for appending by specifying string containing A as the mode and in that case whatever data the program writes will be appended to the file. And of course the green of the file does not already exist and the file will be created. But when we know to go when we want to read the file then the file must already exist otherwise it will be an error and we will not get a proper file handle. So whatever reason to file cannot be opened. For example we are trying to open it for reading in the file does not exist or if we are trying to open the file for writing and we don't have permission to write to the file or maybe the file does not exist and we don't have permission to create the file and so on or maybe we are trying to read the file and we don't have permission to read the file. If anything wrong and the file cannot be opened then after that returns a social pointer value null which will also have occasion to see in the next lecture this is a very useful pointer value. But essentially this is a social pointer value it does not point to any legal memory location. So the pointer is that whenever we open a file we must check the file handle that has been obtained and if that is equal to null that means we are not able to successfully open the file and so we should print a error message in the program should exit if that is what is appropriate. So once we have obtained the file handle to a file with a now use this file handle for doing actual IO on the file and the function for reading and writing files as you will see are very similar to the ones for reading and writing from the terminal. For example we have the S-Pen-F function which is actually the same as it can function that we have already seen. So the S-Pen-F function reads from the terminal whereas the S-Pen-F function reads from a file. The only difference in the argument is that the first argument has to be the file pointer and then before matching as usual the format thing has exactly the same meaning as in the S-Pen-F. Then the function S-Pen-F is again the same as the function gets our for reading one character from the terminal. The file for return three is sent to return one character from the file and the argument is the file pointer. S-Pen-F is the equivalent of the getters function. You set the file pointer to and character array where the data has to be read. Now there are two additional arguments in this case. The third argument is the file pointer and the second argument is the size of the array which has been specified here and the F-Pen-F function ensures that no more than this many bytes are actually returned to this array. Otherwise of course as you know there is an array of points bound violation. The better function does not actually check that array of points violation. For adding to a file the functions are again similar to the functions for writing to the terminal. The F-Pen-F function is actually the same as the printer function except there is an extra for argument which is the file pointer of the file to which we want to write. This file pointer must be opened for writing or for a pending. Similar to the put-clare function we have the F-Pen-F function which takes a character and additionally a file pointer of the file to which this character has to be written. The F-Pen-F function is the equivalent of the put-F function which writes a string to a particular file. And finally the F-Pen-F function is used to close a file as I said once the program is finished reading or writing the file it should properly close the file and you use the F-Pen-F function for doing that. All the unit will specify ESD file handle or the file pointer as the argument. Okay so this will be end of this lecture but before we start here is a simple exercise for you to try using the concepts that we have learned in the last couple of lectures. So the file is to write a program that will read an insert file name and an output file name from the terminal that is the user will type the name of the input file and the output file. The insert file is supposed to contain two written records of the type that just saw one for line. So the program will read the student records from the file. So this is what the records the whole number using the sorting algorithm that we have already seen and finally write the sorted student records in the order of the whole number to the output file. In the next lecture we will talk about another very important technique in programming and that's a technique of dynamic memory allocation which allows us to overcome some of the limitations of arrays.