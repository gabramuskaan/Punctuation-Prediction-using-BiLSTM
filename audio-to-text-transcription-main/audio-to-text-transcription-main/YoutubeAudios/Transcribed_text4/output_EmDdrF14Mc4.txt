 In today's lecture we will look at a very powerful programming technique that known as recursion. In many cases, recursion can be used to obtain in many cases very simple and elegant solutions to many problems that matter otherwise appear very difficult. The basic idea in recursion is that we solve a given instance of a problem. What we mean by an instance of a problem is the problem for the given parameters. For example, finding the factorial is a problem and finding factorial of a given value of n is a problem in the instant. So, using recursion what we do is we solve a given instance of a problem by using a solution to be smaller or a simpler instance of the same problem. So, suppose the problem can be defined or expressed in such a fashion that the problem to a given instance of the problem can the solution to the given instance of a problem can be expressed in terms of the solution to a simpler instance of the problem. Then we can use recursion to solve that problem very simply and essentially how do we obtain the solution to the simple instance of the problem that is accomplished by calling a function from within itself. That is a function f can call itself and that is essentially what is known as recursion. Now, this may appear to be counter intuitive to you because one might say that if a function calls itself then is that not a circular definition of a function well that is not necessarily true. As you know recurrence relations are often used in mathematics to define functions. For example, you know that this is a common definition for the factorial function 0 factorial is defined as 1 and n factorial for n greater than 0 is defined as n times n minus 1 factorial. Now, so n factorial is defined in terms of n minus 1 factorial but tell this definition is found because the solution to the factorial of n is defined in terms of the solution to a simpler problem which is the effective finding the factorial of n minus 1 which in terms which in turn is defining terms of n minus 2 factorial and so on and finally 0 factorial is defined without reference to the factorial function itself. So, the key is to realize that any the solution to any instance of the problem must be defined in terms of the solution of a simpler instance of the problem and finally, there must be a base case in in which for which the solution is defined without reference to the function itself. On the other hand, one could also possibly think of defining the factorial function this way that 0 factorial is 1 as before but now we are defining n factorial to be n plus 1 factorial divided by n plus 1. Note that as a property this is clearly true because follows directly from the definition of the factorial function. But as a definition this definition is not found because n factorial is defined in terms of n plus 1 factorial which is defined in terms of n plus 2 factorial which is defined in terms of n plus 3 factorial and so on and this never ends and so you never reach the base case in which for which n is 0. So, clearly this definition is not found. So, the basic point we are trying to make is that calling a function from within itself recursively as it is known is is not necessarily incorrect. It is not it can not only be correct it can be extremely useful in certain cases as well. So, for example now let us see how the factorial function in C can be defined recursively. We have already seen that the non recursive definition of the factorial problem is simple enough but let us see how it can be done recursively. So, there are two things that we will talk about in terms of in the context of recursion. One is how to think about recursion and how to you know develop solutions to problems using recursion and the other which is equally important to understand is to understand how recursion actually works what is happening when a function is calling itself and so on. So, forth how do we trace the execution of the program and so on. So, what we will do is that in this lecture we will talk about how to use recursion is a technique for finding solutions to problems and how to write recursive function. We will talk about how actually recursion works in the next lecture. So, I said the way you use recursion is if the solution to be given problem in sense can be computed using the solution to a simpler instance of the same problem. Then essentially we assume that the solution to the simpler instance is available by magic. Of course, it is not really available by magic what to obtain that solution what you need to do is to call the same function recursively to obtain the solution to the simpler instance. And finally, of course, you must have a base case in the function definition where the function is not called recursively and the solution is directly given. So, let us see a recursive definition of the factorial function. As I said you have already seen that the factorial function can be defined non recursively also without too much trouble, but the recursive definition would be illustrative that is why we are looking at it. In many cases we will see that the recursive solution is much simpler than the non recursive solution. So, here is the recursive definition of the factorial function. So, we are defining the function factorial which takes a given n which is assumed to be greater than equal to 0 as an argument and returns n factorial. So, first we check whether n is equal to 0 or not because that is the base case. So, if n is equal to 0 then we return 1 because 0 factorial as you know is equal to 1 and otherwise if n is greater than 0 we return n into factorial of n minus 1. Now, this is the recursive call the factorial function is calling itself, but with a different parameter. So, the parameter here is n minus 1 and so factorial of n minus 1 is a simpler instance of the same problem and we are using recursion to find the solution to the simpler instance and finally, using the answer to this problem we are computing the answer to be given instance. So, if the factorial of n minus 1 is known then we know that the factorial of n is nothing, but n times the factorial of n minus 1. Let us look at another problem where recursion can be applied very easily. I call that we talked earlier about the GCD function or the greatest common divisor function and I showed you some properties of the GCD function and we will see that using this properties of the GCD function the GCD function can be implemented very easily recursively. So, these are the property GCD of A and A is A. So, if the two numbers are equal then the GCD is equal to the same number. GCD of A and B is equal to GCD of B and A. So, you can trap the two numbers if you wish and finally, GCD of A and B is the same as GCD of A minus B and B if A is greater than B. So, if A is greater than B then you can subtract the smaller number from the larger number and this difference and this smaller number where GCD is the same as the GCD of the original two numbers and as we will just see the properties can be directly used to implement the GCD function. Here is the definition. So, this GCD function that we are defining there are two parameters A and B. This is the base case if A is equal to B then we return A or return B since both are equal it does not really matter. Otherwise if A is greater than B then we return GCD of A minus B comma B. So, this these parameters A minus B and B define the simpler instance of the problem in this case and given the solution to the to this simpler instance the answer to the given instance is is trivial to compute it is the same as the as the solution to this simpler instance. And if A happens to be less than B then we can mentally trap the two numbers and then apply the last property that we saw and that will result in GCD of A and B being equal to GCD of B minus A and A. So, that is what we return in that case if A happens to be less than B. So, now having written a recursive function we need to be able to argue or convince ourselves that this definition is indeed correct. Now, there are two aspects of proving the correctness of a recursive function or for that matter of any program. The first is to show that the function actually terminates or the program actually terminates. Now, for a recursive function this means that you must show or argue that there is a base case whose solution is computed without calling the function recursively. So, for example, in the factorial function the base case was n equal to 1 or n equal to 0. In the case of the GCD function the base case was when the two given numbers are equal. So, we have to ensure that there is a base case in which the recursive function is not called and in other cases when the recursive call is made then the recursive call is made for one or more problem instances that are closer to the base case. So, for example, in the factorial function the recursive call is made for n minus 1 factorial. Now, n minus 1 is closer to the base case which is n equal to 0 then the given value n clearly and so this process will finally end. So, we have to argue that the recursive call is being made for a problem instance or for multiple problem instances that are all closer to the base case then the given instance. So, once we have argued that the function actually terminates then what we need to show is that whatever answer it does that the function computes for a given instance of the problem is the correct answer. And the way to argue that for recursive functions is very simple use well known and familiar to you principle of mathematical induction you show that in the base case the answer is computed correctly and in the other cases the what you do in proving something by induction is that you assume an induction hypothesis and then show in the induction step that the solution to the given instance of the problem is correct. So, as the induction hypothesis you would assume that the solution to the simpler instances of the problem for which you are using recursion they result in the right answer and if the result in the right answer in the induction step we need to show that the solution to the given instance of the problem is computed correctly. So, let us look at the factorial function and the DCD functions and again and try to apply these kinds of argument. So, for the factorial function arguing that the function terminates is easy you can see that there is a base case is the base case and in the other cases where also in the base case no recursive called the same function is made and in the other cases the call is made for a smaller value of n and so which is which is closer to the base case than the given value of n and therefore, the function will certainly terminate and the other thing that we need to argue is that if when the function terminates it returns to the right value. Now, again we use principle of mathematical induction for n equal to 0 which is the base case the answer is correct because by definition n factorial is equal to 1 and of course, for other cases it is also correct because if we assume that the factorial of n minus 1 is computed correctly then it is easy to see that the factorial of n which is computed as n times factorial of n minus 1 is also computed correctly. So, this happens to be particularly simple example where arguing correctness is quite easy. Let us look at the GCD function next. Now, it is easy to argue that the result computed by the function is correct because we are directly using the properties of the GCD function that we know to be correct. It is a little harder to argue that the function indeed terminates because we need to show that when we made a recursive call the recursive call is for a problem in sense which is closer to the base case. Now, for the base case if you look at the magnitude of the difference of the two numbers given that is 0 because in the base case is equal to 2. Now, in the other cases you can see that the recursive call is made for a instance in which the absolute value of the difference of the two numbers actually is less than the difference of the two given numbers. So, let us say a is greater than b. If a is greater than b then the difference of the two numbers in the instance of the problem that we are solving recursively is a minus b minus b is equal to a minus 2 b and which is less than a minus b. So, we have got we have gone closer to the base case because the difference between the two numbers has actually reduced. Similarly, if a happens to be less than b then the absolute value of the difference between the two numbers is b minus originally b minus a and which is greater than the new difference which is b minus a minus a is equal to b minus 2 a and so again from the difference b minus a we have gone to the difference b minus 2 a. So, the difference between the two numbers absolute value of the difference between the two numbers has decreased and so finally, the difference will become 0 because in each step it is certainly decreasing and therefore, finally, it will become 0 in which case will have reached the base case. So, that is how you argue the correctness of recursive functions. I will see in the next lecture how the recursive functions work, but even without understanding fully how recursive functions work we should be able to use these principles to develop and argue the correctness of recursive function. Now, the question is what you want to use recursion at all? So, as I said in many cases the problems are very difficult to solve without using recursion, but are quite simple to solve by using recursion. The examples that you just saw the factorial function and the d c d function these were not really very good examples of recursion because as you know these functions can be these functions can be implemented quite easily without using recursion also, but we will see some other problems which are very easy to solve recursively and comparatively harder to use comparatively harder to solve without using recursion. So, let us see an example this is the famous accurment function which is defined as follows. So, again it is defined for a for 2 parameter m and n which are both greater than 0 and a of m n is equal to n if m is equal to 0 is equal to a of m minus 1 comma 1 if m is greater than 0 and n is equal to 0 and it is equal to a of m minus 1 comma a of m comma minus 1 if both m and n are greater than 0. So, as an exercise you can try to implement the accurment function without using recursion you will find that it is extremely hard, but as you can see if you directly use this definition then using recursion the function is extremely easy to define. So, here is the possible implementation for the accurment function if m is equal to 0 return n if m is greater than 0 and n is equal to 0 return accurment of m minus 1 comma 1 otherwise return accurment of m minus 1 comma accurment of m comma n minus 1 as you can see that this implementation of the function follows directly from the definition of the function itself and we did not have to think at all about implementation. On the other hand if you want to implement a non-recurricular solution to this problem that extremely hard even though in principle it can be done. So, let us now look at another example of using recursion suppose we did not have useful printf function to print integers for us and let us say we then wanted to print an integers and let us assume that the only library function for printing something on the screen is the put care function which can print a single character given its f key value. So, essentially the problem is to write a function which given an integer n prints that integer on the screen using only the put care library function. Now, how do you go about printing an integer? You can print only one character at a time. So, what we need to do is to find all the digits of the number successively one by one and then print them using the put care function. Now, so the problem is easy if the number is a single digit number. So, for example if n happens to be 6 all you have to do is to call put care with the f key value of the character 6. But if the number is larger than 10 then you have to successively divide 8 by 0 and in every step take the remainder you have to repeatedly divide the number by 10 and in every step take the remainder and that gives you one digit of the number and this process has to be repeated till the number which comes equal to 0. Now, this process gives you all the digits of the number but in the reverse order. So, for example, if the number happen to be 123 when you divide it first by 10 and take the remainder you get 3 and then if you then the number remaining is 12 and then if you take again the remainder with 10 then you get 1 then you get 2 and the number left is 1 and that of course is less than 10. So, you get all the 3 digits but in the reverse order. So, if you print them as soon as you take the remainder you will get the wrong result because the digits will be printed in the reverse order. Now, if you want to print them in the correct order then what we need to do is to store these digits that you obtain in an array and then later print the elements of the array in the reverse order. Now, using recursion we can actually make this problem simpler. So, let us think about this problem recursively for negative integers of course, are not difficult to handle. If n is negative to print it all we have to do is to print a minus sign the minus correct and then set to set n to minus n. So, we do not have to worry too much about negative numbers therefore, let us assume that the number is greater than equal to 0. Now, the base case is when the number is a single digit number in in other words n is less than 10. Now, when n is less than 10 it is easy to print the number using put care. So, if the number is n then what we need to do is to find the sq value of the character of the character n. Now, how do we do that? That is quite easy if you take the sq value of 0 and add n to it that will give you the sq value of the character n provided then of course is less than 10. So, for example, if n happens to be 6 then the sq value of 0 plus the integer 6 will give you the sq value of the character 6 and that is because if you recall the sq values of all digits from 0 to 9 are contiguous to each other and in the increasing order. So, the sq value of 6 is actually 6 more than the sq value of the character 0 and so on. So, in the base case printing a single digit number is easy. Now, suppose we have given a number which is not a single digit number let us assume it is a k digit number and where k is less is greater than 1. Now, how do we go about printing this number? Well, you can see that we need to first print the value n by 10. Now, how do we print n by 10? n by 10 in general n by 10 is always going to be a k minus 1 digit number and k minus 1 may also be more than 1. So, how do we print this k minus 1 digit number? Well, we use recursion to solve this simpler instance of the same problem. This is a simpler instance of the same problem because the number of digits has reduced by 1 and the base case is and the number of digits is just 1. So, having printed recursively the number n by 10 then we print the last digit of n which is nothing but n percent n that is a remainder left and n is divided by 0. So, let us say again the number happen to be 123. So, let us assume that n by 10 can somehow be printed. So, n by 10 in this case is nothing but 12 and by making recursive call to the same function let us assume that number 12 gets printed somehow and once that is done all we have to do is now print the last digit of the number which is nothing but n percent n and we know how to print a single digit. So, we can do that easily. So, let us look at the implementation of this function now. Where is the implementation? So, we are I am calling the function print under 4 n the return type is void because it does not return any value it just print a given integer n and n is the parameter which is given integer which needs to be printed. So, if n is less than 0 then we print the minus sign using the put care function and set n to minus n. So, that is it now this is the base case if n is less than n then we know what to do all we have to do is to compute the sq value of the digit that represents n and print that using put care. So, that is what we do here otherwise n is greater than equal to 10 which means that n has at least 2 digits. So, we recursively print the number n by 10 which is guaranteed to have 1 digit less than the original number n and finally, after doing that we print the last digit of n which is nothing but n percent n. So, we obtain h sq value by adding the sq value of 0 to it and print that. So, again you can argue the correctness and termination property of this function in a way similar to what we have argued earlier you can see this function terminates because every time when we make recursive calls the number of digits in the number decreases by 1, strictly decreases by 1 and finally, the number of digits in the number will reduce to 1 in which case the number is printed without calling the function recursively. And of course, you know that to print a k digit number all you need to do is to first print the first k minus 1 digit which are represented by n by 10 and then print the kth digit. So, assuming that recursive call to print the k minus 1 digit number works correctly it is easy to see that the given k digit number will also be printed correctly. So, we will stop the lecture here today and in the next lecture we will talk about how recursion actually works and that will give us a better insight also into how to use recursion in our problem solving exercises.