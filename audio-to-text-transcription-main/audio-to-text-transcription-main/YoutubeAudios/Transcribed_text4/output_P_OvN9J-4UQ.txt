 In the last lecture we had talked about the technique of recursion for problem solving and we saw that essentially using recursion a function can call itself and we can exploit this capability by defining the solution to a given instance of a problem in terms of a simpler instance of the same problem and we saw several examples of using recursion for solving simple problem. Today we will talk about how recursion actually works and what happens really when a function calls itself and how the what is really happening inside the machine when a function is calling itself and all the whole thing works. Let us first recapitulate what happens when a function is called by another function. So recollect when a function is called the following things happen, base is created for the local variables in parameters of the function which is being called. The parameters are initialized with the values of the corresponding argument and the return address in the calling function is told. What we mean by return address is the place in the calling function where control will go back once the called function returns and this is just the statement or part of the expression following the function calls. And when a function returns the space which had been created for the for the local variables in parameters of this function that is destroyed the control goes back to the told return address where it was supposed to go back in the calling function and the return value of the function is used as the value of the call expression. Now with recursion exactly the same thing happens when recursive call is made there is no difference in terms of the kind of things happening when the when a normal non recursive call is made. But the important thing to understand is that in the case of recursive function multiple instances of the same function may be simultaneously acted. What that means is the following consider for example the factorial function. And you call factorial n let us assume we have defined factorial recursively as we saw in the last lecture. So when factorial n is called before this this instance of the call to the factorial function finishes that is before it returns a call is made again to the factorial function this time with the parameter n minus 1 and before that finishes again a call is made to the factorial function with the parameter n minus 2 and so on. So at the same point in time is possible that multiple instances of the factorial function or of the whatever the recursive function is they are simultaneously active that is they are not yet finished. Of course only one is currently executing but the others are suspended and waiting for the call function to return. Now each has instant has its own copy of local variables parameters and they return at it. In other words if factorial n was called and that call factorial n minus 1 that call factorial n minus 2 and so on for each of these instances of the factorial function which are simultaneously active each will have its own copy of the parameter n there were no local variables in the definition and also of the return address where the control is supposed to go back once that instance of the of this is called the factorial function return. So all these things the local variables the parameters and the return address for a particular function call instance are stored in what is known as a stack frame for the function and it will become clear shortly why it is called a stack frame. So essentially at runtime what is known as a function called stack is maintained by the system. So it is a stack of a stack frame what you mean by a stack is what you normally mean by a stack in English usage a stack is essentially a pile of things placed one on top of the other and when you want to remove something from the pile you remove it from the top of the pile and when you place something on the pile you place it on the top of the pile. So the function call stack is similar. So let us say the function f called the function g and f itself was called by the main function. So the function call stack will capture this stack. So each element in the stack is a stack frame so at the bottom is the stack frame for main and on top of that is the stack frame for f and on top of that is the stack frame for the now the stack frame for any function will contain space for the local variables of the function parameters of the function and the return address from the function where control is supposed to go back once the function returns. So let us now see in terms of an actual recursive function what is really happening at runtime. So the example I have taken is the print function from the last lecture which print say given integer n. So let us assume that the main function calls print with the parameter value minus 123 and let us say the control is just before the call to the print in print function in main. So at this point in time this is what the stack looks like. Only the stack frame for main is on the stack we are not concerned too much about what it really contains will be more concerned with what the stack frame for the print in function contain and this arrow points to the stack frame at the top of the stack this called the stack pointer and as functions get called the stack frame will get pushed on top of the stack and so the stack pointer will move upward and when function return the stack frame will be removed from the stack and the stack pointer will move downwards. So in the first step when the call to the print in function is made what will happen is that a stack frame for the print in function will be created and that will contain space for the parameter n there are no local variables of this function and the value of n in the stack frame will be initialized to the value of the argument being passed to this function which in this example happens to be minus 123. In addition the stack frame will also contain the return address where control is supposed to go back once this invocation of the function print in return. Now print in print is being called from this location in the function main and once print in return execution should continue at the next statement. So I am calling this location in the program as R1 so when main calls printed the return address told in the stack frame for print in will be R1 and that indicates where the program should resume execution once the print in function return. So when the function print in the call the stack frame for the function print in has been created as you can see it has space for the parameter n of the function print in and the return address is R1 which happens to be dislocation in the program and the value of n is minus 123 which was the argument which was passed to the function and the control has gone to the first statement in the print in function. So let us now trace the execution of the print in function for this value of n and see exactly how the recursive calls are going to work. So the first statement is if n is less than 0. Now n is minus 123 which is indeed less than 0 so this condition value is to true so the control goes back to the goes to the next to the first statement in the then part of the if statement which is put care the minus sign and so when we do this in the output the minus character will appear nothing else changes so that is all that happen and then the next statement is n assign minus n when that execute of course the value of this n here just changes to plus 123 so that what happens. Now the next statement checks if n is less than n which of course in this case is false so we start executing the body of the L part. Now here is recursive call to the print in function now again what is going to happen is that a stack frame for this call to print in will be created that will also have space for n and for the return address and the value of n for that call to print in will be the value of this expression which is being passed as the argument now the value of this expression happens to be 123 divided by n which is 12 so the stack frame which gets created will have space for another instance of the parameter n which will have the value 12 and that will be the top top stack frame and the return address will be this address R2 because once this call to print in return the control is supposed to come back here and execute this put care statement which follows the call to the print in function. So that is what happens when this function is called and of course as soon as the function gets called apart from the stack frame etcetera being created control will again go back to the first statement of the print in function. So this is what happens this is the new stack frame which has been created note that it also has a parameter n here but this time it is it has the value 12 which is the argument which was passed from the previous invocation of print in and the return address is also different the return address is this location R2 and now we are executing we have started to execute another instance of the function print in while this previous instance is still not finished that is what happens in the question. So again we start executing this call but but note that the value of n is now the n in the top most stack frame and which is 12 at this point in time and the value of n is no longer 123. So even though in the program it is the same n but at runtime these are two different n because each instance of the function call has its own copy of the local variables and the parameters. So let us see so again the control will slow the same way since n is not less than 0 and is 12 in this case so this statement is kept and is not less than 10 so we start executing the as part and again there is a recursive call to print in with the argument n by 10. Now this n now evaluates to 12 because that is the value of n in the top most stack frame so whenever local variable or a parameter is accessed its value is the value for that variable or parameter in the top most stack frame even though below that stack frame there may be other stack frame for the same function which also have the variable n or which have also the same variable or the parameter. So the value of n here is currently 12 and n by 10 would evaluate therefore to 1. So again the same thing happens when this time print in this call to curfably a new stack frame is created which space for n and return address for return address is again R2 because again the print in has been called from this location and therefore when it returns the control should come back to this statement R2 and once again the function start getting executed from the beginning now for a value of n is equal to 1. So again n is not less than 0 but n is less than 10 so put care n plus 0 that means put care the as he code of 0 plus 1 which gives the as he code of 1 and so the put care statement results in the character 1 being printed on the output and this L part is of course skipped and the control goes to the end of the function. Now the function has finished or to be more precise this instance of the function execution has finished and the function is about to return. Now when the function is going to return what going to happen is that this stack frame is going to be destroyed or it is going to be popped off from the stack this will again become the top most stack frame and the control will go back to the location R2 in other words to this location which is the statement immediately following the call to print in the calling function which also happened with print in this case. So when this instance of print and return that is what happened the stack frame for the top most print is destroyed and control goes to the return address which was stored in that stack frame. So we are now again executing the second instance of the print in function which was suspended when it made recursive call to itself. So now the value of n here in this expression is again 12 because the top most stack frame is this one and that has a value of 12 for n. So when this state when this put care statement executes n percent n gives value to that plus the sq code of 0 gives the sq code of the character 2 and put care print stack character on this screen and now this instance of the function is also about to return and when the return happens again the same thing happen this stack frame will be deleted this stack frame will become the top stack frame and control will go back to this return address which again is the address of this put care statement. So that is what happened now we are back in the very first invocation of the print in function the value of n is now again 123 that gets printed that is divided by 10 and the remainder comes out to be 3 plus sq code of 0 gives the s code of 3 that gets printed and this invocation of print is also now about to return and this time when the return happens the control will go back to the location r1 which is the end of the function main. So the main function will return or if there was some other statement in the main function after print end then those statements who have started executing and the stack frame for main would now become the top most stack frame. So the function has returned so finally we are back in the main function all invocations of the print end including all recursive invocations have finished and the output is minus 123 as expected. Okay let us now take another very interesting problem which can be solved very elegantly using recursion and which is actually quite difficult to solve without using recursion this is like a puzzle and it is called the problem of 3 towers of annoying. So essentially in this problem you have these 3 towers let us call them 12 and 3 and initially in the within the tower number 1 there are these end disks which are placed on top of the other each disk has a hole within it so it can be put inside the tower and the disk at the bottom has the largest diameter and the diameter is decreasing as we go up. So this picture shows 3 disks but in general there could be any number of so we assume that there are end disks in general. Now the task is to move these end disks from tower 1 to tower 3 and in one move what can be done is that the top top most disk from any tower can be removed and it can be placed on top of the stack on any other tower but we have to always follow the constraint that a larger disk can never be placed on a smaller disk. Now this actually appears to be a very difficult problem and for large values of n it can be actually very difficult to solve if you try hard you might be able to obtain a solution for n equal to 3 but you will find that as the value of n becomes larger the solution becomes harder and harder to obtain and without using without thinking about recursion in general algorithm is not all that is to obtain but let us think about this problem using recursion. So the task is to move end disks from some tower s to some tower d and this third tower is there because so that we can place some disk on this tower during the process as an intermediate stop for these disks. So from the tower s to the tower d we have to move these end disks. Now how can we do that? If you think about it recursively well the base case is simple the base case is when n is equal to 1 and when n is equal to 1 all we have to do is take the disk from the tower s and place it on the tower d that is not a problem at all but if n is more than 1 then let us think about this problem recursively. So suppose n is more than 1. Now suppose somehow by magic the top n minus 1 disk can be moved from the can be moved from one tower to the another to another tower somehow and of course that somehow is is not really mysterious it can be achieved by using recursion. So the first step is to recursively move the top n minus 1 disk from the tower s to the tower t that is the temporary tower using the tower d as an intermediary. So whenever we want to move some disk we have to specify one intermediate tower where disk can be stored on their way to the final destination. So suppose somehow we are able to do that that is we are able to move the top n minus 1 disk from the source to the temporary tower using the destination as a temporary. So suppose somebody allows us to do that or shows us how to do this step then the next step is to move this bottom disk from the source to the destination. So this is an easy step this we can always perform and finally now again the task is to move these two disks from this intermediate tower to the final destination tower and for this move we can use now this original source as an intermediate tower because it is it is now empty. Now again how do we move these two disks from here to here it is a simpler instance of the same problem so we can use recursion. So let us assume that by doing recursion we can do that but once you do that you can see that the problem is finished and we have obtained the solution. So as you can see using recursion the solution to this problem is extremely simple to obtain as a matter of fact. So let us write a program to do this. So I have written this function move which which solves the tower of an OI problem it has four parameters and is the number of disks which have to be moved S is the source tower which could be 1 2 or 3 and B is the destination tower which could again be 1 2 or 3 and T is the intermediate tower or the temporary tower. So initially if the disks are in tower one and they have to move to the tower three then we will call this function as move value of n whatever the number of disks is 1 comma 3 comma 2 the source is 1 the destination is 3 and the time 3 or the intermediate tower is 2. So this is the base case if n is equal to 1 then we just print the move to move the top disk source to destination directly this can be complete in a single step otherwise when n is greater than 1 we use recursion. So first move n minus the top n minus 1 disk from the source to the temporary using the destination D as the intermediate. So at the end of this step the configuration will look something like this is the source this is the destination and this is the temporary. So the top n minus 1 disk have been moved to the temporary and then move a disk from source to destination so this disk goes here and finally move these n minus 1 disk from the temporary to the final destination these three disks go here. So that is all. So the solution is actually extremely simple once you think about it you can see. And limit is an exercise for you to trace the solution using the technique that you just saw for the printin function and convince yourself actually for small values of n like 2 or 3 that it does work correctly by tracing the sequence of the recursive function calls and creating stack frames and putting values of the parameters and so on. So that is the end of this lecture in this next lecture we will continue our discussion on recursion and talk about some situation where we should not use recursion and how we should not use recursion in appropriately or inefficiently because as we will see it is easy often to write programs which are extremely inefficient when not written properly using recursion.