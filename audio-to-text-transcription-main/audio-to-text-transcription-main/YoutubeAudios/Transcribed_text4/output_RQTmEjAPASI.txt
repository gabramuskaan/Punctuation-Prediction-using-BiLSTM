 In the last lecture we had talked about expressions and operators with side effects. In today's lecture we will discuss a very important aspects of all programs that is input and output. We have already seen how basic input and output of data is done in the simple program that we have written so far. Today we will go into some more details of how input and output is done in C. So, C has no built-in primitive or statements for input and output. For all input and output that is I O we have to use library functions. We have already seen several of these library functions in action. For example, we have seen scan s for reading values from the terminal and print s for printing some output on the terminal. In this lecture we will restrict our system to input and output only from the terminal although in general programs need to read data from and write data to files as well. But we will discuss that in later lecture. Today we will restrict ourselves to input and output from the terminal only. But as we will see using something called I O redirecting facilities of UNIX we can actually use the same techniques to do simple input and output from files as well. So, the two library functions for input that we will discuss today are scan s and get the scan s we have discussed also we have seen examples of usage of scan s already and the output library functions that we will discuss today are print s and put cards. Again print s we have seen some examples of. So, let us start with the print f function as you know this is used to print some data on the terminal. We have seen several examples of usage of this function. The first argument is what is known as a format string which specify essentially what is going to be printed on the screen and how it is going to be formatted. The format string may contain ordinary characters like alphabets and numerals or other special characters which are printed as they are on the screen as they appear in the format string. Plus we can have escape sequences such as that flash and for the new line character and so on. And when you go to print some values whose actual value is not part of the string what is specified by some expression which is an additional argument to print f we use what is known as a format conversion specifier which starts with a person character in the format string. The person character specifies that a value to be printed is supplied as an additional argument to the printer function and the character following the person character in the format string specifies what is the type of the value and how it is to be printed. So we have already seen examples of person D when we use person D in the format string of printers then the argument which follows is assumed to be of type int and it is printed like an integer. If you want to print an unsigned int we should use person U in set and similarly person LD for long person UL for unsigned long person S3 for short person S U for unsigned short person S for double person LF for long double and so on. The person C specifies that the corresponding argument is of type integer but it is not to be printed as an integer but the character whose SQ code is this integer that character should be printed. We will see examples of this and since percent has a special meaning in the format string if we want to print the person character itself we can use percent percent to indicate that we want to print 1 percent character. So here is a simple example which demonstrates some of these specifiers that we have seen. So in this example we have several variables. The variable C is a type care and is initialized to the character A remember that a variable of type care is actually an integer and the value assigned to the character C in this initialization is the ac code of the character capital A. i is a variable of type integer with the value 5 x is a double with value 5.0 y is a float of with value 10.0. We call that literal constants of this type have by default a type double and we have put an F of rate to indicate that we want this value to be of type float. Now here is a print of statement and this first argument here is the format string. Now this has a percent C percent F percent F and since there are 4 format conversion specifiers percent C percent F and percent F they have to be 4 arguments. Now the first argument corresponds to the first argument following the formatting that is corresponds to the convergence specifier percent D and so therefore it should be of type int we have given the expression here as simply i which means that the value of i will be printed as an integer that is the value 5 will be printed and then the next specifier is percent C which means we want a character to be printed and the corresponding argument that is the second argument following the following the format string has to be of type int and it should be the as he code of the character that we want to print. Now he happens to be of type care actually but what is expected is a length. So therefore we have to explicitly say that we want this value to be converted to a value of type integer. So that is why this ink within the bracket indicates that we want this explicit type conversion to be done. This is also called type quotient. They have already seen that in expression sometimes automatic type conversion happens if the operands of a operator happen to be of different type and so on. Sometimes you also need to explicitly perform type conversion in this case it is called type quotient. The third argument is x which corresponds to the percent f here and percent f requires the corresponding argument to be of type double which x is so that is all right but the next one is again percent f which means that we have to supply a double what we want to print is y which is of type flow and so therefore we have again explicitly converted this value to double by doing a type quotient here. So these two are examples of type quotient. So what will the output look like? Well this percent d in format string will get replaced by the actual value of this integer i which is 5 and then after that the character corresponding to the as he code, the character whose as he code is supplied as the next argument will be printed that happens to be a. So a is printed note that there is no blank between 5 and a because there is no blend between percent d and percent c in the format string and after that the two double values will be printed which are 5.0 and 10.0. So it is important to understand at this point in time what exactly is going on when we are using printers. Now it comes out that when we do input and outsource that input and outsource can always only be in terms of characters only characters can be printed on a terminal. So that means that to print anything on the terminal the terminal must be sent a sequence of characters that is as he codes of characters and the corresponding characters are what will what what are going to be printed on the terminal. So therefore if you want to print the integer 50 then we have to send two bytes to the terminal the as he codes for the character 5 followed by the as he code of the character 0. So as he code of character 5 happens with the 53 and as he code of the character 0 happens to be 48. Therefore to print the integer 50 actually two bytes which are 53 followed by 48 have to be sent to the terminal but internally the integer i is represented as the binary equivalent of the decimal number 50. So this conversion has to happen and this conversion is what is being done by the useful library function print s. And the the the way it performs the conversion it is guided by the conversion specified. For example, pretend he says that an integer is specified and it has to be converted to a sequence of bytes corresponding to the digits in that integer. Okay let us now come to a simpler output function that is the put care function. So this function can be used instead of print s when we want to print just one single character on the terminal and we would usually prefer to use put care instead of print s because put care is usually faster. So if what we want to print is just a single character we can use put care instead of print s. The argument to print to put care is an integer of type int which must be the fc code of the character that we want to print. So for example, we want to print x on the terminal then we can use this kind of statement. Put care within rackets int followed by within code x. Now this within code x remember denote the fc code of the character x but the type is care since put care expects an integer as an argument we have explicitly converted it to an integer before supplying it to put care. So this statement will print x on the terminal. Let us now look at the scan f function for reading input from the terminal scan f is the analog of print f or input. Again the input is in terms of character only. Now what we type on the keyboard when we are supplying input as a user are characters for example when I type 5 and 0 what is actually being sent to the program is a sequence of 2 bytes which is the fc code of the character 5 followed by the fc code of the character 0. Now if I want this value 50 to be stored in integer variable we must convert this sequence of fc codes into the binary equivalent of the decimal number 50. So this reverse conversion is what is being done by the scan f function. The use of scan f we have seen earlier in examples it is fairly similar to print f the first argument again is the format string which specified how the input is to be converted whether we expect an integer or a real number or whatever it is and the remaining argument specified where that is in which variable this input data is to be stored. So the conversion specified code nf are fairly similar to those for print f with some minor differences. For example, certainly read an integer. Now what that means remember is that it reads fc code it reads characters and expects characters which constitute an integer. For example an integer really means that you should have optionally a plus or minus sign followed by a sequence of digits and scan f what it does is it reads characters keeps initial wide-space characters, wide-space characters are like the blanks are the new line characters on the tab character and it starts converting once it finds a character which could be sparked off an integer. So it plus or a minus sign or a or a a a a inumoral and then it keeps reading till it reaches the end of the number and then converts the sequence of write as read so far into a single integer and a sign set or source set in the variable which is supplied as the corresponding argument for the conversion specified. In this case, the argument must be a pointer to a variable of type int. We have not really discussed what pointers are. We will discuss that in subsequent lectures later on, but a pointer to a variable essentially is obtained by pre-sixing the M-perfect sign before the variable name. So, in usage of KF as we have already seen that the argument subsequently for matching are M percent followed by some variable name. So, this M percent is required because the argument must be a pointer to a variable of the appropriate type. So, in this case, I must be an integer and we have to use first M percent I as the argument for KF corresponding to presently. There are minor differences from the printf specified. For example, percent X is first load instead of double and percent L S is used for double instead. Similarly, for percent C because corresponding argument must be a variable, must be pointed to a variable of type KF not int. And in this case, what happens is that Sennheff read-se character and assign it value which is the acicode of the character to the variable which has been specified. Note that no character's escape in this case as opposed to when reading an integer, when reading an integer, the initial white space character's escape. But when you when you are reading a character, no character's escape because even white space characters are characters. So, if the first character type was a blank space for example, the variable will be assigned as ac code of the blank character. The get-car function is similar to the put-car function. It can be used when we want to just read a single character from the input. There are no arguments, the return value which means the value of the get-car expression is off-site int and it is simply the ac code of the next character in the input. So, for example, if you want to read just one character from the input, we declare a variable X off-site int and use the Sennheff and assignment statement X to sign get-car. This will read the next character from the input and assign it as a code to it. Note that when a character has been read from the input, the next time when we call get-car again, it will return the next character in the input. That is the character which is read here has been in some sense consumed by get-car. So, when we call get-car again or indeed scan F or any other function for reading from the input, then this character since it has already been consumed is no longer available. So, for example, if we use a type X Y Z and then we call get-car three times, then we successfully get the ac code for the character of X Y and Z. One important point to note is that the variable which is used to store the return value of get-car must be of type int always. We will come to the reason why this is so in a little while, but never use a variable of type-car or something else to store the result of get-car. Okay, let us now use what we have learnt today to write a couple of simple programs. In the first example is particularly simple. All you have to do is to write a program which copies its input to output. That is whatever is the input, the output is exactly the same. So, the way we are going to write this program is fairly simple. We are going to use get-car to read characters again and again, we will call this in a while loop. Till the end of input is reached and for each character red, we will use put-car to output-it. Now, how do we know that the end of input has been reached? We will know that when get-car returns this special value, UF. UF stands for end of file. So, this indicates the end of end of the terminal as well. And on the terminal, how does the user indicate that he finished giving the input when he does that by typing control D online by itself? Now, the reason as I said earlier, the return value of get-car should be stored in a variable of type integer is that the value UF is minus 1. It is a negative value. So, that is why it must be stored in an integer. Okay, so let us now see this program and try to execute it. Okay, here is the program. Very simple program, but there are some structure points about this program. So, we declare a variable of type int, we call the variable C. This will hold the correctors that we read from the input 1 by 1. And this loop says read a character, if it is not end of file, use put-car to print the same correctors. Note that we have used an expression with side effect in this particular loop condition. So, if you look at this particular expression, C assign get-car, what it does is that it calls get-car to get the s-code of the next character, that is assign to the variable C. And the value of this expression itself is the value that has just been assigned to the variable C. Now, that value is what is compared against UF. And effect value is not UF, that is end of file has not been read. Then we use put-car to print the character C. So, this is a very common idiom and this often simplifies the loop condition to use assignment to a variable and then compare the value that has just been seen with something else. Okay, so let us now run this program. I have already compiled this. So, let us hear some input. You can see that we have type several characters, but no output has appeared so far. Output will appear as soon as we press return character. As soon as we press return character, you see that all the characters that we have typed so far they appear on the output exactly the same as they were in the input. Let us give some more input. And when we want to indicate the end of file, we can simply press control D on the line by itself. That will cause get-car to return the UF value and which will terminate the loop and the program will accept. Okay, now we have written this program to read input from the terminal, but unique as a facility called input output read direction using which we can make the program believe that it is input is actually coming from the file. So, for example, if we use this notation to execute the program, we need some input file to let us say copy.c itself. Then the contents of the file copy.c which is the program that we just wrote has been printed on the screen. So, what is happening in this case is that the input is coming from this file. The program does not need to change in order to do that. The operating system ensures that when the program reads from what it believes is a terminal, the input actually comes from the file. And of course, the file does not contain- does not need to contain the control D character because the file has a finite length. And when it finishes, the end of file is indicated to the program by the operating system automatically. So, this way we can actually- we can write any program that is expected to take input from the terminal and we can supply input from the file insects. And similarly, we can actually redirect the output of the program to a file instead of the terminal. So, for example, suppose we do something like this. So, in this case what we are saying is this greater than sign says that the output of the program is being redirected from the terminal to a file called XXX. That is whatever the program prints as output will not appear on the terminal but will go in this file insect. So, let us see if some input. You see that it does not appear on the terminal at all. And if you see now, we already have a file called XXX. We can see what the contents of this file are. This is exactly what we type as the input. And in fact, we can combine both input and output redirections. Let me first delete the file XXX. We can actually combine the input and output redirections both so that the input comes from a file and the output goes to a different file. If we do that, we can actually use the program that we just wrote in a very useful manner to copy files. So, for example, we want to make a copy of the file copy.c. We can do this like this. So, what we are selling the operating system in this case is that when the program copy is run, its input should actually come from the file copy.c and its output must go to the file copy2.c. Of course, you must not use the same file name for both the input and the output redirection that will just corrupt both the files. So, if we just do this, you see that there is nothing better for you from the terminal. And we did not have to give any input either. But the file copy2.c now contains a copy of the file copy.c. So, we can use as you have seen the copy program, this very simple program that we wrote to see the contents of a file by doing input redirection. We can use it to enter some contents into a file by doing output redirection and we can use it to copy, make a copy of the file into another file by doing both input and output redirection. So, as we saw, one of the observations that you made by me cooking this program is that for input from the terminal, the program receives the characters only after the user ends the line. We saw that as soon as we type the character it ends up here again on the output that is because the program received all the characters that we typed only after we ended the line by pressing the enter key. And similarly, although it is not really apparent from this execution, the output also appears only after a new line is printed by the program. So, this is called buffering which is done by the operating system. And we have seen that programs have read input from the terminal and print output to the terminal can be used with files easily using the IOD direction facility of Linux. In later lectures, we will discuss in more detail how the program can directly work with file because in many cases the simple IOD direction is not sufficient. The program may want to open and read several files and write different outputs to different files and so on, which is the simple IOD direction facility is not sufficient, but we will come to that in a later lecture. Okay, here is the example too. We want to write a program which counts the number of characters, the number of words and the number of lines in the input. How do we do that? The idea is very similar to what we have just seen. We again read the input character by character. How do we count the character? That is quite easy. For each character that we read, we increment the character count by 1, which of course initialize to 0. For each new line character that we see, that is the back flash and within code, that is how we will use it in our program. We instrument the line count by 1. So, we are maintaining a word count, the character count, line count and three different variables, all three initialize to 0. For each character see, we increment the character count by 1, for each new line character that we see, we increment the line count by 1, but what about words? Well, we will assume that the words are separated by white space character. Between two words, there must be some white space character. Any number of white space character, remember white space characters are blank, characters, the tab character and the new line character. So, how do we count the words? Well, what we are going to do in this program is that we are going to instrument the word count when a new word starts. Now, when does the new word start? A new word starts when we see a non-white space character followed by a white space character. That means that a new word has started, where white space character of course is a blank or a new line or a tab. Or a world also starts if the first character in the input itself is a non-white space character. For example, if the input starts with the character X, then a word has started, so we must count that as 1. Which means that in addition to storing the current character that we are costing right now, we must keep track of whether or not the previous character was a white space character. Because if what we have just seen is a non-white space character, then we must instrument the count only if the previous character was a white space character and not otherwise. Because if we have a blank followed by X followed by Y, then when we see the X, we should instrument the word count. But when we see the Y, we must not instrument the word count because it is not part of a new word. So, how do we keep track of whether the previous character that we saw was a white space character or not? Very easy, we can use the Boolean variable to keep track of that. So, we will use this Boolean flag to keep track of whether the previous character was a white space character or not and we will have to initialize it properly. Initially, it will be true because if the first character itself is a non-white space character, we must assume that it is starting a new word and therefore, count 1. So, we will initialize it to true and subsequently it will be true or false depending on whether the previous character that we saw was a white space character or not. Okay, so let us look at this program now. Here is the program, this is slightly more complicated program. So, note that I have put a large comment which describes what the program does. We are going to use of course, integer values 1 and 0 as to a false. So, we have as for our usual practice put defines for true and false. Okay, and here the main program start, start there are three variables, line, cache and count, line, cache and words. These are the counts of the lines and the characters and the words that we have seen so far. They are all initialize to 0. Now, this instance is the Boolean variable that we are talking about and this is meant to be true initially and when the previous character that was seen was a white space character. Remember that a Boolean variable can be implemented by using a neat digit type. So, we have chosen to use a type cache, we could have used a neat or a short instead that would be perfectly fine too. So, instances will be true if the last character scene was a white space character and it will be true initially otherwise it will be false. And this variable C of type int of course, is variable that will hold the ac code of the character that we have just seen. The loop condition looks very similar to what we had for the copy program, read a character and compare it with end of file. If we get the end of file as a result of calling cache then the loop terminate otherwise C is assigned the character that we have just seen and we switch to execute the loop body. So, now the first thing that we do is increment the character count we are seen one more character. So, immediately increment the number of characters that we have seen so far and if what we are seeing is a new line character then we increment the number of lines seen so far. That part is very easy. What remains is to figure out whether this is a new word which is starting or not and appropriately update the in-space Boolean variable. So, for doing that we need to first figure out whether the character that we have just seen is a white space character or not. So, if C is equal to the blank character or the tab character or the new line character then we have just seen a white space character. In this case we need to set in-space to true. Note that it might have already been true because the previous character we saw might also have been a white space character but that does not really matter whenever we see a white space character in-space must be true in the next iteration so that is why we are making it true. Otherwise if we have seen a character which is not a white space character now we have to decide whether this is the starting of a new word or whether it is the continuation of an old word and the distinction between the two is that a new word is starting if the previous character was a white space character in other words if in-space was true earlier then this is the starting of a new character of a new word. Note that in this case we have not changed in-space to true. We have changed in-space to true in this iteration only if this character was a white space character and of course a character cannot be both a white space character and an on-white space character. So, if in-space is true that means that what we have seen is either the first character in main input or the previous character was a white space character and now of course in-space should become false because certainly this character is not a white space character so in the next iteration of the loop in-space must be false so that if we encounter another non-white space character in the next iteration we do not count that as a bringing of another word and since this has been a new word we must instrument the count of the number of words. Note that we have used the instrument operator plus plus to increment the values of line scales and words I1. We have already seen what the operator does in the previous lecture it increments the variable and this is the post increment so what it returns is the old value of the variable but in any case we are using this as a statement and so therefore we are starting the value of the expression itself and depending on the preference you know we could have used the free increment or the post increment operators the result would have been exactly the same because the side effect of both is to increment the variable by 1 and return value is the only thing which is different and the return value or the value of the expression is being ignored in this particular case in any case. So, that is all there is to the program and when when the loop ends we have the count of the characters words and lines so we can just print that so we print f using this format string. So, this format string note that the characters C as A R as colon blank will get printed as here the the character's first and D will be actually replaced by the value of the variable's here and again these characters get printed as here this percent D is replaced by the value of the variable words these characters get printed as here and this percent D gets replaced by the value of the variable line and this new line character is printed as it is which means that the culture comes on to the next line and the program ends. So, let us now try out this program I already compiled it again so let us just execute it and let us see some input we already know how to terminate the input. Note that no output will appear till we actually end the output because we are not outputting anything for every character in the input. So, let us terminate the input now. What this says is that there were 104 characters that we typed note that this will include the blank spaces in the new line characters that we typed. Number of words is 17 we can count that is really enough to ensure that this is correct on the first line we have five words six on the second one, right the level and six on the third one that makes it 17 and there are three lines and again we can use IO-RE direction to count the number of words in some other files in some file. So, as before let us count the number of words in this file word count or C itself which contains a program that we just wrote and the program tells us that this file contains 985 characters 178 words and 41 lines and we can actually verify this output by using the standard word count things as utility in Munich. So, there is a program called WC which does pretty much the same as a simple word count program. So, we use the standard WC utility to count the number of words lines characters etcetera in the file word count or C we find that we get the same output. The WC program prints the number of lines then words and then characters. So, we see that it prints it says 95 characters 178 words and 41 lines which is precisely what we also what our program also produce for same files. Okay. So, at the end of the lecture here is a simple exercise for you. We write the copy program yourself but this time we want to make small changes to it so that the case of all alphabet letters is changed that is all lower case letters in the input are converted to the corresponding upper case letters and the upper case letters in the input should be converted to the corresponding lower case letters and the other characters like social characters for lines for new lines etcetera should remain as they are. Now, here are a couple of hints for to help you with writing this program. So, we need to do two things in this program really when we read a character we need to check whether or not it is a lower case letter if it is a lower case letter then we need to output the corresponding upper case letter and similarly if the character happens to be an upper case letter we need to output the corresponding lower case letter and if the character is neither lower case nor upper case then we output the character as it is. So, now how do we check whether for example the character C is a lower case letter of the alphabet we do not need to compare the value of C with all the lower case alphabet letters from A to Z because remember that in the Fck codes of the various characters the characters of the codes for the characters A to Z are one after the other that is B the Fck codes for B is one more than A then the Fck code of the character C is one more than the Fck code of character C of character B and so on so forth. So, it is given the property of the Fck codes it is enough to check that if C is greater than equal to the character A and it is less than equal to the character Z then it must be some lower case letter and similarly you can check whether a character is an upper case letter or not. So, having checked whether a character is let us say lower case letter we need to find the corresponding upper case letter now how do we compute that. Now again we use the same property that the Fck codes for small a to small Z are contiguous and similarly Fck codes for capital A to capital Z are contiguous now which means that Fck is indeed a lower case letter then if you subtract a C code of A from it then what we will get will be the place of the letter C of the character C in the alphabet starting with 0. So, if C happened to be the character A itself this will give us 0 if C happened to be character B this will give the value 1 if it happened to be character C it will give the value 2 and so on and remember that we can do this arithmetic on characters because characters really are nothing but small integers we are only storing the Fck codes of these characters. So, once you know this the place of the of the particular lower case character that we have seen in the alphabet now to that place value if we just add the Fck code of capital A that will give us the corresponding upper case letter for example suppose C happened to be the lower case letter D now D minus A will give us the value 3 because D minus A will give us 1 C minus A will give us 2 and D minus A will give us 3 and if we add 3 to the Fck code for character A that we give us the Fck code for the character D. So, this way we can find out what is the Fck code for the upper case letter corresponding to a certain lower case letter and similarly we want to find the lower case letter corresponding to an upper case letter because this is very similar we subtract the Fck code of capital A and add the Fck code of small A. So, this finishes today's lecture in the next lecture we will start looking at the control statements like the if statement and the while statement and so on in more detail and we will introduce some more useful control statements. you you you you you you you you you you you you you you you you you you you you