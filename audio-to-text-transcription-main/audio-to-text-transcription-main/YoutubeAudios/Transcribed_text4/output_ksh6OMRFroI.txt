 In the previous lecture we had familiarized our lecture and we have also tried these things of the lecture and are now comfortable using the Linux environment. In this lecture we will look at the basic components of the computer and try to understand how it works. At a very low level the computer consists of very large number of complex electronics circuits, but we are interested in this lecture in a more abstract high level view of the computer. So let us look at what the main components of the computer at this high level are. The first component is the system bus which connects all the other major components of the computer. You can think of this bus as the nervous system of the computer which transmits signals from one place to the other. The two most important components are the CPU and the memory. The CPU stands for central processing unit and it is this circuit which executes and understands all programs at the computer executes. The memory shows all data that is needed to run this program. We will look at some details of the memory and the CPU shortly. Apart from the CPU and memory the computer also has a number of input output devices some of which we have already come across in the previous lecture. For example, we are already familiar with the keyboard, the mouse and the monitor. There are two more IOD devices namely the hard disk and the feedback drive. Both of these are mass storage media that is they can store large volumes of data for a long time. These are in contrast with memory. The memory is much smaller in size as compared to the hard disk and feedback drive but is much quicker to access for the central processing unit. Also an important difference between memory and hard disk and feedback drive is that the data in memory is volatile. What this means is that if the power is switched off the data is raised. Whereas the data stored on the hard disk and the feedback drive remains even if the power to the computer is switched off. So all the files and directories that we had talked about in the last lecture are actually stored on the hard disk and the feedback drive. Let us first discuss the memory in some detail. Memory is essentially a correct collection of large number of memory cells and each cell can store what is known as a bit. Bit is a binary digit which means that its value is either 0 or 1 and the memory of the computer is nothing but a collection of a large number of memory cells each of which can store just one bit that is either 0 or 1. And the reason for this storing bit is that the current electronic technology is on the survey and transistors can be in two states either on or off and the two states essentially represent the numbers 0 or 1. For efficiency data is usually accessed from the memory in terms of why that is group of 8 bits which is known as a byte is accessed at one time. Data may also be accessed from memory in larger units for example 2 bytes or 4 bytes or on some computer C1 each byte. Now you can see that the memory consists of a large number of bytes. So for example, you might have heard the term that a computer has 256 megabytes of memory. What that means is that in this computer the number of bytes in the memory is 256 into 2 to the power 20 roughly speaking this is 256 million bytes. So when the C2 needs to access the particular byte of data from the memory it has to specify to the memory circuit somehow which byte out of these 256 million bytes it wants to access and for this reason every byte has a distinct address. So the addresses of these bytes will start from 0, 1, 2 and go up to 256 million or so. It is important to note that both programs as well as the data for these programs is stored in memory. So as you can see that since at the lowest level we can only store 0s and 1s in memory it is necessary that all the kinds of data that we are interested in dealing with are represented as sequences of less 0s and 1. So we need encoding for all kinds of data such as integers, real numbers, characters and so on so forth. So in this lecture we will only look at the coding use for integers and we will not write not talk about when coding use for real numbers and text characters and so on. We will talk about them in subsequent lecture. So let us look at how integers are represented inside a computer. So we are dealing only with non-negative integers as you know any integers can be converted to its binary representation that is the base 2 representation which then becomes just a sequence of 0s and 1 for example. 113 that is the decimal number 113 when represented in binary is 111 0 0 0 1 and you can verify this because as you can see this binary number in decimal is equivalent to 1 into 2 to the power 6 plus 1 into 2 to the power 5 etcetera up to 1 into 2 to the power 0. This is because the binary system is a positional system and this entire expression evaluates to the number 113. But what if we want to represent both positive as well as negative numbers? One possible way is that out of the number of bits available to us we use one of the bits to store or represent the sign of the number that is plus or minus. So for example we can have the convention that if left most bits is 1 that denotes a negative number and if it is 0 then it denotes a positive number and the rest of the bits gives the magnitude of the number. Given this information you can observe some facts if you are using 8 bits to represent an integer and let us say we are presenting only non-negative integers then the largest integers that we can store would be 255. Why is that? Because the largest binary number in 8 bits that we can have is 111 178 times and which in decimal is equal to 255 and if we are storing both positive and negative numbers then we have to use one bit for the sign which means we have only 7 bits for the magnitude and in this case the maximum positive number that we will be able to store will be 127 which is 247 minus 1 and as you can see that if you just use one byte for storing an integer we cannot store a very large range of integers and therefore usually a number of bytes are actually used to store single integer. Typically most computers would use a group of consecutive four bytes in memory to store an integer so four bytes means 32 bits because each byte is 8 bits which means that is we are storing both positive and negative numbers 31 bits are used for the magnitude and which means in turn that the largest positive number that we can store is 2 to the power 31 minus 1. Okay let us now come to the CPU. The CPU as I said is the brain of the computer it is the component that understands and executes our program. However CPU can understand and executes only very simple instructions of the time add a1 comma a2 comma a3 in this example what this instruction represents is the instruction to the computer to add the contents of the memory location whose addresses are a1 and a2 respectively add these two values and store the in the third memory location whose address is a3. So instructions of this kind constitute the machine language of the CPU and the CPU can only understand and execute programs which are written in this machine language. So as you can imagine writing even reasonably complicated programs in such a language is an extremely cumbersome task. For example try to imagine what a program for computing the factorial in machine language would look like. We would have to worry about what addresses to assign to various variables and we would not be able to use high level instructions such as loops and assignments and so on so forth and therefore we require some tools to that the cast of programming is somewhat easier and that is the role of what are known as high level programming languages. High level programming languages make programming easier because they offer higher level or more abstract programming constructs such as variables. We have already seen what these variables are. There are other high level abstract constructs that programming languages offer that we will see throughout this course. There are large number of high level programming languages which have been in use over a number of years for example C, 4th ran, Java and so on so forth. In this particular course we will learn the programming language C but please know that the focus of this course is on learning the concepts of programming. The choice of programming language is only a vehicle to actually implement those concepts in practice. So even though we are learning C in this course you might actually be required to write programs later on in your professional career in other programming languages possibly 4th ran or Java but having learned the concepts of programming you will find that it will not be a very difficult task to migrate from C to some other programming language. Now the problem is that program programming is high level programming languages cannot be directly understood by the machine and therefore we need some tools using which we can actually run this program and that is where tools called compilers come in. So a compiler essentially translates a program in a high level language such as C to an equivalent machine language program for a particular kind of CPU. So a compiler as you can see is specific to both the high level language that it translates from and to the kind of CPU whose machine language it translates the program to. So this program called a compiler automatically performs the translation from a high level language to the machine language of the computer. So therefore when we write a program we will write it in a high level language in this course we will write all our programs in C then we will compile it using compiler for this language. So in this course we will use the C compiler and then we will execute the generated machine language program the compiler will automatically translate our C program into the machine language program for our computer and this machine language program that will be able to execute directly on the computer and it will have the same effect as what we intended in our C program. So let us now see what the factorial program written in C looks like. So I have already written this program and let us add it this file tag.c which contains the C program for computing factorial and this is what it looks like in this lecture we will not go into the details of the C syntax but you can still note that this program in C looks very similar to the algorithm that we have written informally. So here we are saying that while n is greater than 1 we have to repeat these two statements. Note that the assignment operation in C is denoted by an equal sign. So this particular statement result is equal to result star n should actually be read as result assigned results star n like the equal symbol here denotes not equality but assignment. So therefore saying that result is equal to result star n does not mean that n is necessarily 1 and similarly in the in the next line we are not stating or claiming that n is equal to n minus 1 which is of course third we are saying that the new value of n becomes sole value of n minus 1. Here we are initializing result to 1 here we are reading the value of n we will see the details of all these statements later on in the course and here we are finally printing the value of the result. So let us now actually compile this program and try to run it. To compile this program we need to use the C compiler and the command for the C compiler is cc cc. So the arguments that I have given to the Cc command are first of all minus O minus O says that the equivalent machine language program which is generated for the C program should go in the file which is named after minus O. So what this is saying is that the generated machine language program for completed factorial should be stored in a file called track and track.c is the name of the file which contains a C program for computing the factorial. It is a convention that the names of all files containing C program and then dot C. So let us just execute this command by fitting the return key. We do not get any error messages which means that the compiler accepted our program and now you can check that a file called track has been generated and this file actually contains the machine language program which is equal to the C program that we wrote for completing factorial. Let us now execute this program. Since this is in the current directory the relative path to this file is dot slash track and to execute this program I just need to give the command dot slash track and when I hit enter actually nothing happens and this is so because the program is waiting for us to type a number whose factorial is to be computed. So let us enter some numbers let us say file hit the enter or the return key and the result which is 120 is printed. Let us write with some more number. So this is the factorial of 14. Let us try to compute the factorial of 20 and you see that the output is a negative number. This is obviously wrong and this has happened because the factorial of 20 is too large to be stored in an integer. In this machine the representation of an integer uses 4 bytes that means 32 bits and since both positive and negative integers are represented that means the largest positive number that we can represent in this rotation is 2 to the power 31 minus 1 and the factorial of 20 actually happens to be much larger than this number that is 2 to the power 31 minus 1 and therefore we are getting some concentric results. In this lecture we have looked at the basic components of the computer and how they interact with each other. We also saw the notions of machine language, high and high level languages and the role of compiler and finally we saw our first C program and we saw how to compile and execute this program. From the next lecture onwards we will start looking at the C language in more detail and start developing programs which are somewhat more complex than the simple P program that we have seen so far.