 In today's lecture we will talk about two very important problems which find applications in most application areas. These are the problems of searching and sorting, I will explain what these problems are and we will try to develop and analyze some algorithms for these problems. So, let us talk about the searching problem first. The problem is very simple, we are given an array of n element, this could be of any type really and we need to find out whether another given value is present in the array or not. And let us say if it is present in the array, we return the index in the array at which this element is present or if it is not present in the array, we can return minus 1. Now, this problem is of course very simple as you might imagine. All one has to do is to look at each element of the array 1 by 1 and compare it with the given element and if there is a match, if the two values are equal, then we have found the element in the array and we know at what place in the array it has. And we exhaust all the elements of the array, then clearly the element is not in the array. So, this algorithm is called linear search and clearly it takes time proportional to n to find the answer in the worst case because in the worst case, we may have to look at all the elements in the array to say to find the before finding a match or before saying that the element does not exist in the array. Let us quickly see the C function for implementing this algorithm. So, this is the function search, it takes as argument an array and the size of the array. So, there are assumed to be n elements in the array and E is the element that we are searching for in the array A from A 0 to A of n minus 1. So, the algorithm is very simple, we have a loop that runs for I from 0 to n minus 1 that is for each index in the array and in each iteration we compare A i with E and if the value of A i is equal to the value of E, then we return the index at which we found this element that is I. And if this loop finishes that is become all of the loop that means that this return statement never executed and that happened because we never found a match and so therefore, we return minus 1 to indicate that the element E is not in the array. So, you can see that in the worst case there will be n iterations of this for loop and each iteration takes a constant time and therefore, clearly the worst case time complexity of the algorithm is order n. So, the question is can we do better than order n for searching and the answer is no if there is nothing known about the elements of the array because in the worst case we do need to look at all elements of the array at least once. So, therefore, we must do time we must to effort proportional to n but if we know something about the array elements then we can do better. So, suppose the array is sorted that is the array elements are known to be arranged in the non in non decreasing or non increasing order. Now, if that is the case and that happens in many situations that the array is already arranged in certain fashion then we can actually do search in at most order log in time. Now, do we do that the basic idea is very simple if we compare the I's element of A with E and E happens to be greater than A i that means that E cannot be present from A 0 to A i because we know that A i is less than E and since if you are assuming that the elements are arranged in a non decreasing order that means A 0 to A minus 1 they must also be less than E. So, therefore, we need to now focus our attention for searching only to the part of the array which is to the right of A i that is from A i plus 1 to A n minus 1 and similarly if A i happens to be greater than E that means that E cannot be present in A i plus 1 to A n minus 1 because the elements are assumed to be arranged in non decreasing order. So, if A i is greater than E then A i plus 1 A i plus 2 etcetera are also greater than E and therefore, we do not need to look at all these elements to locate E. So, that is the basic idea of the well known binary search algorithm and this is how the algorithm is. So, in each step we compare E with the middle element of the part of the array that we are looking for that we are looking at. So, we basically compare E with A m where m is equal to m by 2 that is the middle element of the array. If A E and A m are equal then clearly we have found E in the array and we have found it at index m. So, M is the answer if E is less than M if E is less than A m then we restrict our first two A 0 to A m minus 1 because we know that E cannot be anywhere from A m to A of n minus 1 and similarly if E is greater than A m then we restrict the search to be to the second half of the array that is from A of m plus 1 to A of n minus 1. And so, in one step itself the problem one step reduces to half because in the next step we have to consider only half the array and similarly after the second step will have only one fourth of the array left that we have to search for E in. And if we keep repeating this process in each step we keep reducing the part of the array we have to look at that we have to look at by half and so it is easy to see that in log n steps the array size will become will will reduce to 1 or 0 in which case the problem is trivially solvable in a constant amount of time. So, let us now implement this as a C function. So, again the header for the function is the same we are given the array A the size n of the array A that is it has elements from A 0 to A n minus 1 total of n elements and E is the value that we are looking for. This variable is low and high indicate what part of the array we are currently focusing our attention on that is this is the part of the array in which we need to search for E. And as we as we saw when we discuss the algorithm in every step this part of the array gets reduced to about half of the size that it was in the last step. To begin with the entire array has to be looked at and therefore, low is pointing to the very first element of the array that is low is equal to 0 and high is the index of the very last element of the array which is equal to n minus 1. So, that is why low is initialized to 0 and high is initialized to 1 because we have to look at the entire array from indices 0 to n minus 1. The variable mid will be used to compute the index of the middle element of the part of the array that we are currently looking at. Now, the number of elements that we need to look at is high minus low plus 1 clearly and so if low becomes greater than high then the number of elements that we that are there in the part of the array that we are looking at will become 0. So, in which case we will have found the answer if the size of the array that we need to look at becomes 0 that means, e cannot be anywhere in the array. So, we know the answer is answer that we need to return e is minus 1. So, where sir as long as low is less than equal to high we keep repeating this process we compute the middle index of this array fragment and if e is equal to the middle element we return this index otherwise if e is less than a of mid then so this is mid. So, if e happens to be less than a of mid that means e is to be find found somewhere in this part of the array. So, which means that high should be set to mid minus 1 whereas, low should remain the same so that in the next step we focus only on this part of the array whereas, if e is greater than a mid then we need to focus our attention on this part of the array in the next step which means that low should become mid plus 1 whereas, high should remain the same. And when the loop terminates that can only terminate and if we reach this statement we should have a return minus 1 here which I omitted by mistake. So, this loop terminates and we reach this statement that means, we did not find the element anywhere in the array because otherwise we would have returned from the function using this return statement and so if we come out of the loop then we know that the element e is not in the array and so we return minus 1. Let us see a couple of examples using animations to see how this algorithm is working. So, let us say this is the given array 3, 4, 7, 19, 21, 23, 30 and what we are looking for is 4 which of course, we know is present here. So, initially low is 0, mid is 6, there are 7 elements in the array I am sorry high is 6 because there are 7 elements in the array and mid is 6 plus 0 by 2 which is equal to 3. So, mid is pointing here. So, we compare e with a mid now e 4 and a mid is 19 and so e is lesser and therefore, in this step high moves to mid minus 1 and then mid becomes the new value of mid becomes low plus high by 2 which is 0 plus 2 by 2 which is 1 and so in the next step we again compare a mid with e and this time they are equal because a mid is 4 which is equal to the value of e. So, we have found the answer and the index 1 gets returned. Let us look at another example in this case we have the same array but we are searching for the element 22. So, now 22 is larger than a mid which is 19 and so, low will move to mid plus 1 and mid will correspondingly change. So, low has become 4 and high is 6 so, the new value of mid is 6 plus 4 by 2 which is 5 and this time again we come they are a mid with e which is 22 and we find 22 is lesser than 23. So, high will become mid minus 1 mid is re computed. Now, low and high have become equal but still the loop will continue because recall that the loop condition was while low is less than equal to high. Low is still equal to high so, this condition is true. So, mid is re computed and it will return out to be 4 again because low and high are both 4. So, we compare 21 which is a mid with the value of e which is 22 and e is greater than this. So, that means that low will become now mid plus 1 and once that happens in the next then the loop terminates because the value of high value of low has actually become higher than the value of high which means that the fragment of the array that we are now looking at has size 0 and an array of size 0 clearly cannot contain any element and so, the loop terminates and we return a failure to find the element in the array. Ok, let us now analyze this algorithm that we just developed. So, let us say the time taken in the worst case is T n as a function of n which is the array size and as for all the first three functions as in this case we can again come up with the recurrence relation for T n because in every step we are reducing the problem size by half. So, if n is 0 which means low is actually greater than high then takes a constant amount of time C 1 otherwise T n is T of n by 2 plus C 2 because if the array size is n then in the next step the array size reduces to at most the floor of n by 2. So, it is not really a recursive function of course, we could have implemented the same algorithm recursively as well, but it is still easy to express the time taken as a recurrence relation. So, we have done that and this recurrence relation of course, should be familiar to you from the last lecture when we looked at the square in multi-clay algorithm this is exactly the same recurrence relation and as we saw last time we can solve it to obtain the fact that T n is order log n which means that the time being taken by this algorithm is proportional to log n instead of n and the number of elements of the array that we are looking at in the worst case is just log n instead of looking at all the n elements. Let us now look at the second problem that we want to discuss today and that is the problem of sorting. The problem of sorting is simply to arrange a given array of elements in some order may be the non-decreasing order or the non-increasing order will we will consider only the non-decreasing order clearly the algorithm will remain the same only the direction of comparison will really change and it does not really matter. There are a number of sorting algorithms which have been developed for this problem. What we will look at today is a very simple algorithm called the insertion sort not the most efficient algorithm known for this problem this is an algorithm which is commonly used by card players when they have a set of cards in their hand and they need to sort it they take the next card and insert it at the right place in the card prior to that. So, that is what the basic idea of the insertion sort algorithm also is. So, at any given step let us assume that the elements a 0 to a i minus 1 are already sorted and to begin with of course if we set i to 1 then a 0 a single element is of course always sorted if an array sequence of one element is obviously trivial is sorted. So, to begin with this is true for i equal to 1 but at some intermediate step let us assume that a 0 to a i minus 1 are correctly sorted but the rest of the elements are not really in the correct places. So, in this particular step what we are going to do is to make sure that the size of the sorted sequence becomes one larger that is at the end of this step will achieve the condition that a 0 to a i are correctly sorted. So, to do that what we are going to do is to insert a i in its correct position among a 0 to a i minus 1. So, that after this step a 0 to a i are correctly sorted and this procedure is repeated from i for i from 1 to n minus 1. So, after the first step the first two elements would get sorted after the second step the first three elements would be sorted and so on and so after the n minus 1 of step the all the n elements of the array would get sorted. Before we write the C implementation of this algorithm let us look at the algorithm at a high level. So, we are given an array of size n and what we do is we run a loop for i from 1 to n minus 1 as we just saw and in each iteration of the loop we assume that a 0 to a i minus 1 are correctly sorted and a i is going to be inserted somewhere in its right place in the correct sorted order within this sequence. So, that the end at the end of this step the elements a 0 to a i are all correctly sorted. So, we need to first find where what is the correct position of a i in this sorted sequence and let us call that position as j that is a i should go at a j where j is less than or equal to i and we inferred a i at the location a j by shifting all elements which are to the right of a j by 1 position and then putting a i at the location a j this will become clear once we look at the details of the algorithm. So, there are two subsets here one is to do this searching of the correct position and the second step is to do this insertion. So, for the searching step we can use binary search because we already know that a 0 to a i minus 1 are already sorted but in the program that we will write I will not do that I will use a simpler linear search and I will leave it as an exercise for you to implement that using binary search which we have already seen. So, using linear search essentially what we will do is we will try to find the first j such that a of j is greater than a of i which means that a of j minus 1 was less than equal to a i but a j is greater than a i and therefore, the correct position for a i in the sequence is at the position at the index j in the array. And so, a i would then be inserted in the next step next sub step at the index j note that it may turn out that j is equal to i. Now, j is equal to i will happen when a i is larger than all the elements a 0 to a a i minus 1 and that is it happens by chance that we sorted just the first i minus 1 element and the i s element was already in a right place. So, in that case of course, nothing needs to be done but we must ensure that our algorithm works correctly even in this case. So, here is an example of the insertion step. So, let us assume that these sequences already sorted. So, i is 6 which means that the 6 element of the array has to be inserted at the right place and a 0 to a 5 are already sorted as you can see in this example. Now, j is 3 in this example because sin should really appear at this location. Now, the way the insertion will happen is let us move out this sin and store it in a temporary variable and then after that shift this element one step to the right again shift the next element one step to the right and shift the next element one step to the right. So, that now 10 can be safely stored here because the old value stored here has been shifted here the value stored here has been shifted here the value stored here has been shifted here and so 10 comes here. So, that is the insertion step now ready to look at the implementation of the algorithm. So, we have this function insertion sort which has no return value takes an array a and an integer n and sort the array a. Note that this function is going to modify the values of elements of a but and it does not return the new value but that is all right because the array as you know is passed as the starting address of the array is really passed and when an element of that array is accessed or modified it is accessed using its address and so therefore, the change is reflected in the array of the calling function. So, we have this local variables i, g and t. Now, this is the outer loop which runs for i from 1 to n minus and for each value of i we have to first do the search search is quite easy. So, we start so essentially what we have to do is for j from 0 to i minus 1 we have to find the first value of j such that a j is greater than a of i because a of i is what we are trying to insert here. So, we start from 0 and we proceed towards a of i minus 1 and as soon as we find a j such that a j is greater than a i we break from the loop. So, when we come here either a j is greater than a i and that is why we broke from the loop or it is possible that j is equal to i if j is equal to i that means that a i is already in its correct position it is already larger than all of a 0 to a i minus 1 and nothing really needs to be done in this case. So, this is the insertion step note that this step happens even when i is equal to j but as we will see that it works exactly even when i is equal to j. So, we first move the value of a i to a temporary variable and then for all locations of the array starting from i minus 1 going back right up to j this should be k minus minus instead of plus plus we move the value of a k to the location a k plus 1 and so all the elements of the array starting from i minus 1 and going back up to j they get shifted one place right and then finally the location a j is given the value t which was the original value of a i. Note that if i happens to be equal to j then all will happen is that t will be assigned a i and then this loop will not run at all because the initial value of k is i minus 1 j is equal to i. So, i minus 1 is not greater than equal to i. So, this condition will become false in the very first iteration and so therefore, the loop body will not execute at all when j is equal to i and so therefore, all that will happen will be these two assignments t assigned a i and a j assigned t. Now, since j is equal to i all that happens is that t assigned a i and again a i assigned t which has no effect really because the same value is assigned back into a i. So, that is as we want it to happen. So, when this outer loop terminates when it has run for all values of i from n 1 to n minus 1 the array is sorted and the function returns. Let us now analyze this algorithm to find its time complexity. The outer loop as we know runs for i from 1 to n minus 1 for different values of i all values of i from 1 to n minus 1 and let us look at one particular iteration of this outer loop. So, let us look at the iteration where for from particular value of i that is the i th iteration of the outer loop. Now, in the i th iteration of the outer loop this loop as well as this loop is will run at most i times because we may have to do this i times because the element which is greater than i may not be present at all in which case we need to look at all elements from a 0 to a i minus 1 and the worst case for this step happens when the value of j turns out to be 0 itself because then all elements from a 0 to a i minus 1 need to be shifted so a total of i element is shifted. So, and if you think carefully about this the number of times that this loop will execute plus number of times this loop will execute will actually always be equal to i. So, therefore, the time taken in the i th iteration is in the worst case is c 1 times i plus c 2 that it is proportional to i plus a constant. Note that if we had made the search step as a binary search step you will instead of using linear search if you had used a binary search over here then the amount of time taken in this step in the worst case would be log i and the amount of time taken in the worst case over here would be order i. But if you add these 2 up that would still be order i. So, which means that the amount of time taken in the i th iteration would not really change in the order notation and therefore, the overall time taken would also not really change in the order notation even though using binary searches of course slightly more efficient. So, for each iteration of the for i th iteration of the loop the time taken by the iteration is proportional to i or we have been noted as c 1 i plus c 2 and therefore, the total time taken is c 1 times 1 plus c 2 for i equal to 1 plus c 1 times 2 plus c 2 for i equal to and so on up to i equal to n minus 1 and so if you add up all that c 1 will have a coefficient of 1 plus 2 plus up to n minus 1 and c 2 will have a coefficient of n minus 1 and c 3 time might be some constant 1 of time required in addition to the outer loop for example, for initialization and overhead of the function call and so on so forth. So, now if you this is an arithmetic series and if you add this up it turns out to be n times n minus 1 by 2 which is a constant times n square plus lower order term and so this entire thing is constant times n square plus lower order terms and therefore, in the big o notation this is order n square. So, this is the end of today's lecture in the next lecture we will talk about a new data type and see that we have not looked at so far which is the structure type.