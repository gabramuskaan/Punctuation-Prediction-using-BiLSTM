 In the last lecture we had talked more about functions than we had introduced motion of scope and left time and we had talked about global variables etcetera. And finally, I have left I had left you with a problem to think about and that problem was to write a program to find a path through the maze. I hope you spend some time thinking about the problem. So, let us just review the problem once again. We want to write a program to find a path through the maze. The maze is represented as a grid of characters, a two dimensional grid of characters, a star in the grid represents a part of the wall where one cannot go and a blank space represents an open space where movement is possible. And an entry point into the maze is given by the user as an x comma y value and remember that we had said that if there is any other exit in the maze, then the path should take one from the entry point to some other exit in the maze. And if there is no other exit in the maze, then the path should bring one back outside the maze through the same entry point. And this member walls our representation of the maze on the x y plate, the star represents walls and the blanks represent open spaces and assuming this is the entry point, this is the path that the program should tell us to take. So, in terms of the coordinate system, this path turns out to be this. Now, this problem might look to be complicated, but as it turns out, it has a very simple algorithm to solve this problem. I will give you the algorithm, but and I will leave you to convince yourself that this algorithm works in all cases. So, the algorithm is very very simple. So, we started the entry point and as long as we are not outside the maze, that is as long as we are somewhere within the maze, we do the following. So, this entire thing is one step in the path. So, we have to maintain a current sense of direction, the direction could be not south east or west. The first thing you do at any place in the maze, you turn right and then if you are facing a wall, turn left, if you are still facing a wall, turn left again, if you are still facing a wall, turn left again and so on. So, as long as you are facing a wall, keep turning left. Note that you cannot turn left more than four times, because then you will be facing in the original direction. And if you had come to a particular point from some direction, then there is at least one way to move from the current point, which is to go back in the direction from which we had come. So, when this loop terminates, then step forward in the current direction. So, essentially while we are turning, the direction is changing. Now, the reason this algorithm really works is that by trying this, we are trying all possible four directions and seeing which way we can go. But we are trying these four directions in a certain order. So, if we reach a dead end and then this loop will make sure that we turn back and come back to some place, which we had visited earlier. And then later on, we will not go back to a path that we have already visited once. That is because when we come back to the same place, we will be facing in the reverse direction, as compared to the direction in which we were facing when we visited this particular place, the first time. So, this is of course, very intuitive explanation of why the algorithm works. I would like to encourage you to take some examples and see for yourself that the algorithm indeed works. And the nice thing about the algorithm is that if there is no path in the maze from the entry point to some other exit point, then it will plot a path which brings you back to the original entry point. So, the algorithm straightforward enough. Now, we have to focus our attention on how to implement this algorithm as a program. And the first thing that we have to worry about for implementing this as a program is how we are going to represent a maze. So, the obvious answer to that is that we represent the maze as a two dimensional array of characters. Because it is a two dimensional create and each character in the array at any I.D. location would either be a star character which represents a wall or a blank character which represents an open space. So, maze x y suppose maze is the name of the array would represent the maze character at position x y. Now, since we will also finally go outside the maze and at other places we will check whether we are facing a wall or not. Now, when we are checking whether we are facing a wall or not, we are going to be at we may be at the edge of the maze and the direction we are facing is outside the maze. So, if you have to check that the character facing us is a wall or an open space, we have to make sure that we do not violate array bounds. Remember that it is very important that when we access an array element the index or the indexes that we specify for the array element are within the bounds of the array. So, we have to make sure that even when we are outside the maze or when we are on the edge of the maze and we are checking and we are facing outside the maze and we are checking whether we are facing a wall or not, we have to ensure that we never violate the array bounds and to make sure that we never do that what we are going to do is to create an open path all around the maze. So, let us say the user gives us a maze of size 5 by 5 what we are going to do is to convert that maze into a maze of size 7 by 7 and in the center of this size 5 by 5 maze the original maze is even by the user is placed and all around it on all four directions there is an open path. So, let me show you what I mean. So, let us say this is the maze that the user has given us. I have instead of putting blank characters I have put the dash character just to show you that these characters exist. Now, around this maze we are going to put a one character thick open path. So, this path we have created outside the maze on all four directions. So, the idea is that even if from this point we come out here and we are at this location the x and y positions are still within the bounds of the array and similarly for example, if we are here and we are facing towards the south assuming that downwards is south and we want to check whether we are facing a wall or not then we will have to check this character in the maze. Now, if the maze is if the array is only till here then this index would be outside the bounds of the array and we will have to we will have to put special checks to ensure that we do not wallet the array bounds by putting an extra path all around the maze we avoid those kinds of complications. So, the next result is that the size that will declare for the maze will be 2 more than the actual maximum size that we want to permit. Let us now try to develop a program for this, but let us first look at a design for this problem this is a reasonably complicated problem. So, here is a possible what is known as functional decomposition of the problem that is we can identify these distinct and independent subproblems and so what we will do is to define functions for each of these and then put together these functions and use these functions in the main program to solve the overall problem. So, the first function is read maze which will read the maze from the user. The second function will be read starting position which will read the starting or the entry point of the user. Note that we need to make these into functions because even though the complexity even though the functionality of these functions might appear simple it is actually little bit more complex because we want to make sure that the input given by the user is always consistent and it is not invalid and so on so forth and so as you will see we need to make a large number of checks on the user supplied inputs and that is why we prefer to make these into independent functions. The next function is outside maze which will just tell us whether we are currently outside the maze or within the maze and you can see that this function would essentially check whether our current position is on that border around the maze that is somewhere on that border around the maze that we are created. So, if it is on the border then we are outside the actual maze otherwise we are inside it. The next function is facing wall which will tell us whether we are currently in the current direction what we are facing is a wall or not. So, if we are facing a wall we cannot move ahead and then functions turn left and turn right which will change our direction appropriately. The step forward function will move one step ahead in the current direction and that will change the current position that we are at in the maze and finally the function print position will use to simply print one position in the path. So, at each step in the path will print the current position. So, we need to write all these functions and as you can see that most of these functions are going to use number of large amount of common information. So, all of those will define as global variable. So, these are the global variable so you do not need the maze itself which is going to be as we said a two dimensional array. Then the actual size of the maze as opposed from the as opposed to the maximum size of the maze that we can accept. So, in the size x will be the actual size of the maze in the x direction and size y will be the actual size of the maze in the y direction and the power x power y is the current position within the maze at what point we are within the maze at any given step and finally direction is the direction that we are facing at the current moment which could be not south east or west. So, let us now put together these ideas in the form of a program and using bottom approach let us develop these functions one by one and then finally put these together into an overall program. So, let us now look at the program for solving this maze problem. So, we start with some constant in global variable declarations. So, this max maze size is a constant which says what is the maximum size of the maze that the user can give. So, this is in the x direction as well as the y direction. So, we have defined this two have the value 20 meaning that the maximum maze size can be 20 by 20 and then we have defined these four constants for the four directions north west south and east. They could have been different to any numbers as long as they are distinct numbers. These are the global variables that we had already identified for the program. The maze is a two dimensional area of characters of size max maze size plus 2 into max maze size plus 2. The direction is the current we are facing which will be one of north west south and east. Pause x and pause y are the coordinates of the current position within the maze and size x size y are the actual maze size in the x and the y directions. So, let us now look at the function read maze that is the first function. So, first ask the user to enter the maze size and read the sizes in the two directions size x and size y. Note that we store the return value of scan f in the local variable r and now we need to check whether the user supplied input for the maze sizes is correct or not. So, if the value of r is not equal to 2 that means, he did not really enter two integers and therefore, the next message should be printed or if the x size or the y size is more than next maze size then the size x specified for the maze is 2 large and we cannot handle that. So, again we should give an error message or if the maze size in either direction is 2 small less maze of size less than 2 does not really make sense then also we should print an error message. So, in any of these circumstances we print this error message that the maze size that was entered was invalid and then we use the library function exit here. Now, this is a function that we are seeing for the first time. So, this exit function is a library function which causes the program execution to terminate immediately. Note that this is different from the return statement in that the return statement causes the currently executing function to immediately return but calling the exit function causes the entire program to terminate immediately. The argument to the exit function is an integer which we have specified as one here. So, this argument to the exit function is a kind of exit status of the program and usually the convention is that if the program terminates successfully then it should exit within exit status of 0 otherwise if it terminates due to some kind of error condition then it should exit within with a non-zero exit status. So, since in this case we are exiting because of an error in the input we are supplying a non-zero value for the exit status. So, after having read the size of the maze we will need to read the actual maze but before doing that we need to be careful because the first line of input that the user entered contained the two integers and at least the return character or the end of line character after that. Now, we are going to use the get-car function for reading the configuration of the maze that is for each position in the maze whether it contains a open space or parts of all. So, in the get-car library function recall that it does not skip any character in the input. So, suppose the user entered 5 and 5 for the size of the maze and then he entered the return character. Now, if we now read the next character we will see the new line character as the value returned by the get-car function. Now, this is clearly not part of the maze itself. So, what we need to do is that whatever the user entered on this line after the second integer and till and including the new line character that needs to be skipped. So, that is precisely what this simple while loop is doing note that the body of the while loop is empty. It has just this empty statement in it. So, the body is not doing anything all the action is actually happening in the condition itself which has the side effect of reading a character because it is calling the get-car function. So, as long as we read characters as long as we do not see a new line character and we stop reading characters when you have seen a new line character. And the effect of that is that on this in first input line whatever the user entered after the second integer till the new line character all these characters are read from the input and they are discarded. So, the next character that we read from the input will be the first character entered by the user on the next line. So, after doing that we prompt the user to start inputting the maze and this big loop reads the maze. Now, how are we going to read the maze? I said we are going to use the get-car function to read individual characters in the maze. Recall that our x and y directions for like this. So, the user is going to give the maze configuration in this fashion that is for he will first supply the entire row for y equal to 1 and then the row for y equal to 2 and so on so forth. The y equal to 0 row in the array we will reserve for the path that we are going to create around the maze. So, for each successive value of y from 1 till size y we have to read the entire row of maze character and the number of character is size x. So, for x from 1 to size x we read the maze character at the position x y using the get-car function and now again we make sanity checks on the input that we have just received. So, the maze character that we have just seen should either be a star character indicating a wall or it should be a blank space character indicating an open path. So, if the character that we just saw is neither star nor the blank character then again we print a mirror message that an invalid character in the maze was entered by the user and we specify in the bracket what character was found to be invalid and then we exit from the program. So, once this inner loop terminates we have read all the characters in the in a particular row and then at the end the user of course, terminated this line by and by hitting the enter key which means a new line character is also there. So, now if we immediately start reading the next row the first character that we will read will be the new line character which of course, would be an invalid character. So, what we need to do is to discard again this new line character and that we are doing by calling get-car one more time to discard the end of the line character at the end of the line. So, after having read the maze now our array is of size let us say 7 by 7 if the size x was 5 and size y was also 5 and what we have done is that we have read this part of the array from the user and this part of the array outside this has to be initialized to a to an open path. Now, note that this part of the open path will have the value y equal to 0 and x will range from 0 to size x plus plus 1 and similarly, this portion of the path will have y is equal to size y plus 1 and x again will range from 0 to size x plus 1 and similarly, these two paths will have the same y but will have the same x but different values of y. So, this first loop is initializing these paths in the north, north of directions on the two sides of the maze. So, essentially what we are doing is for x equal to 0 and for x equal to size x plus 1 we are initializing all elements of the maze to the blank character for y from 0 to size y plus 1. Note that the loop front still y is less than size y plus 2 which means that y is less than or equal to size y plus 1 and then this loop essentially initializes these two parts of the path. So, now we have created the open path around the maze also there is nothing else to be done in this function. So, the function finishes note that there is no return statement. Return statement as we had discussed is not needed for functions that do not have any return value when the function body finishes then the function automatically returns. So, here is the next function that we had identified namely read starting point. So, again it has no parameter and has no return value it will read the starting point and store the starting point in the variables or x or y which are declared to be global variables. So, again it asks the user to enter the starting point and reads two integers into or x and for y which are global variables and again stores the return value of scan s into local variable r. So, if the value of r is not equal to 2 or if the starting position is not a valid starting position then we want to print an error message and exit from the program. What we mean by start by a valid starting position well the starting position must be on the boundary of the maze. So, first of all what we are going to check is that, or x and for y have valid values that is for x must be at least one and or for x must be no more than size x and similarly for y must be at least one and for y must be no more than size y. And then we are checking that the starting point that the user has specified at that point in the maze there is an open space because if at this place there is no open space then this cannot be a starting point and then this last check ensures that the starting point is indeed on the boundary of the maze. So, a point is on the boundary of the maze if either x the the value of x is one or size x or the value of y is one or size y. So, if the value of x is one that it is on this border of the maze somewhere if the value of x is size x then the starting point is somewhere on the side of the maze if the value of y is one then the position is somewhere on this line and is the value of y is size y then the starting position is on on this edge. But if it is on neither of these four edges then the starting point specified is somewhere inside the maze and that is obviously not permitted. So, therefore if project is not equal to size x and project is not equal to 1 and positive is not equal to size y and positive is not equal to 1 then the starting point that the user has specified is again invalid. So, in that case also we print the message that it is an invalid starting point and terminate the program by calling the exit function. So, we print that it is an invalid starting point and then we terminate the function by calling exit. So, now if we reach this point in the program that means that the starting point entered by the user was a valid starting point and now we need to initialize the initial direction. Now, how do we initialize the direction to begin with well that is again simple if the starting position is somewhere here then the initial direction must be south similarly if the starting position is somewhere here then initial position initial direction must be west if it is here then it must be north and if it is here then it must be west. So, if positive is one that means the starting point is like this somewhere on the left edge of the maze then the starting direction is east this way. If positive is equal to size x then it is a situation like this and the starting direction is west this way. Similarly, if positive is one then it is a situation like this and therefore, this direction is south otherwise it must be the case that the starting point is on the bottom edge of the maze because if it is on neither of the four edges you would have not accepted that starting point at all. So, in this last case the starting point the starting direction would be north. So, after having computed the starting direction in this way the function simply returns all the initializations it needed to do have been done. Let us now look at the next function which is turn left and this is quite simple depending on the current direction just the direction changes the position within the maze does not really change. So, if right now we are facing north then on a left turn will start facing west. So, if the direction is north the direction becomes west similarly if the direction is west if we take a left turn we start facing south and if we were initially facing south then on taking a left turn we start facing east and otherwise if the direction is neither north west or south then it must be the case that the direction is east. So, on a left turn the direction becomes north. The turn right function is exactly similar except that from north we go to east and so on so forth. So, the next function is to determine whether we are in the current position and in the current direction facing evolve. So, this function is supposed to return true if we are facing evolve and false otherwise. So, again there are no parameter because all the information that we need is available in global variables, but there is a return value which is true or false and in C as you know there is no Boolean type. So, we use the integer types to represent Boolean. So, we have declared the return type as int. Now, how do we determine whether we are facing evolve or not? Let us say we are facing in the north direction that is the current direction is not then if this is the current position then if we go one step north the current position then the new position will become x comma y minus 1 because x will remain the same and y will get decremented by 1. Now, if whether we are facing evolve or not depends on whether the maze at this new position had we moved one step north from the current position this new position whether it contains a wall or not. So, if maze, post x, post y minus 1 is equal to star that means we are facing evolve otherwise we are not facing evolve. So, note that what we are returning is the value of this entire expression and the value of this entire expression is true if the maze element at post x, post y minus 1 is star and it falls if the maze element at this position is a blank. So, that is precisely what we are supposed to return and so therefore, this is the current this is the correct return value. Similarly, if the direction that we are facing is west then if we move one step west from the current position then the new position would become x minus 1 comma y and so what we return is whether maze post x minus 1 post y is equal to star or not. Similarly, if the direction is south then moving one step in the south direction would lead us to x comma y plus 1 and that is what we return here whether that new position contains a wall or not and similarly as the direction is east this should be east. So, we are facing east by moving one step we would have east x plus 1 comma y and so in this case we return the result of checking whether at that new position the maze contains a wall or not. Okay the next function is to determine whether the current position is outside the maze or not. So, again there are no parameters because all the information required is available in global variable and the return value is of type int because we are going to return two or false. So, how do we determine whether we are outside the maze or not all we have to check is whether we are somewhere on this path that we have created around the maze or not and so if post x is 0 note that the actual maze runs from y equal to 1 to y equal to size y and in the x direction from x equal to 1 to x equal to size x. So, if the current value of x is 0 that means, we are somewhere on this path or if the current position of x is size x plus 1 then we are somewhere on this path and if the current value of y is 0 that means we are somewhere on this path and if the value of y is size y plus 1 then we are somewhere on this path. So, in all these cases we are supposed to return true and that is what precisely this expression consisting of or of these multiple conditions we do. So, if cos x equal to 0, then this entire expression whose value we are returning will evaluate to true and similarly if cos x is equal to size x plus 1, then this expression evaluates to true and therefore, the entire expression also values to true and so on. And in all other cases the expression representing the return value evaluates to false and so therefore, we end up returning the right value. So, that is almost the end of the program just need to write a couple of simple functions. So, the next function is to step forward from the current position in the current direction. So, all we need to do is to change the value of the current or this other line of need to take a couple of different. So, that is the first square x will get incremented by 1, remember that our coordinate system is like this x is increasing this way and y is increasing southwards. The next function print position is equally simple, all it does is that it prints recurrent position, power x, power y in this notation. So, if the current position happens to be 3 and 2 that is power x equal to 3 and power y equal to 2, then this function will print something like 3 comma 2 where they blank after the bracket. So, that if we successfully print multiple positions within the maze they are separated by blank spaces. So, finally, we are in a position to write the main program which we just call all these functions that we have written. So, in the main function we first read the maze, note that the main function does not really require any local variables at all. We first read the maze, then we read the starting point, then we print the current position and then essentially this loop captures the algorithm for this problem that we have already seen. While we are not outside the maze turn right and then while facing evolve turn left and then step forward and then since we have step forward we have moved to a new position. So, we print that position as well. So, at the end of this loop the entire path has been printed and then we finally print a new line character. So, that the cursor comes to the next line and that is all that the main program needs to do. You can see that once the functions have been written the main program is really simple and somebody on reading this immediately understands what are algorithm for solving this particular problem is. That is the end of today's lecture. In the next lecture we will start by discussing another important tool in programming and that is the notion of pointers.