 In today's lecture we will look at remember very important tool in programming in that the information of pointers. So, the interest are let me try to motivate some use for pointers. As we have seen when we were discussing functions the communication between the collar function and the cauliflower function that is the function that has been called is in two ways. By communication we mean the flow of information or the transfer of information one is the collar can pass some arguments to the cauliflower function. This communication is from the collar to the collar and in the reverse direction the cauliflower function can return a value to the collar function and this communication is from the collar to the collar. But note that the return value as you have seen can be a single value it cannot be more than one value. Now, suppose we want a function to return more than one value then how do we achieve that. So, here is a example problem in which you might want to actually do that. Suppose you want to write a function to convert from polar coordinates to rectangular coordinates maybe the program that we are writing is a graphics program and deals with geometric objects and so on. So, we want to write a function which converts from polar coordinates that is R theta to rectangular coordinates that is x, y. Now, how do we write such a function the parameters of the functions are clear they would be the values of R and theta and the return value should comprise of x and y. But that is not possible because we cannot return two values from a function. One possibility as we know is that we could make the variables x and y global variables and then the function which converts from polar to rectangular coordinates could modify these global variables instead of returning any value. But in general that is not a good idea. We should avoid using global variables as far as possible because when two functions share global variables that is they both access the same set of global variables then this increases what is known as binding between the two functions. And what binding means is that the two functions cannot really be understood in isolation that is for understanding one of these functions you have to also understand what the other function is doing. So, that makes it more difficult for somebody to understand the program by reading it because he cannot just focus on one function anytime and consider it independently of the rest of the function. So, we should use global variables when it is really required. But in most cases we should avoid using global variables and variables which really are of use to only one function should be made local to that particular function. So, the question remains how do we solve this problem. So, we will solve this problem using pointer. I will show you the solution towards the end of the lecture. But having motivated the use of pointer let us now look at what pointers are and what we can do with them. So, suppose we did not use pointers and wrote our polar to rectangular function by adding two extra arguments x and y to it and the polar to rectangular function modified these x and y values. As you know what would happen is that when polar to rectangular modifies this variables x and y what it is really modifying are the parameter of the function polar to rectangular and this change would not have effect on these variables x and y of the main function. So, that is something that we can do only using pointer. If we wrote the function like this as we have already seen this does not work because the x and y in the calling function they do not really get modified. So, let us not try to understand what pointers are but to understand that let us go back to our basics and first talk about what a variable is. So, recall that a variable represents a cell or a location in the memory of the computer that holds a certain value at any given point in time. Recall that the memory consists of a large number of memory locations or memory cells and each of these cells has a distinct address associated with it that is how at a lower level we identify or refer to individual cells in the memory. So, a pointer to a variable is nothing but the address of the memory location which is associated with that particular variable. So, so far we have been using variables that is accessing their values and altering or modifying their values using only their names that is use the name of a variable to refer to it or to get its value or to modify its value and so on. But using pointers what we can also do is to instead of using the name of a variable to access it we could use its address to actually access the same variable. So, that is what pointers allow us to do. It is actually not important to worry about the actual addresses of variables because what the actual address of a variable is depends on what address the compiler really assigns to it. But the actual addresses are not important what is more important to realize is that a particular value is the address of a particular variable. So, that is better understood using a pictorial representation. So, what we are going to do is to represent variables as boxes. So, each variable is a box in which some value can be stored or placed the name of the variable we can think of as a label attached to that box. The value of the variable is the value stored in the box or written in the box and finally, we can represent or think about a pointer to the variable as an arrow pointing to the box. So, for example, here is a variable x with value 5. So, we have represented this variable as a box. The value 5 is written inside it and x is a label for this box and a pointer to this box is nothing but we should think of it as an arrow pointing towards the box. We will see that it is very helpful to use this notation to understand what a particular program is doing because we do not need to actually deal with actual numerical values of the addresses. So, all that all the information that we need to know about a particular address or a pointer is that is the variable that it is pointing to. So, representing it as an arrow pointing towards the box representing a particular variable is a very powerful notation and we will see that we can using this notation very easily visualize what is going on in a program that is using pointers. Now, the next important thing to understand is that pointers are also values and just like values of types like integers and characters and floating points and so on and so forth. They can also be stored in variables and they can be passed as arguments to functions and so on and so forth. But the type of a pointer is not in tors float or car or something like this. There is a notation for specifying the types of pointers and the type of a pointer depends on the type of the variables that it can point to. A particular pointer variable can hold a pointer to only variables of a certain fixed type. For example, if we say that we have a variable which will hold pointers to integers then this variable can only hold pointers to a variable of the type int. At different points in time in the execution of the program it may hold pointers to different integer variables, but it will always hold pointer to some variable which is of type int. So, if a variable is going to point to if a pointer is going to point to a variable of type P and therefore also the type of a variable that is going to store such a pointer then the type of that pointer and the type of the variable which will store such a pointer is t star. This is just a notation that see uses. So, t star should be read as pointer to t and t itself could be any of the types that we have seen it could be an int it could be a car it could be a float or a double or whatever else. As an example suppose we want to declare a variable that will hold a pointer to some variable of type int then this variable would be declared as says here P is the name of the pointer variable and int star is the type of this variable. So, what this declaration says is that P is a variable which means that P is itself a box somewhere with the label P and what this box will contain is not an integer but a pointer or an arrow to some other box which contains an integer which might be x at a certain point in time at a certain later point in time we may modify the value of this variable and make it point to another variable may be y which itself has the value 5 and so on so forth. So, there are two operators associated with pointer the first is the operator ampersand and the other is the operator star both of which we will look at one by one. So, the operator ampersand is a new operator it should not be confused with another ampersand operator that exists in C this is a unary operator which means that it has just one operand. Now, this operator can be applied to a variable it cannot be applied to an expression which cannot appear on the left hand side of an assignment. So, suppose x is a variable than the expression ampersand x refers to the address of or the pointer to the variable x. So, using this particular operator we can obtain the pointer to or the address of any variable that we care to and this itself is a value and it can be stored in a variable of an appropriate type and so on so forth. Note that this kind of an expression ampersand x cannot appear on the left hand side of an assignment because we cannot modify the address of a variable the address of a variable is fixed and it is assigned by the compiler we cannot really change that and therefore, this expression can appear on the right hand side of an assignment because we can store it somewhere but we cannot place it on the left hand side of an assignment because we cannot modify this value. So, for example, to illustrate the pictorial representation that we have been talking about consider this simple piece of code. So, we have two variable declarations here the variable x is of type integer and has the value 5 and the variable p has the type in star which means that it is it will hold a pointer to an integer variable and it is initialized to the value ampersand x. So, what this means really is that x has the value 5 x is a box is the value 5 in it and p is another box labeled p and what it contains is a pointer to or an arrow pointing towards the variable x. The other operator that is associated with pointer is the unary star operator and again please do not confuse it with the multiplication operator of c the multiplication operator is a binary operator whereas, this is a unary operator and this is not an arithmetic operator this does not really do an arithmetic. So, again let us assume that p is a pointer variable that currently points to the variable x. So, the situation is something like this. The type of p is some p star and the type of x is the type t could be int or float or anything else. Now, the expression star p refers to not the value of the variable p but the value of the variable to which p points. So, the expression p itself would be a pointer to the variable x but the expression star p is the same as the value of the variable x of to which the point to which the variable p points. So, if x happen to have the value 5 and p happen to point x then star p would have the value 5 also. So, this can be used on the right hand side of an expression to obtain the value of the variable to which a particular pointer is pointing. It could also be used on the left hand side of an assignment to modify the value of the variable to which the pointer is pointing. So, for example, if we have the assignment star p assigned 7 then this does not change the value of the variable p itself what it changes is the value of the variable to which p is pointing which in this case is x and that value becomes 7. So, you can see in this case what is happening is that by using star p we are actually referring to the variable x itself but instead of referring to the variable x by its name we are referring to the variable x by its address which is the value of the expression which is the value of the expression p. So, let us make this more concrete with the help of a detailed example. So, here is a piece of code and we will trace through this piece of code and see exactly what is happening here. So, we have three variable declarations i j and p and these are the three boxes for these three variables i j and p i and j are of type n. So, these boxes will contain some integer values and p is of type n star which means that p will hold a pointer to some integer variable. We have only two integer variables in this particular example. So, p can hold a pointer to either i or 2 j note that as we will seen this example indeed that at different points in time of the execution of this program the variable p may hold pointers to different variables. So, let us just step through this code and see what happens. So, this is the statement that we need to execute next i is i and p when that is executed you all know what is going to happen. The variable i will get the value 3 and control goes to the next statement j is i and 4 and when j sign 4 is executed the value of j becomes 4. So, till now everything is familiar. Now, the next statement is p assigned m percent j m percent i. So, what that is going to do is the following m percent i represents a pointer to i or the address of i. So, this value is going to be stored in the variable p. So, what that is going to do is establish an arrow from p to i and that is precisely what it does in day 2. And the next statement is j assigned star p. So, what should happen here what is the so the left hand side of the assignment is j. So, clearly the value of j is going to change but what is going to the new value the new value is the value of the expression star p the value of star p as we just saw is the value of the variable to which the pointer variable p points. Now, p is pointing to the variable i and so the value of the expression star p will be 3. So, what is going to happen is that j should become 3 when we execute this particular assignment statement as indeed that is precisely what happens. Now, the next statement again modifies the value of p to the address of j. What that means is that now p will stop pointing to the variable i this pointer will be removed and instead the value of p itself will change and will start pointing to the variable j. So, that is what is the effect of this statement. The next statement of course, is simple is assigned 5. So, that just changes the value of the variable 5. And finally, here we have an assignment in which the expression star p appears on the left side of an expression of an assignment. So, in this case what is going to change? What is going to change is the value of the variable to which p points. Now, at this point in time p is pointing to j. Note that the fact that p earlier pointed to i is no longer relevant that fact is forgotten. p is now pointing to j and therefore, when star p is assigned something the value of the variable j will change and what will the value of the variable j will become? This will be the value of the expression on the right hand side of the assignment which is i plus 3 which of course, is 8. So, this value should become 8 as indeed that is what happens. So, having understood the basic concepts of pointers we can now solve the problem of conversion from polar to rectangular coordinates. And this example will also illustrate how we can pass pointers as arguments to functions. And so, recall that the basic problem was that we wanted the function polar to rectangular to modify the variables x and y of the function mean. Now, it cannot access this variables x and y of mean by name because the scope of these variables is only within the body of the function mean. But it can access them if it has the addresses of these variables. And how does it obtain the addresses of these variables? Well, if the main function itself passes them as arguments to the function polar to rectangular. When the function polar to rectangular will have access to the addresses of these variables. And when it uses these addresses to access these variables that process is called d referencing then it will be able to modify the variables x and y of mean itself. So, let us see what the solution will look like. The function polar to rectangular is similar to what we have written with some important differences. Now, the type of the variables x and y which we are calling p x and p y to stand for pointer to x and pointer to y are double star instead of double the value the parameter r and theta remain of the type double. So, and when we compute the value of x and y r star cos theta is the x component and r star sin theta is the y component instead of running to x which would be illegal because the variable x is not in scope we assigned to star p x and to star p y respectively. And when we call this function from main the variable declarations in main are the same as before. So, we pass these parameters r and theta we pass these arguments r and theta as before. Now, instead of passing the value of x and y what we are passing are addresses of x and y note that m percent x denotes the address of x or a pointer to x and similarly m percent y denotes the pointer to y. So, that is what we are passing. So, let us try to understand in terms of pictures comprising of boxes and arrows what exactly is going on in this particular example. So, we have these when when when when main starts executing the space for these variables get created as we saw in the last lecture. So, four variables get created r theta x and y and somewhere here r and theta are initialized let us assume that the value of r is 1 just for example, and the value of theta is 5 by 2. Now, when this function is called polar to rectangular r theta m percent x m percent y what exactly happens as you know space will be created for the local variables and the parameters of the function which is being called the function being called is polar to rectangular which has four parameters, but no local variables. So, the space for these four parameters will be created r theta note that these r and this theta have nothing to do with the r and theta of main and then we have p x and p y. Now, these variables will be initialized by the values of these expressions which are being passed as arguments. So, the the parameter r gets the value of the expression r in main which was 1. So, this gets initialized to 1 similarly theta gets initialized to the value of theta in main which is 5 by 2. So, this gets initialized to 5 by 2 what is p x get initialized to p x will get initialized to the value of this expression which is nothing, but a pointer to x. So, p x gets initialized to an arrow pointing towards the variable x of main and similarly the variable p y the parameter p y or the function polar to rectangular gets initialized to a pointer pointing towards the variable y of main. So, this is what the picture looks like when the function polar to rectangular starts executing. Now, this assignment takes place. So, right hand side is r into cos theta r is 1 theta is 5 by 2 and cos 5 by 2 is 0. So, 1 into 0 is 0. So, this entire thing evaluates to 0 and that gets assigned to star p x. Now, star p x refers to the variable to which p x points which is x. So, the value 0 is actually written here and similarly next assignment computes the value of r sin theta. r sin theta will be 1 because sin 5 by 2 is 1 and that value gets written to the variable to which the parameter p y points and that is the variable y. So, the value 1 gets written over here and then the function polar to rectangular returns. When the function polar to rectangular returns, these variables get destroyed. The control goes back to main but when the control goes back to main note that the variables x and y have been modified to contain the rectangular equivalent of the polar coordinates r comma theta. So, before we end this lecture today, here is an exercise for you to utilize the concepts that we have seen so far. So, should write a program that given a month name and an year, the month name could be January, February and so on and an year 1995, 2005 whatever should print the calendar for that month and you should use the techniques that we have learnt so far that is divide the entire problem into sub problems that is identify the functions, possibly identify global variables and then use either the top down or the bottom up approach and then start implementing the functions one by one and finally put them together as the main program to implement the entire solution.