 The title of this course is in translation to computing and in this course we are going to study how to use computers effectively for solving a real life problem that will come across in a professional career. As you know in today's work a computer is an invaluable tool to every engineer and scientist for solving problems related to his or her discipline. For example, if you are a civil engineer you need a computer to compute the stresses on the various structures of the building or if you are going to be an aerospace engineer then you might need to use a computer to compute the airflow around an earthouse and so it is important for all of us to understand how to use computers effectively to solve our problems and not just as users of computers we need to be able to sell the computers how to solve our problems. So in this course we are going to basically see how to use computers to effectively solve engineering problems and as a first step we are going to try and understand what a computer is and at a very high level of what it is. So what is a computer as the word suggests it is something that computes. Well in that case how is it different from a simpler device that you are all familiar with namely a calculator a calculator calculates. So are the words calculating compute any difference? Well let us try and consult a dictionary to find out. Here is what calculate mean to determine something by mathematical process and here is what to compute mean to determine especially by mathematical mean. So as you can see the meanings of the two words are quite similar and therefore one would expect a calculator to be similar to a computer. So it is actually not the case a computer as we are going to see very soon is much more powerful and we can use it in much more flexible and interesting ways than we can use a calculator. So allow us see what we can do using a calculator there is something that is similar to all of you. Let me show you a calculator. So here is what a standard calculator looks like. As you can see it has buttons for various primitive arithmetic operation and we can use this operation to do some calculations with numbers for example 56 into 23 is 1288. However what we cannot use this calculator to do is to select how to combine these operations in a certain fashion so that a certain computation can be achieved. For example how do I compute let us say the factorial of numbers using this calculator. You might say all that is very easy if I have to calculate the factorial of 5 there is what I am going to do 5 times 4 times 3 times 2 and that 1.20 is the factorial of 5 and that is correct but you cannot teach this calculator how to compute the factorial of any given number. For any specific given number you can use this calculator to find the factorial by combining these operations in a certain way that you know but you cannot teach this calculator how to combine these operations in some way so that it can compute the factorial of any number automatically. Well you might say if I want to do that I can use a scientific calculator which has a primitive operation for factorial but even with a scientific calculator the set of operations that you have is fixed and you still cannot select how to combine these operations automatically in a certain sequence so as to achieve a certain computation. For example your scientific calculator might have a button for factorial but can you for example teach it to compute let us say the area of the intersection of two given circles when you find and that is the important distance between the calculator and the computer really computers you can actually select how to how to combine the various primitive operations that are available in a certain fashion so as to achieve the desired computation of the desired problem. Okay so let us look at some terminology now which relates to the concepts that we have been talking about. This is something the computer about how to a second task is what is called a programming and should you comment on this one before. A program is nothing but the set of instructions that you are given to the computer to query out the certain task and the third term is programmability which is the ability of the computer to accept a set of instructions from you and to say fully carry them out and this programmability is what primarily distinguishes a computer formic calculator because a computer is programmable that is we can give it a set of instructions to solve the problem of our choice whereas we cannot to run the calculator or we cannot instruct it how to carry out a certain task. Of course there are other important differences between computer and calculator which are also significant for example a calculator can only deal with numbers whereas a computer can deal with data in variety of forms as some of you might be aware for example it can it can handle text, it can handle images, it can handle sounds and it can take its input from a variety of interesting input devices and so on but the fundamental difference again is that a computer is programmable while a calculator is not. Addiffer the program is the sequence of instructions that is applied to the computer in order to solve our problem at hand there is a related term called an algorithm which is similar to the program but different in certain details. So an algorithm is also a sequence of sets to solve the problem but it is usually written in a natural language such as English and written precisely enough whereas to be unambiglously understood by a human a program on the other hand is essentially an algorithm translated to what is known as a programming language that a computer can understand and execute. So that's a fundamental difference between only a algorithm and a program you might think of an algorithm as a solution to a problem whereas a program is the translation of that solution from English to a programming language that a computer can understand. In this course we are going to talk both about how to develop algorithm for solving some simple problems which you will find useful as building blocks for solving more complex problems and at the same time we are also going to see how to express visual algorithms in a programming language and actually execute these programs on a computer. So let's not take an example. Let us say we stick to our old example of computing factorial and we want to write an algorithm to compute the factorial of a given number n. Note that here n could be any number and we don't know a prime what this number n is. So our sequence steps namely our algorithm to find the factorial of n should be such that it can handle any given n and not just a certificate. So what do we go about finding such an algorithm? Well we all know how to compute factorial. So as you know the factorial of n is nothing but n times n minus 1 times n minus 2 times n1. But how do I express this as an algorithm? Note that multiplication is fundamentally a binary operation and we can really only multiply two numbers at a time. So how do we go about converting this knowledge of our definition of a factorial into an algorithm for a factorial? Well let us just think a little as you can imagine what we can do if you want to multiply numbers two at a time we can start with one let's call it for the time being as a result and our n is whatever it is and in each step let us say we multiply result by the value of n that is the first step we multiply result by the value of n and that is you was n. So let us take an example let us say n happens to be 5 so we start with result as 1. In the first step we multiply the value of result by the value of n which gives us 5 and that's the new value of result and in the next step we have to multiply this result by 4 not 5. So therefore we decrease the value of n by 1 and make it 4 and in the next step we do the same thing multiply result by the new value of n and that gives us 20 decrease the value of n by 3 and we keep doing this so in the next step 20 becomes 60 and becomes 2 and in the next step 160 becomes 120 and and becomes 1 and how long do we keep doing this as long as and is greater than 1. So once you have done this we have essentially arrived at an algorithm to compute the factorial all we need to do is to now express our heart more precisely. So here is the expression of our heart in the form of an algorithm so here is the algorithm to compute the factorial of n. The first step is to read the value of n and in the second step as we did earlier while you are struggling set the result initially to 1 and as long as n is greater than 1 keep doing these two steps and these two steps as we have seen are multiplying the value of result by the value of n and decreasing the value of n by 1. So set the new value of result to the old value of result times the value of n and the second step is set the new value of n to old value of n minus 1 and keep doing this as you can see here still as long as n is greater than 1 and once you have the value of result contains the answer to our problem namely the value of n factorial and we can output the value of result. In this algorithm I know that we are not really bothered too much about red wire it is the value of n from or red wire trained the value of the result or how do I trained the value of the result that is not something that was in the straight law it is the step 2 3 3.1 and 3.2 which are really important at this stage. Okay and let us note some more things about this algorithm note that our instructions for computing the factorial of n is not just a straight line sequence of instructions to be executed by the computer 1 by 1 but there are things which have to be repeatedly done the steps 3.1 and 3.2 have to be repeatedly performed as long as a certain condition holds this is called a loop in the technical jargon the second thing that we should note is that we have to value we have to remember the result of intermediate computations and the intermediate computations as you can see in this particular simple example are two namely the value of result and the value of n. So these things these values that we have to remember these are called as variable so in this example there are two variables in this algorithm result and n and show the motion of variables is similar to you from your high school algebra where you have equations like x plus y is equal to x square plus y square something like this but at mathematical motion of variables is very different from the programming motion of variables in mathematics variables such as x and y denote unknown but fixed values whereas in an algorithm variables denote values that may change over time okay. So as you can see the values of result and n change over time as we go through this algorithm and execute itself by step and that's what the programming motion of variable is okay. So let's now see this algorithm in action so here is the same algorithm and let's see step by step how it's going to execute and compute the desired result here's the first step read the value of n let's take an example the same example as matrices as before and let's assume that the value of n that is given to us is 5. So this blue arrow indicates where in the execution we are currently right so after having executed line number one we now have to execute line number two and the result of executing the line number one was that the value of n has become 5 okay. So the second step is set the value of result to 1 and what do you think this will do as you can imagine this will do nothing but set the value of result to 1 here it is. Now here is something the sequence of steps you need to be repeated as long as a condition holds so while n is greater than 1 do these sequence of steps well as so this this particular line in the algorithm is essentially just going to check whether or not n is greater than 1. The current value of n is higher which is certainly is greater than 1 and therefore the answer to this condition or the result of this condition is true and therefore we are supposed to do the step 3.1 and 3.2 and because the condition evaluated to prove we have come to the step 3.1 which says set the new value of result to the old value result thanks to value of n and so the new value of result will be result times n which is 5 times 1 which is 5 and that caught this line in the algorithm does. So the result becomes 5. Note that in this step n has not changed. In the next step we are going to set the value new value of n to old value of n minus 1 which is 5 minus 1 namely 4. So we do that and note that once we have finished everything 3.1 and 3.2 we must come back to line number 3 and check this condition again why because remember that the step 3.1 and 3.2 have to be repeated as long as this condition holds and this condition will not as you can imagine continue to hold forever because in every step we are decreasing the value of n by 1 and therefore after some time certainly after the finite number of steps the value of n will become less than equal to 1 at which time we will stop repeating the steps 3.1 and 3.2 but at this point in time the value of n is still greater than 1 so we repeat the same step becomes here the value of result now becomes 20 5 times 4 and now the value of n becomes 3 so you go back and is still more than 1 and therefore we repeat the steps again so result now becomes 60 and n now becomes 2 which is still greater than 1 so we do this once more result now becomes 20 the value of n becomes 1 now when we test whether n is greater than 1 or not we conclude that n is not greater than 1 because we need n is equal to 1 and therefore this condition is no longer identified now and therefore the step 3.1 and 3.2 will not be executed now will later become 2 step 4 which is to pin the value of the result and once you do that the output is the value of the result which of course is 120 and which of course as you know is factorial of n. And we could have all the same problem in other ways as well for example instead of multiplying 1 by n and then by n minus 1 and then by n minus 2 we could have started this process from the reverse direction that is multiply 1 by 2 and then by 3 and then by 4 and so on you could express that algorithm in a fashion similar to what we have done here and I will leave that as an exercise view and at the end of the lecture there is one more exercise for you to try yourself I wanted to write in the algorithm to compute the quotient and the remainder when if you want integer x which is more than or equal to 0 is divided by another given is a y which is known to be greater than 0. So for example if let the 15 is divided by 7 then the quotient should be 2 and the remainder should be 1 but as you that only addition and subtraction are the arithmetic operations available to you. So please write a algorithm for doing that just to increase the concepts that we have learned today. So before we end this lecture today let me summarize what we have seen so far we have seen the notions of programming a program and programmability and this notion of programming and programmability is essentially as we have seen what we have to computer it's power because we can write programs to solve our problems and tell the computer to go z programs to find the results that we need and before actually writing programs in programming languages that computers can understand we have seen what the notion of an algorithm is which is independent of any programming language and we saw simply we got them to solve the simple problem namely to find the factorial of given number n and we saw roughly how the computer would go about executing the algorithm. you you you you