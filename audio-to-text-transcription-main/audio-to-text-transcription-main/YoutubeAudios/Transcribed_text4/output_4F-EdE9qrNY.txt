 So, before we start some new topics today, let us look again at the problem that I had before. use the three left side for phynex which as you know is x minus x cube by p factorial plus x bar 5 by p factorial etcetera. So, how do we solve this problem? Well, let us say we will just keep computing terms of the three one by one and keep adding them to a sum which will be the final value of phynex and this is an infinite series we will have to solve the submission when the absolute difference of two consecutive terms becomes less than a silent. So, before looking at the program let us try to work out an informal algorithm for doing this. So, let us say we will use these variables phynex will carry the sum of the terms which will finally of course give the value of the phynex and x x x term is the most recently computed term the last computed term in this series that was computed and let us say let us use the variable phynex for the term prior to the most recent term. So, the difference between the two terms is term minus curve term and absolute value of phynex addition. So, you will have to keep computing still the value of difference becomes less than a silent. Now, one thing that you should note in this series is that when I am computing let us say x to the power k over k factorial where k is some odd number then I do not have to compute x to power k and k factorial all over again because if I do that I will have to multiply x k times and then also multiply k by k minus 1 k minus 2 etcetera up to 1 which is the number of multiplication. If so, that we can use the fact that we already know what the previous term was the previous term that we had computed was x to power k minus 2 divided by k minus 2 factorial. So, if you just multiply this by x twice and divided by k minus 1 and k that gives us the value for the next term. So, let us now try to write an informal algorithm using this idea. So, the main loop will look something like this while difference is less than a silent. So, the term that we computed in the previous iteration will become the previous term for the iteration. So, previous term will become equal to the current value of term and new value of term will have to compute. It is assumed that the previous value of term used a value k that is the previous the term that we had computed earlier was x for k over k factorial. Then the new value of term would be minus term into x into x divided by k plus 1 times k plus 2. This minus comes because if you observe the term in the 3 I am alternating sign plus and minus and after this the value of k will become k plus 2, it will get incremented by k and to the value of sin x will add the value of term and what else do we need to do? Well, we need to update the value of difference. So, difference will now be the new value of the difference which is term minus the previous term and that is it and the end of this the value of sin x is the desired answer. So, let us now look at the C program to do all this. Here then is the C program to compute sin x. Note that we have a big comment upfront which says what the program does and how it does it. You can remember I told you earlier in the writing comments and programs is very important because they help us understand programs even the person who has himself written the program may need to understand some difficult parts of it and comment something do that. Okay, before we look at the other things in the program, let us look at the mean loop of the program. There is the mean loop and it is quite the same as what we just discussed. Well, while the difference is greater than the value of a silent that is as long as the desired accuracy is not obtained, the previous term is assigned to term because we most recent computed term will not become previous term and the new term will be computed and the new term is computed from the last computed term as minus term sin x square divided by k plus 1 sin k plus 2. Note that the fresh and k plus 1 sin k plus 2 has to be enclosed in the next set of bracket that is because otherwise it will become equivalent to term into x square divided by k plus 1, but multiplied by k plus 2 instead of multiplication by instead of division by k plus 2. That is because really the division and the multiplication operator have the same what is known as precedence which we will talk about in detail later on and essentially they are carried out in the left to right order, but will not worry about this. Let us for the ending let us just put these extra places here. So, the value of i next gets updated by the value of this new term just get added to the old value k becomes k plus 2. The new distance is term minus previous term, but remember that we want the absolute value of difference. So, how do we compute that that is that is straight forward is the value of distance turns out to be less than 0 then we simply change its size. Okay, let us now look at the initialization fact we need to perform to start off this loop. Now, let us have you that we have already read the value of x and epsilon above these statements in the program and show them to you in a minute. So, here are the initialization. So, we know the first term is x. So, therefore, we can assign the term to be x and the initial value of i next is also x because term is already included in that. The previous term the one before this is of course 0. So, therefore, the value of previous term is initialized to 0 and the value of difference is also x because term is x and previous term is 0. So, difference is term minus previous term which is x. But of course, since x can be negative so this difference can be negative as well and therefore, if distance is less than 0, we change the sign of the distance and because the current value of term is x to the power 1 divided by 1 factorial therefore, x should be initialized to 1. Let us now see what else we need to do. This is the standard set of statements for reading some input. So, we want to read the value of x and the value of the silent. So, from enter value for x, read the value of x using k and s percent f. Note that since x is going to be a floating point number of type load. Therefore, we have used percent f here and similarly, you present f to read the value of epsilon. Here are the declarations of various variables. x is the input value. Note that in the program I have given a comment for explaining every variable used in the program. This helps in understandability of the program. So, x is the value that is going to be input to us. The variable sin x will hold the value of sin of x. So, this comment says the sin x will be equal to sin of x. We cannot use sin of x with brackets. It self has a variable name because remember that variable names cannot contain brackets characters. So, just to verify that our answer is correct, we are also going to use the math library function sin x which is built into the c math library. Just to verify that our answer is correct, we will also compute the value using the sin x function from the math library. So, the variable lib sin x is going to contain the value of sin x of sin using the math library sin function. A epsilon of course, is a desired accuracy. The term and the previous term, we already know what they are. Term is the current term in the Taylor series, previous term is the previous term in the series. Rift is the difference between term and previous term actually the absolute value of that and k is the current power of x. So, always term is x for k divided by k factorial. Now, sin x is also going to use the math function name designs from the math library. We also have to include, we have another include statement saying hash includes math.h. This statement says that we are going to use a function from the math library name design function. Remember that the hash include actually i.o.s is there in almost every program that we write because in almost every program that we write, we need to use the standard input and output function. So, after the loop run and terminate, finally, we can print the value of sin x for the computed value of sin of whatever. We want to print the x value of x here, we just put percent f and that we get to place where x value of f and x value is another real number. So, therefore, another percent f and the corresponding value is sin of x and here we are computing the same value using the math library function sign. So, the lip sign x sign of x. So, this will directly give us the value of sin of x from the math library and we are also printing this value just to compare that the value that we have computed is correct. Okay, so let us compile this program and see where it was correctly. One new thing in this command line for compiling the program that you should notice is this minus LM that we have used over here. This minus LM is required because you have to tell the compiler that we are using a function from the math library and therefore, the math library should be linked along with our program by the compiler. So, it is not necessary for the standard C library function such as print f, k and f etcetera that we have been using because the C compiler always links the standard C library along with every program that it compiles but that is not true for the math library and many other specialized libraries that we might need to use in our program. So, in the case of math library for example, we have to in the program itself, we have the include statement that we just saw. In addition, we have to use this minus LM flat to tell the compiler that the math library should also be linked with the program. Okay, the program has been compiled. Let us now try to run it. So, let us try to give some familiar values for X. You know that X i is 0. So, let us try to give the value of i as the value of X. Actually, you want to have an accuracy up to 5 decimal points. We can see the answer is almost 0 and in fact, the math library function has given precisely the same value. Let us try some other value. Let us say 5 by 2, 5 by 2 is 1. The value of 5 by 2 is approximately 1.57 and we get to 5 by 1 this time. Okay, so this program is working. Okay, let us not talk about another couple of types of values that are very useful in program. The first such values that we will talk about are characters. By character, what is meant is really all these alphabet, numerals and other facial symbols, colon, semicolon, full stop, less than, etcetera, that you see on the keyboard. One very important capability of a computer is to be is that it can deal with characters also apart from just numbers. And in particular, it can deal with strings which are with a string is nothing but a sequence of characters. We will not talk too much about handling of characters in this lecture. We will leave that to a later lecture. But we want to talk about and let us see about the representation of characters inside the computer. So, how as you know that every data, every piece of data inside the computer is represented as a sequence of bits which are nothing but zeros and one. So, the question is how would characters represented in Mandarin and the natural answer is that we simply assign some codes to different characters. Let us say integer code to the various characters. And when you own a storey character in memory, we just store the corresponding integer code. There are several standard coding which have been defined by various codeys and many such codeys are in use. Some of these codeys are called S-key, Unicode, U-T-F-A-T, etcetera, etcetera. The C programming language that you are using uses the S-C standard which essentially is a standard for defining impetus codes corresponding to all characters that you can see on the keyboard. So, in the S-key coding, the different characters are assigned codes from 0 to 127. So, that means the total of 128 characters can be represented. Only the Roman alphabet is supported. In some of the other coding schemes, for example, in Unicode and U-T-F-A, you can infect support characters from many different trips like Devnagry and many other trips. So, but we will be focusing on S-key for this code because that is what C uses. So, here are some examples of S-C codes. The codes for the characters A to Z are contiguous one after the other. The code for small A character, small A is 97. That for small Z is 122. B is 98, C is 99 and so on. The A to A to A to Z are also one after the other. A is 65, A is 66 and so on. A is 90. And similarly, the characters 0 to 9 have the S-C code 48 to 57. Note, carefully that we should always be careful in distinguishing between the characters 0 and the integer 0. The characters 0 would be represented by the S-C code for 0, which is 47, which is 48 and sorry. Whereas, the integer 0 would be stored internally just as the 0 in binary, which is all bit set to 0. So, therefore, the characters 0 and the integer 0 are very, very different. The C type correct R, which we have already visited in the last lecture, is usually used in programs to store characters that we might be reading from the input or we might be manipulating these characters and so on. And the reason for using this type, is remember that the cache type is an integer type for which exactly one byte is used for storage, which means that numbers from minus 128 to 127 can be represented. And since the S-C code has codes from 0 to 127, any character can be represented using the track type. But in principle, any integer type can be used to hold a character because, automatically remember that a character is internally stored as an integer, which is the S-C code for that particular character. And we can of course, use unsigned cache because the range for unsigned cache is going to be from 0 to 255. Another important type of values that we will often need to deal with in our program are what are known as Boolean value. And Boolean value is nothing but just two or all. We often need to remember just the truth or falsity of some condition in the program. We will shortly see an example of the program that uses this notion. These values which are just two or all, they are called Boolean value, after the famous mathematician called Boolean. There is no Boolean type in C and really to store Boolean values that is to store through or all, what we can do is to use any integer type, character, integer, long, short, any of the values. And in the integer representation for Boolean in C, the value 0 be known called whereas, any non-zero value which may be negative or positive denotes true. Okay. So, another example problem that we are going to call today is to find out whether a given integer n which is greater than 0 is prime or not. So, the primary testing problem has been actually a very fascinating problem for mathematicians for a long time and people have tried to come up with a physical algorithm for solving this problem and only recently as in fact, as recent as last year, this problem was solved in a very efficient fashion. Our those algorithms are fairly complicated when you will use very easy, very easy algorithm which should be familiar to all of you for solving this problem and that algorithm follows directly from the definition of primary. You know that the number is prime if and only if it is visible by no other number other than 1 and itself. So, if there is some other factor of n other than 1 and itself then n is not a prime. So, essentially the idea to find whether n is prime or not, what we need to do is to test whether n has any factor other than 1 and then or not. So, we need to test four factors from 2 to n minus 1. However, we do not need to test all these numbers to check whether there any of them is a factor of n or not because you know that if there is a factor of n let us say let us say p which is greater than square root of n then there must be another factor q which is less than square root of n. Why is that? If you take simply q to be n by p since p is a factor of n therefore q must be an integer that is p only divided by n and since p is greater than square root of n and p times q is n therefore q must be less than square root of n. What does that tell us? That tells us that we need to do for a divisor or a factor of n only from 2 up to square root of n. If we cannot find a factor of n from 2 to square root of n that means there cannot be any factor greater than square root of n either apart from n of course it tells. So, how do we use this to use these factors to fashion the algorithm? So, central idea is very simple let us use a variable called t which is the potential factor that will be test whether it is a factor of n or not. What do we test whether p is a factor of n or not? We just have to check the remainder of the division of n by p and test whether the remainder is 0 or not. So, if p is a factor then the remainder would be 0 and you see there is an operator called the percent operator which does precisely that. So, n percent p will give us exactly the value of the remainder when n is divided by p. So, if n percent p is equal to 0 this implies that p is a factor of n. So, what we need to do is to have a little bit of flow run it looks from 2 to square root of n and so, p will vary from 2 to square root of n in that loop and if at any step p is a factor of n then we should stop the loop. So, the loop will look like this while some condition if the remainder of n is equal to 0. So, if we have a factor of dividing remainder of n by p is 0 then we know that n is not a prime indeed p is a factor of n which is other than 1 and n itself and we need to do something the we need to in fact stop the loop otherwise we just have to implement p where p plus 1. I have a question mark here because we do not really know what we need to write here. So, the question really is how long this loop should run. Now, clearly this loop has to keep has to has to fall as soon as the value of p becomes greater than 2 to square root of n. So, therefore, it must be running only as long as p is less than equal to square root of n. But if we find 1 factor of p 1 factor of n then we do not need to test the further integers of 2 to square root of n because, himing 1 factor of n is good enough to say that n is not a prime. So, therefore, we must stop the loop as we find a factor if we find a factor if you do not find a factor then of course, the loop will terminate when ultimately p becomes greater than square root of n it will finally, become greater than square root of n because, in every iteration we are implementing p by 1. So, now we need to in this case remember this growth or falsity of the condition that n percent p is equal to 0 or not. So, let us use a Boolean variable to to this value. Let us call that Boolean variable as form. So, form will be either true or false will start out a call. So, true will be initialized to call and I am sorry, form will be initialized to call and will become true as soon as we find 1 factor of n. So, therefore, it should be set to true whenever we find that n percent p has become equal to 0. So, this question mark should now be replaced with form the sand true and this condition which we since have not completed. So, you must keep running the loop as long as p is less than equal to n less than equal to square root of n and we have not found a factor because, as soon as we find a factor we should terminate the loop. So, this is the basic idea of the algorithm note that we have used a Boolean variable found here which of course, in the C program as we have the scene will be represented using a variable of type int only because, there are no Boolean types in C and we have also used two operations on Boolean value and or hand and not. So, the operation mark essentially, inverse the truth value that is the value is true not of that value is called and vice versa. So, if the value of found is true then not found is false and similarly, if the value of found is false then not found is true and the operator and is a binary operator that is it has two operands. So, in this example here are the two operands. He less than equal to square root n and not found. So, essentially what the and operator does is that it gives the value true is both the operands have the value true right. So, if p is less than square root of n less than equal to square root of n and not found is true meaning that found is false then this entire expression will have the value true and therefore, if that is the case then this loop will continue whereas, if either of these two conditions is false that is either p becomes greater than square root of n in which case we should terminate the loop because we have not been able to find any factor and we have tested all possible factors from 2 to square root of n or if we have found a factor then also we should terminate the loop because we know now that p is n is not a prime and p is a factor for n. So, if found is true then not found is false and since and and gives the value true only is both the operands are true it will give the value false and therefore, the loop will terminate. So, let us now convert these ideas into a c program. So, here is a program based on the algorithm which we just discussed. So, start out with recommend as usual seeing what the program does. So, it finds other a non negative integer is trying or not by trying to find a factor for it we have to include the cdi.x file as usual math.x we have included because there will be use the square root function from the math library. So, as you know now that the c language is not defined in the Boolean type it we use integer type for Boolean as well. So, we are going to represent we are going to use the value 1 to represent true and 0 to represent false we call that every non 0 value is considered true and 0 is false. So, it is Boolean convention to use 1 as value for true and here is one more way of defining constants in the program in the program that we had written in the last lecture for concluding the area of a circle we had defined constants by declaring them as variables but to fixing the declaration with the world constant. This is one more way. So, it is to say has defined true one and has defined false 0 what this essentially means is that in the rest of the program wherever the world true or the world false appeared that will be replaced by the value 0 or by the value 1 as the case might be. So, here is the main program this time we are using slightly different type we are using the type unsigned long for n so that n can be as big as we can manage as big as we can handle and has to be always non negative. So, therefore, we can make it unsigned some lovely potential divisor is unsigned long and the initial value potential divisor is true. So, the potential divisor is the variable C that we had been using in that column. So, in the program we are using more verbose for variables longer than for variable. So, that we know precisely what a variable stands for and what is the function that is performing in the program and the variable found that we were using in the journalism is or found a divisor in this particular program and precisely as you can see the name precisely specified or indicate exactly what is meant by this variable what is the purpose of this variable. Now, this has to be conceptually if it is a type Boolean because it is only hold a two or false value. So, what we in see we have to use some integer type for this variable. So, we have used a type care we could have used any integer type but we have used a type care because a type care requires the least amount of storage among the integer type. So, using the type care or representing Boolean variables is a good practice because the program does not in that case use unnecessary storage and of course, we just need to represent the value 0 and 1. So, care type is good enough. Now, max size is going to the value of square root of n or in fact, the number the integer which is just below the square root of n. In other words max size is going to be the flow of square root of n. Note that the square root of n need not be an integer. For example, if n is n then the square root of n is 3 point something. So, in that case max size should be 3 we do not need to test for any divisor above 3 because if there is a divisor above 3 then there will be divisor below 3 as well. So, here is the starting the program. We read the number as usual after entering it from and similarly compute the square root of n by using the square root function in the math library. The square root function actually gives a double value and we are assigning this double value to a variable of type unsigned long remember that max size unsigned long. So, here the compiler automatically converts the double value to an unsigned long value. It is called implicit type conversion which will not talk into much detail in this structure we talk about it later. But, intuitively what is happening here is that out of the double value when it is converted to an unsigned long integer the fractional part of the real number will be talked off and only the integer part will be retained. So, here is the main loop pretty much what we saw in the algorithm. The condition for the while look is while potential divisor is less than equal to max size and so this square of the two M percent denotes the AND logical or Boolean operation in C and this grand corrector or the exclamation mark denotes the negation operation negation Boolean operation or the not Boolean operation in C. So, the loop condition is while potential divisor is equal to max size and we have not so far found the divisor. Note that the loop will terminate when either potential divisor becomes greater than max size or we find divisor. So, if n percent potential divisor is 0 then found divisor is said to prove otherwise potential divisor is simply implemented by one. Note that the body of the while look is a single if-else statement. So, this entire thing is a single if-else statement and therefore we do not need braces around the body of the while look because this is just one statement and similarly the then part of the if statement is a single handman statement. So, we do not need braces here and the else part is also a single handman statement. So, we do not need braces around this either. So, of course if we put braces there is no problem with that. So, this is the end of the loop at the end when the loop terminates if you have found divisor that means that n is not a crime. So, in fact if love just saying n is not a crime we also say that n is not a crime because here is a factor of n which is not 1 and which is not n. So, personally is a factor of 1st person is replace the potential divisor which of course is the actual which is the actual divisor that we found or the actual factor that we found and this person is of course, we replace for the value of n. If the variable found divisor is all then the print that the given number n is a crime. So, it is a pretty straight forward program. Let us not try to compile this and see whether it works correctly. Again we have to use the minus lm flag to compile this program because we are using the square root function from the math library and if you remember we had also included math.h in the program file itself. So, let us now just execute this program. Let us try with some non-frient number let us say 16, 2 is the factor of 16. Let us try with the larger number 324 of course, 2 will again be a factor. So, let us try 327 the same 3 is a factor, 2 is of course a factor let us try with some prime number 17 is a prime 19 is a prime 23 is a prime and so on. So, the program is working correctly. So, this brings us to the end of this lecture. In the next lecture we will start talking about operators in C of various times. We will start with arithmetic operators and then talk about different other different kinds of operators like bullion operators etc. in more detail and we will see how complicated expressions can be formed out of by using and combining these different operators in various ways. They have already been using these operators in the programs that we have been writing, but we will discuss them more commonly in the next lecture and also discuss some of the subtle details associated with these operators. Thank you. you you you you you you you