 In the last lecture we have talked about the notion of pointers and we saw that essentially a pointer is the address of a variable and we saw the two operator which are related to pointers that is the M percent operator which given the operand as a variable is the address of that variable and the star operator or the pointer dereferencing operator which given a pointer value as an operand gives the content of the variable or the location to which the pointer points. So, we will continue our discussion on pointers by exploring the relationship between arrays and pointers. In C there is a very close relationship between arrays and pointers and as we will see in some cases arrays and pointers can be used interchangeably. So, to begin with consider the following two declarations in A 20. So, we are declaring an array called A of 20 integers and then we are declaring a pointer variable P which is of type in star and the initial value of P is nothing but A. Now, in C the expression A itself where A is the name of an array is nothing but the address of the 0th element of the array and therefore, the expression A and the expression M percent A 0 are completely equivalent which means that in this initialization P is being initialized to point to the 0th element of the array A. So, in terms of pictures that we saw last time which help us understand the pointer better. So, P is pointing to the 0th element of the array A. So, essentially what we are saying is that the expression A itself where A is the name of an array is the same or is equivalent to the address of the 0th element of the array. Now, recall that in C we said earlier that the different elements of an array are stored at contiguous or adjacent memory location. So, for example, if the first element or the 0th element of the array A is at memory location 1000 and each element required 4 bytes then the first element would be at memory location 1000 4th the second element would be at 1000 8 and so on so forth. So, essentially, viewed in that sense the expression A gives the starting address where the array A is stored in the memory. And similarly, you can see that since A and M percent A 0 are equivalent so are star A and A 0. This is because star of M percent X is always equivalent to X right because we are first taking the address of the variable X and then we are dereferencing that address. So, this is always true and so therefore, star of M percent A 0 must be the same as A 0 and this is nothing but A. So, therefore, what we get is that star A is same as A 0. Note that what this means is that though star A can appear on the left hand side of an expression of an assignment expression which will mean that the 0th element of the array A is being assigned some value. The expression A itself cannot appear on the left hand side of an assignment because that would mean that the starting address of the array A is being changed which is not possible of course, because as we saw last time the addresses of variables are fixed and they are assigned by the compiler we cannot change them, but when an address is stored in another variable then the contents of that variable can be changed. Now, the next important thing to understand is that even a pointer can be used using the array notation that is derefencing using a pointer can be done even using the array notation provided that the pointer does point to an array. So, let us take a simple example. So, we have two declarations here again A is an array of five elements. So, that is how it is depicted and P is a pointer of type in star which means that this variable P will hold the hold a pointer to some integer. Now, the first assignment that is here is P assigned A. So, what happens when this assignment execute the address stored in the variable P is nothing but the address of the zero element of A. Now, when A 2 is assigned 3 now that is familiar to us what should happen is that the second element of array A will get the value 3, but now what is interesting is that we could use the variable P as if it is an array and that is because it is pointing to an array element. So, when P 3 is done that would be the same as as a matter of type A 3 assigned 5 because P and A are synonymous in the sense that the value of pay of value of the variable P is nothing but the starting address of the array A. So, when P 3 assigned 5 is executed the third element of the array A is assigned the value 5. This will become hopefully more clear using more examples that you will see as the lecture processes. Now, we can also pass arrays as arguments to functions and in fact we have been doing that in the case of some library functions. For example, we saw the string functions in the C standard C library for example, functions to find the length of a string and so on. So, there when we pass a string as an argument as you know a string is nothing but an array of characters with the special property that it is terminated by an L character. So, what we are passing to the string length function is really an array. So, what we want to make explore is what happens when arrays are passed to functions and how do we define the functions and how do we call the functions and so on. So, let us take a very simple example. Suppose, we want to write a function to search for a given element in a given array. So, let us say we are given an array of integers and we are given the number of elements in number of elements in that integer and we are given a particular value and we want to search in the array for that value. And if the array contains that value then we should return this function is supposed to return the index at which in the array that value is present and if that value is not present anywhere in the array then the function should return minus 1. So, here is what the function would look like. Note that n and e are integer parameters as usual. So, there is nothing special about them and is the actual number of elements in the array which is being passed and e is the value that we need to search for. Now, this is the array itself which is being passed. So, what is going to happen in c is that when an array is passed as an argument what is actually passed to the function is nothing but the starting address of the array. So, the argument a here actually denote nothing but the starting address of the array which is being passed as an argument. So, the function itself is quite simple. So, we have a for look and we examine all elements of the array a from 0 to n minus 1 and for a particular value of i a i happens to it happens to equal e then we immediately return i because at the array index i the array a contains the value e. Note that the return statement would not just break out of the loop but would immediately cause the function to return. So, the next statement would not execute in that case. So, that means that if the array element that the value e was found there in the array then this loop will not finish as a matter of fact and this return statement will cause the function to return before the loop finishes. And so, if the loop does finish that implies that the array did not contain the value e at any place or at any index and therefore, we should return the value minus 1. So, important point to note is that the value of the parameter a in this function is nothing but the starting address of the array which is being passed as an argument. The copy a copy of that array is not being passed and that also means that when we declare this array we do not need to specify the size of the array. The reason is that when the memory is allocated for for this parameter a the amount of memory required is the amount of space needed to store just one pointer value or just one address. And so therefore, that does not depend on how many elements in the array that is being passed as an argument are there. And because of this reason in fact we could have return this function slightly differently and instead of declaring a in this fashion we could have declared a in this fashion as well. And even then the rest of the code of the function would not need to change because as we just saw even a pointer value can be used as an array. So, let us see now how this function could be called from some other function let us say the main function so that is not important it could be called from any function really. So, in this example we have two arrays a 1 and a 2 of size 100 and 200 respectively and some code initializes the values of the elements of the arrays a 1 and a 2 and also the values of the variables n 1 and n 2. So, let us assume that a 1 has n 1 elements and a 2 has n 2 elements and we could use the same function search to search for some value in both of these arrays. The fact that the sizes of these two arrays is different does not really matter because the actual size of the array or the actual number of elements in the array is being passed as an argument and when the array itself is passed then what is being passed really is only the starting address and that should be clear also from the rule about that we talked about earlier about how arguments are passed to function. So, the argument a 1 would be evaluated in that case and we just saw that an expression denoting just an array name evaluates to nothing but the starting address of the array. So, the expression a 1 evaluates to just the starting address of the array a 1 and that is passed as argument to the function search and similarly in this case the starting address of the array a 2 is passed as argument. Let us consider now another example which modifies the array in which the function which is given an array as a parameter actually modifies some of the elements in that array. So, let us consider a very simple example again in which we are writing a function which is intended to double the value of every element of an array. So, here is what that function might look like double array is the name of the function there is no return value and so the return type is void the argument is an integer specifying how many elements are actually there in the array a which is being passed as the first argument and the code is very simple for all elements from 0 to n minus 1 of element of the array we just double the array element using this r equal to operator. But the question is whether the change is visible in the calling function that the values of the array that we have changed here in this function in the various elements of the array is that change visible in the calling function recall that when we pass when we modify let us say an integer parameter within the function then if the actual argument happened to be a variable in the calling function then the modification to the parameter does not cause a modification in the variable which was passed as argument to it because as we know a copy of that variable of the value of that variable is made available to the parameter. But in the case of arrays recall that it is the starting address of the array which is being passed as an argument and not a copy of the values of the element of the array. So therefore, when this change is being made to an array element what is actually happening is that the array element of the original array which was passed as argument that is being accessed by using its address and therefore, the change would be visible even when the function returns to the calling function. So, let us try to clarify that situation with the help of this example where I have put the same function in the context of a calling function. So, let us assume that this function double array is being called from the function main which has an array a of five elements and an integer variable i and this loop initializes all array elements of a from index 0 to 4 to 1 and then it calls double array with a and five the number of elements in the array as the argument. Now, when this function call happens so this variable a is the variable a of the main function and which represent this array of five elements each of which has the value 1 and when this is passed as argument to this function double array. So, the parameter there is also called a but what this parameter will contain will not be this parameter a will not refer to an array itself but a pointer to the 0th element of the original array which was passed as argument. So, now when this function executes let us say the when this statement is executed for the value of i equal to 0 which means that a 0 star equal to 2 is executed. Now, what is a 0 really mean a 0 means the 0th element of the array to which the pointer a is pointing note that in the context of this function this a is not really an array but it is a pointer. So, a 0 would refer to the 0th element of the array to which the variable a is pointing and so when this is when this assignment is executed the 0th element of the original array a is modified to 2 and similarly in the next iteration of the loop this statement will be executed and a 1 will refer to the first element of the array to which the variable a is pointing which is this one and so this will become 2. And so finally, when the function double array return this variable a will be destroyed and the control will go back to main but in the main function note that the value of the array element in a have actually changed. So, essentially what is happening is that when an array is passed as a parameter to a function it is the starting address of the array that gets passed and in the called function if some array element is modified then because this value is being modified using the address of the memory location containing this value the change is visible even when the function returns to the calling function. Now, this is different from when a normal integer variable is passed because when a simple integer variable is passed the parameter gets a copy of the value of the argument and if that parameter is changed within the body of the function and that change is not visible in the calling function. Now, let us now come to another related notion and that is the notion of pointer arithmetic. You might be surprised to know that in C you can actually do some arithmetic with pointer. The arithmetic which is allowed with pointers is very limited you can add or subtract integers to or from pointers that is you can add an integer to a pointer or you could subtract an integer from a pointer. Now, this makes sense only when the pointer actually points to some array element of some array. So, for example, if p points to the I th element of some array a then p plus j where j is an integer points to the I plus j th element of the same array a and similarly p minus j points to the I minus j th element of the array a note that it is possible that p is not pointing to an array at all or maybe when p plus j is done the array actually does not have I plus j element or maybe if p minus j is done the value of I minus j happens to be negative which means again the array does not have an element at that particular location. So, the competition of the pointer resulting from the pointer arithmetic will work but when you try to be reference such a pointer which has resulted from this arithmetic that will cause unexpected result and that will be similar to an array element being accessed with an index which is out of bounds. So, for example, if an array has an element and if you try to access the nth or the n plus 1th element or the minus 1th element then that is an error and result in unpredictable behavior and similarly if you try to obtain a pointer to the nth or n plus 1th element of the array or the minus 1st element of the array you can obtain a pointer but when you try to be reference it using the star operator then the result will be completely unpredictable and therefore, it is our responsibility to make sure that this never happens that whenever we do the pointer arithmetic we always make sure that our pointer is pointing to a valid element of the array. So, let us see an example of pointer arithmetic now. So, in this example we have two again a variable A is an array of five elements and P is of type in star which means that P will contain a pointer to an integer. Now, the first assignment that happens is P assigned A plus 1. Now, what do you think will happen? Note that the expression A denote the starting address of array A or in other words the address of the 0th element of A and now if you add 1 to 8 one is an integer. So, add 1 to the address of the 0th element of A what you get is the address of the first element of A. So, once this assignment executes P will point to the first element of the array A. Now, in the next step we have the statement P plus equal to 2 which of course, as you know is the same as P assigned P plus 2. So, in this case again what we are doing is adding 2 to a pointer value and assigning the result back to the pointer variable P. Now, P is currently pointing to the first element of the array A. So, P plus 2 will point to the third element of the array A and that pointer value is assigned back into the variable P and so after execution of this assignment P will point to the third element of the array A and in the next step we are subtracting something from the pointer we are subtracting one from the pointer which means that the pointer will move one step back in the array. So, P will now start pointing to the second element of the array A. Now, we are doing something interesting we are using P as an array and we are dereferencing some in some pointer using the array notation, but note that P is not actually pointing to the zero earth element of the array it is pointing to some element of the array, but that does not really matter when we say P 1 assigned 5 what is going to happen is think of an array which starts here. So, think of this section of the array. So, when we are using P as an array where P is pointing to some is element of the array then P 1 is the same as P i plus 1 if P is the same as sorry is A i plus 1 if P is the same as which is of course the same as A plus i. So, if P points to the I f is the same as element then P 1 would refer to the i plus 1th element of that array. So, therefore, now when P 1 is assigned 5 what will happen is that the first element of this array segment will become 1 and so P 1 would be this particular cell which as you can see is the third element of the array A and that follows from this kind of rule that we just saw since P is pointing to the second element of the array then P 1 is the same as the 2 plus 1 that is the third element of the array A. So, P 1 assigned 5 results in this element of the array A getting the value 5. Now, again talk a little bit about strings and see how strings relate to arrays we already know that strings are actually arrays of characters with the special property that the useful data in the string is terminated by an L character and as a matter of fact strings are very commonly used as pointers because as you have already seen arrays can be used as pointers. So, whenever in a function like for example, print F we pass S format string as an argument or in a function like S t r length we pass string as an argument in terms of length of the string. When we pass string as an argument to a function what we are really passing is the starting address of the character array that stores the string and this follows just from the fact that the string is really nothing but an array and when we pass an array as an argument to a function what is really passed is the starting address of the array. Now, strings are also different from other kinds of arrays in the sense that it is possible to have constant strings for example, the constant string A B C here. Now, what kind of an array is that? Now, what happens with constant strings is that the constant strings are treated by the compiler as anonymous array and anonymous means without a name. So, when we use a constant string in the program what happens is that the compiler creates some space somewhere in the memory which contains that string and the value of the constant string expression is nothing but the starting address of that array and we should be careful here that different declarations different ways of declarations of a string may actually mean different things. So, now that we know that pointers and arrays can be used interchangeably we could have these two different kinds of declarations for a string variable but the behavior is going to be slightly different in these two cases. So, in the first case we are declaring a pointer variable P which is initialized to the starting address of a constant string A B C. In the second case we are declaring an array of vectors called P which is being initialized to the string A B C. So, in the first case if we draw this in terms of pictures what it looks like is the following that A B C is an anonymous array created in the memory somewhere by the compiler which contains a string A B C the character A B C followed by of course, the null character and the variable P a box is created for the variable P or a memory location is assigned for the variable P and that is initialized to point to the starting address of this anonymous array. Note that in this case we can change the value of the variable P because P is a normal variable of type character and we can reassign it to point to some other string. Now, if we contrast it with the other kind of declarations what is happening in this case is that we are asking the compiler to create an array called P it is no longer an anonymous array which is initialized which will have four elements in it because the size of the initializing string is four including null character and so P is the name of an array whose elements are the characters A B C and the null character. Note that now P is the name of an array and therefore, P cannot appear on the left side of an assignment. So P assigned something would be wrong in this declaration whereas P assigned some other thing would be correct in this kind of a declaration because here P is associated with a point P is the name of a pointer variable whereas here P is the name of an array itself. Now, let us revisit some of the string handling functions that we talked about some time back and we will see that it is very easy to write the string handling functions that we use from the library. So, as an example let us try writing the string length function ourselves and that will illustrate how easy it is to actually write functions that manipulate a manipulate strings and so on. So, as you know the functionality of the string length function is simple given a string we have to return its length and to do that all we have to do is we have to count the characters in the string till we find a null character and discount is the length of the string. Note that the length that we have to return should not include the null character itself. So, here is the first version of our string length implementation. So, we are actually using the pointer which is passed to the function as an array using the array notation. So, this loop initializes I to 0 and then as long as Si is not equal to the null character it increments I note that the loop body is empty. So, all that is happening is in this i plus plus and in the loop condition. So, essentially this loop will terminate as soon as we can find that Si is equal to the null character and then I will be nothing but the length of the array because note that we are incrementing I 1 for every non null character that we find in the string. Now, we could have written the same string handling function the same string length function using pointer arithmetic as well that is instead of using Si to access the I s element of the string I s character in the string we could have used something like star of s plus i which would be the same as Si. So, we could have done that and even more interestingly we could have modified the value of the variable s itself in the loop. So, let us look at this second implementation of the same function. So, this time I have chosen to declare s as a car star which of course, is the same as declaring it as an array within the function parameter. But, I am going to use s as a pointer and not use it with the array notation. So, in this version of the function what is being done is that again i is a sin p rho that will be the count and we are checking whether s is pointing to the null character. Now, star s is nothing but the value of the character to which s point and as long as that is not null we keep running the loop the loop body is again empty. But, after every iteration of the loop we increment i by 1 of course, to account or count for the non null character that we have just seen and we also increment the value of s. Note that this is the same as s assigned s plus 1. Now, this is not normal arithmetic this is pointer arithmetic because s is a pointer. So, what you are doing here interestingly is that we are modifying the pointer argument that has been passed to us. But, again note that it is the copy of the address that we have been given we are not actually modifying an element of the string whose address is given to us. But, the address of the string itself and the address of the string that we have been given is actually a copy of the original address from the calling function. So, the change to s will not get reflected in the calling program. Now, this may not be obvious to you, but once we trace this function with a calling function and with the help of the notation that we have already seen using boxes and arrows to represent variables and pointers this will become very clear. So, let us go and do that. So, here is the same function again the string length function that we had the string and let us say this is the calling function. So, in this calling function we have a pointer p which is pointing to a constant string a b c. So, let us draw our familiar boxes and arrows. So, p is pointing to the 0th element of this anonymous array containing the characters a b c followed by a null character and of course, l is a normal integer variable and then we are calling string length with the argument p and the result is assigned to l. So, these two are the variables of the calling function. Now, when this function gets called space is created for the argument for the parameter the parameter is s which is just a pointer and this will be initialized with the value of the argument which is passed. So, value of the argument is the value of the variable p which is a pointer to the 0th element of the string. So, the value of s will also be there. Now, when this loop run i is initialized to 0 i is a local variable of the string length function. So, i gets initialized here and s is already pointing to the 0th element of the string. Now, the check is made whether star s is equal to the null character or not star s is nothing but the character a which is not the null character. So, the loop body execute the loop body itself is empty and at the end of the loop body this expression is evaluated note that it is using the comma operator which means both these expressions will get evaluated. So, the first expression to be evaluated is s plus plus which will which is of course, as we saw is the same as s s and s plus 1 which will mean that s will now start pointing to the first element of this character array and i will become 1. Now, the next time the loop condition is again tested star s is now b which is still not the null character. So, s gets incremented again s start pointing here and i is incremented. So, i becomes 2 and then we again go back to the loop test star s is still not equal to the null character. So, value of s is changed to point to the next element in the array and the value of i becomes 3 and then the loop test is executed again this time star s is the null character and which is so this test failed so the loop terminates and when the loop terminates the we come to this return statement which returns the value of i which is 3 which is the correct length of the string of course, the value 3 is returned. But now the variables of the string length function will get d allocated and the control will go back to the calling function. So, l will get assigned the return value which was of course, 3 and the important point to note is that the modification of s has not resulted in the modification of the variable of the variable p is still pointing to the 0th element of the original array. Now, on the other hand if we had modified an element of the array itself. So, for example, if we had executed a statement like this let us say x and let us say at that point in time s happened to be pointing to the first element of the string then this would have been modified and even when the function return and s got d allocated this string this change in the string would still get reflected. But here what is being modified is just the address which is being passed to us and since we have got a copy of this address this local copy within the string length function is being modified and the original copy of this address does not get modified. So, that is the end of this lecture today and before we stop I would like you to utilize the techniques that we have discussed today to try and implement some of the other string library functions that we have already used in some program. For example, you could implement the string cat str cat function which concatenates two string or you could implement the string comparison function str cmp which compares two