 In the last lecture we had talked about C expressions and operator. We had looked at arithmetic, relational and logical operators. We will continue that discussion today with operators which have side effects. So, far the operators that we have seen when an expression with these operators is evaluated it results in a value, but as a result of the evaluation of the expression the value of the variable of any variable does not change. On the other hand there are second operators that we discussed today where the evaluation of an expression containing such an operator can also result in a change in the value of some variable. So, these kinds of changes are called side effects and such operators are called operators with side effects. Let us start with a very similar operator, the assignment operator. We have already used the assignment statement in all the programs that we have written so far. You will be surprised to know that assignment is actually an operator in C and it has two operands. The left operand always has to be a variable, that is the variable whose value has to be assigned and the right hand side of the right operand can be in an arbitrary expression. So, what does it mean to evaluate the assignment operator? We have to define the effect of evaluating such an expression in terms of what is the value of the expression as well as what is the side effect of evaluating such an expression. So, as an example consider the expression x assigned e if we evaluate this expression what is going to happen is that the expression e gets evaluated to some value that value becomes the new value of x that is the side effect of evaluating this particular expression and the value that was obtained by evaluating the expression e is also the value of the expression. So, the value of the expression is the same as the value of x which is the value of the expression e. So, let us see some examples. So, compare the expression x assigned y minus 2 let us assume that y has value 10. So, when we evaluate this expression the expression on the right hand side y minus 2 get evaluated which results in the value 8 and so the side effect of the expression evaluation is that the value of x becomes 8 as well as the value of the entire expression x is equal to y minus 2 is also 8 as a slightly more complicated example consider this expression z assigned x assigned y minus 2. So, we will have to first see what this expression really means the equal to operator of the assignment operator has a precedence less than that of the minus operator will see the complete list of operator precedence is in the specificity slightly later on and the equal to operator associate right to left not left to right as is the case with the most arithmetic operator. So, which means that the subtraction will be performed first and then the two assignments will happen and the assignment on the right will happen first because the creativity of assignment is right to left not left to right and so therefore, this expression is the same as this bracketed expression first y minus 2 is evaluated that is assigned to x and the resulting value of the expression x assigned y minus 2 is assigned to the values x. So, when y minus 2 is evaluated the value that we get of course, is 8 again in this case assuming that the old value of y is 10 and that assigned to the variable x the value of x becomes 8. Now, the value of this smaller assignment expression is also went to the is also went to the 8 which is the final value of the variable x and that is the value that gets assigned to the variable z and so z also gets the value of 8 and the value of the overall expression also happens to be 8 which is the final value of z. Now, the reason we were able to use assignment as statement is general rule in G which is that any C expression can actually be used as a statement by adding a semicolon abstract. So, we just saw the expression x assigned y minus 2 if we add a semicolon after this then it becomes a valed C statement. Now, when we use such a statement the meaning is that the expression is evaluated and its value is discarded that is the value of the expression is discarded. So, this makes sense this is useful only if the expression has certain satisfaction because it has most satisfaction only its value is important then it does not make sense to use that expression as a statement because the value is discarded anyway. The most common example of course, is the assignment statement which is which is very common in all C program and as we understand now the assignment statement is actually nothing but an assignment expression followed by a semicolon which converts it into a statement. So, as a fact in such a case expression is evaluated and its value is discarded but whatever side effects happened as a result of evaluating the expression state. So, as you can see it is clearly not useful to use an expression that has no satisfaction as a statement for example, consider the statement x plus y semicolon. Now, this in itself is a valed C statement because x plus y is a valed C expression but this is quite useless a C statement because the value of the expression x plus y is the target and expression has no side effects. So, whether or not we put such a statement in the program that makes absolutely no difference to the working of the program. So, we now have to talk about type conversion or we must emphasize implicit type conversion in assignment expression. The rules for type conversion in assignment are slightly different from those that happen in the other arithmetic operators and so on. So, if you recall in operators such as plus minus etcetera the rule was that if the two operands are of different types then the operand which is of the lower type its value gets promoted or gets converted to the higher type. In assignment on the other hand what happens is that regardless of which of the two types is lower or higher the value of the right hand operand always gets converted to the type of the left hand operand because it is the the left hand operand is a variable and it is into this variable that the value is going to get stored. Therefore, whatever the value we get as a result of evaluating drag inside operand must be converted to whatever is the type of the variable. Of course, this may in general result in loss of information or accuracy for example, suppose x is an integer variable and we have an assignment x to send 5.2 you know that 5.2 is a constant literal of floating point time and its type there 4 is double. Now, the double type is higher than the integer type as you know, but because of the special rule in assignment the type of the expression on the right hand side is going to get converted to the type of the of the variable on the left hand which means that the type of the expression 5.2 which is double is going to get converted to an integer before that value is stored in the variable x. So, variable x cannot of course, stored the value 5.2. So, when 5.2 double value is converted to an integer, the fractional part is dropped off and the resultant value is just the integer type and that what gets assigned to the variable x. So, in this case what is happening is a loss of information from 5.2 the original value what actually gets assigned to x is just 5. So, while using this kind of assignment where the two operands are of different type one has to be aware of this. Similarly, if on the right hand side we happen to have a long integer and on the left hand side we happen to have a variable of type simple int then it is possible that the value of the right side may not actually fit in the in in an integer. If the value happens to be large and it cannot fit in an integer then what will happen is that some of the bits will get dropped off and the result will probably not be what we expect. So, one has to be careful in making such an assignment. Okay, here is another example of the same kind. So, in this example x is an integer variable and y is a floating point variable and we have the statement y assigned x assigned 7 point 0 divided by 5 and of course, as you know the flash operator has the highest position. So, the bright thing is going to look something like this. The second assignment is going to be evaluated first because the assignment operator associates from right to left and not left to right. So, the division is carried out first. Now, in division one of the options is of type double let's run point 0. The other is int. So, if you remember the rules what happens? The value 5 gets promoted to a double so that becomes 5.0 and we divide 7.0 by 5.0 that gives us the value 1.4. Now, if you look at this assignment which is carried out next, the left hand side x is of type int whereas, the expression on the right hand side as a type double and value 1.4. So, what we have to happen in this case according to the rules for assignment is that the value on the right hand side is going to get converted to an integer which means that the sectional part will be removed. So, 1.4 will get converted simply to 1. So, the value that x gets is 1 and the value overall expression x is equal to 7.0 divided by 5 is also 1 and the type is an integer. Now, that the first assignment why you find the rest of it this happens. Now, the right hand side of this expression has already been evaluated and that has been evaluated to the value 1 of type integers. On the left hand side we have a variable y which is of type flow. So, the value 1 of type integer is going to get converted to a flow that becomes 1.0. So, y gets the value 1.0. So, in this example both x and y get the value 1. On the other hand suppose the assignment was x assigned y assigned 7.0 divided by 5. So, what will happen in this case? This assignment is going to happen first. Now, 7.0 divided by 5 is evaluated it again evaluates to double value 1.4. Now, y is a flow the double value 1.4 gets converted to the flow value 1.4 and that is the value that gets assigned to the variable y. So, y gets the value 1.4 and the value of this overall expression is 1.4 of type double of type flow and then this assignment happens. Now, here the left hand side is of type integer and the right hand side is of type flow. So, the right hand side value gets converted to an integer. So, 1.4 when it gets converted to an integer the fractional part is dropped off and the right hand value is 1. So, the value of x becomes 1 and of course, that also the value of the overall expression. So, in this case y would get the value 1.4 while x would get the value 1. Now, let us now look at some more operators which are similar to assignments they all have side effects and in fact, can be described in terms of the assignment operator. So, there are 5 of these plus equal to minus equal to star equal to slash equal to n percent equal to and essentially these combine assignment with some arithmetic operation like plus or minus or multiplication or division or remainder and so on. Of these 5 the first 4 can be used with protein point as well as integer quantities while the fifth one can be used only with integer quantities. So, in all these cases again the left hand operand must be a variable and the right hand operand can be any expression. So, for example, let us look at an expression x plus equal to e. This is exactly the same in terms of both value as well as the side effect as the expression x assigned x plus e. So, therefore, the side effect is to add the value of e to the current value of x and the new value of x is the value of the expression and the same is the case with the other operator that you listed here. The only difference is that instead of this plus this could get replaced with subtraction multiplication division or remainder operation as the case might be. However, two commonly used operators in C are the instrument and detachment operator. These are denoted by the plus plus and the minus minus inverse. There should not be any space between the two pluses or the two minuses. Both are unary operators that is there is only one operand and the operand must be a variable. And interestingly is that both can be used in prefix as well as the post-fix form, but the meaning in the two cases is different. Prefix form means that the operator comes before the operand and the post-fix means that the operand comes before the operator. So, let us see what these operator really means. Let us assume that x is the variable of type n with some initial value x 0. So, if you look at the expression x plus plus the value of the expression is x 0 and the side effect is to increment the value of x by 1 that is the new value of x is the old value x 0 plus 1. So, this is the post-fix form of the plus plus operator. In the prefix form the value of the expression is x 0 plus 1 and the side effect is the same which is to add one to the old value of x. So, the new value of x becomes the old value that is x 0 plus 1. So, the only difference really in these two is the value of the overall expression. One way to understand this is that in the post-fix form you could say that the value of x is used as the value of the expression and then the side effect happens that is the value of x then gets incremented once the value of the expression has been computed. Whereas in the prefix case here the value of x or gets incremented that is the side effect for this happens and then the new value of x is used as the value of the expression. So, to clarify these operators let us take some examples you can see that the minus minus operator is exactly the same as the plus plus operator except that these pluses are replaced with minuses. That is the side effect is to decrement the value of x by 1 and the value of the expression is either the old value of x or the new value of x which will be the old value of x minus 1. So, here are some examples to clarify this. Let us assume that x and y are integer variables and the initial value of y is 5. So, let us assume that the expression x is equal to y plus plus is evaluated. So, now if you look at this expression y plus plus the value of this expression is same as the old value of y. Because this is the post-fix form of the plus plus operator so the value is same as the old value. So, the value of the expression y plus plus is the old value of y of y which is 5 and the side effect is to increment the value of y by 1. So, now what gets assigned into x is the value of the expression y plus plus which is the old value of y which is 5 and so x gets the value of y while x while y gets the value of 6 after the entire expression has been evaluated. Now, on the other hand if we had evaluated with the same ah declarations the expression x is equal to plus plus y. Now, what is going to happen is that when plus plus y is evaluated it the value of y is in 3 by 1 it becomes 6 and the value of this expression is the new value of y which is also 6 and so therefore, the value that x gets is in this case 6 and not 5. Let us consider some more freaky example look at this program fragment x and y are declared to be integer variables and y has initial value 10 and you have the assignment statement x assigned plus plus y plus minus minus y. The question is after the evaluation of this statement or after the execution of this statement what are going to the values of the variable x and y. Now, with respect to y you can see that there is one instrument and one decrement happening to the value of y which means that the value of y is going to be 10 it is going to remain 10 because 10 plus 1 becomes 11 and 10 minus 11 minus 1 again becomes 10. So, regardless of the order in which the two ah expressions two sub expressions plus plus y and minus minus y get evaluated the final value of y will be 10 but what about the value of x. Now, the value of x as it turns out will vary depending on which of these two expressions is evaluated first right. Note that plus plus and minus minus both have high precedence higher than that of the binary plus operator and higher also than the precedence of the assignment operator. So, therefore, these are going to get evaluated before the plus operator but if you recall the C language is not specified for a plus operator which of the two operands is evaluated first and as it turns out in this example the answer for the final value of x will be different depending on which of these two is the case. So, let us assume that plus plus y happens first. So, if plus plus y is evaluated first then what happens after the evaluation of this expression the value of y becomes 11 and the value of this entire expression plus plus y is also 11 because remember this is free increment that is the instrument happens before the value of this expression is computed. So, the value of this expression is 11 and y has also changed to 11 and then the expression minus minus y gets computed which means that y gets incremented from 11 to 10 and the value of the expression minus minus y also is the final value of y which is 10 which means that x gets assigned 11 plus 10 this expression gets evaluated to 11 and this expression gets evaluated to 10 so the result is 21. Only other hand suppose minus minus y was to be evaluated first. So, that is it would result in the value 9 and 10 plus plus y when it gets evaluated results in the value 10. So, the final value of x becomes 10 plus 9 that is 90. So, in this case as you can see the final value of x will depend upon which of these two expression gets evaluated first and the C language does not specify as to which one will happen. So, except for these two operators these two exceptions you had noted in the last lecture we will come back these shortly except for these two operators C does not specify the order in which the operands of a particular operator are evaluated this is left to the compiler. So, which means that some compilers may evaluate the left hand operand first and some compilers may evaluate the right hand operand first. And if you are using an expression in which the final result can vary depending on in which order depending on the order in which the two operands are evaluated then what that means is that depending on the compiler that is being used the result might be different. So, so construct like the one that we saw just now plus plus y plus minus minus minus y they are inherently ambiguous what that means is that they can be interpreted in two different ways which are not the same and therefore, we must avoid them because our intent is only one of these two possible interpretations but on a different machine with a different compilers the same program may actually give a different result and so therefore, these expressions and these construct should be strictly avoided. For the logical and in the logical or operator the C language does define the order in which the two operands are evaluated and as a matter of fact the left operand is always evaluated first and the right hand operand is evaluated only if the result of the expression cannot be computed based only on the value of the left operand. So, if you remember that for the logical and operator if the first operand the left operand evaluates to hall then the entire expression must evaluate to hall because for it evaluate to true both the operand must be true. So, the first operand evaluates to hall then the second operand will not be evaluated at all and if the second operand happen to have some side effect and those side effects will not take place simply because the second operand does not get evaluated at all and similarly for the logical or operator if the first operand evaluates to true then regardless of the value of the second operand the entire expression will get the value true and therefore, the second operand will not get evaluated at all and again if it has side effects then those side effects will not take place. So, therefore, again with these operators one has to be careful as to what the final value of the various variables are going to be. So, let us take this simple example here x is initialized to 10 and y is initialized to 20 and we have when it is conditional if x plus plus or y plus plus. So, this is a logical or operator what is going to happen is at the first operand which is x plus plus is going to get evaluated first. Now, the value of x plus plus will be 10 because this is whole sentiment and of course, the side effect is that the value of x becomes 11. So, since the value of this expression turns out to be 10 which is non-zero and therefore, consolidated as true. So, therefore, the second operand need not be evaluated at all that is the expression y plus plus will not get evaluated at all. So, and the entire expression will result in the value true because the first operand evaluated to true. So, which means that the end of the evaluation of this entire expression will result will be true the value of x will become 11 and the value of y will remain 20. On the other hand if instead of the or logical or operator we had the logical and operator then what would have happened is that x plus plus is evaluated that result in the value 10 and x is implemented to 11. But since this is true the second operand must also be evaluated because if the second operand turns out to be false then the overall result will be false and if the second operand turns out to be true then the overall result will be true. So, y plus plus would also get evaluated in that case. So, y plus plus would of course, result in the value 20 and y would get implemented to 21. So, since both are true the overall result would be true but both x and y would get implemented in that case. Similarly, the order of evaluation of argument for a function called is not specified as e. You know that we use several library functions in most of our program. And when we first parameter or argument to be function the order in which these arguments are evaluated is again not specified by the C language it is up to the compiler. So, let see an example. So, here x has the x is a variable of type double with value 24 and the printer statement print 2 double number. The percent f is used in print f to print double quantity. The first quantity is x the value of expression x plus plus and the second quantity is the value of the expression square root x. Now, as I said the C language does not specify in what order these two operands are going to be evaluated. Now, suppose the argument x plus plus is evaluated first which means that x gets implemented to 25 and the value of this expression is 24. And so and then afterwards the square root x is computed. Now, here the square root of 25 will be computed because x has already become 25. So, which will force the result in the value 5 and therefore, the output will be 24.0 for this parameter followed by 5.0 for this value. On the other hand if the square root x was evaluated first then that would be square root of 24 which will be something like 4.89897. And then suppose the second parameter was to be evaluated that would again result in the value 24 because the evaluation of the first expression did not have any side effects x remained 24. So, when this gets evaluated again the value is 24 and side effects is to increment x to make 25. So, the output would be 24.0 followed by 4.89897 and not 5.0. Okay, so we have introduced many new operators in this lecture. So, here is the summary of the precedence and associativity rules. As usual the precedence is decreasing from top to bottom. The highest precedence operators are the unary operator. We had seen the logical not the unary plus and unary minus in the last lecture and the instrument and decrement operators are the two new unary operator sets we have seen in this lecture. So, all these unary operators have the same precedence and they associate from right to left. Then come the arithmetic operators multiplication division to mean the associativity is left to right. Then the addition subtraction again left to right. Then less than less than equal to greater than greater than equal to left to right again. Then equals and not equals left to right. The logical and the logical or both associate left to right. And finally, the assignment and assignment like operators like equals assignment plus equals minus equals star equals and so on. Here is a little exercise at the end of this lecture. Please look at this program. You can out of it and try to find out what it does. So, you will see that the first parts are fairly straight forward. We declare two variables N and P. Please initialize to 1. The value of N is right from the terminal. And while N is greater than 1, the loop is executed and the loop body is T star equal to N minus minus Cn equal and note that the star equal to is an operator. And therefore, this entire thing is an expression. And therefore, we are putting this Cn equal and after it, we can use it as a simple three statement. So, try to figure out what this program is doing. You will find that it does something very familiar. So, as a caution at the end of the lecture, you have been introduced to many interesting operators which had effect. And as you start using these operators, you will find that the use of these operators can make the program very compact and elegant in many cases. However, over use of such operators is not advisable because if you use these operators too often, you tend to make the expressions very very complicated and hard to understand. So, that will mean that the program itself can become very hard to understand. And therefore, of course, one should strive to strike a balance between elegance and understandability.