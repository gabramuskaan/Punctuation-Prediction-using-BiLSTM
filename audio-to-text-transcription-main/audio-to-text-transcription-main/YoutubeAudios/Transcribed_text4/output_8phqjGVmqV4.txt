 In the last lecture we had talked about structures and also towards the end of the lecture we saw how we can write programs that read data from files and write data to files. Today we are going to talk about them, they are very important tool in programming and constructing interesting data structures for holding various kinds of data and that is dynamic memory allocation and link list. So, to motivate the use of dynamic memory allocation let us see what the problems in using arrays for storing large volumes of data are. Arrows let us store large numbers of data items, but as you know we have to pre-specify maximum limit, this maximum limit has to be declared at compile time and we cannot change it at runtime. And if we have more data items at runtime as input then be a specified limit then we cannot really handle that and we specify a very large limit and the problem is that we might end up wasting a lot of memory. So, dynamic memory allocation as the name suggests allows us to ask the system for more memory as in when required. So, we can essentially not allocate all memory at compile time itself instead depending on the inputs as in when more data items are needed to be stored we can ask for more memory. For example, suppose we are reading a large set of data values we can allocate memory for one item as in when we read a data item we do not even need to know in advance how many data items are going to be there. But the problem with dynamic memory allocation is that we need to keep track of all these chunks of memory that we get dynamically allocated. Now, in the case of an array all the elements of the array are at contiguous memory locations. So, if you know the address of the first element of the array then it is easy to find the address of any array element as we know using quantum arithmetic or using the indexing mechanism for arrays. But when we dynamically allocate large number of chunks of memory one after the other they are not guaranteed to be contiguous in memory and therefore, we have to somehow keep track of where these chunks of memory are in memory. And the solution to this particular problem is to use structures and pointers in combination and the basic idea is very simple. That is why we have integers as data items which we need to store and we are using dynamic memory allocation to store them and allocate enough memory to hold an integer as and when we read an integer. So, what we do is that each data item is stored in a structure which besides containing the integer or whatever the type of our data item is it will also contain a pointer to the structure containing the next data item. And so every structure will contain a pointer to the next structure containing the next data item and that one will contain a pointer to the third structure and so on so forth. And as you can see this creates a linked list of data items let us say it better through a pictorial representation. So, in this example again we are assuming that it is integer values that we are interested in storing. So, we have declared a structure type struct item which consists of an integer value and a pointer to another struct item. So, note that in terms of struct item I cannot have an abstract item because then the size of this would have to be infinite. But I can always store a pointer to a similar kind of structure within a structure itself. These kind of structures are called recursive structures and that is possible because the size of a pointer is independent of the size of the quantity to which it points. So, the compiler knows at compile time that an integer will take so many bytes and storing a pointer will require so many bytes and therefore, overall the structure will require so many bytes. And so we have the structure which consists of an integer value that we need to store and a pointer to the next structure and let us say we have a variable p which is a pointer to an item. Now, consider this kind of a linked list. So, the variable p contains the pointer to the first element in the list. Each of these is an element and each of these is of type struct item. So, p contains a pointer to the first element and the next field of the first element contains a pointer to the second element which has a value and a pointer to the next element which again contains three and the pointer value in the next element is a null pointer which we have already talked about earlier in the in some earlier lecture. This is a special pointer value which is not the address of any legal memory location. So, we can use this to mark the end of the list, but we have to be careful that we never de-reference the null pointer that is we never perform a star operation or an arrow operation on a pointer which is null. So, if we have this kind of a list then we need to store only in a variable we need to only store the starting address of the list or the pointer to the first element of the list because the other elements can be tracked using the chain of pointers. So, p is a pointer to the first element. So, p arrow next will be a pointer to the second element. Similarly, p arrow next arrow next will be a pointer to the third element and so on so forth. Similarly, p arrow value is the data value of the first element. p arrow next arrow value is the data value the second element. p arrow next arrow next arrow value is the data value of the third element in the list which is three in this particular case. Now, before we see how we can actually create a list let us see an example where we actually go through this list and compute some quantity or look for something or something of that kind. So, as an example let us assume we have such a list and we want to write a function which computes the average of the numbers in this list and of course it assumes that the number of elements is at least one. So, this is the function prototype. We are going to return a float which is the average. The argument is a p which is a type struct item star. So, the argument is supposed to be a pointer to the first element of the list for which we want to compute the average. So, we have two local variables. Some will represent the some of the data values in the list and count will represent the number of elements in the list. Now, this list essentially traverses the list as long as p is not null we in every step we make p point to the next element in the list and the element that it was pointing to we add that data value to some and increment count by one. So, as long as p is not null some p value is added to some, count is incremented by one and then p is made to point to the next element of the list. And finally, p will become null because the last element of the list will have the next value null. At that time the slope will terminate and then some will be the sum of all the elements in the list count will be the number of elements in the list and therefore, some divide by count will be the average. So, let us see with an example how this executes. So, in this example in the main function we have somehow created the list which we have not seen so far will look at that shortly and let us assume that p points to the first element of the list. Let us again assume that this is what the list looks like. So, this variable p is the variable p in main. Now, when the function average is called as you know space is going to be created for the parameter p of average and the variables sum and count which are local variables of average and the parameter p will be initialized with the value of the argument which is this p and therefore, that will be a pointer to the first element of the list as well. So, so, p is created is initialized to the value of this p which is a pointer to the first element. So, this p also gets a pointer to the first element in the list. Now, let us go through the loop p is not null and so therefore, this loop will execute loop body will execute some will become. So, initially first of course, we sum in count initialized to 0. Now, the first time around the loop executes some will become 5 count will become 1 and p will become p arrow next. Now, p is currently point in this element and p arrow next is this value which is nothing but a pointer to the second element. So, when this statement executes p will now be pointing to the second element of the list that is what happens. Some becomes 5 count becomes 1 again p is not null. So, the next time around some becomes 12 count becomes 2 and p now points to the third element of the list again p is not null. So, some becomes 15 count becomes 3 and now it becomes null because p was this and p arrow next was null. So, now p has become null and so the loop terminates and some divided by count is of course, 5 will be returned. Let us see now how a list can be created. So, essentially in this example of seeing how we can create a list, whenever we read a data item we are going to allocate a memory chance large enough to hold a struct item and store the data item in that field. Now, for allocating memory of a given size we are going to use the library called mLoc which is the library called used for dynamic memory allocation. So, once we have allocated the memory for a struct item dynamically then we initialize the data value in that to the value that we just read as input and the lists that we already have we insert this new item in the existing list. So, in the first example that we are going to see what we are going to do is that the new data item that we read will be inserted in the beginning of the list that is already there. So, let us see the code to do that. Well, for using the MLLAB function you need to include the file at the delib.h. So, that has to be included in all programs that use mLoc. Now, for the function create list which will create a list of read a number of data items from the input and create a linked list of those data items and what it returns is a struct item star which means that it return the pointer to the first element of this list which is going to get created. Now, these are the local variables. List is a local variable which is again of type struct item star. So, and it is initialize to null and that is because currently the list is empty and so therefore, we have made the pointer list point to null and P will point to the structure that we get we dynamically allocate every time and value is the value that we read. Now, as long as reading an integer results in success, scan if it returns one, what we do is we allocate a chunk of memory using MLLAB. The argument to MLLAB is the size invite that we want to of the memory chunk that we want to allocate. Now, recall that the size of any type can be obtained using the size of operator in C. The size of struct item gives us the number of size in number of bytes of the type struct item. So, that is the number of bytes that we done weekly want to allocate. So, we specify that in P as the argument to MLLAB. What MLLAB returns is a pointer to this dynamically allocated structure. But if for some reason, memory allocation fails for example, if we have allocated so much memory dynamically that the system has run out of memory, then MLLAB returns null. So, it is important that whenever we use MLLAB, we check that the return value is not null because if you are careless and we use up too much memory, then MLLAB might return null. So, if C is null, we print some error message and exit. So, assuming P is not null, we set P value of P to the value that we write here. And these two are inserting this new element in the list. Let us see how exactly that is happening. And finally, when the slope terminates that is when we could not read any more integer values, then we return list. Now, let us see how exactly all this is really happening. So, we have this variables list and P list is initialized to null, P is not initialized. Let us say the first data value that we read is 1. So, this allocates a new structure for this and stores the pointer to this structure in P. So, this is what happens and then we store the value that we read in the value field of this structure. Now, P arrow next is list. Now, the value of list right now is null. So, P arrow next will also become null. So, that means this value, the next field of this structure becomes null. And the next statement is list assigned P, which means that list is no longer null, list is now pointing to this element. Now, let us assume that we read one more integer value and let us say we happen to read the value 3. So, again P is assigned M log a structure of a size struct item. So, again another structure of the same size is allocated somewhere in the memory and now P is pointing to this and P arrow value is initialized to 3. P arrow next this sign is list. So, what is being done is that this next field of this new element is being made to point to the first element of the existing list. So, now this 3 becomes the first element of the list and therefore, the value of list is changed to point to this new first element and so on. So, when the next value is read another structure will be created and let us say 5 is read and the next field will be made to point to the first element of the currently existing list and the list pointer will be updated to point to this first element. So, that this will become the first element. So, if you at the end of this if you write 1, 3, 5 the list will look like this. Please go through this example once again to make sure that you understand exactly what is happening here and finally, the value of list is returned. Now, so in this code what was happening is that the list the order of elements in the list is reversed of the order of elements in of the order in which the element the values were read. Now, suppose you want to create the list in which the elements are in the same order as the order in which they were read. Now, what we have to do for achieving that what we will have to make sure is that if we have an existing list of let us say 3 items 1, 3, 5 this is null and we want to insert 7. So, this is a pointer to the first element in the list let us call it the head of the list and now when we let us say read 7 now this element must be inserted at the end of the list. So, that means this pointer value must be updated to point to this and this pointer value must be made null. So, therefore, if you want to update this field of this structure we must somehow optimal a pointer to this structure. Now, one way to do that could be to traverse this list once again and reach the last element and then set the next field of that element to the newly allocated structure, but obviously that is going to be expensive. What is better is that we maintain a pointer to the last element of the list and when we insert one more element since we already have the tail pointer all we have to do is set the next field in the structure pointed to by the tail pointer to the newly allocated structure and update to point to this structure and that is what is going to happen in the first step that we are just going to see, but we have to be careful because if initially the list is empty so both head and tail are going to be null. So, if we try to set tail arrow next to P of where P is the pointer to the newly allocated element then if the value of tail is null then we are de-affirming a null pointer which will result in unpredictable behavior which will probably cause the program to crash and so this must not be done and therefore we need to specially consider the case when inserting the first item in the list. So, let us look at the code. So, we initialize head and tail to null and P will be the pointer to the newly allocated element value is as before. So, we read a value and we allocate a new structure for holding this value. So, if P is null we print another message and exit etcetera. So, this P points to the new value to the new structure that has been allocated. The value field is set to whatever value we write let us say 10, next field is set to null and now there are two cases if tail is null that means that this is going to be the first element in the list and so head and tail are both set to P because this is the first as well as the last element of the list. Now, if tail is not null then tail is pointing to an existing last element of the list list has at least one element let us say this happen to be 5. So, we set tool arrow next to P which means this tool arrow next was null initially. So, we make it now point to the newly allocated structure and tool is set to P. So, that now tail also points here because this element is now the last element in the list. Now, consider some other operations on a linked list that we might want to perform. We might want to insert an element in the list and we might want to delete an element in the list. Now, when we delete an element from the list then we also need to free or deallocate the memory assigned to this particular element in the list because if we do not do that then what might happen is that we keep allocating more and more memory without deallocating any memory and ultimately we might run out of memory. So, it is a good practice to always free or deallocate memory as soon as it is no longer required and we will see how to do that. Now, when we want to insert or delete an element in the list you can see that the value of the next field in the previous element is going to change. So, for example, if we have this list let us say 5, 3 this is and we want to delete this element from the list then what is going to happen is that this value must be changed to this value so that this structure is no longer part of the list. So, therefore, if we want to modify this value we must have a pointer to this element of the list. So, that means we must have a pointer to the element before the one that has to be deleted and similarly when we want to insert an element in the list. So, let us say this is something like the following. Now, suppose we want to insert an element between these two elements let us say 6. So, we allocate a new structure. Now, what will happen is that this value the value of next in the element before the position of the inserted element must be changed to point to this this must be changed to point to the next element in the list. Now, if we have a pointer to this then we can always obtain a pointer to the next element in the list. So, if we have a pointer to a particular element in the list we cannot obtain easily the pointer to the previous element in the list. So, therefore, for both insertion and deletion what is easy to do is to assume that we are given a pointer to the element in the list just before the element which has to be deleted or just before just before the place where the element has to be inserted. And the third operation that we will consider will be to free the entire list. So, if we are we are done with the entire list as a whole not delete or delocate all the elements of the list then we will have to go through the list and delocate each structure in the list each element in the list individually. So, we will look at code snippets to do all these three operations. So, let us take the first operation that is insertion of an element after a given element in the list. So, here is what the code might look like. So, let us assume that list is the pointer to the first element in the list and p is the pointer to the element after which the new element has to be inserted and v is the data value for the new element. So, that means, that list is points to the first element in the list and p is a pointer to the element in the list after which this element has to be inserted. Let us take an example maybe this is null and this list is pointer to the first element in the list and let us say we want to insert the new element here. So, p is a pointer to the element just before that. So, the impression is quite straightforward we have to of course, allocate a new structure and we do that and store the pointer to that structure in the variable new set the value to v the value that needs to be inserted. So, let us just put the value v here. Now, let us assume that p is not null. If p is null we will assume that what we want to do is to insert the new element as the first element in the list and that again will have to specially handle because we cannot dereference the pointer the null pointer. Let us assume that the next p is not null. So, we execute this piece of code. So, what happens is that new arrow next is set p arrow next. Now, p is pointing to this structure and the value of p arrow next is pointer to this structure. So, new arrow next which is this box gets assigned a pointer to the element in the list after p and finally p arrow next is assigned new. Now, this structure p the next element that it should point to is a new structure. So, this is changed to point to new. So, essentially now the list looks like one followed by 3 followed by v followed by 5 followed by whatever else which might have been null. Now, the second case is when we want to insert the new element as the first element in the list and let us assume that in that case the value of p is specified as null. So, if p is null that means that we want to insert the new element as the very first element in the list. So, we assume that this is the existing list and we want to insert the value 1 let us say. So, in this case p is null. So, in this case possible to happen is that the value of the variable list itself needs to change because list remember back convention will always point to the first element and the new element will become the first element and the next field of the new element must point to what will become the second element and therefore, what is the what is currently the first element of the list. So, new arrow next is a I am sorry new arrow next is assigned null. So, the value of new arrow next should be such to the current value of list. In fact, we will mistake here this should be list here and finally list is such to the 2 point to the new element to which new is a pointer. So, list is just assigned new. So, that inserts the element in the list after the element p. Let us now look at deletion from a list and again we assume that list points to the first element in the list and p is a pointer to the element the one after which the element after the one pointed to by p has to be deleted. So, again taking an example. If you want to delete this element then we will set p to this and if you want to delete the third element we will assume that p points to the second element. So, where assuming that p is pointing to the element the one after which has to be deleted. Now, again if p is null then we are assuming that the first item in the list should be deleted. So, because if p points the first element itself then the second element will get deleted. So, if p is null then what should be done is that list should point to the second element of the list to the second element of the existing list and the first element should be the first structure should be deallocated memory should be freed. So, now what we are doing is that we are using the variable q to point to the element which is being removed from the list so that we can free the memory being assigned to this element. So, q is such to list if p is null remember that if p is null let us say p is null. So, if p is null then the very first element of the list has to be deleted. So, q is made to point to the list. So, q will almost point to the element which is going to be deleted and list is assigned list arrow next. So, because the second element in the previous in the existing list not becomes the first element and list arrow next is a pointer to the second element. So, list is changed to point to the second element now this element is no longer in the list, but we still have a pointer to this in the variable q. Now, if p is not null that means we do not want to delete the very first element in the list. So, let us assume as an example that we want to delete the second element in the list. So, in this case if we want to delete the second element in the list, both list and p are pointing to the first element. Now, what should happen is essentially that this pointer should bypass this structure and point directly to the third element. So, first we set q to point to the element which is to be deleted and which will always be p arrow next because the element next to p has to be deleted. So, q is set to that and p arrow next is set to q arrow next. So, p arrow next is this box and the value of that will become q arrow next which is this pointer. So, essentially this pointer is removed and it points directly over here. So, this element has now been removed from the list, but again we have a pointer to this element in the form of q. And finally, once we have removed the element from the list, we must as I said free the memory allocated to the deleted item. So, to do that we use the library called free it does not return anything and the argument is simply a pointer to the chunk of memory which you want to delete. You must be very careful that the pointer that you supply must point to a chunk of memory which was dynamically allocated using amelok. You cannot for example, if you specify the address of some variable in the in the memory in the program then this will have very unpredictable results. And also once a chunk of memory has been freed now the pointer q to that chunk of memory must not be de-reference because it is now pointing to a chunk of memory which has been de-allocated. So, we will in the next example see the consequences of how that might erroneously happen and what might happen in that case. So, next what we are going to do is to try and free the entire list. We are writing a function free list which works a pointer to the first element in the list and free the entire list that is essentially it is going to traverse the list and each element in the list is going to be freed. So, memory assigned to each element in the list is being de-allocated. So, this is our first attempt at writing this function and as this dementia there is something wrong with this. So, what we do is traverse the list again using the same kind of a while loop while p is not null we free p and then assigned p to point to the next element in the list. Now, what is wrong with this code is that p is being de-recent where after it has been freed. So, each unquest memory has been freed. So, it is no longer a phase and now if we try to do a sense of pointer pointing to this remember that p erronext is exactly the same as star p dot next. So, we are do a sensing p which is pointing to a piece of memory which has been de-allocated and that will lead to unpredictable results. Let us see that more precisely through an example. Let us assume that p is pointing to the first element in this list 5, 7 and 3. Now, p is not null. So, the first time around the loop executes free p will essentially de-allocate this structure to which a pointer is being supplied as argument. So, this structure phases to exist in some sense. Now, you can see that p is pointing to a structure which no longer exists and such a pointer is called a dangling pointer and now when we try to find p erronext that will result in unpredictable behavior. That is because the value of p is what is known as a dangling pointer. It is not pointing to a valid region in the memory. So, this is the correct version. What we have to make sure essentially is that we do not dereference a pointer once we have freed the memory pointed to by that pointer. So, what we are doing is that we do p assign p erronext before doing the free, but if we do p assign p erronext then we have I will last the old value of p. So, what we do is to the old value of p in q and then use p q instead. So, that is exactly the same as before except that the dereferencing of a dangling pointer is not happening. Let us see how it is going to execute. So, let us again assume that p points to be first element in this place and now p is not null. So, the loop body executes q is assigned p then p is assigned p erronext. So, p points to the second element now free q happens. So, the first element gets de allocated. Now, p is still not null. So, we go back to the loop condition p is still not null. So, the loop body will execute once more q is again assigned p. So, q now points to the second element p is assigned p erronext and then free q. So, the second element gets de allocated and then p is still not null. So, we will execute the loop one more time q is assigned p p is assigned p erronext. P erronext in this case is null. So, p becomes null and free q results in this being last structure being de allocated and so the entire list has been free. Now, to summarize there are two common problems with dynamic memory allocation and you will find that unless you are careful you will easily make these mistakes and one has to be extra careful against these kind of mistakes. The first kind of problem results when we do not free a dynamically allocated chunk of memory even when we are finished using this. So, first a chunk of memory is called garbage appropriately because it is still in the memory it is it is still not freed. So, it cannot be reused but it is not useful either. So, this leads to what are known as memory leaks. Essentially, what happens is that a program keeps an allocating memory but it does not free memory then ultimately it might run out of memory and that is like you know having the memory leaked away. And the solution to this problem of course is to be careful and be allocate any memory chunk as soon as it uses over. The second problem that is just is the problem of dangling pointer that is the pointer that points to a chunk of memory that has been dealocated and as we saw de-referencing dangling pointer causes unpredictable behavior and the only way to avoid this is to make sure that dangling pointer is never de-referenced and you must always be careful not to that. So, that is the end of produced lecture and as a matter of fact this was the last lecture in the course. So, that is the end of the course as well and I hope that you found the course both useful as well as interesting. But before I take your leave I would like to remind you that programming is not something that you can learn by reading a book or by watching videos. The only way you can learn to program is to actually write programs and not just on paper but also try out things actually on a computer you will certainly make mistakes and it shows mistakes that of course that one learns from. So, write lot of programs have fun doing it and thank you for watching this series. Thank you.