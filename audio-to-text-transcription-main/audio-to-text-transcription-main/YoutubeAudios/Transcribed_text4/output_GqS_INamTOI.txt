 In the last lecture we have talked about input and output facilities in C and we had looked at the printers, canvels, get-sare, input-sare functions. Today we will start looking at another very important topic that is control statement. We are already familiar with control statements and we have been using them in most of the programs that we have written statements like the ifs and ifs and the world statements are known as control statements. Usually program execution starts with first statement and to see it sequentially downwards but in any but most simple program this is not sufficient and we want the controls go to take more complicated form. Usually for example we might want to do one thing or the other depending on some condition or we might want to repeatedly execute some block of code. For that we need what are known as control statements. We have as I said already seen these control statements in action and use them in all the programs that we have written so far but we will now in this lecture and in the next lecture look at some of these statements in more detail. So there are two basic control flow statements or the control flow structures which are the first one is for conditional execution which is either do this or do that. This is implemented using the if and the ifs condition statements that we have already seen and other useful kind of control structure is one of repeated execution wherein we want to keep doing certain action repeatedly till some condition is satisfied. So this lecture will look at the conditional and vacation structures in more detail in particular will look at the EFEFEL statements and the fifth statement which we have not used in program so far. So, let us look at the if statement first. The in the simplest form the if statement has the fintech shown here there is a condition and there is a statement following it and the meaning of this kind of a statement is that if the condition is true then the statement is executed. If the condition evaluates to fall then the statement is not executed. There are two important points about this particular concept. First is that the statement which is shown here must be a single C statement which means that it cannot be a sequence of several assignments for example. Now of course, in practice we would like this block of code to be executed condition is satisfied to consist of more than one statement but that is very easy which is because as we have already noticed in our earlier lectures is as of statements if they are in close and braces then that becomes a single compound statement. So, this statement has to be single statement but of course, it can be a compound statement meaning that if you put enough sequence of statements within braces since that must use a single compound statement we can use that here. So, the meaning of this statement is first evaluate the condition note that the condition may have side effects which you have already talked about and so those side effects will happen and finally, the result of the condition evaluates to true and remember that in C true is any value which is non-zero then the given statement is executed otherwise it is not executed. Here is a simple example to illustrate that side effects may take place during the condition evaluation. So, in this example X is initially 0 and Y is initially 1 and the statement is X plus plus then Y minus minus. Now, plus plus remember is the post increment operator and minus minus is the post decrement operator. So, when the condition which is in this case X plus is evaluated the result of the expression is 0 which is the old value of X and the new value of X becomes 1. So, since the result of the expression evaluation is 0 which is false in C therefore, the statement Y minus minus does not get executed which means that the end of the execution of the statement the value of X becomes 1 because of the side effects in the evaluation of the condition X plus and the value of Y remains 1 because Y minus minus does not get executed. So, let us take another somewhat more realistic example. Suppose you want to write a simple program that takes is input the marks obtained by some student in some exam order funded and output field is the marks are less than 40 is of course, a very very simple program. So, the usual things we declare variable marks and read the value of marks nothing that nothing strange here and here is the main part of the program is marks less than 40 then print a statement. Note that print a fail this is a single statement and therefore, we do not really need to put it in places to make it the body of the statement. So, when this program executes we read the value of marks and if the value of marks are less than 40 then this print a statement executes and frame is printed on the output. But if the marks are 40 or more then nothing happens no print statement is executed and therefore, there is no output from the program in that case. So, that is probably not what we wanted suppose we want to have our program written in such a session that it wants to express a fail depending on where the marks are 40 or above or not. So, print a if the marks are 40 or more or print frame is the marks are less than 40. So, in this case what we need is an if a statement which essentially says do this or that depending on the result of a condition. So, you only evaluate a condition in this case as a marks are more than 40 or more or not and if that is true then execute some statement otherwise execute some other statement. This is again a statement that we have already seen in practice in many programs that we have written earlier. So, here is the syntax. There is again a condition if and else are result words of keyword is condition statement 1 L statement 2, statement 1 and statement 2 again have to be single statement but of course, they can be compound statements or indeed as we will see they can themselves be control statements like statement 1 and statement 2 itself could be another statement. So, for this particular example the code looks very simple a marks less than 40 print S fail L print S half. So, suppose we also want to check whether the input marks given by the user are read between 0 and 100 and if not we should print invalid input remember we talked about program the first lesson in an earlier lecture and we should test all inputs to make sure that they have sensible values. So, you want to do this then what we need is a nested if a structure because the first thing we check is whether the marks are between 0 and 100. If not then we print invalid input otherwise we need to check whether the marks are less than 40 or not. So, say results the program might look like if marks are less than 0 or marks are greater than 100 then we print invalid input otherwise the code that we wrote earlier the entire thing if marks are less than 40 till the same L print S half. Note that this entire F L statement is a single C statement which we are using as the statement for the L part of the outer F L statement. Again since this is a single C statement we do not need to put traces around it so use it as the part of another EF statement. Also note that the indentation makes it very clear that this EF statement is within the L and this print S is within the S which is of course within the L. So, now let us take the example little further and make it little more complicated suppose you want to assign grade to students depending on their marks. So, if marks are less than 40 let us say you want to give the grade F if the marks are more than 40 but less than 50 grade D between 50 and 60 that is 50 or more but less than 60 then grade C 60 or more but less than 80 than the grade B and if 80 or more marks are obtained then you want to give the grade A. So, you might use a sequence of nested EF statement. So, if marks are less than 0 or marks are greater than 100 between invalid input otherwise now this entire thing is a single EF statement that is L part the L statement of this outer EF statement. So, this says if marks are less than 40 print the grade to be F L if marks are less than 50 then print the grade B L if the marks are less than 60 grade D, L marks if marks less than 80 grade B L the grade is A. Now, you can see that each successive EF statement is the L part of the outer EF statement. So, for example, this EF statement is part of the statement for the L part of this EF statement and similarly this EF statement is the L part of the outer one which is this one and similarly this EF statement is part of this entire thing and so, each of these is a single statement and therefore, we do not need basis any where also note that while education when we assign the grade D, we have said that the marks are less than 50 but we have not checked whether the marks are more than 40 or more or not. This is because we will execute this statement only if this condition marks less than 40 is false that because this is in the L part of the EF statement whose condition is marks less than 40 this means that if we are executing this particular EF L statement then the marks are guarantees to be 40 or more and of course, if we are executing any of these statements then we know that the marks are between 0 and 100 and similarly if we execute this EF statement that means that the marks must be 60 or more and so, if they are less than 60 then we do the grade C and so on so forth. So, that this has become little cumbersome because the nesting level of the EFs has become little deep. We have an EF statement within which we have a second one within which we have a third one within which we have a fourth one and within which we have a fifth one and correspondingly the indentation is becoming more and more. Now, this may make it both may the program both easier harder to write as well as harder to read. It has the indentation has become quite clumsy. However, you will find that in lectures such kind of nested EFs statements are quite common and they are called actually EFs letters. So, for these EFs letters we prefer an alternate indentation style which is more readable but of course, can be exactly the same thing. Let us see that in the next slide. So, this is the preferred indentation style for EFs letters where essentially what has happened is that the EF condition the EF statement which is the part of the previous EF statement is written in the same line the condition is written in the same line as the keyword else at all levels. So, what has happened with this indentation style is that regardless of what is the nesting level of the EFs is the indentation remains only at one level and also this indentation style makes it very clear for the reader to understand that exactly one of these statements will get executed that is either this statement will execute or this statement will execute or this statement will execute and so on and so forth. So, let us now consider a common problem associated with EFs statement and let us call the dangling else problem let us consider the following program if n is greater than 0 then within that if n is equal to 0, print f n is 0, else print f and is negative. So, the question I want to ask is what will be the output of this program segment for initial values of n equal to 5 and for n equal to minus 5. Now, the answer to that will depend upon whether this S is paired with this S or with this S. So, let us assume that it is the former that is this that this S is associated with this S as indeed this indentation style suggest because this S I have written at the same level as this S. So, the indentation style suggests that this S matches with this S. So, what happens is that is a K. So, suppose the value of n is 5 we check whether n is greater than 0 which it is. So, we execute this statement because the condition is evaluated to 2 to 2. So, therefore, we will execute the if part of the if element statement rather than the else part. So, this is the statement that we execute and this says if n is equal to 0, print f n is 0 now n is not equal to 0. So, therefore, this is not executed. But suppose this S what to be associated with this inner if what could happen in that case. Now, suppose again that the value of n was 5. So, when we execute when we evaluate this condition that of course, values to prove. So, we have to now execute the statement in the if part which is now this entire if L statement. So, now if n is 5 n equal to 0 value is to fall and therefore, the L part is print is executed which print n is negative that is for n equal to 5 what the program print is n is negative which is of course, probably not what we wanted. And similarly, we will see that for n is equal to minus 5 if this L is associated with this if then the result is not what we expect because if n is minus 5 then we first execute this n is greater than 0. It is not and there is no L for this if so, nothing happens. Whereas, if this L is x is associated then what happens is that if n is equal to 0 if n equal to if n greater than 0 value is to fall and since there is no L part transfer to that question will depend upon whether this L is considered by the compiler to be paired with this S or with this S. Let us consider first n is equal to 5 and let us assume that this S is paired with this S. So, if that happens what happens? If the condition n greater than 0 is evaluated which of course, evaluates to true and then this statement gets executed and since n is equal to n is not equal to 0 nothing is printed. But suppose on the other hand if this if happen to be associated with this then for the same value of n the result will be different. So, again the condition n greater than 0 will be evaluated which evaluates to true again and now since that in the case this entire if L statement which is within the if part will be executed. Now, this condition again evaluates to fall because n is not equal to 0 and what is what execute is this statement which brings on the that n is negative for n is equal to 5 and similarly for n is equal to minus 5 you will find if you trace a program that if this L is associated with the outer if then the output is n is negative whereas, if this L is paired with the inner if then there is no output at all. So, there is an ambiguity here because it is not clear whether this L is associated with the outer if or with the inner if as a example the C language defines that when such an ambiguity occurs or such dangling else is here in the program that is then it is always assumed to be paired with the inner most eligible if. So, in the example that is a soft regardless of how we invented this particular else will be assumed to be paired with the inner most if which is this one. So, which means that this program is probably not doing what we wanted to do because for great for positive values of n it actually prints n is negative and for negative values of n it just does not print a meeting. So, if this is not what we want as in this example what we can do is we should that we can use braces to tell the compiler what the correct pairing is. So, if this is the pairing we want that this L should be paired with the outer if and what we have done is that this is statement which does not have corresponding else we have enclosed in braces. And now the there is no longer that ambiguity of a dangling else because this L cannot possibly be associated with this F because this statement is entirely within this type of braces whereas, this else is outside the braces. So, not the program behaves as we accept it to behave. Okay we will not talk about the next important condition statement which is the switch statement and in many cases it allows us to write programs very elegantly we can of course do whatever the switch statement can do with if else and if else later as always but in many cases the switch statement makes a program much more elegant and similar to it. Essentially when we have an expression and for different values of the expression that are known in advance we want to perform different actions that is where the switch statement is useful. So, this is what the syntax for the switch statement is you have keyword switch followed by an expression in bracket followed by within curly braces the curly braces here are essential you have multiple cases. So, case value 1, case value 2, case value n and could be anything and then a default and for each case you could have a block. Now this block is a sequence of statements need not be a single statement and essential idea is what this statement captures is that if the values expression turns out to be equal to that of the if the values expression turns out to be equal to value 1 then we want the set of statements block 1 to be executed if it is equal to value 2 then we want the set of statements block 2 to be executed and so on and if the value this question does not match either of these n values then we want this default block to be executed. But there are some there are some faculties in this description that I just mentioned and we will look at them in a minute. But before that at the syntactic level this expression must be of an integer type and these values must be constant expressions. So, these cannot be for example things like x plus y where x or y or both are variables this has to be a value which can be evaluated at compile time and as I said each block need not be a single statement it can unlike the ifs and if statements it can be a sequence of statements and even if there are multiple statements in any block there are no braces needed around the block. So, let us see exactly what this statement does. First the expression that we gave is going to be evaluated and then it is going to be compared to value 1 remember of course, at the expression evaluation itself may result in some side effects which will of course, say immediate effect. So, first the result is compared to value 1 if it is true if it is indeed equal to value 1 then the set of statements in block 1 block 2 up to block n and followed with the statements in the default block they will all be executed in that sequence. Now that seems little unusual for that has its uses and we will look at them. If the value of the expression is not equal to value 1 then the result is compared to value 2 and if the result is equal to value 2 then block 2 block 3 etcetera are executed again up to block n and including then finally, the default block and solve this procedure if the result is not equal to value 2 either then it will be compared with value 3 and so on and finally, if the result matches none of the values value 1 to value n then the default block alone will get executed. So, essentially that means that if the value of the expression is equal to value 1 then block 1 block 2 up to block n and then the default block get executed if it is equal to value 2 then block 2 block 3 to block n and the default block is executed if value is equal to value n then block n and the default block are executed and if the value of the expression is not equal to any of these and only the default block is executed. But of course, usually in fact this one one is that we want usually only block i to be executed if the value of the expression matches value i. So, if you want that to happen then we need to put a break statement at the end of block i. So, in whenever a break statement is encountered in any block within the fish then the execution stops right there. Let us now see an example of the use of a fit statement and we will take the same example as before that of assigning grades depending on the mass. Let us assume that we have already checked that the mass are within 0 to 0 to 100 and we want to assign the grade and we do not do it using a fit statement instead of nested essences. Note that we cannot really give Boolean expressions here we can only give a fixed constant value for each case. Now, you want to do that and use the fit statement for the grading problem then one possibility is that we could have a case for every possible mass between 0 and 100 that is a case for case for mass equal to 0 case for mass equal to 1 case for mass equal to 2 and so on up to case for mass equal to 100 and that of course will make the program extremely unwieldy. But fortunately in this example you will recall that the grades are the grade changes at multiples of 10. So, the transition from the D grade to C grade happens at mass when the mass become more than 50 or 50. So, we can exploit that. So, if we divide the mass by 10 and then look at the various cases if we divide the mass by 10 then the resulting value can only be between 10 and 0. So, we can exploit that fact to reduce the number of cases. Now, if we recall that is the mass are 80 or more then we want to assign the A grade. So, the mass are 80 or more in the mass divided by 10 remember that mass is an integer variable and therefore, mass per 10 gives us only the quotient. So, if for example, the mass happen to be 87 then mass per 10 will be 8 and it will not be 8.7. So, in these three cases no one will assign the grade A because in these three cases the mass are at least 80 and up to 100. So, in this case 10 what we have done is we have not put any statement in the corresponding block. Similarly, in case 9 we have not put any statement in the corresponding block and in case 8 we assign the variable grade to A and then the break statement. So, what that means is that suppose the value of mass happen to be let us say 95. So, mass per 10 will evaluate to 9 which does not match 10 but it matches 9. So, the statements in the block corresponding to case 9 will execute it there is no statement over here and remember that there is no break statement over here either. So, which means that control falls through as it is called to the next case without really worrying about whether the value in the next case is equal to the value of expression or not. So, even if the value of mass per 10 is 9 this block corresponding to case 8 still gets executed because in the block for case 9 there is no break statement. So, which means that the value of grade becomes A and then there is a break statement which means that immediately after sending the value of grade to A the execution of the fifth statement finishes and the control comes to the next statement following the switch which prints the value of the grade and similarly if the mass score exactly 100 the candidate got a perfect score then the statements in the block corresponding to case 10 would be executed there are no statements here. So, nothing happen and there is no break statement. So, the control falls through automatically to the next case which is case 9 again there are no statements to be executed here. So, nothing happen and there is no break statement which means that the control falls through again to the next case. So, grade is assigned A and then if break happens which means switch statement finishes executing and similarly if the value of mass by 10 is 7 or 6 then we assign the grade B which means that from arc from 60 to 79 the grade B will be assigned if the value by 10 is 5 which means that mass are between 50 and 59 when the grade is C if the mass are between 40 and 40 when the grade is C and we do not have to have separate cases for 0 to 3 they can all be covered with the default case because if the value of mass by 10 is not 4 5 6 7 8 9 or 10 then it has to be 0 1 2 or 3 because as we said we are assuming that we already checked that the value of mass is at least 0 is at least 0 and at most 100. So, in the different case which means that the value of mass by 10 is anything other than 4 to 10 which in this case will mean that it has to be between 0 and 3 the grade is F and this break statement in the last block is not really required because there is no next block after this regardless of whether there is a break or not it is no difference will be there in the execution. But as a good programming it is a good idea to put a break statement even at the end of the last block because if later one adds some blocks then we might forget to add the break at that point in time. So, finally this is the end of the 6 statement and this 6 statement will hurt in assigning the grade A to F to the variable grade and this in the statement simply tends to fade. So, since the end of this lecture in the next lecture we will look at in more detail the statement the control statement 6 can be used to implement loops we have already seen the while loop in the programs that we have written we will see more kind of loop statement and certain other statements it can alter the behavior of control flow within a loop and so on so forth.