 In the last lecture we have talked about functions and we saw how the use of functions can help us manage the task of solving complex problems and developing large and complicated programs to solve these problems. Today we will discuss more about function, but before that we will start with the summary of what we had discussed last time. So, here is how a function can be defined. You start with the return type of the function which could be any of the types that we have seen so far. This is followed by the function name and then within brackets we have to specify what are the parameters for the function. For each parameter we have to specify the name of the parameter and the type of the parameter. The parameter type can be again any of the types that we have seen so far and then the entire function body is enclosed within braces and which follows just after the function header. Usually the definition of any function should proceed any call to a function in the program. So, this really means that if the function f calls the function g then usually it is better to place the definition of the function g before the definition of the function f. This is not always necessary and we will see later on why we may need to make exception to this rule, but at this point in time there is something we can always do. We also saw the return statement. The return statement has the purpose of specifying the value of the function execution or as it is called the return value of the function. So, along with the return keyword we also specify an expression and the value of the expression is what is returned to the calling function as the return value from the function and also recollect that when within a function the return statement is executing the execution of that function terminates immediately. Regardless of where the function body has been finished or not and control returns to the place where this function had been called from the calling function. So, here is how we make a function call that is how we use a function. So, we specify a function name the function that we want to call and then for each of the parameters we have to supply a corresponding argument. The arguments must of course be of the right type that is the argument one must be of the type that is expected for the parameter one that is declared for the parameter one and similarly argument two must be of the same type as parameter two and so on so forth. These arguments have to be expressions. They can be arbitrary expressions of the appropriate type and this entire piece of code is treated by the C language as an expression and this expression the type of this expression is the same as the return type of the function that we are calling. This means that this entire expression can be used wherever value or variable wherever value of the type which is the return type of the function is expected. For example, if the return type is integer then this entire expression can be used wherever an integer is expected. Of course, as you know you can also convert expressions into statements by putting a semicolon after them in which case the return the value of the expression is discarded. The same is true for these kinds of expressions also if you put a semicolon after such an expression then it becomes a statement and essentially the return value of the function is being ignored and the only effect that the function call has in that case is the side effects that the function can might have made. We have not really discussed side effects and functions will look at that in today's lecture. Then we talked about local variables in function a variable which is defined within the body of a function is said to be local to that particular function and we talked about the scope and lifetime informally of variables we will talk more about scope and lifetime by the scope of a variable we mean the portion of the program code where that variable is visible to people where it can be used. So, local variables are visible only within the function in which they are defined. So, that scope of local variable and by lifetime we mean for how long does the variable exist and the variable exist a local variable exist only while the function is executing. We will make these ideas more concrete with the help of some examples later on in the lecture and parameters are similar to local variables in scope and lifetime which means that a parameter exists like a local variable it is visible only within the function body is created when the function is called and is destroyed when the function returns. So, what happens during a function call is that the argument for the function are evaluated space is created for the parameters and local variables of the function which is being called now as we saw in the last lecture and then the parameters are initialized with the values of the corresponding expressions which are being passed as arguments and then the function starts executing when the function returns we control returns back to the place in the calling function where the function was called note that we saw last time that if in some case the argument to a function happens to be a variable and in the function body we happen to change the value of the corresponding parameter then this change has no effect on the value of the original variable in the calling function when that function returns. Let us now discuss the scope of variables little more formally. So, the scope of variable is defined as the portion of the program where references to that variable are permitted. So, as we have already seen the scope of local variables extend to the body of the function within which the variable is defined and the same is true for scope of parameter the scope of a parameter to a function f is also within the body of the function f. So, scope is a property of the program itself that is you can examine a program and demarcate portions of the code where a particular variable is in scope or is not in the scope and so on. So, we say that it is a static property of the program. The lifetime of a variable on the other hand is a dynamic property because it refers to the execution time of the program. So, by lifetime what we really mean is the time during which a particular variable exists so to speak. So, variables are created and they get destroyed. The time from the time when the variable was created to the time when it was destroyed is called the lifetime of the particular variable. For local variables in parameters as we discussed last time the lifetime is the time for which the function is active. Now, what do we really mean by a function being active we have not really discussed this in detail in the last lecture. Let us do that now with the help of a simple example. Consider this program. So, we have a function main with local variable x. The function main calls a function f with some argument which are not important for this example. Here is the definition of the function f it has a local variable y and it calls another function g and within g we have declared a local variable z. Now, let us see the execution of this program on a timeline and see what is happening and when are variables getting created and destroyed. So, this is our timeline. So, when the function starts executing as you know the main function gets automatically called and so when the main function gets called the variable x gets created. So, when at this point in time the function main has been called and the variable x has been created. Now, the function f is called from main. So, f is called and y is created. Note that when f is called the body of the function f starts executing and f is the currently executing function, but that does not mean that the main function is not active because the function f has been called from main and when main returns execution will go back to main. So, main is not finished yet it is still active. So, at this point in time the variable x still exists it has not been destroyed, but because of the limitations of this scope it cannot be accessed right now because from within f the variable x cannot be accessed. The scope of the variable x is only the body of the function main. So, within the function f the variable x cannot be accessed, but it still exists it has not yet been destroyed. So, when the function f calls g similarly the variable z gets created and again the function f and the function main are still active because when g returns the execution will go back to f and when f returns the execution will go back to main and so the variables x and y they still exist. Though of course, again they cannot be accessed from within the function g because of because the scope of these variables does not include the body of the function g. So, when finally g returns at that point in time the variable z gets destroyed. So, this is because the function g is finished it is no longer active and so the variable z is destroyed it does not exist. So, the lifetime of the variable z is this period during which the variable z existed. And similarly now the control has gone back to be function f and finally, the function f also returns and at that point in time y also gets destroyed. So, the lifetime of the variable y is the time from which f was called to the time when f returns when main returns and the program actually terminates and that time the variable x gets destroyed. So, the lifetime of the variable x is the entire time for which the program was executing because as long as the program is executing the function main is always active. Now, what are the implications of this kind of a lifetime? Let us try to understand that using another simple example. So, I have a program here in which the function main calls to function f twice once with the argument 1 and once with the argument 2 here is the body of the function f the parameter is called x and there is a local variable called y. So, what happens let in this function f what happens is that if the parameter has the value 1 then y is assigned 10 otherwise it is not assigned anything and then finally, the value of y is printed. So, now when f is called the first time it is called with the parameter with argument 1. So, the value of x is 1. So, y gets assigned 10 and the value 10 gets printed. The question is what happens when f is called again with argument 2. So, in the second execution of f is the variable y which is not assigned any value in the second execution because x would have the value 2 what value would it print. So, the answer really is that it is unpredictable. Let us see why that is unpredictable. So, let us again draw the timeline and see how this program executes. So, when main is called and then f is called and at that point in time x y are created is the first call to f then y is assigned the value 10 10 is printed then f return x and y are destroyed. Now, when f returns and control goes back to main f is called again and so x and y are created again. But, because they have been created again this means that this x and this y are not necessarily the same as this x and this y even though they are the same variable of the same function. On a timeline this x is not the same as this x and similarly this y is not the same as this y. So, now the y assigned 10 had assigned a value 10 to this y, but this variable has been destroyed and another variable which also happens to be called y has been created. There is no guarantee that the new variable y which has been created would be created at the same place where the old y also existed and therefore, there is no guarantee that this time the y variable y will retain its old value of 10. So, what that implies is that the second output of this program is unpredictable. The first output will always be 10 of course, because x is given the value 1 and y is assigned and then it is immediately printed. So, the first output will always be 10, but the second output is unpredictable. So, essentially the idea is that a local variable of a function does not retain its value across multiple calls to the same function. That is a point that we have to remember we cannot assume that the value that we assigned to a particular local variable of a function the variable will have the same value when the function is called again at some other place. Let us not talk about variable which are known as global variables and these variables differ in scope as well as in lifetime from the kind of variables that we have seen so far. The situation where you only use global variables is one where we have a large number of functions which all need to access the same variable. Now of course, one way of doing that is that you could pass the same variable as argument to all the functions. Now that of course, might make the program cumbersome because for these functions the number of arguments may be very large because the number of variables need to be accessed by a number of functions. So, in those cases what you might prefer to do is to make these variables global and making a variable global implies that the variable is accessible from all functions in the program and to make a function global what you need to do is to declare it outside any function that is the declaration of the variable is not within the body of the function of any function it is outside any function. And if you do that then the variable becomes automatically becomes global. Now in terms of scope the scope of a global variable is all functions or all hearts of the program which appear after the declaration that is in the program if we declare a global variable at a certain point then below that point in the entire program that variable is accessible everywhere. So, it differs in scope from local variables because as you already saw the scope of a local variable extends only to the body of the function within which the local variable is defined. And the global variable also differs from a local variable in the lifetime the lifetime of a global variable is the same as the lifetime of the program that is it is it gets created when the program begins execution and is destroyed only when the program really terminates. So, the essential idea of the global variables then is that it is a variable which can be accessed anywhere in the program because if you declare it right in the beginning of the program then it is accessible everywhere below it which means in the rest of the program. And remains in existence throughout the execution of the program that is regardless of which functions are called and which functions return and so on this variable always exists and has the same value as what was assigned to it mostly sent. So, therefore, this variable can be used pretty much anywhere in the program when when we take up a large example of using functions to solve a complicated problem we will see examples of global variables as well. But now with global variables there can be a problem of overlapping scope and what that means is the following that there will be two variables with the same name whose scope may be overlapping. So, let us consider this example. So, here we have declared a global variable x note that this variable is declared outside the body of any function and therefore, it is automatically a global variable and in this function f we have declared also a local variable whose name is also x. Now, the scope of this function of this variable x is the rare program starting from this declaration downward and this scope of this variable x is the function body which means this particular piece of the program code. So, now if you look at this portion of the program this x as well as this x are in the scope. So, the question is if we use the variable x within this part of the program that is within the function body of the function f which x are we referring to is it this x that we are referring to or is it this x that we are referring to. So, the rule for that is that if there are two variables both of which are in scope at a given point in time at a given point in the program then at that point in program if a reference to that variable is made these two variables have the same name and if at that point in the program if a reference that variable is made then the reference will always refer to the variable which has been declared innermost or in other words whose declaration is closest to the point of use. So, in this particular example here is the reference to x this is one candidate declaration and this is the other candidate declaration this declaration is closer to this use of x and so therefore, this reference to x really means this x and this is the node this x. So, essentially the inner declaration hides the outer declaration within the scope of the inner declaration. Let us now discuss functions in which we do not necessarily wish to return any value. So, in some cases we may not really bother about returning any value from the function. For example, we may only want to call a function for its side effects the side effect might be to modify some global variable or it might be for example, to print something on the screen. For example, suppose we want to write a function which prints a given character a given number of times using a simple for loop or something of that kind. Now, this function does not really have anything useful to return. So, this function would not have any return type and no return value would be returned from this function. So, in such a case what we could do is that we should declare the return type of such a function to be void and again we will see examples later on. Also note that within such a function the return statement is not really necessary because no return value has to be returned from the function and the function will automatically return when its body is finished that is the execution of the entire body is finished. Of course, we can still have a return statement within such a function also without any return value specified. So, the use of that would be that we want to return from the function prematurely or before the execution of its entire body is finished. We could do that by executing the return statement and in the function of this kind the return statement would simply be the return key world followed by the semicolon no return value would be specified. And similarly we might want to define sometimes functions which do not have any parameters and this might be required for example, if all the information that the function needs to access is available as global variables. So, in that case again the function would be declared as shown here all you have to say is that there are no parameters and so just put a void the key world void where the parameters are expected. So, let us end this lecture with a problem for you to think about will not solve this problem in this lecture will do that in the next lecture. So, here is the problem we want to write a program to find a path through a maze. So, we are given a maze and you must have seen puzzles of this kind in very in popular magazines. So, we are given a maze and we are given entry point through the maze and there is possibly another exit point in the maze and we want this program to find a path from the entry point to the exit point and in some case it is possible that there is no other exit point. So, in that case the path should bring us back to the entry point itself and which and we should get out from the entry point itself. But if there is another exit in the maze then the program should take us to that particular exit. So, the maze is given as an input by the user and the entry point is also given as an input by the user. So, let us assume that the maze is represented as a two dimensional grid of characters where a star represents a part of the wall and a blank space represents an open space through which movement is possible. The maze is rectangular in shape and at any from any position in the maze one can go in any of the four directions provided that one does not run into a wall. So, the entry point into the maze is also given by the user and the path should take one from the entry point to some exit other than the entry point and of course, if no other exit exists in the maze the path should bring one out of the maze through the entry point itself. So, here is an example maze for you to think about. So, this is a 5 cross 5 maze. So, there are 5 characters on the x axis and 5 on the y axis for ease of convenience we have labeled the two directions as x and y axis. So, these stars represent a walls in the maze and these blank spaces represent open path in the maze. So, let us assume that the entry point is one comma two in the familiar Cartesian coordinate system. So, which we which will mean that the entry point is x is one and y is two. So, and here is another exit from the maze. So, the path from the entry point should take us out of the maze through this particular exit point. So, the path will look like we start from one two which is this and we go to two two which is this. So, we move in this way then we go to two three this way then three three four three four four four five and then finally, we come out of the maze here which is four comma six. So, the algorithm for this problem is reasonably simple, but just think about this and you will find that even though the algorithm is simple when you actually try to implement this it becomes quite a bit complicated and one has to use several functions and so on. So, we will take up this example in detail and develop a program for this problem in the next lecture in the meanwhile please think about this problem.