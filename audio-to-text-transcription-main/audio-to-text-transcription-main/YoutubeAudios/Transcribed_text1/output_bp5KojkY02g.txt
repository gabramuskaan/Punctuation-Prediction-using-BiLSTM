 So, in this video we will talk about how pre increment, post increment and operators like that work in C. So, we will first introduce the notion of side effects. Now, we have earlier seen that any expression in C yields a certain value. So, let us look at a particular example, if you have integer variables i and j i is assigned to 1 and then you say that j is assigned to i plus 1. What happens is that you take the value of i add 1 to it and then resulting value is the result of the expression i plus 1. So, the result of the expression will be 2 which is assigned to j. The value of i itself is unchanged due to an expression like i plus 1. It is just that you read the value of a, use it and then return the value of i plus 1. Now, some expressions in C also change the variables involved in them. For example, if you have a code like int i, let us say i is initialized to 1 in j and then you say j equal to plus plus i. In this case, what happens is that you take the value of i, increment it. So, you will get i equal to 2 and then that incremented value is then assigned to j. So, evaluating the expression plus plus i has the side effect that i becomes 2. So, it not only takes the value of i increments it by 1 and gives it to j. It also has the additional effect that i's value is incremented. So, contrast the first example and the second example. In the first example, when you said i plus 1, the value of i was unchanged and in the second when you said plus plus i, the value of i is changed. So, this is known as a side effect because in addition to returning the value, it also changes the variable involved in plus plus i. So, now, let us look at this operation in slightly more detail. So, when you say in i equal to 1 in j and then j equal to plus plus i, the effect of this plus plus i can be understood in terms of an equivalent code. So, what you do is consider a code where you have i equal to i plus 1 and then assign j equal to i. So, in this case i will become 2 after i equal to i plus 1 and then j will be assigned the value 2. So, this is the effect of the pre-increment operation. So, pre-increment operation is calls. So, because before you use the value of i, you would increment the value of i. So, that is one way of understanding this and these two codes are equivalent in effect. There is a slightly different way of writing this, which is a short form for writing i equal to i plus 1. So, instead of doing this, you can say i plus equal to 1. So, plus equal to 1 says that says the effect i equal to i plus 1. So, it is a short form of writing it. So, all these codes are have equivalent effect. So, it is called plus plus i is called a pre-increment operator because before you use the value of i, it is values incremented. Now, there is also the post increment operator. So, plus plus i is an example of an X minus expression with the pre-increment operation and you can also use i plus plus, which is known as the post increment operation. And the confusing thing is how do we interpret fairly complicated expressions like the following. So, suppose you have int i equal to 1 in j and then j equal to i plus plus plus plus plus i. So, what should we expect in this case is this allowed behavior, what does it mean? What will be the result, which is stored in j. So, let us look at these things in slightly greater detail. So, first let us look at some simple examples and try to understand the behavior. So, suppose you have i equal to 1 and then 2 variables j and k and first you say int i in j equal to i plus plus. So, this is the post increment operator. So, what happens here is that you take the value of i, assign it to j. So, that is i equal to 1, the current value of i will be assigned to j and after the expression is over i will be incremented. So, then i will become 2, the old value of i is assigned to j and then the value of i will be incremented. So, it is the post increment operator. So, when you print f i and j here i will be 2 and j will be 1 because the old value of j, old value of i was what was stored in j. Now, let us look at plus plus i. So, if you say k equal to plus plus i, i is now 2 when it starts and you pre-increpan i. So, you increment i, i becomes 3 and that value is stored in k. So, it is the pre-increpan operator. So, the value will be incremented before the assignment will take place. So, when you print i and k, i will be 3 and k will also be 3. So, notice the difference between the first case and the second case, the pre-increpan versus the post increment. Now, let us look at slightly more complicated example. So, at this point what do we have? We have i equal to 3 and j equal to 1 at this point and then you say k equal to plus plus i plus j plus plus. So, take a minute and think about what will happen here. You pre-increment i. So, the value of this expression that is used to add will be 4 because the value of i will be incremented before it is used in the plus expression. Whereas, this is the post increment expression. So, the value of j, the old value of j will be used and then j will be incremented. So, here the value that will be used will be 4 and here the value that will be used will be the old value of j which is 1. So, k will be 4 plus 1 which is 5. I will be incremented. So, i becomes 4 and after this expression is over, j will be incremented. So, j becomes 2. So, when you print this, you will say that i is 4, j is 2 and k is 5. So, understand why k is 5 because it is 4 plus 1 rather than 4 plus 2. So, this is fairly simple can be understood in terms of the pre-increment and the post increment operator. So, let us look at some code that is equivalent to the post increment operation. So, suppose you have j equal to i plus plus, you can think of it like the following. You can say that j is assigned to i. So, the old value of i is assigned to j and then the value of i is incremented i equal to i plus 1. If you want to use the assignment compound assignment operation, then what you can do is j equal to i and i equal to i plus 1. So, this is equivalent to i plus equal to 1 is equivalent to i equal to i plus 1. So, contrast with the pre-increment operation, there i equal to i plus 1 will be done before j equal to i. Here, j equal to i will be done before i equal to i plus 1. So, can we see that this is exactly how post increment works and the answer is yes, in this particular case this is exactly how it works. But, if you want to understand the general case, we have to understand a slightly more advanced concept in C and note that this is not something that strictly falls into an introductory course. But, in case you want to understand exactly how it works, then we will look at the general case. So, the to understand the general case, instead of writing a few examples and compiling it and seeing, one way to do it would be to go to the C standard and say, what is the standard value? And here, it is slightly surprising. So, the result of the post fixed operator is the value of the operand. So, this is the old value of the operand will be written. After the result is obtained, the value of the operand is incremented. This is what we saw in the last slide. Now, when is the operand incremented? We loosely said last time that after the expression is over, then the value of i will be incremented. But, what is the precise point at which the value of i will be incremented? This is slightly surprising. So, the side effect of updating the stored value of the operand shall occur between the previous and the next sequence point. So, the when you have an i plus plus operation, it will not be immediately updated. It will be updated only after a place known as the sequence point. So, let us just understand briefly what is meant by a sequence point. So, before we get into it, let me emphasize. We are trying to understand. So, the post increment operation will say that the old value of i will be used and the value of i will be incremented after the expression. We are trying to precisely understand after what point can be say that i's value will have been incremented. So, a sequence point as defined in the standard is a point in the code by which all pending side effects are assured to be over. So, this is a very technical definition and it is to be understood by compiler writers. But, the we will briefly understand what does it mean. So, some prominent sequence points include end of a full declarator. So, for example, if I have a declaration in i equal to 0 comma j equal to 0, then a full declarator gets over after i equal to 0. So, after i equal to 0, there is a sequence point here. So, if there are any pending side effects, then it will be incremented at this point. This is another full declarator. So, it will after that again any pending side effects will be assured to be done. Then the surprising thing is suppose you have full expressions. So, suppose you have like i plus plus plus 3. So, the major thing to understand will be when is this i plus plus plus suppose to happen. Will it happen immediately after i plus plus and the thing is that the c standard does not say that that has to happen. The c standard says that the next sequence point is the semicolon. So, when you see the semicolon operation, you will know that this whole thing is what is known as a full expression j equal to i plus plus 3. So, that is known as a full expression. So, after you encounter a full expression, any pending side effects. So, this is a pending side effect that will be updated. So, only at that point c standard says that, now by now you should have updated the i plus plus operation. Before that the compiler is free to do what it wants. It may or may not update so, this is actually slightly confusing and contrary to the popular understanding of what should i plus plus when should i plus plus happen. So, again the general case is slightly confusing. It is not what you would expect. It just says that by the next sequence point in the code, all pending side effects should be taking place. Now, it does not say that exactly at the end of the sequence point, you will update all side effects. Compilers are free to do what it wants. All it says is that by the time you meet the next sequence point, pending side effects should take place in whatever order. So, this is slightly technical. Now, for a full list of course, you have to refer to the c standard which is not really recommended. But, it is just that if you want to understand it, then you can look at the standard. So, let us try to understand the post increment operation. So, again slightly greater detail. So, if you say that k equal to i plus plus plus j plus plus. Now, there are two ways to do it. Of course, k equal to i plus j, the old values of i and j are increment are used and then you calculate k, as I need to k. And then you can do i equal to i plus 1, j equal to j plus 1. Because, the standard says that by the time you see the full expression pending updates must be happening. So, you can say that by the time you see the semicolon operation, I will do i equal to i plus 1 and j equal to j plus 1. Now, if you think a minute, you could also do update j first and then i. So, I know that by the time you see the semicolon pending update should happen. But, in what order should it happen? Is it i equal to i plus 1 first and j equal to j plus 1 next or is it the other way around? And the answer is that the c standard does not say. So, it leaves it deliberately unspecified. So, that the compiler can do what it wants. So, here is the second subtlety in this whole business. So, if you say what is the order of side effects? There are certain operations where the sequence is specified. For example, the function called the and the logical and operator, the logical or operator, the conditional operator and the comma operator. So, for very specific operators, the sequence is specified. But, in all other operations, the order of evaluation of sub expressions is unspecified. And similarly, the order of side effects is also unspecified. So, in the previous slide, doing i equal to i plus 1 before j equal to j plus 1 is valid as also j equal to j plus 1 and i equal to i plus 1. So, these both these orders are valid and the c standard does not say that what should really happen. So, what in practice you will notice is that in one compiler, a certain order may happen in another compiler, certain other order may happen. So, it is left to the compiler and you cannot assume anything about what really happens, which order it happens. Further and here is the most important thing as far as these sequence points are concerned. The c standard says that an object or a variable can have its stored value modified at most ones by the evaluation of an expression between two sequence points. This is very important. So, between two sequence points, if a variable is to be updated by a side effect, then there should it should be updated at most ones. Beyond that, if it is updated multiple times, the c standard says that the result is actually unspecified. So, let us look at a few specific examples to see what is actually happening here. So, let us say that let us take the first expression j equal to i plus plus plus i plus plus. So, we know that here is a sequence point and we know that here is a sequence point. These are full expressions. Between these two sequence points, the value of i is updated more than once. Here is i plus plus i plus i plus plus and the c standard says that the behavior is unspecified. This is somewhat surprising because you may try it out multiple times and you will see that consistently some behavior is happening. But what the c standard says is that if you take the code and compile it with a different compiler, the result may be different. So, the result of this expression is actually unspecified. Similarly, let us look at the next example. So, here the sequence point is the full expression. Let us look at the next expression. So, i plus plus i plus plus i. So, post increment and then pre increment. Again, even in this case the result is unspecified because these two are the sequence points here. Between this full expression and between these full expression. So, you have two sequence points and between these two sequence points, the value of i is updated more than once. So, the result is unspecified according to the c standard. Let us look at this interesting example j equal to j plus plus. Again, result is unspecified because you can have these two sequence points and between these the value of j is updated twice. First, by the post increment operator and then by the assignment operator. So, the value of j is updated more than once the result is unspecified. The last expression is interesting. So, if you look at the two sequence points here, you have one full expression here another full expression here. Between these the value of i is updated only once here and the value of j is updated only once here. So, it is not that the value of i is updated more than once or the value of j is updated more than once. But here, it is a which of these sub expressions happen first. Is it i plus plus that happens first or i plus 1 that happens first. So, according to the c standard that is actually unspecified. So, the order of evaluation of the sub expressions is unspecified according to the c standard. So, let us just go back to that and this is what it says the order of evaluation of sub expressions is also unspecified. So, if you look at this expression j equal to i plus plus plus i plus 1 it is not clear which happens first i plus plus or is it i plus 1 that is also unspecified. So, here are the sequence points which ended full expression and the specific case of the last example it is not that values of variables are updated more than once it is just that the sub expressions may be evaluated in whatever order it may happen. So, all this is slightly confusing. So, let us just summarize something that you can take away for as far as programming is concerned. So, list out a few operations operators with side effects. So, let us say pre increment, post increment, pre decrement, post decrement all of these have side effects in addition to returning the value it also updates the variable. The assignment operator clearly has side effects. So, if you say j equal to i obviously the value of i will be assigned to j and we have earlier seen that as an operation it returns the value that was assigned. So, that has a side effect because it updates j and also returns a value which is the value of j. We have also seen this compound assignments. So, you can say i plus equal to 1 which is the same as i equal to i plus 1 and j minus equal to 2 which is the same as j equal to j minus 2. So, all these operators have side effects and the general advice is that use operators with side effects with extreme caution. In general if you use them make sure that a single full expression does not contain more than one sub expression with side effects. So, make sure that even if you want to use these expressions with side effects make sure that one full expression contains at most one side effect. So, avoid expressions like i equal to i plus plus as we have seen before this has two updates on i. So, the result is unspecified i equal to j equal to 1 well here is a full expression that is two side effects. Technically the result is you can predict what the result is but as a programming practice please avoid these kind of expressions because this is an expression that involves multiple updates and it is not really that the result is unspecified because the updates are on different variables but still as a good coding practice avoid such expressions. So, let us look at the third example you have x equal to y equal to 12 divided by y equal to 4. Again it is not clear which of the sub expressions y equal to 12 or y equal to 4 which will happen first. So, the result of this expression is very difficult to interpret. So, in general do not use full expressions that have more than one side effects even if they are on the single variable. If it is if it is multiple updates on a single variable then the c standard clearly says that the result is unspecified but even if they are on multiple variables try to avoid writing such expressions you can write always write slightly longer code where the meaning of the code will be perfectly clear and the result will be completely specified. Thank you.