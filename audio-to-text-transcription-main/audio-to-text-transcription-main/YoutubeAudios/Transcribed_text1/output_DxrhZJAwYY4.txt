 In this video we will look at a slightly more general way of defining problems through recursion. For the lack of a better name I will call it just two way recursion. These are problems which are solved by calling two subinstances. So, this is the picture of a family tree and we will see that the call stack for a two way recursive functions looks somewhat similar to a family tree. Let us revisit a problem that we have seen which is to find the maximum value in an integer array. We saw that the stack depth in our earlier solution was order n because each problem of size n called one sub problem of size n minus 1. Now can we reduce the depth of the stack from something close to n to something smaller than n. So, here is an alternate way to look at the problem which can be described in a very simple way. Instead of looking at the maximum of the first element and then the tail what I can do is take an array of size n and split it roughly into half. So, there is a left half and a right half each of size n over 2. Now imagine that you have the solution for the greatest element in the first half. Let us call that x and imagine that you have the greatest element of the right half let us call that y. Now whichever is greater m x and y is going to be the greatest in the whole array and this is the idea that we are going to implement right now. So, divide the array into about 2 equal half the first half is 0 to a n by 2 minus 1 this contains n by 2 elements and the second half is a n by 2 so on up to n minus 1 this the right half. Now recursively find the maximum element of each half and let us say that you have x which is the maximum in the left half and y which is the maximum in the right half then you just return the larger of x and y that should be the largest element of the array. While doing this we have to take care of the base cases this is as before for the linear case when n is 1 then the only element in the array is the maximum element. So, return a of 0 if n is 0 that is the array is empty you return minus infinity. So, let us consider a concrete array a is an integer array with these elements just to remind you the linear version was done as follows if n is 0 you return something like minus infinity a very large negative value. Now if n is 1 you return a of 0 which is the only element in the array otherwise you have at least 2 elements and earlier what we did was you call the sub problem a plus 1. So, the array which starts with the second element in the array and now the sub problem has n minus 1 elements because you are considering a 0 the first element as a separate thing. Now what you wanted to return was maximum of whatever was return in the sub problem. So, let that be some max well and whichever is greater a 0 and max well that is going to be the greatest element in the array. Now we saw that the stack depth for this problem was n because a size n problem is being reduced to a size n minus 1 problem. So, in each step we are reducing the size of the problem by 1 and increasing the stack depth by 1. So, in total that stack depth would be n because there will be about n calls or n minus 1 calls however you want to count. Now let us look at the 2 way recursive version. So, here is the algorithm that we discussed and let us just code this up. So, we will have int max array and then int a which is the array containing n elements and let us say that we have some constant minus infinity we have defined elsewhere in the program. Later we will see how to do this. Let us say that if n is equal to 0 you return minus infinity some large number some large negative value and if n is equal to 1 you return the only value in the array. So, these are the case cases as before. The changes here if you have at least 2 elements then you return maximum of the values return by the 2 sub problems what are the 2 sub problems. The first is the left half of the array which starts from a that is the first location in the array and contains n upon 2 elements. Then we need to compute the maximum of the right half how do we find the right half. So, we need to skip n upon 2 elements which went to the left half to get to the first index in the right half. So, we do that by saying a plus n upon 2 if a is the address of the first location of the whole array then a plus n upon 2 is going to be the first address of the first location of the right half and how many elements does the right half contain n upon 2 elements went to the left. Therefore, what we are left with is n minus n upon 2. So, notice how we call the left half starting from a and containing n upon 2 elements and the right half which is starting from a plus n upon 2 and containing n minus n upon 2 elements. Now, let us examine whether this is better than the previous recursive call where we reduced a problem of size n to a problem of size n upon 2. It was called linear recursion because we called one sub problem in order to solve the whole problem. Here we have we are roughly dividing it into halves and then calling 2 sub problems each of size about n upon 2. Now, surprisingly we will see that there is a huge improvement if you do this and this is one of the most elementary tricks in computer science it is called divide and conquer and here is a very simple example of that. So, if you look at the concrete array that we had and we call max array a comma 8 because this contains 8 elements. Now, we say that it will recursively call 2 sub problems which is maximum max array a comma 4. So, that will be the first four elements starting from a 0 and then max array a plus 4 comma 4 which are the four elements starting from a 4 which is the fifth element in the array. Now, let us just look at the stack. Now, notice what I have repeatedly mentioned which is that in order to think about a recursive problem you just think about the formulation of the problem and then what you have to convince yourself is if I solve the sub problems correctly then I will get the correct solution to the problem. So, I will divide my work into two sub problems. So, both of them will report their results back to me and now what I have to do is to figure out how do I put these two solutions together in order to solve the whole sub problem. So, think about it in terms of the design of the algorithm and not about the execution stack, but we will show why this is a major improvement over the linear recursion version of the same solution by looking at the stack. So, let us just look at the stack max array a comma 8 calls max array a comma 4. Now, the way function calls in C works you will go to the second half of this problem which is a plus 4 comma 4 only after max array a comma 4 is completely done. So, let us now see how max a comma 4 will execute. It has two sub problems again and let us look at the first sub problem which is max array a comma 2 that itself has a sub problem max array a comma 1 in order to abbreviate I will just put a dot there, but that dot is supposed to signify max array. Now, once you have solved this suppose this is a base case now it contains only one element. So, the only element is the maximum. So, it returns that value to max array a comma 2 that is one of the sub problems for max array a comma 2. So, now this max array a comma 2 calls the second sub problem that it has which is max array a plus 1 comma 1 again it is a base case it contains only one element that single element is the greatest element in that. So, you have two values now one coming from the left and one coming from the right and you just compare these two values and that will be the greatest value in the first two elements of the array. So, once you do this you return and when you return you get the value max array a comma 2. So, suppose all of that happens and then you return to max array a comma 4 at this point this function will call it second component which is max array a plus 2 comma 2 and the recursion continues so as soon as a function returns its stack will be erased I am showing that by dimming out that particular function call and this proceeds. So, once this values obtained you can return to max array a plus 2 comma 2 now this function is finished because it has called both its sub problems. So, this will return and this problem has return has finished with both its sub problems. So, you will after this function is done you eventually unwind all the way back up to the top and now you are ready to call the second sub problem of max array a comma 8 which is max array a plus 4 comma 4 and you do it similarly. Now, one thing you can notice here is that at any point the active path what what are active on the stack the functions which have not yet returned are the highlighted entries in the call tree. So, for example at the very end the call stack contains four functions before you eventually return and compute the last compute the maximum of the whole array the worst case depth of the stack is 4 and we had 8 elements. So, you would think that based on this experience that the depth of the stack is about n over 2 but if you think more carefully about it what happens is that at every sub problem at every level I am dividing the problem by 2. So, the depth of the stack is the maximum length path in this tree and at every step of the tree I am dividing the problem by 2. How many times do I have to divide n by 2 in order to reach 1 that will be the depth of the tree equivalently you can think about how many times do I have to double in order to reach n if I start from 1 that is the bottom of way. So, if I start from 1 and I double every level how many times do I have to double in order to reach n that is the solution to the equation 2 to the x equal to n. So, what I have to find is how many times do I have to double. So, how many times do I have to multiply 2 which itself in order to reach n and you will see that the solution is log n to the base 2. So, this is going to be the height of the call graph or the call tree. So, the stack depth here is about 1 plus log n that is approximately correct which is a huge improvement over n if you think of n as something like 1024 which is 2 to the 10 we are saying that the stack depth is about 10. Notice that in the linear case we would have a stack depth of about 1024 instead we are doing about 10. So, this is a huge improvement in the case of stack depth. So, with a very simple idea which is instead of solving once a problem of size n minus 1 what if you split it into 2 halves roughly about size n by 2 you will see that you get a huge improvement in the stack depth. This is one of the simple ideas that we repeatedly use in computer science. Now, there are standard arithmetic functions also which can be defined in terms of the 2 way recursion a very classic example is Paganaji numbers. So, for example, they are defined as f 0 equal to 1 f 1 equal to 1 and for n greater than or equal to 2 they are defined as f n equal to f n minus 1 plus f n minus 2. So, if we code this up it is a very simple function in 5 in 10 if n is 0 or n is 1 you return 1 otherwise you return Paganaji so, 5 of n minus 2 plus 5 of n minus 1. So, here is a very simple arithmetic sequence which is defined in terms of a 2 way recursion. So, this is a very simple way to write it, but it is a very inefficient way to do it. So, we will see why it is inefficient in a moment. If you just think of how you trace the function in the case of a letter of a concrete Fibranaji number let us say we want to calculate the fifth Fibranaji number. Now, that depends on 5 4 and 5 3, 5 4 depends on 5 3 and 5 2, 5 3 depends on 5 2 and 5 1 and so on. So, this is the call graph that you will have the call tree that you will have if you consider the calculation of Fibranaji 5. Now, what is a problem here you will see that many computations are unnecessarily done multiple times. So, if you look at Fibranaji 2 in the call graph it is evaluated multiple times. So, Fibranaji 2 is evaluated when Fibranaji 3 is called it is also called when Fibranaji 4 is called and Fibranaji 3 is called in a different context when you want to calculate Fibranaji 5 even there Fibranaji 2 is called. So, you will see that Fibranaji 3 is called 2 times Fibranaji 2 is called 3 times and Fibranaji 5 1 is called 5 times and so on. So, we are necessarily repeating the work and there are tricks in computer science to alleviate to remove this kind of unnecessary work, but that is strictly it is not an idea that strictly falls into the concept of recursion and it is slightly outside the scope of this course. So, we will not cover this in this course, but I just want to point out that even though it is natural to consider this arithmetic sequence in terms of 2 way recursion it may not be the most efficient way to do it.