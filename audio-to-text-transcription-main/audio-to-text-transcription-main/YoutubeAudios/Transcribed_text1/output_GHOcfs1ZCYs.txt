 In this lecture, we will see a slightly more advanced data type than a sinkley linked list. We will briefly go over one or two functions to manipulate the data structure. The principle of manipulating the data structure for the other operations is similar. So, in the case of a sinkley linked list, we have seen that every node has one link to its next neighbor. And we have seen this problem in a sinkley linked list that if you are at a current node in a linked list, you can always go forward, but there is no way to go back. There is one, the only way to get to its previous node is to start all over again from the beginning of the list and traverse until you reach a list, traverse until you reach the previous node. So, we can easily remedy this by thinking of a data structure, a slightly more involved data structure, where every node has two links. So, look at this node 2. So, it has two links, one is to its neighbor, successive neighbor. So, it is its next node. There is another link which goes back to its previous neighbor. So, in this data structure, there are two links per node. Therefore, it is known as a doubley linked list. And this list obviously, you can go from a current node, you can go forward or backward. So, easily. So, now the variation is this, if each node has three fields, one is a pointer to the previous node, the second is the data in the node and the third is the pointer to the next node. So, how will the definition look like? It will say something like struct DLL node, doubley linked list node, it will have one field which is data in data, let us say. And then two nodes struct DLL node next and struct DLL node previous. So, one to go to the next node and another to go to the previous node. Now, we will need two pointers typically for a doubley linked list. One is the pointer to the beginning of the list which is usually called the head and then another to the end of the list which is usually called the tail. So, I will use a type def in order to shorten the name, I will just say type def struct DLL node star node pointer. And then I will say that the list has two node pointers node pointer head and node pointer last. So, doubley linked list, each node in the doubley linked list has two list, one to its previous node and another to its next node. And the list itself has two pointers, one to the beginning of the list called the tail and another to the end of the list called the tail. So, now doubley linked list is another data structure, notice that we have seen two or three data structure so far arrays and one which see already provides. We have already seen simply linked list, now we have seen a third linked list, third data structure which is a doubley linked list. Now, a data structure has data and a bunch of operations defined on it. So, let us look at typical operations that can be defined on a doubley linked list and we will go over the implementation of two or three of them. So, node pointer head so this is a function that should return the head of the list. Similarly, node pointer tail this should return the tail of the list insert before. So, this is like the insert before node in the case of a singly linked list. So, here we are given a current node and we have to insert before a current node in the doubley linked list. Notice this was difficult in a singly linked list because there was no way to go from a current node to a previous node. We could always go to the next node. So, if I say that here is a node and insert before that node in a singly linked list it is difficult. You need some extra information but in a doubley linked list you have the current node and you can use the previous link in order to go before that. Insert after node also can be done this could also be done in a singly linked list. So, and then you can think of several other common like you can think of a make node you can think of a make list with a single with a single node pointer to by p new. You can make an empty list you can check whether a given list is empty. You can write functions to copy a doubley linked list to a new doubley linked list. You can concatenate two doubley linked list. You can do a deep concatenate we will see this in a future slide. You can append two linked list and so on. Similarly, we can have insert since we have insert functions we can also have delete functions you can delete a particular node. You can extract a node in the sense that so delete would take out a node and free the memory allocated to the node extract would just take out the node from the linked list but you retain the node. You can delete an entire list and so on. So, let us look at a couple of these functions other functions can be written in similar manner. So, suppose let us take insert before node this was a function that was not easy with the singly linked list. So, I am given a linked list L I am given a current node p C U R R and a new node to insert before the current node. So, what are the things to check if the list is empty then insert before the current node just means that you create a new node and return the new list. Now, if the head of the list is null then you just say that the now the new list contains only one node L head will point to new L tail will point to new. So, if the list itself was null then what you do is you create a new node now the new list contains only one element. So, the head will point to that and the tail will also point to that and you return that now you come to the non trivial case. Suppose there is a list and the list has some elements then so if p current is not equal to null then what you do is sorry if p current equal to null then you return the L this is an error if p current is not equal to null then what you do is the following. So, now you have to insert p new into the list so how do you do this. So, we say that the new nodes next will be so we are trying to insert p new will be so we are trying to insert p new before p current. So, the new nodes next will so the new nodes next will be p current p current previous will go to p new and so the p new next will go to p current and p current previous will go to p new. Similarly, we have to say that the previous node the node before p current it has to point to p new so p current previous that nodes next will go point to p new and then you return the new list. So, this can be done by looking at pointers and handling pointers carefully. So, now let us see how to delete a particular node in a list. So, if you have to delete the header of the list then if there is a list you just delete the header and you just free the entire list. Now, if you have to delete a particular node in the middle of a list what do you do? So, let us look at the various cases. So, in case one the node that you want to delete is the head of the list. So, in this case suppose you want to delete p what would you do you would make head point to the next element and free p. So, head will be made to point to p next. So, this is the line here L head will go to p next. Now, this guy previous will be set to null because we are going to delete this node. So, this guy previous will be set to null. So, now it does not point to anything and then you will free p. So, this is the first case where p the node to be deleted was the head of the list. Now, similarly if you want to delete the tail of the list. So, now what should you do here the tail should go to p previous. So, in case two when p is the end of the list that we want to delete then tail should go into p previous. Now, this guy next will now point to null because we are going to delete this node and finally, we will free p. So, L tail will go to p previous L tail next will be null and then finally, you will free p. So, we have seen two easy cases one is delete the head and the other is delete the tail and now we will see the difficult case where p is an intermediate node. So, in this case what we will do. So, we will we have to remove this node. So, p is the previous next node should be the next node of p previous. So, this link should point to the node after p. So, that is the first thing. So, we will make this node point to the node after p and this node previous should point to the node before p. So, we will reset the links. Now, if you look at the link this guy is next is the one after p this guy is previous is the one before p. So, now p can be safely removed. So, this is how you would delete a node in the intermediate list. So, if there is a next node then p next previous will be p previous that is this backward link and if there is a previous node then p previous next will be p next that is this forward node. And finally, after that you will free p. So, this is how you would delete a node from a link list from a doubly link list and other operations can be done in a similar manner and some of these operations will be asked in the exercise problem that you will be assigned. Similarly, you can think of an extract node the code will be exactly identical to before except at the end you will instead of freeing p you will return p you do not free the p node you will just return the p node. Now, let us look at one more example how do you attend append one node to the end of a list. So, first we will check that the node is pointing to a non-none node if it is pointing to a non-none there is nothing to be done. So, there is nothing to be appended so you return. Now, if the if the reason list then what you do is if there is no need list what you do is you make a list with only one node which is p. Now, if the reason you can in order to append a node at the end what you could do is call insert after node L L last p. So, append will be the same as insert the node p at the end of the list. So, you will say insert after L last what is the node to be inserted p. So, if you have an insert after node or an insert before node you can do this to implement other functions. So, this is a brief introduction to W linked list which are similar to sinkley linked list but facilitate forward as well as backward traveling from a current node using that you can implement more functions easier than a sinkley linked list. At the same time it has all the advantages of a sinkley linked list in the sense that if you want to insert a node it can be done using a constant number of operations if you want to delete a node it can be done in a constant number of operations. So, those advantages are similar to a sinkley linked list. At the same time the disadvantages are also similar to a sinkley linked list in the sense that if you want to search through even a sorted W linked list you have to search through all the elements.