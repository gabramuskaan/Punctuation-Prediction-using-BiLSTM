 In this lecture, let us look at one particular part of the CE compiler which is very important namely the pre processor. Technically speaking, the pre processor is the step before compilation. So, let us understand this in detail. We have used statements such as hash include within angular brackets, stda or dot h also hash include within codes list dot h and you may have seen C code which looks like this. You say hash defined pi to be 3.1416 hash defined max to be 9999 something like this. So, lines in a C program that start with a hash symbol are called macros and they are viewed and they are processed by the C pre processor. Now, the C pre processor implements what is known as a macro language part of C and it is used to transform C programs before they are compiled. So, C pre processor is the step just before compilation. We do not explicitly call the C pre processor, but when you write GCC some file name GCC the first step is the pre processor step. So, as part of the compilation first the C pre processor runs and then transforms the macros. The resulting file including the transform macros is compiled by the C compiler. So, let us look at header files. A header file is a file containing C declarations macro definitions etcetera to be shared between several source files. Head of files are included in your program using C pre processor directives hash include. For example, we have seen include within angular brackets stda or dot h and within codes list dot h. So, header files serve two purposes that we have seen. First is that it could be a system header files this declares interfaces to part of the operating system including system calls C libraries and so on or you could have your own header files which you have written to contain declarations of your code of the functions in your code. Now, what does what happens exactly when you include a header file in a C file including a header file produces the same results as copying the header file into each source file. So, when you say include stda or dot h it is essentially taking the contents of the stda or dot h file and copy pasting into your source code. So, this happens at exactly the place where the corresponding hash include command was written. The advantages of having this header file and hash include is that related declarations appear only in one place and if you want to change the if you want to change a particular function on a declaration of a function you just have to change it in a single file and all files which include that header file will automatically see the change. So, here is something that we have mentioned in the previous video if the difference between angular bracket and the double codes. So, the angular bracket is usually used in system header files and it searches for the file named let us say stda or dot h in a standard list of system directories. If you say within double codes on the other hand like list dot h it searches for this list dot h first in the current directory if it is not found in the current directory then it goes again into the standard list of directories. Now, the argument for hash include whether you include it in a angular bracket or in a double code behaves like a string constant and it is literally put there. So, if you have like commands the commands are not recognized as commands if you have a star symbol for example, it will be just put exactly like a star symbol. So, it is just treated as a string constant and no interpretation is done there. Now, let us look at very special case that could happen in the header file typically you would not do this. So, suppose you have within header dot h you have a text character star error equal to overflow typically you do not initialize variables in a header file but let us say that in a particular header dot h we have this character star error equal to overflow. Now, in p dot c I write this very peculiar thing I write in x and then in the middle of the code I say hash include header dot h till now we have always used hash include headers in the beginning of the file. But, suppose what happens if I do it in the middle. Now, after the c pre-processor processes the file what happens is that in whatever text is there in header dot h is copy pasted at that position. So, for example, this code will be transformed by the c pre-processor to look like this it will say in text and the header dot h contain the single line character star error equal to overflow. So, that text will come here. Now, this transform text is what the c pre c compiler sees and it will compile and produce the object code or the execute. So, included files are not limited to declarations and macro definitions these are merely the typical users you can put any text there and when you include that header file the text will be copy pasted into the position. Typically though you would want to avoid this you would want only declarations in header file. Now, let us look at some other features that the c pre-processor gives we have seen in some code this use of hash define. So, hash define is used for what are known as object like macros. Now, an object like macro is basically an identifier and it will be replaced by some code text. It is called object like because it looks like an object. So, it is most common use is to give symbolic names to numeric constants. Suppose you want to write a program in which the maximum array size is let us say 1024 instead of putting 1024 in several places. A typical usage in a program would be to say hash define buff size. So, buffer size to be 1024. So, you have used hash define to define this identify buff size and buff size will have will be assigned the text 1024. So, this says that I am defining a macro named be buff size and it is an abbreviation a short form for the token 1024. Now, if somewhere in your code if you say hash define buff size 1024 in all places after that the suppose you say like character star string equal to malloc or calloc buff size size of character. What the pre-processor will do will will be that it will look at this string constant. It is the name of a macro and it will replace it with 1024 which is the value of the macro. So, the transform text will look like this character star string equal to malloc or calloc 1024 size of care. Now, by convention macro names are written in upper case. So, that somebody who reads the code will be aware that this could be a macro because if I write it in lower case there are chances that somebody might think that it is a variable name and look for the variable. So, writing it in capital letters is a way of indicating to the user that this is actually a macro. So, please look it in a header file for example. So, the C pre-processor can through a program sequentially this is an important thing to understand and macro definitions take effect at the place you write them. So, let us look at a very specific example to illustrate this point. So, suppose you write Foo equal to capital X after that you have a line saying hash define X 4 and then bar equal to X. What will the C pre-processor do? It will look through the file and say Foo equal to X fine it does not know what X is it will not transform that line. Then it sees the hash define X 4 now it knows that X is a macro and it has the value 4 and then it says bar equal to X but now X is a macro the pre-processor knows about this. So, it will replace X with 4. So, the transform text will be Foo equal to X bar equal to 4 it is natural to imagine that I would have Foo equal to 4 but that is not what happens because the way the source code was written the hash defined happened after Foo equal to X. So, anything that happens before the macro was defined is not changed. Now, let us conclude this discussion of pre-processor with a very typical project management problem and we will see third macro that third operation that is done by the C pre-processor. This is something called hash if and this is used typically when you have multiple projects multiple files in your project and you need to include multiple header files into a single source file. So, let us discuss what is the problem with a particular example. Suppose we have a list.h and a list.c. So, I have this header file list.h. Now, I have a program p 1.c that needs the list functions and also creates a bunch of new functions. So, its declarations will be included in p 1.h. Now, in p 1.h I would say include list noth. So, this is I will have a corresponding p 1.c which will just say include p 1.h. Now, suppose that I have another file p 2.c. The p 2.c needs some functions in list noth and some functions in p 1.h. So, now there when I write p 2.h I will say include p 1.h and include list noth. Now, what happens is that when we compile p 2.c list noth gets included twice first because it directly includes list noth and second because it includes p 1.h which itself includes list noth. So, list noth code will be copy based at twice in p 2.h. So, for example, this is a problem because if list noth contains a structure definition it will be included twice and the compiler will produce an error. So, this is a standard problem in large projects where you want to include a file, but you do not want to include it multiple times. So, in this particular example I want to include list noth, but I want to avoid the possibility that list noth is included multiple times leading to compiler errors. So, how do we solve this? So, this is a facility provided by the C pre-processor. You can say you can use this hash if n if. So, it is saying that if this macro is not defined then do something. So, in list noth I will write the following, hash if and if this is a macro that I will define. So, usually if a file is list noth, the macro will be named in capital letters list under storage. If this macro is not defined then hash define list noth. So, this says define list noth for me and then all the remaining statements in list noth and then it will be enclosed in an n if. So, now what happens is that suppose list noth is included for the first time in p 1 noth then list noth is not defined. So, it will define list noth and then include list noth in p 1 noth. Now p 2 noth includes p 1 noth and list noth. So, now when list noth is included for the second time the C pre-processor will look at this statement if and if list noth list under storage that has been defined because p 2 p 1 noth has already defined it, cost it to be defined. So, it says that list noth is defined. So, I will skip the entire thing until n if. So, this is one way to say that. So, if list list underscore h macro is not defined as yet then define it and process all statements until the matching n if it is already defined this happens when you are trying to include it for the second time then all statements until the n if are skipped. So, you do not copy paste it for the second time. So, this is a standard way to avoid including one file multiple times. So, the high level picture of the stages in compilation you have retaken. So, the high level picture of the stages in compilation you have source files and then it is run through the pre-processor. It produces the transform files and then after compilation using gcc minus c it produces object files and after the object files are done they are linked to produce the executable files. So, when you press gcc some source file internally it first runs the c pre-processor. Then it runs the compiler and then it runs the linker and gcc provides facilities to stop the compilation at any stage. So, for example, we have seen in the previous video that you can stop the compilation just after the compilation itself by using gcc minus c. So, it will produce dot o files and several dot o files can be later linked to produce the a dot o file.