 In this lecture, we will see some more pointer arithmetic operators and we will introduce those by talking about them through a problem. So, the problem that I have is that of reversing an array. So, we have to write a function to reverse an array and let us say that the declaration of the function is void reverse array int a int n. Now, if you have to reverse an array, what is one way to do it? You take the array, copy it into another array and then copy back in the reverse fashion. So, you have an array a, copy all the values into p and now you copy those values back to a in the following way that the b's last value will go to a of 0, b's second last value will go to a of 1 and so on. Now, let us try to do it slightly more cleverly. We want to take an integer array and reverse the array in place that means that essentially using no extra space. So, do not use an extra array in order to reverse it, reverse it within a itself. So, the array before calling reverse array will look like a 0 up to a and minus 1 in this way and after calling reverse array it should look like a and minus 1 a and minus 2 etcetera up to a 0 and in doing that we should not use an extra array. So, how do we do this? Let us look at bunch of con couple of concrete examples to see how do how do we do it by hand and then we will try to code that algorithm. So, in this there are two cases. So, for example what happens when you have an even length array when you have let us say 6 elements, then a 0 and a 5 have to be exchange a 5 goes to a 0 a 5 goes to the 0th location a 0 goes to the 6th location or the 5th location and then a 1 and a 4 have to be exchanged a 2 and a 3 have to be exchanged after this you should stop right that will correctly reverse the array. Now, what happens if the case of in the case of an odd length array. So, suppose you have an array b which has only 5 elements in that case to reverse the array you have to exchange b 0 and b 4 b 1 and b 3 and you can stop there because there is no need to exchange b 2 with itself right. So, the case of an odd length array you will end up with an element which does not need to be touched in the case of an even length array you have to exchange until you reach the middle of the array. Let us try to code this up. So, how is the reverse array written first I need so remember how we did this by hand we exchange the 0th location with the last location then we exchange the first location with the second last location and so on. So, it is easy to code if you have 2 pointers initially 1 pointer starts to at the beginning of the array the second pointer is to the last of the array exchange those values then the first pointer goes to the next location and the second pointer goes to the previous location that is how we did it by hand. So, let us try to code that up I will have a pointer b which points to the last element of the array a plus n minus 1. Now, the loop is as follows I will discuss this in a minute while b is greater than a. So, remember in the example by hand we had to exchange till we reach the middle of the array. Now, how do we find the middle of the array I will just write it as b greater than a and I will explain it in a minute. So, while this is true that you have not yet reached the middle of the array you exchange swap a and b here we use the swap function which we have seen in the previous lecture. So, for example, it will swap the 0th element with the n minus first element after that is done you increment a and you decrement b. So, the design logic is that a initially points to the first element of the array the left end of the array and b points to the right end of the array. In general while the algorithm happens then a is moving forward and b is moving backward. Inside the loop you exchange star a with star b that is what is accomplished by calling swap of a and b because swap a and b will dereference those locations and exchange the values there. So, do this repeatedly until a and b cross over because when a is moving forward and b is moving backward then the middle of the array is the point where a and b cross over or the point where a and b mean. So, this is the very simple logic for reversing an array. Now, I have left one thing unexplained what do I mean by b greater than a b and a are pointers. So, what do I mean by pointer b is greater than pointer a we need to explain that we are introducing an operation an operator on two pointers what does it mean. So, we are seeing a new concept which is relational comparison between two pointers. If a and b are pointers to variables of the same type like in star a and in star b we can compare them compare these pointers using equal to and not equal to this can be done for arbitrary locations a and b as long as those locations are of the same type. So, a equal to b is true if and only if a and b are pointing to the same location that is natural to expect otherwise if they are pointing to different locations a not equal to b is true. Now, there is another case if a is pointing to an integer let us say and b is pointing to a float then equal to and not equal to are undefined. So, notice that even though this behavior looks natural it is natural only if they are pointing to the same type. So, here are operations equal to and not equal to what about less than or equal to greater than greater than or equal to and so on and this is surprising because here is something that you do not expect you cannot compare less than or equal to on arbitrary locations in the memory. We can compare a and b using less than for this they must be pointing to the same locations in the array. Earlier when we discussed plus and minus we were saying that plus and minus are well behaved only when you are navigating within an array. Similarly, when we are comparing two pointers using greater than or equal to less than or equal to then they should all be point then a and b should be pointing to the same array different locations in the same. If that is true then a is less than b if the value is pointing to a location which is before b in the same array. Similarly, a less than or equal to b is true if a is pointing to a location which is b or before b and so on. So, for example we can see that if we have an array in a 10 then a plus 1 is less than plus 2 that is clearly true because a plus 1 is pointing to the location 1 in the array and a plus 2 is pointing to location 2 in the array. So, if you have an array for example, let us say a 0 through a 9 and p t r a is pointing to location 1 and p t r b is pointing to location 3 then p t r a is less than p t r b here the comparison is well defined and it is true. But on the other hand let us say that p t r a is pointing to a of 1 and p t r b is pointing to b of 1 in this case p t r a less than p t r b is undefined because they are pointing to two different arrays. So, maybe memory a is laid out before b and so on but that is not what the less than or equal to operation is supposed to do it is supposed to compare pointers only within the same array. So, with this understanding let us understand how the reverse array works. So, in the first iteration you have an array a let us say that the array is 101 21 and so on it has 6 locations and we will run through the trace of the execution for an even length array and I would encourage you to create an odd length array and trace through the executions to ensure that the code works for odd length arrays as well. So, in this lecture we will do it for even length array. So, a is initially pointing to the beginning of the array b is pointing to the end of the array a plus n minus 1 will go to the end of the array. Now, b is greater than a that is true. So, we will enter the loop and in the first iteration we will swap a and b. So, it will go to the swap function and this is the swap function that actually works from the previous video. So, you can assume that a 0 will be swapped with a 1 a is so they were initially 101 and 0 and after swap they will be 0 and 101. Now, once that happens a advances by 1 integer location b goes back by 1 integer location. So, this is the state after the first iteration. In the second iteration you start with a at 21 and b at minus 101 again b is greater than a so is swap. So, 21 minus 101 becomes minus 101 and 21. So, they are swapped and you advance a by 1 and you take back b by 1 again b is greater than a so you go to the third iteration. In the third iteration this is the state at the beginning of the iteration and you swap these contents. So, you swap minus 1 and 1 21 it becomes this becomes the state of the array and once that is done b overshoots so b goes before a and a goes after b. So, I denoted that with two colored arrows. So, here is the b arrow it goes to location 121 and the a arrow goes to location minus 1. When this happens b is now less than a so this means that you have crossed the middle of the array therefore, you should stop now. So, now b is less than a and the loop terminates and we have seen that this correctly reverse the array. So, here is how the reverse array works we have seen the concept of relational comparison operators using pointers how they make sense when they are pointing to locations within the same array and how that can be used to write code using arrays.