 Once we know structures and pointers to structures, we can introduce some very important data structure called a linked list. So, we will first see what linked lists are, how to operate on them and then argue why linked lists are useful. So, let us just introduce this notion called self referential structures. So, we are defining a struct node that has two fields, one is an int data and the next field is the surprising one, it is a pointer to type struct node. So, this data structure, this C structure is called a self referential structure because internally there is a pointer to an object of the same type. So, in that sense it refers to some other object of the same type. So, it is called self referential. So, an example would be like this where the data field has 10 and the next field points to something else which should be a struct node. So, then field next is of type struct node. Now, there is a subtle point to be emphasized, instead of struct node star had I written struct node next, then this is not allowed because the definition of struct node has an internal struct node inside it. So, it essentially has infinite size. So, we are cleverly avoiding that by including just a pointer to the next node. So, using this structure we can define what is known as a sinkley linked list. So, an example of a sinkley linked list structure would be where we have a pointer which we will call the head of the list. Head points to the first struct which is 4, which has data 4 and it is linked to another struct which has data 2, that is linked to another struct which has data 1 and so on. The last struct in the list will be linked to null. So, there is only one link from each node hence the name sinkley linked list. So, the fact that the next field is null indicates that that is the last node in a linked list and a linked list is always identified by its head which is the pointer to the first node in the linked list. Once we reach the first node we can travel the list by using just the next links. So, once we have a link to 4 we can always say 4, 2, 1, minus 2 and so on. So, the list is made modeled by a variable called the head that points to the first node in the list and if the head is null then that means the list is empty and then you have a bunch of nodes and once we reach a node with the next field null then that is the last node in the linked list. Now, let us look at certain simple operations on sinkley linked list. Suppose you want to insert a node at the front of the list. So, we have a list 4 to 1 minus 2 and we want to insert something else in the beginning. So, what you do is you create a new node of type struct node and set its data field to whatever number that you want to store. Now, add it to the front of the list and we will see how this can be done. So, suppose that the head is now pointing to 4 and the list is 4 to 1 minus 2 and you want to add a new node. So, 2 is the node the data field is 2. Now, how do you add? You do 2 operations. First you say that 2 is next is the first node in the old list. So, that would insert 2 here and then now the list has changed. The list has changed because the first element is now 2. So, head moves to 2. Head was previously 4 and head now moves to 2. So, this is abstractly how you would insert a node at the beginning of a list. So, now let us try to code it and see. So, first we need a code small function to make a node with the given data. So, we will say struct node star make node in 12. Now, we will create a pointer struct node star temp then use one of the malloc function called call log. So, one size of struct node. So, this will allocate memory enough to create one node. Now, this that memory its data field will be set to val which is what we are given as argument to the function and then you return the node. So, we have created a node and how do you insert in the front? Once you have once you receive an value to be inserted at the beginning of a list. So, the list is identified by the head. So, we have to create a node which contains the value and insert it at the beginning of this list. So, what we do is we first create a node with the value using make node function. Now, temp next is set to head. So, this link is activated. So, 2's next will be 4. So, that is the first step. The second step is that the head now has to move to 2 because the first element in the new list is 2 not 4. So, I will just say head equal to temp and return head which is the head of the new list. Now, you can call this function multiple times. Suppose, you want to start with an empty list and insert minus 2 then insert minus 1 then insert 2 then insert 4 then insert 2. You can call these functions one after the other. So, I can just say struck node head equal to insert front 2 of insert front 4 of insert front 2 of 1 of minus 2. So, this is the function this is the sequence of functions and this is the list that you will end up with. So, once you have the function to insert at the beginning of a list you can use that function multiple times to build up the list. Now, let us look at some useful functions to be done on linked list. So, once you have a linked list it will be good if you can search the linked list to see whether an element is present or not. So, we will look at a very simple algorithm. So, we want to search for a particular key that is an element in a singly linked list. So, how do you do it? abstractly what you do is you start with the head see whether the data field in the head node is the key that you want. If it is then you are done and you say that I have found it if it is not what you do is you go to the next node through the next link and then search is it the data field of the next node if it is you are done if it is not you search and follow the next node. You follow this procedure until you reach the last node suppose you have not found the key even in the last node and you follow the next link and it is null. So, once you reach null then you know that you have reached the end of the list. So, you cannot take null next that will cause your code to crash. So, once you know that your node is null you can search you can end the search and then say that the key is not present in the list. Here is a flow chart corresponding to that you start with current equal to head. Now, is current null if the current is null then that means you have reached the end of the list and you have not found the key. So, if the current is not null then there is data still to be searched. So, you see whether current data is equal to key if it is yes then you have found the key otherwise you follow the next node link to go to the next node in the linked list and again repeat the procedure. And you can code this in a straightforward manner. So, I will write slot node star search. I need the head of the list and I need the key you start with current equal to head if current is not equal to null and current data is not equal to key you follow the next link current equal to current next and you repeat the procedure. So, when you exit the list either current will be null or current data will be key. So, what is the condition when you reach the the return. So, if the key is absent then you are returning null if the key is present you are returning the pointer to the node to the pointer to the first node that contains the key. So, convince yourself that the code works. Now, let us look at slightly more involved operations we have seen insert at the head of the list and that was fairly simple. Now, suppose you want to insert into the middle of the list you do not want to insert at the right at the front you want to insert somewhere in the middle. Now, there are two cases here if the list is null that is the easy case if the list is null then insert in the in the middle is essentially insert at the front. So, we already have seen the code for that. Now, the if the list is not null now it is a new algorithm. So, let us look at an example. So, suppose the list is 4 to 1 minus 2 and I want to insert a node 5 after node 2. So, how do I do it? Two's next link was 1 and what we need to do in this case is I want to say that I have to insert this node 5. 5's next node will be 1 that is. So, think about this as a link in a chain. So, you need to disconnect this link say that 2 is now connected to 5 and 5 is then connected to 1. Now, the only thing to be noted is that the links have to be detached in a particular sequence. So, first I need to say that 5's next is 1 and then I need to say that 2's next is 5. So, convince yourself that the opposite sequence where I say that 2's next is 5. Now, your code will has no way to proceed because you have lost the how to traverse from 2 to 1. If you say that 2's next is 5 then 5 has no way to know what was the original next node of 2. So, you have to do it in a particular sequence 5's next is 1 and then 2's next is 5. We will see this code in a minute. So, what we do is we want to insert an insert after a node. So, p current is the node after which we have to insert and p new is the is pointing to the new node that we have to insert. If p current is null then essentially the list is basically p new. This is the case that we have seen before. If p current is not null that means the list is not empty then what you do is the new nodes next node is p current's next node. So, 5's next node is the old 2's next node which is 1. So, 5 next will be said to 1 and after that I will say p current next equal to p new. Then I will say that p current which is 2's next will be said to 5. So, convince yourself that if I swap these 2 lines, if I swap the lines order then the code will not work. So, see this for 5 minutes and you convince yourself that that will not work. So, let us just see how this works. So, initially let us say that I want to insert after 2 and new is the new node. So, initial state is something like this. The 5's next node is pointing to something, maybe some arbitrary location. Now, after line 2 that is p new next equal to p current next, this is the state of pointers. Please look very carefully. So, 5's next will point to 1 and at this point 2's next is also pointing to 1. So, there are 2 nodes whose next is 1 which is fine because we have not completely inserted 5 into the list. Now, at this point I will just detach 2's next and make it 0.25. So, there you go. So, after step 3 you have essentially inserted 5 into the list. Now, let us look at some syntactic conveniences that C provides you. So, repetitively are tripping struck node and things like that is it is just too much to type and C allows you to define short names for types. So, if I want to say like struck node star I want to use the name list node. So, I will just say struck instead of struck node star head I will just say list node head. So, it is a shorter way to do it. So, how do I write this? This is using what is known as a type death keyword in C. So, if I say type death struck node star list node what it means is that list node is another name for the long type struck node star. So, this is something that you may use if you want to it is not something that is that you should use, but it is just convenient. So, if I say list node head this is the same as saying struck node star head comma current. Now, let us see why linked lists are important. So, first of all it is one of the first non trivial data structures that you learn. In the earlier days when C had only fixed size arrays, linked list was important when you needed variable size storage. Now, days C has variable size storage. So, you can in arrays. So, that is not so important anymore, but here is one important thing one difference between linked list and arrays which are very important like insertion and deletion in linked list are fairly cheap. In the case of an array. So, if you want to insert an element at position k in an array, you have to copy all elements from k to n minus 1 to the last element in the array, move each of them backwards make space for it and then insert the kth array. So, this involves in the worst case it involves moving all the elements of the array by one element one position each. Similarly, for deletes, suppose you want to delete an element from an array, then what you have to do is you have to take the remaining elements of the array and move them one position to the left. So, this will involve moving n elements in the array if array has n elements in the worst case. Whereas, note that in the linked list case to insert or delete any element a new node whether at the beginning or at the or in between it just takes one operation. The other elements need not be manipulated. So, let us just quickly see how to delete a particular node in a linked list. So, we will just say that 4 to 1 minus 2 is the linked list and I want to delete this particular node is that possible. So, I cannot straight forward delete this node because the previous nodes next element should point to this guy's next element. So, if I want to delete one what do I have to do? I have to say that 2's next node should be minus 2. But in a linked list there is no way to go back from one you cannot easily get to 2. So, this is slightly so, deletion requires slightly some more information. So, if I can delete a node if I also have a handle a pointer to its previous node then it is very easy to say that 2's next node will be minus 2. And that is what we will do. So, we will say that let us have a delete function. P node is the node that I want to delete and P P node is its previous node and what I will do is if there is a previous node I will say previous nodes next is the current nodes next. So, 2's next link will go to minus 2. If there is no previous node then I will say that T equal to the current nodes next and then once that is done you delete the current node P node. So, this is how you would delete an element from the linked list. So, just recap searching in a linked list will take order n time in the case of a linked list that is you have to search all the elements in the worst case which is the same in an array. Now, suppose you saw an array you have faster search techniques available you can do binary search in an array. Unfortunately in a linked list even if you saw the linked list there is no way to do a binary search in the linked list. Why is this because you cannot reach the middle element of the linked list in one shot. In an array you can just say a mid and it will go to the so suppose you say that mid equal to 0 plus n minus 1 by 2 you can go to the middle element of the array. But there is no way to do that in a linked list you have to go one after the other. So, sorting does not help in searching when you are looking at single linked list. But on the other hand insertion and deletion are very quick in a linked list whereas, they are very slow in an array.