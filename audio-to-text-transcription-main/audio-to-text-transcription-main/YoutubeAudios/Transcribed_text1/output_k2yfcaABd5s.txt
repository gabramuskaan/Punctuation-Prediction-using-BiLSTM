 Since, pointer arithmetic is a tricky concept, let us solve one more problem to try to get comfortable with that notion. So, the problem here is copying a sub array into another array. Now, let us explain what that means. Suppose, I have written a function copy array, which has three arguments, an array, an integer array a, an integer array b, and n, which is the size, I want to copy n successive index elements from a and put it into b. So, a 0 through a n minus 1 have to be copied to b. I can easily write it in the following function as int copy array int a int b int n. And then, I have one variable to keep track of the index and that variable goes from 0 to n i for i equal to 0 i less than n i equal to i plus 1. And then, I simply say b i equal to a i within the loop. So, this would copy whatever a i is into the location b i. So, once the loop executes, I would have copied n elements from the array a to the array b. But, this is not general and I want to solve the following problem. So, I have two arrays, let us name them from and two. And I want to copy n numbers from the array from 2 to 2. But, I have an additional requirement, I want to copy n elements from index i. So, the earlier code solve the problem from index 0. In general, I want to copy from index i of from n elements into the location starting at index j into. So, the earlier function assume that i and j were both 0. In the general function, I want arbitrary i and arbitrary j. So, I need a declaration like the following, I have int copy array 2. So, this is the second function I am writing. And I have from i to j and then n is the number of elements to copy. So, what I have to do is from i from i plus 1, so on up to from i plus n minus 1, have to be copied to 2 of j, 2 of j plus 1, so on up to 2 of j plus n minus 1. So, the for the purposes of this lecture, let us just assume that from and 2 are big enough. So, that you will never overshoot the arrays by taking i plus n minus 1 and j plus n minus 1. Can you write this function? Now, obviously, you can write a separate function to solve this. Now, the trick is can you use the copy array function, the copy array functions copied n elements starting from index 0 of a to index n minus 1 to the array b starting at index b of 0 to b of n minus 1. So, that is what it did. And this should be strange because if you think about it in a mathematical way, you are saying that a general function is being solved in terms of a particular function. So, you are reducing a general case to a special case that sounds a bit strange, but we can do this with pointer arithmetic. So, let us try to solve it using our own function. And here is the guess that I am making and then I will justify that this works. So, I will just say here is my function from i to j n that will be defined as copy array from plus i 2 plus j comma m. So, copy array will start from a of 0 and copy n elements afterwards to b of 0. So, on a point, we will have to b of n minus 1 and that function I am calling using the address from plus i 2 plus j and n, n is the number of elements I want to copy. Now, I will justify that this works. So, here is the problem that I have and I want t of j equal to f of i, t of j equal to f of i, t of j plus 1 equal to f of i plus 1, so on up to t of j plus n minus 1 equal to f of i plus n minus 1. So, let us try to see what happens in this function. Suppose, I call copy array 2 from main using the arrays f t i j n n and that function merely calls the old copy array function using f plus i t plus j n n. So, the state of execution at the start of copy array 2, let us say that f is an array with say 10 elements and t is an array with say 10 elements arbitrary. And what I want is, this is the function of the array. I also assume that i is 2 and j is 4. So, I want to copy 5 elements starting from the second location or the third location in f of 2 onwards to the fifth location in t onwards. So, here is what I want to, so I want to copy this minus 1 minus 1 minus 1 to t of 4 onwards. So, I will copy them here, so 5 elements are to be copied. Let see how function is able to do this. So, t plus 4 is this location f plus 2 is this 4 is this location f plus 2 is this location. So, what I am calling is the old copy array function with f plus i. So, f is the address of the first location of the array. Therefore, f plus 2 using pointer arithmetic is the second integer box after that. So, it is pointing to f of 2. Similarly, t plus 4 t plus j in this case is pointing to the fourth location after the location pointed to by t. t is an array. So, t points to the first location in the array. Therefore, t plus 4 will point to the fifth location in the array. So, when I say f plus 2 f plus 2 is a pointer to here and t plus 4 is a pointer to here. And I am calling copy array function with these as the arguments and n is the number of elements I want to copy. So, here is the state just before I call copy array function. Now, for example, this particular box has several names. The most common name for it will be f of 3. But I can also write it as star of f plus 3. This says jump 3 integer boxes after f and then dereference that address. Now, if you are comfortable with the notion that let us say f of i is the same as star of f plus i. If you are comfortable with that notion then it should be easy to see that f plus 2 of 1 is just star of f plus 2 plus 1. It is the same formula that I am using and this happens to be f plus 3 which happens to be f of 3. So, star of f plus 3 would be f of 3 and so on. So, this formula that f of i is the same as dereferencing the address f plus i. f of i is star of f plus i is applicable even for more strange looking expressions. Now, if you are comfortable with here is a trivia about C that because of the way it is defined. So, if you say that f of i is the same as star of f plus i then you could think that this is the same as star of i plus f. So, I can write this as i of f. So, this is the same formula that I have written. Never do this but it will actually work. So, f of i you can also write it as i of f for example, 3 of f and it will also work because internally C translates into star of f plus i and we know that star of f plus i is the same as star of i plus f. So, never do this but this helps you to understand that f of i is being translated into this format. So, now that we know this similarly you can argue about star of t plus 4 and t plus 4 of 0 and so on all of them refer to the same box. Now, let us see what happens when we call copy array. So, we have the stack space for copy array 2 and copy array 2 calls copy array. The formal parameters are A and B, A copies the address that it was past 2. It was past the address f plus i. So, A points to f plus 2. Similarly, B points to t plus 4. So, t B points to this. Now, as far as copy array is concerned it is not too bothered by the fact that it was not past the absolute first address of the array. It will think that whatever address it has been past is the start of an array and it will work from there. So, copy array does not bother the fact that I was given the second element of the array rather than the first element of the array and so on. It will work as though the array started from there and here is where we are exploiting that fact. So, now copy n elements from this location to this location, this array. So, n is 5. Now, when you execute that you will have copy array 2 should copy 5 elements starting from here to 5 locations here. So, that is what it will actually do and when you execute the loop it will start from this location copy to t plus j then f plus i plus 1 will be copied to t plus j plus 1 and so on. So, it will copy these 5 locations to here in the t array. And after you do this copy array returns and every variable that was allocated to copy array is erased but then because of pointers it was actually working with the arrays in copy array 2. So, even when you erase all the memory allocated to copy array once you return these arrays would have been changed. These 5 locations starting from f plus 2 have been copied to these 5 locations starting from t plus 4. So, changes made to be by copy array is still maintained after you return to the calling function copy array 2.