 In this video we will discuss a slightly advanced usage of pointers, even though the title of the first slide is how to return pointers from a function that is just a motivation for introducing a slightly more advanced topic in pointers. So let us just see what is the problem with returning a pointer from a function. You know that any variable can be passed as argument to a function, can be declared as a local variable within a function and can also be returned from a function. So is there something and we have already seen that in the case of the swap function, how we pass pointers to a function and what new kinds of functions does this enable us to write. So in this slide in this lecture let us talk about what will happen when we return pointers from a function. I have written a very silly function here, you do not need a function to do this, but this illustrates a point. I have a main function in which I have an integer pointer p and I will make it point to the return value of increment 1. And the increment function what it does is it takes an argument, it increments the value, it makes a pointer and points to the incremented value and returns that pointer. We will see a pictorial representation in a minute. Now this leads to a very notorious error in C known as a dangling pointer. Let us examine that in slightly greater detail. What happens when we call the increment function? By the main function we have an int pointer p and when it is declared it is not pointing to anything and immediately you will call increment 1. So you call increment 1, n is a local variable in increment, it is the argument so n is 1 and then you declare a temp and then you declare pointer to temp. So there is a ptr, let us say that temp is at address hexadecimal 1000, so ptr contains 1000 and it points to temp, temp is at address 1000. Now in the next statement you increment temp, you set temp to n plus 1, so n is 1 and temp is 2. Now ptr points to temp and now I will return ptr, so the return value is 1000 which is the address of temp. Now what happens when you return to mean? As soon as increment finishes and we have said this several times before, as soon as any function finishes the memory that is allocated to the function is erased. So when you return to the main function what happens is that you have p and p will contain the address 1000, so it is meant to point to temp but the space meant for temp has already been erased, so p is pointing to a junk value in memory, it is pointing to an arbitrary location memory, so this is known as a dangling pointer, hopefully the picture is representative of a dangling pointer, the fact that it points to a location which is no longer meaningful. Notice that what I am talking about is the ideal situation, when you run the, when you code it in c and try to run it may be p does point to the location with address 2, this is because c may not be aggressive in reclaiming the memory but you should always assume that the safe thing is to assume every location that was allocated to increment is erased immediately after increment returns. In practice it may not be the case but you should never assume that you still have the temp variable, in general what you will have is a dangling pointer because p points to a location which no longer contains any relevant information, so when you print p you will have a danger, so how do you return pointers from a function, so we have seen what a dangling pointer means and here is a very silly function which will create a dangling pointer. Now what is the problem with this function, it returns the address of a local variable temp but temp is erased as soon as increment end returns, so the return value is not a meaningful address to the calling function which is mean, can we get around this, so the main problem here is that anything that is allocated to the called function on the stack is erased as soon as it returns, is there any way at all to meaningful erase, so the return pointers to new variables, we will use a new concept that of a globally accessible memory called heap, we have already seen a stack, now we will understand what a heap is. So, I will roughly the idea is that if we allocate value on the global memory it is not erased when the function returns. I will explain this with a help of a slightly broad analogy, hopefully this is indicative of what actually happens with a heap, so think of executing a function as writing on a classroom blackboard when a lecture is going on, once the function finishes execution this is like the class is over, everything on the blackboard is erased, suppose you want to retain a message after the class is over. Now, the solution could be that you can post things on a notice board which is global to all classrooms, so it is common to all classrooms, so things on the notice board are not removed as soon as a class is over, if you write something on the blackboard which is similar to storing something on the stack, as soon as the class is over it will be erased. So, if you have something to communicate back to another class may maybe you can post it on a notice board, now the notice board is globally accessible to all classrooms, the blackboard is like a stack and the global notice board is like a heap and contents on the heap is not erased when a function finishes, so how do you allocate things on the heap? There is a standard library function called malloc in the file SDD lib dot h which can be used to allocate space on the heap, roughly this is what it does, if you ask for malloc n where n is a positive integer, it will allocate n bytes of memory on the heap and it will return a pointer to that to the first location of the allocated space, now that pointer can be converted to pointer of any type malloc just allocates n bytes, now you may want to interpret those bytes as n divided by 4 integers, in that case it will return a pointer, so you convert that pointer to an int pointer, let see an example I may have an int pointer ptr and now I want to allocate 10 integers on the heap, how do I do that? I will allocate 10 star size of int, so this will allocate on some particular machine let us say 40 bytes and it will return an address of the first location, now that address I want to treat it as an integer address, so I will convert it to an int as int star and then malloc 10 star size of int, so this style of writing code makes the code portable, because suppose you write the code and you on a machine where integer was 4 bytes and you take your code and go to a bigger machine which has 8 bytes as the size of an integer, then you compile the code on that machine and your code will still allocate 10 integers, why? Because on the new machine size of int will be used automatically 8, so it will allocate 8 bytes, so in order to write portable code you can use size of int instead of assuming that integer is 4 bytes, so I want to allocate malloc 10 star size of int, this will allocate 10 integers no matter which machine you do it on, so and it will return you the address of the first byte in that allocated space, that address you convert to an integer at integer pointer, here is how you allocate memory on the heap, so when you think pictorially think of heap as a separate space in the memory, in this case ptr will be allocated some space on the heap, let us say 10 integers, so it will on some particular machine it will say 40 bytes and it will ptr will return the address of the first byte, now that first byte you treat it as a pointer to int that is done through the conversion in star, now it is nice that you can allocate space on the heap, but in order to be hygienic you should also remove the allocated space once you are done with it, there should be a reverse operation to allocate and that is free, it is in the same library stdlib dot h and if I just say free ptr and ptr was originally allocated using malloc then it will correctly remove however many bytes was originally were originally allocated, so let us say that I have instar ptr and then ptr I allocate 10 integers on the heap and ptr is an is the address of the first allocated location, now I may do a bunch of processing here and once I am done it is just nice of me to be allocate things on the heap, this is like saying that things on the notice board once some condition occurs where you know that that notice is no longer needed, you just remove that posting from the notice board, for that you use free of ptr. Now notice the asymmetry here malloc took the number of bytes to be allocated free just wanted to say which pointer is to be freed, it does not ask for how many bytes to free, so you can imagine that malloc does some kind of bookkeeping where it says that I allocated 40 bytes and that was returned to ptr, so if I just say free ptr it automatically knows that 40 bytes are to be freed, you do not have to give the extra argument saying how many bytes to free, once you free the pointer you just set it back to null, this is just a safe practice and it is not absolutely necessary but it is recommended. So let us solve our earlier problem using malloc, our earlier problem was that ptr was pointing to some location within the stack, so as soon as the function returned the return address no longer meant any meaningful address, so let us now solve this problem, I have included STD lib dot h because I will allocate memory on the heap, so the increment function is modified as follows, strictly speaking I do not need attempt variable anymore, I have an int pointer and I will use the pointer to allocate one integer on the heap, this is a really wasteful practice but it just illustrates a point, so it will allocate one integer on the heap and then return that address and treat that address as an in star, now I will use star ptr equal to n plus 1 to dereference that location on the heap and increment the and set the value to n plus 1, once I am done I will return the ptr, I will return the address on the heap, the difference here is that the return address is on the heap and only the stack is erased, so things on the heap are not erased unless you explicitly ask it to be erased wire free, so returning a heap address and so p will point to a meaningful location on the heap, when you print it you will get 2 and once you are done you can say free p, so here is a strange use which you have not seen before, something was done the malloc was done in the increment function and the free is being done in the main function, now if you think back to the physical analogy it is not really surprising, somebody can post something on the notice board and a different person can remove it, what happens here is that the increment function ptr points to some location on the heap using malloc, so one integer is allocated on the heap and when you start ptr equal to n plus once then the location in the heap will contain 2 and here is the catch, earlier p was just a dangling it was just pointing to an arbitrary location in the memory, but increment allocated something on the heap and return that address, as soon as increment returns the stack is erased, so everything that was allocated on the stack for increment is erased, but things that are allocated on the heap remain, so p points to a meaningful address on the heap, then once you are done you can say free p and things will be erased, when you print it the output will be 2, malloc and free are prone to a lot of errors and a lot of programming errors in C can be traced back to incorrect use of malloc and free, so there are some categories of errors, for example you may forget to malloc in the first place, so you will need to dangling references or dangling pointers as we saw in the first example, now you could allocate some space, but you may not allocate enough space that is a very common error, commonly you could allocate off by one errors, I wanted to allocate really n plus 1 number of bytes, but instead I allocated only n number of bytes, another very common error is something known as a memory leak, which is that you allocate things on the heap, but you forget to free memory after use, this is called a memory leak, notice that if you allocate space on the stack it will always be cleaned up as soon as the function returns, so memory leaks usually happen when you malloc space on the heap, but you forget to free them once you are done and a lot of software ships with memory leaks and this is a major concern in the industry, there is also an obscure error which is freeing the same memory more than once, this is uncommon when a single programmer is working on a code, but when multiple programmers are working on the same piece of code, you may end up freeing the same memory twice, this will lead to some runtime errors.