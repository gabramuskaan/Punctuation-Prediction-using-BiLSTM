 In this lecture, let us look at one particular part of the CE compiler which is very important namely the pre processor. Technically speaking, the pre processor is the step before compilation. So, let us understand this in detail. We have used statement such as hash include within angular brackets STDA or dot H, also hash include within codes list dot H. And you may have seen CE code which looks like this. You say hash defined pi to be 3.1416 hash defined max to be 9999 something like this. So, lines in a CE program that start with a hash symbol are called macros and they are viewed and they are processed by the CE pre processor. Now, the CE pre processor implements what is known as a macro language part of CE and it is used to transform CE programs before they are compiled. So, CE pre processor is the step just before compilation. We do not explicitly call the CE pre processor, but when you write GCC some file name GCC the first step is the pre processor step. So, as part of the compilation first the CE pre processor runs and then transforms the macros. The resulting file including the transform macros is compiled by the CE compiler. So, let us look at header files. The header file is a file containing CE declarations macro definitions etcetera to be shared between several source files. Header files are included in your program using CE pre processor directives hash include. For example, we have seen include within angular brackets STDA dot H and within codes list dot H. So, header files serve two purposes that we have seen. First is that it could be a system header files this declares interfaces to part of the operating system including system calls CE libraries and so on or you could have your own header files which you have written to contain declarations of your code of the functions in your code. Now, what does what happens exactly when you include a header file in a CE file? Including a header file produces the same results as copying the header file into each source file. So, when you say include STDA or dot H it is essentially taking the contents of the STDA dot H file and copy pasting into your source code. So, this happens at exactly the place where the corresponding hash include command was written. The advantages of having this header file and hash include is that related declarations appear only in one place and if you want to change the if you want to change a particular function on a declaration of a function you just have to change it in a single file and all files which include that header file will automatically see the change. So, here is something that we have mentioned in the previous video if the difference between angular bracket and the double codes. So, the angular bracket is usually used in system header files and it searches for the file named let us say STDA dot H in a standard list of system directories. If you say within double codes on the other hand like list dot H it searches for this list dot H first in the current directory if it is not found in the current directly then it goes again into the standard list of directories. Now, the argument for hash include whether you include it in a angular bracket or in a double code behaves like a string constant and it is literally put there. So, if you have like comments the comments are not recognized as comments if you have a star symbol for example, it will be just put exactly like a star symbol. So, it is just treated as a string constant and no interpretation is done there. Now, let us look at very special case that could happen in the header file typically you would not do this. So, suppose you have within header dot H you have a you have a text character star error equal to overflow typically you do not initialize variables in a header file, but let us say that in a particular header dot H we have this character star error equal to overflow. Now, in p dot C I write this very peculiar thing I write int x and then in the middle of the code I say hash include header dot H till now we have always used hash include headers in the beginning of the file, but suppose what happens if I do it in the middle. Now, after the C pre-process process is the file what happens is that whatever text is there in header dot H is copy pasted at that position. So, for example, this code will be transformed by the C pre-processor to look like this it will say int x and the header dot H contain the single line character star error equal to overflow. So, that text will come here. Now, this transform text is what the C pre-C compiler sees and it will compile in produce the object code or the execute. So, included files are not limited to declarations and macro definitions these are merely the typical users you can put any text there and when you include that header file the text will be copy pasted into the position. Typically, though you would want to avoid this you would want only declarations in a header file. Now, let us look at some other features that the C pre-processor gives we have seen in some code this use of hash define. So, hash define is used for what are known as object like macros. Now, an object like macro is basically an identifier and it will be replaced by some code text it is called object like because it looks like an object. So, it is most common use is to give symbolic names to numeric constants. Suppose you want to write a program in which the maximum array size is let us say 1024. Instead of putting 1024 in several places, a typical usage in a program would be to say hash define buff size. So, buffer size to be 1024. So, you have used hash define to define as identify buff size and buff size will will be assigned the text 1024. So, this says that I am defining a macro named be above size and it is an abbreviation a short form for the token 1024. Now, if somewhere in your code if you say hash define buff size 1024 in all places after that the suppose you say like character star string equal to malocharcaloch buff size size of character what the preprocessor will do will will be that it will look at this string constant. It is the name of a macro and it will replace it with 1024 which is the value of the macro. So, the transform text will look like this character star string equal to malocharcaloch 1024 size of character. Now, by convention macro names are written in upper case. So, that somebody who reads the code will be aware that this could be a macro because if I write it in lower case there are chances that somebody might think that it is a variable name and look for the variable. So, writing it in capital letters is a way of indicating to the user that this is actually a macro. So, please look at in a header file for example. So, the C preprocessor can through a program sequentially this is an important thing to understand and macro definitions take effect at the place you write them. So, let us look at a very specific example to illustrate this point. So, suppose you write Foo equal to capital X after that you have a line saying hash define X4 and then bar equal to X. What will the C preprocessor do? It will look through the file and say Foo equal to X fine it does not know what X is it will not transform that line then it sees the hash define X4. Now, it knows that X is a macro and it has the value 4 and then it says bar equal to X but now X is a macro the preprocessor knows about this. So, it will replace X with 4. So, the transform text will be Foo equal to X bar equal to 4. It is natural to imagine that I would have Foo equal to 4. But that is not what happens because the way the source code was written the hash defined happened after Foo equal to X. So, anything that happens before the macro was defined is not changed. Now, let us conclude this discussion of preprocessor with a very typical project management problem and we will see third macro that third operation that is done by the C preprocessor. This is something called hash if and this is used typically when you have multiple projects multiple files in your project and you need to include multiple header files into a single source file. So, let us discuss what is the problem with a particular example. Suppose we have a list.h and a list.c. So, I have this header file list.h. Now, I have a program p1.c that needs the list functions and also creates a bunch of new functions. So, its declarations will be included in p1.h. Now, in p1.h I would say include list.h. So, this is I will have a corresponding p1.c which will just say include p1.h. Now, suppose that I have another file p2.c. Now, p2.c needs some functions in list.h and some functions in p1.h. So, now there when I write p2.h I will say include p1.h and include list.h. Now, what happens is that when we compile p2.c list.h gets included twice. First because it directly includes list.h and second because it includes p1.h which itself includes list.h. So, list.h code will be copy-pasted twice in p2.h. So, for example, this is a problem because if list.h contains a structure definition, it will be included twice and the compiler will produce an error. So, this is a standard problem in large projects where you want to include a file, but you do not want to include it multiple times. So, in this particular example, I want to include list.h, but I want to avoid the possibility that list.h is included multiple times leading to compiler errors. So, how do we solve this? So, this is a facility provided by the C pre-processor. You can say you can use this hash if n if. So, it is saying that if this macro is not defined, then do something. So, in list.h, I will write the following. hash if and if this is a macro that I will define. So, usually if a file is list.h, the macro will be named in capital letters list underscore.h. If this macro is not defined, then hash define list.h. So, this says define list.h for me and then all the remaining statements in list.h. And then it will be enclosed in an n if. So, now what happens is that, suppose list.h is included for the first time in p1.h, then list.h is not defined. So, it will define list.h and then include list.h in p1.h. Now p2.h includes p1.h and list.h. So, now when list.h is included for the second time, the C pre-processor will look at this statement if and if list.h, list underscore.h. That has been defined because p1.h has already defined it. Cost it to be defined. So, it says that list.h. is defined. So, I will skip the entire thing until n if. So, this is one way to say that. So, if list.h list underscore.h macro is not defined as yet, then define it and process all statements until the matching end if it is already defined. This happens when you are trying to include it for the second time, then all statements until the n if are skipped. So, you do not copy paste it for the second time. So, this is a standard way to avoid including one file multiple times. So, the high level picture of the stages in compilation, you have retaken. So, the high level picture of the stages in compilation, you have source files and then it is run through the pre-processor, it produces the transformed files. And then after compilation using gcc minus c, it produces object files and after the object files are done, they are linked to produce the executable files. So, when you press gcc some source file internally, it first runs the c pre-processor, then it runs the compiler and then it runs the linker. And gcc provides facilities to stop the compilation at any stage. So, for example, we have seen in the previous video that you can stop the compilation just after the compilation itself by using gcc minus c. So, it will produce dot o files and several dot o files can be later linked to produce the a dot o file.