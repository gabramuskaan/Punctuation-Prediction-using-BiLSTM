 Let us see a few more examples of expression evaluation in C. What kind of expressions are allowed, what kind of errors do people usually make and so on. Let us say that we have given an expression A equal to 1 B equal to 1 C equal to 2 and then we have an expression A less than B and then B greater than or equal to C. So, this is the expression that we want to see how it will be evaluated. So, let us just go through it systematically. The operations on are less than or equal to then we have the logical and operation and the greater than or equal to simple. Of these the relational comparison operations less than or equal to and greater than or equal to have greater precedence over the logical and. So, the precedence will be and and among operations of the same precedence level we have left to right. So, whatever happens first when looking from left to right will be evaluated first. So, these two operations have the same precedence. So, we will have A less than or equal to B within parenthesis then B greater than or equal to C within parenthesis. These have to be done first and then and. So, this will be done first, this will be done second and this is the third operation. Conceptually using just precedence and associativity rules this is how the expression should be evaluated. So, when we evaluate it A less than or equal to B is one less than or equal to one. So, that is one B greater than or equal to C is one greater than or equal to two. So, that is 0. So, this becomes 1 and 0 in which case it is 0. Now, let us look at a few tricky examples. So, if you have an expression of the following form if A equal to B greater than 1 then C equal to 1. So, let us see what happens here we will do the same thing operations sorted by precedence is there is greater than symbol which has a higher precedence over the equal to symbol. So, the expression A equal to B greater than 1 will be evaluated as B greater than 1 because that has higher precedence. So, this goes first and then A equal to B greater than 1. Now, B is 2. So, B greater than 1 is 1. So, you have A equal to 1 and A equal to 1 is an assignment expression it assigns the value 1 to A and the return value is 1 because A is assigned to 1. So, then this whole expression becomes if 1 C equal to 1 in which case we know that C equal to 1 that statement will be executed. So, this is the expression B is 1 C equal to 1. So, this is the expression B. Now, typically what is expected the typical programming style is to say something like A is assigned to B and if that result is greater than 1. So, we may want to deliberately violate the precedence. How do you do that? So, C does it in some way if you do not parenthesis it you can always change the order of evaluation in C by introducing parenthesis. So, that the meaning is very clear. So, if you do not parenthesis it then A equal to B greater than 1 is the same as A equal to B greater than 1. But what if you really want to do A equal to B and then that greater than 1. So, in that case you parenthesis I said why because parenthesis has the highest precedence. So, whatever is within parenthesis will be evaluated first. So, A equal to B will be evaluated first and B is 2. So, A will get the value 2. So, A will get the value 2. So, the assignment A equal to B will have a return the value 2 and 2 is greater than 1. So, it will be executed. One particular way in which such an expression can be seen we have already seen such an example is you read all integers from the terminal until a minus 1 is read. So, suppose the input is of the form 3 2 minus 1 and then let us say dot or something of that sort. So, what this expression does is, scan if returns a value which is the number of tokens that number of inputs that was it was successfully able to read. So, if you try to read a character as an integer it may not succeed. And so, as long as you have correctly written integer and the integer is not minus 1 then you do a particular loop. So, this is the kind of expression that is often used where you assign some value to A using the assignment statement or maybe you want to check the return value of a function whether it is positive or not and based on that you want to write a condition. So, the logical and operation does operates in the following way it evaluates the first the left operand first. If this is the first condition is false then you know that the whole expression is going to be false if at least one of the terms is false then you know that the whole thing is false. So, it will not even evaluate the second operand. On the other hand if the operation is true then it will check whether the second operand is true. If the second operand is also true then the whole expression is true if the second operand is false then it is also then it is also then the whole expression is false. This method of evaluation is also called short circuting because it may not evaluate the whole expression in order to get the result. So, if I know that this expression is false then there is no need to evaluate this because I know that the whole expression is going to be false. Here is a common mistake that people do in the because this is similar to mathematical notation. When you want to check a condition that a is between 1 and 5 what happens if you write a 1 less than a less than 5 because this is the way we do it in mathematics. Well C will apply the precedence and the associativity in this case it is the same operation. So, only associativity applies and according to associativity it is left to right. So, this will be evaluated as 1 less than a less than 5. Now, a is 2 so 1 less than a is false. So, this becomes 0 so the whole thing is 0 less than 5 so it is true. So, if you execute this code it will eventually become an infinite loop because this is an expression that always evaluates to true. Now, what you probably mean is that I want to check that a is between 1 and 5 a is 2. So, the correct way to write such an expression would be 1 less than a and a less than 5 that will check the between this condition. So, notice that this is different from the way we know that the whole expression is normally write in mathematics. This is how we would write such a test in mathematics but that will cause an infinite loop. This is because C will apply the precedence and the associativity rules and not what you think it should do. So, now let us look at can there be expressions which make no sense. We have already or we have seen several examples where you can always make sense out of it. So, let us take this expression again list out the operations see you have equal to twice then you have the modelo operation which is highest precedence then you have minus then you again have an equal to and then you have a plus. So, these are the operations in the expression. So, what needs to be done first be modelo C and then you have minus a and then you have a plus 1 this is by following precedence and associativity rules. Now, now we come to the assignment statement. Assignment statements are done right to left. So, the first thing that you try to do is the following. So, you try to do the so here is a sub expression here is a sub expression here is a sub expression and here is a sub expression. So, it is like assigning 4 terms and the innermost thing will be done first the right most thing will be done first. So, the right most assignment is B modelo C minus a is assigned to A plus 1. Now, this is a syntax error. So, what happens is as we just discussed if you work out the whole assignment if you work out the whole expression it becomes something like this. And somewhere when you work out the assignment from right to left you will see that it is trying to assign a number minus 3 to minus 7 that does not make any sense. The left hand side of assignment statement should be an assignable value which is essentially a variable and in this case you are trying to assign a number to another number which does not make sense. So, here is a syntax error. We will conclude the discussion on operations with one more operation which is quite common in C which is the comma operator. Now, this is not very common in mathematics, but let us just discuss what does it mean in C. So, let us say that we have two expressions one expression one and expression two separated by a comma. Now, think of the comma as an operation just like any other operation like plus a minus. So, it must have a precedence it must have an associativity and so on. So, what will happen when we have an expression like i plus 2 comma sum equal to sum minus 1. So, how does it follows first you evaluate the expression one. So, first in this case you evaluate i plus 2 then you evaluate sum equal to sum minus 1 and return the value of the last expression. So, the whole the comma operation is involved in an expression called the comma expression every expression has a value and the value of the comma expression will be expression two. So, what if you have multiple expressions you figure out what is the associativity of the comma expression the comma expression associates left to right. So, this expression will become scan F and so on sum equal to 0 i equal to 0. So, this for the first comma this is expression one and this is expression two. So, this expression evaluates to the result of sum equal to 0 which is 0 as we know. Now, the second level is you have 0 comma i equal to 0. So, the first comma expression is evaluated and its result is expression two of that expression which is sum equal value of sum equal to 0 which is 0. So, the outer expression becomes 0 comma equal to 0 the value of that expression is the value of expression two in that bigger expression which is the value of i equal to 0. So, here is how you will apply the rule that it is the value of the second expression for a more general expression involving multiple commas. So, what you do is first evaluate the first expression and it has some value for example, in this case it is an assignment expression. So, it will have the value 0 and then the second expression is evaluated and the value of the comma expression is the value of the second expression. Note that the you may at first sight you may see multiple commas in the same expression, but the way you do it is that you group them using associativity rules into a sequence of comma expressions where each comma expression has exactly two terms. This is what we did in the previous example. Now, comma expression is very convenient because you can do things like when you want to initialize multiple variables in a for loop for example, you can just say sum equal to 0 comma equal to 0 it will initialize both values at the same time both variables at the same time. So, commas are evaluated left to right this is what I just worked out an example of the following form. So, if you have multiple sub expressions in a comma expression, if you have multiple commas what you do is you associate them just like you did with plus and star you have multiple comma expressions and then group them two at a time. So, it becomes two comma expressions and then evaluate them. Now, the comma expression has the lowest precedence of any operator in C. So, if you have an operation like a equal to a plus 5 comma sum equal to sum plus a what will happen is you do this expression a equal to a plus 5 then do this expression sum equal to sum plus a and then evaluate the comma expression. And therefore, when you have a comma expression you do not need explicit parenthesis because the precedence takes care of it it has the lowest precedence. So, it will never get swallowed into a bit bigger expression which involves other operations. So, it will always be evaluated at the end. So, just to remind you here is the table once again and notice that as we discussed the comma operation is the lowest precedence and it associates left to right. There is also a slightly different meaning of the comma in C we will just mention that in passing. There is also the normal separator. So, the separator can be seen in multiple occasions in C when you initialize an expression when you say sum equal to 0 comma equal to 0 comma j equal to 0 this is not the comma expression it is just a separator as in English. So, similarly when you call a function you have comma to separate out the arguments that does not mean that the arguments are inside the comma expression. Then here comma is just a separator as in English and it is always clear from the context whether a comma is a separator or an operator as an operator it has a particular value as a separator it does not do anything other than saying that this first and then this. So, we have seen several operators in C and discuss the concepts of precedence and associativity and what is important is given the precedence and associativity tables can you understand an expression see whether it is a valid expression and if it is a valid expression what will be its value.