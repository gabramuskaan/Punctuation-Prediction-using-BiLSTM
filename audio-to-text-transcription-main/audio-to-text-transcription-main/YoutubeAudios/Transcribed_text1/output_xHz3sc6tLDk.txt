 In this video we will look at multidimensional arrays. In particular let us look at two dimensional arrays because that will give you an idea of how multidimensional arrays work. Initially let us look at them as arrays and in a subsequent video we will look at the connection between multidimensional arrays and pointers. So multidimensional arrays can be defined in the similar to the following. You can say double mat 5 6 or int mat 5 6 or float mat 5 6. This is similar to the mathematical notation of multidimensional arrays or matrices. So let us look at the first example. We have that the definition states that mat is a 5 by 6 array of double entries. So this means that mat has 5 rows each row contains 6 entries and all the entries are of type double. Now double is what is known as double precision floating point numbers and if you are doing a lot of floating point computations then instead of float you could use double because you might need a lot of precision in your computation. So the matrix 2 D array might look like this. This looks like a mathematical matrix of size 5 by 6. So it has 5 rows, rows 0 through row 4 and each row has 6 columns, column 0 through column 5. Now the i jth member of matrix is access test mat i j. This is slightly different from the mathematical notation. In mathematical notation you will write matrix and then a square bracket and then you will write i comma j followed by close bracket. So this is different in C you would write the indices separately in their own square brackets. Now the row and the column numbering begin at 0. This is similar to one dimensional arrays. We saw that one dimensional arrays start with index 0. Let us look at a function which prints the input matrix. So I have a function it returns void so it does not return anything it just performs an action which is to print a matrix. Now the function is called print matrix it takes a double matrix mat of size 5 by 6, 5 rows 6 columns each. I first declare i and j, i is supposed to iterate over the rows and j is supposed to iterate over the columns. Now how do you iterate over the whole matrix? Well first you would take each row i so you need an outer loop for that based on the variable i. I will go from 0 to 4 so the for loop goes from 0 until you hit 5. Now for each row what do we have to do? We have to take the elements in the column. Now the columns are numbered 0 through 5. So for each ith row we have to take column 0 column 1 column 2 column 3 column 4 and column 5. So all these entries and then you have to print that entry. Now we have just mentioned the i jth element in the matrix is access test mat i j i in square bracket and j in square bracket. Therefore you will see print f percentage f followed by space mat i j. So this will take the entry in the i th row j th column. One more thing that is worth noting is that even though you had a double matrix you still print it as percentage f as though you were printing a float and the language will take care of printing the double precision. So here is the loop to print the columns of a row. Once you are finished with a row you would print a new line because then you can start at the beginning of the next line for the next row. So here is the loop. So what the loop does is prints the i th row row starting from 0 and ending in 4 and for each row print each of the 6 columns 0 through 5. Now at the end of each row you would print a new line. So here is the code to print a matrix. The lesson here is how to access the i jth element. You would access it as matrix square bracket j. Now the dual operation of printing is of course reading in the input from the user we have done it using scan f. So let us try to use scan f to read in elements which are input by the user. Now one of the things with scan f is that the argument to which variable we have to read it in. We usually give and x if you have to read it into a particular variable x then we will say scan f whatever format it is and then say and x which says the address of x. Similarly I could guess that in order to read to the i jth element of a matrix I would need and math i j and that is actually correct. You do not need a parenthesis here to write. So you do not need to write and of math i j with math i j in square bracket. Because the address operator has lower precedence than the array indexing operator. So when you see an expression like this the parenthesis will be in such a way that math i j is evaluated first and then the address is taken because it is a lower precedence operator. So this is similar to one dimensional array that you have already seen. You would have read it using and of a i. So we have the two dimensional analog of that. So let us look at the code and the code looks exactly as the print routine except that we are now scanning a number. So you have an outer loop which will go through all the rows and then an inner loop which will go through the columns of the ith row and how do you scan? You say scan f percentage f and math i j. So remember if it was just a double variable instead of an array you would have just said and of the variable name. Similarly we have and of math i j. Again note that even though we have a double array you read it in exactly as though it were a floater using percentage f format. So read in the ith row and the ith row goes from 0 to 4 and for each row read the jth column. Column goes from 0 to 5. Now the way the scan f works the scan f with percentage f option will skip over the white space and it will skip over any white space. So in effect what it means is that if I had to enter a matrix of size 5 by 6 I can enter it in multiple ways. I can enter it in the most natural way which is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and so on. So 5 rows each row has is entered in a line and each line has 6 entries. So let us call this may be 10 and 11. So each row has 6 entries and there are 5 rows. This is the most natural way to enter it but as far as scan f is concerned any white space will be skipped. So instead I could just enter one number in one line. So I could enter it line one number per line and it would be read exactly in the same manner. That is the property of scan f. So it really does not matter whether the entire input is given in 5 rows of 6 doubles or just 30 doubles each number in a single row by itself. So that is both of them are fine. We have seen how to print an array, we have seen how to read elements into an array. Now let us see how to initialize a multidimensional array. So we want to initialize let us say 4 by 3 array in the following way it should be 1 2 3 4 5 6 7 8 9 and 0 1 2. Let us say this is the array that I want to enter. Now we have seen initialization of one dimensional arrays. If I had let us say int b 3 how did be initialize it we could initialize it as 0 1 2. So the summary of this is that if it is a list of numbers separated by commas and the list is enclosed in curly braces. This is the case for a one dimensional array. So it is natural to generalize the notation in the following way. If I have to initialize a 4 by 3 array I can just say curly brace and so here is a list of elements and each element is basically a row. So what is a number here will be a row. So it will be a list of rows and each row being somewhat like an array each row will be given by a list. So the list initialize the array initialization on the right hand side is exactly the array that is shown here. So it will come out to 1 2 3 4 5 6 7 8 9 0 1 2. So the notation is consistent and it is a generalization of the one dimensional array notation. So there are some initialization rules similar to what we have seen for one dimensional arrays. Values are given row wise. The first row this row number 0 is the first entry. Number of columns needs to be specified we need to know how many columns there are. Now value of each row is enclosed in double braces, enclosed in braces curly braces and the number of values in a row may be less than the total number of columns. This is allowed. This was similar to how we saw that even though you had declared the size of an array you could give less one dimensional array you could give less than that number of values as the initial values. The remaining values will just be 0. Same case occurs in the multi dimensional array. So let us watch an example if I have an array a 3 a number of rows unspecified number of columns 3 but each row let us say I have 3 rows each row does not have exactly 3 elements. One the row 0 has just one element row has only two elements and so on. It will be initialized as 1 0 0 because in row 0 I have given only one element so that will be the first and the remaining will be 0. 2 3 so I am short of one element that will be 0. 3 4 5 I have 3 columns and I have given 3 values. So it will be a initialized as 3 4 5. So the list the initialization on the left hand side results in the matrix on the right hand side. Here is how initialization works. Now let us look at axis mechanism in somewhat greater detail. So let us ask the following question. Instead of matrix 5 by 6 I have written a function to read a matrix of size 5 by 6. Can I give a 6 by 5 matrix? So this is a matrix of 5 rows 6 columns each. Instead can I give a matrix of 6 rows 5 columns each. The total number of elements is still 30. Would it be the same or would it be even a matrix of 10 by 3 10 rows 3 columns each. All these have 30 elements. Now as far as C is concerned are all these the same. The answer is that no it is not correct neither it should be but we will say that the answer depends on the way the array elements are accessed. So we will see this in greater detail. So in order to motivate that let us introduce the problem of passing an array to a function and let us look at the issue in greater detail. Suppose I want to take a true dimensional array of type double 5 by 6 and print the sum of entries in each row. So this is similar to a matrix program that we have seen much much before. Given a 2D matrix for each row you have to find the sum of elements in each row and just print it out. So in mathematics this is often called marginals. So let us just compute the marginals. We have a function void marginals it takes a matrix 5 by 6. It has int ij i is over the rows j is over the columns and I also have a row some variable to keep track of the sum of a row. So what do I do I have an outer loop which goes through all the rows. For each row I initialize the sum to 0. Now for each row I have to sum all the elements in the i-th row. So I have to sum all the elements in the columns j through 6 j 0 through 5 of matrix ij. So I will go through the elements and add them to the row sum. Once I am done with the last column of row i I have the row sum for row i and I will print that. So this print up is happening in the loop for row i. Now let us look at a slight modification. We say that instead of printing phi rows I currently have only 3 rows of entries available. So can you print me the row sum of the first 3 rows instead of all the phi rows. Now this is very simple. Let us just modify the function a little bit. It takes an additional parameter saying how many of the initial rows do you want me to sum. So that is an additional parameter. Let us call it n rows. So here are the number of rows for which I have to take the sum and that function is a very small modification of the sum that we have already seen. The function that we have already seen the difference is that we now take n rows which is like how many rows do we have to add. And then for i equal to 0 earlier I would go from i equal to 0 to 5 because the matrix had 5 rows. But now I will just say I will go up to n rows. And the logic is the same as before nothing else changes. So here is the strange thing see completely ignore the number of columns. As far as the C language is concerned if you have a 2 D array the number of columns is crucial it has to be specified. But the number of rows is not really important. So see completely ignore the phi part the number of rows. Now this means that we could pass less than 5 rows into the same function since we are not checking for example that n rows is less than or equal to 5. So let us see an example here is the completely surprising example that this code is the same as before the only difference is highlighted in red that I have now omitted what is the number of rows. Please relate this back to the codes that we used to write for arrays. Earlier I said that for an array you do not need to specify the number of elements in the array. When you write a function taking an array as parameter I could just say int a r r and then empty pair of square brackets with no size in between. So we have a similar phenomenon for 2 D arrays except you are not allowed to omit both rows and columns. You have to specify the number of columns but you have the flexibility that you are allowed to omit the number of rows. So the number of rows is not important you could omit it and just give an empty pair of brackets and the code will work as before. So this means that the above program actually works for any k cross 6 matrix where k could be the number of rows and this is because c does not care about the number of rows only about the number of columns and y is this asymmetry y is it that it cares about one element but not the number of rows but not the number of columns. We will see this using the 2 dimensional array addressing. Let us say that I have written a code for computing marginals and it takes these parameters double match empty pair. So the number of rows is unspecified the number of columns is 6 and then it takes an additional parameter n rows which says how many rows should I add and then I am calling this function suppose I have defined the function elsewhere and I am calling this function from mean. So I declare a matrix 9 by 6 and then I will call marginals on just the 8 first 8 rows not the 9th row. So I pass a subset of the rows so I pass a subset of the rows this is fine because I have declared a matrix of size 9 by 8 but I am passing only 8 rows to marginals and that is fine I can pass a subset of the rows. What is definitely not fine is suppose you declare a matrix of size 9 by 6 and see that I want to add I want you to find the marginals of the first 10 rows then this is unsafe because it is true that the marginals function does not really care about the number of rows. So it will work for any k cross 6 matrix but you cannot hope to pass arbitrary junk values to that matrix for example you have just declared a 9 by 6 matrix. Now the 10 row of the matrix is basically invalid so if you pass it you could expect your code to receive a segmentation violation when you run the code. So when it processes the 10th row what it has basically cross the limits of the array so the code may have a segmentation violation. So note the difference between saying that marginals could work with arbitrary k cross 6 matrices it is still true that if you pass junk values to the matrix your code will crash if your code is a valid matrix then you can pass an arbitrary number of rows inside the matrix. So the summary is that as with one dimensional arrays you should allocate your array and stay within the limits allocated within those limits the number of rows does not matter but it does not mean that you can overshoot the limit and hope that your code will work it may not and it can crash.