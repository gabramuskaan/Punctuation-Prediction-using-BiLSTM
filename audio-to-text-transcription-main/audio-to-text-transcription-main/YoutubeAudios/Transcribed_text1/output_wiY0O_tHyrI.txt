 So far we have seen comparison operators like less than equal to less than or equal to and so on. We will see a bunch of few more operators in this session. So let us consider the modulo operator which we have already seen when we discussed Euclidean Gcv. So a percentage B gives the remainder when A is divided by B. So suppose we have the following problem we get a number A and we want to check whether the given number is divisible by 6. If it is divisible by 6, A modulo 6 will be 0, the remainder will be 0. So we will write a simple code. You have INTA, ASF type int, then scan the number using scanF percentage D and A and then you test whether A is divisible by 6. To test whether A is divisible by 6, you check whether A mod 6 is 0. If it is divisible, you say that input is divisible by 6, plus NHD A. Otherwise else print if the input is not divisible by 6. Very simple operation. Now let us make it slightly more elaborate. Suppose you have to test whether this is a slight variant, suppose you have to test whether a given number is divisible by 6 and by 4 to numbers. How do you do this? So you scanF the number and you test whether A is divisible by 6. So A modulo 6 is 0. If that is true, then you also check whether A modulo 4 is 0. If both are true, then you print that the given number is divisible by 6 and 4. So percentage D is divisible by 6 and 4, A. So you can argue about this program and see that if it is divisible by 6 but not by 4, then it will enter the first if but not enter the second if. Therefore it will not print that it is divisible by 6 and 4. Similarly, if it is not even divisible by 6, it will not even enter the first if condition. So you will in any case not print that it is divisible. So convince yourself that this particular code will print a number is divisible by 6 and 4, if and only if the given number is divisible by both 6 and 4. Now that piece of code was slightly long, is there any way to write the same code with a fewer number of lines. And for this C provides what are known as logical operators. Now there are 3 logical operators in Boolean or logic which are Boolean and Boolean or and Boolean not. So there are 3 logical operations and or and not and C provides all of them. So the same if condition that we wrote before, you could have easily said if it is divisible by 6 and if it is divisible by 4, then print the output. So for this C provides an operator which is the Boolean and operation. So the Boolean and operation in C is given by 2 ANS. So by now you should be familiar with the fact that certain operations in C have repeated characters. For example, we already have seen the equality operation which was equal equal. Similarly the Boolean operation and it is actually the AND symbol on the keyboard but you have to have 2 of them that represents the logical AND. So this expression says if a a modulo 6 is 0, so this expression is what test for a is a multiple of 6 and this is the expression which test whether a is a multiple of 4. So if both conditions are true then you say that the given number is divisible by 6 and by 4. So consecutive amperesent signs. So consecutive amperesent signs that is the AND symbols without any blanks in between is the C operator corresponding to the mathematical and the logical AND function. So it takes 2 values as input and returns as 0 if any of the values is 0, if both values are 1 then it returns a 1. So this is the same as the logical AND if either of them is 0 then the result is 0 if both of them are 1 then the result is 1. So the truth table for the operation and is as follows if a is a non-zero value and b is a non-zero value then C considers that the output value is of a and b is 1. If a is 0 and b is any value at all the output is 0 and b is not evaluated. So this is the same as the logical AND the only thing to note is that if in evaluating a and b you already know that a is 0 then you know the result is 0. So C will not bother to evaluate b because it knows that the result is already 0. Every expression has a type A and B is of type int regardless of the value of, regardless of the types of A and B. This is because A and B is a logical assertion the type of a logical assertion is that it is either true or false. It corresponds to a Boolean value therefore the type of an A and B regardless of what A and B are the result is always 0 or 1 so it is of type int. Now you can print the result as an int you can say print of percentage D A and N B. Now there are 3 logical operations as I mentioned so there is also OR in C it is denoted by 2 vertical bars which are there on your keyboard. So A or B, which is A bar bar B evaluates to non-zero if either A is non-zero or B is non-zero. If both of them are 0 then the result is 0. So this is the meaning of a logical OR operation if both of them are false then A or B is false if at least one of them is true then A or B is true. So you can write the truth table for that if N B are 0 then the output is 0 if A is non-zero and B is any value then you already know that the output of A or B is 1 so the output is 1 and B will not be evaluated. This is similar to in the case of AND if A was 0 and B was any other value then you know that the output of AND is 0 therefore B will not be evaluated. Similarly here if A is non-zero then you know the value is 1 so B will not be evaluated and as before A or B is of type int. So the third logical operation is not. Now not in C is denoted as the exclamation mark. So let us see an example of that. So not is the logical complement and it takes only one argument this is different from the previous two that we have seen A or B and A and B both took two arguments each not takes only one argument so it is called a unary operator. So not of A is an expression of type integer and the value is the negation of A. So if A is 0 not of A will be 1 and if A is not 0 then not of A will be 0. So for example if I want to say that A is not divisible by 3 I will just write not of A mod 3 equal to 0. You know that A mod 3 equal to 0 test for A being divisible by 3 so negation of that it will say that the given number is not divisible by 3. Let us finish this by slightly complicated example which is that of leap years. So I am given a particular year number and I want to say whether the given number is a corresponds to a leap year or not. Now what is a leap year it is that you add a few years will have February 29th in February all other years will have 28 days in February. So what is the logic of a leap so roughly an average solar year is 365.242375 rotations. So in particular it is not an integer so we normally say that a year has 365 days that is not quite true it is a rounding. So how much are we losing? So you can calculate it as follows the remaining number after the decimal point is roughly 0.25. So at a rough cut let us say that every 4 years because of this 0.25 you will lose 1 day. So every year you are losing about a quarter of a day so every 4 years you will add a day. Now when you do that you go back to so just a minute. So you have 365 point let us say 2.5. So every 4 years you would lose 4 years you lose about a day. So you have to do this approximately 1 day. So in order to compensate for that you add 1 day every 4 years. So in 100 years you would have added 1 day. So in 100 years you would have added 1 day 25 days. But that is 1 day too much because remember that this number is only 365.24 something. So in 100 days you should have added only 24 days but now you added 25 days. So to compensate for that every 100 years. So every 100 years you would have to do this. So in 100 years skip adding the extra day. So every 4 years you add 1 extra day but every 100 years you do not add that extra day because you skip it because you would have added 1 more day. And then again you can look at what remains. What remains is also roughly 0.24 which means that every 400 years if you do this adjustment you are losing about a day because every 100 years you are losing about quarter of a day from this 0.2375 part. So you do the same logic again every 400 years. So every 400 years add an extra day. So this is the logic of the leap year that we all know. So how do we decide whether a year will be a leap year. So the logic that I have outlined just now says that if a year is a multiple of 4 then it is a leap year but if a year is a multiple of 100 as well then it is not a leap year but if it is a multiple of 400 then it is a leap year. So here is a pretty complicated expression. So every 4th year is a leap year but skip every 100 year unless it is also a 400 year. And you can write this expression in C. It is slightly complicated as you can imagine. So if the first line the first expression says that year is a multiple of 4. So if year is divisible by 4 also the following should be true. It should not be a multiple of 100 unless it is a multiple of 400. So it should not be divisible by 100 that should be true or it should be true that it should be a multiple of 400. For example, if you have 400 then it is a leap year. So what will happen is that year model of 400 model of 400 is 0 then what happens is that you have 400 model of 100 that is 0. So this is equal to 0 that is 1 not of 1 is 0. So this part is entirely 0 but it is divisible by 400. 400 divided by 400 is 0 therefore this part is true this or 0 or 1 is true therefore the whole expression becomes 1 and 1. So it is true. So this logical expression slightly complicated logical expression encodes the logic for saying that the given year is a leap year. So try this out yourself this is a slightly tricky expression and convince yourself that this exactly encodes the logic of a leap year.