 In this lecture, we will see some practices for lighting larger programs using C. As far as we have seen so far, we always wrote our code in a single file and this is not practical for very large programs, running into say thousands of lines or millions of lines. So, we will see what is the usual practice for organizing your code when we have larger programs. So, one of the basic principles is to separate the function prototype declarations from the function definitions. We have seen that when we have a function, we have two things to do, one is to declare a function which is just the types involved in the function and then the definition of the function which is actually the code of the function. So, one way to structure it, one principle in structuring is that we will separate out the function prototype from the function definition. Now, place all prototype definitions, structure definitions, type-def, so just the declarations, you will place it in a file with suffix.h. So, right now we have been coding in a file called .c. So, right now what we are proposing is that the declarations alone, we will place it in a separate file with suffix.h. You have already seen such an example which is stdi.h. We never bothered about what is inside stdi.h. Now, we are talking about how to write these header files. Now, declarations are only half the function, right. I mean we have to write the definition of the function, the code of the function, the actual code of the function you place it in a .c file separately. So, for example, list.h contains the definitions of the struct dln node for doubly linked list and so on and list.c would contain the bodies of the functions. Now, we will see why separate dot h and dot c. Programs that use the doubly linked list need to know only the declarations actually. These are, think of these programs as the consumers of this code. Now, it does not need to know how the code is implemented, just what to call and what is the declaration of the function. Now, if you do this, then list.c can be compiled separately into object code. So, we can say gcc minus c list.c. This will produce just file called list.o. List.o is not executable, but it can be used in other programs to create executables. So, how can we do this? This is the procedure known as linking. So, we can link the list.o. So, notice the difference here. When we see gcc minus c list.c, what it would produce is a dot o function dot o file and this dot o file can be included to produce output. So, this says that we are combining broke dot c file with list dot o object file and the output will produce is called prog. So, gcc minus o prog means the output file will produce will be called prog. So, if we omit minus o prog and we simply say gcc prog dot c list dot o, then the file that will get is a dot out. If we specify an output file, we will get that out file name. Now, inside prog.c, let us say that we need to use list functions. So, prog.c will include list dot h. This is the important thing. It will not say include list dot c. It will just say include list dot h. This is similar to what we have seen with STDIO. We did not bother about whether there was an STDIO dot c file. We said we will include STDIO dot h. Also notice the difference that we are using double codes instead of angular brackets. So, when we wrote STDIO dot h, what we had was, we have a number of different types of values. So, we have a number of values. Then we wrote STDIO dot h. What we had was angular brackets, open angular bracket and close angular bracket. Here we have codes. Why is that? We will see this. So, what is the advantage of separating list dot c from prog.c? Why break it up into multiple files? One advantage is that it is saves repeated compilation of list dot c functions when compiling prog.c. So, the double codes around list dot h specifies to the pre processor. We will see this in a subsequent lecture. That the current working directory will be searched for list dot h file. So, since we are saying that include list dot h within double codes, what it means is that where is list dot h found? It will be found in the current directory. If it is not found in the current directory, it will search for some standard library parts, some standard header file parts. So, in the case of STDIO dot h, we put angular brackets around STDIO dot h. That means that STDIO dot h will be found not in the current directory, but in some standard library and standard header directories. So, when you use double codes, you can also use some full path name. Suppose your full path name in a Linux system is slash user slash BTEC2115 slash 1T slash prog slash list dot h, you can specify the whole path as well. This is a more general notation. So, currently the structure is as follows. You have a list dot h file. It has just the prototype declarations. List dot c will define those functions. So, first inside list dot c, you would say include within codes list dot h and then have all the function definitions. Prog dot c needs list dot c functions, but instead of saying include list dot c, it will say include list dot h within quotations. Now, we will see how to compile such a setup. So, what is the division of work? What is the separation between the dot c and the dot h files? Dot h file is the public interface that if anybody else any other program wants to use the list functions, what you would do is include the list dot h functions, include the list dot h file. Now, list dot c implements defines all the functions that list dot h has declared. In addition, it can also define other functions, but these functions will not be available to other programs that are using the list dot h file. So, files using list dot h will not be able to use these extra functions or even know about these functions. These are thought of as private functions. So, this can be used to implement certain details of your code that other users of this program need not know about. So, the general principle is bot is known as information hiding or localization. So, the break your programs into modules, we have already seen one way to break a program into modules, which is by writing functions. Now, this is another way to this is another level of modularization, where you say that take a collection of functions and put them in a file and have multiple files. Now, each module implementing some aspect, for example, a data structure like a linked list. Now, if a module B does not need to know the details of how another module A works, then we do not need to tell B about how it is done, but module B should use module is dot h file, not the dot c file. Now, why do we separate definitions into dot h and dot c, there are some reasons, programs that use the list functions for example, are typically consumers and they do not need to know the exact details behind how these functions work. And we have already done this in other, we do not know about how scan of for print of work, we just know that scan of needs these two arguments for example, it needs a format string and it needs the variable to be printed, the print of needs the format string and the variable to be printed. Similarly, scan of needs a format string and the variable to be assigned. So, we just knew that we do not know anything about how scan of for print of is actually defined or implemented, we just know that it needs these arguments and therefore, we can call them. So, this is the kind of separation of detail that we are hoping to achieve. Now, so if some program wants to use the list functions, such programs can use the prototypes using the include commit, hash include within codes list dot h. So, again to remind the double codes specify that it is the current working directly that list dot h is present in you can also give full paths. List dot c program will contain all the actual function definitions. Now, usually header files are much smaller than the c files. If list dot h and list dot c are separated, then list dot c can be compiled ahead of time and you can generate the object file. Notice that list dot o in this case will be not executable, it is just an object file that can be used to build executables. Now, list dot c program is complete except for main function. So, it has a lot of functions it defines all the functions that list dot h has declared plus optionally some more functions and it can be compiled to produce an object code, but it cannot be done it cannot be compiled into an executable code because it does not have a main function. Now, suppose we have written a function called probe dot c that uses many of the list functions that uses list dot h. We can compile probe dot c to generate an object code g c c when the c probe dot o probe dot c. So, now we have two object files list dot o and probe dot o and then we can use these two object files to create the executable file. Let us look at a diagram which will hopefully be helpful. So, list dot h includes prototype declarations, but not the function definitions list dot c defines these functions. So, in order to define these functions first it says include list dot h therefore, it will get all the declarations and then it has this code which implements the list function definitions. Proc dot c is a consumer which needs these functions. So, how does it do it it does not say list dot c it says include list dot h. So, the declarations of all the functions are available to probe dot c. Now, I separately compile list dot c into list dot o using g c c minus c and probe dot c into probe dot o using g c c minus c. So, now I have to object files list dot o and probe dot o and these will be combined using g c c minus o. So, this says that the output file will be called a dot out the compilation units that I need are probe dot o and list dot o and so use these two files in order to create the output file a dot out and what is the big advantage here. Let us consider a scene where the probe dot c file changes. I need some changes to be made into probe dot c maybe I add some more functions modify some functions and all. So, now I need to recompile and produce the output file I have changed probe dot c but not list dot c. So, let us say probe dot c has changed. What should I do now I should compile only the probe dot c I can say g c c minus c probe dot c now I will produce a new probe dot o file. Notice list dot c has not changed. So, we do not need to recompile list dot c. So, we can just say g c c minus c probe dot c list dot o is the same as before and then I can use the new probe dot o the old list dot o in order to produce the new a dot out. So, notice the a dot out depends on probe dot o and probe dot c has changed. So, only this path gets recompiled which is saving a lot of effort and in large programs then one particular file changes and you recompile the project only the necessary files get recompiled. It does not recompile the whole project which will take a lot of time. Instead it will compile only those files which are necessary. So, this is a huge advantage. So, this is the result of the process. Just repeats what was said in the last slide. Now, couple of thoughts about writing data structure libraries there is no one design which is best for a data structure library. Choose your structured function structure functions to be as complete as possible for your programs. Now, programs can be based only on the function prototype. Suppose I write a program which needs a list function I can just look at the function prototypes in the dot h file and then write my program consumers do not need to know how the program is implemented. Just what the functions are what are its arguments not the details about how it is implemented. Now, implementation of libraries should be very sound all boundary cases should be completely defined and the implementation should thoroughly match the specifications. So, libraries need to be tested and debug thoroughly before other users can use it. Also one more thing allocation and release of storage if the library is allocating storage it is only sensible to provide routines in the library itself which can free those storage. So, it cannot be that libraries allocating storage and the freeing of the storage has to be done outside the library that is not a sensible design. So, if the library itself is allocating storage you give library functions to free the storage. For example, in list dot h memory allocation is done only in two places make empty list and make load. So, to deallocate that you should provide a free functions for these functions corresponding to these functions.