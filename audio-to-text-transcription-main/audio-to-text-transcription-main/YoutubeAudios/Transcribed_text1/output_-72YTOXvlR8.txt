 In this video we will look at linear recursion in a bit more depth and describe what I mean by linear recursion. We have mentioned earlier that when designing recursive programs think about the problem in recursive times, do not think in terms of the stack that is used in execution. When it is actually executed there will be a stack created and used for the execution and the depth of recursion is a term which means the maximum size of the stack while you execute the program on a given input. The memory used by the programs includes the local memory of the function plus the depth of the stack. Let us look at linear recursion in a bit more detail. By linear recursion I mean problems which can be solved by calling an instance of the sub problem. Exactly one instance of some sub problem. We will see more general kinds in later videos. Let us look at an example that we have seen before which is reversing an array in place. We had to reverse an array A with n elements and it is supposed to reverse the values contained in the first n indices of A. That is A 0 is exchanged with A and minus 1. A 1 is exchanged with A and minus 2 and so on. We have to do n upon 2 exchanges approximately. So, let us look at the problem recursively. We had earlier solved it using loops. Now, the basic idea of the recursive solution to in place reversion is the following. If n is 0 or 1 if the array is either empty or it contains exactly one element then we do not need to do anything to reverse the array. Otherwise it contains at least two elements. In this case exchange A 0 with A and minus 1 that will be the first layer. Now, call the sub problem. We have to solve one more sub problem which is reverse on an array which is A 1 through A n minus 2. Notice that we had already solved the problem of swapping A 0 and A n minus 1. So, earlier we had seen a program which involved linear recursion which just went left to right. In the case of reversal of an array it is still linear recursion in the sense that there is only one call to a sub problem. But the way in which you call the sub problem is slightly different. Let us see with an example. We will consider actually two examples one for an even length array and another for an odd length array. Let us say that A is an even length array with six elements and we want to reverse it using the function reverse A 6 and we have to do it in a recursive way. So, what you do is first swap A 0 with A 5 and now what is the sub problem left to be solved. We have to solve reverse of this intermediatory which starts from A 1 and contains four elements. So, we have to reverse the array which starts from A plus 1 and there are four elements to be reversed. So, in one step even though we have only a single call to a sub problem we have actually reduce the size by two. And now you reverse or rather swap A 1 and A 4 and now the sub problem that remains is to reverse this sub array which is A plus 3 and you have two elements to reverse. So, you do this and at this point you have a sub array which starts at A plus 3 and has zero elements to reverse. At this point there is nothing left. Now for an odd length array let us take a very small array which contains three elements and we have to reverse it. What you do is you reverse you swap B 0 with B 2. At this point you have a sub problem which has exactly one element and you do not need to reverse that array that array is its own reverse. So, the problem just stops there. So, notice the difference between the even length array and the odd length array in the case of an even length array the step just before the last step involved an array of size 2 and you still had to reverse that array. In the case of an odd length array this the last step involves a single length array which is its own reverse. So, you do not have to do anything. So, there are two basic cases to worry about one is where the sub array is of size 0 and another is where the sub array is of size 1. Zero corresponds to even length arrays and one corresponds to odd length arrays. Let us write this code now. So, we have reverse A containing n elements and we have reverse A and we have reverse return type void which means that this function is not going to return your value but it is going to do something. So, if n equal to 0 or n equal to 1 return because in that case A is its own reverse. Otherwise you swap the first element with the last element that is this operation A and A plus n minus 1. So, notice that swap is a function that takes two pointers to int and exchanges them. Once you do that you call the sub problem which is reverse A plus 1 n minus 2. Notice that unlike the previous examples we have discussed the sub problem reduces by 2 in size even though you have only a single call the sub problem is not of size n minus 1 it is of size n minus 2. So, look at the case of the odd length array and the even length array that we have seen before and you can notice that the sub problem reduces by 2 in size for every step. Now, what is the depth of the stack? You know that roughly n upon 2 calls will be done because you start at a size n the next call will be of size n minus 2 and so on until you hit either 1 or 0. So, you can work out that there will be about n upon 2 steps before you reach 1 or 0. The accurate expression is ceiling of the function ceiling of the expression n upon 2 plus 1. So, many calls will be there before you hit 1 or 0. So, each function call will take let us say constant amount of space and there are about n upon 2 function calls. So, the stack depth is n upon 2 and therefore, the whole space which is stack depth times the number of variables at each function that will be about n upon 2. So, now let us consider a third example which is computing the size the maximum of a particular array. For concreteness let us consider in integer array and we have to compute the following function int max array it takes two arguments one is the array itself and the second is n which is the number of elements in the array. Again let us think about the problem recursively we have written loops to solve the problem earlier, but now let us think about it in a recursive manner. If the array contains 0 elements then what is the maximum? So, here it may be slightly counter intuitive if you are seeing this for the first time the maximum of an empty array is some large negative value think of it as minus infinity. Why do we do this? This is because let us take maximum of let us take a concrete example 1 2 3 we know that the maximum of this array is 3. Now what happens when you take a larger array or list of numbers. So, what happens if you take let us keep this unspecified as an int you know the array is a large array that if a is less than 3 then the maximum of this array is going to be 3. If a is greater than 3 then the maximum of this the second one is going to be greater than that. So, in any case whatever be the nature of a you can always say that maximum of 1 2 3 a is going to be greater than or equal to the maximum of 1 2 3. Now what that means is that if you take a larger set its maximum is always going to be greater than or equal to the maximum of a subset. This is note that this is independent of a because you can analyze by cases if a is less than or equal to 3 then this maximum will be 3 itself and 3 is greater than or equal to 3. If a is greater than 3 then this maximum is strictly greater than the previous maximum. So, maximum is always monotone in the according to the subset relation. Now this means that what will be the maximum of the empty set the empty set is a subset of every set. So, no matter which S I pick maximum S has to be greater than or equal to maximum of the empty set. This means that a reasonable value for maximum of empty set is minus infinity. So, we set so this is a reasonable convention that is why when any of size 0 we return some really large negative value by which I mean the absolute value of the number is really big because we are trying to say that it is essentially minus infinity. If any of size 1 then you just return a of 0 because the array contains only one element its maximum will be a 0. If n has size at least 2 now we are in business we have to solve the problem in terms of a sub problem. So, here was an example where the base case had to be really thought of but now we are at the case where we are thinking of the recursion. So, what is the recursive step here? So, let us take a concrete array. We have array a which contains the numbers 2 4 3 7 5 23 minus 3 and 9 some concrete array and we want to say that I want to calculate the maximum of the array a in terms of some sub problem the natural sub problem that we can think of is the sub problem of finding the maximum of this sub array which starts from a 1 and goes on until the last element. So, the cursive call should be something like max array a plus 1 and there are n minus and elements in it because we omit the first element. Now, maximum value how can we solve the whole problem in terms of the sub problem. Suppose we know what is the maximum value in the tail a plus 1 to containing n minus 1 elements the maximum of the whole array will be the greater of the two numbers which two numbers the maximum of this sub array and a 0. So, maximum value is the larger of a 0 and the maximum of the tail sub array which is a plus 1 to a plus n minus 1. Now, in order to compute the sub problem we call a recursive call to the same function it looks for the max array from a plus 1 containing n minus 1 elements. So, in this example the maximum of the tail sub array will be 23 and let us say that a 0 is 25. So, the maximum of the whole array will be the greater of the numbers 25 and 23. So, in this case the maximum value will be 25 which is a 0. So, now let us write this code. So, the recursive function is very simple and this is one of the reasons why people like to write recursive functions because the whole array is the from a recursive function it is very clear what the function is going to do. Usually, recursive functions are shorter than their loop versions and it is they are easier to understand when you read someone else's code. So, let us solve max array using a recursive function in C. We have int max array because it is finally going to return an int value which is the greatest value in the array. Now, you have an int array a and n is the size of the array. Let us say that we set some max value if n is 0 then the maximum is simply something like minus infinity. Let us keep it at a very large number minus 9, 9, 9, 9. So, minus 5, 9 some large value it does not matter and then if n minus 1 if n is equal to 1 then the array contains only one element and therefore, it is the maximum. So, you just return a of 0. Otherwise n is at least 2. So, in this case you say that the maximum value of the sub problem is max array a plus 1 n minus 1. So, this is the maximum of the Taylor array. Now, once you have the maximum of the Taylor array the maximum of the whole array is the greater of the two numbers which is a 0 and max value. So, we return max of a 0 comma max value. Now, max is a function that is already there in the standard math library in C. But, if you want to write it it is not a difficult function to write. You can take two integers and return the greater of the two integers. Now, we can think about is it better than the loop version of the program. The advantage of the recursive program is that it is easier and in some sense it contains fewer number of lines than the loop program. The more the disadvantage is that it takes up more space by executing. So, the questions are how much time does the function take, how much space does the function take. And there is also a so these are things which are concrete and can be measured. There is also a softer question which is how easy is it for a programmer to look at this function and understand what it does. In the second criterion it is the recursive function that is course. In the first criterion it is often the iterative function the loop function that is course. So, please think about these questions and you can work through it and say that in order to solve max array of an array of size n. Let us take an array of size 8. You will see that these are the recursive calls it will make a plus 1 7 a plus 2 6 so on up to a plus 7 1. And when you hit an array of size 1 you get to one of the base cases which is that when you have an array which contains a single element the maximum is the only element in the array. So, once you hit here you will start returning. So, the maximum depth of function calls in this will be the size of the array. So, you can say that stack depth is n. Now, recursive programs are general programs just like loop programs are general programs. You have written loops even before you saw water array since see. Similarly, you can write recursive programs which deal with general data not just array data. And in all of these questions you can ask the question you can ask the following questions how much time does the function take and how much space does the function take. We will see an example for recursive function that will read n numbers and returns their maximum. Before we came to know of see arrays this is the kind of loop functions that we used to write. We would take n numbers. So, first you will read how many numbers to read then you will read exactly those many numbers and find their maximum using a loop. Now, let us try to do that using recursion we are not going to use any arrays. So, we have to do is write a function read max it takes n elements and the logic is the same as finding the maximum of an array. But we will do it without using arrays how do you do this if you have zero numbers to read then you return minus infinity or some approximation some large negative value. Otherwise you read the first number if n is equal to 1 that is we had to read only one number then you just say that x is the maximum. Otherwise n is greater than or equal to 2 and we have read one number. So, you say that return the maximum of the two values which is x and what goes inside inside you have to solve a sub problem which is the sub problem of reading n minus 1 numbers and returning their maximum. Go back and compare the program with finding the array maximum and the recursion works exactly in the same way. So, we will read n minus 1 numbers and return the maximum of those and then you compare maximum of the first number and the maximum of the sub problem. This is exactly as before except that we did not use any arrays and how do you call this function just declare a main function with n you scan of how many numbers to read and call the function read max n. Finally, it will return the maximum of the n numbers rate and you just print that value. So, think about this for a minute and see why we did not need to use arrays. Now, there are other functions which are typically written in a recursive manner. We just saw that you can use recursion with arrays we saw problems where you do do not need to use arrays but you can still write a recursive routine. Now, we will come to arithmetic functions and many arithmetic functions are often recursively defined. For example, let us take the GCD function Euclid's algorithm and you can write the GCD function as follows. You first ensure that is greater than or equal to B using the swap function and then you just call GCD of a comma B and GCD of a comma B is defined recursively as follows. If B is 0 then GCD of a comma B is A. If B is non-zero then you just return GCD of B comma A modulo B. So, this is how you write the recursive GCD routine and I will make the claim that this routine is cleaner than the iterative routine. In the iterative routine remember we had to use an intermediate variable which will store the value of let us say A and then did the careful 3 way exchange in order to accomplish B comma A modulo B. Here the code is very simple if B is 0 then we know that GCD of A comma B is A. If B is non-zero then we know that GCD of A comma B is GCD of B comma A modulo B. So, it is a very concise way of writing the function. Now, which you can ask the question which is better is that the recursive formulation of the iterative formulation logic is the same. So, it will take the same number of steps. So, the time taken will roughly be the same and we have also made the claim that the recursive version is easier to understand. The disadvantage may be the following that the recursive function may use a very deep stack. So, you can ask a question like how deep will be the stack in the case of the recursive program. So, in the following video we will talk about more general kinds of recursion. In this video and the previous video we have seen recursive problems which can be solved by one call to a sub problem and we will see more general kinds of recursion.