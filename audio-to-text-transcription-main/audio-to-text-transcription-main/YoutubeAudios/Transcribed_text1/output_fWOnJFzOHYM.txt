 In this video we will look at a few basic things about file handling and see. This is a vast topic in itself and we will see just the basics of this. So, let us begin by describing what are files. Now, you would think that the most natural way to define what a file is, it is a set of bytes, a collection of bytes sitting in secondary storage like maybe your hard drive, maybe your CD room drive or DVD drive or something. I mean it is on a secondary storage device. But the actual description is that any addressable part of the file system in an operating system is a file. Now, this includes extremely bizarre strange things. For example, slash dev slash null in Linux, this stands for nothing. So, if you write to slash dev slash null, it is like discarding the data. Similarly, slash dev slash u rant, this is the random data device. If you read from here, you will get random data. Slash dev slash audio is speakers. So, if you write some data into that, it will be heard on the speakers. And of course, plain old data files. For example, in your home directly, you may have slash home slash down to slash input dot text. So, input dot text is just a collection of bytes. So, we will not bother with defining what a file says. But it is something that can be manipulated using the file system interface. So, you can open a file system interface to that file. You can read from that file. You can write into that file. You can close that file and so on. Now recall that in one of our earlier lectures, I said that there are three files which are available by default to all C programs. So, these are standard input, STDIN. This is associated usually with the keyboard. And this is where scanf, get char, get us, these kind of functions get their input from. It has file descriptors 0. Similarly, standard output STD out is where printf, put car, put s, all these functions output their data to. This is usually visible on the terminal, on the screen. This has file descriptor 1. We also have a third file which is known as standard error. This is the standard error console and it has file descriptor 2. Usually, you can print error messages to STDERR. We haven't seen how to print error messages to STDERR so far. We will see that in this video. Now, how do you read input using standard file descriptors, but from sources other than keyboard and so on. So, for example, if you are running A dot out and you want to take the input not from the keyboard, but from an input file, you can say slash A dot out less than input file. This says that the input is coming from the file input file. So, this is the input file as the source instead of the keyboard. Similarly, if you want to redirect, so if you want to redirect the output to a particular output file instead of the screen, you can say slash A dot out greater than out file. So, this will use the out file as the output instead of the terminal. If you want to output something, the error messages to error file, you can say slash A dot out to greater than error file. Two stands for the standard error console. So, if you say redirect this to this file, you will say the standard output should get the standard output messages and the standard error messages should go to error file. So, Linux gives you some facilities to take input from other files using the standard input and the output. So, what you say is that instead of the standard input, you can use this less than greater than arrows in order to redirect input from some file or output to another file or error to another file. So, this is the facility Linux gives you, but consider the general situation when you have a program, you want to read the input from multiple files and maybe output to multiple files. So, this is the general situation, we just saw how to take input from one particular input file, how to output to another input output file using the redirection operator the less than and the greater than operation on Linux. So, the redirection mechanism is provided by the Linux shell and is not part of the C programming language. So, is there a way to do it in C itself rather than using the facilities of Linux. So, can we read from other files other than the standard input, can we write into other files other than writing on to the screen standard output and so on. So, we look at the general scheme of file handling in C, all these functions that I am going to talk about are in STDIO dot itself. So, you do not need to include any more files. So, if you want to open the file for reading or writing etcetera, we need to first open the file. The three standard files, STDIO, STDIN and STDIER are available to the program, any other file you have to open the file and the function to do that is F open takes two arguments name and mode and we will see what these are soon and it returns something called a file pointer. Now, file pointer is a pointer to a structure and that structure contains a lot of information about the file. For example, where is it situated? The current position being in the being read in the file. So, maybe you have read 1000 bytes and you are about to read the 1000 and first byte. So, it has that information and various maintenance information about the file. Now, in order to read or write into the file, you can use F scan F or F print F. These are the analogs of scan F and print F, which allow you to write to arbitrary files. It takes three arguments, at least two arguments, the first is the file pointer where you want to write the file, where you want to read from the file and so on. Then, there is a format specifier just as a normal scan F or normal print F and then further arguments. So, the difference here is that, whereas scan F and print F started with the format specifiers, we have an additional file pointer in the beginning. So, compare with the scan F and the print F, the first argument F P is missing. This is because scan F just assumes that the file it has to read from is the standard input and print F assumes that it has to print to the standard output and to close the file you say F close F P. Notice the way the F scan F, print F and F close work, they do not take the file name as input, only F open takes the name of the file as input. Whatever F open returns the file pointer, those are the arguments to F scan F, print F and F close. This is because once it is once a file has been opened, all the information that scan F scan F, print F and F close need are already in the structure pointed to by F P. Now, let us write a very simple program, this takes two files, it takes the names of two files and what it does is, it first prints the contents of the first file and then prints the contents of the second file and these will be output to the standard output. What is the algorithm? It is very simple, you have to first read the file names, then open file 1, if open fails we exit. Now, if print the contents of file 1 to STD out, after you are done you close file 1, then you open file 2, check whether open has succeeded if it has fail we exit, then print the contents of file 2 to STD out, close file 2 and that is it. So, let us see what each of these steps in slightly more detail, how do you open the file, we open it using a standard called F open, F open takes two arguments the name and the mode as character pointers and returns a file point. The first argument name is the name of the file and the name of the file can be given in short form, suppose you are already in a directory where that file is situated, then you can just give the name of the file for example, input file or you can give the full path name of that file in the operating system. So, for example, input file may be in the directory slash home slash dawn. So, in that case you can give the name as slash home slash dawn slash input file. So, this will be the full path name either of this is accepted. Now, the second argument is the mode, this is the way in which you want to open the file. So, what are the common modes for example, if you give R this will open the file in read only mode, this is if you want to just read a file and not write to that file, there are also other situations where the medium itself may not support writing. For example, if you have a CD roam disk, then you cannot write to that. So, it can only be opened in a read only mode. If you give W this is the write mode. Now, the first write happens at the beginning of the file. So, if the file already exists it will be overwritten. If a file does not exist, so this is the name of a new file that we support commonly is known as the append mode you specify that by saying the mode is A. So, if you open the file for append mode, then instead of the name writing at the first location of the file, it will write at the end of the current file. So, if the file does not exist, then it will start from the first location. If the file exists, it will go to the end of the file and start writing from there. So, append does not overwrite the file. We have seen the arguments of F open. Now, let us look at what it returns. If successful F open returns what is known as a file pointer, this is later used for F print F scan F close as I just mentioned. If unsuccessful the file may be you try to open a non-existent file for reading and or you try to write to a file which cannot be return to for example, it is a file sitting inside a CD-ROM drive and you are not allowed to write to it. So, if you try to open the file in write mode, then you have a problem. So, for whatever reason, if the file open does not succeed, then the F open returns in null and it is always a good idea to check for these errors. So, just try opening a file and always check whether it has returned a null. So, let us write the program that we were discussing which will take two input files and print one file and then print the other file. So, the program is fairly simple. We have a main function. You have two file pointers F P 1 and F P 2 and then two file names, file name 1 and file name 2. You get the input you get the file name 1 from the input, you get file name 2 from input using getters functions. Now, what we have to first do is write the contents of the first file. So, try opening the file. So, if F P 1 equal to F open file name 1 R because we just need to read from the file, we do not need to write into it. So, open it in R mode. If it is successful that is if it is or rather if it has failed. So, if it has returned a null, then you just say print if that it has failed. And here is for the first time we are seeing how to print to the standard error. So, in STD E R R is any other file, you can is similar to any other file, you can just say F print of STD E R R and then opening file failed, file name 1. So, we try to open file name with file name 1 as the name, but there was some error. So, try to the error terminal which is STD E R R. Now, once you do that, we will call the function copy file F P 1 to STD out. So, here is a function that we will write, which will copy from a source file to a destination file. And what it takes is what it takes are pointers to those files. Once you are done, you close the file 1 and then you repeat the whole process, exactly the same process for file 2. So, try to open it, if there is an error, you print the error message to STD E R R, then copy the file from F P 2 to STD out and finally, close the file. Once you are done, you can return from name. So, now what is left is what is this copy file function. So, let us look at the copy file function. Now, there are two ways to start writing any function which takes files as arguments. One is you can take the file name as the argument itself and within the function try to open the file. So, you will get a file pointer and you can start reading from the file using F scan F and writing to the file using F print F. This is possible. It is somewhat more convenient to say that I assume that the files are already open and I am getting the file names as the pointer using file pointers. This avoids duplication of work. The main doesn't have to open the file and then a brief function has to open the file again and again. Instead, what you can just say that I assume that the caller function has already the file open and I will just take the file pointer as the argument. So, let us look at this function. It is a void function. So, it does not return anything, it just performs an action. So, name is copy file takes two arguments from F P which is a file pointer after to the source file and two F P which is file pointer to the destination file. And what does the function do? We have a character C and here is a function we will see in a later video. But right now it just checks whether from F P has encountered enter file. So, F E O F just tells you whether you are done with the from file. So, if you are not done with the from file, what you do is you scan one character from the from file. So, F scan F from F P percentage C and C. So, this will read one character from the source file from F P and read it into the variable C. Now, what we have to do is to print that to two F P. So, you say F print F two F P percentage C comma C. So, this is exactly like scan F and print F, but taking one extra argument. So, in the case of scan F it just says what is the source file that is the file pointer argument. In the case of F print F you have to take the destination file which is two F P that is the extra argument and that is the function.