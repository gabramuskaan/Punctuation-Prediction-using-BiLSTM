 In this video we will look at one of the other expressions in particular we will look at the third one which is in star mat 5. So, if I had written int array 5 this means that array is an integer array of size 5. So, similarly I can read this as star mat is an integer array of size 5. So, in other words mat is a pointer to an array of size 5 array of int of size 5. We can look at it in this way and let us see what this really means. So, we can pictureize in this way if you de-reference mat that is if you take star mat you will get some array of size 5 of integers. Now, let us look at the picture. So, mat may be pointing to some array of size 5 which means that the next subsequent location will be another array of size 5 if it is valid address. Now, for the first location we can refer to it as mat 0 0 or it is the same as star mat of 0 or it is the same as star star mat. So, remember the general formula that we had was if I have the notation mat i j I can look it up as star mat. So, first let me translate mat i. So, that we have seen that this is simply de-referencing mat plus i that address. So, now we have one more subscript. So, in order to decode that I will do the formula for a second time. So, this plus j. So, remember that this is the general form. So, similarly if we have mat 0 0 I can write it as star mat of 0 or I can write it as star star mat because i and j are both 0. So, this is just a special case of the general formula. Mat plus 1 points to the second row of 5 integers. So, remember that the type of mat is it is a pointer to an array of size 5 of integers. So, the next pointer location when you do mat plus 1 goes to the next array of size 5. So, mat plus 1 is another array of size 5 in particular it may be the second row of a two dimensional array where you have 5 columns. Mat plus 2 will be similarly the third row and so on. So, mat 2 3 for example, if you apply the formula it will come out to be star of star of mat plus 2 plus 3. Notice that all boxes are allocated in this example. Now, mat plus i points to the ith row of 5 integers and star mat is an array of size 5. This is what we have seen. Now, you can in order to get comfortable with the notation you can look at these formulas and try to decode like for example, you could try what is the pointer way arithmetic way of representing the location mat 1 1. So, you can see that it is definitely the first case where it is star of star mat plus 1. So, that is definitely true because this is just the formula that we just now discussed. But if I do not decode both the subscripts I decode only one subscript using pointer arithmetic and leave the other subscript as it is then I know that it is also the equivalent to 3. So, 3 is also another representative and try to convince yourself by the second is not correct. Now, let us understand this in somewhat more detail by considering a tricky question. We have a function int search. So, here is a function int search int a int and int key. So, what does this function do? It will search for key inside array a of size n a is an array with n elements and you have to search for it search inside for it for the element key. If it is found then you return the index where it is found if it is not found you return minus 1 because minus 1 can never be a valid index in an array. So, when you return minus 1 you know that it is not present in the array. Now, can we use this function to search inside a 2 d array. So, we are using a 1 dimensional function in order to search inside a 2 d array. Now, the basic idea is that we can search rho by rho. Each rho of a 2 dimensional array is somewhat like a 1 dimensional array. So, we will call search multiple times once for each row in the array until we either find it or we are done with all rows. The algorithm is search it rho by rho. Now, the question is which of the following is actually doing that. So, we have three expressions search mat plus 1 5 key search star of mat plus 1 5 key and search mat of 1 5 key which of these will do it. So, this is the function of mat. Now, let us look at second mat is pointing to an array of size 5. Therefore, mat plus 1 is also a pointer to an array of size 5 when we dereference that we get an array of size 5. So, that is the right type. So, the first argument to search the second statement will be an array of size 5. So, therefore, the second call is valid. What about the third call again mat of 1 is simply star of mat plus 1 if you translate into pointer arithmetic. So, the third line is just the second line in disguise instead of using pointer arithmetic notation we are using subscript notation. So, 2 and 3 in fact are equivalent. So, 2 is correct therefore, 3 is also correct. Now, think about why statement 1 does not make sense. So, mat plus 1 is actually a pointer to an array of size in size 5. Therefore, it is not the right type it is not an array of size 5 it is a pointer to an array of size 5. So, it is not the correct type and therefore, the first call is not valid. The first option is a bit delicate. So, I would encourage you to stop here and think about why it is not correct. Now, let us utilize the function in order to write our routine to search inside a 2 D array. So, once again we are utilizing a 1 dimensional search routine in order to search inside a 2 dimensional array. So, let us say that we are given this int search function which can search inside a 1 dimensional array for a key. Now, I will write a 2 D function which can search inside a 2 D array. Now, the correct declaration of the function would be in star mat 5. And, N rows and a key N rows is going to be the number of key rows in the array key is the key we are searching for and in star row and in star column. So, I want to focus on the first argument and the last two arguments. The first argument says that I will pass you a pointer to an array of size 5. This is exactly what we should find out in the array of size 2. So, we will have to do because then a 2 dimensional array can be just traversed by using mat plus 1, mat plus 2 and so on. So, here is the correct type declaration that should accompany the 2 D search routine. N rows is just the number of rows key is the key. Why are we saying in star row and in star column? We want to return two things. If key is found, we want to return its row index and its column index. Now, unfortunately a function can return only one value. So, how will you return two values? So, we will say that we will not return two values. What we will do is give me a pointer and I will write you and I will write in that address the correct row and the correct column if it is found. Here is a standard way in C where you might encounter a situation where you need to return two values and instead what you pass are the pointers. The algorithm is what we have discussed before. You check each row of mat using the function search. If search returns success, then that will be the column index in that row because search is searching inside a 1 D array. So, wherever it returns that will be the column index in the I th row. So, now you say that the column index is that and the row index is the I that I had. If it is not found in any of the rows, you return minus 1. So, let us write the function. We have an I to go traverse through the rows. We have found equal to 0. This will be the flag indicating whether the key is found or not and initially you just set star row equal to minus 1 and star column equal to minus 1 to indicate that I have not yet found it. Found the key. Now, you write the main loop which is going through the rows 1 by 1. You start with rows 0 and you go on until both these conditions are true that is you have not seen all the rows I is less than n rows and you have not found the key. So, not found. What should you do for to the I th row? I should say that search the I th row. So, the way I say it is search star of mat plus I is the same as saying search mat of square black at I comma 5 which is the number of columns and key which is the key that I want to search for. The return value is stored in star column. So, it is you dereference call and store the return value there. Now, search can return either if the key is found it will return the correct column index or it will return minus 1. So, you just check for that if column if star column is a non negative number then you say that it has been found. So, you say that the row is I. So, star row is I and found is now 1. So, at the next iteration you will exit out of the loop because you have found the key and then the last statement in the loop will be just to increment the I variable. Finally, if you have done with all the rows and if you have exit out of the while loop you check whether you exit out of the while loop because you exhausted all the rows. So, there are two conditions to exit the while loop. One is I is greater than or equal to n rows that is one condition. The second is that found equal to 1. If you exit it because found equal to 1 then you can return the correct value without any problem. If you exit it before you if all the rows were exhausted and you still did not find the key then you have to say that column is minus 1. So, here is a brief code which will do this. So, this code utilizes our understanding of two dimensional arrays as basically an array of point as a pointer to an array of size 5. And here is why the number of columns is important because in order to do math plus 1 correctly we need to know how many bytes to skip. And this is crucially dependent on the number of columns. The number of rows actually does not matter because you can keep on incrementing the rows as long as the array is valid. The number of columns is important because that is how you get to the next row.