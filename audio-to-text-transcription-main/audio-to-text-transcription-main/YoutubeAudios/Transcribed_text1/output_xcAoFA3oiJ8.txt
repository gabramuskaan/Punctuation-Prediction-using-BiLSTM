 In this lecture, let us look at an application of malloc and free to solve some problem that we are interested in. So, the problem that I will define is to write a function to return the duplicate of a string. A string is given as the argument and you have to return the duplicate of that string. So, we have to write a function to take a string as input and return a copy. Now, let us assume that the input string is s and it ends in a null character. Assume that we can find the number of non null characters in the string. So, this will be referred to as the length of the string. What we will do is allocate length plus one characters. So, there are length non null characters and then one more for storing the null characters. So, we will allocate length plus one characters on the heap using malloc and we will copy the contents of s to that space on the heap and finally, return the address of that location. So, that will be the t the new array. So, notice that the original array may be on the stack and the new array the duplicate array will be on the heap. Let us write this function. So, I will call it duplicate. It takes one array, which is the same as a pointer. So, I can declare it as star s or car s with square brackets. It does not matter. So, I will just declare it as a character pointer s and what will it return? It will return another array and array is the same as a pointer. So, I will return character star. So, the input argument is an array and the output is also an array. I will declare three variables i, which is for the loop, length which will store the number of non null characters in s. So, let us be very specific. I do not want to store the number of characters in s because I want to say that I do not want to count null. Now, if you want to count null as well in the length, then you will have to modify the code. But, typical convention is that when you mention the length of a string, you do not count the null character. I will also declare a car star t. Now, the code proceeds in stages. First, I have to write a loop to find the length of the string. I can write a very simple loop to do that. I can say for i equal to 0 as long as s of i is not null, do increment i. So, as soon as I see the first null in s, I will stop. When I exit out of the loop, i will be the number of non null characters in s. So, I can say length equal to i. So, in the first step of the function, you just find the length of the string, excluding the null character at the end. Now, comes the important thing. We have to copy that array to somewhere. If we copy that array to the stack itself, that is if I copy that array to some space within the duplicate function stack, it will be erased when I return. So, I should allocate the space on the heap. I can allocate space on the heap using the malloc function. So, let us look at the malloc function. I want to allocate a bunch of space on the heap. How much do I have to allocate? I have to allocate length plus 1 number of characters. In other words, I have to allocate length plus 1 times size of a single character. These many bytes on the heap. Notice that it is not length times size of a pair, because if I allocate only that much, then I will not have space to copy the last null character. So, I should the input is a null terminated character. Its duplicate should also be null terminated. So, I should make space for all characters, including the null character on the heap. So, I will allocate length plus 1 times size of a pair many bytes on the heap. It will return me an address of the first byte and that address I will convert to a care star. So, malloc returns a kind of an unsorted. So, here are these many bytes. Now, it will return you the address of the first byte that was located. Now, I want to treat that as a character pointer. So, I will can do that using the casting operator. Why do you have to do that? Think about it for a minute, because you want pointer arithmetic to work. When I say T of I, I should correctly execute star of T plus I. So, go back to that lecture and understand why it is important that you know that it is not just a byte address, it is a character pointer. Once you do the allocation, you can copy SRA into TRA. We do not really care about the fact that T is not on the stack, T is on the heap, because copying is done exactly the same way. So, I can say I equal to 0, I less than length, I plus plus T I equal to S I. And then finally, this will copy all the non-null characters. And finally, I will say T of I equal to null. The last character will be the null character. Now, if you want to understand it in slightly greater detail, understand why the character star cast was required in order for T of I to work properly. Once I have done copying the array, I can just return T. And I will not leave it will not lead to a dangling pointer, because T is allocated on the heap. So, let us pictorially understand what happens during the execution of this program. I have main function and I allocate a car array. Now, this is allocated on the stack. As soon as I declare a character array and initialize it within main, it is allocated in the stack corresponding to main. So, S is appointed to the first location in the array. And I declare another pointer T and then I call T equal to duplicate of S. I should return a separate copy of S. Let us see what happens in the duplicate function. We do allocation for all the local variables, all that. But the important thing is that we have S and T, which are new pointers. Now, S is the input argument to duplicate and it will be pointing to the array in the main function, because I call duplicate of S. So, duplicates S will point to the same array as the S of me. So, it is pointing to the array on the stack. Now, as soon as I allocate memory for T on the heap, which was step 3 of duplicate. I would say T equal to character star, malach, length plus 1 times size of care. What is length here? Lenn is 6. There are 6 non-nil characters. Lenn plus 1 is 7. So, I allocate 7 characters on the heap and its return address will be cast to a character pointer. So, T is now pointing to this space on the heap. Now, once I am done creating the space on the heap, what I can do is, I can copy the S array into the T array on the heap. So, once that loop executes, it will look like this. Here is the S array inside main. Here is the heap of the array allocated by duplicate. And you will just copy T of I equal to S of I. So, you will copy S a m p l e that is within the loop. And then finally, I will say that T of 6 equal to null. So, here is an array of size 7. It has 6 non-nil characters and the last element as well. And then once I am done, I will return from duplicate. Again keep in mind, what is the raised is the stack. Everything that was allocated to duplicate on the stack is erased. Those S T and the local variables in duplicate no longer exist, but the work that was done by allocating on the heap, that still remains. So, the return value T, return value which is the address of the array in heap will be assigned to T. So, T now points to heap. Notice how it executed. S was allocated on the stack and the effect of the duplicate function will be that the duplicate of the array will be created on the heap. So, notice what we understood about the size of operator. Size of operator was used to know the number of bytes needed to store a data type. It is used in pointer arithmetic. It is used in array index calculation and it is also used when allocating memory on the heap, because alloc needed to know how many bytes to allocate. And suppose I wanted to allocate 10 integers, instead of me saying that on this machine, I know that an integer is 4 bytes. So, we will go ahead and allocate 40 bytes. The problem with doing that is you take your code to another machine and on that machine integer is 8 bytes and your code will no longer allocate sufficient space. So, the real way to write portable code would be to say 10 times size of int. That code will work regardless of which machine you execute on. So, here is the use of size of operator when you call malloc. It helps you to write portable code which will execute on any machine. So, we have seen that allocating memory on the heap can be done using malloc. We have understood what it means to allocate memory on the heap. The difference between stack is erased as soon as a function returns. Heap is not erased when a function returns. You have to explicitly say that I am now freeing that using free function. Again remember the asymmetry between malloc and free. Malloc needed to know how many bytes to allocate. Free just needed to know which pointer to the allocate, which pointer to free. It wants to know how many bytes to free. It does that automatically. And to repeat common errors using malloc you could forget to malloc. Now, you could not allocate enough space in heap. For example, in the code that we have just seen suppose you had allocated just length number of characters instead of length plus 1. Then you would not have enough space on the heap to copy the last null character. So, you will violate that T is an exact duplicate of S. Now, you could forget to free memory after use. This is called memory leak and you could have this obscure error of freeing the same memory twice. That leads to run time errors.