 So, we have been talking about designing programs using functions and the general philosophies that you have a large task that you want to accomplish and you break it into sub task, maybe each of those sub task are split into smaller sub task and so on. So, break them until some sub task can be easily solved by a single function and then you put all these functions together in order to solve the whole problem. So, design your program from top down, big task decomposing into small task and so on and debug your program or make sure that they are free of errors from the bottom up. So, test each function thoroughly and then test the overall program. In this we will discuss a few technical details about how C executes its functions. In particular we will see how C passes arguments to its functions and also how does it return values. When passing arguments we will talk about issues like evaluation order, in what are order arguments evaluated if there are multiple arguments and we will discuss what are known as side effects. So, let us start by considering a very simple example. I have very simple function called sum which just adds up to variables x and y which are integers therefore, the return value is also an integer. Now, inside the main program I will call a equal to sum of a b, a is 1 and b is 2 and then you will sum this up and the return value is assigned to a. So, this is supposed to do 1 plus 2, 3 and a is assigned the value 3. So, after passing the parameters sum is called with x as a which is 1 and y as b which is 2. So, sum returns a 3. So, the return value is 3 and the 3 is assigned back to a. So, when you print it the output will be 3 followed by 2. So, this is simple enough. Now, let us try a slightly more tricky example. So, here is the novelty in this example. Sum instead of being declared with a instead of being declared with x and y are now being declared with 2 variables called a and b. The main program also has 2 variables named a and b. So, what will happen here? The output is the same as before. So, 3, 2 if you compile the program and execute it it will be the same as before. So, what really happened here after passing the parameters sum is called with a as 1 and b as 2 and so, it returns a value 3 assigned to the a of main. Now, these variables are called a and b in main and they are called a and b in sum as well. Now, the variables a and b inside sum are different from the variables a and b inside main. So, the scope of these variables is main and the scope of these variables a and b is the sum function. So, in other words the a and b inside sum has scope just this function they are not visible or addressable outside especially in main. So, if you want to think of it you can think of them as sum dot a and sum dot b. So, they are the a variable belonging to sum and the b variable belonging to sum. So, even though you would think that this a and this a might get confused they are actually different variables one is the a variable belonging to main and the other is the a variable inside sum and they are different even though they have a common name. So, now let us try a slightly more elaborate program what happens if you have sum of sum of a b and then sum of that with comma b. So, this is the program in this case what will happen. So, first evaluate the inner program inner function sum of a b. So, a is 1 and b is 2. So, the that will return 3 then you add b again to it b is 2. So, you have 5 as the total sum. So, the total the complete output is a will be assigned 5 and b is still 2. So, this is similar to evaluating a normal mathematical expression one thing that we need to take care of is to handle expressions with side effects. Now, what are expressions with side effects. So, let us classify expressions into 2 kinds one is what are known as pure expressions. So, they are the normal mathematical expressions like a minus b star c slash d and so on similarly, evaluating functions these normally do not have any effect other than returning you the value. So, they will they will be correctly evaluated and they will return some value other than that they have no effect. Now, expressions with side effects change the state of the program for example, when I execute an expression a equal to a plus 1. Now, this is an expression it has a value. So, let us say that a was 1 before a equal to a plus 1 a plus 1 has value 2 and a is assign the value 2. The state of the program is involves for example, what values are stored in the variables. When you execute the expression a equal to a plus 1 the value of the variable a changes contrast this with previous expressions like a minus b star slash d. You can see that unless you assign it to something no variables value is changing. It will just be evaluated and the value will be returned. Here the value will be returned also the variable a is changing. Here in the second function you have 2 arguments to function f. The first is an expression a equal to b plus 1 the second is an expression b equal to a plus 1. This might sound like a very strange way to code, but you know that any expression can be given as arguments. So, in particular assignment expressions can be given as arguments for example, a equal to b plus 1 is an assignment expression which is given as an argument to the function. Now, such expressions are called expressions with side effects because they change the state of the program. When you have side effects you should be careful for example, what will happen in the following program you have a function int minus int a int b and it returns b minus a. Now, in this program main calls the minus function with 2 expressions as arguments a equal to b plus 1 and b equal to a plus 1. They are expressions with side effects because once you evaluate these arguments you know that the variable a will change in the first expression and the variable b will change in the second expression. So, what will happen in this program? So, how should be evaluated? The general rule is that all arguments are evaluated before the function called as made. So, before the function is executing we know that a equal to b plus 1 and b equal to a plus 1 both will be executed. But and here is the major problem we know that both have to be executed, but c does not specify in which order they have to be executed. So, it is left to the compiler. So, let us evaluate it in first in left to right order. So, this expression first and then b equal to a plus 1. So, what will happen then? a equal to b plus 1 b is 1. So, a will get the value 2 b equal to a plus 1 will be executed after that a is now 2. So, b will get the value 3. Now, you execute minus. So, b will be, you will return 3 minus 2 which is 1 and b has value 3. So, this is the expected output, but when you run it on some machines you may get the output minus 1 3. So, what happened here? Now, this happens for example, when the compiler would evaluate it right to left. So, when you evaluate it right to left what will happen is that b equal to a plus 1 will be executed first. So, b equal to a plus 1. So, b gets the value 2 plus 1 3 and then you will execute the argue you will execute a equal to b plus 1 b is now 3. So, a gets the value 4. So, when you call minus of 3 minus of 4 comma 3 minus will return 3 minus 4 which is minus 1. So, in this case you know that b gets the value 3 a gets the value 4 and the result will be minus 1. So, what was the mistake? The mistake was that we assume that both arguments will be evaluated before the function is called, but we assume that it will be evaluated left to right and the first expression will be evaluated before the second expression. That is a reasonable assumption to make, but c does not guarantee you that. See leaves these decisions to the compiler. Now, compilers may evaluate arguments in different orders for example, a very common order is right to left. So, both answers like 1 and 3 and minus 1 and 3 are both consistent with the c specification. Now, this is a very troubling scenario what should we do? So, we should write these functions in such a way that they do not depend on whether the arguments are evaluated left to right or whether they are evaluated right to left. So, write expressions in such a way that they are free of side effects when you pass them to functions. So, how do we do that? We can do the following for example, if we really wanted the left to right order that is if you want a equal to b plus 1 to happen first and then b equal to a plus 1. Why not write them explicitly in that order in the main function? So, first this will be executed then b equal to a plus 1 will be executed. So, a will get the value 2 and then b will get the value 3. So, minus of a comma b will execute as 3 minus 2 in which case you will get 1. So, the important thing to note is that in this particular function called the arguments do not have any side effects because we explicitly coded them up before to specify that this is the order in which I want. If I put it here then it is up to the compiler the compiler can do whatever is best in for several criteria. So, now let us come back to what the functions were we have the function definition which is the entire function the logic of the function is what is known as the function body and the heading is what we call the declaration the type signature. The type signature has for example, two arguments a and b these are called the formal parameters. Now, we focus on the return expression. So, return followed by some expression is the only mechanism for returning the value from a function. If the type of the return expression does not match the declared type of the return. So, if for example, a is of a variable which is different from int in this case they are they are the same then it is fine. But otherwise the return expression is converted to this type and then return. So, it might lead to some undesirable behavior. Now, we have discussed parameter passing in when passing parameters in c the values from the calling function are copied to formal parameters in the called function. So, the actual parameters are converted to the formal parameter type and a separate copies made. So, this is known as called by value. So, formal parameters and local variables of the function are accessible only within the function we have already seen this and memory for the formal parameters and the local variables of the called function will be erased as soon as the function returns. So, executing return anywhere inside the function will immediately return from the function and transfer control back to the calling function at the specified return address. So, when you execute there are few things to keep in mind whenever you execute any return expression it will cause the function to immediately return. Now, main is a function. So, we can use return statements inside main what that means is that main will immediately stop execution that is the whole program will stop execution. Now, when you return a particular value the calling function may choose to ignore the value for example, let us say that I write some dummy function int f and it takes two arguments float a and int b and we have some code here. And then I have the main function in which I have two variables int x and float y and then I have some code and here is the interesting thing I call f of y comma x y is a float x is an int. So, I am fine, but this function returns an integer value, but I am not assigning it to anything. So, I am not saying something like x equal to f of y comma x. So, this is not required. So, if this is the case then y call the function in the first place this is because the function also may have side effects. So, remember that side effects are something some expressions which change the state of the program. So, functions may have side effects you have already seen one such function which has a side effect for example, scan f. So, the side effect of calling scan f is that the input from the keyboard is copied into some variable. So, functions may have side effects this is why you can call the function and choose to ignore the output of the return value. Now, just for curiosity sake executing return will cause the function to immediately return to the return address. Now, the return value if you omit it then the return value is unpredictable. So, here is a example you should in general avoid doing things like this, but just for completeness I am supposed to return a float value instead if I just say return the program will compile, but when you execute some unpredictable behavior may result. So, the printed value in this case can in general be not predicted.