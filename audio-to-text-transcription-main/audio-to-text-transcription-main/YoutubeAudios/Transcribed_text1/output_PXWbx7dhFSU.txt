 Today's video we will talk about an important concept in computer science which is recursion. And we will slowly approach this by looking at various kinds of recursion. Now recursion is usually something that is completely new. It is a new way of thinking about problems that might sound unfamiliar at first. But eventually it is a more natural way of solving problems than other techniques. So we will carefully examine what recursion means. So this is the video of a media player having itself inside having a copy of itself inside the video and it goes on forever. And we will see what dusters have to do with recursion. So recursion in English means roughly say again and functions defined in terms of itself are called recursive functions. Now this is not completely accurate. We want to say that functions defined in terms of itself in a particular way. These are valid recursions. One is a powerful tool for program construction and for thinking about and reasoning about functions in general. So it is a general purpose technique of programming and you can do any kind of program using only just recursion. We will not see such general types of recursion in this course but we will see fairly common examples of recursions. So for example let us consider a very simple function which will search for a key within a given array. And we know how to write this. What I will do is I will take an integer initialized it to 0 for i equal to 0 to n. n is the size of the array. I will increment i. And if at any i I find the key I will return 1 indicating that I have found the key. If I have not found the key and I have reached the end of the array I will return minus 1. This is a typical way to search for a key inside a given array. Now we will approach the idea of recursion by looking at a recursive solution to this. Hopefully while seeing this program we will get an idea of what recursion means. So what do we mean by a recursive solution to this rather than defining it and describing abstract properties of recursion. Why not let us write an actual program which is defined in a recursive manner and through these kind of examples we will eventually get the hang of recursion. We have to write a function search. It will return whether a key is found or not. If the key is found it returns a 1. If the key is not found it returns a minus 1. And you have to search an array a of size n for the key. Now we have written this function just now using loops. Now let us write this using recursion. Now what do we mean by solving it in recursive? We have to think of the function search in terms of the same function applied to a smaller instance of the problem. So we have to solve the problem of searching for a key in an array of size n. Can we think of this in terms of solving the sub problem for a smaller array? This is the basic question that you have to ask when you want to design a recursive function. So let us try to in very abstract terms think of how to solve this in recursive manner. So let us say that I will in some unspecified syntax. This is not going to be valid C but this is just so that we see the idea in a very clear manner. I have to search for an array of size a of size n for key. Now if the array is empty that is n is equal to 0. You can have more conditions here n can be less than 0 as well. But let us say that empty array is n is equal to 0. Then you say that I have not found the key because it is an empty array. So you give back the value minus 1. So n equal to 0 implies the value to be returned is minus 1. That is what this notation is supposed to stand for. Suppose n is not 0. So this means that the array is non empty. Now how do we solve this recursively? So we look for the first element whether it is the key or not. If the first element is the key we do not have to do anything further. We know that the key is present in the array so you return 1. So the key has been found and you return 1. And now is the big step for recursion. How can we search for the key in an array of size smaller than n? So if a 0 is not equal to key then this means that key can be somewhere in a 1 through a n minus 1 or it is not absent in the array. In any case what we now have to do is search for the array starting at a 1. So by a 1 this is not strictly c notation. What I mean is the sub array starting at a plus 1. So search in the sub array starting at a plus 1. Now the sub array has one element less because we already know if we are here that a 0 is not equal to key. So there are only n minus 1 elements in the smaller sub problem. And what do we have to search for? We have to search for the key. So this says that either the key is present as the first element of the array or you have to solve the sub problem of searching in the sub array of size n minus 1 for the same key. So here is the key to thinking about a problem in recursive terms. What you first do is consider the case when you have the trivial array which is the empty array in this case. So we have the base case and then these are the recursive case. So the recursive case consists of doing something at size n. So in this case it is search whether the first element is the key or not. If it is true then we do not have to do anything further we have found the key. Otherwise solve the sub problem. Now the sub problem is a smaller copy of the old problem. So this is what is known as the inductive case or the recursive case. The reason I am calling it is inductive case is that recursion has very tight connections to the idea of mathematical induction. If you know how to write a proof by mathematical induction what you normally do is you consider a base case. So you have a theorem and you want to prove this by mathematical induction. You consider the base case probably n equal to 1 or n equal to 0. These will be the base cases for an assertion about natural numbers. And then if the base case is true then you say that I assume that the problem is true for size n and now I want to prove that the theorem is true for size n plus 1. This is how a mathematical induction proof looks like. And in the case of a recursive program there is a very tight analogy. The recursion in fact is just mathematical induction in the context of writing programs. We have to solve a problem. What we will see what is the problem in the base case? The base case is a very trivial case usually but it is important that you think about the base case. You say that if the array is empty then I will return minus 1 because the key cannot be in the array. Then you say that I will now define the problem of size n in terms of a sub problem of size n minus 1 for example. So we will solve the bigger problem in terms of a smaller copy of itself and this is the key to thinking about recursive programs. Let us code this in C. So we code this in a very straightforward manner. I will write in search int a which is the size of the array a int key which is the size the key we are searching for. If n equal to 0 then return minus 1 because the key is not found this is the base case. And if otherwise n is greater than 0 so you can search for a equal to a 0 is equal to key or not. So you can search for whether the first element is the key. If it is then you have found the key. Otherwise what you do is you call search a plus 1 which is the sub array starting at size 1. The sub array has size n minus 1 and key. So when you search when you write a recursive program there are a few things that you want to check. The first is that the base case is properly handled. The second is that when you define the sub problem you want to ensure that it really is a sub problem because if you solve the problem in terms of an equal size problem or even a bigger size problem your program may not terminate. We will see this in a moment. So this part which is highlighted in green which is calling search itself but on a smaller sub problem this is a plus 1 and minus 1. This is what is known as a recursive call to the same function. So we have seen functions that can call other functions. Now we are seeing functions which can call themselves and this is what is known as recursion. Let us see how this function behaves. Now before we go into the execution trace of this function I want to add a word of caution. The actual way to understand recursion is not to think about the stack and how functions are calling other functions. The real way to understand recursion is to think about this program as a problem defined in terms of sub instance. But in any case we will just see the execution of this function through the stack trace just to get comfortable with what happens at the back of all of this. So let us do a quick trace. Suppose we have an array 31, 4, 10, 35, 59. It is an array of size 5 named A and we are searching for the key 3. Now we know that this key is not present in the array. But let us see how the function executes. So first we call search A53. A0 is 31 which is not the key. So it calls search A plus 1, 4 because now we are searching in the sub array of size 4 for the same key. So that is in effect the same as calling the same search function on this sub array highlighted in gray. This is because the answer to search in the whole array is now the same as answer to the search in the sub array. That is what the recursive statement is. Now A plus 1 of 0 is 4. This is the first element of the sub array. Now 4 is not 3. And at this point you call the sub sub problem which is search A plus 2 the sub array of size 3 for the key 3. Here is the sub array of size 3 and you are searching for 3 in this sub array. Again the first element of the array is 10 which is not 3. So you call the sub problem of this which is A plus 3. Now the array is of size 2 and you will search for 3. And this goes on until you find that you have exhausted the array and finally the array is of size 0. You will finally say that since the array is of size 0 I have not found the key so you return minus 1. Now let us just look at this stack of function calls and see how it looks like. Search A 5 3 is called by main and let us say that it has some return address. We do not care about it right now. But search A 5 3 calls search A plus 1 4 3 and the place to return is some line in search function. This calls the sub sub problem A plus 2 3 that calls A plus 3 2 that calls A plus 4 1 and that calls A plus 5 0 at which point you realize that the sub problem now is empty. And then you return a minus 1. So at this point you have reached the base case if n equal to 0 return minus 1. So that will return a minus 1. Where will it return to? It will return to the function which immediately called it which is search A plus 4 1 3. So this guy gets a minus 1 therefore and it just returns that minus 1. And the value of whatever is returned by the sub problem. So it is minus 1 and that minus 1 gets returned. So it gets bubbled up all the way back to main and main you can realize that the element is not present in the array because the return value of search A 5 3 was minus 1. And this point the call stack terminates. So what was special about the recursion call stack? It was just that most of the stack was involved by a function calling itself over and over. But each time the function called itself it was calling on a smaller version of the problem. And here is how you think about a very simple program in terms of recursion. Earlier we saw how to solve this using iteration which was using a loop and we have seen the problem how to be solved using recursion. Now a word of caution we will see this in further examples. It is very important that you handle the base case properly. Now this is something that we are not used to in normal way of thinking. When we think about solving a problem we are thinking about solving substantial sizes of the problems. We are not concerned too much with what happens with an empty array what happens when n is minus 1 and things like that. But even in this problem we know that when we call search A plus 5 0 3 we know that the function terminated because we had a base case which said that if n equal to 0 then return minus 1. If we did not have this case you could see that probably it will go on calling itself infinite number of times. So just like when you are writing a for loop or a while loop you have the case of infinite loops. In the case of recursion you can have an infinite recursion and you have to guard against that. The only way to guard against that is to get the base case correct. So here is something counter intuitive about programming recursive functions. You know almost half of your intellectual effort is in handling the base case properly and only the remaining is in involved in solving the recursive case.