 In this video, we will see the size of operator, which is a slightly advanced topic in relation to pointer arithmetic. This is explaining how pointer arithmetic really works and it is also important to understand one topic that we will see later on called malloc. So, the size of operator and note that it is an operator and I have highlighted that in red. It looks like a function call, but it is not. The operator gives the number of bytes that any value with the given type occupies. So, size of is an operator which takes the name of a type as an argument. It can also take other kinds of arguments, we will see that. So, you could ask what is the size of an int, what is the size of a float, what is the size of a character and the answer, the value that it will come out to be will depend on some particular machine. So, the reason why you use the size of operator is that it helps you to write the code that is general enough for any machine. We will see what that means. So, right now it just returns you the size of any given data type. So, the size size of operator has an effect on the way data is allocated and the way data is allocated depends on the machine. We will see that. So, for example, if we have a character array, the cells are one byte apart. So, size of operator returns you the number of bytes that a data type occupies. So, in the case of a character, a character occupies one byte. So, if you have a character array declared as car S 8, what you have are 8 cells and each of those cells occupy a width of one byte. So, let us see that the character array starts at hexadecimal address 1000. So, the next cell will be at the next byte which is byte address hexadecimal 1000 and 1 and this goes on until the last cell which is hexadecimal 1000 and 7. So, this contains a null terminated character array with the latest SUCCES and then followed by another. What happens with an integer array? So, in an integer array size of an int is 4 bytes. So, the successive elements of an integer array are 4 bytes apart. So, let us say that I have declared an integer array as int a 4. This means that a 0 let us say start set hexadecimal address 2000. Then a 1 will start 4 bytes away because the size of an int is 4 bytes. So, it should start at address hexadecimal 2004 and I have seen that the initials sort of indicated it pictorially. I want to say that a character is a narrower data type than an integer. An integer occupies 4 bytes. So, the next integer cell, the next integer element in the array will start at hexadecimal address 2004. The third element will start at hexadecimal address 2008 and the last at hexadecimal address 2000 and C. So, no one will notice that I should have started it at 2012. But, 12 in hexadecimal address addressing scheme is C. So, in base 16, C is the same as decimal 12. So, that is why I have written it as hexadecimal 200C. Now, let us look at pointer arithmetic in greater detail. With our current understanding of the size of operator. So, suppose you have an instar pointer. If you have an instar pointer and then you want to say that PTR plus I is equal to what it should. So, notice that plus makes sense when you are navigating within an array. So, PTR is let us say pointing to some cell within the array and PTR plus I should go to the Ith cell after PTR. That is what it should do. Now, the Ith cell after PTR means the Ith integer after PTR. So, we should skip 4 I bytes in order to reach the Ith integer cell after PTR. So, this is what we have written here. PTR plus I is the byte numbered PTR plus I star size of end. The machine addressing goes in terms of bytes. So, in order to jump to the Ith integer cell, we have to know how many bytes to skip and the size of an integer is 4 bytes. So, this means we have to skip ahead 4 I bytes in order to reach PTR plus I. Now, if had you declared character star PTR, then PTR plus I is supposed to jump to the Ith character after PTR. Size of a character is 1 byte. So, PTR plus I star size of character would be PTR plus I star 1. It is the same as PTR plus I. So, notice that let us say the machine understands only byte addresses. So, in order to execute PTR plus I correctly, we have to tell which byte should I go to? Should the machine go to? And in order to do that, you utilize the size of operator. So, since you had declared character star PTR, you know that it is size of character. I star size of character. Those many bytes I have to skip. In the previous case, I had declared in star PTR. So, in that case, I had to skip I star size of end in order to reach the correct cell. So, here is the actual reason why PTR plus I would magically work correctly, whether it was an integer array or it was a character array. This is because at the back of it all, you translate everything to byte addresses using star size of whatever type. So, in general if you have type star PTR, then PTR plus I is the byte numbered PTR plus I star size of type. So, this type is the same as the declared type of pointer. PTR is a pointer to that type. Therefore, you multiply it with size of type and this is the general formula for pointer array. Now, one of the side effects of that or one of the consequences of this kind of addressing is that array plus I is star of array plus I and it will correctly jump to the I th location in that array. Regardless of whatever type the array was, why is that? Because array plus I is then translated to array plus I star size of whatever type the array has been declared to be. So, you will correctly jump to the byte address corresponding to the I th element in the array. So, here is how array arithmetic in C works in full. What do we mean by this? Let us see that with the help of an example. Suppose you have an integer array declared as int a 10 and it starts at the address 2000 and I want to know how is it that you get this third element of the array a of 2. So, a of 2 we know is star of a plus 2 a is a pointer to the first element of the array and we have to now understand how plus 2 is executed. So, plus 2 should be the content located at byte address a plus 2 star size of it. Why is this? A is been declared as integer array and in C integer array has the same type as in star. So, is a is a pointer to int. Therefore, we know that we have to do a plus 2 star size of int. Whatever the argument is, it will do 2 star size of the type pointer to by that pointer. So, we will do a plus 2 star 4 which is hexadecimal address 2008, A was 2000. So, if you have an array int a 4 let us say and it started at address 2000 then you will jump to array address 2008 and this is the reason why C arrays started index 0 because it is a very easy formula. A of 0 would be star of A plus 0 which is simply star of A. In that case you have the consistent explanation that the name of the array is a pointer to the first address of the array. First element of the array you do not need a special rule to do that. Think of what would have happened if arrays started at 1 then A of 2 would be A plus 1 star size of int. So, A of n would be A plus n minus 1 times size of whatever and that is an earlier formula then what we have here. So, it is better for arrays to start at location 0 because it makes the pointer arithmetic easier. So, in summary the size of operator is used in pointer arithmetic and we will see one more common use of the size of operator very soon. So, the general usage is you can give size of an expression what will do what will it do is it will take the type of the type of expression. So, if I say size of 10 then 10 is an int. So, it will execute size of int and let us say that on a particular machine it is 4 bytes. Similarly, you could also say size of type name. So, for example, I could say size of int rather than giving an integer as an argument I could also say size of int where int is the name of the type and it will return me 4 on some particular machine. A less common usage is you could give size of array where array is some particular array and it will return you the size of the array in bytes and this is important it will not return you exactly the number of elements in the array it will return the total size of the array in bytes. What do I mean by that? If I say int num 10 and then I say size of num it will return me 40 because there are 10 integers each integer occupying 4 bytes. So, in order to calculate the number of elements in the array for example, you could do the following you could say size of num 0 divided by size of num 0. So, this would evaluate to 40 divided by 4 which is 10. So, size of the operator on the array does not exactly give you the number of elements in the array will give you the total number of bytes in the array. But if you also know how much how many bytes a particular element in the array occupies then you can easily figure out the size of the array in terms of the number of elements. So, also note that C does not say that an integer is 4 bytes or float is 4 bytes and so on. What it specifies is the relationship between the sizes of various types and we will not get into it right now. But just keep in mind that the size of a particular type is dependent on which machine you are running the code on.