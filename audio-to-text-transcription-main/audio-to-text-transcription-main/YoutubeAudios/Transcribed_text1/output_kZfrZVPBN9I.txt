 So far we have been using wild loops in C. Now, C programming language also provides you other kinds of loops. Let us look at some of them. The first alternative loop mechanism in C that we will look at is what is known as a do wild loop. So, it is a variant of a wild loop and the general form is what you see here. You have do statement followed by wild expression and here is an important syntactic difference which causes some syntax errors when you code. The do wild terminates within semicolon whereas, the wild loop does so the wild loop has the following form which is wild expression and then statement. The difference is that here the statement is occurring before the wild test expression. So, the way it executes is the following. You first execute the statement then evaluate the expression. If the expression is true you go back to step one that is execute the statement. If the expression is false then you get out. So, you execute the statement then test whether the expression is true or not. If it is true you go back and execute the statement again. So, you loop if the statement is false you get out of the loop. The difference from a wild loop and a do wild loop is the following. You have a statement that will be executed without testing the expression even once. So, when you start executing the loop you will first execute the statement without testing the expression and after testing the expression you will go back and test the loop expression if it is true and you start executing the loop again. So, the first execution of the statement there is no test done for that. So, let us see the comparison between a wild loop and a do wild loop. So, we will look at the following problem you have to read numbers and output integer until a minus 1 is seen. Now, the difference is that in this problem you have to include the minus 1. So, read all the numbers up to and including minus 1 and print all the numbers. So, we will have the following programs using wild loop and do wild loop. Now, the important thing to notice is that the wild construct and the do wild construct are equally expressive. So, you cannot write any more new programs using the do wild construct than you could using the wild construct. But, certain kinds of programs are easier using a shorter using the do wild construct. For example, let us solve this problem using the wild construct. So, what you do initially is you declare a variable then scan the variable. If the variable is minus 1 you immediately exit out of the loop and print minus 1 and finish the program. If the number is not minus 1 you print the value and scan the next number. If the number you scan this not minus 1 you just print it and repeat the loop. If it is minus 1 you exit out of the loop and print the minus 1 that you saw. So, here is the logic using the do wild loop using the wild loop and notice that when we exit it out of the loop we needed a print up statement and before you enter the loop you needed a scan up statement. So, this was the structure of the program. This problem can be elegantly solved using the do wild loop. What you initially need to do is you declare a variable then scan the variable and print it anyway. Either the number is minus 1 or it is not in any case we need to print it. So, go ahead and print it then test whether the number was minus 1. If it is minus 1 you are done and you exit out of the program. If it is not minus 1 you go back and scan the next number and print it. So, this is a program that we have seen where you could do the same thing with the wild loop. The only difference is that the do wild program is shorter and please be careful about the syntactic difference between the wild loop and the do wild loop. Notice the semicolon at the end. This causes a lot of confusion when you compile the program it is easy to miss this. If you are new to see programming you can stick to one particular loop as I said before you cannot write any new programs that you can do using the do wild loop then you could previously do using the wild loop. So, you can write the same logic you can write the same number of programs using the wild loop and the do wild loop it gives you no further power. So, it is recommended that you stick to one loop pick wild or pick do wild whatever you do but stick to that loop in when you write the program. When you are comfortable with one of the loops programming using the other loop becomes easy. So, let us try to solve a problem that we have already seen which is to find the length of the longest continuous increasing subsequence ending in minus 1. The difference that we have is that earlier we did not include minus 1 in the sequence when you computed the length of the sequence. Now we will include minus 1. So, here is the program to do that and the logic the core logic. So, here is the initialization and here is the loop logic. So, this is the loop logic and the final check. So, if you recall from the lecture which covered the problem solving the longest increasing subsequence then you will see that the main structures in the code the main lines of logic in the code are pretty much the same. All I have done is to change the wild logic to the do wild logic and let us see what that has accomplished for us. So, what this does is that you will scan a particular number if the particular number is bigger than the previous number then you extend the sequence. If it is less than or equal to the previous number then you stop the sequence and start a new sequence this was the logic and when you start a new sequence the length is you start with 1. Then you say current equal to the next number and previous equal to the number that was just read. So, the logic here is that the testing for whether the currently read number is minus 1 is done at the end of the loop. So, if the first number is minus 1 you just do all this and then say that the length of the increasing subsequence is 1 and then you test if the currently read number is minus 1 or not. If the currently read number is minus 1 then you are already done and you exit out of the loop then you check whether max length is less than length as before. The difference between this logic and the logic that we have seen before is that we do this execution without testing whether the currently read number is minus 1. So, automatically what happens is that if the number is minus 1 all these steps will be performed before we test that the sequence has ended. So, automatically we ensure that minus 1 is also included when we calculate the increasing subsequence.