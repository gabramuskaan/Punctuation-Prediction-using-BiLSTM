 In this session, we are going to introduce a new concept of programming in C called functions. So, initially let us just try to motivate why we need functions and then we will try to see whether programming becomes easier if we have functions. So, let us say that why do we need functions? There are essentially two different reasons for it and I will mention these reasons one after the other. The first reason is to break up a complex problem into simple sub problems. All of us for example, like to draw a drop into two do lists saying that these are the things I wish to accomplish today. So, step one you know get to college, we are step two at an classes step three finish homework or something like that. And then each of those main tasks will have several sub tasks in order to get to college, maybe you need to renew the ticket subscription, get on the bus, get to college and so on. So, each of those higher level task involves several such smaller sub tasks and conceptually it is cleaner to say that these are the big level things that I want to do. Each of those big level task have several sub tasks so that I can think of it what I want to accomplish in a layer wise manner. So, this is something that we do intuitively we always break up a complex problem into simpler sub problems. So, that we can analyze the simplest sub problem and perform it completely and then come back to the bigger problem. So, we need to solve it each separately and the main tool for this programming in C which allows you to accomplish breaking up a complex sub problem into simplest sub problems is what is known as functions. So, this enables you to do what is known as modular programming in C and functions are not new we have already seen three functions in particular main was a function that we always wrote and then we have sprinter and scan up which we use for outputting and inputting respectively. So, let us just motivate the notion of functions by using the second motivation that I was talking about. So, suppose you have you want to say I want to compute n C k which is n factorial upon k factorial n minus k factorial. So, this is the definition of n choose k or n C k as it is known. Now, suppose I want to write this and code this into a C program. So, I will have let us say a main function and then inside the main function I will have let us say three variables a, b, c and then float a result because the result of a division will be a float. So, I will have what should I do intuitively one way to do it is I will have a block of code which says it will calculate n factorial which is the numerator then I will say that a equal to n factorial at the end of this let us say that a stores n factorial. Then I will have another block of code which says that I will calculate k factorial and then this will say let us say b equal to k factorial. And a third block of code will calculate n minus k factorial. Let us say I will store this in C and then I will say a result equal to a by b times c some code that looks like this. And you would notice what is inconvenient about it all these three blocks of code once we completed we look very similar they are all calculating the factorial of a particular number, but there is nothing in C which will that using the feature will actually calculating the factorial of a particular number, but there is nothing in C which will that using the features we have seen so far which will tell us that this code and this code are essentially the same and I need to write that similar code only once. So, what there is no simple way to use loops to accomplish this. So, it seems like this redundant business of writing similar code again and again can be avoided. So, this is the second motivation for introducing the notion of functions which is basically to avoid duplication of code. So, here is a side benefit of functions avoid code replication. We have already seen loops to some extent avoid code replication, but here is a newer method to avoid code replication in a greater degree. So, the second reason why we write functions is to avoid writing similar code again and again. So, let us try to write functions by motivating it with the help of an example. This example will show the benefit of how we can avoid code duplication using functions and also how we can break up a complex problem into simpler sub problems. So, in this I will introduce the problem similar to what we have seen before. We have a sequence of numbers the first number tells you how many inputs there are and then what we need to do is to pick out the numbers which are relatively prime in this sequence. So, two numbers are relatively prime if their GCD is 1. So, 16 and 7 are relatively prime 4 and 6 are not because they have a common factor of 2 6 and 16 are not they have a common factor of 2 16 and 7 do not have a common factor other than 1 7 and 8 are similarly relatively prime 8 and 9 are relatively prime 9 and 10 are relatively prime and 10 and 11 are relatively prime. So, these are the relatively prime pairs and we need to write a function which given a sequence of these numbers count how many pairs how many successively occurring numbers are relatively prime to each other in this case there are 5 such pairs. So, in this problem we can clearly see that there is a sub problem which is given 2 numbers are they relatively prime that is one sub problem and if we have the solution to that sub problem then we can compose the solution to the whole problem as follows given 2 numbers I check whether they are relatively prime if they are relatively prime I will increment the count of the relatively prime pairs I have seen so far otherwise I will skip to the next pair and see whether they are relatively prime. So, for each new pair of numbers I am seeing that is the subtask of checking whether they are relatively prime. So, let us say that suppose we have a function a function is something that we will see in a minute suppose we have a small component which will perform the task of testing is co prime a b. So, is co prime a b that function will take 2 numbers a and b and check whether they are relatively prime or not if a and b are relatively prime it evaluates to 1 it is we say that it returns 1 if they are relatively prime and if they are not co prime to each other if they are not relatively prime then it has to return as 0. So, it has to evaluate to 0 now associated with every function there are 3 concepts we will see them 1 by 1 there is this declaration of a function which says what does the function look like what is the type of the function. So, the declaration of the function will be written in the following way it will be written as int e scope prime int a int b this means that e scope prime is the function name and then it takes 2 arguments a and b which are of type int. So, int a and int b if we had written another function which takes a float a and int b we would say function int float a int b. So, in this case we are taking 2 integers as arguments so you have to say int a int b a small syntactic point that you have to notice that you cannot abbreviate this as int a comma b. So, that is not allowed each variable needs to have a separate type signature. So, these are called the input arguments. So, that is the second part of the declaration the first part of the declaration the first which says that it is an int is actually the type of the return value. So, the return value is 1 if the pairs is co prime and it is 0 if the pair is not co prime. So, the return values and int is 0. So, we need a function name we need a declaration of the input arguments the arguments need to be named and the return value of the output. So, let us say how do we design the higher level function. So, here is how you use functions menu program you assume that the function is already available to you and it does what it is supposed to do using that how do I build the solution to the whole program. So, in this case let us just assume that we have written int a is co prime we have written that function and we are interested in how do we build the solution to the entire problem using that. So, how do you do that use have a flow chart which reads numbers 1 by 1 and count is the number of co prime pairs that you have seen so far. So, you check whether you have seen n numbers if you have not seen n numbers then you will read the next number and check whether the previous number and the current number form a co prime pair. So, you give is co prime pre current it will return 1 if they are co prime. So, that will get added to the count if they are not co prime they will it will return a 0. So, count will remain as it is once you do that you say previous equal to current and indicate that you are going to read the next number. This is similar to other problems where we scanned this bunch of numbers and did some function based on that. The new thing here is the is co prime function which we just assume that it is correctly written and it does what it is supposed to do. So, this is the function declaration. Now, how do you code this up you basically code this up in C just as you did it with other program other functions like scan F you just say count plus is co prime previous current. So, this is how you can encode the flow chart including the function called as a C program. Now, let us come to the interesting part which is how do we design the int is co prime function. So, the top is the declaration part of the function where I say that what is its type. So, the function name is is co prime it takes two variables a and b a is of type int b is of type int and it is supposed to return an integer value. So, that much is clear from the type signature so called of is co prime. Now, what do you do with it? You say that so this is the classic GCD code you declare a t variable if a is less than b is swap a and b and this part of the code is just calculating the GCD. This is code that we have seen before and at the end of that a will become the GCD if a and b are co prime then a will be 1 if a is any number greater than 1 then they are not co prime. So, if a is equal to 1 you return 1 and for returning you use the code return. So, you return the value 1 otherwise you return the value 0. So, this is how you write the function is co prime. So, now we have to put both these code together so I will say include a stdao dot h this is the first line of the code then I will have closed code for is co prime. So, I will write that and afterwards write main function. So, that when main calls is co prime function then we already have the code for is co prime available first this line then the is co prime function and then the main function. So, let us look at the function in somewhat greater detail a and b are what are called the formal parameters of the function they are viewed as variables. Now, the formal parameters are visible only within the function. So, we say that their scope is inside the function now there is this is what is known as the definition of the function every function can be called the notice that we have already called the functions like printf and scanf. So, once you define a function you can call a function calling a function will be evaluating that function with particular arguments you can do that. So, when you call a function you execute the function with the given arguments. So, phi becomes a and 6 becomes b. Once a function call is encountered what happens is that formal parameters are mapped to actual parameters. So, a becomes so the value phi is copied to a and the value 6 is copied to b this process of copying values is known as parameter passing. Then what you do is you store the return address of the call the return address is the line of the main function where the function was called. So, let us say that it was called in the second line of main. Once the function finishes it has to come back to this point. Now, in addition we also create a box for storing the return value at the end of the function either 1 or 0 will be returned. So, we also need some space in memory to store that return value. So, to the function look at it in slightly greater detail. So, let us say that is co prime 9 4 is called in step 20 A. So, this is the address 20 A by which I mean it is line 20 and some location A. So, now you have to allocate the space for the return value store the return address and pass the parameters. Now, at when you pass the inputs 9 and 4 the space is allocated for A equal to 9 and B equal to 4 this is the process of parameter passing. So, we visualize the memory SS stack. So, when you start the program you start executing from line 1 of main. So, access initialize to minus 1 and then you come to the function called is co prime 9 4. So, when you execute this you do the following you allocate the space for the return value you pass the parameters and then execute the function and finally, pass back the return value. So, when you execute the function you imagine that the stack is now divided into a separate space. So, here is a clean separation between the memory that is required for main. So, above here is main and below here is the memory required for is co prime. So, in that I have stored a box for return value I have stored the return address which is 20 A and then I have A equal to 9 and B equal to 4. Now, I will execute the function as though memory is limited to here. So, I will declare t and then execute the GCD algorithm. So, this is stuff that we have seen before and finally, A is the GCD which is 1. If A is 1 we have to return 1. So, the value 1 will be copied to the return value and that is the value that will be the value of the value. So, the return value will be copied back to the main function.