 So, we will see a few more examples because loops are really important. Let us go back to the first problem that we discussed which was the problem of computing the greatest common divisor of two numbers, two positive numbers. So, the problem is to read the two numbers, find their GCD and compute the output. Now, we had a flow chart of the problem based on the fact that if A is greater than or equal to B, then GCD of A comma 0 if B is 0, then GCD of A comma 0 is A. Otherwise GCD of A comma B is the same as GCD of B comma A modulo B, where A modulo B is A percent is B is the reminder of when A is divided by B. So, let us now try to write the program in C using a while loop. So, we have to do a few preliminary things. So, let us call it the first half of the program. In the first half I declare three variables A, B and there is another variable T whose need we will see right now. But let us say that I need an extra variable for now let us just take it on faith. So, what I will do is scan two variables A and B. Now, recall in the GCD equation that if it is saw right now, we assume that A is greater than or equal to B. Now, what if the user is unaware of this condition and entered the lesser number first. So, he just entered the numbers in such a way that A is less than B. So, we need to correct that we need to make sure that A is the greater number. So, we need to exchange the values of A and B if it is true that A is less than B. Now, how do we do this? So, the first thing to note to try will be to say that for example, if I say that let us say A was 3 and B was 4. And suppose I just said A equal to B I want to exchange the values of A and B I just said A equal to B and B equal to A. What will be the effect of this? Note that this is the assignment statement. So, after I execute this line B is 4. So, A will be 4, A equal to B results in A equal to 4 right. After the execution of this line, so what the situation that we will have is that B equal to 4 and A equal to 4 and we will have no memory of what was the original value of A that is lost right. So, it is just simply lost. So, this idea that we can exchange 2 values by just writing A equal to B equal to A does not work. So, what is the correct way to do it? So, we have an idea known as the cyclic exchange and this is a really neat idea the idea is that. So, how can I motivate it? Let us say that you have 2 rooms and these 2 rooms are full of stuff and I want to change the contents of the first room to the second and the second room to the third. One way I can do it is that I will move the contents of the first room to a different room. So, have a temporary room and then copy the contents of the second room to the first and copy the contents of the third room to the second. So, this is a very nice intuition and it almost is similar to what we need to do. So, we have 2 variables A and B that we need to swap. So, one thing we can do is I will keep a third variable T. First what I will do is I will copy the value of A to T. So, now I have a backup copy. Now, then I will say B equal to A, A equal to B. So, at this point the value of B will be copied to the A. So, now A is 6, B is 6, but still we have a memory of what was A before because the old value of A was stored in T. So, in order to complete the routine all you need to do is to copy the value of T to B and that can be accomplished by the equation by the assignment statement B equal to T. So, this idea is known as cyclic exchange. So, recall the physical intuition of swapping the contents of 2 rooms which are almost full. You have a third room and you copy the you move the contents of the first room to the third room, move the contents of the second to the first and move the contents of the third to the second. So, this is similar to what we did in the case of physical contents we cannot copy in the case of variables we can copy. So, now let us complete the GCD program. We have just done the first part of the program which is to ensure that A is actually the greater number. If it was not the greater number you swap or exchange. Now, so after exchange we have ensured that A is greater than or equal to B. Now, we have to write the main loop for the GCD function. So, just by translating that flow chart what we will do is while B is not 0 what you do is you say that store the value of A and T assign A to B, A equal to B and B becomes T modulo B. Recall the equation was written as follows that. So, recall that the equation was GCD of A B is the same as GCD of B A modulo B. So, when you assign A to B the old value of A is lost and we can no longer do A modulo B. So, the way to do that is you use the idea of a temporary variable store the old value of A and T before you do A equal to B. So, that finally A modulo B can be done by T modulo B. I do not want the new value of A I want the old value of A. So, let us just trace the execution of this program. Let us say that I scan 2 numbers A and B and the user was correct in entering it. So, he or she entered the greater number first. So, we have 16 and 9 A equal to 16 B equal to 9 and T is undefined. So, after you read the numbers you just say GCD of after this you enter a message which is print a message which is that GCD of A and B is. So, GCD of 16 and 9 is and then you enter the loop. So, in the initial execution of the loop you have T equal to A which will store T equal to 16 A equal to B which is A will become 9 and then but you want to compute the modulo 16 modulo 9, but 16 was lost in A because A is now 9. So, you have to do T modulo B. So, 16 modulo 9 which is 7. So, you go back to the while loop and then you see that B is not 0 B is 7. So, you enter the loop again T is equal to A. So, T is 9 A equal to B. So, A becomes 7 B becomes 2 again B is not 0. So, you enter the loop again. So, T is 7 A equal to 2 and B equal to 1 again you enter the loop B is not 0 T is 2 A becomes 1 and B becomes 0. At this point you exit the loop and at this point the A that we ended with is the GCD of these numbers. So, 16 and 9 are relatively prime therefore, their GCD is 1. Now, let us think of minute about what is the loop invariant in this program. What is what is it that we have a central while loop which computes the GCD what was the invariant in that loop. So, for this I will just introduce a slight notation which makes it easier to discuss these invariant. So, let capital A and capital B be the original numbers that I input and little A and little B represent the numbers which are involved in the loop. So, capital A and capital B were the original input and the invariant that I have is that at every stage the GCD of the original inputs are the same as the GCD of little A and B. Recall that little A and B are the variables involved in the loop. So, little A and B keep changing through the loop whereas, capital A and B are fixed they are the input. So, the invariant that I have is that at every time you enter the loop the GCD of the input were the same as the GCD of the variable. Now, this guarantees the correctness because when you exit out of the loop the you will correctly compute you exit out of the loop because B equal to 0 and by the original equation you know that when B equal to 0 A is the GCD of A and B. So, this guarantees correctness. Now, you could also ask other questions like how many times has the loop run and this question is a bit complicated because you have to compute it based on the input numbers. So, such questions are of interest to computer science but we will not go into computing the efficiency or the performance of this code but it is also a very crucial question.