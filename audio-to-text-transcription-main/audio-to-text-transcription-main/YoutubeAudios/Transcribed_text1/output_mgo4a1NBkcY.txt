 So, here is the stuff that we have seen about pointers. First we have defined what is a pointer, a pointer is just a variable that holds the address of another variable. We say that pointer points to another variable and depending on what variable it points to the type of that target, we say it is an in pointer or a character pointer or a float pointer and so on. So, this is the first thing what is a pointer and then we have seen what all can you do with a pointer, what are the operations that you can do in a pointer. So, if you have a normal variable you can take the address of that variable using the and operator. If you have a pointer then you can de-reference the pointer by using star of ptr that will go to the location pointer to by ptr and take the value of that target. Further we have seen pointer arithmetic involving plus and minus and I have introduced you with the caution that they are meant to navigate within arrays. They are not meant to navigate to arbitrary locations in the memory. If you do that it may or may not work. And further we have touched upon the intimate relationship between arrays and pointers in C as captured by the formula array of i is star of array plus i. A special case of this is to say that the name of the array is an address of the first entry in the array. For example array of 0 is the same as star of array plus 0. We have seen this and think about them once more to get comfortable with the notion. In this video we will talk about how pointers interact with functions. When we introduced arrays we first said here are arrays here is how you write programs with arrays and then we introduced here is how you pass arrays into functions. Let us do that the same thing with pointers. So, here are pointers and how do you pass them to pointers. Before coming into how do you pass them to pointers we will go into why should you pass pointers to functions. So, let me introduce this with a very standard example this is a classic example in C how do you exchange two variables. We have seen the three way exchange where I said that if you have B rooms A B I have two full rooms A and B and then I want to exchange the contents of these rooms then I can use a third room first move the contents of A to T that is your first move then move the contents of B to A that is your second move and then afterwards A now contains the contents of B and B is empty T is containing the contents of A. So, the third move is move T to B. So, the net effect will be that B contains the old contents of A contains the old contents of A and T is empty. So, this was the three way exchange which we did within main function this is long back when we discussed GCD algorithm. Now, let us try to do that using a function. So, I have a swap routine which takes two integer arguments A and B and it is meant to exchange the values of A and B. So, inside main I have A equal to 1 B equal to 2 and I call A and swap A and B and swap A and B what it does is this three way exchange that we have just discussed. Now, just to test whether things are working I have bunch of print of statements which says what is the value of swap what is the value of A and B after swap has executed. Similarly, when I come back I will just print the values of A and B to see what has happened after swap. So, when you call swap and you output it within swap it is very clear that A equal to 2 B equal to 1. So, this the three way exchange would work as you expect and you have whatever was passed which is swap 1 to. So, it will exchange those variables and it will print A equal to 2 and B equal to 1. Now, within main A was 1 and B is 2. Now, when you print these statements inside main surprisingly you will find that A equal to 1 and B equal to 2. So, the effect of swap has is completely absent when you come back to main swap within swap they were exchanged but when you come back to main they were not exchanged. Now, why does this happen this is because remember that some space is allocated to a function and whatever space is allocated to the swap function all the variables there is erased are erased once you return from the swap function. So, within swap function A and B are exchanged but all that is gone when you return to main. So, passing integer float character variables as parameters does not allow passing back to the calling function. You have only the return value to return back any changes made within the called function are lost once this function returns. So, the question is can we now make a new function such that work done within that function will be reflected back in main. Now, here is an intermediate solution we know that if we pass a erase then work done in the called function will be reflected back in the calling function. So, you could think of the following intermediate function. So, if I have int num 2 and then I say that num 0 is 1 num 1 is 2. So, this is the function of num 2. This is in the main function and then I call swap of num or we will call it swap 1 of num I have a new function. Now, what swap 1 does is so int swap 1 int error is 1. So, suppose I have this function inside that I will just say that I will have an intermediate variable t and then have t equal to num or error 0 then error 0 equal to t error 0 equal to 1 and error 1 equal to t. Suppose I have this function and now you can sort of argue that this will also swap the two cells in the num array. So, the dirty trick that I am doing is that I want to swap two variables instead I will say that instead of these two variables I will insert them into a array of size 2 and then call swap 1 on that array. Now, what I will do is I will do this. So, I will do this in the name of the array and then I will do this in the name of the array. So, I will do this in the name of the array and then call swap 1 on that array. Now, what swap 1 does is it will it will exchange it will do the 3 way exchange on the array. Now, I know that because of the way arrays are passed in C any change that happens to the array error inside swap 1 will be reflected back in main. So, when I print this num array back in main I would see that num 0 is now 2 and num 1 is 1. So, this is a intermediate trick in order to write the correct swap function, but you will agree that this is a kind of a dirty trick because in order to swap two variables I created an array and then dependent on the fact that swap will change array in such a way that the change will be reflected back in main. So, is there a nicer way to do it that is what we are interested in and the answer is let us just think about that array trick what we did was when we passed an array we were passing the address of the array. This is how arrays are passed to functions. So, now let us just take that idea that we are passing the address. So, let us try to write a swap function where you are passing address of variables instead of the variables themselves. So, here is the correct swap function and what I write is void swap. So, void is a new keyword that you will see, but it is not a big deal is just a function that does not return a value it just performs an action without returning a value. So, such functions you can write it as void swap in star p, t array in star p, t array so p, t array and p, t array are pointers. Now, inside the code you have something that looks like a 3 way exchange it is very carefully written because the obvious way to code the function is not right. So, you have to be slightly careful you have to declare an integer variable. Now, t contains star p, t array star p, t array equal to star p, t array and star p, t array be equal to t. The obvious way to write it seems to be you declare an integer star p, t array and then do this it is not quite right we will come to that later. So, here is the swap function and how do you call the function you declare two integer variables in main a equal to 1 and b equal to 2 and then pass the addresses using and a and and b. So, let us just trace the function you have two variables in main a equal to 1, b equal to 2 and call swap of address a and address b. Now, just to denote that these are addresses I will say that these are a is situated at location 1024 in hexadecimal. So, this is some location in memory hexadecimal 1024 and this is some other location in memory b is say at hexadecimal location 2000. Now, do not be distracted by the hexadecimal notation if you are uncomfortable with it just write 1024 in equal equivalent in a in an equal and decimal notation and you can say that it is at that location. So, it is at that location and I am representing the location in hexadecimal because it leads to shorter addresses and this is also an address. So, when I take address of a I will get 1024 hex in when I take the address of b I will get 2000 hex. So, this is the address of a and it is located at memory location 1024 when represented in the hexadecimal notation. What happens when you call the swap function? So, here is the state of mean and when you call the swap function a new bunch of memory a new block of memory is allocated on the stack. So, first the formal parameters are copied their values from the actual parameters. So, PTRA will get AND A which is 1024 PTRB will get AND B which is 2000. Now, I declare a new variable T T equal to star PTRA. So, what does that mean? PTRA is an address D reference address which means go look up that address. So, it will go to this location and get that value. So, T will now become 1 and the next statement is somewhat mysterious. Please understand it very slowly. So, on the right hand side you have star PTRB this means D reference PTRB. So, we are saying PTRB is address 2000 when you D reference it you will get the value 2. Now, where do I have to store that value 2 for that D reference PTRA? So, 1024 D reference it you will go to this box that is where you have to store 2. So, 2 will go to that location. So, what has happened due to that is that A in main has now changed. Why? Because within the swap function we were dealing with pointers. So, as a result of the statement star PTRA equal to star PTRB it has taken 2 from the main functions B and put it back into the main functions A and that was accomplished through variables inside swap. So, think about it for a while. And the last statement of course, is star PTRB equal to T. So, D reference PTRB and put the value 1 there. So, here is a 3 way exchange that works through variables in only in swap. But since they were pointer variables you ended up changing the locations in the main as well. And once you return all the memory will all the memory corresponding to swap will be erased. But then when you return the main A and B will have changed A and B were 1 and 2 before. Now, A is 2 and B is 1. So, it has correctly swapped. Now, as an exercise I said that the obvious way to write the swap function is as follows. Voids swap A in star PTRB's PTRA and in star PTRB. And then I declare in star PTRT and then I write these statements. This is a very obvious way to code swap. This does not work. So, try to draw these pictures as we have done with a swap function that actually worked. Try to draw the picture of what happens in main and what happens in the swap function and understand why this particular swap function does not work. One final word about passing pointers to, passing pointers to functions. C has something called a call by value mechanism. What is meant by call by value is that when you call a function remember the original picture that your friend came with his notebook and copied down the numbers in your page. So, your friend created a separate copy of your arguments then computed what had to be computed and returned you a value. That picture is essentially still correct. Even though you are now dealing with functions which can manipulate memory inside main, the passing mechanism is still called by value. It is just the fact that what is being copied are the addresses. So, when you manipulate the addresses through dereferencing you end up changing the location inside main. So, even with pointers in C what happens is call by value.