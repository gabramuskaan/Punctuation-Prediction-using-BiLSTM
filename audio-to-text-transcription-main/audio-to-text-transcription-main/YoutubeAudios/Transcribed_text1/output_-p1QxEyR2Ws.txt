 In this lecture, we will see a slightly more advanced data type than a sinkley link list. We will briefly go over one or two functions to manipulate the data structure. The principle of manipulating the data structure for the other operations is similar. So, in the case of a sinkley link list, we have seen that every node has one link to its next neighbor and we have seen this problem in a sinkley link list that if you are at a current node in a link list, you can always go forward, but there is no way to go back. There is one the only way to get to its previous node is to start all over again from the beginning of the list and traverse until you reach a list, traverse until you reach the previous node. So, we can easily remedy this by thinking of a data structure, a slightly more involved data structure where every node has two links. So, look at this node 2. So, it has two links, one is to its neighbor, success in neighbor. So, it is its next node. There is another link which goes back to its previous neighbor. So, in this data structure, there are two links per node. Therefore, it is known as a doubley link list and this list, obviously, you can go from a current node, you can go forward or backward. So, easily. So, now the variation is this, if each node has three fields, one is a pointer to the previous node, the second is the data in the node and the third is the pointer to the next node. So, how will the definition look like? It will say something like struct DLL node, doubley link list node. It will have one field which is data in data, let us say and then two nodes struct DLL node next and struct DLL node previous. So, one to go to the next node and another to go to the previous node. Now, we will need two pointers typically for a doubley link list. One is the pointer to the beginning of the list, which is usually called the head and another to the end of the list, which is usually called the tail. So, I will use a type def in order to shorten the name, I will just say type def struct DLL node star node pointer. And then I will say that the list has two node pointers, node pointer head and node pointer last. So, doubley link list, each node in the doubley link list has two list, one to its previous node and another to its next node. And the list itself has two pointers, one to the beginning of the list called the head and another to the end of the list called the tail. So, now doubley link list is another data structure, notice that we have seen two or three data structures so far, arrays are one which see already provides. We have already seen single link list, now we have seen a third link list, third data structure which is a doubley link list. Now, a data structure has data and a bunch of operations defined on it. So, let us look at typical operations that can be defined on a doubley link list and we will go over the implementation of two or three of them. So, node pointer head, so this is a function that should return the head of the list. Similarly, node pointer tail, this should return the tail of the list, insert before. So, this is like the insert before node in the case of a single link list. So, here we are given a current node and we have to insert before a current node in the doubley link list. Notice this was difficult in a single link list because there was no way to go from a current node to a previous node. We could always go to the next node. So, if I say that here is a node and insert before that node in a single link list, it is difficult. You need some extra information, but in a doubley link list you have the current node and you can use the previous link in order to go before that. Insert after node also can be done. This could also be done in a single link list. So, and then you can think of several other common like you can think of a make node, you can think of a make list with a single with a single node pointer to by p new. You can make an empty list, you can check whether a given list empty, you can write functions to copy a doubley link list to a new doubley link list. You can concatenate two doubley link list, you can do a deep concaten, we will see this in a future slide, you can append two link list and so on. Similarly, we can have insert, since we have insert functions, we can also have delete functions, you can delete a particular node, you can extract a node in the sense that, so delete would take out a node and free the memory allocated to the node, extract would just take out the node from the link list, but you retain the node, you can delete an entire list and so on. So, let us look at a couple of these functions, other functions can be written in similar manner. So, suppose let us take insert before node, this was a function that was not easy with the single link list. So, I am given a link list L, I am given a current node p, c urr and a new node to insert before the current node. So, what are the things to check, if the list is empty, then insert before the current node just means that, you create a new node and return the new list. Now, if the head of the list is null, then you just say that, now the new list contains only one node, L head will point to new, L tail will point to new. So, if the list itself was null, then what you do is you create a new node, now the new list contains only one element. So, the head will point to that and the tail will also point to that and you return that. Now, you come to the non trivial case, suppose the reason list and the list has some elements, then so if p current is not equal to null, then what you do is, sorry if p current equal to null, then you return the L, this is an error, if p current is not equal to null, then what you do is the following. So, now you have to insert p new into the list, so how do you do this? So, we say that the new nodes next will be, so we are trying to insert p new before p current. So, the new nodes next will be p current, p current previous will go to p new and so the p new next will go to p current and p current previous will go to p new. Similarly, we have to say that the previous node, the node before p current, it has to point to p new. So, p current previous that nodes next will go point to p new and then you return the new list. So, this can be done by looking at pointers and handling pointers carefully. So, now let us see how to delete a particular node in a list. So, if you have to delete the header of the list, then if there is a list, you just delete the header and you just free the entire list. Now, if you have to delete a particular node in the middle of a list, what do you do? So, let us look at the various cases. So, in case 1, the node that you want to delete is the head of the list. So, in this case, suppose you want to delete p, what would you do? You would make head point to the next element and free p. So, head will be made to point to p next. So, this is the next. So, this line here, L head will go to p next. Now, this guy's previous will be set to null because we are going to delete this node. So, this guy's previous will be set to null. So, now it does not point to anything and then you will free p. So, this is the first case where p, the node to be deleted was the head of the list. Now, similarly, if you want to delete the tail of the list. So, now what should you do here? The tail should go to p previous. So, in case 2, when p is the end of the list that we want to delete, then tail should go into p previous. Now, this guy's next will now point to null because we are going to delete this node and finally, we will free p. So, L tail will go to p previous L tail next will be null and then finally, you will free p. So, we have seen 2 easy cases. One is delete the head and the other is delete the tail and now we will see the difficult case where p is an intermediate node. So, in this case what we will do? So, we will we have to remove this node. So, p previous's next node should be the next node of p. So, this link should point to the node after p. So, that is the first thing. So, we will make this node point to the node after p and this node's previous should point to the node before p. So, we will reset the links. Now, if you look at the link, this guy's next is the one after p. This guy's previous is the one before p. So, now p can be safely removed. So, this is how you would delete a node in the intermediate list. So, if there is a next node, then p next previous will be p previous that is this backward link and if there is a previous node, then p previous's next will be p next that is this forward node. And finally, after that you will free p. So, this is how you would delete a node from a link list, from a doubly linked list and other operations can be done in a similar manner. And some of these operations will be asked in the exercise problem that you will be assigned. Similarly, you can think of an extract node. The code will be exactly identical to before, except at the end, you will instead of freeing p, you will return p. You do not free the p node, you will just return the p node. Now, let us look at one more example. How do you attend append one node to the end of a list? So, first we will check that the node is pointing to a non-null node. If it is pointing to a null node, there is nothing to be done. So, there is nothing to be appended. So, you return. Now, if the if the reason list, then what you do is, if there is no list, what you do is, you make a list with only one node which is p. Now, if the reason list, you can in order to append a node at the end, what you could do is call insert after node L L last p. So, append will be the same as insert the node p at the end of the list. So, you will say insert after L last, what is the node to be inserted p. So, if you have an insert after node or an insert before node, you can do this to implement other functions. So, this is a brief introduction to doubly linked list which are similar to sinkley linked list, but facilitate forward as well as backward traveling from a current node. Using that, you can implement more functions easier than a sinkley linked list. At the same time, it has all the advantages of a sinkley linked list in the sense that, if you want to insert a node, it can be done using a constant number of operations. If you want to delete a node, it can be done in a constant number of operations. So, those advantages are similar to a sinkley linked list. At the same time, the disadvantages are also similar to a sinkley linked list in the sense that, if you want to search through even a sorted doubly linked list, you have to search through all the elements.