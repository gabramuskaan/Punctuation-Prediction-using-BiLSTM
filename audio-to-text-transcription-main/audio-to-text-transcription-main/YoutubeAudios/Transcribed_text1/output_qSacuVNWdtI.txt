 In this session we will write another algorithm to solve a mathematical problem. If you do not know this algorithm already that is fine, it is more for the purpose of demonstrating if you know a solution how do you come up with the algorithm to tell a computer how to solve it. The algorithm is for finding the greatest common device or the highest common factor it is known under two names of two positive integers M and N. So, this is an algorithm you probably know. How do you solve this? Let us first try naive solution and before writing an algorithm let us see what do I mean by the simple solution of GCD. So, you are asked to find the greatest common divisor of M and N, take the smaller number N and now you start looking for each number K between 1 and N remember that N is the smaller number in descending order do the following. What you do is if K divides M and N then K is the greatest common divisor of M and N and this is obvious by the definition of greatest common divisor. If K divides M and N then it is obviously a divisor of M and N also we are coming in descending order we start from N and go down to N. So, the first divisor that you hit when you go down is going to be the greatest common divisor of M and N. So, this algorithm obviously works it will compute the GCD correctly but it is very slow and think about very large numbers M and N and you will see that it may go N steps before reaching the correct GCD. So, compute the GCD of two very large numbers which are relatively prime to each other that means that the GCD of M and N are 1. Now, if you pick such a pair this algorithm will compute the GCD correctly but it will take N steps because you have to go down all the way from N to 1 before you will hit the GCD. Can we do better? There is a faster way and it is a very old algorithm the algorithm is due to Euclid we will see a slightly modified version of that algorithm. So, before we go into Euclid's algorithm for GCD we will describe what it does and give you a slight intuition of why it works. So, consider the GCD of 8 and 6. Now, you can consider two rods one of length 8 and another of length 6. Now, obviously if a number divides 6 and 8 then I should be able to make a stick of that length so that I can measure 6 exactly with that shorter rod and I can measure 8 exactly with that shorter rod. This is the meaning of a common divisor and we have to find the greatest common divisor. So, first what we will do is we will measure the shorter we will measure the longer rod using the shorter rod. Now, it may not measure the longer rod exactly for example in this case 6 does not measure 8 exactly there will be a small piece of length 2 left over. So, take that remainder and now repeat the process now 2 has become the shorter rod and 6 has become the longer rod. Now, see if 2 measures 6 exactly it does so you are done and then you can say that 2 is the GCD of 8 and 6. The reason why this works is by the nature of this algorithm it is clear that 2 divides 6 because that is why we stop the algorithm and also we know that 8 is basically 6 plus 2. So, it is obviously a multiple of 2. So, it is a common divisor and with a slightly more elaborate argument we can argue that it is the greatest common divisor. So, this is an algorithm which is essentially due to Uplit. So, it was known for at least 2000 years. Let us pick a slightly more elaborate example. Let us say we want to find the GCD of 102 and 21. The process of taking remainder is what is known as the modulo operator in mathematics. So, 102 modulo 21 is the remainder of integer division of 102 by 21. So, the remainder of when you divide 102 by 21 is 18. So, that is the shorter rod for the next stage. Now, 21 mod 18 is 3 and that becomes the rod for the next stage the shorter rod for the next stage and 18 mod 3 is 0 that is when you stop the algorithm. So, when the modulo operator gives you 0 result that means that the shorter number exactly divides the larger number that means that the shorter number is a divisor of the larger number and you stop the algorithm. Now, you say that GCD of 102 and 21 is 3. So, this is a slight modification of the classical Uplits method for GCD and so it is based on the following simple fact which we have described and you can prove this mathematically as well. So, suppose you take two positive numbers A and B where A is the larger number. Then GCD of A and B is the same as GCD of A, GCD of B and the remainder when you divide A by B. So, it is written by the equation GCD of A B is GCD of B comma A modulo B. The modulo operator is represented as the percentage sign because this is the convention that we will use in C and this equation can be seen by our previous slide A was the bigger rod, B was the shorter rod. This was the first stage the second stage was when B is the shorter rod and the shorter rod for the next stage is modulo is given by the modulo operator. To prove this you can start by considering the division of A by B and writing A as B times Q plus R, but we will not go into the proof. From elementary properties of natural numbers it is possible to prove that Uplits method correctly computes the GCD. Right now we will move into how do we write the GCD algorithm in the form of an input. So, here is a slightly abbreviated picture. I have skipped the start state, but the start state is there. Let us focus on what happens during the algorithm. You have two numbers A and B. The first thing to ensure is that A is the larger number. The reason we do that is that if A is the larger number then the modulo operator is properly defined. So if A is the larger number then we are fine we can go into the GCD algorithm. If A is not the larger number you merely swap A and B so that whatever is the larger number you call it A. So exchange A and B means that you say that the value of A is stored in a temporary variable then the value of B is stored in A and then the value of B is stored in T, the value of T is stored in B. So here is a way to exchange the values of A and B. So ensure at first that A is the larger number. Once you do that you get into the code for the proper Euclidean GCD. First you test whether B is 0. If B is 0 then there is nothing to do A is the GCD of A and B. GCD of 4, 0 is 4, GCD of 8, 0 is 8 and so on. So if the smaller number is 0 then there is nothing to do in the algorithm. The algorithm is over and you say that print A. If B is not 0 then we do the Euclidean equation. You take A modulo B, store it in a variable G then assign the value of B to A and assign the value of B to A and assign the value of G to B. So this corresponds to the operation of taking B and A modulo B as the next step. After you do that you again test the condition whether B has now become 0. If it is 0 then we are done and A is the GCD. Otherwise we do another round of taking A modulo B and setting A equal to B and B equal to G. So A B and G are what are known as variables and variables are used in programming to store exactly one value at a time. So at any particular time it will have one value then after the execution of another instruction it will have a new value and so on. Now for the purposes of describing an algorithm imagine that the variable is a box and it is the name of a box and the value is stored inside the box. For example A, B and G are the variables that we have used in the program and they are the names for these integer boxes. So if you are computing let us say the GCD of 5 and 3 then you might start with A equal to 5 and B equal to 3. The second operation that we have used in the code is the assignment operation. So this is what an example of the assignment operator and when we do an assignment what we mean is that you take the left variable which is G in this case and assign it the value of what is the expression on the right hand side which is A mod L O B. So assignment A equal to B replaces whatever is stored in A by what is stored in B. So take the right hand side, take the value of that and put it into the variable that the left hand side represents. For example if A was 5 and B is 3 then we have to say that after A equal to B you would take the value of B and put it in A. So A will now become 3 and B will remain 3. Another small thing that we have used in the code is sequential assignment. So if you write a bunch of statements one after the other let us say separated by semi-colons then this means that the instructions are to be executed one after the other in sequence. So first you do G equal to A mod L O B then you do A equal to B and after that you do B equal to G. So initially let us say that A is 10 and B is 6 G is undefined. After you run the statement G equal to A mod L O B you take 10 mod L O 6 you will have 4 and then A equal to B the value of B will be stored in A so A becomes 6 and then B equal to G the value of G will be stored in B so B will become 4. Now let us just dry run the program on the algorithm and see how it computes the GCD of 2 numbers. So I will denote the currently executing statement with an icon and I will call this the program counter so this is at any point it is the next step to be executed. Initially it is at the beginning of the code where you take the input and we will have 3 variables which will represent the current state of a program. So suppose you want to compute the GCD of 8 and 6 so you have A equal to 8 B equal to 6 you know that is greater than B so you proceed. Now you test whether B is 0. So since B is non-zero you go into the main body of the loop. So you do G equal to A mod L O B A equal to B equal to G this step once so you will end up with A is now 6 B is 2 and G is 2. You again come back to the decision and test whether B is 0 or not B is not 0. So you will get the go back into the body of the loop again. So you have G to be A mod L O B so 6 mod L O 2 should be 0 and then you do A equal to B and B equal to G you will have A equal to 2 B equal to 0 and G equal to 0. At this point B is now 0 so you say that A is actually the GCD of the numbers of the of the numbers 8 and 6. So you can ensure that it computes the GCD correctly.