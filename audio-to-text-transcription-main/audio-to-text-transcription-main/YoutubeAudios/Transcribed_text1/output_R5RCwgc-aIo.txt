 In this session, we will try to code up the C code for finding the length of the longest increasing continuous subsequence. So let us first examine what we need to do. We will write a code and from the previous discussion, we saw that we need at least three variables, one for storing the previous number, one for storing the current number and the third for storing the length of the current decreasing subsequence. So we start by declaring all those three variables and initializing length to 0. So here is a new construct that we are seeing for the first time, which is that when you declare a variable, you can also initialize it immediately by saying length equal to 0. So this is a very intuitive notation. So this will declare a variable and immediately initialize it to 0. So once we declare these three variables, let us say that we scan the first variable into previous. Now let us focus on the main body of the program. If the currently red number is not minus 1, then you say that you start with length 1. So the length of the current increasing subsequence is 1 and then you scan the next number into CURR. So here is the current number. So this part of the code is just to initialize. So if the current, if the first number is minus 1, then there is no point in getting into the program because it is equivalent to the empty input. So there is no increasing subsequence to be found. So we just exit out of the program. So initially we just check to see whether the first number is minus 1 or not. If the first number is not minus 1, you scan the next number. So current will be the second number. And if current is not minus 1, while the currently red number is not minus 1, what you do is exactly the logic that we were discussing before. If the previous number is less than the current number, then you extend the length by 1. So length equal to length plus 1 says that I am continuing the current increasing subsequence by increasing its length. Otherwise that is current is less than or equal to previous. You break the sequence and say length equal to 1. Then we have this step, previous equal to current, which is the advancing both variables by 1. So previous becomes the currently red number and current becomes the next number to be red. So recall from the diagram that previous and current were at some position and we will advance both of them by 1. And when the loop condition is checked next time, we will check whether the current is not getting seen number is minus 1 or not. So far we have coded up part of the logic, which is the part of the logic dealing with when the current, when the next number is red, do we extend the sequence or do we break the sequence and start a new sequence. So this is just part of the work that we need to do to solve the problem. So let us continue with the logic. So let us start with a few boundary cases and let us see whether this works. If it works, we can try your logic on other cases. So let us say that by boundary cases, I mean maybe very long inputs or very short inputs. So these are cases where your code normally breaks. So when you test your code, it is always a good idea to check boundary cases. And one thing that makes programming difficult is that when we do things by hand, we know how to handle the boundary cases elegantly. But in a program, unless you say how to handle the boundary cases, the program might break. And a lot of testing and a lot of errors come from incorrectly handling the boundary cases. So it is always good to handle the boundary cases. Test our code on very small inputs. So let us say that I enter a sequence 5 minus 1. So previous becomes, so length is 0, previous becomes 5. And then since previous is not minus 1, I have used an abbreviation here which is the not equal to operator. This is the same as saying not of previous equal to equal to 1. So previous not equal to 1 is the same as saying not of previous equal to equal to 1. It is an operator in C. This is equal to 1. Then you say that the length is 1 because you have seen 1 number and scan the next number. The next number is minus 1. So you scan the next number and the next number is minus 1. So you break the sequence. So you immediately exit out of the sequence and the length of the increasing sub sequence that we saw. So 5 is the only increasing sub sequence and when we exit it, the length was 1. So we handle the boundary case of an extremely small sequence, a sequence with exactly one element correctly. This gives us confidence that the code could be correct. Of course we have handled only the boundary case. Now we need to test it for other cases as well. So far the program is not doing anything useful because we are just extending the sequence and breaking the sequence. But recall that what we were supposed to do was to find the length of the longest increasing sub sequence. So this is the main thing that we have to do in the logic. So to do this, what we do is something simple. We keep track of the maximum length sequence that we have seen so far. We keep track of the length of the longer sequence that we have seen so far. So we have the current sequence. Now all we need to do is whether to check whether the current sequence is longer than the previously known longest one. So for this, what we do is keep track of the maximum length that we have seen so far. So this is a standard technique in programming and how do I do that? So let us modify the program a little bit. So earlier we resend out that we need at least three variables. Now in order to keep track of the length, the maximum length that we have seen so far, I need a new variable. So this part we have already done before and here is the max length equal to 0. So that is the new variable which is the maximum length that we have seen so far. When we start the program, we have not seen any increasing subsequence and therefore the length of the longest increasing sequence, the current increasing sequence is 0 that is length equal to 0 and the length of the maximum length that we have seen so far is also 0. Then you scan the new number. If the new number is not minus 1, you continue. So length equal to 1. Now max length equal to 1 because currently the longest sequence that we have seen so far is 1, 1 long. You scan the next number. So here is the main body of the loop and what we need to do is the following. If the currently red number is greater than the previous number, we extend the sequence. So this logic is the same as before. Otherwise which means that current number is less than or equal to previous. So we are starting a new sequence. So the situation is the following. We have some max length sequence somewhere in the past. So max length is the length of the sequence that we have seen somewhere in the past. Now we are scanning the sequence. We have a current sequence. And we have decided to break the sequence. So we are now starting a new sequence starting at current. So we are at this part of the logic. So we have decided to start a new sequence. That is because the current sequence is last number is greater than or equal to the current number. So here is previous and this is current. So we are deciding to start a new sequence. What we need to see is whether this sequence is longer than the previously known maximum length. If the sequence that we just stopped is longer than the previously known maximum length sequence. So if max length is less than length, notice that length is the sequence that length of the sequence that we just stopped. Then we say that max length equal to length. So now, if the current sequence is longer than the previously known max length, what we do is that max length becomes the length of this sequence. Otherwise if the current sequence was shorter than the previously known maximum length, we do not do anything. So maximum length is the same.