 In this video we will look at the relation between multi dimensional erase and pointers and this is by far one of the trickiest topics in the entire course and you can code multi dimensional erase without actually understanding the exact relation between multi dimensional erase and pointers. But understanding this gives you a better grasp of how C treats multi dimensional erase. So, we will now discuss how pointer arithmetic works with two dimensional matrices because as soon as we had discussed one dimensional matrices the next thing we did was we discussed two dimensional matrices. We discussed the relation between pointers and one D arrays. So, let us try to see what is the relation between pointers and 2 D arrays. Now, this is more complicated than it looks at first sight and you can do a lot of matrix computations by not understanding this except that understanding this gives you a better grasp of what is happening. We have seen that when you declare a 2 D array as a parameter to a function then you should specify the number of columns but not the number of rows. So, let us look at a function which makes an identity matrix. An identity matrix is a matrix that has one along its diagonal and zero everywhere else. So, we have void make identity 10 and it takes a matrix of size double the number of columns is 10. Since identity matrices are square matrices this essentially says that the code will work for a 10 by 10 matrix. Then I have a for loop going from i equal to 0 to 10 for loop going from for the columns going from j equal to 0 to 10 and the code just says that if I am at a diagonal element that is i equal to j then m i j is 1 for all other elements it m i j is 0. So, this creates a matrix of size 10 by 10. Now, this is a very strange code because it is a function that essentially makes exactly one matrix. It would have been nice if I would have a function that can create arbitrary size identity matrices. For example, if I wanted a 20 by 20 matrix it looks like I have to write another function make identity 20 double m 20. The rows are unspecified the number of columns is 20. This is the standard way to do it, but there is a slightly more complicated way to actually accomplish a function which can take an arbitrary size. So, let us see how these things can be done by understanding how pointer arithmetic works with 2 d arrays. So, let us go back to how do I address the i j th element in a 2 d array. Now, we can view it as a 3 by 5 matrix of integers something like this here. So, it may be an array is 0 1 2 3 4 that is row 0 and 5 6 7 8 9 that is row 1 10 11 12 13 14 that is row 2. So, this is the matrix view which is 3 rows each with 5 columns this is the standard view, but internally see views this as a long linear array of size 15 in what is known as the row major form. So, let us just look at what what it is internally see looks as looks at the array in the following form it is basically 0 0 through 14 laid out in a single row. So, this is the row major view it is called row major because first all elements of row 0 will be laid out then all elements of row 1 will be laid out and finally, all elements of the last row will be laid out, but it is laid out as a linear way. Now, the natural question to ask is in that case is a 2 d array really at the heart of it just a 1 d array. So, the difference between a 2 d array seen in the row major view point and an actual 1 dimensional array will come in the pointer array of it magic. So, as I just mentioned there are 2 views the matrix view and the row major view and both views are correct. So, if I have the matrix view mat is a pointer to the first row. So, mat plus 1 will be a pointer to the second row and mat plus pointer to the second row and mat plus 2 will be a pointer to the third row. So, row number 3 or row indexed with 2 in the row major view point here is the difference mat points to the first row and mat plus 1 should point to the second row. So, we cannot say that mat is pointing to the first element here and mat plus 1 should point to therefore, 1. Now, that is not what happens it has to be consistent with the matrix view. So, the pointer arithmetic mat plus 1 should point to the same element regardless of whether you are looking at it using the matrix view point or whether you are looking at it using the row major view point. So, mat plus 1 will still point to 5 and mat plus 2 will still point to 10. So, these 2 view points are consistent. Now, here is the difference with one dimensional arrays. So, we have just repeated the view points here the matrix view point and the row major view point. Now, had mat actually been a one dimensional array mat would point to the first element in the array therefore, mat plus 1 should point to the second element in the array that is not what happens it is actually the row major representation of a 2 D array and mat plus 1 should skip exactly 5 elements because that is the size of the column. So, mat plus 1 should skip 5 elements and go to the element mat 1 0. So, here is the mat 1 0. So, here is the gist of why you need to know the number of columns because in the row major view point I have to implement mat plus 1. So, I have to say how many elements should I skip in order to get to the first element of the second row. So, how and that number is exactly the number of columns in the array. So, the number of columns in the array is 5. So, to get to mat plus from mat I have to skip 5 elements. Similarly, to get to mat plus 2 from mat plus 1 I have to skip exactly 5 elements. So, this is the reason why the number of columns is an important information because that tells me how many in the row in the row major representation how many elements do I have to skip in order to get to the correct entry in the second row of the third row. So, here is the pointer arithmetic for the row major representation and notice that this is considerably different from the pointer arithmetic for a 1 D array. In a 1 D array array plus 1 will go here the first element of the array. Now, can you try to guess what will be the type of mat. So, here are 4 candidates and let us go through them to see what is the most likely candidate and we will see this in greater detail. In-stare mat mat is a pointer to int. Now, we have seen that that is approximately an array of integers and that is definitely incorrect because this is supposed to be a 2 D array not an array of integers. Pointer to pointer to mat we have not seen that so far and that looks like a likely candidate. So, what about the third and the fourth? So, the third and the fourth looks confusingly similar what do they mean. So, here is a hint the array indexing operator square black edge has higher precedence than star the dereferencing operator. So, in this case the first says that so what does this mean? The first declaration is actually int star mat 5. And the second declaration is int star mat 5. So, what does this say? So, let us compare with the standard declaration like float array 5. This means that array is a r r is an array of size 5 each entry of type float. Similarly, this means that matrix mat is a standard is an array of size 5 each entry being a pointer to integer. So, it will be some matrix like this it has 5 elements and each of them is a pointer. So, here is the view point for declaration 3. Now, what about declaration 4? So, there is a point of the definition let us see this. So, let us compare it with a standard declaration like let us take a standard declaration like int a r r 5. Again this says that a r r is an integer array of size 5. So, it contains 5 elements each of type int correspondingly what this means is that star mat is an integer array. So, here is an integer array containing 5 elements. These are integers. Now, this means that if you dereference mat so, mat is a pointer to an array of size 5 and this is exactly the actual representation of a 2 dimension array. So, notice the difference between these 2 representations the first says that mat 5 mat is an array of 5 entries and each entry is a pointer to an int. So, it looks like this. So, it is an array of 5 pointers to int. The last declaration says that star is an array of int of size 5. So, mat is a pointer to an array of integers of size 5. So, here is the difference and we will argue that the fourth definition is essentially what we want and we will see this in greater detail. So, let us understand these type expressions in greater detail and we will see this in the further video also. We will particularly pick on one representation here. So, we have argued that a 2 d array is similar to the last declaration here. I have eliminated the most obviously wrong declaration which is int star mat that is basically a 1 dimensional array. So, I have just eliminated that we will examine all the others. What I have just said is that a 2 d array is similar to the last declaration, but even the previous 2 declarations do make sense and there may be situations where you need to use such variables. Let us examine them in greater detail. So, let us look at the first one which is in star star mat and it means all of the following equivalent ways. So, all of these are equivalent ways of looking at the same thing. You could say that a mat is of type in star star or you could say that mat is a pointer to a pointer to an int. Since arrays are pointers approximately you could also say that mat is an array of pointers to int and this is also commonly called array of arrays. So, you have mat in star star. Now, this is a pointer to an array of integers. Now, every pointer to an int is essentially a pointer to an array you can look at it like that. So, you can say that mat will point to an array of pointers and this array of pointers each of them may point to a different array. So, you de-reference mat once you will get a pointer to an integer and again you de-reference once more you will get the actual array. So, what happens when I do mat plus 1 it will go to the second entry in the array of integers. Now, that may be a different array altogether. So, mat 00 is similar to star star mat this is just the way address arithmetic works and both of them are addresses both of them are pointing to this location both of them mean the content of this location. Similarly, star star of star mat plus 1 is mat of 0 plus mat of 0 1. So, in the case of one dimensional arrays we have just mentioned the equation that array of I is the same as star of a r r plus I and what we are saying here essentially is that mat i j is the same rule applied twice. So, I could say mat i is star of mat plus I so that will give me an array and then I need the jth element of that. So, we can again do star of star mat plus I plus j. So, this is these are two ways of looking at this array. So, mat plus 1 will be the next element in the pointer to integers and it is the same as and when you dereference it you will get another array. So, in order to get the first element of this array I could say mat 1 0 or using the pointer notation I have star of star mat plus 1. So, these are the same and similarly for other elements of the array. One of the advantages of this kind of in star star mat is that I have freedom in both dimensions. You can see these as the rows of a matrix and these as the columns of a matrix. If you see that then you can see that I have a lot of freedom here. First of all the number of rows is not limited because it is just in star star mat I could have any number of rows here. Now, another main advantage and the reason why this is somewhat popular is that the length of row 0 need not be the same as the length of row 1. These are just pointers to integers. So, the first pointer to integer may be pointing to a row of size 2. The second pointer may be pointing to a row of size 3 and so on. So, the row lengths need not be the same. So, think of an array where row 0 is two elements long and row 1 is has three elements in the row and so on. So, if you have extremely ragged arrays then in star star mat is a nice representation to pick.