 When it comes to C functions, we have seen the following concepts. One is the declaration and the definition of a function by which I mean the declaration is what type is the function, what are the input arguments, what types are the input arguments and what is the result return type. So, these form the declaration definition is the logic of the function. So, this is what is known as the declaration and the definition of the function and we do it only once. So, a function is defined only once. Once we define a function, we can of course, call the function multiple times. So, definition is done only once and calling can be done any number of times. Now, we refer to a stack which is what is the central concept in executing a function. The stack is just a part of the memory that grows only in one direction. So, that is what it is supposed to mean. Basically, you can think of it as a stack of boxes or a stack of paper on your table or a stack of plates. So, it grows in one direction. So, the stack is grows as the main calls a particular function, that function calls as the different function and so on. And you can imagine the stack is growing upwards or growing downwards. It does not matter as functions get called it either keeps growing upwards or keeps going downwards. We will usually represent it as keeping growing downward. So, let us look at this function that we were talking about earlier. So, n choose k is n factorial upon k factorial times n minus k factorial and let us try to code this up. We know that factorial is something that we will need over and over in this program. So, let us say that I will write factorial as a function. So, factorial takes an integer and returns an integer. So, the declaration is int fact int r is the input argument and the return type is int. Now, inside that we will write the code for factorial. All variables declared inside the factorial are local or private to the factorial function. They cannot be seen outside. So, the input argument as well as any variables declared inside factorial are private or local to the factorial function. So, I have i and this encodes the logic of factorial that we have seen earlier. So, you start with the product equal to 1 and keep on multiplying the numbers till you reach r factorial. So, once you reach r, you return the r factorial. This logic is something that we have seen before. Now, we will see how do we put this together in order to produce the function. So, what we need to do is we will just encode up the solution that we have. So, it is factorial n divided by factorial k divided by factorial n minus k. So, here I have encoded just the logic. So, even though division is involved, I know that when I do n c k, the result is always going to be an integer. So, I can declare it as int r s. So, this part is known as the definition of the factorial function. So, this part is what is known as definition and each of these are what are known as calls. Now, we have a function called as n c k, now let us try to see what happens when we execute this program. So, regardless of how many functions have been defined, whenever you start executing a program, it always executes the first line of main. So, let us try to add some temporary variables because we call this function 3 times in this main. Let us try to separate them out into 3 separate calls just for the sake of clarity. So, I will add a slightly larger code, this is not proper c code. Let us say that I have 3 extra variables which I have declared up int t 1, t 2 and t 3. Now, t 1 will be factorial of n, t 2 will be factorial of k and t 3 will be factorial of n minus k. I have separated these out so that I can clearly explain what happens when the code executes. Let us say that I want to calculate 4 c 2. Now, first when the program starts executing, you start with the main on the first line of the, with the code on the first line of the main. So, you scan of n and k, so n is 4 and k is 2. Now, you do t 1 equal to factorial of n. So, when t 1 equal to factorial of n is called, what you do is you set up the return value and return address. So, return value is not yet decided, return address is 5 because you have to go back to line 5 of the code. So, that is why the return value is 5. Also, what do you need to do? You need to copy the parameter value which is 4. So, this is the actual parameter 4 and you have to copy it to the input argument r. So, r is the input argument r should be assigned to the value n here n is 4. So, that is known as passing the argument. Now, once that is done, the code can be seen as jumping to factorial. So, as soon as the function is called, you actually pass the execution to the factorial function. Now, inside the factorial function, you have 2 local variables i and a n s which is answered and we start executing the factorial function. So, let us see what happens when we execute the factorial function. So, far we have passed the arguments and so on. Now, I have just hidden the part of the stack that was used for main and let us focus just on the factorial function. This computes the factorial function that we are familiar with. There is nothing new here. So, it has a variable i which keeps track of how many times it has the loop has executed and r is notice 4. So, you compute the factorial of 4. Finally, when r equal to 4 answer equal to 24. Now, this 24 value, we say return the answer value. So, answer value is 24. So, this will be copied to the return value location. Return value location. So, the return value will get the value 24 and now jump back to return address. So, return address is line 5. So, we will jump back to line 5 and there we will say that t 1 equal to 24. Only the return value is equal to 24. So, this is the return value is copied back to the main program. All other things are irrelevant. So, the correct way to imagine what happens when a function has returned is that the stack that was allocated to main to the execution of fact is completely erased. So, once you go back to main as soon as the function returns back to the main, you should imagine that the entire stack is deleted and only the memory that was originally allocated to main remains. So, the correct way to think about a function executing, you can imagine that you are main and you have a friend who can calculate factorial for you. Now, you can ask your friend to calculate factorial for you and things are done in a very hygienic manner. So, what you do is you write on a piece of paper the number 4 and give it to your friend. Now, your friend is another room. So, he has at his disposal some blackboard. So, he looks at the number 4 and using the private local variables that he has which is I and result or answer, he calculates the factorial of these numbers. Once he does that, he copies the result back onto a piece of paper. So, 4 factorial is 24 and brings it back to you. Before he does that, he raises his blackboard and he will bring back the number 24 on a piece of paper. Now, you can imagine that the space that your friend used to compute 24 has now been wiped clean and all that remains is the value 24 which you can copy back into onto your notebook. So, this allegory tells you exactly what happens in the case of a function execution. You write down what you want the factorial of on a piece of paper, pass it to your friend, he will go to a separate room and he will calculate whatever he wants. Once he does that, he will clean his blackboard, write down the result on a piece of paper and bring that paper back to you. So, as far as you are concerned, you are least bothered with how he is computing the factorial function, all you want is the result and this is the basic way to think about functions. You should be able to reason out a bigger program by saying what does a smaller program, what does a smaller function do regardless of how that function does it. Now, let us get on with the remaining execution. We have just computed factorial of 4. Now, we need to calculate factorial of 2 and factorial of 4 minus 2. So, we go to the next line, the next line also involves a call to factorial of k. So, we do the same things again, we save the return address. Now, the return address is 6 because we are executing line 6, then we create a box for the return value and pass the parameters and finally, jump to the called function. So, we do all that, we have some memory for the main, but we allocate a new stack, new space in the stack for executing factorial. At this point, return address is 6 because it is a second factorial that is being called R is 2 because k is 2 and you execute the factorial function. So, you again go to the factorial function and calculate 2 factorial, 2 factorial is 2. So, that will be transferred back to the return value and now, you can imagine that you will get back to the address 6 where t 2 will have the value 2. So, once you do that, again the thing to imagine is that this slit is wiped clean and all the memory that you allocated to the stack is now free. So, once you are back in main, all you have is the memory for me. Now, there is a third call to factorial, factorial of n minus k and it is done in exactly the same manner. So, without much elaboration, so it will create n minus k is 4 minus 2 which is also 2 and the return address is 7. Here is an n and once you do that, it will execute the factorial code again and calculate the factorial of 2 which is again 2. So, this is the return and return to line 7. So, 2 will be copied as the return value and once the execution finishes, you return to line 7 of the main program. At this point, you say that t 3 equal to 2 and you can imagine that the stack allocated to factorial is now erased. So, at this point, main has t 1 equal to 24, t 2 equal to 2 and t 3 equal to 2. You have all the information that you need in order to calculate your result. So, you calculate 24 divided by 2 divided by 2 and the answer is 6 which is 4 choose 2. So, this illustrates how do you write a function, how do you define a function and how do you call it and what actually happens when you execute a function. So, the execution of a function can be visualized as a stack. A stack is a part of memory that is allocated as private to a new function that is being called. Once that function finishes execution, the stack is erased and you go back to the previous function and you go back to the calling function.