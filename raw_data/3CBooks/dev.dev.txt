The Basics of C Programming
Marshall Brain
Last updated: October 30 <sil=0.556> ,COMMA 2013
The C programming language is a popular and widely used programming language for creating computer programs <sil=0.987> .PERIOD Programmers embrace C because it gives maximum control and efficiency to the programmer <sil=0.991> .PERIOD If you are a programmer <sil=0.573> ,COMMA or if you are interested in becoming a programmer <sil=0.451> ,COMMA there
are a couple of benefits you gain from learning C:
• You will be able to read and write code for a large number of platforms – everything from microcontrollers to the most advanced scientific systems
can be written in C <sil=0.942> .PERIOD • Because of the performance and portability of C <sil=0.627> ,COMMA almost all popular crossplatform programming languages and scripting languages <sil=0.584> ,COMMA such as C++ <sil=0.606> ,COMMA Java <sil=0.616> ,COMMA Python <sil=0.425> ,COMMA Objective-C <sil=0.604> ,COMMA Perl <sil=0.615> ,COMMA Ruby <sil=0.563> ,COMMA PHP <sil=0.385> ,COMMA Lua <sil=0.622> ,COMMA and Bash <sil=0.404> ,COMMA are implemented in C and borrowed syntaxes and functions heavily from C <sil=0.936> .PERIOD They share the similar operators <sil=0.550> ,COMMA expressions <sil=0.389> ,COMMA repetition statements <sil=0.627> ,COMMA control structures <sil=0.611> ,COMMA arrays <sil=0.399> ,COMMA input and output <sil=0.487> ,COMMA and functions <sil=0.946> .PERIOD Furthermore <sil=0.387> ,COMMA almost all languages can interface with C and C++ to take advantage of a large volume of existing C/C++ libraries <sil=0.908> .PERIOD In this article <sil=0.364> ,COMMA we will walk through the entire language and show you how to
become a C programmer <sil=0.502> ,COMMA starting at the beginning <sil=0.925> .PERIOD What is C <sil=0.998> ?QUESTIONMARK C is a computer programming language <sil=0.969> .PERIOD That means that you can use C to create
lists of instructions for a computer to follow <sil=0.983> .PERIOD C is one of thousands of programming languages currently in use <sil=0.925> .PERIOD C has been around for several decades and has won widespread acceptance because it gives programmers maximum control and efficiency <sil=0.992> .PERIOD C is an easy language to learn <sil=0.973> .PERIOD It is a bit more cryptic in its style than some other languages <sil=0.388> ,COMMA but you get beyond that fairly quickly <sil=0.993> .PERIOD C is what is called a compiled language <sil=0.954> .PERIOD This means that once you write your C program <sil=0.511> ,COMMA you must run it through a C compiler to turn your program into an executable that the computer can run (execute) <sil=0.989> .PERIOD The C program is the human-readable form <sil=0.620> ,COMMA while the executable that comes out of the compiler is the machine-readable and executable form <sil=0.969> .PERIOD What this means is that to write and run a C program <sil=0.438> ,COMMA you must have access to a C compiler <sil=0.944> .PERIOD We will start at the beginning with an extremely simple C program and build up from there <sil=0.922> .PERIOD I will assume that you are using the Linux command line and gcc as your environment for these examples <sil=0.451> ;SEMICOLON if you are not <sil=0.460> ,COMMA all of the code will still work fine – you will simply need to understand and use whatever compiler you have available <sil=0.982> .PERIOD The simplest C program <sil=0.350> ,COMMA I
Let’s start with the simplest possible C program and use it both to understand the
basics of C and the C compilation process <sil=0.907> .PERIOD Type the following program into a
standard text editor <sil=0.922> .PERIOD Then save the program to a file named samp <sil=0.948> .PERIOD c <sil=0.952> .PERIOD If you leave
off <sil=0.964> .PERIOD c <sil=0.931> ,COMMA you will probably get some sort of error when you compile it <sil=0.326> ,COMMA so make
sure you remember the <sil=0.951> .PERIOD c <sil=0.901> .PERIOD Also <sil=0.508> ,COMMA make sure that your editor does not automatically
append some extra characters (such as <sil=0.931> .PERIOD txt) to the name of the file <sil=0.903> .PERIOD Here’s the first
program:
#include <stdio <sil=0.951> .PERIOD h>
int main ( void )
{
printf ( " This is output from my first program <sil=0.983> !EXCLAMATIONMARK \ n " ) <sil=0.486> ;SEMICOLON return 0 <sil=0.398> ;SEMICOLON }
Spacing and indentation
When you enter this program <sil=0.574> ,COMMA position #include so that the pound sign is in column 1 (the far left side) <sil=0.971> .PERIOD Otherwise <sil=0.545> ,COMMA the spacing and indentation can be any way you like it <sil=0.932> .PERIOD On some Linux systems <sil=0.521> ,COMMA you will find a program called indent <sil=0.497> ,COMMA which will format code for you <sil=0.941> .PERIOD The spacing and indentation shown above is a good example to follow <sil=0.948> .PERIOD Compilation and run
When executed <sil=0.646> ,COMMA this program instructs the computer to print out the line “This is output from my first program <sil=0.959> !EXCLAMATIONMARK ” – then the program quits <sil=0.940> .PERIOD You can’t get much simpler than that <sil=0.955> !EXCLAMATIONMARK To compile this code on a Linux machine <sil=0.399> ,COMMA type gcc samp <sil=0.970> .PERIOD c −o samp
This line invokes the C compiler called gcc <sil=0.596> ,COMMA asks it to compile samp <sil=0.984> .PERIOD c and asks it
to place the executable file it creates under the name samp <sil=0.958> .PERIOD To run the program <sil=0.371> ,COMMA type <sil=0.998> .PERIOD / samp
You should see the output “This is output from my first program <sil=0.892> !EXCLAMATIONMARK ” when you run
the program <sil=0.987> .PERIOD If you mistype the program <sil=0.324> ,COMMA it either will not compile or it will not run <sil=0.982> .PERIOD If the program does not compile or does not run correctly <sil=0.532> ,COMMA edit it again and see where you went wrong in your typing <sil=0.908> .PERIOD Fix the error and try again <sil=0.979> .PERIOD The simplest C program <sil=0.461> ,COMMA II
Let’s walk through this program and start to see what the different lines are doing:
#include <stdio <sil=0.918> .PERIOD h>
int main ( void )
{
printf ( " This is output from my first program <sil=0.937> !EXCLAMATIONMARK \ n " ) <sil=0.470> ;SEMICOLON return 0 <sil=0.570> ;SEMICOLON }
• This C program starts with #include <stdio <sil=0.997> .PERIOD h> <sil=0.941> .PERIOD This line includes the “standard input/otput library” into your program <sil=0.946> .PERIOD The standard I/O library lets you read input from the keyboard (called “standard in”) <sil=0.372> ,COMMA write output to the screen (called “standard out”) <sil=0.643> ,COMMA process text files stored on the disk <sil=0.580> ,COMMA and so on <sil=0.922> .PERIOD It is an extremely useful library <sil=0.920> .PERIOD C has a large number of standard
libraries like stdio <sil=0.385> ,COMMA including string <sil=0.392> ,COMMA time and math libraries <sil=0.970> .PERIOD A library is simply a package of code that someone else has written to make your life easier (we’ll discuss libraries a bit later) <sil=0.973> .PERIOD • The line int main(void) declares the main function <sil=0.966> .PERIOD Every C program must have a function named main somewhere in the code <sil=0.935> .PERIOD We will learn more about functions shortly <sil=0.990> .PERIOD At run time <sil=0.324> ,COMMA program execution starts at the first line of the main function <sil=0.910> .PERIOD • In C <sil=0.351> ,COMMA the { and } symbols mark the beginning and end of a block of code <sil=0.919> .PERIOD In this case <sil=0.456> ,COMMA the block of code making up the main function contains two lines <sil=0.972> .PERIOD • The printf statement in C allows you to send output to standard out (for us <sil=0.535> ,COMMA the screen) <sil=0.942> .PERIOD The portion in quotes is called the format string and describes how the data is to be formatted when printed <sil=0.998> .PERIOD The format string can contain string literals such as “This is output from my first program <sil=0.893> !EXCLAMATIONMARK  <sil=0.517> ,COMMA ” symbols for carriage returns (\n) <sil=0.392> ,COMMA and operators as placeholders for variables (see below) <sil=0.940> .PERIOD • The return 0 <sil=0.435> ;SEMICOLON line causes the function to return an error code of 0 (no error)
to the shell that started execution <sil=0.917> .PERIOD More on this capability a bit later <sil=0.924> .PERIOD Variables
As a programmer <sil=0.472> ,COMMA you will frequently want your program to “remember” a value <sil=0.972> .PERIOD For example <sil=0.628> ,COMMA if your program requests a value from the user <sil=0.632> ,COMMA or if it calculates a value <sil=0.337> ,COMMA you will want to remember it somewhere so you can use it later <sil=0.935> .PERIOD The way your program remembers things is by using variables <sil=0.975> .PERIOD For example:
int b <sil=0.392> ;SEMICOLON This line says <sil=0.433> ,COMMA “I want to create a space called b that is able to hold one integervalue <sil=0.954> .PERIOD ” A variable has a name (in this case <sil=0.387> ,COMMA b) and a type (in this case <sil=0.424> ,COMMA int <sil=0.349> ,COMMA an integer) <sil=0.980> .PERIOD You can store a value in b by saying something like:
b = 5 <sil=0.576> ;SEMICOLON You can use the value in b by saying something like:
printf ("%d " <sil=0.428> ,COMMA b ) <sil=0.315> ;SEMICOLON In C <sil=0.640> ,COMMA there are several standard types for variables:
• int - integer (whole number) values
• float - floating point values
• char - single character values (such as “m” or “Z”)
We will see examples of these other types as we go along <sil=0.990> .PERIOD Input and output
printf
The printf statement allows you to send output to standard out <sil=0.904> .PERIOD For us <sil=0.481> ,COMMA standard out is generally the screen (although you can redirect standard out into a text file or another command) <sil=0.938> .PERIOD Here is another program that will help you learn more about printf:
#include < stdio <sil=0.976> .PERIOD h>
int main ( void )
{
int a <sil=0.408> ,COMMA b <sil=0.516> ,COMMA c <sil=0.564> ;SEMICOLON a = 5 <sil=0.443> ;SEMICOLON b = 7 <sil=0.493> ;SEMICOLON c = a + b <sil=0.493> ;SEMICOLON printf ("% d + %d = %d \ n " <sil=0.629> ,COMMA a <sil=0.587> ,COMMA b <sil=0.562> ,COMMA c ) <sil=0.521> ;SEMICOLON return 0 <sil=0.594> ;SEMICOLON }
Type this program into a file and save it as add <sil=0.967> .PERIOD c <sil=0.902> .PERIOD Compile it with the line gcc add <sil=0.986> .PERIOD c -o add and then run it by typing <sil=0.917> .PERIOD /add <sil=0.984> .PERIOD You will see the line “5 + 7 = 12” as Output <sil=0.979> .PERIOD Here is an explanation of the different lines in this program:
• The line int a <sil=0.627> ,COMMA b <sil=0.362> ,COMMA c <sil=0.503> ;SEMICOLON declares three integer variables named a <sil=0.636> ,COMMA b and c <sil=0.977> .PERIOD Integer variables hold whole numbers <sil=0.934> .PERIOD • The next line initializes the variable named a to the value 5 <sil=0.904> .PERIOD • The next line sets b to 7 <sil=0.960> .PERIOD • The next line adds a and b and “assigns” the result to c <sil=0.954> .PERIOD The computer adds the value in a (5) to the value in b (7) to form the result 12 <sil=0.649> ,COMMA and then places that new value (12) into the variable c <sil=0.909> .PERIOD The variable c is assigned the value 12 <sil=0.921> .PERIOD For this reason <sil=0.622> ,COMMA the = in this line is called “the assignment operator <sil=0.980> .PERIOD ”
• The printf statement then prints the line “5 + 7 = 12 <sil=0.974> .PERIOD ” The %d placeholders in the printf statement act as placeholders for values <sil=0.976> .PERIOD There are three %d placeholders <sil=0.507> ,COMMA and at the end of the printf line there are the three variable names: a <sil=0.331> ,COMMA b and c <sil=0.979> .PERIOD C matches up the first %d with a and substitutes 5 there <sil=0.993> .PERIOD It matches the second %d with b and substitutes 7 <sil=0.996> .PERIOD It matches the third %d with c and substitutes 12 <sil=0.916> .PERIOD Then it prints the completed line to the screen: 5 + 7 = 12 <sil=0.932> .PERIOD The + <sil=0.408> ,COMMA the = and the spacing are a part of the format line and get embedded automatically between the %d operators as specified by the programmer <sil=0.946> .PERIOD Let’s look at some variations to understand printf completely <sil=0.990> .PERIOD Here is the simplest printf statement:
printf ( "Hello " ) <sil=0.506> ;SEMICOLON This call to printf has a format string that tells printf to send the word “Hello” to standard out <sil=0.911> .PERIOD Contrast it with this:
printf  ( "Hello \n" ) <sil=0.348> ;SEMICOLON The difference between the two is that the second version sends the word “Hello” followed by a carriage return to standard out <sil=0.942> .PERIOD The following line shows how to output the value of a variable using printf <sil=0.955> .PERIOD printf ("% d " <sil=0.335> ,COMMA b ) <sil=0.334> ;SEMICOLON The %d is a placeholder that will be replaced by the value of the variable b when
the printf statement is executed <sil=0.971> .PERIOD Often <sil=0.458> ,COMMA you will want to embed the value within some other words <sil=0.979> .PERIOD One way to accomplish that is like this:
printf ( " The temperature " ) <sil=0.313> ;SEMICOLON printf ("% d " <sil=0.639> ,COMMA b ) <sil=0.510> ;SEMICOLON printf ( "degrees \ n " ) <sil=0.486> ;SEMICOLON An easier way is to say this:
printf ( " The temperature %degrees \ n " <sil=0.319> ,COMMA b ) <sil=0.359> ;SEMICOLON You can also use multiple %d placeholders in one printf statement:
printf ("% d + %d = %d \ n " <sil=0.318> ,COMMA a <sil=0.516> ,COMMA b <sil=0.482> ,COMMA c ) <sil=0.593> ;SEMICOLON In the printf statement <sil=0.488> ,COMMA it is extremely important that the number of operators in the format string corresponds exactly with the number and type of the variables following it <sil=0.948> .PERIOD For example <sil=0.596> ,COMMA if the format string contains three %d operators <sil=0.334> ,COMMA then it must be followed by exactly three parameters and they must have the same types in the same order as those specified by the operators <sil=0.945> .PERIOD You can print all of the normal C types with printf by using different placeholders:
• int (integer values) uses %d
• float (floating point values) uses %f
• char (single character values) uses %c
• character strings (arrays of characters <sil=0.579> ,COMMA discussed later) use %s
You can learn more about the nuances of printf on a Linux machine by typing man
3 printf <sil=0.948> .PERIOD scanf
The previous program is good <sil=0.536> ,COMMA but it would be better if it read in the values 5 and
7 from the user instead of using constants <sil=0.917> .PERIOD Try this program instead:
#include<stdio <sil=0.966> .PERIOD h>
int main ( void )
{
int a <sil=0.433> ,COMMA b <sil=0.304> ,COMMA c <sil=0.526> ;SEMICOLON printf ( " Enter the firstvalue  : " ) <sil=0.372> ;SEMICOLON scanf ("% d " <sil=0.592> ,COMMA &a ) <sil=0.606> ;SEMICOLON printf ( " Enter the second value : " ) <sil=0.413> ;SEMICOLON scanf ("% d " <sil=0.617> ,COMMA &b ) <sil=0.609> ;SEMICOLON c = a + b <sil=0.315> ;SEMICOLON printf("% d + %d = %d \ n " <sil=0.372> ,COMMA a <sil=0.400> ,COMMA b <sil=0.525> ,COMMA c ) <sil=0.525> ;SEMICOLON return 0 <sil=0.386> ;SEMICOLON }
Make the changes <sil=0.631> ,COMMA then compile and run the program to make sure it works <sil=0.969> .PERIOD Note that scanf uses the same sort of format string as printf (type man scanf for more info) <sil=0.922> .PERIOD Also note the & in front of a and b <sil=0.988> .PERIOD This is the address operator in C:
It returns the address of the variable (this will not make sense until we discuss pointers) <sil=0.928> .PERIOD You must use the & operator in scanf on any variable of type char <sil=0.630> ,COMMA int <sil=0.358> ,COMMA or float <sil=0.515> ,COMMA as well as structure types (which we will get to shortly) <sil=0.991> .PERIOD If you leave out the & operator <sil=0.477> ,COMMA you will get an error when you run the program <sil=0.960> .PERIOD Try it so that you can see what that sort of run-time error looks like <sil=0.992> .PERIOD The scanf function allows you to accept input from standard in <sil=0.552> ,COMMA which for us is
generally the keyboard <sil=0.961> .PERIOD The scanf function can do a lot of different things <sil=0.550> ,COMMA but it
is generally unreliable unless used in the simplest ways <sil=0.925> .PERIOD It is unreliable because
it does not handle human errors very well <sil=0.962> .PERIOD But for simple programs it is good
enough and easy-to-use <sil=0.962> .PERIOD The simplest application of scanf looks like this:
scanf ("%d " <sil=0.305> ,COMMA &b ) <sil=0.607> ;SEMICOLON The program will read in an integer value that the user enters on the keyboard (%d
is for integers <sil=0.617> ,COMMA as is printf <sil=0.451> ,COMMA so b must be declared as an int) and place that value
into b <sil=0.930> .PERIOD The scanf function uses the same placeholders as printf:
• int uses %d
• float uses %f
• char uses %c
• character strings (discussed later) use %s
You must put & in front of the variable used in scanf <sil=0.986> .PERIOD The reason why will become clear once you learn about pointers <sil=0.944> .PERIOD It is easy to forget the & sign <sil=0.328> ,COMMA and when you forget it your program will almost always crash when you run it <sil=0.981> .PERIOD In general <sil=0.383> ,COMMA it is best to use scanf as shown here – to read a single value from the keyboard <sil=0.915> .PERIOD Use multiple calls to scanf to read multiple values <sil=0.945> .PERIOD In any real program <sil=0.387> ,COMMA you will use the gets or fgets functions instead to read text a line at a time <sil=0.948> .PERIOD Then you will “parse” the line to read its values <sil=0.959> .PERIOD The reason that you do that is so you can detect errors in the input and handle them as you see fit <sil=0.959> .PERIOD The printf and scanf functions will take a bit of practice to be completely understood <sil=0.453> ,COMMA but once mastered they are extremely useful <sil=0.913> .PERIOD Programming exercise
1 <sil=0.990> .PERIOD Modify the following program so that it accepts three values instead of two
and adds all three together:
# include < stdio <sil=0.934> .PERIOD h>
int main ( v oi d ) {
int a <sil=0.419> ,COMMA b <sil=0.335> ,COMMA c <sil=0.552> ;SEMICOLON printf ( " Enter the first value : " ) <sil=0.438> ;SEMICOLON scanf ("% d " <sil=0.450> ,COMMA &a ) <sil=0.514> ;SEMICOLON printf  ( " Enter the second value : " ) <sil=0.590> ;SEMICOLON scanff ("% d " <sil=0.356> ,COMMA &b ) <sil=0.617> ;SEMICOLON c = a + b <sil=0.457> ;SEMICOLON printf  ("% d + %d = %d \ n " <sil=0.404> ,COMMA a <sil=0.447> ,COMMA b <sil=0.442> ,COMMA c ) <sil=0.320> ;SEMICOLON return 0 <sil=0.443> ;SEMICOLON }
2 <sil=0.972> .PERIOD Try deleting or adding random characters or words in one of the previous programs and watch how the compiler reacts to these errors <sil=0.973> .PERIOD For example <sil=0.452> ,COMMA delete the b variable in the first line of the above program and see what the compiler does when you forget to declare a variable <sil=0.928> .PERIOD Delete a semicolon and see what happens <sil=0.953> .PERIOD Leave out one of the braces <sil=0.930> .PERIOD Remove one of the parentheses next to the main function <sil=0.906> .PERIOD Make each error by itself and then run the program through the compiler to see what happens <sil=0.923> .PERIOD By simulating errors like these <sil=0.316> ,COMMA you can learn about different compiler errors <sil=0.512> ,COMMA and that will make your typos easier to find when you make them for real <sil=0.990> .PERIOD Branching and looping
if statement
Here is a simple C program demonstrating an if statement:
#include < stdio <sil=0.973> .PERIOD h>
int main ( void )
{
int b <sil=0.328> ;SEMICOLON printf ( " Enter a value : " ) <sil=0.632> ;SEMICOLON scanf ("%d " <sil=0.427> ,COMMA &b ) <sil=0.541> ;SEMICOLON if ( b < 0 )
{
printf  ( " The value is negative \ n " ) <sil=0.415> ;SEMICOLON }
return 0 <sil=0.409> ;SEMICOLON }
This program accepts a number from the user <sil=0.995> .PERIOD It then tests the number using an if statement to see if it is less than 0 <sil=0.952> .PERIOD If it is <sil=0.643> ,COMMA the program prints a message <sil=0.975> .PERIOD Otherwise <sil=0.514> ,COMMA the program is silent <sil=0.953> .PERIOD The (b < 0) portion of the program is the Boolean expression <sil=0.913> .PERIOD C evaluates this expression to decide whether or not to print the message <sil=0.914> .PERIOD If the Boolean expression evaluates to True <sil=0.453> ,COMMA then C executes the single line immediately following the if statement (or a block of lines within braces immediately following the if statement) <sil=0.919> .PERIOD If the Boolean expression is False <sil=0.384> ,COMMA then C skips the line or block of lines immediately following the if statement <sil=0.909> .PERIOD Here’s slightly more complex example:
#include <stdio <sil=0.966> .PERIOD h>
int main (void)
{
Int b <sil=0.413> ;SEMICOLON printf ( " Enter a value: " ) <sil=0.622> ;SEMICOLON scanf("% d " <sil=0.581> ,COMMA &b ) <sil=0.576> ;SEMICOLON i f ( b < 0 )
{
printf ( " The value is negative \ n " ) <sil=0.390> ;SEMICOLON }
else if ( b == 0 )
{
printf ( " The value is zero \ n " ) <sil=0.404> ;SEMICOLON }
else
{
printf( " The value positive \ n " ) <sil=0.430> ;SEMICOLON }
return 0 <sil=0.619> ;SEMICOLON }
In this example <sil=0.376> ,COMMA the else if and else sections evaluate for zero and positive values as well <sil=0.918> .PERIOD Boolean expressions
Here is a more complicated Boolean expression: 
i f ( ( x == y ) && ( j > k ) )
{
z = 1 <sil=0.557> ;SEMICOLON }
else
{
q = 1 0 <sil=0.342> ;SEMICOLON }
This statement says <sil=0.351> ,COMMA “If the value in variable x equals the value in variable y <sil=0.487> ,COMMA and if the value in variable j is greater than the value in variable k <sil=0.382> ,COMMA then set the variable z to 1 <sil=0.555> ,COMMA otherwise set the variable q to 10 <sil=0.924> .PERIOD ” You will use if statements like this throughout your C programs to make decisions <sil=0.941> .PERIOD In general <sil=0.566> ,COMMA most of the decisions you make will be simple ones like the first example <sil=0.378> ;SEMICOLON but on occasion <sil=0.481> ,COMMA things get more complicated <sil=0.925> .PERIOD Notice that C uses == to test for equality <sil=0.553> ,COMMA while it uses = to assign a value to a variable <sil=0.931> .PERIOD The && in C represents a Boolean AND operation <sil=0.985> .PERIOD Here are all of the Boolean operators in C:
equality ==
Less than<
Greater than >
<= <=
>= >=
inequality <sil=0.920> !EXCLAMATIONMARK =
and &&
or | |
not <sil=0.965> !EXCLAMATIONMARK = vs == in boolean expressions
The == sign is a problem in C because every now and then you may forget and type just = in Boolean expression <sil=0.976> .PERIOD This is an easy mistake to make <sil=0.563> ,COMMA but to the compiler there is a very important difference <sil=0.907> .PERIOD C will accept either = and == in a Boolean expression – the behavior of the program changes remarkably between
the two <sil=0.568> ,COMMA however <sil=0.987> .PERIOD Boolean expressions evaluate to integers in C <sil=0.577> ,COMMA and integers can be used inside of Boolean expressions <sil=0.985> .PERIOD The integer value 0 in C is False <sil=0.480> ,COMMA while any other integer value is True <sil=0.900> .PERIOD The following is legal in C:
# include <stdio <sil=0.933> .PERIOD h>
int main ( v oi d )
{
int a <sil=0.544> ;SEMICOLON printf ( " Enter a number : " ) <sil=0.507> ;SEMICOLON scanf ("% d " <sil=0.401> ,COMMA &a ) <sil=0.493> ;SEMICOLON if ( a )
{
printf ( " The value is True \ n " ) <sil=0.614> ;SEMICOLON }
return 0 <sil=0.593> ;SEMICOLON }
If a is anything other than 0 <sil=0.422> ,COMMA the printf statement gets executed <sil=0.913> .PERIOD In C <sil=0.529> ,COMMA a statement like if (a = b) means <sil=0.416> ,COMMA "Assign b to a <sil=0.317> ,COMMA and then test a for its Boolean value <sil=0.969> .PERIOD " So if a becomes 0 <sil=0.510> ,COMMA the if statement is False <sil=0.572> ;SEMICOLON otherwise <sil=0.525> ,COMMA it is True <sil=0.979> .PERIOD The value of a changes in the process <sil=0.972> .PERIOD This is not the intended behavior if you meant to type == (although this feature is useful when used correctly) <sil=0.523> ,COMMA so be careful with your = and == usage <sil=0.953> .PERIOD while loop You’ll find that while statements are just as easy to use as if statements <sil=0.979> .PERIOD For
example:
while ( a < b )
{
printf ("% d \ n " <sil=0.631> ,COMMA a ) <sil=0.312> ;SEMICOLON a = a + 1 <sil=0.546> ;SEMICOLON }
This causes the two lines within the braces to be executed repeatedly until a is greater than or equal to b <sil=0.924> .PERIOD The while statement in general works as illustrated to the right <sil=0.978> .PERIOD do-while loop
C also provides a do-while structure:
do
{
printf ("% d \ n " <sil=0.616> ,COMMA a ) <sil=0.398> ;SEMICOLON a = a + 1 <sil=0.501> ;SEMICOLON }
while ( a < b ) <sil=0.443> ;SEMICOLON for loop
The for loop in C is simply a shorthand way of expressing a while statement <sil=0.964> .PERIOD For example <sil=0.557> ,COMMA suppose you have the following code in C:
x = 1 <sil=0.398> ;SEMICOLON while ( x < 1 0 )
{
blah blah blah
x ++ <sil=0.390> ;SEMICOLON / ∗ x++ is the same as saying x = x+1 ∗ /}
You can convert this into a for loop as follows:
f o r ( x = 1 <sil=0.516> ;SEMICOLON x < 1 0 <sil=0.580> ;SEMICOLON x ++)
{
blah blah blah
}
Note that the while loop contains an initialization step (x=1) <sil=0.563> ,COMMA a test step (x<10) <sil=0.435> ,COMMA and an increment step (x++) <sil=0.922> .PERIOD The for loop lets you put all three parts onto one line <sil=0.529> ,COMMA but you can put anything into those three parts <sil=0.932> .PERIOD For example <sil=0.584> ,COMMA suppose you have the following loop:
a = 1 <sil=0.465> ;SEMICOLON b = 6 <sil=0.416> ;SEMICOLON while ( a < b )
{
a ++ <sil=0.454> ;SEMICOLON printf ("% d \ n " <sil=0.362> ,COMMA a ) <sil=0.393> ;SEMICOLON }
You can place this into a for statement as well:
for ( a = 1 <sil=0.352> ,COMMA b = 6 <sil=0.452> ;SEMICOLON a < b <sil=0.507> ;SEMICOLON a ++)
{
printf ("% d \ n " <sil=0.390> ,COMMA a ) <sil=0.581> ;SEMICOLON }
It is slightly confusing <sil=0.391> ,COMMA but it is possible <sil=0.912> .PERIOD The comma operator lets you separate several different statements in the initialization and increment sections of the for loop (but not in the test section) <sil=0.996> .PERIOD Many C programmers like to pack a lot of information into a single line of C code <sil=0.445> ;SEMICOLON but a lot of people think it makes the
code harder to understand <sil=0.582> ,COMMA so they break it up <sil=0.905> .PERIOD Looping: an example
Let’s say that you would like to create a program that prints a Fahrenheit-toCelsius conversion table <sil=0.927> .PERIOD This is easily accomplished with a for loop or a while
loop:
# include < stdio <sil=0.967> .PERIOD h>
int main ( void )
{
int a = 0 <sil=0.585> ;SEMICOLON while ( a <= 100 )
{
printf ("%4 d degrees F = %4d degrees C\ n " <sil=0.452> ,COMMA a <sil=0.356> ,COMMA ( a − 3 2 ) ∗ 5 / 9 ) <sil=0.432> ;SEMICOLON a = a + 1 0 <sil=0.460> ;SEMICOLON }
return 0 <sil=0.514> ;SEMICOLON }
If you run this program <sil=0.430> ,COMMA it will produce a table of values starting at 0 degrees F and ending at 100 degrees F <sil=0.921> .PERIOD The output will look like this:
0 degrees F = −17 degrees C
10 degrees F = −12 degrees C
20 degrees F = −6 degrees C
30 degrees F = −1 degrees C
40 degrees F = 4 degrees C
50 degrees F = 10 degrees C
60 degrees F = 15 degrees C
70 degrees F = 21 degrees C
80 degrees F = 26 degrees C
90 degrees F = 32 degrees C
100 degrees F = 37 degrees C
The table’s values are in increments of 10 degrees <sil=0.917> .PERIOD You can see that you can easily change the starting <sil=0.524> ,COMMA ending or increment values of the table that the program produces <sil=0.947> .PERIOD If you wanted your values to be more accurate <sil=0.483> ,COMMA you could use floating point values
instead:
# include < stdio <sil=0.973> .PERIOD h>
int main ( v oi d )
{
float a = 0 <sil=0.390> ;SEMICOLON while ( a <= 1 0 0 )
{
printf ( "% 6 <sil=0.955> .PERIOD 2 f degrees F = %6 <sil=0.922> .PERIOD 2 f degrees C\ n ") <sil=0.381> ,COMMA a <sil=0.464> ,COMMA ( a − 32 <sil=0.976> .PERIOD 0 ) ∗ 5 <sil=0.962> .PERIOD 0/9 <sil=0.925> .PERIOD 0 ) <sil=0.333> ;SEMICOLON a = a + 1 0 <sil=0.372> ;SEMICOLON }
return 0 <sil=0.480> ;SEMICOLON }
You can see that the declaration for a has been changed to a float <sil=0.587> ,COMMA and the %f symbol replaces the %d symbol in the printf statement <sil=0.986> .PERIOD In addition <sil=0.391> ,COMMA the %f symbol has some formatting applied to it: The value will be printed with six digits
preceding the decimal point and two digits following the decimal point <sil=0.994> .PERIOD Now let’s say that we wanted to modify the program so that the temperature 98 <sil=0.954> .PERIOD 6 is inserted in the table at the proper position <sil=0.967> .PERIOD That is <sil=0.588> ,COMMA we want the table to increment every 10 degrees <sil=0.541> ,COMMA but we also want the table to include an extra line for 98 <sil=0.982> .PERIOD 6 degrees F because that is the normal body temperature for a human being <sil=0.903> .PERIOD The following program accomplishes the goal:
# include < stdio <sil=0.945> .PERIOD h>
int main ( void )
{
float a = 0 <sil=0.581> ;SEMICOLON while ( a <= 100 )
{
if ( a > 98 <sil=0.910> .PERIOD 6 )
{
printf ( "% 6 <sil=0.968> .PERIOD 2 f degrees F = %6 <sil=0.942> .PERIOD 2 f degrees C\ n " <sil=0.631> ,COMMA 98 <sil=0.917> .PERIOD 6 <sil=0.429> ,COMMA ( 98 <sil=0.908> .PERIOD 6 − 32 <sil=0.988> .PERIOD 0 ) ∗ 5 <sil=0.953> .PERIOD 0 / 9 <sil=0.904> .PERIOD 0 ) <sil=0.346> ;SEMICOLON }
printf ( "% 6 <sil=0.996> .PERIOD 2 f degrees F = %6 <sil=0.976> .PERIOD 2 f degrees C\ n " <sil=0.595> ,COMMA a <sil=0.335> ,COMMA ( a − 32 <sil=0.943> .PERIOD 0 ) ∗ 5 <sil=0.950> .PERIOD 0 / 9 <sil=0.931> .PERIOD 0 ) <sil=0.327> ;SEMICOLON a = a + 1 0 <sil=0.305> ;SEMICOLON }
return 0 <sil=0.358> ;SEMICOLON }
This program works if the ending value is 100 <sil=0.397> ,COMMA but if you change the ending value
to 200 you will find that the program has a bug <sil=0.941> .PERIOD It prints the line for 98 <sil=0.915> .PERIOD 6 degrees
too many times <sil=0.929> .PERIOD We can fix that problem in several different ways <sil=0.948> .PERIOD Here is one
way:
# include < stdio <sil=0.939> .PERIOD h>
int main ( void )
{
float a <sil=0.612> ,COMMA b <sil=0.527> ;SEMICOLON a = 0 <sil=0.395> ;SEMICOLON b = −1 <sil=0.395> ;SEMICOLON while ( a <= 100 )
{
if ( ( a > 98 <sil=0.950> .PERIOD 6 ) && ( b < 98 <sil=0.936> .PERIOD 6) )
{
printf ( "% 6 <sil=0.931> .PERIOD 2 f degrees F = %6 <sil=0.940> .PERIOD 2 f degrees C\ n " <sil=0.372> ,COMMA 98 <sil=0.910> .PERIOD 6 <sil=0.562> ,COMMA ( 98 <sil=0.955> .PERIOD 6 − 32 <sil=0.962> .PERIOD 0 ) ∗ 5 <sil=0.939> .PERIOD 0 / 9 <sil=0.947> .PERIOD 0 ) <sil=0.476> ;SEMICOLON }
printf ( "% 6 <sil=0.928> .PERIOD 2 f degrees F = %6 <sil=0.975> .PERIOD 2 f degrees C\ n " <sil=0.338> ,COMMA a <sil=0.574> ,COMMA ( a − 32 <sil=0.970> .PERIOD 0 ) ∗ 5 <sil=0.912> .PERIOD 0 / 9 <sil=0.940> .PERIOD 0 ) <sil=0.505> ;SEMICOLON b = a <sil=0.302> ;SEMICOLON a = a + 1 0 <sil=0.300> ;SEMICOLON }
return 0 <sil=0.407> ;SEMICOLON }
Programming exercise
1 <sil=0.963> .PERIOD Try changing the Fahrenheit-to-Celsius program so that it uses scanf to accept the starting <sil=0.470> ,COMMA ending and increment value for the table from the user <sil=0.958> .PERIOD 2 <sil=0.903> .PERIOD Add a heading line to the table that is produced <sil=0.902> .PERIOD 3 <sil=0.929> .PERIOD Try to find a different solution to the bug fixed by the previous example <sil=0.984> .PERIOD 4 <sil=0.935> .PERIOD Create a table that converts pounds to kilograms or miles to kilometers <sil=0.963> .PERIOD Arrays
In this section <sil=0.455> ,COMMA we will create a small C program that generates 10 random numbers and sorts them <sil=0.919> .PERIOD To do that <sil=0.400> ,COMMA we will use a new variable arrangement called an array <sil=0.931> .PERIOD An array lets you declare and work with a collection of values of the same type <sil=0.909> .PERIOD For example <sil=0.586> ,COMMA you might want to create a collection of five integers <sil=0.937> .PERIOD One way to do it would be to declare five integers directly:
int a <sil=0.595> ,COMMA b <sil=0.627> ,COMMA c <sil=0.934> ,COMMA d <sil=0.602> ,COMMA e <sil=0.435> ;SEMICOLON This is okay <sil=0.648> ,COMMA but what if you needed a thousand integers <sil=0.905> ?QUESTIONMARK An easier way is to declare an array of five integers:
int a [ 5 ] <sil=0.358> ;SEMICOLON The five separate integers inside this array are accessed by an index <sil=0.970> .PERIOD All arrays start at index zero and go to n-1 in C <sil=0.957> .PERIOD Thus <sil=0.340> ,COMMA int a[5] <sil=0.421> ;SEMICOLON contains five elements <sil=0.948> .PERIOD For example:
int a [ 5 ] <sil=0.304> ;SEMICOLON a [ 0 ] = 12 <sil=0.588> ;SEMICOLON a [ 1 ] = 9 <sil=0.313> ;SEMICOLON a [ 2 ] = 14 <sil=0.397> ;SEMICOLON a [ 3 ] = 5 <sil=0.437> ;SEMICOLON a [ 4 ] = 1 <sil=0.417> ;SEMICOLON One of the nice things about array indexing is that you can use a loop to manipulate
the index <sil=0.987> .PERIOD For example <sil=0.387> ,COMMA the following code initializes all of the values in the array
to 0:
int a [ 5 ] <sil=0.450> ;SEMICOLON int i <sil=0.528> ;SEMICOLON for ( i = 0 <sil=0.474> ;SEMICOLON i < 5 <sil=0.396> ;SEMICOLON i ++)
{
a [ i ] = 0 <sil=0.592> ;SEMICOLON }
You declare arrays by inserting an array size after a normal declaration <sil=0.455> ,COMMA as shown
below:
int a [ 10 ] <sil=0.457> ;SEMICOLON / ∗ array of integers ∗ /
chars [ 100 ] <sil=0.350> ;SEMICOLON / ∗array of integers ∗ /
floatf [ 20 ] <sil=0.351> ;SEMICOLON / ∗ a r r a y o f r e a l s ∗ /
structurer [ 5 0 ] <sil=0.405> ;SEMICOLON / ∗ array of records ∗ /
Programming exercise
• In the first piece of code <sil=0.548> ,COMMA try changing the for loop that fills the array to a single line of code <sil=0.986> .PERIOD Make sure that the result is the same as the original
code <sil=0.943> .PERIOD Take the bubble sort code out and put it into its own function <sil=0.988> .PERIOD The function header will be void bubble_sort() <sil=0.985> .PERIOD Then move the variables used by the bubble sort to the function as well <sil=0.532> ,COMMA and make them local there <sil=0.971> .PERIOD Because the array is global <sil=0.639> ,COMMA you do not need to pass parameters <sil=0.940> .PERIOD • Initialize the random number seed to different values <sil=0.924> .PERIOD The following code initializes the values in the array sequentially and then prints
them out:
#include < stdio <sil=0.936> .PERIOD h>
int main ( void )
{
int a [ 5 ] <sil=0.403> ;SEMICOLON int i <sil=0.577> ;SEMICOLON for ( i = 0 <sil=0.488> ;SEMICOLON i < 5 <sil=0.304> ;SEMICOLON i ++)
{
a [ i ] = i <sil=0.427> ;SEMICOLON }
for ( i = 0 <sil=0.391> ;SEMICOLON i < 5 <sil=0.619> ;SEMICOLON i ++)
{
printf ( " a [%d ] = %d \ n " <sil=0.372> ,COMMA i <sil=0.499> ,COMMA a [ i ] ) <sil=0.303> ;SEMICOLON }
}
Arrays are used all the time in C <sil=0.969> .PERIOD To understand a common usage <sil=0.609> ,COMMA start an editor and enter the following code:
# include < s t d i o <sil=0.951> .PERIOD h>
# define MAX 10
int a [MAX] <sil=0.396> ;SEMICOLON int rand_seed = 10 <sil=0.630> ;SEMICOLON / ∗
∗ from K&R − p r o d u c e s an i n t e g e r random number
∗ between 0 and 3 2 7 6 7 <sil=0.987> .PERIOD ∗ /
int  rand ( voi d )
{
rand_seed = rand_seed ∗ 1103515245 + 12345 <sil=0.485> ;SEMICOLON return ( unsigned int ) ( rand_seed / 65536 ) % 32768 <sil=0.489> ;SEMICOLON }
int main ( v oi d )
{
int i <sil=0.557> ,COMMA t <sil=0.559> ,COMMA x <sil=0.442> ,COMMA y <sil=0.340> ;SEMICOLON / ∗ fill array ∗ /
for ( i = 0 <sil=0.350> ;SEMICOLON i < MAX <sil=0.314> ;SEMICOLON i ++)
{
a [ i ] = rand ( ) <sil=0.461> ;SEMICOLON printf ("% d \ n " <sil=0.443> ,COMMA a [ i ] ) <sil=0.394> ;SEMICOLON }
/ ∗ more stuff will go here in a minute ∗ /
return 0 <sil=0.502> ;SEMICOLON }
This code contains several new concepts <sil=0.926> .PERIOD The #define line declares a constant named MAX and sets it to 10 <sil=0.946> .PERIOD Constant names are traditionally written in all caps to make them obvious in the code <sil=0.994> .PERIOD The line int a[MAX] <sil=0.476> ;SEMICOLON shows you how to declare an array of integers in C <sil=0.996> .PERIOD Note that because of the position of the array’s declaration <sil=0.515> ,COMMA it is global to the entire program <sil=0.955> .PERIOD The line int rand_seed=10 also declares a global variable <sil=0.338> ,COMMA this time named rand_seed <sil=0.480> ,COMMA that is initialized to 10 each time the program begins <sil=0.994> .PERIOD This value is the starting seed for the random number code that follows <sil=0.905> .PERIOD In a real random number generator <sil=0.624> ,COMMA the seed should initialize as a random value <sil=0.648> ,COMMA such as the system time <sil=0.942> .PERIOD Here <sil=0.624> ,COMMA the rand function will produce the same values each time you run the program <sil=0.950> .PERIOD The line int rand(void) is a function declaration <sil=0.994> .PERIOD The rand function accepts no
parameters and returns an integer value <sil=0.974> .PERIOD We will learn more about functions later <sil=0.985> .PERIOD The four lines that follow implement the rand function <sil=0.981> .PERIOD We will ignore them for
now <sil=0.955> .PERIOD The main function is normal <sil=0.923> .PERIOD Four local integers are declared <sil=0.396> ,COMMA and the array is filled with 10 random values using a for loop <sil=0.972> .PERIOD Note that the array a contains 10 individual integers <sil=0.981> .PERIOD You point to a specific integer in the array using square brackets <sil=0.914> .PERIOD So a[0] refers to the first integer in the array <sil=0.424> ,COMMA a[1] refers to the second <sil=0.614> ,COMMA and so on <sil=0.918> .PERIOD The line starting with /* and ending with */ is called a comment <sil=0.934> .PERIOD The compiler completely ignores the line <sil=0.929> .PERIOD You can place notes to yourself or other
programmers in comments <sil=0.920> .PERIOD Now add the following code in place of the more stuff <sil=0.981> .PERIOD  <sil=0.978> .PERIOD  <sil=0.902> .PERIOD comment:
/ ∗
∗ bubble sort the array
∗ /
for ( x = 0 <sil=0.507> ;SEMICOLON x < MAX−1 <sil=0.400> ;SEMICOLON x ++)
{
for ( y = 0 <sil=0.503> ;SEMICOLON y < MAX−x−1 <sil=0.323> ;SEMICOLON y ++)
{
if ( a [ y ] > a [ y + 1 ] )
{
t = a [ y ] <sil=0.365> ;SEMICOLON a [ y ] = a [ y + 1 ] <sil=0.534> ;SEMICOLON a [ y +1 ] = t <sil=0.399> ;SEMICOLON }
}
}
/ ∗
∗ print sorted array
∗ /
printf ("−−−−−−−−−−−−−−−−−−−−\n " ) <sil=0.420> ;SEMICOLON f o r ( i = 0 <sil=0.524> ;SEMICOLON i < MAX <sil=0.590> ;SEMICOLON i ++)
{
printf ("% d \ n " <sil=0.435> ,COMMA a [ i ] ) <sil=0.643> ;SEMICOLON }
This code sorts the random values and prints them in sorted order <sil=0.923> .PERIOD Each time you run it <sil=0.497> ,COMMA you will get the same values <sil=0.929> .PERIOD If you would like to change the values that are sorted <sil=0.639> ,COMMA change the value of rand_seed each time you run the program <sil=0.925> .PERIOD The only easy way to truly understand what this code is doing is to execute it “by hand <sil=0.963> .PERIOD ” That is <sil=0.335> ,COMMA assume MAX is 4 to make it a little more manageable <sil=0.596> ,COMMA take out a sheet of paper and pretend you are the computer <sil=0.911> .PERIOD Draw the array on your paper and put four random <sil=0.317> ,COMMA unsorted values into the array <sil=0.909> .PERIOD Execute each line of the sorting section of the code and draw out exactly what happens <sil=0.923> .PERIOD You will find that <sil=0.394> ,COMMA each time through the inner loop <sil=0.583> ,COMMA the larger values in the array are pushed toward the bottom of the array and the smaller values bubble up toward the top <sil=0.942> .PERIOD Variable Types
There are three standard variable types in C:
• Integer: int
• Floating point: float
• Character: char
An int is a 4-byte integer value <sil=0.930> .PERIOD A float is a 4-byte floating point value <sil=0.920> .PERIOD A char is a 1-byte single character (like “a” or “3”) <sil=0.930> .PERIOD A string is declared as an array of characters <sil=0.926> .PERIOD There are a number of derivative types:
• double (8-byte floating point value)
• short (2-byte integer)
• unsigned short or unsigned int (positive integers <sil=0.439> ,COMMA no sign bit)
Typecasting
C allows you to perform type conversions on the fly <sil=0.969> .PERIOD You do this especially often when using pointers <sil=0.928> .PERIOD Typecasting also occurs during the assignment operation for certain types <sil=0.966> .PERIOD For example <sil=0.603> ,COMMA in the code above <sil=0.609> ,COMMA the integer value was automatically converted to a float <sil=0.909> .PERIOD You do typecasting in C by placing the type name in parentheses and putting it in front of the value you want to change <sil=0.950> .PERIOD Thus <sil=0.605> ,COMMA in the above code <sil=0.381> ,COMMA replacing the line a = 10/3 <sil=0.367> ;SEMICOLON with a = (float)10/3 <sil=0.601> ;SEMICOLON produces 3 <sil=0.952> .PERIOD 33333 as the result because 10 is converted to a floating point value before the division <sil=0.972> .PERIOD Typedef
You declare named <sil=0.429> ,COMMA user-defined types in C with the typedef statement <sil=0.972> .PERIOD The following example shows a type that appears often in C code:
# define TRUE 1
# define FALSE 0
typedef int boolean <sil=0.456> ;SEMICOLON int main ( v oi d )
{
boolean b <sil=0.335> ;SEMICOLON b = FALSE <sil=0.541> ;SEMICOLON Blah blah blah
}
This code allows you to declare Boolean types in C programs <sil=0.912> .PERIOD If you do not like the word “float” for real numbers <sil=0.626> ,COMMA you can say:
typedef float real <sil=0.548> ;SEMICOLON and then later say:
real r1 <sil=0.623> ,COMMA r2 <sil=0.431> ,COMMA r3 <sil=0.323> ;SEMICOLON You can place typedef statements anywhere in a C program as long as they come prior to their first use in the code <sil=0.922> .PERIOD Operators
The operators in C are similar to the operators in most languages:
+ − addition
− − subtraction
/ − division
∗ − multiplication
\% − mod
The / operator performs integer division if both operands are integers <sil=0.506> ,COMMA and performs floating point division otherwise <sil=0.995> .PERIOD For example:
int main ( v oi d )
{
float a <sil=0.593> ;SEMICOLON a = 10 / 3 <sil=0.402> ;SEMICOLON printf ("% f \ n " <sil=0.499> ,COMMA a ) <sil=0.531> ;SEMICOLON return 0 <sil=0.615> ;SEMICOLON }
This code prints out a floating point value since a is declared as type float <sil=0.492> ,COMMA but a will be 3 <sil=0.985> .PERIOD 0 because the code performed an integer division <sil=0.923> .PERIOD Operator precedence <sil=0.356> ,COMMA I
Operator precedence in C is also similar to that in most other languages <sil=0.946> .PERIOD Division
and multiplication occur first <sil=0.621> ,COMMA then addition and subtraction <sil=0.993> .PERIOD The result of the
calculation 5+3*4 is 17 <sil=0.596> ,COMMA not 32 <sil=0.394> ,COMMA because the * operator has higher precedence
than + in C <sil=0.992> .PERIOD You can use parentheses to change the normal precedence ordering:
(5+3)*4 is 32 <sil=0.972> .PERIOD The 5+3 is evaluated first because it is in parentheses <sil=0.992> .PERIOD We’ll get
into precedence later – it becomes somewhat complicated in C once pointers are
introduced <sil=0.954> .PERIOD Incrementing
Long Way Short Way
i = i + 1 <sil=0.321> ;SEMICOLON i ++ <sil=0.529> ;SEMICOLON i = i − 1 <sil=0.468> ;SEMICOLON i −− <sil=0.531> ;SEMICOLON i = i + 3 <sil=0.520> ;SEMICOLON i += 3 <sil=0.442> ;SEMICOLON i = i ∗ j <sil=0.352> ;SEMICOLON i ∗= j <sil=0.516> ;SEMICOLON Programming exercise
• Try out different pieces of code to investigate typecasting and precedence <sil=0.975> .PERIOD Try out int <sil=0.497> ,COMMA char <sil=0.535> ,COMMA float <sil=0.631> ,COMMA and so on <sil=0.927> .PERIOD • Create an array of records and write some code to sort that array on one
integer field <sil=0.972> .PERIOD Functions
Most languages allow you to create functions of some sort <sil=0.925> .PERIOD Functions let you chop up a long program into named sections so that the sections can be reused throughout the program <sil=0.985> .PERIOD Functions accept parameters and return a result <sil=0.978> .PERIOD C functions can accept an unlimited number of parameters <sil=1.000> .PERIOD In general <sil=0.351> ,COMMA C does not care in what order you put your functions in the program <sil=0.434> ,COMMA so long as a the function name is known to the compiler before it is called <sil=0.915> .PERIOD We have already talked a little about functions <sil=0.940> .PERIOD The rand function seen previously is about as simple as a function can get <sil=0.986> .PERIOD It accepts no parameters and returns an integer result:
int rand ( void )
/ ∗
∗ from K&R − produces an integer random number
∗ between 0 and 32767 <sil=0.955> .PERIOD ∗ /
{
rand_seed = rand_seed ∗ 1103515245 + 12345 <sil=0.420> ;SEMICOLON return ( unsigned int ) ( rand_seed / 65536 ) % 32768 <sil=0.337> ;SEMICOLON }
The int rand() line declares the function rand to the rest of the program and specifies that rand will accept no parameters and return an integer result <sil=0.962> .PERIOD This function has no local variables <sil=0.322> ,COMMA but if it needed locals <sil=0.525> ,COMMA they would go right below the opening { (C allows you to declare variables after any { – they exist until the program reaches the matching } and then they disappear <sil=0.906> .PERIOD A function’s local variables therefore vanish as soon as the matching } is reached in the function <sil=0.910> .PERIOD While they exist <sil=0.633> ,COMMA local variables live on the system stack <sil=0.909> .PERIOD ) Note that there is no <sil=0.327> ;SEMICOLON after the () in the first line <sil=0.923> .PERIOD If you accidentally put one in <sil=0.341> ,COMMA you will get a huge cascade of error messages from the compiler that make no sense <sil=0.943> .PERIOD Also note that even though there are no parameters <sil=0.330> ,COMMA you must use the () <sil=0.997> .PERIOD They tell the compiler that you are declaring a function rather than simply declaring an int <sil=0.962> .PERIOD The return statement is important to any function that returns a result <sil=0.994> .PERIOD It specifies the value that the function will return and causes the function to exit immediately <sil=0.910> .PERIOD This means that you can place multiple return statements in the function to give it multiple exit points <sil=0.994> .PERIOD If you do not place a return statement in a function <sil=0.356> ,COMMA the function returns when it reaches } and returns a random value (many compilers will warn you if you fail to return a specific value) <sil=0.908> .PERIOD In C <sil=0.583> ,COMMA a function can return values of any type: int <sil=0.496> ,COMMA float <sil=0.384> ,COMMA char <sil=0.646> ,COMMA struct <sil=0.446> ,COMMA etc <sil=0.965> .PERIOD There are several correct ways to call the rand function <sil=0.983> .PERIOD For example: x=rand() <sil=0.630> ;SEMICOLON  <sil=0.341> .PERIOD The variable x is assigned the value returned by rand in this statement <sil=0.947> .PERIOD Note that you must use () in the function call <sil=0.492> ,COMMA even though no parameter is passed <sil=0.909> .PERIOD Otherwise <sil=0.498> ,COMMA x is given the memory address of the rand function <sil=0.608> ,COMMA which is generally not what you intended <sil=0.935> .PERIOD You might also call rand this way:
if ( rand () > 100 )
Or this way:
rand () <sil=0.420> ;SEMICOLON In the latter case <sil=0.484> ,COMMA the function is called but the value returned by rand is discarded <sil=0.923> .PERIOD You may never want to do this with rand <sil=0.468> ,COMMA but many functions return some kind of error code through the function name <sil=0.493> ,COMMA and if you are not concerned with the error code (for example <sil=0.354> ,COMMA because you know that an error is impossible) you can discard it in this way Functions can use a void return type if you intend to return nothing <sil=0.967> .PERIOD For example:
void print_header ( )
{
printf ( " Program Number 1 \ n " ) <sil=0.556> ;SEMICOLON printf ( " by Marshall Brain \ n " ) <sil=0.594> ;SEMICOLON printf( "  version1 <sil=0.902> .PERIOD 0 <sil=0.500> ,COMMA released 12 / 26 / 91 \ n " ) <sil=0.473> ;SEMICOLON }
This function returns no value <sil=0.905> .PERIOD You can call it with the following statement:
print _header ( ) <sil=0.468> ;SEMICOLON You must include () in the call <sil=0.984> .PERIOD If you do not <sil=0.489> ,COMMA the function is not called <sil=0.464> ,COMMA even though it will compile correctly on many systems <sil=0.921> .PERIOD C functions can accept parameters of any type <sil=0.938> .PERIOD For example:
int fact ( int i )
{
int j <sil=0.506> ,COMMA k <sil=0.453> ;SEMICOLON j = 1 <sil=0.388> ;SEMICOLON for ( k = 2 <sil=0.649> ;SEMICOLON k <= i <sil=0.341> ;SEMICOLON k ++)
{
j = j ∗k <sil=0.620> ;SEMICOLON }
Return j <sil=0.643> ;SEMICOLON }
returns the factorial of i <sil=0.587> ,COMMA which is passed in as an integer parameter <sil=0.932> .PERIOD Separate multiple parameters with commas:
int add ( i n t i <sil=0.645> ,COMMA i n t j )
{
return i + j <sil=0.625> ;SEMICOLON }
C has evolved over the years <sil=0.932> .PERIOD You will sometimes see functions such as add
written in the “old style <sil=0.437> ,COMMA ” as shown below:
int add ( i <sil=0.417> ,COMMA j )
int i <sil=0.403> ;SEMICOLON int j <sil=0.337> ;SEMICOLON {
return i + j <sil=0.404> ;SEMICOLON }
It is important to be able to read code written in the older style <sil=0.929> .PERIOD There is no difference in the way it executes <sil=0.603> ;SEMICOLON it is just a different notation <sil=0.984> .PERIOD You should use the “new style <sil=0.516> ,COMMA ” (known as ANSI C) with the type declared as part of the parameter list <sil=0.557> ,COMMA unless you know you will be shipping the code to someone who has access only to an “old style” (non-ANSI) compiler <sil=0.904> .PERIOD Programming exercise
• Go back to the bubble sort example presented earlier and create a function
for the bubble sort <sil=0.940> .PERIOD • Go back to earlier programs and create a function to get input from the user rather than taking the input in the main function <sil=0.901> .PERIOD Function prototypes
It is considered good form to use function prototypes for all functions in your program <sil=0.973> .PERIOD A prototype declares the function name <sil=0.355> ,COMMA its parameters <sil=0.588> ,COMMA and its return type to the rest of the program prior to the function’s actual declaration <sil=0.901> .PERIOD To understand why function prototypes are useful <sil=0.590> ,COMMA enter the following code and run it:
# include < stdio <sil=0.953> .PERIOD h>
int main ( v oi d )
{
printf ("% d \ n " <sil=0.457> ,COMMA add ( 3 ) ) <sil=0.633> ;SEMICOLON return 0 <sil=0.445> ;SEMICOLON }
int add ( int i <sil=0.508> ,COMMA int j )
{
return i + j <sil=0.441> ;SEMICOLON }
This code compiles on many compilers without giving you a warning <sil=0.588> ,COMMA even though add expects two parameters but receives only one <sil=0.943> .PERIOD It works because many C compilers do not check for parameter matching either in type or count <sil=0.997> .PERIOD You can waste an enormous amount of time debugging code in which you are simply passing one too many or too few parameters by mistake <sil=0.953> .PERIOD The above code compiles properly <sil=0.506> ,COMMA but it produces the wrong answer <sil=0.983> .PERIOD To solve this problem <sil=0.537> ,COMMA C lets you place function prototypes at the beginning of (actually <sil=0.636> ,COMMA anywhere in) a program <sil=0.988> .PERIOD If you do so <sil=0.604> ,COMMA C checks the types and counts of all parameter lists <sil=0.980> .PERIOD Try compiling the following:
# include <stdio <sil=0.947> .PERIOD h>
int add ( int <sil=0.416> ,COMMA int ) <sil=0.368> ;SEMICOLON / ∗ function prototype for add ∗ /
int main ( void )
{
printf ("% d \ n " <sil=0.467> ,COMMA add ( 3 ) ) <sil=0.646> ;SEMICOLON return 0 <sil=0.551> ;SEMICOLON }
int add ( int i <sil=0.334> ,COMMA int j )
{
return i + j <sil=0.369> ;SEMICOLON }
The prototype causes the compiler to flag an error on the printf statement <sil=0.914> .PERIOD Place one prototype for each function at the beginning of your program <sil=0.956> .PERIOD They can save you a great deal of debugging time <sil=0.475> ,COMMA and they also solve the problem you get when you compile with functions that you use before they are declared <sil=0.945> .PERIOD For example <sil=0.558> ,COMMA the following code will not compile:
# include <stdio <sil=0.904> .PERIOD h>
int main ( void )
{
print f ("% d \ n " <sil=0.585> ,COMMA add ( 3 ) ) <sil=0.590> ;SEMICOLON return 0 <sil=0.423> ;SEMICOLON }
float add ( int i <sil=0.330> ,COMMA int j )
{
return i + j <sil=0.396> ;SEMICOLON }
Why <sil=0.608> ,COMMA you might ask <sil=0.529> ,COMMA will it compile when add returns an int but not when it returns a float <sil=0.913> ?QUESTIONMARK Because older C compilers default to an int return value <sil=0.902> .PERIOD Using a prototype will solve this problem <sil=0.959> .PERIOD “Old style” (non-ANSI) compilers allow prototypes <sil=0.508> ,COMMA but the parameter list for the prototype must be empty <sil=0.939> .PERIOD Old style compilers do no error checking on parameter lists <sil=0.989> .PERIOD Structures
Structures in C allow you to group variable into a package <sil=0.945> .PERIOD Here’s an example:
struct rec
{
int a <sil=0.378> ,COMMA b <sil=0.463> ,COMMA c <sil=0.373> ;SEMICOLON float d <sil=0.495> ,COMMA e <sil=0.442> ,COMMA f <sil=0.554> ;SEMICOLON } <sil=0.325> ;SEMICOLON struct rec <sil=0.636> ;SEMICOLON As shown here <sil=0.625> ,COMMA whenever you want to declare structures of the type rec <sil=0.597> ,COMMA you have
to say struct rec <sil=0.988> .PERIOD This line is very easy to forget <sil=0.580> ,COMMA and you get many compiler
errors because you absent-mindedly leave out the struct <sil=0.961> .PERIOD You can compress the
code into the form:
struct rec
{
int a <sil=0.480> ,COMMA b <sil=0.597> ,COMMA c <sil=0.574> ;SEMICOLON float d <sil=0.580> ,COMMA e <sil=0.561> ,COMMA f <sil=0.601> ;SEMICOLON } r <sil=0.472> ;SEMICOLON where the type declaration for rec and the variable r are declared in the same
statement <sil=0.915> .PERIOD Or you can create a typedef statement for the structure name <sil=0.901> .PERIOD For
example <sil=0.312> ,COMMA if you do not like saying struct rec r every time you want to declare a
record <sil=0.581> ,COMMA you can say:
typedef structrec rec_type <sil=0.596> ;SEMICOLON and then declare records of type rec_type by saying:
rec_typer <sil=0.468> ;SEMICOLON You access fields of structure using a period <sil=0.466> ,COMMA for example <sil=0.394> ,COMMA r <sil=0.902> .PERIOD a = 5 <sil=0.366> ;SEMICOLON  <sil=0.333> .PERIOD Libraries
Libraries are very important in C because the C language supports only the most basic features that it needs <sil=0.955> .PERIOD C does not even contain I/O functions to read from the keyboard and write to the screen <sil=0.939> .PERIOD Anything that extends beyond the basic language must be written by a programmer <sil=0.909> .PERIOD The resulting chunks of code are often placed in libraries to make them easily reusable <sil=0.996> .PERIOD We have seen the standard I/O <sil=0.428> ,COMMA or stdio <sil=0.552> ,COMMA library already: Standard libraries exist for standard I/O <sil=0.422> ,COMMA math functions <sil=0.339> ,COMMA string handling <sil=0.410> ,COMMA time manipulation <sil=0.491> ,COMMA and so on <sil=0.972> .PERIOD You can use libraries in your own
programs to split up your programs into modules <sil=0.907> .PERIOD This makes them easier to understand <sil=0.339> ,COMMA test <sil=0.532> ,COMMA and debug <sil=0.386> ,COMMA and also makes it possible to reuse code from other programs that you write <sil=0.943> .PERIOD You can create your own libraries easily <sil=0.954> .PERIOD As an example <sil=0.328> ,COMMA we will take some code from a previous article in this series and make a library out of two of its functions <sil=0.947> .PERIOD Here’s the code we will start with:
#include <stdio <sil=0.906> .PERIOD h>
#define MAX 10
int a [MAX] <sil=0.357> ;SEMICOLON int rand_seed = 10 <sil=0.422> ;SEMICOLON int rand ( void )
/ ∗
∗ from K&R − p r o d u c e s an i n t e g e r random number
∗ between 0 and 32767 <sil=0.995> .PERIOD ∗ /
{
rand_seed =  rand_seed ∗ 1103515245 +12345 <sil=0.626> ;SEMICOLON return ( unsigned int ) ( rand_seed / 65536 ) % 32768 <sil=0.476> ;SEMICOLON }
int main ( void )
{
int i <sil=0.414> ,COMMA t <sil=0.324> ,COMMA x <sil=0.414> ,COMMA y <sil=0.479> ;SEMICOLON / ∗ fill array ∗ /
for ( i = 0 <sil=0.623> ;SEMICOLON i < MAX <sil=0.341> ;SEMICOLON i ++)
{
a [ i ] = rand ( ) <sil=0.489> ;SEMICOLON printf ("% d \ n " <sil=0.624> ,COMMA a [ i ] ) <sil=0.384> ;SEMICOLON }
/ ∗ bubble sort the array ∗ /
f o r ( x = 0 <sil=0.338> ;SEMICOLON x < MAX−1 <sil=0.313> ;SEMICOLON x ++)
{
for ( y = 0 <sil=0.613> ;SEMICOLON y < MAX−x−1 <sil=0.426> ;SEMICOLON y ++)
{
if ( a [ y ] > a [ y + 1 ] )
{
t = a [ y ] <sil=0.479> ;SEMICOLON a [ y ] = a [ y + 1 ] <sil=0.395> ;SEMICOLON a [ y +1 ] = t <sil=0.491> ;SEMICOLON }
}
}
/ ∗ print sorted array ∗ /
printf ("−−−−−−−−−−−−−−−−−−−−\n " ) <sil=0.635> ;SEMICOLON for ( i = 0 <sil=0.383> ;SEMICOLON i < MAX <sil=0.577> ;SEMICOLON i ++)
{
printf ("% d \ n " <sil=0.582> ,COMMA a [ i ] ) <sil=0.346> ;SEMICOLON }
return 0 <sil=0.625> ;SEMICOLON }
This code fills an array with random numbers <sil=0.509> ,COMMA sorts them using a bubble sort <sil=0.633> ,COMMA and
then displays the sorted list <sil=0.930> .PERIOD Take the bubble sort code <sil=0.430> ,COMMA and use what you learned in the previous article to make a function from it <sil=0.964> .PERIOD Since both the array a and the constant MAX are known globally <sil=0.514> ,COMMA the function you create needs no parameters <sil=0.533> ,COMMA nor does it need to return a result <sil=0.923> .PERIOD However <sil=0.468> ,COMMA you should use local variables for x <sil=0.457> ,COMMA y <sil=0.535> ,COMMA and t <sil=0.958> .PERIOD Once you have tested the function to make sure it is working <sil=0.403> ,COMMA pass in the number
of elements as a parameter rather than using MAX:
#include<stdio <sil=0.978> .PERIOD h>
# define MAX 10
int a [MAX] <sil=0.513> ;SEMICOLON int rand_seed = 10 <sil=0.583> ;SEMICOLON / ∗
∗ from K&R − produces an integer random number
∗ between 0 and 32767 <sil=0.924> .PERIOD ∗ /
int rand ( void )
{
rand_seed = rand_seed ∗ 1103515245 + 12345 <sil=0.313> ;SEMICOLON return ( unsigned int ) (rand_seed  / 65536 ) % 32768 <sil=0.316> ;SEMICOLON }
void bubble_sort ( int m)
{
int x <sil=0.507> ,COMMA y <sil=0.607> ,COMMA t <sil=0.549> ;SEMICOLON for ( x = 0 <sil=0.485> ;SEMICOLON x < m−1 <sil=0.590> ;SEMICOLON x ++)
{
for ( y = 0 <sil=0.575> ;SEMICOLON y < m−x−1 <sil=0.473> ;SEMICOLON y ++)
{
i f ( a [ y ] > a [ y + 1 ] )
{
t = a [ y ] <sil=0.642> ;SEMICOLON a [ y ] = a [ y + 1 ] <sil=0.558> ;SEMICOLON a [ y +1 ] = t <sil=0.500> ;SEMICOLON }
}
}
}
int main ( v oi d )
{
int i <sil=0.333> ,COMMA t <sil=0.486> ,COMMA x <sil=0.325> ,COMMA y <sil=0.499> ;SEMICOLON / ∗ fill array ∗ /
for ( i = 0 <sil=0.482> ;SEMICOLON i < MAX <sil=0.439> ;SEMICOLON i ++)
{
a [ i ] = rand ( ) <sil=0.504> ;SEMICOLON printf ("% d \ n " <sil=0.372> ,COMMA a [ i ] ) <sil=0.480> ;SEMICOLON }
bubble_sort (MAX) <sil=0.565> ;SEMICOLON / ∗ print sorted array ∗ /
printf ("−−−−−−−−−−−−−−−−−−−−\n " ) <sil=0.414> ;SEMICOLON for ( i = 0 <sil=0.457> ;SEMICOLON i < MAX <sil=0.449> ;SEMICOLON i ++)
{
printf ("% d \ n " <sil=0.575> ,COMMA a [ i ] ) <sil=0.628> ;SEMICOLON }
return 0 <sil=0.603> ;SEMICOLON }
You can also generalize the bubble_sort function even more by passing in a as a parameter:
bubble_sort ( int m <sil=0.426> ,COMMA int a [ ] )
This line says <sil=0.633> ,COMMA “Accept the integer array a of any size as a parameter <sil=0.951> .PERIOD ” Nothing in the body of the bubble_sort function needs to change <sil=0.919> .PERIOD To call bubble_sort <sil=0.638> ,COMMA change the call to:
bubble_sort (MAX <sil=0.490> ,COMMA a ) <sil=0.622> ;SEMICOLON Note that & a has not been used in the function call even though the sort will change a <sil=0.956> .PERIOD The reason for this will become clear once you understand pointers <sil=0.958> .PERIOD Making a library
Since the rand and bubble_sort functions in the previous program are useful <sil=0.356> ,COMMA you
will probably want to reuse them in other programs you write <sil=0.940> .PERIOD You can put them into a utility library to make their reuse easier <sil=0.906> .PERIOD Every library consists of two parts: a header file and the actual code file <sil=0.952> .PERIOD The header file <sil=0.353> ,COMMA normally denoted by a <sil=0.932> .PERIOD h suffix <sil=0.637> ,COMMA contains information about the library that programs using it need to know <sil=0.967> .PERIOD In general <sil=0.635> ,COMMA the header file contains constants and types <sil=0.636> ,COMMA along with prototypes for functions available in the library <sil=0.959> .PERIOD Enter the following header file and save it to a file named util <sil=0.997> .PERIOD h <sil=0.934> .PERIOD / ∗ util <sil=0.973> .PERIOD h ∗ /
extern int rand ( ) <sil=0.392> ;SEMICOLON Extern void bubble_sort ( int <sil=0.399> ,COMMA int [ ] ) <sil=0.385> ;SEMICOLON These two lines are function prototypes <sil=0.944> .PERIOD The word “extern” in C represents functions that will be linked in later <sil=0.922> .PERIOD Enter the following code into a file named util <sil=0.923> .PERIOD c <sil=0.995> .PERIOD / ∗ util <sil=0.942> .PERIOD c ∗ /
#include "util <sil=0.943> .PERIOD h"
intrand_ seed = 10 <sil=0.578> ;SEMICOLON / ∗
∗ from K&R − produces an integer random number
∗ between 0 and 32767 <sil=0.998> .PERIOD ∗ /
int rand ( void )
{
rand_seed = rand_seed ∗ 1103515245 + 12345 <sil=0.631> ;SEMICOLON return ( unsigned int ) ( rand_seed / 65536 ) % 32768 <sil=0.454> ;SEMICOLON }
void bubble_sort ( int m <sil=0.597> ,COMMA int a [ ] )
{
int x <sil=0.644> ,COMMA y <sil=0.446> ,COMMA t <sil=0.547> ;SEMICOLON for ( x = 0 <sil=0.306> ;SEMICOLON x < m−1 <sil=0.616> ;SEMICOLON x ++)
{
for ( y = 0 <sil=0.569> ;SEMICOLON y < m−x−1 <sil=0.618> ;SEMICOLON y ++)
{
if ( a [ y ] > a [ y + 1 ] )
{
t = a [ y ] <sil=0.625> ;SEMICOLON a [ y ] = a [ y + 1 ] <sil=0.329> ;SEMICOLON a [ y +1 ] = t <sil=0.590> ;SEMICOLON }
}
}
}
Note that the file includes its own header file (util <sil=0.930> .PERIOD h) and that it uses quotes instead of the symbols <and> <sil=0.616> ,COMMA which are used only for system libraries <sil=0.913> .PERIOD As you can see <sil=0.556> ,COMMA this looks like normal C code <sil=0.980> .PERIOD Note that the variable rand_seed <sil=0.642> ,COMMA because it is not in the header file <sil=0.477> ,COMMA cannot be seen or modified by a program using this library <sil=0.928> .PERIOD This is called information hiding <sil=0.957> .PERIOD Adding the word static in front of int enforces the hiding completely <sil=0.988> .PERIOD Enter the following main program in a file named main <sil=0.996> .PERIOD c <sil=0.939> .PERIOD # include < stdio <sil=0.989> .PERIOD h>
# include " util <sil=0.957> .PERIOD h "
# define MAX 10
int a [MAX] <sil=0.520> ;SEMICOLON int main ( v oi d )
{
int i <sil=0.456> ,COMMA t <sil=0.637> ,COMMA x <sil=0.394> ,COMMA y <sil=0.332> ;SEMICOLON / ∗ fill array ∗ /
for ( i = 0 <sil=0.396> ;SEMICOLON i < MAX <sil=0.407> ;SEMICOLON i ++)
{
a [ i ] = r a n d ( ) <sil=0.556> ;SEMICOLON printf ("%d \ n " <sil=0.353> ,COMMA a [ i ] ) <sil=0.494> ;SEMICOLON }
bubble_sort (MAX <sil=0.615> ,COMMA a ) <sil=0.516> ;SEMICOLON / ∗ print sorted array ∗ /
printf ("−−−−−−−−−−−−−−−−−−−−\n " ) <sil=0.523> ;SEMICOLON f or ( i = 0 <sil=0.488> ;SEMICOLON i < MAX <sil=0.569> ;SEMICOLON i ++)
{
printf ("%d \ n " <sil=0.420> ,COMMA a [ i ] ) <sil=0.354> ;SEMICOLON }
return 0 <sil=0.424> ;SEMICOLON }
This code includes the utility library <sil=0.978> .PERIOD The main benefit of using a library is that the code in the main program is much shorter <sil=0.990> .PERIOD Compiling and running
To compile the library <sil=0.633> ,COMMA type the following at the command line (assuming you are using UNIX) (replace gcc with cc if your system uses cc):
gcc −c −gutil <sil=0.918> .PERIOD c
The -c causes the compiler to produce an object file for the library <sil=0.999> .PERIOD The object file contains the library’s machine code <sil=0.996> .PERIOD It cannot be executed until it is linked to a program file that contains a main function <sil=0.988> .PERIOD The machine code resides in a separate file named util <sil=0.994> .PERIOD o <sil=0.996> .PERIOD To compile the main program <sil=0.604> ,COMMA type the following:
gcc −c −g main <sil=0.913> .PERIOD c
This line creates a file named main <sil=0.958> .PERIOD o that contains the machine code for the main program <sil=0.907> .PERIOD To create the final executable that contains the machine code for the entire program <sil=0.558> ,COMMA link the two object files by typing the following:
gcc −o main main <sil=0.941> .PERIOD outil <sil=0.910> .PERIOD o
This links main <sil=0.982> .PERIOD o and util <sil=0.915> .PERIOD o to form an executable named main <sil=0.998> .PERIOD To run it <sil=0.589> ,COMMA type main <sil=0.977> .PERIOD Makefiles
It can be cumbersome to type all of the gcc lines over and over again <sil=0.343> ,COMMA especially
if you are making a lot of changes to the code and it has several libraries <sil=0.976> .PERIOD The make facility solves this problem <sil=0.961> .PERIOD You can use the following makefile to replace the compilation sequence above:
main : main <sil=0.953> .PERIOD outil <sil=0.947> .PERIOD o
gcc −o main main <sil=0.960> .PERIOD outil <sil=0.902> .PERIOD o
main <sil=0.921> .PERIOD o : main <sil=0.982> .PERIOD cutil <sil=0.936> .PERIOD h
gcc −c −g main <sil=0.967> .PERIOD c
util <sil=0.928> .PERIOD o :util <sil=0.944> .PERIOD cutil <sil=0.944> .PERIOD h
gcc −c −gutil <sil=0.936> .PERIOD c
Enter this into a file named makefile <sil=0.471> ,COMMA and type maketo build the executable <sil=0.957> .PERIOD Note that you must precede all gcc lines with a tab <sil=0.943> .PERIOD (Eight spaces will not suffice – it must be a tab <sil=0.901> .PERIOD All other lines must be flush left <sil=0.937> .PERIOD )
This makefile contains two types of lines <sil=0.955> .PERIOD The lines appearing flush left are dependency lines <sil=0.973> .PERIOD The lines preceded by a tab are executable lines <sil=0.517> ,COMMA which can contain any valid UNIX command <sil=0.995> .PERIOD A dependency line says that some file is dependent on some other set of files <sil=0.948> .PERIOD For example <sil=0.421> ,COMMA main <sil=0.918> .PERIOD o: main <sil=0.931> .PERIOD c util <sil=0.964> .PERIOD h says that the file main <sil=0.975> .PERIOD o is dependent on the files main <sil=0.989> .PERIOD c and util <sil=0.940> .PERIOD h <sil=0.941> .PERIOD If either of these two files changes <sil=0.374> ,COMMA the following executable line(s) should be executed to recreate main <sil=0.989> .PERIOD o <sil=0.938> .PERIOD Note that the final executable produced by the whole makefile is main <sil=0.396> ,COMMA on line 1 in the makefile <sil=0.943> .PERIOD The final result of the makefile should always go on line 1 <sil=0.458> ,COMMA which in this makefile says that the file main is dependent on main <sil=0.999> .PERIOD o and util <sil=0.984> .PERIOD o <sil=0.952> .PERIOD If either
of these changes <sil=0.426> ,COMMA execute the line gcc -o main main <sil=0.985> .PERIOD o util <sil=0.999> .PERIOD o to recreate main <sil=0.939> .PERIOD It is possible to put multiple lines to be executed below a dependency line – they must all start with a tab <sil=0.925> .PERIOD A large program may have several libraries and a main program <sil=0.948> .PERIOD The makefile automatically recompiles everything that needs to be recompiled because of a change <sil=0.935> .PERIOD If you are not working on a UNIX machine <sil=0.361> ,COMMA your compiler almost certainly has functionality equivalent to makefiles <sil=0.959> .PERIOD Read the documentation for your compiler to learn how to use it <sil=0.987> .PERIOD Now you understand why you have been including stdio <sil=0.923> .PERIOD h in earlier programs <sil=0.902> .PERIOD It is simply a standard library that someone created long ago and made available to other programmers to make their lives easier <sil=0.931> .PERIOD Pointers
Pointers are used everywhere in C <sil=0.483> ,COMMA so if you want to use the C language fully you have to have a very good understanding of pointers <sil=0.954> .PERIOD They have to become comfortable for you <sil=0.901> .PERIOD The goal of this section and the next several that follow is to help you build a complete understanding of pointers and how C uses them <sil=0.972> .PERIOD For most people it takes a little time and some practice to become fully comfortable with pointers <sil=0.558> ,COMMA but once you master them you are a full-fledged C programmer <sil=0.908> .PERIOD C uses pointers in three different ways:
• C uses pointers to create dynamic data structures – data structures built up from blocks of memory allocated from the heap at run-time <sil=0.948> .PERIOD • C uses pointers to handle variable parameters passed to functions <sil=0.922> .PERIOD • Pointers in C provide an alternative way to access information stored in arrays <sil=0.928> .PERIOD Pointer techniques are especially valuable when you work with strings <sil=0.900> .PERIOD There is an intimate link between arrays and pointers in C <sil=0.957> .PERIOD In some cases <sil=0.395> ,COMMA C programmers also use pointers because they make the code slightly more efficient <sil=0.955> .PERIOD What you will find is that <sil=0.372> ,COMMA once you are completely comfortable with pointers <sil=0.515> ,COMMA you tend to use them all the time <sil=0.991> .PERIOD We will start this discussion with a basic introduction to pointers and the concepts surrounding pointers <sil=0.416> ,COMMA and then move on to the three techniques described above <sil=0.952> .PERIOD Especially on this article <sil=0.445> ,COMMA you will want to read things twice <sil=0.942> .PERIOD The first time through you can learn all the concepts <sil=0.997> .PERIOD The second time through you can work on binding
the concepts together into an integrated whole in your mind <sil=0.968> .PERIOD After you make your way through the material the second time <sil=0.366> ,COMMA it will make a lot of sense <sil=0.938> .PERIOD Pointers: why <sil=0.977> ?QUESTIONMARK Imagine that you would like to create a text editor – a program that lets you edit normal ASCII text files <sil=0.546> ,COMMA like “vim” on UNIX or “Notepad” on Windows <sil=0.909> .PERIOD A text editor is a fairly common thing for someone to create because <sil=0.482> ,COMMA if you think about it <sil=0.479> ,COMMA a text editor is probably a programmer’s most commonly used piece of software <sil=0.913> .PERIOD The text editor is a programmer’s intimate link to the computer – it is where you enter all of your thoughts and then manipulate them <sil=0.963> .PERIOD Obviously <sil=0.376> ,COMMA with
anything you use that often and work with that closely <sil=0.453> ,COMMA you want it to be just right <sil=0.976> .PERIOD Therefore many programmers create their own editors and customize them to suit their individual working styles and preferences <sil=0.908> .PERIOD So one day you sit down to begin working on your editor <sil=0.919> .PERIOD After thinking about the features you want <sil=0.393> ,COMMA you begin to think about the “data structure” for your editor <sil=0.957> .PERIOD That is <sil=0.617> ,COMMA you begin thinking about how you will store the document you are editing in memory so that you can manipulate it in your program <sil=0.994> .PERIOD What you need is a way to store the information you are entering in a form that can be manipulated quickly and easily <sil=0.991> .PERIOD You believe that one way to do that is to organize the data on the basis of lines of characters <sil=0.924> .PERIOD Given what we have discussed so far <sil=0.361> ,COMMA the only thing you have at your disposal at this point is an array <sil=0.941> .PERIOD You think <sil=0.324> ,COMMA “Well <sil=0.398> ,COMMA a typical line is 80 characters long <sil=0.355> ,COMMA and a typical file is no more than 1 <sil=0.624> ,COMMA 000 lines long <sil=0.962> .PERIOD ” You therefore declare a two-dimensional array <sil=0.422> ,COMMA like this:
char doc [ 1000 ] [ 80 ] <sil=0.399> ;SEMICOLON This declaration requests an array of 1 <sil=0.585> ,COMMA 000 80-character lines <sil=0.966> .PERIOD This array has a total size of 80 <sil=0.644> ,COMMA 000 characters <sil=0.904> .PERIOD As you think about your editor and its data structure some more <sil=0.578> ,COMMA however <sil=0.923> ,COMMA you might realize three things:
• Some documents are long lists <sil=0.947> .PERIOD Every line is short <sil=0.584> ,COMMA but there are thousands of lines <sil=0.948> .PERIOD Some special-purpose text files have very long lines <sil=0.945> .PERIOD For example <sil=0.450> ,COMMA a certain data file might have lines containing 542 characters <sil=0.568> ,COMMA with each character representing the amino acid pairs in segments of DNA <sil=0.948> .PERIOD • In most modern editors <sil=0.496> ,COMMA you can open multiple files at one time <sil=0.947> .PERIOD Let’s say you set a maximum of 10 open files at once <sil=0.320> ,COMMA a maximum line length of 1 <sil=0.508> ,COMMA 000 characters and a maximum file size of 50 <sil=0.458> ,COMMA 000 lines <sil=0.998> .PERIOD Your declaration now looks like this:
char doc [ 50000 ] [ 1000 ] [ 10 ] <sil=0.315> ;SEMICOLON That doesn’t seem like an unreasonable thing <sil=0.502> ,COMMA until you pull out your calculator <sil=0.564> ,COMMA multiply 50 <sil=0.461> ,COMMA 000 by 1 <sil=0.488> ,COMMA 000 by 10 and realize the array contains 500 million characters <sil=0.993> !EXCLAMATIONMARK Most computers today are going to have a problem with an array that size <sil=0.926> .PERIOD They simply do not have the RAM <sil=0.505> ,COMMA or even the virtual memory space <sil=0.351> ,COMMA to support an array that large <sil=0.936> .PERIOD If users were to try to run three or four copies of this program simultaneously on even the largest multi-user system <sil=0.473> ,COMMA it would put a severe strain on the facilities <sil=0.927> .PERIOD Even if the computer would accept a request for such a large array <sil=0.462> ,COMMA you can see that it is an extravagant waste of space <sil=0.999> .PERIOD It seems strange to declare a 500 million character array when <sil=0.389> ,COMMA in the vast majority of cases <sil=0.314> ,COMMA you will run this editor to look at 100 line files that consume at most 4 <sil=0.479> ,COMMA 000 or 5 <sil=0.307> ,COMMA 000 bytes <sil=0.957> .PERIOD The problem with an array is the fact that you have to declare it to have its maximum size in every dimension from the beginning <sil=0.960> .PERIOD Those maximum sizes often multiply together to form very large numbers <sil=0.989> .PERIOD Also <sil=0.356> ,COMMA if you happen to need to be able to edit an odd file
with a 2 <sil=0.541> ,COMMA 000 character line in it <sil=0.465> ,COMMA you are out of luck <sil=0.933> .PERIOD There is really no way for you to predict and handle the maximum line length of a text file <sil=0.596> ,COMMA because <sil=0.566> ,COMMA technically <sil=0.627> ,COMMA that number is infinite <sil=0.912> .PERIOD Pointers are designed to solve this problem <sil=0.913> .PERIOD With pointers <sil=0.300> ,COMMA you can create dynamic data structures <sil=0.932> .PERIOD Instead of declaring your worst-case memory consumption upfront in an array <sil=0.325> ,COMMA you instead allocate memory from the heap while the program is running <sil=0.955> .PERIOD That way you can use the exact amount of memory a document needs <sil=0.531> ,COMMA with no waste <sil=0.926> .PERIOD In addition <sil=0.477> ,COMMA when you close a document you can return the memory to the heap so that other parts of the program can use it <sil=0.932> .PERIOD With pointers <sil=0.437> ,COMMA memory can be recycled while the program is running <sil=0.973> .PERIOD Pointer Basics
To understand pointers <sil=0.486> ,COMMA it helps to compare them to normal variables <sil=0.987> .PERIOD A “normal variable” is a location in memory that can hold a value <sil=0.931> .PERIOD For example <sil=0.525> ,COMMA when you declare a variable i as an integer <sil=0.391> ,COMMA four bytes of memory are set aside for it <sil=0.985> .PERIOD In your program <sil=0.372> ,COMMA you refer to that location in memory by the name i <sil=0.995> .PERIOD At the machine level that location has a memory address <sil=0.909> .PERIOD The four bytes at that address are known to you <sil=0.528> ,COMMA the programmer <sil=0.424> ,COMMA as i <sil=0.342> ,COMMA and the four bytes can hold one integer value <sil=0.959> .PERIOD A pointer is different <sil=0.971> .PERIOD A pointer is a variable that points to another variable <sil=0.982> .PERIOD This means that a pointer holds the memory address of another variable <sil=0.924> .PERIOD Put another way <sil=0.478> ,COMMA the pointer does not hold a value in the traditional sense <sil=0.615> ;SEMICOLON instead <sil=0.537> ,COMMA it holds the address of another variable <sil=0.986> .PERIOD A pointer “points to” that other variable by holding a copy of its address <sil=0.951> .PERIOD Because a pointer holds an address rather than a value <sil=0.512> ,COMMA it has two parts <sil=0.937> .PERIOD The pointer itself holds the address <sil=0.993> .PERIOD That address points to a value <sil=0.993> .PERIOD There is the pointer and the value pointed to <sil=0.985> .PERIOD This fact can be a little confusing until you get comfortable with it <sil=0.628> ,COMMA but once you get comfortable it becomes extremely powerful <sil=0.966> .PERIOD The following example code shows a typical pointer:
#include <stdio <sil=0.922> .PERIOD h>
int main ( void )
{
int i <sil=0.612> ,COMMA j <sil=0.513> ;SEMICOLON int ∗p <sil=0.578> ;SEMICOLON / ∗ a pointer to an integer ∗ /
p = &i <sil=0.480> ;SEMICOLON ∗p = 5 <sil=0.331> ;SEMICOLON j = i <sil=0.563> ;SEMICOLON printf ("% d %d %d \ n " <sil=0.327> ,COMMA i <sil=0.463> ,COMMA j <sil=0.525> ,COMMA ∗p ) <sil=0.386> ;SEMICOLON return 0 <sil=0.342> ;SEMICOLON }
The first declaration in this program declares two normal integer variables named i and j <sil=0.904> .PERIOD The line int *p declares a pointer named p <sil=0.938> .PERIOD This line asks the compiler to declare a variable p that is a pointer to an integer <sil=0.915> .PERIOD The * indicates that a pointer is being declared rather than a normal variable <sil=0.952> .PERIOD You can create a pointer to anything: a float <sil=0.466> ,COMMA a structure <sil=0.556> ,COMMA a char <sil=0.503> ,COMMA and so on <sil=0.973> .PERIOD Just use a * to indicate that you want a pointer rather than a normal variable <sil=0.930> .PERIOD The line p = &i <sil=0.415> ;SEMICOLON will definitely be new to you <sil=0.929> .PERIOD In C <sil=0.582> ,COMMA & is called the address operator <sil=0.942> .PERIOD The expression &i means <sil=0.557> ,COMMA "The memory address of the variable i <sil=0.949> .PERIOD "
Thus <sil=0.532> ,COMMA the expression p = &i <sil=0.650> ;SEMICOLON means <sil=0.353> ,COMMA "Assign to p the address of i <sil=0.974> .PERIOD " Once you execute this statement <sil=0.455> ,COMMA p “points to” i <sil=0.937> .PERIOD Before you do so <sil=0.345> ,COMMA p contains a random <sil=0.503> ,COMMA unknown address <sil=0.631> ,COMMA and its use will likely cause a segmentation fault or similar program crash <sil=0.989> .PERIOD In the program above the three variables i <sil=0.526> ,COMMA j and p have been declared <sil=0.394> ,COMMA but none of the three has been initialized <sil=0.952> .PERIOD Once p points to i <sil=0.374> ,COMMA the memory location i has two names <sil=0.959> .PERIOD It is still known as i <sil=0.301> ,COMMA but now it is known as *p as well <sil=0.930> .PERIOD This is how C talks about the two parts of a pointer variable: p is the location holding the address <sil=0.446> ,COMMA while *p is the location pointed to by that address <sil=0.993> .PERIOD Therefore *p=5 means that the location pointed to by p should be set to 5 <sil=0.911> .PERIOD Because the location *p is also i <sil=0.409> ,COMMA i also takes on the value 5 <sil=0.968> .PERIOD Consequently <sil=0.310> ,COMMA j = i <sil=0.480> ;SEMICOLON sets j to 5 <sil=0.355> ,COMMA and the printf statement
produces 5 5 5 <sil=0.996> .PERIOD The main feature of a pointer is its two-part nature <sil=0.933> .PERIOD The pointer itself holds an
address <sil=0.955> .PERIOD The pointer also points to a value of a specific type - the value at the address the point holds <sil=0.940> .PERIOD The pointer itself <sil=0.343> ,COMMA in this case <sil=0.354> ,COMMA is p <sil=0.909> .PERIOD The value pointed to is *p <sil=0.963> .PERIOD Pointers: Understanding Memory Addresses The previous discussion becomes a little clearer if you understand how memory addresses work in a computer’s hardware <sil=0.927> .PERIOD All computers have memory <sil=0.488> ,COMMA also known as RAM (Random Access Memory) <sil=0.912> .PERIOD For example <sil=0.618> ,COMMA your computer might
have 16 or 32 or 64 megabytes of RAM installed right now <sil=0.951> .PERIOD RAM holds the programs that your computer is currently running along with the data they are currently manipulating (their variables and data structures) <sil=0.934> .PERIOD Memory can be thought of simply as an array of bytes <sil=0.909> .PERIOD In this array <sil=0.595> ,COMMA every memory location has its own address – the address of the first byte is 0 <sil=0.532> ,COMMA followed by 1 <sil=0.463> ,COMMA 2 <sil=0.394> ,COMMA 3 <sil=0.598> ,COMMA and so on <sil=0.954> .PERIOD Memory addresses act just like the indexes of a normal array <sil=0.926> .PERIOD The computer can access
any address in memory at any time (hence the name “random access memory”) <sil=0.986> .PERIOD It can also group bytes together as it needs to to form larger variables <sil=0.571> ,COMMA arrays <sil=0.571> ,COMMA and structures <sil=0.933> .PERIOD For example <sil=0.399> ,COMMA a floating point variable consumes 4 contiguous bytes in memory <sil=0.908> .PERIOD You might make the following global declaration in a program: float f <sil=0.393> ;SEMICOLON This statement says <sil=0.560> ,COMMA "Declare a location named f that can hold one floating point value <sil=0.908> .PERIOD " When the program runs <sil=0.363> ,COMMA the computer reserves space for the variable f somewhere in memory <sil=0.905> .PERIOD That location has a fixed address in the memory space <sil=0.953> .PERIOD The variable f consumes four bytes of RAM in memory <sil=0.907> .PERIOD While you think of the variable f <sil=0.408> ,COMMA the computer thinks of a specific address in memory (for example <sil=0.568> ,COMMA 248 <sil=0.564> ,COMMA 440) <sil=0.911> .PERIOD Therefore <sil=0.328> ,COMMA when you create a statement like this:
f = 3 <sil=0.996> .PERIOD 14 <sil=0.331> ;SEMICOLON The compiler might translate that into <sil=0.564> ,COMMA “Load the value 3 <sil=0.915> .PERIOD 14 into memory location 248 <sil=0.453> ,COMMA 440 <sil=0.906> .PERIOD ” The computer is always thinking of memory in terms of addresses and values at those addresses <sil=0.994> .PERIOD There are <sil=0.550> ,COMMA by the way <sil=0.542> ,COMMA several interesting side effects to the way your computer treats memory <sil=0.982> .PERIOD For example <sil=0.397> ,COMMA say that you include the following code in one of
your programs:
int i <sil=0.415> ,COMMA s [ 4 ] <sil=0.541> ,COMMA t [ 4 ] <sil=0.370> ,COMMA u = 0 <sil=0.541> ;SEMICOLON for ( i = 0 <sil=0.306> ;SEMICOLON i <= 4 <sil=0.486> ;SEMICOLON i ++)
{
s [ i ] = i <sil=0.458> ;SEMICOLON t [ i ] = i <sil=0.600> ;SEMICOLON }
printf ( " s : t \ n " ) <sil=0.464> ;SEMICOLON for ( i = 0 <sil=0.369> ;SEMICOLON i <= 4 <sil=0.417> ;SEMICOLON i ++)
{
printf ("% d:%d \ n " <sil=0.640> ,COMMA s [ i ] <sil=0.581> ,COMMA t [ i ] ) <sil=0.601> ;SEMICOLON }
printf ( " u = %d \ n " <sil=0.550> ,COMMA u ) <sil=0.463> ;SEMICOLON The output that you see from the program will probably look like this:
s : t
1: 5
2: 2
3: 3
4: 4
5: 5
u = 5
Why are t[0] and u incorrect <sil=0.935> ?QUESTIONMARK If you look carefully at the code <sil=0.381> ,COMMA you can see that the for loops are writing one element past the end of each array <sil=0.915> .PERIOD In memory <sil=0.578> ,COMMA the arrays are placed adjacent to one another <sil=0.994> .PERIOD Therefore <sil=0.522> ,COMMA when you try to write to s[4] <sil=0.441> ,COMMA which does not exist <sil=0.315> ,COMMA the system writes into t[0] instead because t[0] is where s[4] ought to be <sil=0.982> .PERIOD When you write into t[4] <sil=0.425> ,COMMA you are really writing into u <sil=0.963> .PERIOD As far as the computer is concerned <sil=0.513> ,COMMA s[4] is simply an address <sil=0.356> ,COMMA and it can write into it <sil=0.992> .PERIOD As
you can see however <sil=0.382> ,COMMA even though the computer executes the program <sil=0.432> ,COMMA it is not
correct or valid <sil=0.949> .PERIOD The program corrupts the array t in the process of running <sil=0.949> .PERIOD If you
execute the following statement <sil=0.583> ,COMMA more severe consequences result:
s [ 1 0 0 0 0 0 0 ] = 5 <sil=0.574> ;SEMICOLON The location s[1000000] is more than likely outside of your program’s memory space <sil=0.942> .PERIOD In other words <sil=0.541> ,COMMA you are writing into memory that your program does not own <sil=0.983> .PERIOD On a system with protected memory spaces (UNIX <sil=0.572> ,COMMA Windows 98/NT) <sil=0.498> ,COMMA this sort of statement will cause the system to terminate execution of the program <sil=0.910> .PERIOD On other systems (Windows 3 <sil=0.994> .PERIOD 1 <sil=0.404> ,COMMA the Mac) <sil=0.509> ,COMMA however <sil=0.981> ,COMMA the system is not aware of what you are doing <sil=0.984> .PERIOD You end up damaging the code or variables in another application <sil=0.967> .PERIOD The effect of the violation can range from nothing at all to a complete system crash <sil=0.953> .PERIOD In memory <sil=0.451> ,COMMA i <sil=0.350> ,COMMA s <sil=0.369> ,COMMA t and u are all placed next to one another at specific addresses <sil=0.986> .PERIOD Therefore <sil=0.618> ,COMMA if you write past the boundaries of a variable <sil=0.338> ,COMMA the computer will do what you say but it will end up corrupting another memory location <sil=0.957> .PERIOD Because C and C++ do not perform any sort of range checking when you access an element of an array <sil=0.589> ,COMMA it is essential that you <sil=0.306> ,COMMA as a programmer <sil=0.429> ,COMMA pay careful attention to array ranges yourself and keep within the array’s appropriate boundaries <sil=0.944> .PERIOD Unintentionally reading or writing outside of array boundaries always leads to faulty program behavior <sil=0.983> .PERIOD As another example <sil=0.383> ,COMMA try the following: 
# include<stdio <sil=0.976> .PERIOD h>
int main ( void )
{
int i <sil=0.330> ,COMMA j <sil=0.402> ;SEMICOLON int ∗p <sil=0.459> ;SEMICOLON / ∗ a pointer to an integer ∗ /
printf ("% d %d \ n " <sil=0.360> ,COMMA p <sil=0.313> ,COMMA &i ) <sil=0.342> ;SEMICOLON p = &i <sil=0.317> ;SEMICOLON printf ("% d %d \ n " <sil=0.605> ,COMMA p <sil=0.465> ,COMMA &i ) <sil=0.548> ;SEMICOLON return 0 <sil=0.335> ;SEMICOLON }
This code tells the compiler to print out the address held in p <sil=0.352> ,COMMA along with the address of i <sil=0.948> .PERIOD The variable p starts off with some crazy value or with 0 <sil=0.993> .PERIOD The address ofiis generally a large value <sil=0.950> .PERIOD For example <sil=0.617> ,COMMA when I ran this code <sil=0.548> ,COMMA I received the following output:
0 2147478276
2147478276 2147478276
which means that the address of i is 2147478276 <sil=0.910> .PERIOD Once the statement p = &i <sil=0.437> ;SEMICOLON has been executed <sil=0.345> ,COMMA p contains the address of i <sil=0.985> .PERIOD Try this as well:
#include<stdio <sil=0.937> .PERIOD h>
void main ( void )
{
int ∗p <sil=0.573> ;SEMICOLON / ∗ a pointer to an integer ∗ /
printf ("% d \ n " <sil=0.412> ,COMMA ∗ p ) <sil=0.362> ;SEMICOLON }
This code tells the compiler to print the value that p points to <sil=0.949> .PERIOD However <sil=0.615> ,COMMA p has not been initialized yet <sil=0.588> ;SEMICOLON it contains the address 0 or some random address <sil=0.902> .PERIOD In most cases <sil=0.432> ,COMMA a segmentation fault (or some other run-time error) results <sil=0.383> ,COMMA which means that you have used a pointer that points to an invalid area of memory <sil=0.968> .PERIOD Almost always <sil=0.535> ,COMMA an uninitialized pointer or a bad pointer address is the cause of segmentation faults <sil=0.943> .PERIOD Having said all of this <sil=0.428> ,COMMA we can now look at pointers in a whole new light <sil=0.907> .PERIOD Take this program <sil=0.488> ,COMMA for example: 
#include<stdio <sil=0.982> .PERIOD h>
int main ( void )
{
int i <sil=0.366> ;SEMICOLON int ∗p <sil=0.650> ;SEMICOLON / ∗ a pointer to an integer ∗ /
p = &i <sil=0.521> ;SEMICOLON ∗p = 5 <sil=0.642> ;SEMICOLON printf ("% d %d \ n " <sil=0.335> ,COMMA i <sil=0.370> ,COMMA ∗p ) <sil=0.433> ;SEMICOLON return 0 <sil=0.503> ;SEMICOLON }
The variable i consumes 4 bytes of memory <sil=0.949> .PERIOD The pointer p also consumes 4 bytes (on most machines in use today <sil=0.303> ,COMMA a pointer consumes 8 bytes of memory <sil=0.904> .PERIOD Memory addresses are 64-bits long on most today) <sil=0.949> .PERIOD The location of i has a specific address <sil=0.502> ,COMMA in this case 248 <sil=0.641> ,COMMA 440 <sil=0.983> .PERIOD The pointer p holds that address once you say p = &i <sil=0.314> ;SEMICOLON  <sil=0.519> .PERIOD The variables *p and i are therefore equivalent <sil=0.938> .PERIOD The pointer p literally holds the address of i <sil=0.997> .PERIOD When you say something like this in a program:
printf ("% d " <sil=0.565> ,COMMA p ) <sil=0.540> ;SEMICOLON what comes out is the actual address of the variable i <sil=0.966> .PERIOD Pointers: Pointing to the Same Address
Here is a cool aspect of C: Any number of pointers can point to the same address <sil=0.904> .PERIOD For example <sil=0.397> ,COMMA you could declare p <sil=0.598> ,COMMA q <sil=0.415> ,COMMA and r as integer pointers and set all of them to point to i <sil=0.325> ,COMMA as shown here:
int i <sil=0.637> ;SEMICOLON int ∗p <sil=0.428> ,COMMA ∗q <sil=0.442> ,COMMA ∗ r <sil=0.467> ;SEMICOLON p = &i <sil=0.352> ;SEMICOLON q = &i <sil=0.606> ;SEMICOLON r = p <sil=0.514> ;SEMICOLON Note that in this code <sil=0.634> ,COMMA r points to the same thing that p points to <sil=0.450> ,COMMA which is i <sil=0.918> .PERIOD You can assign pointers to one another <sil=0.610> ,COMMA and the address is copied from the right-hand side to the left-hand side during the assignment <sil=0.912> .PERIOD The variable i now has four names: i <sil=0.478> ,COMMA *p <sil=0.478> ,COMMA *q and *r <sil=0.902> .PERIOD There is no limit on the number of pointers that can hold (and therefore point to) the same address <sil=0.947> .PERIOD Pointers: Common Bugs
Bug #1 - Uninitialized pointers
One of the easiest ways to create a pointer bug is to try to reference the value of a pointer even though the pointer is uninitialized and does not yet point to a valid address <sil=0.961> .PERIOD For example:
int ∗p <sil=0.554> ;SEMICOLON ∗p = 12 <sil=0.420> ;SEMICOLON The pointer p is uninitialized and points to a random location in memory whenyou declare it <sil=0.926> .PERIOD It could be pointing into the system stack <sil=0.514> ,COMMA or the global variables <sil=0.619> ,COMMA or into the program’s code space <sil=0.579> ,COMMA or into the operating system <sil=0.960> .PERIOD When you say *p=12 <sil=0.521> ;SEMICOLON  <sil=0.606> ,COMMA the program will simply try to write a 12 to whatever random location p points to <sil=0.992> .PERIOD The program may explode immediately <sil=0.628> ,COMMA or may wait half an hour and then explode <sil=0.436> ,COMMA or it may subtly corrupt data in another part of your program and
you may never realize it <sil=0.911> .PERIOD This can make this error very hard to track down <sil=0.957> .PERIOD Make sure you initialize all pointers to a valid address before dereferencing them <sil=0.982> .PERIOD Bug #2 - Invalid Pointer References
An invalid pointer reference occurs when a pointer’s value is referenced even though the pointer doesn’t point to a valid block <sil=0.937> .PERIOD One way to create this error is to say p = q <sil=0.504> ;SEMICOLON  <sil=0.428> ,COMMA when q is uninitialized <sil=0.946> .PERIOD The pointer p will then become uninitialized as well <sil=0.449> ,COMMA and any reference to *p is an invalid pointer reference <sil=0.998> .PERIOD The only way to avoid this bug is to draw pictures of each step of the program and make sure that all pointers point somewhere <sil=0.956> .PERIOD Invalid pointer references cause a program to crash inexplicably for the same reasons given in Bug #1 <sil=0.994> .PERIOD Bug #3 - Zero Pointer Reference
A zero pointer reference occurs whenever a pointer pointing to zero is used in a statement that attempts to reference a block <sil=0.940> .PERIOD For example <sil=0.568> ,COMMA if p is a pointer to an integer <sil=0.326> ,COMMA the following code is invalid:
p = 0 <sil=0.555> ;SEMICOLON ∗p = 12 <sil=0.407> ;SEMICOLON There is no block pointed to by p <sil=0.986> .PERIOD Therefore <sil=0.509> ,COMMA trying to read or write anything from
or to that block is an invalid zero pointer reference <sil=0.939> .PERIOD There are good <sil=0.395> ,COMMA valid reasons
to point a pointer to zero <sil=0.515> ,COMMA as we will see in later articles <sil=0.926> .PERIOD Dereferencing such a
pointer <sil=0.336> ,COMMA however <sil=0.958> ,COMMA is invalid <sil=0.991> .PERIOD All of these bugs are fatal to a program that contains them <sil=0.947> .PERIOD You must watch your code so that these bugs do not occur <sil=0.959> .PERIOD The best way to do that is to draw pictures of the code’s execution step by step <sil=0.988> .PERIOD Using Pointers for Function Parameters
Most C programmers first use pointers to implement something called variable parameters in functions <sil=0.953> .PERIOD You have actually been using variable parameters in the scanf function – that’s why you’ve had to use the & (the address operator) on variables used with scanf <sil=0.999> .PERIOD Now that you understand pointers you can see what has really been going on <sil=0.922> .PERIOD To understand how variable parameters work <sil=0.439> ,COMMA lets see how we might go about implementing a swap function in C <sil=0.996> .PERIOD To implement a swap function <sil=0.306> ,COMMA what you would like to do is pass in two variables and have the function swap their values <sil=0.915> .PERIOD Here’s one attempt at an implementation – enter and execute the following code and see what happens:
# include <stdio <sil=0.960> .PERIOD h>
void swap ( int i <sil=0.395> ,COMMA int j )
{
int t <sil=0.592> ;SEMICOLON t = i <sil=0.583> ;SEMICOLON i = j <sil=0.459> ;SEMICOLON j = t <sil=0.305> ;SEMICOLON }
void main ( void )
{
int a <sil=0.456> ,COMMA b <sil=0.303> ;SEMICOLON a = 5 <sil=0.315> ;SEMICOLON b = 1 0 <sil=0.587> ;SEMICOLON printf ("% d %d \ n " <sil=0.309> ,COMMA a <sil=0.374> ,COMMA b ) <sil=0.321> ;SEMICOLON swap ( a <sil=0.431> ,COMMA b ) <sil=0.303> ;SEMICOLON printf ("% d %d \ n " <sil=0.458> ,COMMA a <sil=0.352> ,COMMA b ) <sil=0.530> ;SEMICOLON }
When you execute this program <sil=0.324> ,COMMA you will find that no swapping takes place <sil=0.925> .PERIOD The values of a and b are passed to swap <sil=0.435> ,COMMA and the swap function does swap them <sil=0.411> ,COMMA but when the function returns nothing happens <sil=0.962> .PERIOD To make this function work correctly you can use pointers <sil=0.382> ,COMMA as shown below:
# include < stdio <sil=0.993> .PERIOD h>
void swap ( int ∗ i <sil=0.550> ,COMMA int ∗ j )
{
int t <sil=0.627> ;SEMICOLON t = ∗ i <sil=0.565> ;SEMICOLON ∗ i = ∗ j <sil=0.509> ;SEMICOLON ∗ j = t <sil=0.512> ;SEMICOLON }
void main ( void )
{
int a <sil=0.370> ,COMMA b <sil=0.573> ;SEMICOLON a = 5 <sil=0.345> ;SEMICOLON b = 10 <sil=0.539> ;SEMICOLON printf ("% d %d \ n " <sil=0.499> ,COMMA a <sil=0.560> ,COMMA b ) <sil=0.631> ;SEMICOLON swap (&a <sil=0.561> ,COMMA &b ) <sil=0.631> ;SEMICOLON printf ("% d %d \ n " <sil=0.614> ,COMMA a <sil=0.333> ,COMMA b ) <sil=0.555> ;SEMICOLON }
To get an idea of what this code does <sil=0.373> ,COMMA print it out <sil=0.619> ,COMMA draw the two integers a and b <sil=0.527> ,COMMA and enter 5 and 10 in them <sil=0.974> .PERIOD Now draw the two pointers i and j <sil=0.531> ,COMMA along with the integer t <sil=0.947> .PERIOD When swap is called <sil=0.509> ,COMMA it is passed the addresses of a and b <sil=0.985> .PERIOD Thus <sil=0.380> ,COMMA i
points to a (draw an arrow from i to a) and j points to b (draw another arrow from b to j) <sil=0.945> .PERIOD Once the pointers are initialized by the function call <sil=0.623> ,COMMA *i is another name for a <sil=0.477> ,COMMA and *j is another name for b <sil=0.969> .PERIOD Now run the code in swap <sil=0.982> .PERIOD When the code uses *i and *j <sil=0.315> ,COMMA it really means a and b <sil=0.919> .PERIOD When the function completes <sil=0.565> ,COMMA a and b have been swapped <sil=0.922> .PERIOD Suppose you accidentally forget the & when the swap function is called <sil=0.638> ,COMMA and that the swap line accidentally looks like this: swap(a <sil=0.577> ,COMMA b) <sil=0.398> ;SEMICOLON  <sil=0.518> .PERIOD This causes a segmentation fault <sil=0.963> .PERIOD When you leave out the & <sil=0.596> ,COMMA the value of a is passed instead of its address <sil=0.915> .PERIOD Therefore <sil=0.628> ,COMMA i points to an invalid location in memory and the system crashes when *i is used <sil=0.902> .PERIOD This is also why scanf crashes if you forget the & on variables passed to it <sil=0.941> .PERIOD The scanf function is using pointers to put the value it reads back into the variable you have passed <sil=0.931> .PERIOD Without the & <sil=0.329> ,COMMA scanf is passed a bad address and crashes <sil=0.914> .PERIOD Variable parameters are one of the most common uses of pointers in C <sil=0.938> .PERIOD Now you
understand what’s happening <sil=0.909> !EXCLAMATIONMARK Dynamic Data Structures
Dynamic data structures are data structures that grow and shrink as you need them to by allocating and deallocating memory from a place called the heap <sil=0.981> .PERIOD They are extremely important in C because they allow the programmer to exactly control memory consumption <sil=0.909> .PERIOD Dynamic data structures allocate blocks of memory from the heap as required <sil=0.412> ,COMMA and link those blocks together into some kind of data structure using pointers <sil=0.902> .PERIOD When the data structure no longer needs a block of memory <sil=0.370> ,COMMA it will return the block to the heap for reuse <sil=0.915> .PERIOD This recycling makes very efficient use of memory <sil=0.914> .PERIOD To understand dynamic data structures completely <sil=0.603> ,COMMA we need to start with the heap <sil=0.907> .PERIOD Dynamic Data Structures: The Heap The operating system and several applications <sil=0.413> ,COMMA along with their global variables and stack spaces <sil=0.539> ,COMMA all consume portions of memory <sil=0.957> .PERIOD When a program completes execution <sil=0.523> ,COMMA it releases its memory for reuse by other programs <sil=0.935> .PERIOD Note that part of
the memory space remains unused at any given time <sil=0.946> .PERIOD Memory holds the executable code for the different applications currently running on the machine <sil=0.372> ,COMMA along with the executable code for the operating system itself <sil=0.958> .PERIOD Each application has certain global variables associated with it <sil=0.937> .PERIOD These variables also consume memory <sil=0.960> .PERIOD Finally <sil=0.543> ,COMMA each application uses an area of memory called the stack <sil=0.452> ,COMMA which holds all local variables and parameters used by any function <sil=0.989> .PERIOD The stack also remembers the order in which functions are called so that function returns occur correctly <sil=0.991> .PERIOD Each time a function is called <sil=0.577> ,COMMA its local variables and parameters are “pushed onto” the stack <sil=0.945> .PERIOD When the function returns <sil=0.417> ,COMMA these locals and parameters are “popped <sil=0.976> .PERIOD ” Because of this <sil=0.300> ,COMMA the size of a program’s stack fluctuates constantly as the program is running <sil=0.457> ,COMMA but it has some maximum size <sil=0.910> .PERIOD As a program finishes execution <sil=0.514> ,COMMA the operating system unloads it <sil=0.355> ,COMMA its globals and its stack space from memory <sil=0.911> .PERIOD A new program can make use of that space at a later time <sil=0.934> .PERIOD In this way <sil=0.565> ,COMMA the memory in a computer system is constantly “recycled” and reused by programs as they execute and complete <sil=0.956> .PERIOD In general <sil=0.424> ,COMMA perhaps 50 percent of the computer’s total memory space might be unused at any given moment <sil=0.914> .PERIOD The operating system owns and manages the unused memory <sil=0.464> ,COMMA and it is collectively known as the heap <sil=0.993> .PERIOD The heap is extremely important because it is available for use by applications during execution using the C functions malloc (memory allocate) and free <sil=0.916> .PERIOD The heap allows programs to allocate memory exactly when they need it during the execution of a program <sil=0.460> ,COMMA rather than pre-allocating it with a specifically-sized array declaration <sil=0.981> .PERIOD Dynamic Data Structures: Malloc and Free
Let’s say that you would like to allocate a certain amount of memory during the execution of your application <sil=0.923> .PERIOD You can call the malloc function at any time <sil=0.623> ,COMMA and it will request a block of memory from the heap <sil=0.952> .PERIOD The operating system will reserve a block of memory for your program <sil=0.506> ,COMMA and you can use it in any way you like <sil=0.923> .PERIOD When you are done with the block <sil=0.595> ,COMMA you return it to the operating system for recycling by calling the free function <sil=0.925> .PERIOD Then other applications can reserve it later for their own use <sil=0.987> .PERIOD For example <sil=0.471> ,COMMA the following code demonstrates the simplest possible use of the
heap:
int main ( void )
{
int ∗p <sil=0.561> ;SEMICOLON p = ( int ∗) malloc ( size of ( int ) ) <sil=0.382> ;SEMICOLON if ( p == 0 )
{
printf ( "ERROR: Out o f memory \ n " ) <sil=0.557> ;SEMICOLON return 1 <sil=0.512> ;SEMICOLON }
∗p = 5 <sil=0.462> ;SEMICOLON printf ("% d \ n " <sil=0.328> ,COMMA ∗p ) <sil=0.470> ;SEMICOLON free ( p ) <sil=0.625> ;SEMICOLON return 0 <sil=0.534> ;SEMICOLON }
The first line in this program calls the malloc function <sil=0.997> .PERIOD This function does three things:
1 <sil=0.975> .PERIOD The malloc statement first looks at the amount of memory available on the heap and asks <sil=0.550> ,COMMA “Is there enough memory available to allocate a block of memory of the size requested <sil=0.907> ?QUESTIONMARK ” The amount of memory needed for the block is known from the parameter passed into malloc – in this case <sil=0.444> ,COMMA sizeof(int) is 4 bytes <sil=0.985> .PERIOD If there is not enough memory available <sil=0.310> ,COMMA the malloc function returns the address zero to indicate the error (another name for zero is NULL and you will see it used throughout C code) <sil=0.973> .PERIOD Otherwise malloc proceeds <sil=0.916> .PERIOD 2 <sil=0.940> .PERIOD If memory is available on the heap <sil=0.384> ,COMMA the system “allocates” or “reserves” a block from the heap of the size specified <sil=0.987> .PERIOD The system reserves the block of memory so that it isn’t accidentally used by more than one malloc statement <sil=0.952> .PERIOD 3 <sil=0.957> .PERIOD The system then places into the pointer variable (p <sil=0.649> ,COMMA in this case) the address of the reserved block <sil=0.963> .PERIOD The pointer variable itself contains an address <sil=0.951> .PERIOD The allocated block is able to hold a value of the type specified <sil=0.394> ,COMMA and the pointer points to it <sil=0.920> .PERIOD The program next checks the pointer p to make sure that the allocation request succeeded with the line if (p == 0) (which could have also been written as if (p == NULL) or even if ( <sil=0.907> !EXCLAMATIONMARK p) <sil=0.959> .PERIOD If the allocation fails (if p is zero) <sil=0.629> ,COMMA the program terminates <sil=0.937> .PERIOD If the allocation is successful <sil=0.409> ,COMMA the program then initializes the block to the value 5 <sil=0.490> ,COMMA prints out the value <sil=0.519> ,COMMA and calls the free function to return the memory to the heap
before the program terminates <sil=0.908> .PERIOD There is really no difference between this code and previous code that sets p equal
to the address of an existing integer i <sil=0.941> .PERIOD The only distinction is that <sil=0.548> ,COMMA in the case of
the variable i <sil=0.645> ,COMMA the memory existed as part of the program’s pre-allocated memory
space and had the two names: i and *p <sil=0.942> .PERIOD In the case of memory allocated from
the heap <sil=0.364> ,COMMA the block has the single name *p and is allocated during the program’s
execution <sil=0.902> .PERIOD Two common questions:
• Is it really important to check that the pointer is zero after each allocation <sil=0.881> ?QUESTIONMARK Yes <sil=0.990> .PERIOD Since the heap varies in size constantly depending on which programs are running <sil=0.430> ,COMMA how much memory they have allocated <sil=0.606> ,COMMA etc <sil=0.945> .PERIOD  <sil=0.419> ,COMMA there is never any guarantee that a call to malloc will succeed <sil=0.908> .PERIOD You should check the pointer after any call to malloc to make sure the pointer is valid <sil=0.958> .PERIOD • What happens if I forget to delete a block of memory before the program terminates <sil=0.980> ?QUESTIONMARK When a program terminates <sil=0.380> ,COMMA the operating system “cleans up after it <sil=0.421> ,COMMA ” releasing its executable code space <sil=0.615> ,COMMA stack <sil=0.416> ,COMMA global memory space and any heap allocations for recycling <sil=0.944> .PERIOD Therefore <sil=0.636> ,COMMA there
are no long-term consequences to leaving allocations pending at program termination <sil=0.984> .PERIOD However <sil=0.320> ,COMMA it is considered bad form <sil=0.389> ,COMMA and “memory leaks” during the execution of a program are harmful <sil=0.347> ,COMMA as discussed below <sil=0.938> .PERIOD The following two programs show two different valid uses of pointers <sil=0.340> ,COMMA and try to distinguish between the use of a pointer and of the pointer’s value:
void main ( void )
{
int ∗p <sil=0.478> ,COMMA ∗q <sil=0.487> ;SEMICOLON p = ( int ∗) malloc ( size of ( int ) ) <sil=0.616> ;SEMICOLON q = p <sil=0.450> ;SEMICOLON ∗p = 1 0 <sil=0.344> ;SEMICOLON printf ("% d \ n " <sil=0.359> ,COMMA ∗q ) <sil=0.554> ;SEMICOLON ∗q = 2 0 <sil=0.508> ;SEMICOLON printf ("% d \ n " <sil=0.512> ,COMMA ∗q ) <sil=0.566> ;SEMICOLON }
The final output of this code would be 10 from line 4 and 20 from line 6 <sil=0.954> .PERIOD The following code is slightly different:
void main ( void )
{
int ∗p <sil=0.322> ,COMMA ∗q <sil=0.546> ;SEMICOLON p = ( int ∗) malloc ( sizeof ( int ) ) <sil=0.426> ;SEMICOLON q = ( int ∗) malloc ( sizeof ( int ) ) <sil=0.514> ;SEMICOLON ∗p = 10 <sil=0.357> ;SEMICOLON ∗q = 20 <sil=0.529> ;SEMICOLON ∗p = ∗q <sil=0.546> ;SEMICOLON printf ("% d \ n " <sil=0.417> ,COMMA ∗p ) <sil=0.615> ;SEMICOLON }
The final output from this code would be 20 from line 6 <sil=0.955> .PERIOD Notice that the compiler will allow *p = *q <sil=0.369> ,COMMA because *p and *q are both integers <sil=0.904> .PERIOD This statement says <sil=0.374> ,COMMA “Move the integer value pointed to by q into the integer value pointed to by p <sil=0.981> .PERIOD ” The statement moves the values <sil=0.929> .PERIOD The compiler will also allow p = q <sil=0.395> ,COMMA because p and q are both pointers <sil=0.345> ,COMMA and both point to the same type (if s is a pointer to a character <sil=0.480> ,COMMA p = s is not allowed because they point to different types) <sil=0.942> .PERIOD The statement p = q says <sil=0.575> ,COMMA “Point p to the same block q points to <sil=0.903> .PERIOD ” In other words <sil=0.336> ,COMMA the address pointed to by q is moved into p <sil=0.443> ,COMMA so they both point to the same block <sil=0.989> .PERIOD This statement moves the addresses <sil=0.914> .PERIOD From all of these examples <sil=0.481> ,COMMA you can see that there are four different ways to initialize a pointer <sil=0.983> .PERIOD When a pointer is declared <sil=0.492> ,COMMA as in int *p <sil=0.497> ,COMMA it starts out in the program in an uninitialized state <sil=0.931> .PERIOD It may point anywhere <sil=0.321> ,COMMA and therefore to dereference it is an error <sil=0.971> .PERIOD Initialization of a pointer variable involves pointing it to a known location in memory <sil=0.939> .PERIOD 1 <sil=0.956> .PERIOD One way <sil=0.339> ,COMMA as seen already <sil=0.631> ,COMMA is to use the malloc statement <sil=0.914> .PERIOD This statement allocates a block of memory from the heap and then points the pointer at the block <sil=0.966> .PERIOD This initializes the pointer <sil=0.389> ,COMMA because it now points to a known location <sil=0.922> .PERIOD The pointer is initialized because it has been filled with a valid address – the address of the new block <sil=0.995> .PERIOD 2 <sil=0.996> .PERIOD The second way <sil=0.378> ,COMMA as seen just a moment ago <sil=0.625> ,COMMA is to use a statement such as p = q so that p points to the same place as q <sil=0.967> .PERIOD If q is pointing at a valid block <sil=0.424> ,COMMA then p is initialized <sil=0.946> .PERIOD The pointer p is loaded with the valid address that q contains <sil=0.983> .PERIOD However <sil=0.501> ,COMMA if q is uninitialized or invalid <sil=0.473> ,COMMA p will pick up the same useless address <sil=0.990> .PERIOD 3 <sil=0.934> .PERIOD The third way is to point the pointer to a known address <sil=0.609> ,COMMA such as a global variable’s address <sil=0.956> .PERIOD For example <sil=0.556> ,COMMA if i is an integer and p is a pointer to an integer <sil=0.449> ,COMMA then the statement p=&i initializes p by pointing it to i <sil=0.950> .PERIOD 4 <sil=0.925> .PERIOD The fourth way to initialize the pointer is to use the value zero <sil=0.970> .PERIOD Zero is a special values used with pointers <sil=0.342> ,COMMA as shown here:
p = 0 <sil=0.331> ;SEMICOLON or:
p = NULL <sil=0.503> ;SEMICOLON What this does physically is to place a zero into p <sil=0.924> .PERIOD The pointer p’s address is zero <sil=0.947> .PERIOD Any pointer can be set to point to zero <sil=0.945> .PERIOD When p points to zero <sil=0.609> ,COMMA however <sil=0.989> ,COMMA it does not point to a block <sil=0.986> .PERIOD The pointer simply contains the address zero <sil=0.332> ,COMMA and this value is useful as a tag <sil=0.904> .PERIOD You can use it in statements such as:
if ( p == 0 )
{ <sil=0.900> .PERIOD  <sil=0.903> .PERIOD  <sil=0.902> .PERIOD }
or:
while ( p <sil=0.866> !EXCLAMATIONMARK = 0 )
{ <sil=0.931> .PERIOD  <sil=0.911> .PERIOD  <sil=0.972> .PERIOD }
The system also recognizes the zero value <sil=0.536> ,COMMA and will generate error messages if you happen to dereference a zero pointer <sil=0.966> .PERIOD For example <sil=0.469> ,COMMA in the following code:
p = 0 <sil=0.486> ;SEMICOLON ∗p = 5 <sil=0.572> ;SEMICOLON The program will normally crash <sil=0.966> .PERIOD The pointer p does not point to a block <sil=0.499> ,COMMA it points to zero <sil=0.558> ,COMMA so a value cannot be assigned to *p <sil=0.913> .PERIOD The zero pointer will be used as a flag when we get to linked lists <sil=0.904> .PERIOD The malloc command is used to allocate a block of memory <sil=0.967> .PERIOD It is also possible to deallocate a block of memory when it is no longer needed <sil=0.912> .PERIOD When a block is deallocated <sil=0.630> ,COMMA it can be reused by a subsequent malloc command <sil=0.595> ,COMMA which allows the system to recycle memory <sil=0.905> .PERIOD The command used to deallocate memory is called free <sil=0.468> ,COMMA and it accepts a pointer as its parameter <sil=0.919> .PERIOD The free command does two things:
1 <sil=0.992> .PERIOD The block of memory pointed to by the pointer is unreserved and given back to the free memory on the heap <sil=0.949> .PERIOD It can then be reused by later new statements <sil=0.930> .PERIOD 2 <sil=0.976> .PERIOD The pointer is left in an uninitialized state <sil=0.616> ,COMMA and must be reinitialized before it can be used again <sil=0.921> .PERIOD The free statement simply returns a pointer to its original uninitialized state and makes the block available again on the heap <sil=0.918> .PERIOD The following example shows how to use the heap <sil=0.957> .PERIOD It allocates an integer block <sil=0.566> ,COMMA fills it <sil=0.459> ,COMMA writes it <sil=0.587> ,COMMA and disposes of it:
# include < stdio <sil=0.994> .PERIOD h>
int main ( v oi d )
{
i n t ∗p <sil=0.428> ;SEMICOLON p = ( int  ∗) malloc ( size of ( int  ) ) <sil=0.558> ;SEMICOLON ∗p = 10 <sil=0.505> ;SEMICOLON printf ("% d \ n " <sil=0.476> ,COMMA ∗ p ) <sil=0.351> ;SEMICOLON free ( p ) <sil=0.465> ;SEMICOLON return 0 <sil=0.367> ;SEMICOLON }
This code is really useful only for demonstrating the process of allocating <sil=0.534> ,COMMA deallocating <sil=0.363> ,COMMA and using a block in C <sil=0.987> .PERIOD The malloc line allocates a block of memory of the size specified – in this case <sil=0.309> ,COMMA sizeof(int) bytes (4 bytes) <sil=0.928> .PERIOD The sizeof command in C returns the size <sil=0.460> ,COMMA in bytes <sil=0.481> ,COMMA of any type <sil=0.932> .PERIOD The code could just as easily have said malloc(4) <sil=0.613> ,COMMA since sizeof(int) equals 4 bytes on most machines <sil=0.971> .PERIOD Using sizeof <sil=0.457> ,COMMA however <sil=0.997> ,COMMA makes the code much more portable and readable <sil=0.917> .PERIOD The malloc function returns a pointer to the allocated block <sil=0.983> .PERIOD This pointer is generic <sil=0.950> .PERIOD Using the pointer without typecasting generally produces a type warning from the compiler <sil=0.955> .PERIOD The (int *) typecast converts the generic pointer returned by malloc into a “pointer to an integer <sil=0.309> ,COMMA ” which is what p expects <sil=0.912> .PERIOD The free statement in C returns a block to the heap for reuse <sil=0.948> .PERIOD The second example illustrates the same functions as the previous example <sil=0.383> ,COMMA but it uses a structure instead of an integer <sil=0.974> .PERIOD In C <sil=0.537> ,COMMA the code looks like this:
# include < stdio <sil=0.974> .PERIOD h>
structrec
{
int i <sil=0.530> ;SEMICOLON float f <sil=0.392> ;SEMICOLON charc <sil=0.616> ;SEMICOLON } <sil=0.396> ;SEMICOLON int main ( v oi d )
{
structrec ∗p <sil=0.315> ;SEMICOLON p = ( structrec ∗) m all o c ( sizeof ( structrec ) ) <sil=0.382> ;SEMICOLON (∗ p ) <sil=0.985> .PERIOD i = 1 0 <sil=0.611> ;SEMICOLON (∗ p ) <sil=0.946> .PERIOD f = 3 <sil=0.928> .PERIOD 1 4 <sil=0.369> ;SEMICOLON (∗ p ) <sil=0.937> .PERIOD c = ’ a ’ <sil=0.572> ;SEMICOLON printf ("% d %f %c \ n " <sil=0.471> ,COMMA ( ∗ p ) <sil=0.935> .PERIOD i <sil=0.317> ,COMMA ( ∗ p ) <sil=0.970> .PERIOD f <sil=0.359> ,COMMA ( ∗ p ) <sil=0.983> .PERIOD c ) <sil=0.642> ;SEMICOLON free ( p ) <sil=0.599> ;SEMICOLON return 0 <sil=0.491> ;SEMICOLON }
Note the following line:
(∗ p ) <sil=0.992> .PERIOD i = 1 0 <sil=0.412> ;SEMICOLON Many wonder why the following doesn’t work:
∗p <sil=0.945> .PERIOD i = 1 0 <sil=0.351> ;SEMICOLON The answer has to do with the precedence of operators in C <sil=0.979> .PERIOD The result of the calculation 5+3*4 is 17 <sil=0.443> ,COMMA not 32 <sil=0.430> ,COMMA because the * operator has higher precedence than + in most computer languages <sil=0.942> .PERIOD In C <sil=0.599> ,COMMA the <sil=0.964> .PERIOD operator has higher precedence than * <sil=0.611> ,COMMA so parentheses force the proper precedence <sil=0.933> .PERIOD Most people tire of typing (*p) <sil=0.974> .PERIOD i all the time <sil=0.531> ,COMMA so C provides a shorthand notation <sil=0.917> .PERIOD The following two statements are exactly equivalent <sil=0.430> ,COMMA but the second is easier to type:
(∗ p ) <sil=0.984> .PERIOD i = 1 0 <sil=0.594> ;SEMICOLON p−>i = 1 0 <sil=0.401> ;SEMICOLON You will see the second more often than the first when reading other people’s code <sil=0.938> .PERIOD Advanced Pointers
You will normally use pointers in somewhat more complicated ways than those shown in some of the previous examples <sil=0.997> .PERIOD For example <sil=0.466> ,COMMA it is much easier to create a normal integer and work with it than it is to create and use a pointer to an integer <sil=0.974> .PERIOD In this section <sil=0.497> ,COMMA some of the more common and advanced ways of working with pointers will be explored <sil=0.926> .PERIOD Pointer Types
It is possible <sil=0.471> ,COMMA legal <sil=0.532> ,COMMA and beneficial to create pointer types in C <sil=0.301> ,COMMA as shown below:
Typedef int ∗ Int Pointer <sil=0.572> ;SEMICOLON  <sil=0.936> .PERIOD  <sil=0.917> .PERIOD  <sil=0.931> .PERIOD Int Pointer p <sil=0.381> ;SEMICOLON This is the same as saying:
int ∗p <sil=0.479> ;SEMICOLON This technique will be used in many of the examples on the following pages <sil=0.983> .PERIOD The technique often makes a data declaration easier to read and understand <sil=0.433> ,COMMA and also makes it easier to include pointers inside of structures or pass pointer parameters in functions <sil=0.944> .PERIOD Pointers to Structures
It is possible to create a pointer to almost any type in C <sil=0.476> ,COMMA including user-defined types <sil=0.911> .PERIOD It is extremely common to create pointers to structures <sil=0.997> .PERIOD Typesdef struct
{
char name [ 2 1 ] <sil=0.307> ;SEMICOLON char city [ 2 1 ] <sil=0.402> ;SEMICOLON char state [ 3 ] <sil=0.593> ;SEMICOLON } Rec <sil=0.430> ;SEMICOLON typedef Rec ∗ Rec Pointer <sil=0.541> ;SEMICOLON Rec Pointer r <sil=0.628> ;SEMICOLON r = ( Rec Pointer ) malloc ( sideof ( Rec ) ) <sil=0.347> ;SEMICOLON The pointer r is a pointer to a structure <sil=0.951> .PERIOD Please note the fact that r is a pointer <sil=0.623> ,COMMA and therefore takes four bytes of memory just like any other pointer <sil=0.940> .PERIOD However <sil=0.459> ,COMMA the malloc statement allocates 45 bytes of memory from the heap <sil=0.995> .PERIOD *r is a structure just like any other structure of type Rec <sil=0.901> .PERIOD The following code shows typical uses of the pointer variable:
strcpy ( ( ∗ r ) <sil=0.971> .PERIOD name <sil=0.322> ,COMMA " Leigh " ) <sil=0.391> ;SEMICOLON strcpy ( ( ∗ r ) <sil=0.978> .PERIOD city <sil=0.515> ,COMMA " Raleigh " ) <sil=0.342> ;SEMICOLON strcpy ( ( ∗ r ) <sil=0.941> .PERIOD state <sil=0.323> ,COMMA "NC " ) <sil=0.634> ;SEMICOLON printf ("% s \ n " <sil=0.600> ,COMMA (∗ r ) <sil=0.949> .PERIOD city ) <sil=0.501> ;SEMICOLON free ( r ) <sil=0.379> ;SEMICOLON You deal with *r just like a normal structure variable <sil=0.526> ,COMMA but you have to be careful with the precedence of operators in C <sil=0.929> .PERIOD If you were to leave off the parenthesis around *r the code would not compile because the “ <sil=0.901> .PERIOD ” operator has a higher precedence than the “*” operator <sil=0.952> .PERIOD Because it gets tedious to type so many parentheses when working with pointers to structures <sil=0.635> ,COMMA C includes a shorthand notation that does exactly the same thing:
strcpy ( r−>name <sil=0.342> ,COMMA " L ei g h " ) <sil=0.516> ;SEMICOLON The r-> notation is exactly equivalent to (*r) <sil=0.990> .PERIOD  <sil=0.357> ,COMMA but takes two fewer characters <sil=0.987> .PERIOD Pointers to Arrays
It is also possible to create pointers to arrays <sil=0.595> ,COMMA as shown below:
int ∗p <sil=0.430> ;SEMICOLON int i <sil=0.533> ;SEMICOLON p = ( int ∗) malloc ( sizeof ( int [ 1 0 ] ) ) <sil=0.389> ;SEMICOLON for ( i = 0 <sil=0.333> ;SEMICOLON i < 1 0 <sil=0.400> ;SEMICOLON i ++)
p [ i ] = 0 <sil=0.328> ;SEMICOLON free ( p ) <sil=0.432> ;SEMICOLON or:
int ∗p <sil=0.352> ;SEMICOLON int i <sil=0.352> ;SEMICOLON p = ( i n t ∗) malloc ( sizeof ( int [ 1 0 ] ) ) <sil=0.407> ;SEMICOLON for ( i = 0 <sil=0.550> ;SEMICOLON i < 1 0 <sil=0.411> ;SEMICOLON i ++)
∗( p+ i ) = 0 <sil=0.401> ;SEMICOLON free ( p ) <sil=0.383> ;SEMICOLON Note that when you create a pointer to an integer array <sil=0.525> ,COMMA you simply create a normal pointer to int <sil=0.963> .PERIOD The call to malloc allocates an array of whatever size you desire <sil=0.386> ,COMMA and the pointer points to that array’s first element <sil=0.955> .PERIOD You can either index through the array pointed to by p using normal array indexing <sil=0.453> ,COMMA or you can do it using pointer arithmetic <sil=0.938> .PERIOD C sees both forms as equivalent <sil=0.987> .PERIOD This particular technique is extremely useful when working with strings <sil=0.948> .PERIOD It lets you allocate enough storage to exactly hold a string of a particular size <sil=0.982> .PERIOD Arrays of Pointers
Sometimes a great deal of space can be saved <sil=0.604> ,COMMA or certain memory-intensive problems can be solved <sil=0.599> ,COMMA by declaring an array of pointers <sil=0.933> .PERIOD In the example code below <sil=0.523> ,COMMA an array of 10 pointers to structures is declared <sil=0.429> ,COMMA instead of declaring an array of structures <sil=0.967> .PERIOD If an array of the structures had been created instead <sil=0.403> ,COMMA 243 * 10 = 2 <sil=0.571> ,COMMA 430 bytes would have been required for the array <sil=0.950> .PERIOD Using the array of pointers allows the array to take up minimal space until the actual records are allocated with malloc statements <sil=0.906> .PERIOD The code below simply allocates one record <sil=0.642> ,COMMA places a value in it <sil=0.367> ,COMMA and disposes of the record to demonstrate the process:
Typesdef struct
{
char s1 [ 8 1 ] <sil=0.579> ;SEMICOLON char s2 [ 8 1 ] <sil=0.368> ;SEMICOLON char s3 [ 8 1 ] <sil=0.365> ;SEMICOLON } Rec <sil=0.316> ;SEMICOLON Rec ∗a [ 1 0 ] <sil=0.359> ;SEMICOLON a [ 0 ] = ( Rec ∗) malloc ( sizeof ( Rec ) ) <sil=0.307> ;SEMICOLON strcpy ( a [0]−> s1 <sil=0.399> ,COMMA " hello " ) <sil=0.526> ;SEMICOLON free ( a [ 0 ] ) <sil=0.562> ;SEMICOLON Structures Containing Pointers
Structures can contain pointers <sil=0.416> ,COMMA as shown below:
Typesdef struct
{
char name [ 2 1 ] <sil=0.581> ;SEMICOLON char city [ 2 1 ] <sil=0.378> ;SEMICOLON char  phone [ 2 1 ] <sil=0.320> ;SEMICOLON char ∗comment <sil=0.451> ;SEMICOLON } Addr <sil=0.572> ;SEMICOLON Addr s <sil=0.391> ;SEMICOLON char comm [ 1 0 0 ] <sil=0.621> ;SEMICOLON gets ( s <sil=0.957> .PERIOD name <sil=0.561> ,COMMA 2 0 ) <sil=0.440> ;SEMICOLON gets ( s <sil=0.952> .PERIOD c i t y <sil=0.312> ,COMMA 2 0 ) <sil=0.384> ;SEMICOLON gets ( s <sil=0.947> .PERIOD phone <sil=0.329> ,COMMA 2 0 ) <sil=0.498> ;SEMICOLON gets (comm <sil=0.430> ,COMMA 1 0 0 ) <sil=0.614> ;SEMICOLON s <sil=0.984> .PERIOD comment =
( c h a r ∗) m all o c ( sizeof ( char [ strlen(comm ) + 1 ] ) ) <sil=0.457> ;SEMICOLON strcpy ( s <sil=0.977> .PERIOD comment <sil=0.372> ,COMMA comm ) <sil=0.363> ;SEMICOLON This technique is useful when only some records actually contained a comment in the comment field <sil=0.916> .PERIOD If there is no comment for the record <sil=0.376> ,COMMA then the comment field would consist only of a pointer (4 bytes) <sil=0.900> .PERIOD Those records having a comment then allocate exactly enough space to hold the comment string <sil=0.448> ,COMMA based on the length of the string typed by the user <sil=0.924> .PERIOD Pointers to Pointers
It is possible and often useful to create pointers to pointers <sil=0.910> .PERIOD This technique is sometimes called a handle <sil=0.380> ,COMMA and is useful in certain situations where the operating system wants to be able to move blocks of memory on the heap around at its discretion <sil=0.950> .PERIOD int ∗∗p <sil=0.436> ;SEMICOLON int ∗q <sil=0.447> ;SEMICOLON p = ( int ∗ ∗) malloc ( sizeof ( int ∗ ) ) <sil=0.579> ;SEMICOLON ∗p = ( int ∗) malloc ( sizeof ( int ) ) <sil=0.363> ;SEMICOLON ∗∗p = 1 2 <sil=0.353> ;SEMICOLON q = ∗p <sil=0.587> ;SEMICOLON printf ("% d \ n " <sil=0.389> ,COMMA ∗q ) <sil=0.443> ;SEMICOLON free ( q ) <sil=0.303> ;SEMICOLON free ( p ) <sil=0.532> ;SEMICOLON Windows and the Mac OS use this structure to allow memory compaction on the heap <sil=0.962> .PERIOD The program manages the pointer p <sil=0.367> ,COMMA while the operating system manages the pointer *p <sil=0.967> .PERIOD Because the OS manages *p <sil=0.431> ,COMMA the block pointed to by *p (**p) can be moved <sil=0.622> ,COMMA and *p can be changed to reflect the move without affecting the program using p <sil=0.916> .PERIOD Pointers to pointers are also frequently used in C to handle pointer parameters in functions <sil=0.997> .PERIOD Pointers to Structures Containing Pointers
It is also possible to create pointers to structures that contain pointers <sil=0.987> .PERIOD The following example uses the Addr record from the previous section:
Typesdef struct
{
char name [ 2 1 ] <sil=0.317> ;SEMICOLON char r c i t y [ 2 1 ] <sil=0.444> ;SEMICOLON char  phone [ 2 1 ] <sil=0.491> ;SEMICOLON char  ∗comment <sil=0.506> ;SEMICOLON } Addr <sil=0.505> ;SEMICOLON Addr ∗ s <sil=0.500> ;SEMICOLON c h a r comm [ 1 0 0 ] <sil=0.462> ;SEMICOLON s = ( Addr ∗) m all o c ( sizeof ( Addr ) ) <sil=0.484> ;SEMICOLON gets ( s−>name <sil=0.457> ,COMMA 2 0 ) <sil=0.462> ;SEMICOLON gets ( s−> city <sil=0.325> ,COMMA 2 0 ) <sil=0.364> ;SEMICOLON gets ( s−>phone <sil=0.373> ,COMMA 2 0 ) <sil=0.511> ;SEMICOLON gets (comm <sil=0.341> ,COMMA 1 0 0 ) <sil=0.417> ;SEMICOLON s−>comment =
( char  ∗) m all o c ( sizeof ( char  [strlen (comm ) + 1 ] ) ) <sil=0.311> ;SEMICOLON strcpy ( s−>comment <sil=0.497> ,COMMA comm ) <sil=0.470> ;SEMICOLON The pointer s points to a structure that contains a pointer that points to a string <sil=0.949> .PERIOD In this example <sil=0.592> ,COMMA it is very easy to create lost blocks if you aren’t careful <sil=0.912> .PERIOD For example <sil=0.307> ,COMMA here is a different version of the AP example <sil=0.985> .PERIOD s = ( Addr ∗) m all o c ( sizeof ( Addr ) ) <sil=0.437> ;SEMICOLON gets (comm <sil=0.378> ,COMMA 1 0 0 ) <sil=0.549> ;SEMICOLON s−>comment =
( char  ∗) m all o c ( sizeof ( char [ strlen (comm ) + 1 ] ) ) <sil=0.519> ;SEMICOLON strcpy ( s−>comment <sil=0.416> ,COMMA comm ) <sil=0.355> ;SEMICOLON free ( s ) <sil=0.328> ;SEMICOLON This code creates a lost block because the structure containing the pointer pointing to the string is disposed of before the string block is disposed of <sil=0.480> ,COMMA as shown to the right <sil=0.901> .PERIOD Linking
Finally <sil=0.307> ,COMMA it is possible to create structures that are able to point to identical structures <sil=0.607> ,COMMA and this capability can be used to link together a whole string of identical records in a structure called a linked list <sil=0.994> .PERIOD Typesdef struct
{
char name [ 2 1 ] <sil=0.385> ;SEMICOLON Char city [ 2 1 ] <sil=0.525> ;SEMICOLON char state [ 2 1 ] <sil=0.421> ;SEMICOLON Addr ∗ next <sil=0.532> ;SEMICOLON } Addr <sil=0.345> ;SEMICOLON Addr ∗ first <sil=0.458> ;SEMICOLON The compiler will let you do this <sil=0.460> ,COMMA and it can be used with a little experience to create structures like the one shown to the right <sil=0.912> .PERIOD A Linked Stack Example
A good example of dynamic data structures is a simple stack library <sil=0.477> ,COMMA one that uses a dynamic list and includes functions to init <sil=0.335> ,COMMA clear <sil=0.370> ,COMMA push <sil=0.609> ,COMMA and pop <sil=0.939> .PERIOD The library’s header file looks like this:
/ ∗ Stack Library − This library offers the
minimal stack operations for a
stack of integers ( easily changeable ) ∗ /
typedef int stack _ d a t a <sil=0.571> ;SEMICOLON extern void stack _init ( ) <sil=0.390> ;SEMICOLON / ∗ Initialize this library <sil=0.901> .PERIOD Call first before calling anything <sil=0.978> .PERIOD ∗ /
extern void stack_clear ( ) <sil=0.481> ;SEMICOLON / ∗ Clears the stack of all entries <sil=0.937> .PERIOD ∗ /
extern int stack _ empty ( ) <sil=0.381> ;SEMICOLON / ∗ Returns 1 if stack is empty <sil=0.554> ,COMMA 0 otherwise <sil=0.966> .PERIOD ∗ /
extern void stack_push ( stack _ data d ) <sil=0.641> ;SEMICOLON / ∗ Pushes the value dont o the stack <sil=0.904> .PERIOD ∗ /
extern stack_data stack_pop ( ) <sil=0.368> ;SEMICOLON / ∗ Returns the top element of the stack <sil=0.519> ,COMMA and removes that element <sil=0.958> .PERIOD Returns Garbage If the stack is empty <sil=0.987> .PERIOD ∗ /
The library’s code file follows:
#include "stack <sil=0.904> .PERIOD h "
#include  <stdio <sil=0.992> .PERIOD h>
/ ∗ Stack Library − This library offers the minimal stack operations for a stack of integers ∗ /
struct stack_rec
{
stack_data data <sil=0.608> ;SEMICOLON struct stack_rec ∗ next <sil=0.377> ;SEMICOLON } <sil=0.400> ;SEMICOLON struct stack_rec ∗ top =NULL <sil=0.373> ;SEMICOLON void stack_init ( )
/ ∗ Initialize this library <sil=0.905> .PERIOD Call before calling anything else <sil=0.957> .PERIOD ∗ /
{
top =NULL <sil=0.327> ;SEMICOLON }
void stack_clear ( )
/ ∗ Clears the stack of all entries <sil=0.991> .PERIOD ∗ /
{
stack_data x <sil=0.548> ;SEMICOLON while ( <sil=0.893> !EXCLAMATIONMARK stack _ empty ( ) )
x= stack_pop ( ) <sil=0.525> ;SEMICOLON }
int stack _ em pt y ( )
/ ∗ Returns 1 if the stack is empty <sil=0.303> ,COMMA 0 otherwise <sil=0.908> .PERIOD ∗ /
{
if ( t o p ==NULL)
return ( 1 ) <sil=0.395> ;SEMICOLON else
return ( 0 ) <sil=0.637> ;SEMICOLON }
void stack _ push ( stack_data d )
/ ∗ Pushes the value dont o the stack <sil=0.926> .PERIOD ∗ /
{
struct stack_rec ∗ temp <sil=0.568> ;SEMICOLON temp = (struct stack _rec ∗) malloc ( sizeof ( struct stack _rec ) ) <sil=0.585> ;SEMICOLON temp−> data =d <sil=0.321> ;SEMICOLON temp−> next = top <sil=0.422> ;SEMICOLON top = temp <sil=0.360> ;SEMICOLON }
stack_data stack_pop ( )
/ ∗ Returns the top element of the stack <sil=0.553> ,COMMA and removes that element <sil=0.970> .PERIOD Returns Garbage If the stack is empty <sil=0.953> .PERIOD ∗ /
{
struct stack_rec ∗ temp <sil=0.510> ;SEMICOLON stack _ data d = 0 <sil=0.539> ;SEMICOLON if ( top <sil=0.937> !EXCLAMATIONMARK =NULL)
{
d=top −> data <sil=0.547> ;SEMICOLON temp= top <sil=0.453> ;SEMICOLON top =top −>next <sil=0.503> ;SEMICOLON free ( temp ) <sil=0.431> ;SEMICOLON }
return ( d ) <sil=0.381> ;SEMICOLON }
Programming exercise
• Add a dup <sil=0.363> ,COMMA a count <sil=0.399> ,COMMA and an add function to the stack library to duplicate the top element of the stack <sil=0.605> ,COMMA return a count of the number of elements in the stack <sil=0.536> ,COMMA and add the top two elements in the stack <sil=0.998> .PERIOD • Build a driver program and a makefile <sil=0.528> ,COMMA and compile the stack library with the driver to make sure it works <sil=0.985> .PERIOD Note how this library practices information hiding: Someone who can see only the header file cannot tell if the stack is implemented with arrays <sil=0.457> ,COMMA pointers <sil=0.625> ,COMMA files <sil=0.326> ,COMMA or in some other way <sil=0.981> .PERIOD Note also that C uses NULL <sil=0.904> .PERIOD NULL is defined in stdio <sil=0.945> .PERIOD h <sil=0.901> ,COMMA so you will almost always have to include stdio <sil=0.963> .PERIOD h when you use pointers <sil=0.907> .PERIOD NULL is the same as zero <sil=0.994> .PERIOD Using Pointers with Arrays
Arrays and pointers are intimately linked in C <sil=0.935> .PERIOD To use arrays effectively <sil=0.427> ,COMMA you have to know how to use pointers with them <sil=0.968> .PERIOD Fully understanding the relationship between the two probably requires several days of study and experimentation <sil=0.362> ,COMMA but it is well worth the effort <sil=0.946> .PERIOD Let’s start with a simple example of arrays in C:
# define MAX 10
int main ( v oi d )
{
int a [MAX] <sil=0.401> ;SEMICOLON int b [MAX] <sil=0.419> ;SEMICOLON int i <sil=0.354> ;SEMICOLON for ( i = 0 <sil=0.529> ;SEMICOLON i <MAX <sil=0.467> ;SEMICOLON i ++)
a [ i ]= i <sil=0.518> ;SEMICOLON b=a <sil=0.574> ;SEMICOLON return 0 <sil=0.305> ;SEMICOLON }
Enter this code and try to compile it <sil=0.929> .PERIOD You will find that C will not compile it <sil=0.923> .PERIOD If you want to copy a into b <sil=0.425> ,COMMA you have to enter something like the following instead:
for ( i = 0 <sil=0.362> ;SEMICOLON i <MAX <sil=0.596> ;SEMICOLON i ++)
b [ i ]= a [ i ] <sil=0.527> ;SEMICOLON Or <sil=0.616> ,COMMA to put it more succinctly:
for ( i = 0 <sil=0.433> ;SEMICOLON i <MAX <sil=0.590> ;SEMICOLON b [ i ]= a [ i ] <sil=0.474> ,COMMA i + + ) <sil=0.300> ;SEMICOLON Better yet <sil=0.446> ,COMMA use the memcpy utility in string <sil=0.912> .PERIOD h <sil=0.903> .PERIOD Arrays in C are unusual in that variables a and b are not <sil=0.367> ,COMMA technically <sil=0.450> ,COMMA arrays themselves <sil=0.917> .PERIOD Instead they are permanent pointers to arrays <sil=0.962> .PERIOD a and b permanently point to the first elements of their respective arrays – they hold the addresses of a[0] and b[0] respectively <sil=0.954> .PERIOD Since they are permanent pointers you cannot change their addresses <sil=0.992> .PERIOD The statement a=b <sil=0.636> ;SEMICOLON therefore does not work <sil=0.966> .PERIOD Because a and b are pointers <sil=0.492> ,COMMA you can do several interesting things with pointers and arrays <sil=0.916> .PERIOD For example <sil=0.617> ,COMMA the following code works:
# define MAX 10
void main ( v oi d )
{
int a [MAX] <sil=0.329> ;SEMICOLON int i <sil=0.609> ;SEMICOLON int ∗p <sil=0.637> ;SEMICOLON p=a <sil=0.567> ;SEMICOLON for ( i = 0 <sil=0.372> ;SEMICOLON i <MAX <sil=0.475> ;SEMICOLON i ++)
a [ i ]= i <sil=0.365> ;SEMICOLON printf ("% d \ n " <sil=0.615> ,COMMA ∗ p ) <sil=0.373> ;SEMICOLON }
The statement p=a <sil=0.577> ;SEMICOLON works because a is a pointer <sil=0.986> .PERIOD Technically <sil=0.608> ,COMMA a points to the address of the 0th element of the actual array <sil=0.985> .PERIOD This element is an integer <sil=0.429> ,COMMA so a is a pointer to a single integer <sil=0.978> .PERIOD Therefore <sil=0.330> ,COMMA declaring p as a pointer to an integer and setting it equal to a works <sil=0.957> .PERIOD Another way to say exactly the same thing would be to replace p=a <sil=0.362> ;SEMICOLON with p=&a[0] <sil=0.444> ;SEMICOLON  <sil=0.531> .PERIOD Since a contains the address of a[0] <sil=0.326> ,COMMA a and &a[0] mean the same thing <sil=0.947> .PERIOD Now that p is pointing at the 0th element of a <sil=0.453> ,COMMA you can do some rather strange things with it <sil=0.961> .PERIOD The a variable is a permanent pointer and can not be changed <sil=0.648> ,COMMA but p is not subject to such restrictions <sil=0.988> .PERIOD C actually encourages you to move it around using pointer arithmetic <sil=0.987> .PERIOD For example <sil=0.491> ,COMMA if you say p++ <sil=0.575> ;SEMICOLON  <sil=0.607> ,COMMA the compiler knows that p points to an integer <sil=0.306> ,COMMA so this statement increments p the appropriate number of bytes to move it to the next element of the array <sil=0.930> .PERIOD If p were pointing to an array of 100-byte-long structures <sil=0.425> ,COMMA p++ <sil=0.347> ;SEMICOLON would move p over by 100 bytes <sil=0.924> .PERIOD C takes care of
the details of element size <sil=0.965> .PERIOD You can copy the array a into b using pointers as well <sil=0.979> .PERIOD The following code can replace (for i=0 <sil=0.396> ;SEMICOLON i<MAX <sil=0.587> ;SEMICOLON a[i]=b[i] <sil=0.384> ,COMMA i++) <sil=0.502> ;SEMICOLON :
p=a <sil=0.625> ;SEMICOLON q=b <sil=0.550> ;SEMICOLON f o r ( i = 0 <sil=0.437> ;SEMICOLON i <MAX <sil=0.648> ;SEMICOLON i ++)
{
∗q = ∗p <sil=0.546> ;SEMICOLON q ++ <sil=0.388> ;SEMICOLON p ++ <sil=0.603> ;SEMICOLON }
You can abbreviate this code as follows:
p=a <sil=0.514> ;SEMICOLON q=b <sil=0.486> ;SEMICOLON for ( i = 0 <sil=0.497> ;SEMICOLON i <MAX <sil=0.466> ;SEMICOLON i ++)
∗q++ = ∗p ++ <sil=0.597> ;SEMICOLON And you can further abbreviate it to:
f o r ( p=a <sil=0.570> ,COMMA q=b <sil=0.305> ,COMMA i = 0 <sil=0.634> ;SEMICOLON i <MAX <sil=0.314> ;SEMICOLON ∗q++ = ∗p ++ <sil=0.435> ,COMMA i + + ) <sil=0.311> ;SEMICOLON What if you go beyond the end of the array a or b with the pointers p or q <sil=0.991> ?QUESTIONMARK C does not care – it blithely goes along incrementing p and q <sil=0.534> ,COMMA copying away over other variables with abandon <sil=0.995> .PERIOD You need to be careful when indexing into arrays in C <sil=0.559> ,COMMA because C assumes that you know what you are doing <sil=0.921> .PERIOD You can pass an array such as a or b to a function in two different ways <sil=0.929> .PERIOD Imagine a function dump that accepts an array of integers as a parameter and prints the contents of the array to stdout <sil=0.956> .PERIOD There are two ways to code dump:
void dump ( int a [ ] <sil=0.445> ,COMMA int n i a )
{
int i <sil=0.409> ;SEMICOLON for ( i = 0 <sil=0.357> ;SEMICOLON i < n i a <sil=0.645> ;SEMICOLON i ++)
printf ("% d \ n " <sil=0.407> ,COMMA a [ i ] ) <sil=0.636> ;SEMICOLON }
or:
void dump ( int ∗p <sil=0.432> ,COMMA int n i a )
{
int i <sil=0.386> ;SEMICOLON for ( i = 0 <sil=0.587> ;SEMICOLON i < n i a <sil=0.611> ;SEMICOLON i ++)
printf ("% d \ n " <sil=0.572> ,COMMA ∗ p + + ) <sil=0.399> ;SEMICOLON }
The nia (number_in_array) variable is required so that the size of the array is known <sil=0.933> .PERIOD Note that only a pointer to the array <sil=0.623> ,COMMA rather than the contents of the array <sil=0.492> ,COMMA is passed to the function <sil=0.920> .PERIOD Also note that C functions can accept variable-size arrays as parameters <sil=0.993> .PERIOD Strings
Strings in C are intertwined with pointers to a large extent <sil=0.993> .PERIOD You must become familiar with the pointer concepts covered in the previous articles to use C strings effectively <sil=0.977> .PERIOD Once you get used to them <sil=0.649> ,COMMA however <sil=0.907> ,COMMA you can often perform string manipulations very efficiently <sil=0.984> .PERIOD A string in C is simply an array of characters <sil=0.983> .PERIOD The following line declares an array that can hold a string of up to 99 characters <sil=0.944> .PERIOD char str [ 100 ] <sil=0.432> ;SEMICOLON It holds characters as you would expect: str[0] is the first character of the string <sil=0.611> ,COMMA str[1] is the  second character <sil=0.622> ,COMMA and so on <sil=0.961> .PERIOD But why is a 100-element array unable to hold up to 100 characters <sil=0.879> ?QUESTIONMARK Because C usesnull-terminated strings <sil=0.417> ,COMMA which means that the end of any string is marked by the ASCII value 0 (the null character) <sil=0.453> ,COMMA which is also represented in C as ‘\0’ <sil=0.946> .PERIOD Null termination is very different from the way many other languages handle strings <sil=0.950> .PERIOD For example <sil=0.386> ,COMMA in Pascal <sil=0.629> ,COMMA each string consists of an array of characters <sil=0.410> ,COMMA with a length byte that keeps count of the number of characters stored in the array <sil=0.947> .PERIOD This structure gives Pascal a definite advantage when you ask for the length of a string <sil=0.978> .PERIOD Pascal can simply return the length byte <sil=0.493> ,COMMA whereas C has to count the characters until it finds ‘\0’ <sil=0.904> .PERIOD This fact makes C much slower than Pascal in certain cases <sil=0.337> ,COMMA but in others it makes it faster <sil=0.424> ,COMMA as we will see in the examples below <sil=0.908> .PERIOD Because C provides no explicit support for strings in the language itself <sil=0.432> ,COMMA all of the string-handling functions are implemented in libraries <sil=0.987> .PERIOD The string I/0 operations (gets <sil=0.399> ,COMMA puts <sil=0.477> ,COMMA and so on) are implemented in <stdio <sil=0.979> .PERIOD h> <sil=0.996> ,COMMA and a set of fairly simple string manipulation functions are implemented in <string <sil=0.959> .PERIOD h> (on some systems <sil=0.573> ,COMMA <strings <sil=0.914> .PERIOD h> ) <sil=0.963> .PERIOD The fact that strings are not native to C forces you to create some fairly roundabout code <sil=0.991> .PERIOD For example <sil=0.437> ,COMMA suppose you want to assign one string to another string <sil=0.379> ;SEMICOLON that is <sil=0.313> ,COMMA you want to copy the contents of one string to another <sil=0.936> .PERIOD In C you cannot simply assign one array to another <sil=0.983> .PERIOD You have to copy it element by element <sil=0.903> .PERIOD The string library (<string <sil=0.938> .PERIOD h> or <strings <sil=0.928> .PERIOD h> ) contains a function called strcpy for this task <sil=0.939> .PERIOD Here is an extremely common piece of code to find in a normal C program:
chars [ 1 0 0 ] <sil=0.450> ;SEMICOLON str cpy ( s <sil=0.402> ,COMMA " hello " ) <sil=0.569> ;SEMICOLON The following code shows how to use strcpy in C:
# include < string <sil=0.920> .PERIOD h>
int main ( void )
{
Char s1 [ 100 ] <sil=0.333> ,COMMA s2 [ 100 ] <sil=0.352> ;SEMICOLON Str cpy ( s1 <sil=0.334> ,COMMA " hello " ) <sil=0.454> ;SEMICOLON / ∗ copy " hello " into s1 ∗ /
Str cpy ( s2 <sil=0.446> ,COMMA s 1 ) <sil=0.433> ;SEMICOLON / ∗ copy s1 into s2 ∗ /
return 0 <sil=0.405> ;SEMICOLON }
strcpy is used whenever a string is initialized in C <sil=0.987> .PERIOD You use the strcmp function in the string library to compare two strings <sil=0.945> .PERIOD It returns an integer that indicates the result of the comparison <sil=0.942> .PERIOD Zero means the two strings are equal <sil=0.307> ,COMMA a negative value means that s1 is less than s2 <sil=0.449> ,COMMA and a positive value means s1 is greater than s2 <sil=0.950> .PERIOD #include < stdio <sil=0.909> .PERIOD h>
#include < string <sil=0.995> .PERIOD h>
int main ( void )
{
chars 1 [ 100 ] <sil=0.397> ,COMMA s2 [ 100 ] <sil=0.585> ;SEMICOLON gets ( s1 ) <sil=0.326> ;SEMICOLON gets ( s2 ) <sil=0.561> ;SEMICOLON if ( st r cm p ( s1 <sil=0.363> ,COMMA s2 ) == 0 ) {
printf ( " equal \ n " ) <sil=0.374> ;SEMICOLON } else if ( str cmp ( s1 <sil=0.451> ,COMMA s2 ) < 0 ) {
printf ( " s1 less than s2 \ n " ) <sil=0.646> ;SEMICOLON } else {
printf ( " s1 greater than s2 \ n " ) <sil=0.373> ;SEMICOLON }
return 0 <sil=0.573> ;SEMICOLON }
Other common functions in the string library include strlen <sil=0.327> ,COMMA which returns the length of a string <sil=0.391> ,COMMA and strcat which concatenates two strings <sil=0.948> .PERIOD The string library contains a number of other functions <sil=0.579> ,COMMA which you can peruse by reading the man page <sil=0.976> .PERIOD To get you started building string functions <sil=0.383> ,COMMA and to help you understand other programmers’ code (everyone seems to have his or her own set of string functions for special purposes in a program) <sil=0.577> ,COMMA we will look at two examples <sil=0.459> ,COMMA strlen and strcpy <sil=0.945> .PERIOD Following is a strictly Pascal-like version of strlen:
int strlen ( chars [ ] )
{
int x <sil=0.301> ;SEMICOLON x = 0 <sil=0.513> ;SEMICOLON while ( s [ x ] <sil=0.852> !EXCLAMATIONMARK = ’ \ 0 ’ )
x=x + 1 <sil=0.451> ;SEMICOLON return ( x ) <sil=0.644> ;SEMICOLON }
Most C programmers shun this approach because it seems inefficient <sil=0.915> .PERIOD Instead <sil=0.303> ,COMMA they often use a pointer-based approach:
int strlen ( char ∗ s )
{
int x = 0 <sil=0.413> ;SEMICOLON while (∗ s <sil=0.862> !EXCLAMATIONMARK = ’ \ 0 ’ )
{
x ++ <sil=0.324> ;SEMICOLON s ++ <sil=0.570> ;SEMICOLON }
return ( x ) <sil=0.405> ;SEMICOLON }
You can abbreviate this code to the following:
int strlen ( char ∗ s )
{
int x = 0 <sil=0.443> ;SEMICOLON while (∗ s ++)
x ++ <sil=0.355> ;SEMICOLON return ( x ) <sil=0.458> ;SEMICOLON }
I imagine a true C expert could make this code even shorter <sil=0.914> .PERIOD When I compile these three pieces of code with gcc <sil=0.506> ,COMMA using no optimization <sil=0.366> ,COMMA and run each 20 <sil=0.532> ,COMMA 000 times on a 120-character string <sil=0.381> ,COMMA the first piece of code yields a time of 12 <sil=0.955> .PERIOD 3 seconds <sil=0.547> ,COMMA the second 12 <sil=0.957> .PERIOD 3 seconds <sil=0.464> ,COMMA and the third 12 <sil=0.920> .PERIOD 9 seconds <sil=0.994> .PERIOD What does this mean <sil=0.941> ?QUESTIONMARK To me <sil=0.399> ,COMMA it means that you should write the code in whatever way is easiest for you to understand <sil=0.907> .PERIOD Pointers generally yield faster code <sil=0.340> ,COMMA but the strlen code above shows that that is not always the case <sil=0.957> .PERIOD We can go through the same evolution with strcpy:
strcpy ( char s1 [ ] <sil=0.605> ,COMMA char s2 [ ] )
{
int x <sil=0.559> ;SEMICOLON for ( x = 0 <sil=0.549> ;SEMICOLON x <= strcpy ( s 2 ) <sil=0.325> ;SEMICOLON x ++)
s1 [ x ] = s2 [ x ] <sil=0.540> ;SEMICOLON }
Note here that <= is important in the for loop because the code then copies the ‘\0’ <sil=0.957> .PERIOD Be sure to copy ‘\0’ <sil=0.925> .PERIOD Major bugs occur later on if you leave it out <sil=0.541> ,COMMA because the string has no end and therefore an unknown length <sil=0.976> .PERIOD Note also that this code is very inefficient <sil=0.357> ,COMMA because strlen gets called every time through the for loop <sil=0.975> .PERIOD To solve this problem <sil=0.379> ,COMMA you could use the following code:
strcpy ( char s1 [ ] <sil=0.496> ,COMMA char s2 [ ] )
{
int x <sil=0.450> ,COMMA len <sil=0.576> ;SEMICOLON len = strlen ( s2 ) <sil=0.471> ;SEMICOLON for ( x = 0 <sil=0.595> ;SEMICOLON x <= len <sil=0.467> ;SEMICOLON x ++)
s1 [ x ] = s2 [ x ] <sil=0.605> ;SEMICOLON }
The pointer version is similar <sil=0.976> .PERIOD strcpy ( char ∗ s1 <sil=0.350> ,COMMA char ∗ s2 )
{
while (∗ s2 <sil=0.991> !EXCLAMATIONMARK = ’ \ 0 ’ )
{
∗ s1 = ∗ s2 <sil=0.482> ;SEMICOLON s1 ++ <sil=0.632> ;SEMICOLON s2 ++ <sil=0.599> ;SEMICOLON }
}
You can compress this code further:
strcpy ( char ∗ s1 <sil=0.374> ,COMMA char ∗ s 2 )
{
while (∗ s2 )
∗ s1 ++ = ∗ s2 ++ <sil=0.465> ;SEMICOLON }
If you wish <sil=0.305> ,COMMA you can even say while (*s1++ = *s2++) <sil=0.623> ;SEMICOLON  <sil=0.339> .PERIOD The first version of strcpy takes 415 seconds to copy a 120-character string 10 <sil=0.559> ,COMMA 000 times <sil=0.333> ,COMMA the second version takes 14 <sil=0.971> .PERIOD 5 seconds <sil=0.636> ,COMMA the third version 9 <sil=0.965> .PERIOD 8 seconds <sil=0.323> ,COMMA and the fourth 10 <sil=0.907> .PERIOD 3 seconds <sil=0.396> .PERIOD As you can see <sil=0.528> ,COMMA pointers provide a significant performance boost here <sil=0.929> .PERIOD The prototype for the strcpy function in the string library indicates that it is designed to return a pointer to a string:
char ∗ s t r c p y ( c h a r ∗ s1 <sil=0.477> ,COMMA c h a r ∗ s 2 )
Most of the string functions return a string pointer as a result <sil=0.434> ,COMMA and strcpy returns
the value of s1 as its result <sil=0.947> .PERIOD Using pointers with strings can sometimes result in definite improvements in speed and you can take advantage of these if you think about them a little <sil=0.978> .PERIOD For example <sil=0.396> ,COMMA suppose you want to remove the leading blanks from a string <sil=0.990> .PERIOD You might be inclined to shift characters over on top of the blanks to remove them <sil=0.922> .PERIOD In C <sil=0.430> ,COMMA you can avoid the movement altogether:
# include < stdio <sil=0.947> .PERIOD h>
# include < string <sil=0.985> .PERIOD h>
int main ( void )
{
chars [ 100 ] <sil=0.307> ,COMMA ∗p <sil=0.574> ;SEMICOLON gets ( s ) <sil=0.646> ;SEMICOLON p = s <sil=0.351> ;SEMICOLON while (∗ p == ’ ’ )
p ++ <sil=0.579> ;SEMICOLON print f ("% s \ n " <sil=0.457> ,COMMA p ) <sil=0.602> ;SEMICOLON return 0 <sil=0.496> ;SEMICOLON }
This is much faster than the movement technique <sil=0.379> ,COMMA especially for long strings <sil=0.999> .PERIOD You will pick up many other tricks with strings as you go along and read other code <sil=0.926> .PERIOD Practice is the key <sil=0.975> .PERIOD Special Note on String Constants Suppose you create the following two code fragments and run them:
Fragment 1
{
char ∗ s <sil=0.373> ;SEMICOLON s = " hello " <sil=0.509> ;SEMICOLON printf ("% s \ n " <sil=0.379> ,COMMA s ) <sil=0.546> ;SEMICOLON }
Fragment 2
{
chars [ 100 ] <sil=0.387> ;SEMICOLON strcpy ( s <sil=0.920> ,COMMA " hello " ) <sil=0.630> ;SEMICOLON printf ("% s \ n " <sil=0.424> ,COMMA s ) <sil=0.524> ;SEMICOLON }
These two fragments produce the same output <sil=0.556> ,COMMA but their internal behavior is quite different <sil=0.910> .PERIOD In fragment 2 <sil=0.420> ,COMMA you cannot say s = “hello” <sil=0.465> ;SEMICOLON  <sil=0.472> .PERIOD To understand the differences <sil=0.533> ,COMMA you have to understand how the string constant table works in C <sil=0.938> .PERIOD When your program is compiled <sil=0.360> ,COMMA the compiler forms the object code file <sil=0.546> ,COMMA which contains your machine code and a table of all the string constants declared in the program <sil=0.951> .PERIOD In fragment 1 <sil=0.478> ,COMMA the statement s = “hello” <sil=0.613> ;SEMICOLON causes s to point to the address of the string hello in the string constant table <sil=0.922> .PERIOD Since this string is in the string constant table <sil=0.466> ,COMMA and therefore technically a part of the executable code <sil=0.505> ,COMMA you cannot modify it <sil=0.917> .PERIOD You can only point to it and use it in a read-only manner <sil=0.963> .PERIOD In fragment 2 <sil=0.372> ,COMMA the string hello also exists in the constant table <sil=0.471> ,COMMA so you can copy it into the array of characters named s <sil=0.940> .PERIOD Since s is not a pointer <sil=0.312> ,COMMA the statement s = “hello” <sil=0.327> ;SEMICOLON will not work in fragment 2 <sil=0.939> .PERIOD It will not even compile <sil=0.909> .PERIOD Special Note on Using Strings with malloc
Suppose you write the following program:
int main ( void )
{
char ∗ s <sil=0.318> ;SEMICOLON s = ( char ∗) malloc ( 100 ) <sil=0.603> ;SEMICOLON s = " hello " <sil=0.314> ;SEMICOLON free ( s ) <sil=0.581> ;SEMICOLON return 0 <sil=0.436> ;SEMICOLON }
It compiles properly <sil=0.378> ,COMMA but gives a segmentation fault at the free line when you run it <sil=0.977> .PERIOD The malloc line allocates a block 100 bytes long and points s at it <sil=0.313> ,COMMA but now the s = “hello” <sil=0.582> ;SEMICOLON line is a problem <sil=0.985> .PERIOD It is syntactically correct because s is a pointer <sil=0.435> ;SEMICOLON however <sil=0.990> ,COMMA when s = “hello” <sil=0.360> ;SEMICOLON is executed <sil=0.505> ,COMMA s points to the string in the string constant table and the allocated block is orphaned <sil=0.965> .PERIOD Since s is pointing into the string constant table <sil=0.444> ,COMMA the string cannot be changed <sil=0.400> ;SEMICOLON free fails because it cannot deallocate a block in an executable region <sil=0.991> .PERIOD The correct code follows:
int main ( void )
{
char ∗ s <sil=0.615> ;SEMICOLON s = ( char ∗) malloc ( 100 ) <sil=0.582> ;SEMICOLON str cpy ( s <sil=0.370> ,COMMA " hello " ) <sil=0.561> ;SEMICOLON free ( s ) <sil=0.353> ;SEMICOLON return 0 <sil=0.436> ;SEMICOLON }
Programming exercise
• Create a program that reads in a string containing a first name followed by a blank followed by a last name <sil=0.942> .PERIOD Write functions to remove any leading or trailing blanks <sil=0.965> .PERIOD Write another function that returns the last name <sil=0.983> .PERIOD • Write a function that converts a string to uppercase <sil=0.953> .PERIOD • Write a function that gets the first word from a string and returns the remainder of the string <sil=0.995> .PERIOD Operator Precedence <sil=0.301> ,COMMA II
C contains many operators <sil=0.596> ,COMMA and because of the way in which operator precedence works <sil=0.467> ,COMMA the interactions between multiple operators can become confusing <sil=0.939> .PERIOD x = 5 + 3 ∗ 6 <sil=0.428> ;SEMICOLON x receives the value 23 <sil=0.545> ,COMMA not 48 <sil=0.382> ,COMMA because in C multiplication and division have higher precedence than addition and subtraction <sil=0.916> .PERIOD char ∗ a { [ } 1 0 { ] } <sil=0.403> ;SEMICOLON Is a a single pointer to an array of 10 characters <sil=0.400> ,COMMA or is it an array of 10 pointers to character <sil=0.920> ?QUESTIONMARK Unless you know the precedence conventions in C <sil=0.365> ,COMMA there is no way to find out <sil=0.907> .PERIOD Similarly <sil=0.616> ,COMMA because of precedence statements such as *p <sil=0.939> .PERIOD i = 10 <sil=0.582> ;SEMICOLON do not work <sil=0.910> .PERIOD Instead <sil=0.544> ,COMMA the form (*p) <sil=0.955> .PERIOD i = 10 <sil=0.418> ;SEMICOLON must be used to force correct precedence <sil=0.971> .PERIOD The following table from C Programming Language by Kernighan and Ritchie <sil=0.517> ,COMMA shows the precedence hierarchy in C <sil=0.963> .PERIOD The top line has the highest precedence <sil=0.996> .PERIOD Operators Associativity
( [ − <sil=0.961> .PERIOD Left to right <sil=0.914> !EXCLAMATIONMARK − ++ −{− + ∗ & ( type−cast ) size of Right to left
(in the above line <sil=0.378> ,COMMA + <sil=0.344> ,COMMA − and ∗ are the unary forms )
∗ / % Left to right
+ − left to right
<< >> left to right
< <= > >= left to right
== <sil=0.935> !EXCLAMATIONMARK = left to right
& left to right
^ left to right
| left to right
&& left to right
| | left to right <sil=0.945> ?QUESTIONMARK : left to right
= += −= ∗= / = %= &= ^= | = <<= >>= Right to left <sil=0.528> ,COMMA left to right
Using this table <sil=0.539> ,COMMA you can see that char *a[10] <sil=0.497> ;SEMICOLON is an array of 10 pointers to character <sil=0.905> .PERIOD You can also see why the parentheses are required if (*p) <sil=0.906> .PERIOD i is to be handled correctly <sil=0.942> .PERIOD After some practice <sil=0.572> ,COMMA you will memorize most of this table <sil=0.433> ,COMMA but every now and again something will not work because you have been caught by a subtle precedence problem <sil=0.964> .PERIOD Command Line Arguments
C provides a fairly simple mechanism for retrieving command line parameters entered by the user <sil=0.918> .PERIOD It passes an argv parameter to the main function in the program <sil=0.982> .PERIOD argv structures appear in a fair number of the more advanced library calls <sil=0.376> ,COMMA so understanding them is useful to any C programmer <sil=0.990> .PERIOD Enter the following code and compile it:
# include < stdio <sil=0.939> .PERIOD h>
int main ( int arg c <sil=0.566> ,COMMA char ∗ arg v [ ] )
{
int x <sil=0.439> ;SEMICOLON printf ("% d \ n " <sil=0.438> ,COMMA arg c ) <sil=0.449> ;SEMICOLON for ( x = 0 <sil=0.441> ;SEMICOLON x < arg c <sil=0.556> ;SEMICOLON x ++)
printf ("% s \ n " <sil=0.483> ,COMMA arg v [ x ] ) <sil=0.330> ;SEMICOLON return 0 <sil=0.466> ;SEMICOLON }
In this code <sil=0.388> ,COMMA the main program accepts two parameters <sil=0.549> ,COMMA argv and argc <sil=0.935> .PERIOD The argv parameter is an array of pointers to string that contains the parameters entered when the program was invoked at the UNIX command line <sil=0.912> .PERIOD The argc integer contains a count of the number of parameters <sil=0.989> .PERIOD This particular piece of code types out the command line parameters <sil=0.981> .PERIOD To try this <sil=0.501> ,COMMA compile the code to an executable file named aaa and type aaa xxx yyy zzz <sil=0.961> .PERIOD The code will print the command line parameters xxx <sil=0.489> ,COMMA yyy and zzz <sil=0.376> ,COMMA one per line <sil=0.972> .PERIOD The char *argv[] line is an array of pointers to string <sil=0.982> .PERIOD In other words <sil=0.420> ,COMMA each element of the array is a pointer <sil=0.305> ,COMMA and each pointer points to a string (technically <sil=0.383> ,COMMA to the first character of the string) <sil=0.930> .PERIOD Thus <sil=0.635> ,COMMA argv[0] points to a string that contains the first parameter on the command line (the program’s name) <sil=0.347> ,COMMA argv[1] points to the next parameter <sil=0.345> ,COMMA and so on <sil=0.998> .PERIOD The argc variable tells you how many of the pointers in the array are valid <sil=0.906> .PERIOD You will find that the preceding code does nothing more than print each of the valid strings pointed to by argv <sil=0.922> .PERIOD Because argv exists <sil=0.615> ,COMMA you can let your program react to command line parameters entered by the user fairly easily <sil=0.954> .PERIOD For example <sil=0.415> ,COMMA you might have your program detect the word help as the first parameter following the program name <sil=0.373> ,COMMA and dump a help file to stdout <sil=0.997> .PERIOD File names can also be passed in and used in your fopen statements <sil=0.939> .PERIOD Text files
Text files in C are straightforward and easy to understand <sil=0.969> .PERIOD All text file functions and types in C come from the stdio library <sil=0.938> .PERIOD When you need text I/O in a C program <sil=0.425> ,COMMA and you need only one source for input information and one sink for output information <sil=0.415> ,COMMA you can rely on stdin (standard in) and stdout (standard out) <sil=0.993> .PERIOD You can then use input and output redirection at the command line to move different information streams through the program <sil=0.979> .PERIOD There are six different I/O commands in <stdio <sil=0.903> .PERIOD h> that you can use with stdin and stdout:
• printf - prints formatted output to stdout
• scanf - reads formatted input from stdin
• puts - prints a string to stdout
• gets - reads a string from stdin
• putc - prints a character to stdout
• getc <sil=0.564> ,COMMA getchar - reads a character from stdin
The advantage of stdin and stdout is that they are easy to use <sil=0.997> .PERIOD Likewise <sil=0.314> ,COMMA the ability to redirect I/O is very powerful <sil=0.910> .PERIOD For example <sil=0.588> ,COMMA maybe you want to create a program that reads from stdin and counts the number of characters:
# include < stdio h>
# include < string <sil=0.954> .PERIOD h>
int main ( void )
{
chars [ 1000 ] <sil=0.578> ;SEMICOLON int count = 0 <sil=0.468> ;SEMICOLON while ( gets ( s ) )
{
count += strlen ( s ) <sil=0.344> ;SEMICOLON }
printf ("% d \ n " <sil=0.384> ,COMMA count ) <sil=0.613> ;SEMICOLON return 0 <sil=0.381> ;SEMICOLON }
Enter this code and run it <sil=0.979> .PERIOD It waits for input from stdin <sil=0.435> ,COMMA so type a few lines <sil=0.997> .PERIOD When you are done <sil=0.302> ,COMMA press CTRL-D to signal end-of-file (eof) <sil=0.968> .PERIOD The gets function reads a line until it detects eof <sil=0.397> ,COMMA then returns a 0 so that the while loop ends <sil=0.999> .PERIOD When you press CTRL-D <sil=0.471> ,COMMA you see a count of the number of characters in stdout (the screen) <sil=0.995> .PERIOD (Use man gets or your compiler’s documentation to learn more about the gets function <sil=0.981> .PERIOD )
Now <sil=0.610> ,COMMA suppose you want to count the characters in a file <sil=0.969> .PERIOD If you compiled the program to an executable named xxx <sil=0.359> ,COMMA you can type the following:
xxx < filename
Instead of accepting input from the keyboard <sil=0.556> ,COMMA the contents of the file named filename will be used instead <sil=0.935> .PERIOD You can achieve the same result using pipes:
c a t < filename | xxx
You can also redirect the output to a file:
xxx < filename > out
This command places the character count produced by the program in a text file named out <sil=0.967> .PERIOD Sometimes <sil=0.508> ,COMMA you need to use a text file directly <sil=0.908> .PERIOD For example <sil=0.456> ,COMMA you might need to open a specific file and read from or write to it <sil=0.998> .PERIOD You might want to manage several streams of input or output or create a program like a text editor that can save and recall data or configuration files on command <sil=0.904> .PERIOD In that case <sil=0.494> ,COMMA use the text file functions in stdio:
• fopen - opens a text file
• fclose - closes a text file
• feof - detects end-of-file marker in a file
• fprintf - prints formatted output to a file
• fscanf - reads formatted input from a file
• fputs - prints a string to a file
• fgets - reads a string from a file
• fputc - prints a character to a file
• fgetc - reads a character from a file
Text files: opening
You use fopen to open a file <sil=0.975> .PERIOD It opens a file for a specified mode (the three most common are r <sil=0.614> ,COMMA w <sil=0.617> ,COMMA and a <sil=0.580> ,COMMA for read <sil=0.616> ,COMMA write <sil=0.425> ,COMMA and append) <sil=0.934> .PERIOD It then returns a file pointer that you use to access the file <sil=0.938> .PERIOD For example <sil=0.625> ,COMMA suppose you want to open a file and write the numbers 1 to 10 in it <sil=0.971> .PERIOD You could use the following code:
# include < stdio <sil=0.933> .PERIOD h>
# define MAX 10
int main ( void )
{
FILE ∗ f <sil=0.584> ;SEMICOLON int x <sil=0.395> ;SEMICOLON f = fopen ( " out " <sil=0.642> ,COMMA "w " ) <sil=0.494> ;SEMICOLON if ( <sil=0.864> !EXCLAMATIONMARK f )
return 1 <sil=0.483> ;SEMICOLON for ( x = 1 <sil=0.580> ;SEMICOLON x <= MAX <sil=0.589> ;SEMICOLON x ++)
fprintf ( f <sil=0.542> ,COMMA "% d \ n " <sil=0.393> ,COMMA x ) <sil=0.551> ;SEMICOLON fclose ( f ) <sil=0.392> ;SEMICOLON return 0 <sil=0.346> ;SEMICOLON }
The fopen statement here opens a file named out with the w mode <sil=0.977> .PERIOD This is a destructive write mode <sil=0.342> ,COMMA which means that if out does not exist it is created <sil=0.414> ,COMMA but if it does exist it is destroyed and a new file is created in its place <sil=0.985> .PERIOD The fopen command returns a pointer to the file <sil=0.518> ,COMMA which is stored in the variable f <sil=0.901> .PERIOD This variable is used to refer to the file <sil=0.950> .PERIOD If the file cannot be opened for some reason <sil=0.366> ,COMMA f will contain NULL <sil=0.927> .PERIOD The fprintf statement should look very familiar: It is just like printf but uses the file pointer as its first parameter <sil=0.940> .PERIOD The fclose statement closes the file when you are done <sil=0.937> .PERIOD Text files: reading
To read a file <sil=0.388> ,COMMA open it with r mode <sil=0.986> .PERIOD In general <sil=0.432> ,COMMA it is not a good idea to use fscanffor reading: Unless the file is perfectly formatted <sil=0.360> ,COMMA fscanf will not handle it correctly <sil=0.990> .PERIOD Instead <sil=0.613> ,COMMA use fgets to read in each line and then parse out the pieces you need <sil=0.969> .PERIOD The following code demonstrates the process of reading a file and dumping its contents to the screen:
# include < stdio <sil=0.967> .PERIOD h>
int main ( void )
{
FILE ∗ f <sil=0.322> ;SEMICOLON chars [ 1000 ] <sil=0.320> ;SEMICOLON f = fopen ( "  infile " <sil=0.349> ,COMMA " r " ) <sil=0.621> ;SEMICOLON if ( <sil=0.887> !EXCLAMATIONMARK f )
return 1 <sil=0.624> ;SEMICOLON while ( fgets ( s <sil=0.519> ,COMMA 1000 <sil=0.503> ,COMMA f ) <sil=0.946> !EXCLAMATIONMARK = NULL)
printf ("% s " <sil=0.570> ,COMMA s ) <sil=0.491> ;SEMICOLON fclose ( f ) <sil=0.559> ;SEMICOLON return 0 <sil=0.591> ;SEMICOLON }
The fgets statement returns a NULL value at the end-of-file marker <sil=0.988> .PERIOD It reads a line (up to 1 <sil=0.320> ,COMMA 000 characters in this case) and then prints it to stdout <sil=0.900> .PERIOD Notice that the printf statement does not include \n in the format string <sil=0.428> ,COMMA because fgets adds \n to the end of each line it reads <sil=0.909> .PERIOD Thus <sil=0.310> ,COMMA you can tell if a line is not complete in the event that it overflows the maximum line length specified in the second parameter to fgets <sil=0.961> .PERIOD Main function return values
This program is the first program in this series that returns an error value from the main program <sil=0.969> .PERIOD If the fopen command fails <sil=0.595> ,COMMA f will contain a NULL value (a zero) <sil=0.934> .PERIOD We test for that error with the if statement <sil=0.956> .PERIOD The if statement looks at the True/False value of the variable f <sil=0.967> .PERIOD Remember that in C <sil=0.398> ,COMMA 0 is False and anything else is true <sil=0.994> .PERIOD So if there were an error opening the file <sil=0.629> ,COMMA f would contain zero <sil=0.314> ,COMMA which is False <sil=0.990> .PERIOD The <sil=0.851> !EXCLAMATIONMARK is the NOT operator <sil=0.925> .PERIOD It inverts a Boolean value <sil=0.953> .PERIOD So the if statement could have been written like this:
if ( f == 0 )
That is equivalent <sil=0.989> .PERIOD However <sil=0.502> ,COMMA if ( <sil=0.879> !EXCLAMATIONMARK f) is more common <sil=0.965> .PERIOD If there is a file error <sil=0.476> ,COMMA we return a 1 from the main function <sil=0.987> .PERIOD In Linux <sil=0.556> ,COMMA you can actually test for this value on the command line <sil=0.930> .PERIOD See the shell documentation for details <sil=0.984> .PERIOD Binary Files
Binary files are very similar to arrays of structures <sil=0.360> ,COMMA except the structures are in a disk file rather than in an array in memory <sil=0.935> .PERIOD Because the structures in a binary file are on disk <sil=0.457> ,COMMA you can create very large collections of them (limited only by your available disk space) <sil=0.902> .PERIOD They are also permanent and always available <sil=0.908> .PERIOD The only disadvantage is the slowness that comes from disk access time <sil=0.912> .PERIOD Binary files have two features that distinguish them from text files:
• You can jump instantly to any structure in the file <sil=0.595> ,COMMA which provides random access as in an array <sil=0.998> .PERIOD • You can change the contents of a structure anywhere in the file at any time <sil=0.929> .PERIOD Binary files also usually have faster read and write times than text files <sil=0.460> ,COMMA because a binary image of the record is stored directly from memory to disk (or vice versa) <sil=0.997> .PERIOD In a text file <sil=0.516> ,COMMA everything has to be converted back and forth to text <sil=0.528> ,COMMA and this takes time <sil=0.967> .PERIOD C supports the file-of-structures concept very cleanly <sil=0.974> .PERIOD Once you open the file you can read a structure <sil=0.439> ,COMMA write a structure <sil=0.607> ,COMMA or seek to any structure in the file <sil=0.999> .PERIOD This file concept supports the concept of a file pointer <sil=0.918> .PERIOD When the file is opened <sil=0.324> ,COMMA the pointer points to record 0 (the first record in the file) <sil=0.915> .PERIOD Any read operation reads the currently pointed-to structure and moves the pointer down one structure <sil=0.977> .PERIOD Any write operation writes to the currently pointed-to structure and moves the pointer down one structure <sil=0.937> .PERIOD Seek moves the pointer to the requested record <sil=0.926> .PERIOD Keep in mind that C thinks of everything in the disk file as blocks of bytes read from disk into memory or read from memory onto disk <sil=0.972> .PERIOD C uses a file pointer <sil=0.368> ,COMMA but it can point to any byte location in the file <sil=0.940> .PERIOD You therefore have to keep track of things <sil=0.954> .PERIOD The following program illustrates these concepts:
# include < stdio <sil=0.907> .PERIOD h>
/ ∗ random record description − could be anything ∗ /
struct rec
{
int x <sil=0.593> ,COMMA y <sil=0.346> ,COMMA z <sil=0.303> ;SEMICOLON } <sil=0.470> ;SEMICOLON / ∗
∗ writes and then reads 10 arbitrary records
∗ from the file " junk " <sil=0.957> .PERIOD ∗ /
int main ( void )
{
int i <sil=0.436> ,COMMA j <sil=0.462> ;SEMICOLON FILE ∗ f <sil=0.521> ;SEMICOLON struct rec r <sil=0.605> ;SEMICOLON / ∗ create the file 10 records ∗ /
f = fopen ( " junk " <sil=0.498> ,COMMA "w " ) <sil=0.372> ;SEMICOLON if ( <sil=0.946> !EXCLAMATIONMARK f )
{
return 1 <sil=0.563> ;SEMICOLON }
for ( i = 1 <sil=0.462> ;SEMICOLON i <= 1 0 <sil=0.635> ;SEMICOLON i ++)
{
r <sil=0.996> .PERIOD x = i <sil=0.374> ;SEMICOLON fwrite (& r <sil=0.482> ,COMMA sizeof ( structrec ) <sil=0.431> ,COMMA 1 <sil=0.424> ,COMMA f ) <sil=0.901> ;SEMICOLON }
fclose  ( f ) <sil=0.344> ;SEMICOLON / ∗ read the 10 records ∗ /
f = fopen ( " junk " <sil=0.463> ,COMMA " r " ) <sil=0.527> ;SEMICOLON if ( <sil=0.983> !EXCLAMATIONMARK f )
{
return 1 <sil=0.373> ;SEMICOLON }
for ( i = 1 <sil=0.324> ;SEMICOLON i <= 1 0 <sil=0.367> ;SEMICOLON i ++)
{
fread (& r <sil=0.509> ,COMMA sizeof ( structrec ) <sil=0.542> ,COMMA 1 <sil=0.432> ,COMMA f ) <sil=0.863> ;SEMICOLON printf ("%d \ n " <sil=0.559> ,COMMA r <sil=0.941> .PERIOD x ) <sil=0.312> ;SEMICOLON }
fclose ( f ) <sil=0.603> ;SEMICOLON printf ( " \ n " ) <sil=0.373> ;SEMICOLON / ∗ use fseek to read the 10 records
inreverse order ∗ /
f = fopen ( " junk " <sil=0.300> ,COMMA " r " ) <sil=0.440> ;SEMICOLON if ( <sil=0.938> !EXCLAMATIONMARK f )
{
return 1 <sil=0.327> ;SEMICOLON }
for ( i = 9 <sil=0.549> ;SEMICOLON i >= 0 <sil=0.551> ;SEMICOLON i −−)
{
fseek ( f <sil=0.409> ,COMMA sizeof (  structrec )∗ i <sil=0.535> ,COMMA SEEK_SET ) <sil=0.520> ;SEMICOLON fread (& r <sil=0.510> ,COMMA sizeof (  structrec ) <sil=0.515> ,COMMA 1 <sil=0.534> ,COMMA f ) <sil=0.870> ;SEMICOLON printf ("%d \ n " <sil=0.481> ,COMMA r <sil=0.929> .PERIOD x ) <sil=0.450> ;SEMICOLON }
fclose ( f ) <sil=0.548> ;SEMICOLON printf ( " \ n " ) <sil=0.414> ;SEMICOLON / ∗ use fseek to read every other record ∗ /
f = fopen ( " junk " <sil=0.366> ,COMMA " r " ) <sil=0.606> ;SEMICOLON if ( <sil=0.983> !EXCLAMATIONMARK f )
{
return 1 <sil=0.303> ;SEMICOLON }
fseek ( f <sil=0.456> ,COMMA 0 <sil=0.319> ,COMMA SEEK_SET ) <sil=0.479> ;SEMICOLON for ( i = 0 <sil=0.398> ;SEMICOLON i < 5 <sil=0.374> ;SEMICOLON i ++)
{
fread (& r <sil=0.605> ,COMMA sizeof ( structrec ) <sil=0.568> ,COMMA 1 <sil=0.362> ,COMMA f ) <sil=0.936> ;SEMICOLON printf ("% d \ n " <sil=0.432> ,COMMA r <sil=0.995> .PERIOD x ) <sil=0.601> ;SEMICOLON fseek ( f <sil=0.557> ,COMMA sizeof ( structrec ) <sil=0.559> ,COMMA SEEK_CUR ) <sil=0.592> ;SEMICOLON }
fclose ( f ) <sil=0.393> ;SEMICOLON printf ( " \ n " ) <sil=0.520> ;SEMICOLON / ∗ use fseek to read 4 t h record <sil=0.551> ,COMMA change it <sil=0.608> ,COMMA and write it back ∗ /
f = fopen ( " junk " <sil=0.487> ,COMMA " r + " ) <sil=0.634> ;SEMICOLON if ( <sil=0.958> !EXCLAMATIONMARK f )
{
return 1 <sil=0.448> ;SEMICOLON }
fseek ( f <sil=0.445> ,COMMA sizeof ( structrec ) ∗ 3 <sil=0.310> ,COMMA SEEK_SET ) <sil=0.569> ;SEMICOLON fread (& r <sil=0.495> ,COMMA sizeof ( structrec ) <sil=0.472> ,COMMA 1 <sil=0.570> ,COMMA f ) <sil=0.951> ;SEMICOLON r <sil=0.920> .PERIOD x = 1 0 0 <sil=0.374> ;SEMICOLON fseek ( f <sil=0.397> ,COMMA sizeof ( structrec ) ∗ 3 <sil=0.540> ,COMMA SEEK_SET ) <sil=0.498> ;SEMICOLON fwrite (& r <sil=0.624> ,COMMA sizeof ( structrec ) <sil=0.489> ,COMMA 1 <sil=0.326> ,COMMA f ) <sil=0.913> ;SEMICOLON fclose ( f ) <sil=0.599> ;SEMICOLON printf ( " \ n " ) <sil=0.548> ;SEMICOLON / ∗ read the 10 records to insure
4 the record was changed ∗ /
f = fopen ( " junk " <sil=0.440> ,COMMA " r " ) <sil=0.464> ;SEMICOLON if ( <sil=0.906> !EXCLAMATIONMARK f )
{
return 1 <sil=0.648> ;SEMICOLON }
for ( i = 1 <sil=0.558> ;SEMICOLON i <= 1 0 <sil=0.453> ;SEMICOLON i ++)
{
fread (& r <sil=0.629> ,COMMA sizeof ( structrec ) <sil=0.322> ,COMMA 1 <sil=0.403> ,COMMA f ) <sil=0.917> ;SEMICOLON printf ("% d \ n " <sil=0.583> ,COMMA r <sil=0.988> .PERIOD x ) <sil=0.337> ;SEMICOLON }
fclose ( f ) <sil=0.398> ;SEMICOLON return 0 <sil=0.346> ;SEMICOLON }
In this program <sil=0.517> ,COMMA a structure description rec has been used <sil=0.448> ,COMMA but you can use any structure description you want <sil=0.905> .PERIOD You can see that fopen and fclose work exactly as they did for text files <sil=0.938> .PERIOD The new functions here are fread <sil=0.521> ,COMMA fwrite and fseek <sil=0.920> .PERIOD The fread function takes four parameters:
• A memory address
• The number of bytes to read per block
• The number of blocks to read
• The file variable
Thus <sil=0.516> ,COMMA the line fread(&r <sil=0.336> ,COMMA sizeof(struct rec) <sil=0.644> ,COMMA 1 <sil=0.322> ,COMMA f) <sil=0.633> ;SEMICOLON says to read 12 bytes (the size of rec) from the file f (from the current location of the file pointer) into memory address &r <sil=0.944> .PERIOD One block of 12 bytes is requested <sil=0.953> .PERIOD It would be just as easy to read 100 blocks from disk into an array in memory by changing 1 to 100 <sil=0.950> .PERIOD The fwrite function works the same way <sil=0.468> ,COMMA but moves the block of bytes from memory to the file <sil=0.948> .PERIOD The fseek function moves the file pointer to a byte in the file <sil=0.934> .PERIOD Generally <sil=0.333> ,COMMA you move the pointer in sizeof(struct rec) increments to keep the pointer
at record boundaries <sil=0.979> .PERIOD You can use three options when seeking:
• SEEK_SET
• SEEK_CUR
• SEEK_END
SEEK_SET moves the pointer x bytes down from the beginning of the file (from byte 0 in the file) <sil=0.959> .PERIOD SEEK_CUR moves the pointer x bytes down from the current pointer position <sil=0.954> .PERIOD SEEK_END moves the pointer from the end of the file (so you must use negative offsets with this option) <sil=0.951> .PERIOD Several different options appear in the code above <sil=0.957> .PERIOD In particular <sil=0.580> ,COMMA note the section where the file is opened with r+ mode <sil=0.998> .PERIOD This opens the file for reading and writing <sil=0.466> ,COMMA which allows records to be changed <sil=0.918> .PERIOD The code seeks to a record <sil=0.566> ,COMMA reads it <sil=0.405> ,COMMA and changes a field <sil=0.530> ;SEMICOLON it then seeks back because the read displaced the pointer <sil=0.320> ,COMMA and writes the change back <sil=0.993> .PERIOD Further reading
For more information on C and related topics <sil=0.464> ,COMMA check out the links below <sil=0.910> .PERIOD 1 <sil=0.950> .PERIOD Cprogramming <sil=0.937> .PERIOD com: Programming Tutorials
2 <sil=0.912> .PERIOD C Program Development Cycle
3 <sil=0.997> .PERIOD Introduction to Object-Oriented Programming Using C++
4 <sil=0.979> .PERIOD C Programming
5 <sil=0.962> .PERIOD comp <sil=0.912> .PERIOD lang <sil=1.000> .PERIOD c Frequently Asked Questions
Index
address operator <sil=0.498> ,COMMA 10
compiled language <sil=0.303> ,COMMA 2
Fahrenheit to Celsius conversion <sil=0.513> ,COMMA 18
if statement <sil=0.315> ,COMMA 13
library <sil=0.315> ,COMMA 4
printf <sil=0.454> ,COMMA 7
programming language <sil=0.325> ,COMMA 2
qcompiler <sil=0.644> ,COMMA 2
type <sil=0.550> ,COMMA 5
variables <sil=0.517> ,COMMA 5

Phil's C Course
Aims of this Course
This course is intended to help a good programmer (pause for mass exodus) <sil=0.649> ,COMMA particularly someone familiar with DEC Fortran <sil=0.597> ,COMMA start programming in C <sil=0.948> .PERIOD There are a number of program examples <sil=0.318> ,COMMA copies of which you can download as phils_c_examples <sil=0.916> .PERIOD zip <sil=0.971> .PERIOD A detached PGP signature file (which it is not necessary to download unless you know what it's for) is provided so you can be sure the archive has not been altered <sil=0.961> .PERIOD When you unzip the archive on a Windows machine <sil=0.577> ,COMMA note the workspace file phils_c_examples <sil=0.927> .PERIOD dsw <sil=0.947> .PERIOD You should open this with Microsoft Visual Studio 98 and Microsoft Visual C++ 6 <sil=0.907> .PERIOD 0 <sil=0.460> ,COMMA then "batch build" everything <sil=0.938> .PERIOD VMS users should use unzip -a phils_c_examples <sil=0.914> .PERIOD zip to get the correct file attributes for the text files <sil=0.353> ,COMMA like the <sil=0.908> .PERIOD c source files and MAKE <sil=0.923> .PERIOD COM <sil=0.539> ,COMMA the VMS command file which you can use to build the programs <sil=0.991> .PERIOD There are also several programming challenges <sil=0.977> .PERIOD Have a go at these <sil=0.509> ,COMMA nicking as much code as you can from the examples <sil=0.942> !EXCLAMATIONMARK Using C is the best way to learn it <sil=0.415> ,COMMA and making mistakes is definitely the best way to find out how it really works <sil=0.983> .PERIOD I mention the ANSI C standard <sil=0.514> ,COMMA ANSI/ISO 9899-1990 <sil=0.446> ,COMMA a lot in this document <sil=0.997> .PERIOD Always try to adhere to the standard <sil=0.507> ;SEMICOLON experience has shown that it pays off in the long term <sil=0.914> .PERIOD Some of the points I make are stylistic <sil=0.969> .PERIOD However <sil=0.354> ,COMMA many of these suggestions are made for one of two reasons <sil=0.579> ;SEMICOLON either the majority of the C programming world has reached consensus that the style is good (which will make it easier for you to read and learn from other peoples' code) or I have found that you can avoid errors by doing things in a particular way <sil=1.000> .PERIOD I reckon that you can "learn" C in about an hour <sil=0.552> ,COMMA then spend the next year wishing you hadn't done things in a particular way the hour after that <sil=0.907> .PERIOD This course should help you avoid some of the pitfalls that are so easy to fall into (and <sil=0.340> ,COMMA in fact <sil=0.420> ,COMMA dig for yourself) because of the total control <sil=0.591> ,COMMA power <sil=0.418> ,COMMA and 0 to 60 ACCVIOS in under 10 seconds that C can deliver to the programmer <sil=0.906> .PERIOD Why is the language called C <sil=0.937> ?QUESTIONMARK C was developed under Unix on the PDP-11 in 1972 by Dennis Ritchie <sil=0.633> ,COMMA building on the language B <sil=0.616> ,COMMA written by Ken Thompson in 1970 on a PDP-7 <sil=0.608> ,COMMA also running Unix <sil=0.984> .PERIOD B was in turn <sil=0.437> ,COMMA based on BCPL which was developed in 1967 by Martin Richards (and which is still available for the BBC Micro) <sil=0.911> .PERIOD BCPL and B were typeless languages - variables were all multiples of byte or word sized bits of memory <sil=0.922> .PERIOD C is more strongly typed than B <sil=0.406> ,COMMA BCPL or Fortran <sil=0.933> .PERIOD Its basic types are char <sil=0.648> ,COMMA int <sil=0.382> ,COMMA float and double <sil=0.448> ,COMMA which are characters <sil=0.645> ,COMMA integers and single and double precision floating point numbers <sil=0.927> .PERIOD An important addition <sil=0.348> ,COMMA compared to Fortran <sil=0.481> ,COMMA is the pointer type <sil=0.611> ,COMMA which points to the other types (including other pointers) <sil=0.936> .PERIOD All these types can be combined in structures or unions to provide composite types <sil=0.984> .PERIOD The main shock to Fortran programmers is the fact that C has no built-in string type <sil=0.557> ,COMMA and consequently you have to make a function call to compare two strings <sil=0.600> ,COMMA or assign one string to another <sil=0.923> .PERIOD Luckily <sil=0.618> ,COMMA the ANSI standard describes a set of string manipulation routines that MUST be present if an implementation is described as ANSI C <sil=0.970> .PERIOD Similarly <sil=0.371> ,COMMA a good set of standard IO <sil=0.482> ,COMMA time manipulation and even sorting routines exist <sil=0.929> .PERIOD HELP CC RUN-TIME_FUNCTIONS will give you information on all of these <sil=0.457> ,COMMA and even tell you which header files you should include to use them <sil=0.957> .PERIOD For example HELP CC RUN PRINTF will inform you that you need the header file stdio <sil=0.998> .PERIOD h <sil=0.903> .PERIOD In the early days of C <sil=0.321> ,COMMA different compiler vendors all had their own flavours of C <sil=0.448> ,COMMA usually based on the book <sil=0.430> ,COMMA The C Programming Language <sil=0.372> ,COMMA by Brian Kernighan and Dennis Ritchie <sil=0.917> .PERIOD These older compilers are often referred to as "Classic C" or "K&R C" <sil=0.976> .PERIOD As C gained in popularity <sil=0.461> ,COMMA the need to standardize certain features became apparent <sil=0.376> ,COMMA and in 1983 the American National Standards Institute established the X3J11 technical committee <sil=0.401> ,COMMA which published the ANSI C standard in 1988 <sil=0.919> .PERIOD If you only buy one book on C <sil=0.595> ,COMMA get the second edition of the K&R book <sil=0.934> .PERIOD If you want to buy two books add Expert C Programming: Deep C Secrets by Peter van der Linden <sil=0.945> .PERIOD If you really want to be a language lawyer and contribute to threads like "Is i = i++ + --i legal <sil=0.981> ?QUESTIONMARK " in the comp <sil=1.000> .PERIOD lang <sil=0.943> .PERIOD c newsgroup <sil=0.524> ,COMMA then get "The Annotated ANSI C Standard" <sil=0.587> ,COMMA annotated by Herbert Schildt <sil=0.937> .PERIOD Personally I think a line of code like i = i++ + --i should be taken out and shot <sil=0.902> .PERIOD The DEC C compiler is a good ANSI compiler <sil=0.600> ,COMMA and any code you write should pass through this compiler (with its default qualifiers) without so much as an informational murmer <sil=0.967> .PERIOD If it doesn't you are storing up big trouble and intermittent bugs for the future <sil=0.984> .PERIOD Even if you decide to do nonstandard things <sil=0.360> ,COMMA there are techniques to do them in a standard way ( <sil=0.862> !EXCLAMATIONMARK ) <sil=0.617> ,COMMA which will be explained later <sil=0.986> .PERIOD OK <sil=0.322> ,COMMA enough waffle <sil=0.906> .PERIOD Let's look at a "Hello World" program in C <sil=0.922> .PERIOD /*---- Hello World C Example ("hello <sil=0.919> .PERIOD c") -------------------------------------*/

/* ANSI C Headers */
#include <stdio <sil=0.980> .PERIOD h>
#include <stdlib <sil=0.972> .PERIOD h>

/* Main Program starts here */
int main( int argc <sil=0.327> ,COMMA char *argv[] )
{
    int i <sil=0.437> ;SEMICOLON /*  End of declarations <sil=0.993> .PERIOD  <sil=0.609> .PERIOD  <sil=0.584> .PERIOD */

    for ( i = 0 <sil=0.504> ;SEMICOLON i < 10 <sil=0.559> ;SEMICOLON i++ ) {
      printf("%d Hello World <sil=0.989> !EXCLAMATIONMARK \n" <sil=0.507> ,COMMA i) <sil=0.422> ;SEMICOLON }

    exit(EXIT_SUCCESS) <sil=0.424> ;SEMICOLON }

As you have probably gathered <sil=0.635> ,COMMA comments in C are delimited by /* and */ <sil=0.647> ,COMMA and comments must NOT be nested <sil=0.475> ,COMMA or you will get some very interesting bugs <sil=0.903> .PERIOD The perceived need for nested comments is usually for commenting out (say) a debug piece of code <sil=0.622> ,COMMA and this can be done in a better way <sil=0.493> ,COMMA which will be explained later <sil=0.928> .PERIOD Some C compilers let you use the trailing C++ style comments // <sil=0.576> ,COMMA which are a like a trailing <sil=0.851> !EXCLAMATIONMARK in DEC Fortran <sil=0.970> .PERIOD NEVER USE THESE IN C PROGRAMS <sil=0.975> .PERIOD It is not ANSI standard <sil=0.616> ,COMMA and immediately confuses people as to whether they are looking a C or C++ code (and some meanings can subtly change) <sil=0.951> .PERIOD To compile this program under DEC C (both Alpha's and VAX should be using DEC C now <sil=0.931> .PERIOD VAX C was retired around 1993 <sil=0.352> ,COMMA and you really should switch to DEC C for both platforms now)

$ CC HELLO
$ LINK HELLO
Alternatively <sil=0.337> ,COMMA you can use the MAKE <sil=0.951> .PERIOD COM DCL command file <sil=0.635> ,COMMA as shown below <sil=0.952> .PERIOD On Alphas the resulting executable will have file type <sil=0.998> .PERIOD EXE_ALPHA <sil=0.409> ,COMMA and on VAX machines it will be <sil=0.918> .PERIOD EXE <sil=0.901> .PERIOD $ @MAKE HELLO
  DEV$DISK:[PHIL <sil=0.947> .PERIOD PHILS_C_EXAMPLES]
CC/PREFIX=ALL HELLO <sil=0.990> .PERIOD C  -> HELLO <sil=0.958> .PERIOD OBJ_ALPHA
LINK HELLO  -> HELLO <sil=0.909> .PERIOD EXE_ALPHA
Exiting
If you must use VAX C (and you mustn't :-) the link step will whinge about unresolved symbols <sil=0.495> ,COMMA so change the line to

$ LINK HELLO <sil=0.606> ,COMMA VAXCRTL/OPT
where the VAXCRTL <sil=0.984> .PERIOD OPT options file contains the line

SYS$SHARE:VAXCRTL/SHARE
You are now ready to RUN HELLO <sil=0.952> .PERIOD Not too many surprises there <sil=0.932> .PERIOD Note the form of the code <sil=0.954> .PERIOD The main entry point in a standard C is always called main <sil=0.353> ,COMMA though you can override this on VMS platforms <sil=0.343> ,COMMA as we will discover <sil=0.945> .PERIOD The main program in C is declared as int main(some funny stuff) <sil=0.986> .PERIOD This is because the main program should always return a value (usually to DCL or the Unix shell) indicating how things went <sil=0.933> .PERIOD This is done by the call to exit(EXIT_SUCCESS) <sil=0.948> .PERIOD There are two ANSI standard return codes <sil=0.308> ,COMMA EXIT_SUCCESS and EXIT_FAILURE <sil=0.455> ,COMMA both defined in <stdlib <sil=0.958> .PERIOD h> <sil=0.910> .PERIOD Always use these values <sil=0.624> ,COMMA and don't do what a lot of Unix programmers do which is exit(0) or some other magic number just because "everybody knows that exit(0) means success" <sil=0.963> .PERIOD You can return VMS condition codes <sil=0.499> ,COMMA e <sil=0.986> .PERIOD g <sil=0.982> .PERIOD exit(SS$_NORMAL) <sil=0.345> ,COMMA but this should be avoided unless really necessary <sil=0.378> ,COMMA and even then there are ways to fall back to the standard return codes if your code is compiled on a non-VMS machine <sil=0.969> .PERIOD The (some funny stuff) is the argument list <sil=0.306> ,COMMA or the "formal parameters" of function main <sil=0.970> .PERIOD Imagine main as a function called from your command shell (DCL on VMS <sil=0.475> ,COMMA or the DOS window on Windows NT) <sil=0.943> .PERIOD The declaration int main( int argc <sil=0.460> ,COMMA char *argv[] ) means that main is a function returning an integer <sil=0.549> ,COMMA which takes two arguments <sil=0.949> .PERIOD The first is an integer <sil=0.563> ,COMMA and is the number of arguments passed to main by DCL <sil=0.540> ,COMMA and the second is a pointer to arrays of characters <sil=0.939> .PERIOD The latter are <sil=0.534> ,COMMA in fact <sil=0.331> ,COMMA any command line arguments <sil=0.357> ,COMMA as will be demonstrated in args <sil=0.937> .PERIOD c <sil=0.906> ,COMMA a demo programming coming soon to a disk near you <sil=0.937> .PERIOD The body of a function is delimited by { and } <sil=0.920> .PERIOD Because C is largely a free format language <sil=0.501> ,COMMA the whole function can be on one line if you really want <sil=0.560> ,COMMA but that tends to be unreadable and confusing <sil=0.900> .PERIOD I like to start the function with a { in column one <sil=0.345> ,COMMA just after the function declaration (which I can then nick for prototyping) <sil=0.363> ,COMMA and end the function with a } in the same column <sil=0.949> .PERIOD Notice how each statement ends with a semicolon <sil=0.992> .PERIOD The " <sil=0.485> ;SEMICOLON " is known as a statement terminator <sil=0.985> .PERIOD It is also a "sequence point" <sil=0.623> ,COMMA as are the comma operator <sil=0.515> ,COMMA and various other logical comparison operators <sil=0.304> ,COMMA and the standard guarantees that side effects of expressions will be over once a sequence point is reached <sil=0.952> .PERIOD This basically means that all the things you made happen in one statement will have happened by the time you start on the next statement or expression <sil=0.966> .PERIOD The printf( <sil=0.959> .PERIOD  <sil=0.559> .PERIOD  <sil=0.362> .PERIOD ) statement is a call to a routine defined in <stdio <sil=0.961> .PERIOD h> <sil=0.962> ,COMMA and enables formatted output to the stdout stream <sil=0.939> .PERIOD In C <sil=0.638> ,COMMA three default output streams are defined <sil=0.956> .PERIOD These are stdin <sil=0.646> ,COMMA stdout and stderr <sil=0.428> ,COMMA and they correspond to SYS$INPUT <sil=0.588> ,COMMA SYS$OUTPUT and SYS$ERROR under VMS <sil=0.931> .PERIOD The first argument is a format string containing conversions characters <sil=0.532> ,COMMA each preceded by the % sign (use %% if you actually want a % sign) <sil=0.403> ,COMMA which tell the routine how to interpret the variable number of arguments to be printed <sil=0.949> .PERIOD In this case the integer i is to be printed in decimal <sil=0.575> ,COMMA so "%d" is used <sil=0.996> .PERIOD There are corresponding functions <sil=0.314> ,COMMA sprintf to write directly into a character string array <sil=0.402> ,COMMA and fprintf to write to a file <sil=0.956> .PERIOD Similar formatted input routines <sil=0.462> ,COMMA sscanf and fscanf are also available <sil=0.972> .PERIOD The table below <sil=0.332> ,COMMA nicked off the network <sil=0.396> ,COMMA summarizes the conversion characters:


                    Clive Feather's Excellent Table:
 
     Types of arguments for the various fprintf and fscanf conversions
      
         Conversion        fprintf          fscanf
         ----------------------------------------------------
         d  i              int              int *
         o  u  x  X        unsigned int     unsigned int *
         hd hi             int              short *
         ho hu hx hX       [see note 1]     unsigned short *
         ld li             long             long *
         lo lu lx lX       unsigned long    unsigned long *
         e  E  f  g  G     double           float *
         le lE lf lg lG    [invalid]        double *
         Le LE Lf Lg LG    long double      long double *
         c                 int              [see note 2]
         s                 [see note 2]     [see note 2]
         p                 void *           void **
         n                 int *            int *
         hn                short *          short *
         ln                long *           long *
         [                 [invalid]        [see note 2]
 
     Note 1: the type that (unsigned short) is promoted to by the integral
             promotions <sil=0.980> .PERIOD This is (int) if USHORT_MAX <= INT_MAX <sil=0.441> ,COMMA and
             (unsigned int) otherwise <sil=0.988> .PERIOD Note 2: any of (char *) <sil=0.596> ,COMMA (signed char *) <sil=0.384> ,COMMA or (unsigned char *) <sil=0.956> .PERIOD Don't worry about the "*"s for now <sil=0.930> .PERIOD They can be read as "pointer to thing named before them" <sil=0.520> ,COMMA so int * means pointer to int <sil=0.967> .PERIOD Similar summaries can be found in K &R II pages 154 and 158 <sil=0.910> .PERIOD Programming Challenge 1
      _______________________
      
        Have a  go at adapting "hello <sil=0.975> .PERIOD c"  to print out the value of i in
      hexadecimal <sil=0.977> .PERIOD Fiddle about with the format string -  remove the "\n"
      for example <sil=0.564> ,COMMA and see what happens to your output <sil=0.961> .PERIOD Unlike Fortran <sil=0.384> ,COMMA whitespace is significant in C <sil=0.402> ,COMMA and there are reserved keywords <sil=0.937> .PERIOD These reserved keywords should not appear as any type of identifier <sil=0.444> ,COMMA even a structure member (YRL people - don't forget LID files) <sil=0.949> .PERIOD The list below shows both C and C++ reserved keywords <sil=0.925> .PERIOD asm1         continue    float       new1         signed      try1 
    auto        default     for         operator1    sizeof      typedef
    break       delete1      friend1      private1     static      union
    case        do          goto        protected1   struct      unsigned
    catch1       double      if          public1      switch      virtual1 
    char        else        inline1      register    template1    void
    class1       enum        int         return      this1        volatile
    const       extern      long        short       throw1       while

The items marked like this1 are C++ <sil=0.624> ,COMMA not C keywords <sil=0.341> ,COMMA but it makes sense to avoid both <sil=0.932> .PERIOD Avoid using a language name like Fortran too <sil=0.959> .PERIOD Variables <sil=0.330> ,COMMA Types and Functions
Variables are like little boxes with numbers on them <sil=0.472> ,COMMA a bit like houses <sil=0.439> ,COMMA and inside the boxes <sil=0.916> .PERIOD  <sil=0.417> .PERIOD  <sil=0.333> .PERIOD naaahh <sil=0.937> !EXCLAMATIONMARK Just kidding <sil=0.985> .PERIOD You all know what variables are <sil=0.438> ,COMMA and I think we all understand that x = x + 1 isn't a contradictory algebraic statement <sil=0.963> .PERIOD C <sil=0.333> ,COMMA unlike Fortran <sil=0.571> ,COMMA has case sensitive variable and other identifier names <sil=0.932> .PERIOD Therefore the variable NextPage is completely different to nextpage <sil=0.997> .PERIOD The same is true for functions <sil=0.974> .PERIOD Some people like to use the capitalized-first-letter form of naming <sil=0.543> ,COMMA others prefer underbars <sil=0.405> ,COMMA e <sil=0.999> .PERIOD g <sil=0.943> .PERIOD GetNextPage() or get_next_page() <sil=0.901> .PERIOD Many professional library packages tend towards TheCapitalizedFormat <sil=0.955> .PERIOD Some people like Microsoft's Hungarian Notation which involves prefixing variable names with their type <sil=0.478> ,COMMA e <sil=0.989> .PERIOD g <sil=0.956> .PERIOD uiCount for an unsigned int counter variable <sil=0.998> .PERIOD It all depends how good you are with the Shift key :-) Whatever method you choose <sil=0.566> ,COMMA try and be clear and consistent <sil=0.958> .PERIOD In C <sil=0.584> ,COMMA local variable definitions can be at the start of any {block} <sil=0.312> ,COMMA and aren't restricted to the top of the module as in Fortran <sil=0.984> .PERIOD Be careful if you take advantage of this feature <sil=0.342> ,COMMA because you may run into scoping problems where the innermost variable definition hides an outer one <sil=0.945> .PERIOD If you are used to C++ <sil=0.621> ,COMMA remember that the variable definitions can only be at the start of the {block} before the first statement (e <sil=0.930> .PERIOD g <sil=0.959> .PERIOD expression <sil=0.328> ,COMMA function call or flow control statement) <sil=0.943> .PERIOD If you try and intersperse definitions <sil=0.350> ,COMMA C++ style <sil=0.485> ,COMMA the C compiler will issue some sort of "bad statement" warning <sil=0.989> .PERIOD Variables declared at the beginning of the {function body} are local to the function <sil=0.302> ,COMMA variables declared at the "top" of the file (or compilation unit to be pedantic) <sil=0.565> ,COMMA in the header files <sil=0.341> ,COMMA or outside any function bodies <sil=0.423> ,COMMA are global to the compilation unit (and are externally visible symbols <sil=0.485> ,COMMA unless declared as static) <sil=0.970> .PERIOD More will be said about this later <sil=0.910> .PERIOD For now <sil=0.361> ,COMMA suffice it to say that you should avoid using global variables wherever possible <sil=0.902> .PERIOD A brief example will illustrate the scope of variables:


/*---- Variable Scope Example ( "scope <sil=0.947> .PERIOD c" ) ----------------------------------*/
/* ANSI C Headers */
#include <stdio <sil=0.927> .PERIOD h>
#include <stdlib <sil=0.964> .PERIOD h>

/* Global variables <sil=0.537> ,COMMA visible externally too (i <sil=0.912> .PERIOD e <sil=0.601> .PERIOD to things linked  */
/* against this) Generally they should be avoided as far as */
/* possible <sil=0.324> ,COMMA because it can be very difficult to discover which */
/* routine changes their value <sil=0.574> ,COMMA and they introduce "hidden" dependencies */
int some_counter <sil=0.577> ;SEMICOLON double double_result <sil=0.326> ;SEMICOLON /* Function prototypes */
void set_double_result(void) <sil=0.343> ;SEMICOLON /* Main Program starts here */
int main( int argc <sil=0.453> ,COMMA char *argv[] )
{
    int j <sil=0.459> ;SEMICOLON int i_am_local <sil=0.501> ;SEMICOLON /* <sil=0.950> .PERIOD  <sil=0.371> .PERIOD to main */
/*  End of declarations <sil=0.956> .PERIOD  <sil=0.409> .PERIOD  <sil=0.590> .PERIOD */

    i_am_local = 1 <sil=0.329> ;SEMICOLON printf("i_am_local = %d (in main)\n\n" <sil=0.490> ,COMMA i_am_local ) <sil=0.441> ;SEMICOLON for ( j = 0 <sil=0.610> ;SEMICOLON j < 10 <sil=0.538> ;SEMICOLON j++ ) {
      int i_am_local <sil=0.325> ;SEMICOLON /* <sil=0.916> .PERIOD  <sil=0.562> .PERIOD to this loop - Not necessarily a good idea */
                      /* because it can cause confusion as to which */
                      /* variable we actually want to access */
      i_am_local = j <sil=0.498> ;SEMICOLON printf("i_am_local = %d (inside loop)\n" <sil=0.364> ,COMMA i_am_local ) <sil=0.627> ;SEMICOLON }

    printf("\ni_am_local = %d (in main)\n\n" <sil=0.396> ,COMMA i_am_local ) <sil=0.447> ;SEMICOLON /* Now let's look at the default initialization values of the globals */
    printf("nsome_counter = %d (in main)\n" <sil=0.309> ,COMMA some_counter) <sil=0.388> ;SEMICOLON printf("double_result = %f (in main)\n\n" <sil=0.586> ,COMMA double_result) <sil=0.563> ;SEMICOLON /* Call a function that changes the global variables <sil=0.960> .PERIOD  <sil=0.368> .PERIOD */
    set_double_result() <sil=0.515> ;SEMICOLON /* <sil=0.961> .PERIOD  <sil=0.365> .PERIOD and look at them again */
    printf("some_counter = %d (in main)\n" <sil=0.408> ,COMMA some_counter) <sil=0.484> ;SEMICOLON printf("double_result = %f (in main)\n" <sil=0.312> ,COMMA double_result) <sil=0.559> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.459> ;SEMICOLON }

void set_double_result(void)
{
    ++some_counter <sil=0.548> ;SEMICOLON double_result = 3 <sil=0.924> .PERIOD 141 <sil=0.455> ;SEMICOLON printf("some_counter = %d (in set_double_result)\n" <sil=0.602> ,COMMA some_counter) <sil=0.555> ;SEMICOLON printf("double_result = %f (in set_double_result)\n\n" <sil=0.552> ,COMMA double_result) <sil=0.629> ;SEMICOLON }

The basic types in C are:


     char - this defines a byte <sil=0.544> ,COMMA which must be able to hold one character
            in the local character set (normally <sil=0.572> ,COMMA but not necessarily 8 bits) <sil=0.605> ;SEMICOLON int - holds an integer <sil=0.495> ,COMMA usually in the machine's natural size <sil=0.920> .PERIOD They are 32 bits on both VAX and Alpha <sil=0.931> .PERIOD float - holds a single precision floating point number <sil=0.984> .PERIOD They are 32 bits on both VAX and Alpha <sil=0.965> .PERIOD double - Double precision floating point number <sil=0.398> ,COMMA 64 bits on the VAX
            and Alpha <sil=0.979> .PERIOD These bit sizes are just to give you an idea <sil=0.971> .PERIOD They should not be relied on <sil=0.454> ,COMMA and you should code independently of them <sil=0.481> ,COMMA unless you are addressing hardware registers or some equally hardware-specific task <sil=0.999> .PERIOD Some of these basic types can be modified with various qualifiers:


     char - can be signed or unsigned <sil=0.376> ;SEMICOLON int - can be long or short <sil=0.526> ,COMMA signed or unsigned <sil=0.305> ;SEMICOLON double - can be long <sil=0.492> ,COMMA for (possibly) even more precision <sil=0.380> ;SEMICOLON The long modifier normally gives larger integers <sil=0.484> ,COMMA but the compiler vendor is free to ignore it provided that


             short <= int <= long
             16 bits <= short/int 
             32 bits <= long

Assignment to variables of these basic types is fairly intuitive <sil=0.514> ,COMMA and can be done in the definition <sil=0.592> ,COMMA rather like using the DATA statement in Fortran or the DEC Fortran extension


/*  C Example */                  |*     DEC  Fortran Example
                                  |
    int x <sil=0.512> ,COMMA y <sil=0.509> ;SEMICOLON /* Not initialized*/|      INTEGER     X <sil=0.449> ,COMMA Y
    int counter = 0 <sil=0.378> ;SEMICOLON |      INTEGER     COUNTER /0/
    float total = 0 <sil=0.926> .PERIOD 0 <sil=0.545> ;SEMICOLON |      REAL        TOTAL   /0 <sil=0.973> .PERIOD 0/
    char c = 'A' <sil=0.538> ;SEMICOLON |      CHARACTER*1 C       /'A'/

Note that C uses single quote ' for character constants <sil=0.975> .PERIOD The double quotes are used for strings <sil=0.972> .PERIOD There are escape sequences for getting nonprintable characters <sil=0.971> .PERIOD These are listed on page 38 of K&R II <sil=0.967> .PERIOD A few useful ones are '\n' to get a new line (C doesn't automatically add line feeds when you use printf() ) <sil=0.588> ,COMMA '\a' to get a bell (alert) sound <sil=0.506> ,COMMA and '\0' to get the null character (which is NOT THE SAME as the NULL pointer) used to terminate strings (arrays of characters) <sil=0.951> .PERIOD The initialization of non-static (discussed later) int and float variables is necessary before use <sil=0.978> .PERIOD It doesn't have to be done in the definition <sil=0.414> ,COMMA but you can't rely on their value being anything sensible <sil=0.333> ,COMMA so whilst the initialization of COUNTER and TOTAL is redundant in the Fortran example (assuming non-recursive compilation) <sil=0.510> ,COMMA you do need to initialize the variables before use in C <sil=0.972> .PERIOD  <sil=0.973> .PERIOD {
    int i <sil=0.354> ;SEMICOLON int j <sil=0.486> ;SEMICOLON  <sil=0.938> .PERIOD i = 0 <sil=0.648> ;SEMICOLON /* i's value could be anything up to this point */ <sil=0.964> .PERIOD j = i*OFFSET <sil=0.488> ;SEMICOLON /* j's value could be anything up to this point */ <sil=0.978> .PERIOD }

Global variables are guaranteed to be initialized to 0 (or 0 <sil=0.917> .PERIOD 0 if floating type) but you can override this by specifying an initial value <sil=0.915> .PERIOD Similar rules apply to float <sil=0.456> ,COMMA double <sil=0.414> ,COMMA and long double <sil=0.993> .PERIOD There are two standard header files <sil=0.454> ,COMMA <limits <sil=0.939> .PERIOD h> and <float <sil=0.929> .PERIOD h> which tell you the maximum and minimum values that can be stored in a particular type <sil=0.414> ;SEMICOLON for example INT_MAX is 2147483647 <sil=0.369> ,COMMA and FLT_MAX is 1 <sil=0.978> .PERIOD 7014117e+38 on the VAX <sil=0.966> .PERIOD The signed or unsigned modifiers are fairly self explanatory <sil=0.971> .PERIOD The default for int is signed <sil=0.384> ,COMMA so it is rarely specified <sil=0.902> .PERIOD Signed integer arithmetic is usually done in Two's Complement form <sil=0.639> ,COMMA but this need not be the case <sil=0.944> .PERIOD Characters can be signed or unsigned by default - it is implementation defined <sil=0.978> .PERIOD I find it best just to use char with no qualifiers <sil=0.442> ,COMMA and let the compiler do what it will <sil=0.966> .PERIOD This is probably a good point to introduce the sizeof(thing) operator <sil=0.989> .PERIOD It is an operator <sil=0.584> ,COMMA not a function <sil=0.590> ,COMMA and is evaluated at compile time <sil=0.935> .PERIOD It returns the size of the argument <sil=0.611> ,COMMA where the size of char is defined to be 1 <sil=0.977> .PERIOD To be pedantic <sil=0.522> ,COMMA it returns an unsigned integer type <sil=0.453> ,COMMA size_t <sil=0.549> ,COMMA defined in <stddef <sil=0.980> .PERIOD h> <sil=0.924> ,COMMA but is not often used in a way that requires a size_t declaration <sil=0.983> .PERIOD Here are some examples of its use (this is a "programming fragment" not a complete program) <sil=0.988> .PERIOD size_t s <sil=0.304> ;SEMICOLON int fred <sil=0.513> ;SEMICOLON /* Integer */
    char bob <sil=0.315> ;SEMICOLON /* Character */
    char *c_ptr <sil=0.582> ;SEMICOLON /* Pointer to character */
    char bloggs[6] <sil=0.639> ;SEMICOLON /* Array of 6 characters */ <sil=0.967> .PERIOD s = sizeof( fred ) <sil=0.486> ;SEMICOLON s = sizeof( bob ) <sil=0.330> ;SEMICOLON s = sizeof( c_ptr ) <sil=0.595> ;SEMICOLON s = sizeof( long double ) <sil=0.512> ;SEMICOLON /* Allowed to use types instead of variables */ <sil=0.991> .PERIOD /*  Safe string copy <sil=0.576> ,COMMA checks size of destination and allows for terminating */
/*  null character (not to be confused with the NULL pointer discussed later) */
    strncpy( bloggs <sil=0.625> ,COMMA "Bloggs" <sil=0.474> ,COMMA sizeof(bloggs)-1 ) <sil=0.440> ;SEMICOLON  <sil=0.909> .PERIOD You can leave the brackets off after sizeof <sil=0.347> ,COMMA e <sil=0.956> .PERIOD g <sil=0.913> .PERIOD sizeof int is quite legal <sil=0.589> ,COMMA but I think that the bracketed form is clearer <sil=0.928> .PERIOD Programming Challenge 2
      _______________________
      
        Have a  go at adapting "hello <sil=0.965> .PERIOD c"  to print  out  the size  of some
      commonly  used types <sil=0.341> ,COMMA e <sil=0.975> .PERIOD g <sil=0.944> .PERIOD int <sil=0.556> ,COMMA short int <sil=0.405> ,COMMA long  int <sil=0.379> ,COMMA float <sil=0.529> ,COMMA double
      and  so  on <sil=0.948> .PERIOD Try  some arithmetic to familiarize yourself  with the
      basic  operators <sil=0.592> ,COMMA + <sil=0.576> ,COMMA - <sil=0.600> ,COMMA * <sil=0.421> ,COMMA / <sil=0.430> ,COMMA and  one  that  doesn't appear  in
      Fortran <sil=0.615> ,COMMA the modulus operator <sil=0.583> ,COMMA % <sil=0.370> ,COMMA which acts on  integer types  to
      yield the  remainder after division <sil=0.963> .PERIOD Use this  to determine whether
      the year 2000 is a leap year <sil=0.959> .PERIOD The rule is that it is a leap year if
      the year is divisible by 4 <sil=0.523> ,COMMA except if it is a multiple of 100 years <sil=0.329> ,COMMA unless it is also divisible by 400 <sil=0.931> .PERIOD In addition to the integer and floating point types <sil=0.472> ,COMMA there is a type called void <sil=0.929> .PERIOD The meaning of void changes according to context <sil=0.874> !EXCLAMATIONMARK If you declare a function returning void <sil=0.624> ,COMMA you mean that it returns no value <sil=0.303> ,COMMA like a Fortran subroutine <sil=0.955> .PERIOD A void in the argument list means that the function takes no arguments (you can have a void function that does take arguments by declaring arguments in the usual way <sil=0.342> ,COMMA and you can have a function that does return a value but takes no arguments) <sil=0.906> .PERIOD Below is an example of a Fortran subroutine and C function:


/*     C Version */                    |*        Fortran Version
                                       |
void initialize_things( void )         |      SUBROUTINE INITIALIZE_THINGS
{                                      |*
/*  Do cunning setup procedure     */  |*     Do cunning setup procedure  
/*  No need for a return statement */  |*
}                                      |      END <sil=0.998> .PERIOD | <sil=0.974> .PERIOD /*  Call it */                         |*     Call it
    initialize_things() <sil=0.303> ;SEMICOLON /* Note () */ |      CALL INITIALIZE_THINGS <sil=0.930> .PERIOD | <sil=0.914> .PERIOD The void qualifier also has yet another meaning <sil=0.448> ,COMMA which will be discussed when we look at pointers <sil=0.975> .PERIOD The void function above demonstrates the general form of functions in C <sil=0.985> .PERIOD They have a function definition with the formal parameters <sil=0.465> ,COMMA then a {body} enclosed by the {} brackets <sil=0.964> .PERIOD Function arguments are always passed by value in C <sil=0.929> .PERIOD The actual arguments are copied to the (local) function formal arguments <sil=0.610> ,COMMA as if by assignment <sil=0.961> .PERIOD The arguments may be expressions <sil=0.396> ,COMMA or even calls to other functions <sil=0.965> .PERIOD The order of evaluation of arguments is unspecified <sil=0.329> ,COMMA so don't rely on it <sil=0.868> !EXCLAMATIONMARK Here is a C function example <sil=0.335> ,COMMA with a similar Fortran routine for comparison <sil=0.914> .PERIOD /*     C Version */                    |*     Fortran Version
                                       |
int funcy( int i )                     |      INTEGER FUNCTION FUNCY( I )
{                                      |      INTEGER I
                                       |*
    int j <sil=0.396> ;SEMICOLON |      INTEGER J
/*  End of declarations <sil=0.987> .PERIOD  <sil=0.585> .PERIOD  <sil=0.591> .PERIOD */         |*     End of declarations <sil=0.910> .PERIOD  <sil=0.354> .PERIOD  <sil=0.549> .PERIOD j = i <sil=0.408> ;SEMICOLON |      J = I
    i = i + 1 <sil=0.488> ;SEMICOLON /* Only local i changed*/|      I = I + 1 <sil=0.880> !EXCLAMATIONMARK Calling arg changed
    j = i*j <sil=0.505> ;SEMICOLON |      J = I*J
                                       |      FUNCY = J
    return( j ) <sil=0.458> ;SEMICOLON |      RETURN
}                                      |      END <sil=0.927> .PERIOD | <sil=0.921> .PERIOD /*  Call it */                         |*     Call it
    k = 3 <sil=0.540> ;SEMICOLON |      K = 3
    ival = funcy(k) <sil=0.520> ;SEMICOLON /* ival is 12 */  |      IVAL = FUNCY( K ) <sil=0.988> !EXCLAMATIONMARK IVAL is 12 <sil=0.994> .PERIOD /* k is still 3 */| <sil=0.960> .PERIOD  <sil=0.922> !EXCLAMATIONMARK K is 4

Notice that changing the function parameter in the C function does not alter the actual argument <sil=0.600> ,COMMA only the local copy <sil=0.904> .PERIOD To change an actual argument <sil=0.510> ,COMMA you would pass it by address <sil=0.444> ,COMMA using the address operator <sil=0.313> ,COMMA & <sil=0.619> ,COMMA and declare the function argument as a pointer to type int <sil=0.962> .PERIOD More will be said about this in the pointers section <sil=0.984> .PERIOD Generally <sil=0.596> ,COMMA you should avoid writing functions in C that change the actual arguments <sil=0.970> .PERIOD It is better to return a function value instead <sil=0.626> ,COMMA where possible <sil=0.974> .PERIOD /*     C Version */                    |*     Fortran Version
                                       |
    myval = funcy( gibbon ) <sil=0.370> ;SEMICOLON |      CALL FUNCY( GIBBON <sil=0.325> ,COMMA MYVAL )

      Programming Challenge 3
      _______________________
      
        Hack  your copy of the "hello <sil=0.942> .PERIOD c" to call some sort  of  arithmetic
      function <sil=0.474> ,COMMA perhaps to return the square  of the argument <sil=0.997> .PERIOD Write the
      function <sil=0.483> ,COMMA and add a "prototype"  (these are discussed  later) for it
      before the main program <sil=0.591> ,COMMA e <sil=0.904> .PERIOD g <sil=0.991> .PERIOD  <sil=0.970> .PERIOD /*  Function prototype */
      int funcy( int myarg ) <sil=0.626> ;SEMICOLON /* semicolon where function body would be */ <sil=0.927> .PERIOD /* Main Program starts here */
      int main( int argc <sil=0.610> ,COMMA char *argv[] )
      { <sil=0.977> .PERIOD }

      /* The real McCoy - "Dammit Jim <sil=0.426> ,COMMA I'm a function not a prototype" */
      int funcy( int myarg )
      { <sil=0.938> .PERIOD /*  Do something and return() an int value */ <sil=0.981> .PERIOD }


      If  you are  feeling  really  cocky <sil=0.583> ,COMMA write a recursive  factorial()
      function that calls itself <sil=0.990> .PERIOD Hint: <sil=0.918> .PERIOD if ( n > 0) {
            factorial = n * factorial( n-1 ) <sil=0.383> ;SEMICOLON } else {
            factorial = 1 <sil=0.451> ;SEMICOLON } <sil=0.948> .PERIOD Call it from you main program  and step through with the debugger to
      convince yourself that it really is recursive <sil=0.922> .PERIOD When you write your own functions <sil=0.513> ,COMMA try to avoid interpositioning <sil=0.593> ,COMMA i <sil=0.521> .PERIOD e <sil=0.633> .PERIOD naming your function with the same name as a standard library (or system/Motif/X11/Xt library) function <sil=0.992> .PERIOD Use

$ HELP CC RUN-TIME_FUNCTIONS your_function_name
to check for the existence of a similarly named DEC C RTL function <sil=0.966> .PERIOD Or look in a book <sil=0.978> .PERIOD It is a very bad idea to replace a standard function <sil=0.908> .PERIOD If you need to write something with the same purpose as a standard function <sil=0.516> ,COMMA but maybe with better accuracy or speed <sil=0.580> ,COMMA call it something different <sil=0.433> ,COMMA e <sil=0.943> .PERIOD g <sil=0.930> .PERIOD my_fast_qsort() <sil=0.918> .PERIOD Three other modifiers I haven't yet explained are static <sil=0.640> ,COMMA const and extern <sil=0.918> .PERIOD The static modifier is another one that changes meaning depending on its context <sil=0.968> .PERIOD If you declare a global variable or function as static <sil=0.496> ,COMMA it will still be visible throughout the same compilation unit (file to us) <sil=0.451> ,COMMA but will NOT be visible externally to programs linked against our routines <sil=0.971> .PERIOD This is often used as a neat way of storing data that has to be visible to a number of related functions <sil=0.580> ,COMMA but must not be accessible from outside <sil=0.934> .PERIOD Some code fragments below illustrate this <sil=0.963> .PERIOD /*---- C Fragments -----------------------------------------------------------*/
/* Global Vars <sil=0.386> ,COMMA NOT visible externally (i <sil=0.950> .PERIOD e <sil=0.333> .PERIOD to things linked against this)   */
static int number_of_things <sil=0.587> ;SEMICOLON int AddToThings( int a_thing )
{ <sil=0.928> .PERIOD number_of_things = number_of_things + 1 <sil=0.593> ;SEMICOLON return( number_of_things ) <sil=0.603> ;SEMICOLON }

int GetNumberOfThings(void)
{
    return( number_of_things ) <sil=0.567> ;SEMICOLON }

int RemoveThing( int a_thing )
{ <sil=0.963> .PERIOD number_of_things = number_of_things - 1 <sil=0.530> ;SEMICOLON return( number_of_things ) <sil=0.524> ;SEMICOLON }



*      Fortran (sort of) Equivalent
*-----------------------------------------------------------------------
      INTEGER FUNCTION ADD_TO_THINGS( A_THING ) <sil=0.932> .PERIOD INTEGER NUMBER_OF_THINGS
      SAVE    NUMBER_OF_THINGS <sil=0.921> .PERIOD NUMBER_OF_THINGS = NUMBER_OF_THINGS + 1
      ADD_TO_THINGS_ = NUMBER_OF_THINGS
      RETURN
*
      ENTRY FUNCTION GET_NUMBER_OF_THINGS()
      GET_NUMBER_OF_THINGS = NUMBER_OF_THINGS
      RETURN
*
      ENTRY REMOVE_THING( A_THING ) <sil=0.946> .PERIOD NUMBER_OF_THINGS = NUMBER_OF_THINGS - 1
      REMOVE_THING = NUMBER_OF_THINGS
      RETURN
*
      END

Another use of static is with variables that are local to a function <sil=0.961> .PERIOD In this case it is similar to the Fortran SAVE statement <sil=0.463> ,COMMA i <sil=0.342> .PERIOD e <sil=0.458> .PERIOD the variable will retain its value across function calls <sil=0.474> ,COMMA and WILL BE INITIALIZED to 0 if it is an integer type <sil=0.406> ,COMMA or 0 <sil=0.940> .PERIOD 0 if a floating point type (even if the floating point representation of 0 on your machine is not all bits set to 0) <sil=0.553> ,COMMA or NULL (pointer to nothing) if it is a pointer <sil=0.909> .PERIOD /*---- C Example -------------------------------------------------------------*/
int log_error( int code )
{
    static int total_number_of_errors <sil=0.553> ;SEMICOLON /*  End of declarations <sil=0.921> .PERIOD  <sil=0.649> .PERIOD  <sil=0.486> .PERIOD */

/*  ++ is the same as  total_number_of_errors = total_number_of_errors + 1 */
    return( ++total_number_of_errors ) <sil=0.584> ;SEMICOLON }



*     Fortran Equivalent
*-----------------------------------------------------------------------
      SUBROUTINE LOG_ERROR( CODE ) <sil=0.995> .PERIOD INTEGER TOTAL_NUMBER_OF_ERRORS
*     Not required for non-recursive DEC Fortran <sil=0.399> ,COMMA but it documents your intent
      SAVE    TOTAL_NUMBER_OF_ERRORS <sil=0.980> .PERIOD TOTAL_NUMBER_OF_ERRORS = TOTAL_NUMBER_OF_EBRORS + 1
      END

The const modifier is used to flag a read only quantity <sil=0.915> .PERIOD For example <sil=0.399> ,COMMA const double pi = 3 <sil=0.990> .PERIOD 14159265358979 <sil=0.372> ;SEMICOLON  <sil=0.978> .PERIOD /*  Arizona <sil=0.955> ?QUESTIONMARK */
    pi = 3 <sil=1.000> .PERIOD 0 <sil=0.636> ;SEMICOLON /* Gives compiler error - try it in your test program */

The const modifier is useful for function prototype arguments which are passed by pointer <sil=0.566> ,COMMA where you want to indicate that your function will not change the object pointed to <sil=0.979> .PERIOD More will be said about function prototypes later <sil=0.998> .PERIOD Programming Challenge 4
      _______________________
      
        Look   at   the   Fortran   example  above <sil=0.985> .PERIOD Spot  the  deliberate
      mistake <sil=0.936> .PERIOD The compiler would probably flag an error for it <sil=0.469> ,COMMA but think
      of  another instance where  perhaps you wanted to increment an array
      element indexed by a  non-trivial expression <sil=0.934> .PERIOD Using the ++  operator
      in C  helps  avoid  typographical errors <sil=0.508> ,COMMA and looks less clumsy (and
      saves valuable bytes <sil=0.417> ;SEMICOLON -) ) <sil=0.936> .PERIOD There is a similar  operator <sil=0.446> ,COMMA -- <sil=0.319> ,COMMA which
      decrements by one <sil=0.909> .PERIOD Read K&R II <sil=0.587> ,COMMA pages 46-48 <sil=0.416> ,COMMA and pages 105-106 <sil=0.968> .PERIOD Make
      sure  you  understand  the  difference  between prefix  and  postfix
      versions  of ++ and -- <sil=0.446> ,COMMA and  try to rewrite the AddToThings() set of
      functions using these operators <sil=0.908> .PERIOD Great - that's saved  me  having to
      explain it all <sil=0.923> .PERIOD The extern qualifier is rather like EXTERN in Fortran <sil=0.442> ,COMMA and basically gives type information for a reference that is to be resolved by the linker <sil=0.992> .PERIOD You DO NOT need to use extern with function declarations - int funcy( int i ) <sil=0.321> ;SEMICOLON is the same as extern int funcy( int i) <sil=0.329> ;SEMICOLON  <sil=0.961> .PERIOD It is usually used when declaring global variables to indicate that they are referenced in the particular compilation unit <sil=0.338> ,COMMA but not defined in it <sil=0.951> .PERIOD What is the difference between "definition" and "declaration" <sil=0.893> ?QUESTIONMARK In short <sil=0.318> ,COMMA a definition actually ALLOCATES SPACE for the entity <sil=0.453> ,COMMA whereas a declaration tells the compiler what the entity is and what it is called <sil=0.509> ,COMMA but leaves it up to the linker to find space for it <sil=0.881> !EXCLAMATIONMARK A global variable <sil=0.448> ,COMMA structure or function can have many declarations <sil=0.481> ,COMMA but only one definition <sil=0.911> .PERIOD This is explained in more details in the "Header Files" section which follows <sil=0.961> .PERIOD Three less commonly used modifiers are volatile <sil=0.587> ,COMMA auto and register <sil=0.958> .PERIOD The volatile modifier tells the compiler not to perform any optimization tricks with the variable <sil=0.621> ,COMMA and is most often used with locations that refer to hardware <sil=0.400> ,COMMA like memory-mapped IO <sil=0.435> ,COMMA or shared memory regions which might change in a way the compiler cannot predict <sil=0.955> .PERIOD The auto qualifier may only be used for variables at function scope (inside {}) and is in fact the default <sil=0.950> .PERIOD Auto variables are usually allocated off the stack (but this is up to the implementation) <sil=0.998> .PERIOD They will certainly not be retained across function calls <sil=0.924> .PERIOD NEVER return the ADDRESS of an automatic variable from a function call (once you know about pointers) <sil=0.931> .PERIOD Because new automatic variables are "created" every time you go into a function <sil=0.582> ,COMMA this allows C functions to be called recursively <sil=0.937> .PERIOD The register qualifier is really obsolete <sil=0.992> .PERIOD It is a hint to the compiler that a variable is frequently used and should be placed in a register <sil=0.957> .PERIOD The compiler is quite free to ignore this hint <sil=0.579> ,COMMA and frequently does <sil=0.389> ,COMMA because it generally knows far more about optimizing than you do (Microsoft Visual C++ or DEC C for example) <sil=0.931> .PERIOD Don't bother using register <sil=0.904> .PERIOD Enumerated types <sil=0.409> ,COMMA enum <sil=0.649> ,COMMA are similar to Fortran integer PARAMETERs <sil=0.344> ,COMMA but nicer to use <sil=0.906> .PERIOD The general form is enum identifier { enumerator_list } <sil=0.572> ,COMMA where "identifier" is optional but recommended <sil=0.996> .PERIOD The comma-separated list of enumerated values starts at zero by default <sil=0.317> ,COMMA but you can override this as shown in the example <sil=0.968> .PERIOD C Example

/*----------------------------------------------------------------------------*/
    enum timer_state_e { TPending <sil=0.586> ,COMMA TExpired <sil=0.499> ,COMMA TCancelled} <sil=0.432> ;SEMICOLON enum timer_trn_e { TmrSet=4401 <sil=0.591> ,COMMA TCancel=4414} <sil=0.391> ;SEMICOLON  <sil=0.902> .PERIOD enum timer_state_e t_state <sil=0.575> ;SEMICOLON enum timer_trn_e t_trn <sil=0.394> ;SEMICOLON  <sil=0.949> .PERIOD t_state = TExpired <sil=0.505> ;SEMICOLON /* t_state now contains 1 */
    t_trn = TCancel <sil=0.464> ;SEMICOLON /* t_trn now contains 4414 */



*     Fortran Example
*------------------------------------------------------------------------
      INTEGER TPENDING <sil=0.503> ,COMMA TEXPIRED <sil=0.396> ,COMMA TCANCELLED
      INTEGER TSET <sil=0.525> ,COMMA TCANCEL
      PARAMETER (TPENDING = 0 <sil=0.410> ,COMMA TEXPIRED = 1 <sil=0.579> ,COMMA TCANCELLED = 2)
      PARAMETER (TSET = 4401 <sil=0.440> ,COMMA TCANCEL = 4414) <sil=0.961> .PERIOD INTEGER T_STATE <sil=0.415> ,COMMA T_TRN <sil=0.983> .PERIOD T_STATE = TEXPIRED
      T_TRN = TCANCEL

When examining t_state or t_trn in the C program with the DEC debugger <sil=0.625> ,COMMA the integer value will be converted to a name <sil=0.518> ,COMMA e <sil=0.989> .PERIOD g <sil=0.965> .PERIOD DBG> EXAMINE t_trn
PROG\main\t_trn:   TCancel
which is handy <sil=0.906> .PERIOD Unfortunately <sil=0.619> ,COMMA because the enumerated types are really type int <sil=0.346> ,COMMA you can assign any integer value to t_trn without a compiler whinge <sil=0.948> !EXCLAMATIONMARK Types and storage class modifiers are discussed in more detail in K&R II <sil=0.541> ,COMMA page 209 onwards <sil=0.643> ,COMMA if you still thirst for knowledge <sil=0.987> .PERIOD Loop and Flow Control Constructs
C has three basic loop constructs <sil=0.974> .PERIOD These are for loops <sil=0.487> ,COMMA while loops and do loops <sil=0.938> .PERIOD An example is worth a thousand words:

*     Fortran Loops Example <sil=0.975> .PERIOD INTEGER I
      LOGICAL FIRST <sil=0.993> .PERIOD PRINT * <sil=0.639> ,COMMA I
      ENDDO
*
      I = 0
      DO WHILE ( I <sil=0.914> .PERIOD LT <sil=0.970> .PERIOD LIMIT )
        I = I + 1
        PRINT * <sil=0.643> ,COMMA I
      ENDDO
*
      FIRST = <sil=0.992> .PERIOD TRUE <sil=0.964> .PERIOD DO WHILE ( FIRST <sil=0.957> .PERIOD OR <sil=0.912> .PERIOD I <sil=0.921> .PERIOD LT <sil=0.985> .PERIOD LIMIT )
        IF ( FIRST ) FIRST = <sil=0.952> .PERIOD FALSE <sil=0.970> .PERIOD PRINT * <sil=0.594> ,COMMA I
        I = I + 1
      ENDDO

/*---- C Loops Example ("loops <sil=0.975> .PERIOD c") -------------------------------------------*/

/* ANSI C Headers */
#include <stdio <sil=0.994> .PERIOD h>
#include <stdlib <sil=0.927> .PERIOD h>

/* Defines and Macros */
#define LMT 5

/* Main Program starts here */
int main( int argc <sil=0.352> ,COMMA char *argv[] )
{
    int i <sil=0.551> ;SEMICOLON /*  End of declarations <sil=0.970> .PERIOD  <sil=0.488> .PERIOD  <sil=0.340> .PERIOD */
    printf("LMT = %d\n" <sil=0.453> ,COMMA LMT) <sil=0.352> ;SEMICOLON printf("\n'for' loop - for ( i = 1 <sil=0.608> ;SEMICOLON i <= LMT <sil=0.628> ;SEMICOLON i++ ) { <sil=0.921> .PERIOD  <sil=0.625> .PERIOD  <sil=0.541> .PERIOD }\n") <sil=0.327> ;SEMICOLON for ( i = 1 <sil=0.559> ;SEMICOLON i <= LMT <sil=0.500> ;SEMICOLON i++ ) { /* More usual in C would be  i = 0 <sil=0.391> ;SEMICOLON i < LMT <sil=0.562> ;SEMICOLON i++ */
      printf("%d\n" <sil=0.578> ,COMMA i ) <sil=0.459> ;SEMICOLON }

    printf("\ni = 0\n") <sil=0.383> ;SEMICOLON printf("'while' loop - while ( i++ < LMT ) { <sil=0.909> .PERIOD  <sil=0.448> .PERIOD  <sil=0.463> .PERIOD }\n") <sil=0.611> ;SEMICOLON i = 0 <sil=0.649> ;SEMICOLON while ( i++ < LMT ) {
      printf("%d\n" <sil=0.411> ,COMMA i ) <sil=0.356> ;SEMICOLON }

    printf("\ni = LMT\n") <sil=0.400> ;SEMICOLON printf("'do' loop - do { <sil=0.907> .PERIOD  <sil=0.598> .PERIOD  <sil=0.401> .PERIOD } while ( ++i < LMT ) <sil=0.398> ;SEMICOLON - always executes at least once\n") <sil=0.608> ;SEMICOLON i = LMT <sil=0.539> ;SEMICOLON do {
      printf("%d\n" <sil=0.421> ,COMMA i ) <sil=0.473> ;SEMICOLON } while ( ++i < LMT ) <sil=0.336> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.382> ;SEMICOLON }

All these constructs are explained in detail in K&R II <sil=0.357> ,COMMA chapter 3 <sil=0.952> .PERIOD The for loop has the following general form:



    for ( expression1 <sil=0.414> ;SEMICOLON terminate_if_false_expression2 <sil=0.534> ;SEMICOLON expression3 ) { <sil=0.997> .PERIOD }

If "terminate_if_false_expression2" is missed out it is taken as being true <sil=0.588> ,COMMA so an infinite loop results <sil=0.376> ,COMMA for ( <sil=0.552> ;SEMICOLON  <sil=0.323> ;SEMICOLON ) {ever} <sil=0.930> .PERIOD The "expression1" is evaluated once before the loop starts and is most often used to initialize the loop count <sil=0.341> ,COMMA whereas "expression3" is evaluated on every pass through the loop <sil=0.635> ,COMMA just before starting the next loop <sil=0.400> ,COMMA and is frequently used to modify the loop counter <sil=0.993> .PERIOD It is quite legal <sil=0.367> ,COMMA in C <sil=0.623> ,COMMA to modify the loop counter within the loop <sil=0.438> ,COMMA and the loop control variable retains its value when the loop terminates <sil=0.922> .PERIOD Obviously "terminate_if_false_expression2" causes the loop to end if it is false <sil=0.520> ,COMMA and is used to test the termination condition <sil=0.979> .PERIOD The "while" looks like this:


    while ( expression ) { <sil=0.981> .PERIOD }

and keeps going for as long as "expression" is true <sil=0.939> .PERIOD It zero trips (that is <sil=0.474> ,COMMA the code in it is never executed) if "expression" is false on the first encounter <sil=0.902> .PERIOD The for loop above could be written using while <sil=0.908> .PERIOD expression1 <sil=0.623> ;SEMICOLON while ( terminate_if_false_expression2 ) { <sil=0.948> .PERIOD expression3 <sil=0.322> ;SEMICOLON }
It isn't a good idea to do this though <sil=0.330> ,COMMA because someone will spend ages looking at your code wondering why you didn't write a for loop <sil=0.454> ,COMMA expecting some cunning algorithm <sil=0.975> .PERIOD Finally <sil=0.346> ,COMMA before time <sil=0.620> ,COMMA the old enemy <sil=0.441> ,COMMA makes us leave Loopsville City Limits <sil=0.382> ,COMMA let's look at the "do-while" construct <sil=0.922> .PERIOD The loop body is always executed at least once


    do { <sil=0.969> .PERIOD } while ( expression ) <sil=0.375> ;SEMICOLON /* Semicolon needed */

and the loop will be repeated if "expression" is true at the end of the current loop <sil=0.975> .PERIOD There is a keyword <sil=0.316> ,COMMA break <sil=0.486> ,COMMA which lets you leave the innermost loop early <sil=0.598> ,COMMA transferring control to the statement immediately after the loop <sil=0.990> .PERIOD for ( i = 0 <sil=0.403> ;SEMICOLON i < strlen(string) <sil=0.429> ;SEMICOLON i++) {
      if ( string[i] == '$' ) {
        found_dollar = TRUE <sil=0.343> ;SEMICOLON /*      Once we've found the dollar no need to search rest of string */
        break <sil=0.347> ;SEMICOLON }
    }
/*  Jump to here on "break" */ <sil=0.987> .PERIOD A related keyword <sil=0.584> ,COMMA continue <sil=0.339> ,COMMA skips to the end of the loop and continues with the next loop iteration <sil=0.986> .PERIOD for ( i = 0 <sil=0.508> ;SEMICOLON i < strlen(string) <sil=0.627> ;SEMICOLON i++) {
/*    Don't  bother trying to upcase spaces */
      if ( string[i] == ' ' ) continue <sil=0.609> ;SEMICOLON /* Move on to next character */
/*      It wasn't a space so have a go */
        string[i] = toupper( string[i] ) <sil=0.552> ;SEMICOLON }
/*  Jump to here on "break" */ <sil=0.921> .PERIOD This is most often used to avoid complex indenting and "if" tests <sil=0.958> .PERIOD Don't use it like I just did <sil=0.439> ,COMMA which was a silly example <sil=0.921> .PERIOD You have already met the "if" construct <sil=0.901> .PERIOD Here it is again <sil=0.376> ,COMMA with the "else if" demonstrated too <sil=0.942> .PERIOD if ( expression ) { <sil=0.991> .PERIOD /*    Do something */ <sil=0.940> .PERIOD } else if ( other_expression ) { <sil=0.992> .PERIOD /*    Do something else */ <sil=0.925> .PERIOD } else if ( final_expression ) { <sil=0.960> .PERIOD /*    Do something different */ <sil=0.994> .PERIOD } else { <sil=0.902> .PERIOD /*    Catch all if none of above expressions are true */ <sil=0.966> .PERIOD }

It is legal to write this kind of thing

    if ( expression )       /* Avoid this form */
      i = 1 <sil=0.624> ;SEMICOLON else
      i = 2 <sil=0.486> ;SEMICOLON The problem arises if you do this

    if ( expression )       /* This is probably not what was intended */
      i = 1 <sil=0.548> ;SEMICOLON else
      i = 2 <sil=0.556> ;SEMICOLON dont_forget_this = 3 <sil=0.572> ;SEMICOLON You might think that if "expression" is true (i <sil=0.981> .PERIOD e <sil=0.452> .PERIOD non-zero) then you would set i to 1 <sil=0.622> ,COMMA and if it were false you would set i to 2 and dont_forget_this to 3 <sil=0.941> .PERIOD In fact you will always set dont_forget_this to 3 <sil=0.424> ,COMMA because only the first statement after the "else" is grouped with the "else" <sil=0.954> .PERIOD I never use this form <sil=0.390> ,COMMA other than for a one liner like


    if ( expression ) expression_was_true = TRUE <sil=0.353> ;SEMICOLON where the meaning is clear <sil=0.916> .PERIOD Use the bracketed form which makes it totally unambiguous <sil=0.392> ,COMMA and is easier to use with the debugger <sil=0.925> .PERIOD C provides an alternative to lots of if - else if tests <sil=0.909> .PERIOD This is the "switch" statement <sil=0.990> .PERIOD The "expression_yielding_integer" is calculated <sil=0.382> ,COMMA and matched against the "case" "const-int-expression"s <sil=0.907> .PERIOD When one matches <sil=0.381> ,COMMA the statements following are executed <sil=0.324> ,COMMA or if none match <sil=0.328> ,COMMA the statements following "default" are executed

    switch ( expression_yielding_integer ) {
      case const-int-expression1:
        statements1 <sil=0.348> ;SEMICOLON case const-int-expression2:
        statements2 <sil=0.324> ;SEMICOLON case const-int-expression3:
        statements3 <sil=0.626> ;SEMICOLON  <sil=0.954> .PERIOD  <sil=0.989> .PERIOD default:
        statementsN <sil=0.587> ;SEMICOLON }
Unfortunately a bad default behaviour was chosen for this <sil=0.956> .PERIOD Each "case" drops through to the next one by default <sil=0.325> ,COMMA so if <sil=0.560> ,COMMA say <sil=0.401> ,COMMA "expression_yielding_integer" matched "const-int-expression2" <sil=0.344> ,COMMA then "statements2" through to "statementsN" would ALL be executed <sil=0.929> .PERIOD This is solved by using "break" again <sil=0.999> .PERIOD switch ( expression_yielding_integer ) {
      case const-int-expression1:
        statements1 <sil=0.434> ;SEMICOLON break <sil=0.521> ;SEMICOLON /* Always use break by default */
      case const-int-expression2:
        statements2 <sil=0.308> ;SEMICOLON break <sil=0.518> ;SEMICOLON case const-int-expression3:
        statements3 <sil=0.645> ;SEMICOLON break <sil=0.444> ;SEMICOLON  <sil=0.988> .PERIOD  <sil=0.930> .PERIOD default:
        statementsN <sil=0.364> ;SEMICOLON break <sil=0.369> ;SEMICOLON }
The default behaviour is rarely what is required in practise <sil=0.538> ,COMMA and it would have been far better to have a default "break" before each case <sil=0.335> ,COMMA and maybe use "continue" to indicate fall-through <sil=0.915> .PERIOD Remember that chars can be used as small integers <sil=0.603> ,COMMA so the following is quite legal <sil=0.987> .PERIOD char command_line_option <sil=0.352> ;SEMICOLON  <sil=0.960> .PERIOD switch ( command_line_option ) {
      case 'v':
        verbose_mode = TRUE <sil=0.375> ;SEMICOLON break <sil=0.565> ;SEMICOLON case 'l':
        produce_listing = TRUE <sil=0.604> ;SEMICOLON break <sil=0.343> ;SEMICOLON case ' <sil=0.956> ?QUESTIONMARK ':               /* Following two cases deliberately fall thru */
      case 'h':
        display_help = TRUE <sil=0.380> ;SEMICOLON break <sil=0.633> ;SEMICOLON default:
        use_default_options = TRUE:
        break <sil=0.469> ;SEMICOLON }

Arrays
Arrays in C always start at the 0 element rather than 1 <sil=0.399> ,COMMA and there is NO ARRAY BOUND CHECKING (gasps of horror) <sil=0.913> .PERIOD Here is a one-dimensional example array:

    int job[20] <sil=0.428> ;SEMICOLON /* job[0] <sil=0.511> ,COMMA job[1] <sil=0.961> .PERIOD  <sil=0.636> .PERIOD job[19] */

and the dimension must be an integer greater than zero <sil=0.978> .PERIOD This is how to declare a two-dimensional array [rows][columns]


    int job[4][20] <sil=0.370> ;SEMICOLON /* Like 4 job[20] 's <sil=0.435> ,COMMA job[0][0] <sil=0.360> ,COMMA job[0][1] <sil=0.961> .PERIOD  <sil=0.552> .PERIOD job[3][19] */ <sil=0.966> .PERIOD i = job[2][0] <sil=0.460> ;SEMICOLON /* Good */ <sil=0.974> .PERIOD i = job[2 <sil=0.530> ,COMMA 0] <sil=0.496> ;SEMICOLON /* Bad - don't ever do this */ <sil=0.961> .PERIOD Multi-dimensional arrays are column major <sil=0.519> ;SEMICOLON that is <sil=0.518> ,COMMA the right-most subscript varies fastest <sil=0.649> ,COMMA unlike Fortran <sil=0.416> .PERIOD Notice that you can't use commas to separate the indices <sil=0.980> .PERIOD Separate pairs of square brackets are needed for each index <sil=0.976> .PERIOD There is no limit to the number of dimensions other than those imposed by your compiler and the amount of memory available <sil=0.961> .PERIOD In practice <sil=0.526> ,COMMA multi-dimensional arrays are rarely used <sil=0.967> .PERIOD Unfortunately <sil=0.389> ,COMMA you can't (in C) use const int's as array bounds <sil=0.973> .PERIOD You have to use #define <sil=0.489> ,COMMA like this:


#define MAX_SIZE <sil=0.907> .PERIOD float floaty[MAX_SIZE] <sil=0.382> ;SEMICOLON More will be said about #define later <sil=0.967> .PERIOD Arrays can be initialized when they are defined:


    int days_in_month[12] = { 31 <sil=0.494> ,COMMA 28 <sil=0.377> ,COMMA 31 <sil=0.356> ,COMMA 30 <sil=0.647> ,COMMA 31 <sil=0.528> ,COMMA 30 <sil=0.547> ,COMMA 31 <sil=0.507> ,COMMA 31 <sil=0.601> ,COMMA 30 <sil=0.421> ,COMMA 31 <sil=0.300> ,COMMA 30 <sil=0.649> ,COMMA 31 } <sil=0.505> ;SEMICOLON int matrix[2][3] = { { 0 <sil=0.441> ,COMMA 1 <sil=0.643> ,COMMA 2 } <sil=0.598> ,COMMA { 3 <sil=0.304> ,COMMA 4 <sil=0.428> ,COMMA 5 } } <sil=0.562> ;SEMICOLON Remember that uninitialized arrays can contain anything at all <sil=0.444> ,COMMA so don't expect them to be full of zeros <sil=0.995> .PERIOD In addition <sil=0.330> ,COMMA initialized arrays can't be "demand zero compressed" <sil=0.991> .PERIOD You can leave out the size of an array and have it use the number of initializers <sil=0.622> ,COMMA like this


    int array_initialization_pages_in_K_and_R_II[] = { 86 <sil=0.608> ,COMMA 112 <sil=0.361> ,COMMA 113 <sil=0.577> ,COMMA 219 } <sil=0.611> ;SEMICOLON which produces an array of 4 integers <sil=0.944> .PERIOD You would probably want to use sizeof() to determine the size of the array in this case


     nelements =   sizeof( array_initialization_pages_in_K_and_R_II )    /
/*               -----------------------------------------------------        */
                 sizeof( array_initialization_pages_in_K_and_R_II[0] ) <sil=0.612> ;SEMICOLON  <sil=1.000> .PERIOD for ( i = 0 <sil=0.359> ;SEMICOLON i < nelements <sil=0.543> ;SEMICOLON i++) { <sil=0.943> .PERIOD }

Notice that you index up to LESS THAN the number of elements <sil=0.309> ,COMMA because the last element is (nelements-1) <sil=0.955> .PERIOD Strings
Character arrays containing a contiguous sequence of characters terminated with the null character <sil=0.591> ,COMMA '\0' <sil=0.648> ,COMMA are known as strings in C <sil=0.903> .PERIOD Initialized character arrays become static by default <sil=0.364> ,COMMA i <sil=0.370> .PERIOD e <sil=0.545> .PERIOD retain their value across function calls <sil=0.556> ,COMMA unless you change them <sil=0.917> .PERIOD The initializer <sil=0.304> ,COMMA or "string literal" is delimited by double quotes "like this" <sil=0.945> .PERIOD You can split a string initializer over several lines <sil=0.646> ,COMMA each part being in " quotes <sil=0.529> ,COMMA and they will be concatenated together <sil=0.944> .PERIOD The resultant string has the null character <sil=0.395> ,COMMA represented by the escape sequence '\0' <sil=0.352> ,COMMA appended to the end of it <sil=0.982> .PERIOD char random[80] <sil=0.631> ;SEMICOLON /* Could contain anything */
    char title[] = "Phil's Ramblings" <sil=0.493> ;SEMICOLON /* Takes 17 bytes due to '\0' at end */

    char longer_string[] = "Here is quite a long string split up over"
                           "two lines <sil=0.920> .PERIOD VAX C doesn't allow this <sil=0.311> ,COMMA though <sil=0.990> .PERIOD "
                           "Another good reason to switch to DEC C on"
                           "VAX or Alpha VMS <sil=0.392> ,COMMA or Visual C++ for Windows <sil=0.939> .PERIOD "

    char string_with_quote[] = "Here is the quote \" character" <sil=0.474> ;SEMICOLON The name that you give to an array can be used as a pointer to the zeroeth element of the array <sil=0.950> .PERIOD More will be said about this in the "Pointers" section <sil=0.991> .PERIOD There are many functions in the standard library for manipulating character strings <sil=0.403> ,COMMA and these all begin with "str" <sil=0.912> .PERIOD You will need to include <string <sil=0.920> .PERIOD h> to use them <sil=0.950> .PERIOD Look in K&R II pages 249-250 <sil=0.996> .PERIOD These functions expect an array <sil=0.462> ,COMMA or a pointer to characters <sil=0.409> ,COMMA as their arguments <sil=0.917> .PERIOD Finally <sil=0.510> ,COMMA note that an empty string is not really empty <sil=0.921> .PERIOD char is_it_empty[] = "" <sil=0.349> ;SEMICOLON /* No <sil=0.527> ,COMMA it contains one character <sil=0.385> ,COMMA '\0' */

Always bear in mind that the string functions often copy trailing '\0' characters <sil=0.458> ,COMMA so you must ensure that you allow space for this <sil=0.933> .PERIOD It is a good idea to always use the "strn" versions of the calls <sil=0.625> ,COMMA with sizeof(destination) as the character limit <sil=0.404> ,COMMA because that way you will avoid runaway (and hard to detect) memory overwriting <sil=0.944> .PERIOD Remember to terminate the destination string <sil=0.362> ,COMMA e <sil=0.902> .PERIOD g <sil=0.926> .PERIOD strncpy( destination <sil=0.411> ,COMMA source <sil=0.625> ,COMMA sizeof(destination) ) <sil=0.421> ;SEMICOLON destination[sizeof(destination)-1] = '\0' <sil=0.346> ;SEMICOLON else you'll end up avoiding potential overwrites <sil=0.615> ,COMMA but leave a potentially unterminated string to catch you out later <sil=0.919> !EXCLAMATIONMARK Pointers
Pointers are declared using the * <sil=0.559> ,COMMA or "dereference operator" <sil=0.968> .PERIOD int *i_ptr <sil=0.445> ;SEMICOLON declares a pointer to type int <sil=0.960> .PERIOD As declared above <sil=0.563> ,COMMA i_ptr is most likely not yet pointing at a valid location <sil=0.976> .PERIOD In order to make it point somewhere valid <sil=0.583> ,COMMA you generally use the "address operator" <sil=0.402> ,COMMA & <sil=0.473> ,COMMA like this


    int i <sil=0.389> ;SEMICOLON int j <sil=0.449> ;SEMICOLON int *i_ptr <sil=0.313> ;SEMICOLON  <sil=0.948> .PERIOD i_ptr = &i <sil=0.360> ;SEMICOLON  <sil=0.962> .PERIOD You can then change or read the value of i by using the "dereference operator" <sil=0.503> ,COMMA and change the object pointed to <sil=0.448> ,COMMA providing it is an object of the correct type <sil=0.974> .PERIOD *i_ptr = 3 <sil=0.370> ;SEMICOLON /* Set the int pointed to by i_ptr to 3 */
    printf("%d\n" <sil=0.354> ,COMMA i ) <sil=0.542> ;SEMICOLON /* i will be 3 */ <sil=0.911> .PERIOD i_ptr = &j <sil=0.629> ;SEMICOLON /* Set the i_ptr to point to j now */ <sil=0.957> .PERIOD *i_ptr = 3 <sil=0.569> ;SEMICOLON /* Set the int pointed to by i_ptr to 3 */
    printf("%d\n" <sil=0.452> ,COMMA j ) <sil=0.605> ;SEMICOLON /* j will be 3 */ <sil=0.962> .PERIOD This is a rather silly example <sil=0.604> ,COMMA because you would obviously just use i or j directly <sil=0.947> .PERIOD A more realistic use of pointers is with arrays:


    char string[] = "Here is a string with a $ in it" <sil=0.470> ;SEMICOLON char *sptr <sil=0.562> ;SEMICOLON int contains_dollar <sil=0.593> ;SEMICOLON  <sil=0.950> .PERIOD sptr = string <sil=0.573> ;SEMICOLON /* Remember that the array name is the same as &array[0] */
    contains_dollar = FALSE <sil=0.605> ;SEMICOLON while ( *sptr ) {  /* While thing pointed to is not 0 i <sil=0.975> .PERIOD e <sil=0.464> .PERIOD null character */
      if ( *sptr == '$' ) {
        contains_dollar = TRUE <sil=0.533> ;SEMICOLON break <sil=0.433> ;SEMICOLON /* Leave the while loop early and safely */
      }
      ++sptr <sil=0.617> ;SEMICOLON } <sil=0.949> .PERIOD When you increment pointers <sil=0.531> ,COMMA they automatically increment the address they point to by the size of one of the objects to which they point <sil=0.964> .PERIOD In the example above <sil=0.628> ,COMMA that is one character <sil=0.515> ,COMMA i <sil=0.396> .PERIOD e <sil=0.566> .PERIOD a byte <sil=0.982> .PERIOD If the array was an array of int <sil=0.602> ,COMMA then the pointer would increment by sizeof(int) bytes <sil=0.946> .PERIOD Just to frighten you <sil=0.562> ,COMMA this loop could be written


    while ( *sptr && <sil=0.963> !EXCLAMATIONMARK ( contains_dollar = *sptr++ == '$' ) ) <sil=0.479> ;SEMICOLON Programming Challenge 5
      _______________________
      
        You  guessed it <sil=0.963> .PERIOD Figure out what is happening in the scary "while"
      loop above <sil=0.959> .PERIOD Now write your own (differently named) version of strcpy
      using similar techniques to make it as short as possible <sil=0.970> .PERIOD Arrays and pointers are closely related <sil=0.981> .PERIOD They can be used in identical ways in many situations <sil=0.987> .PERIOD For example: <sil=0.921> .PERIOD char string[80] <sil=0.644> ;SEMICOLON char *sptr <sil=0.351> ;SEMICOLON  <sil=0.931> .PERIOD sptr = &string[0] <sil=0.640> ;SEMICOLON /* This could be written as sptr = string */ <sil=0.930> .PERIOD *string       = 'A' <sil=0.305> ;SEMICOLON /* Using array name like pointer */
    *(string+10)  = 'B' <sil=0.531> ;SEMICOLON /* Using array name like pointer */ <sil=0.936> .PERIOD sptr[0]       = 'A' <sil=0.558> ;SEMICOLON /* Using pointer like array */
    sptr[10]      = 'B' <sil=0.542> ;SEMICOLON /* Using pointer like array */ <sil=0.914> .PERIOD This is because <sil=0.621> ,COMMA in expressions or function calls <sil=0.476> ,COMMA arrays and pointers are both converted to the form "*(pointer + index-offset)" <sil=0.903> .PERIOD The main thing to remember is that pointers are variables <sil=0.392> ,COMMA and can be changed to point to different objects <sil=0.522> ,COMMA whereas array names are not variables <sil=0.924> .PERIOD The index-offset is automatically scaled according to the type of data pointed to <sil=0.908> .PERIOD In this case <sil=0.438> ,COMMA we are dealing with char which <sil=0.472> ,COMMA by definition <sil=0.428> ,COMMA has a size of 1 <sil=0.643> ,COMMA but if the pointers were pointers to int <sil=0.537> ,COMMA then on the VAX or Alpha <sil=0.533> ,COMMA the index-offset would be automatically scaled by 4 <sil=0.969> .PERIOD  <sil=0.936> .PERIOD int array[20] <sil=0.603> ;SEMICOLON int another_array[20] <sil=0.567> ;SEMICOLON int *i_ptr <sil=0.429> ;SEMICOLON  <sil=0.909> .PERIOD i_ptr = array <sil=0.474> ;SEMICOLON /* Legal */
    i_ptr[12] = 3 <sil=0.464> ;SEMICOLON  <sil=0.914> .PERIOD i_ptr = another_array <sil=0.315> ;SEMICOLON /* Legal */
    i_ptr[2] = 4 <sil=0.549> ;SEMICOLON  <sil=0.933> .PERIOD array = another_array <sil=0.620> ;SEMICOLON /* Illegal <sil=0.908> !EXCLAMATIONMARK */ <sil=0.902> .PERIOD Even multi-dimensional arrays get decomposed to the "*(pointer + index-offset)" by the compiler in say <sil=0.635> ,COMMA a function call <sil=0.415> ,COMMA which gives you no special knowledge of how they fold <sil=0.946> .PERIOD Hence if you are using a pointer to a multi-dimensional array where the dimensions could vary <sil=0.537> ,COMMA it is up to you to calculate the offset correctly <sil=0.545> ,COMMA e <sil=0.943> .PERIOD g <sil=0.990> .PERIOD int mda[ROWS][COLS] <sil=0.368> ;SEMICOLON  <sil=0.988> .PERIOD i = funcy( mda <sil=0.597> ,COMMA ROWS <sil=0.575> ,COMMA COLS ) <sil=0.576> ;SEMICOLON  <sil=0.963> .PERIOD int funcy( int *array <sil=0.532> ,COMMA rows <sil=0.556> ,COMMA cols )
{ <sil=0.941> .PERIOD for ( i = 0 <sil=0.531> ;SEMICOLON i < rows <sil=0.646> ;SEMICOLON i++) {
      for ( j = 0 <sil=0.477> ;SEMICOLON j < cols <sil=0.565> ;SEMICOLON j++) {
        total += *(array + i*cols + j) <sil=0.426> ;SEMICOLON }
    } <sil=0.917> .PERIOD }

Of course <sil=0.555> ,COMMA if the function was only expected to deal with arrays of set dimensions <sil=0.365> ,COMMA you could just declare those in funcy() <sil=0.920> .PERIOD int mda[ROWS][COLS] <sil=0.604> ;SEMICOLON  <sil=0.933> .PERIOD i = funcy( mda ) <sil=0.368> ;SEMICOLON  <sil=0.923> .PERIOD int funcy( int array[ROWS][COLS] )
{ <sil=0.993> .PERIOD for ( i = 0 <sil=0.423> ;SEMICOLON i < ROWS <sil=0.472> ;SEMICOLON i++) {
      for ( j = 0 <sil=0.448> ;SEMICOLON j < COLS <sil=0.456> ;SEMICOLON j++) {
        total += array[i][j] <sil=0.600> ;SEMICOLON }
    } <sil=0.943> .PERIOD }

The strange += assignment operator isn't a misprint <sil=0.937> .PERIOD It is shorthand <sil=0.366> ,COMMA so that


    x = x + 4 <sil=0.390> ;SEMICOLON can be written


    x += 4 <sil=0.547> ;SEMICOLON Similarly

    y = y - 10 <sil=0.541> ;SEMICOLON becomes


    y -= 10 <sil=0.543> ;SEMICOLON There must be NO SPACE between the operator and the = sign <sil=0.523> ,COMMA and the operator comes immediately before the = <sil=0.988> .PERIOD This notation is handy for more complex expressions <sil=0.619> ,COMMA such as


    array[ hash_value[index]*k + offset[i] ] += 4 <sil=0.308> ;SEMICOLON so you only need maintain the expression in one place <sil=0.937> .PERIOD Many binary operators have a similar assignment operator <sil=0.992> .PERIOD Check K&R II page 50 and page 48 for the bitwise operators that can also be used in this way <sil=0.930> .PERIOD The other thing to remember is that whereas arrays allocate space <sil=0.348> ,COMMA and hence the array name points to something valid <sil=0.649> ,COMMA pointers MUST NEVER BE USED UNTIL THEY HAVE BEEN INITIALIZED TO POINT TO SOMETHING VALID <sil=0.920> .PERIOD There is a special pointer value defined by the standard <sil=0.359> ,COMMA called the NULL pointer <sil=0.322> ,COMMA which is used to indicate that the pointer doesn't point to anything <sil=0.950> .PERIOD Normally <sil=0.321> ,COMMA you cannot directly assign integers to pointers <sil=0.582> ,COMMA but the NULL pointer is an exception <sil=0.987> .PERIOD Both the following lines make p point to "nothing" (well <sil=0.329> ,COMMA a guaranteed "not valid location" really) <sil=0.998> .PERIOD i_ptr = 0 <sil=0.353> ;SEMICOLON /* Legal but not recommended */    
    i_ptr = NULL <sil=0.614> ;SEMICOLON /* Recommended - it is clear that you refer to a pointer */

The NULL macro (see Macros section later on) <sil=0.508> ,COMMA defined identically in <stddef <sil=0.908> .PERIOD h> and <stdio <sil=0.992> .PERIOD h> among other places <sil=0.504> ,COMMA is often defined as


#define NULL     ((void *) 0)

even though "0" would do <sil=0.905> .PERIOD This discourages its use as an integer <sil=0.432> ,COMMA which you should never do <sil=0.959> .PERIOD People often make the mistake of writing


    string[i] = NULL <sil=0.627> ;SEMICOLON /* Never do this - you really want '\0' */
    i = NULL <sil=0.456> ;SEMICOLON /* Never do this if i is integer and you really mean 0 */

when what they actually mean is


    string[i] = '\0' <sil=0.365> ;SEMICOLON /* The null character - that's more like it */
    i = 0 <sil=0.566> ;SEMICOLON /* Integer zero */

A pointer of type (void *) is a special type of pointer that is guaranteed to be able to point to any type of object <sil=0.584> ,COMMA hence the NULL pointer can be assigned to any pointer type <sil=0.916> .PERIOD The NULL pointer need not have all bits set to zero <sil=0.513> ,COMMA so don't rely on this <sil=0.953> .PERIOD Pointers are very useful as function arguments for routines that manipulate strings of unknown (at compile time) length <sil=0.947> .PERIOD int how_long( const char *s )
{
    int i <sil=0.535> ;SEMICOLON /*  End of declarations <sil=0.987> .PERIOD  <sil=0.303> .PERIOD  <sil=0.346> .PERIOD */
    i = 0 <sil=0.425> ;SEMICOLON while ( *s++ ) {
      i++ <sil=0.376> ;SEMICOLON /* Increment i until '\0' found */
    }
    return( i ) <sil=0.347> ;SEMICOLON }

Even though the thing pointed to by s is const <sil=0.641> ,COMMA note that it is quite legal to increment the pointer s in the function <sil=0.317> ,COMMA because s is a local <sil=0.532> ,COMMA variable pointer <sil=0.362> ,COMMA pointing to whatever the calling argument to how_long() was <sil=0.992> .PERIOD Hence if you call how_long(string) <sil=0.523> ,COMMA you don't change string <sil=0.466> ,COMMA you assign string to s then increment s <sil=0.979> .PERIOD Any expression using array subscripting <sil=0.393> ,COMMA for example array[index] <sil=0.454> ,COMMA is exactly the same in C as its pointer equivalent <sil=0.408> ,COMMA in this case *(array+index) <sil=0.990> .PERIOD You have to be careful when using the const modifier with pointers <sil=0.923> .PERIOD The following examples should illustrate the point <sil=0.997> .PERIOD int i <sil=0.360> ;SEMICOLON const int *i_ptr <sil=0.324> ;SEMICOLON /* i_ptr points to a const int */
    int * const i_ptr = &i <sil=0.322> ;SEMICOLON /* i_ptr is const <sil=0.440> ,COMMA points to variable int */

Another important difference between pointers and arrays relates to the sizeof() operator <sil=0.999> .PERIOD int array[20] <sil=0.616> ;SEMICOLON int *i_ptr <sil=0.403> ;SEMICOLON size_t s <sil=0.449> ;SEMICOLON  <sil=0.912> .PERIOD i_ptr = array <sil=0.452> ;SEMICOLON  <sil=0.970> .PERIOD s = sizeof(array) <sil=0.449> ;SEMICOLON /* s is 20*sizeof(int) <sil=0.555> ,COMMA which is 100 on the VAX */
    s = sizeof(i_ptr) <sil=0.450> ;SEMICOLON /* s is sizeof(int *) <sil=0.590> ,COMMA which is 4 on the VAX    */ <sil=0.980> .PERIOD You can't deduce the size of an array from a pointer <sil=0.628> ,COMMA only the size of the pointer <sil=0.938> .PERIOD Because arrays as function arguments are treated the same as pointers <sil=0.406> ,COMMA then even if you declare the function arguments as "func( int array[10] )" array is still treated like a pointer in the function body <sil=0.569> ,COMMA so sizeof(array) in the function will give you the size of pointer to int <sil=0.541> ,COMMA not 10 times size of int <sil=0.941> .PERIOD It is quite legal to write a pointer definition like this:


    int* i_ptr <sil=0.311> ;SEMICOLON /* Not recommended */

This is best avoided <sil=0.500> ,COMMA because it can be confusing <sil=0.976> .PERIOD Consider


    int* i_ptr1 <sil=0.519> ,COMMA i_ptr2 <sil=0.562> ;SEMICOLON /* Probably not what you intended */

At first glance it looks like you have just declared two pointers to int <sil=0.947> .PERIOD In fact <sil=0.417> ,COMMA i_ptr1 is a pointer <sil=0.399> ,COMMA but i_ptr2 is an int <sil=0.929> .PERIOD int *i_ptr1 <sil=0.344> ,COMMA *i_ptr2 <sil=0.512> ;SEMICOLON /* Better */

The second example keeps the * with the variable to which it relates <sil=0.309> ,COMMA and is considered better style (by me at any rate) <sil=0.914> !EXCLAMATIONMARK There are two standard library functions often used with pointer <sil=0.984> .PERIOD They are declared in <stdlib <sil=0.971> .PERIOD h> <sil=0.919> ,COMMA and are malloc() and free() <sil=0.945> .PERIOD Both are AST reentrant under DEC C <sil=0.996> .PERIOD The malloc() function allocates an area of memory specified in bytes <sil=0.512> ,COMMA and is declared as


void *malloc(size_t size) <sil=0.628> ;SEMICOLON and would be used like this <sil=0.935> .PERIOD int *i_ptr <sil=0.303> ;SEMICOLON  <sil=0.914> .PERIOD i_ptr = (int *)malloc( sizeof(int)*nelements_wanted ) <sil=0.632> ;SEMICOLON if ( i_ptr <sil=0.977> !EXCLAMATIONMARK = NULL ) { <sil=0.933> .PERIOD i_ptr[i] = i <sil=0.619> ;SEMICOLON  <sil=0.984> .PERIOD } else { <sil=0.973> .PERIOD /*    Couldn't get the memory - do some cunning recovery */ <sil=0.973> .PERIOD }

It is good practise to "cast" the result of a malloc() to the correct type <sil=0.989> .PERIOD This helps the compiler to indirectly check whether you are using the correct type in the sizeof() invocation too <sil=0.993> .PERIOD If it complains about your cast <sil=0.403> ,COMMA then (assuming the type is the same in the sizeof() ) you are probably using the wrong type in both places <sil=0.414> ,COMMA and might have allocated too little memory <sil=0.958> .PERIOD There is no check if you wander off the allocated memory <sil=0.587> ,COMMA out into memory space no man has seen before <sil=0.866> !EXCLAMATIONMARK The memory returned by malloc() can contain any values when you get it <sil=0.373> ,COMMA i <sil=0.595> .PERIOD e <sil=0.459> .PERIOD it is not set to zero <sil=0.912> .PERIOD The free() function frees up the memory obtained from malloc() <sil=0.968> .PERIOD It is declared as


void free(void *pointer) <sil=0.426> ;SEMICOLON and would be used like this to free the memory obtained in the previous example


    free( i_ptr ) <sil=0.554> ;SEMICOLON i_ptr = NULL <sil=0.575> ;SEMICOLON /* Good practise */

I like to set the pointer to NULL immediately upon freeing the memory <sil=0.481> ,COMMA because the pointer MUST NOT BE USED again after being free()ed <sil=0.976> .PERIOD By setting it to NULL <sil=0.313> ,COMMA you will (under VMS or Windows NT) get an ACCVIO if you try and dereference the pointer <sil=0.910> .PERIOD This is safer than leaving it <sil=0.352> ,COMMA having the memory reused elsewhere <sil=0.553> ,COMMA then changing it via the duff pointer <sil=0.913> .PERIOD This sort of mistake is very hard to track down <sil=0.913> .PERIOD It is very important to always free malloc()-ed memory when you are done with it <sil=0.446> ,COMMA or you will cause what is known as a "memory leak" <sil=0.994> .PERIOD There are a couple of functions related to malloc() <sil=0.936> .PERIOD One is calloc() <sil=0.347> ,COMMA which allows you to allocate memory and initialize it's value in one go <sil=0.979> .PERIOD void *calloc(size_t number <sil=0.522> ,COMMA size_t size) <sil=0.361> ;SEMICOLON The other function is realloc() <sil=0.542> ,COMMA which allows you to expand a region of memory obtained by malloc() <sil=0.629> ,COMMA whilst retaining its current contents <sil=0.997> .PERIOD void *realloc(void *pointer <sil=0.564> ,COMMA size_t size) <sil=0.359> ;SEMICOLON The new <sil=0.419> ,COMMA expanded region of memory need not be in the same place as the original


    new_i_ptr = (int *)realloc( i_ptr <sil=0.619> ,COMMA sizeof(int)*larger_nelements_wanted ) <sil=0.594> ;SEMICOLON if ( new_i_ptr ) {
/*    Successfully expanded */
      i_ptr = new_i_ptr <sil=0.316> ;SEMICOLON /* Don't free anything here <sil=0.856> !EXCLAMATIONMARK */
    } else {
/*    Couldn't get the extra memory <sil=0.409> ,COMMA stick with the existing pointer */
    }

so in this example the memory may have changed location <sil=0.367> ,COMMA but the original content will have been copied to the new location <sil=0.927> .PERIOD Note how I use a new pointer <sil=0.477> ,COMMA new_i_ptr <sil=0.506> ,COMMA to check that the relocation was successful <sil=0.928> .PERIOD This is essential because if you directly assigned to the pointer to the memory you were trying to realloc and the call failed (returning NULL) you would have no way to free the memory originally pointed to by i_ptr <sil=0.923> .PERIOD /*  Never do this - always assign the return value to a different pointer */
    i_ptr = (int *)realloc( i_ptr <sil=0.304> ,COMMA sizeof(int)*larger_nelements_wanted ) <sil=0.336> ;SEMICOLON A final couple of warnings about pointers <sil=0.952> .PERIOD Firstly <sil=0.379> ,COMMA the [] operator has a higher precedence than the * <sil=0.426> ,COMMA so int *array[] means an array of pointers to int <sil=0.402> ,COMMA not a pointer to an array of ints <sil=0.915> .PERIOD Secondly <sil=0.339> ,COMMA the following two statements are not equivalent:


extern int  is[] <sil=0.530> ;SEMICOLON /* This declares an int array <sil=0.515> ,COMMA defined elsewhere */
extern int *is <sil=0.388> ;SEMICOLON /* This declares a pointer to int <sil=0.343> ,COMMA defined elsewhere */

The compiler will actually generate code you did not intend <sil=0.490> ,COMMA and probably cause an ACCVIO if you confuse these <sil=0.902> .PERIOD This is because an access via a pointer first looks at the address of the pointer <sil=0.307> ,COMMA gets the pointer value stored there <sil=0.458> ,COMMA and uses that as the base address for lookups <sil=0.995> .PERIOD Access via an array name uses the address of the array itself as the base address for lookups <sil=0.945> .PERIOD Draw a diagram if you are confused <sil=0.932> !EXCLAMATIONMARK Using the EXT and DEFINE_GLOBALS macros <sil=0.553> ,COMMA explained later <sil=0.491> ,COMMA should stop this ever happening to you <sil=0.915> .PERIOD Structures and Unions
Structures and unions in C are pretty much like their Fortran counterparts <sil=0.974> .PERIOD The general form of a structure declaration is
struct optional_structure_identifier {what's in it} optional_instance <sil=0.417> ;SEMICOLON I suggest that you always specify optional_structure_identifier <sil=0.525> ,COMMA then declare the instances of the structure later in a manner similar to the way we used enum <sil=0.901> .PERIOD Example:


/*     C Example */                    |*     Fortran Example
                                       |
struct oscar_location_s {              |      STRUCTURE /OSCAR_LOCATION_S/
  int x <sil=0.607> ;SEMICOLON |        INTEGER X
  int y <sil=0.566> ;SEMICOLON |        INTEGER Y
} <sil=0.382> ;SEMICOLON /* Note the semicolon <sil=0.569> ;SEMICOLON */          |      END STRUCTURE <sil=0.932> .PERIOD | <sil=0.973> .PERIOD int main( int argc <sil=0.495> ,COMMA char *argv[] )     | <sil=0.958> .PERIOD {                                      | <sil=0.941> .PERIOD struct oscar_location_s loc <sil=0.617> ;SEMICOLON |      RECORD /OSCAR_LOCATION_S/ LOC <sil=0.977> .PERIOD | <sil=0.976> .PERIOD loc <sil=0.943> .PERIOD x = 100 <sil=0.493> ;SEMICOLON |      LOC <sil=0.948> .PERIOD X = 100
    loc <sil=0.913> .PERIOD y =  50 <sil=0.308> ;SEMICOLON |      LOC <sil=0.969> .PERIOD Y =  50 <sil=0.935> .PERIOD | <sil=0.977> .PERIOD }                                      |

Similarly with unions <sil=0.589> ,COMMA the following trivial example shows how they might be declared and used:


/*     C Example */                    |*     Fortran Example
                                       |
union hat_u {                          |      STRUCTURE /HAT_U/
  int   mileage <sil=0.600> ;SEMICOLON |        UNION
  float hotel_cost <sil=0.357> ;SEMICOLON |          MAP
} <sil=0.541> ;SEMICOLON |            INTEGER MILEAGE <sil=0.998> .PERIOD |          END MAP
int main( int argc <sil=0.577> ,COMMA char *argv[] )     |          MAP
{                                      |            REAL HOTEL_COST
    int was_tow <sil=0.380> ;SEMICOLON |          END MAP
    union hat_u cost <sil=0.366> ;SEMICOLON |        END UNION <sil=0.993> .PERIOD |      END STRUCTURE
    if ( was_tow ) {                   | <sil=0.927> .PERIOD cost <sil=0.919> .PERIOD mileage = 100 <sil=0.479> ;SEMICOLON |      IF ( WAS_TOW ) THEN
    } else {                           |        COST <sil=0.912> .PERIOD MILEAGE = 100
      cost <sil=0.949> .PERIOD hotel_cost =  45 <sil=0.949> .PERIOD 50 <sil=0.340> ;SEMICOLON |      ELSE
    }                                  |        COST <sil=0.969> .PERIOD HOTEL_COST =  45 <sil=0.967> .PERIOD 50 <sil=0.957> .PERIOD |      ENDIF <sil=0.989> .PERIOD | <sil=0.900> .PERIOD }                                      | <sil=0.973> .PERIOD Notice that you don't need the MAP - END MAP sequence in C that is used in DEC Fortran <sil=0.940> .PERIOD Everything in the union { body } acts as though it is sandwiched between MAP - END MAP <sil=0.936> .PERIOD Structures may contain pointer references to themselves <sil=0.365> ,COMMA which is very handy for implementing linked lists:


struct list_s {
  struct list_s *prev <sil=0.547> ;SEMICOLON struct list_s *next <sil=0.417> ;SEMICOLON void *data_ptr <sil=0.617> ;SEMICOLON } <sil=0.632> ;SEMICOLON When you declare a pointer to a structure <sil=0.416> ,COMMA let's call it p <sil=0.314> ,COMMA there is a potential trap in using the pointer because the binding of the structure member operator <sil=0.411> ,COMMA  <sil=0.984> .PERIOD  <sil=0.566> ,COMMA is higher than the * dereference operator <sil=0.945> .PERIOD Hence *p <sil=0.941> .PERIOD thing means lookup the member "thing" of p <sil=0.402> ,COMMA and use that as an address for the dereference <sil=0.913> .PERIOD What you really want is (*p) <sil=0.900> .PERIOD thing <sil=0.981> .PERIOD This is a bit ugly <sil=0.402> ,COMMA so C provides the -> operator <sil=0.973> .PERIOD  <sil=0.908> .PERIOD struct my_struct_s my_struct <sil=0.379> ;SEMICOLON struct my_struct_s *struct_ptr <sil=0.627> ;SEMICOLON  <sil=0.972> .PERIOD struct_ptr = &my_struct <sil=0.580> ;SEMICOLON (*struct_ptr) <sil=0.934> .PERIOD thing = 1 <sil=0.454> ;SEMICOLON /* "thing" = 1 in struct pointed to by struct_ptr*/
    struct_ptr->thing = 1 <sil=0.607> ;SEMICOLON /* Same as above */ <sil=0.977> .PERIOD This is good place to introduce a program example kindly provided by Rob Cannings <sil=0.904> .PERIOD This uses cunning (Cannings <sil=0.982> ?QUESTIONMARK ) pointer manipulation to create a binary sorted tree <sil=0.965> .PERIOD /*---- Illustration of pointer manipulation ("treesort <sil=0.983> .PERIOD c") -------------------*/
/* Example provided by Rob Cannings:                                          */
/* (Excess white space removed by Phil O <sil=0.920> .PERIOD  <sil=0.961> ;SEMICOLON -))                                */
/* We implement a sorting routine with the sorted list stored in a tree <sil=0.957> .PERIOD */

/* ANSI C Headers */
#include <stdlib <sil=0.933> .PERIOD h>
#include <stdio <sil=0.936> .PERIOD h>

/* Structures */
struct treeNode {
  int data <sil=0.333> ;SEMICOLON struct treeNode *pLeft <sil=0.460> ;SEMICOLON struct treeNode *pRight <sil=0.429> ;SEMICOLON } <sil=0.613> ;SEMICOLON /* Function prototypes */
void AddNode(struct treeNode **ppNode <sil=0.637> ,COMMA struct treeNode *pNewNode) <sil=0.502> ;SEMICOLON void Dump(struct treeNode *pNode) <sil=0.497> ;SEMICOLON /* Defines and macros */
#define NUMBER_OF_NUMBERS 4

/* Main Program starts here */
int main(int argc <sil=0.365> ,COMMA char *argv[])
{
    int i <sil=0.634> ;SEMICOLON int toBeSorted[NUMBER_OF_NUMBERS] = { 93 <sil=0.563> ,COMMA 27 <sil=0.510> ,COMMA 15 <sil=0.460> ,COMMA 47} <sil=0.605> ;SEMICOLON struct treeNode dataNode[NUMBER_OF_NUMBERS] <sil=0.412> ;SEMICOLON struct treeNode *pSortedTree <sil=0.360> ;SEMICOLON struct treeNode *pNewNode <sil=0.469> ;SEMICOLON /*  End of declarations <sil=0.938> .PERIOD  <sil=0.359> .PERIOD  <sil=0.635> .PERIOD */

/*  Initialise one node for each item of data */
    for (i = 0 <sil=0.569> ;SEMICOLON i < NUMBER_OF_NUMBERS <sil=0.531> ;SEMICOLON i++) {
      dataNode[i] <sil=0.971> .PERIOD pLeft = NULL <sil=0.435> ;SEMICOLON dataNode[i] <sil=0.990> .PERIOD pRight = NULL <sil=0.480> ;SEMICOLON dataNode[i] <sil=0.950> .PERIOD data = toBeSorted[i] <sil=0.469> ;SEMICOLON }

/*  Build a sorted tree out of the data nodes <sil=0.593> ,COMMA printing it */
/*  out after each new node is added to the tree           */
    pSortedTree = NULL <sil=0.553> ;SEMICOLON /* the tree starts as just as a stump */

    for (i = 0 <sil=0.377> ;SEMICOLON i < NUMBER_OF_NUMBERS <sil=0.417> ;SEMICOLON i++) {
      pNewNode = &dataNode[i] <sil=0.366> ;SEMICOLON AddNode(&pSortedTree <sil=0.516> ,COMMA pNewNode) <sil=0.351> ;SEMICOLON printf("\nSorted list of %d items:\n" <sil=0.585> ,COMMA i + 1) <sil=0.518> ;SEMICOLON Dump(pSortedTree) <sil=0.605> ;SEMICOLON }
    exit(EXIT_SUCCESS) <sil=0.571> ;SEMICOLON }

void AddNode(struct treeNode **ppSortedTree <sil=0.538> ,COMMA struct treeNode *pNewNode)
{
    struct treeNode *pCurrentNode <sil=0.428> ;SEMICOLON /*  End of declarations <sil=0.950> .PERIOD  <sil=0.624> .PERIOD  <sil=0.573> .PERIOD */

    pCurrentNode = *ppSortedTree <sil=0.389> ;SEMICOLON /* ppSortedTree is a pointer to a pointer */

/*  Have we reached the end of a branch <sil=0.915> ?QUESTIONMARK */
    if (pCurrentNode == NULL) {
      *ppSortedTree = pNewNode <sil=0.647> ;SEMICOLON } else {
/*    We have not reached the end of a branch */
      if (pCurrentNode->data > pNewNode->data) {
        AddNode(&(pCurrentNode->pRight) <sil=0.319> ,COMMA pNewNode) <sil=0.425> ;SEMICOLON } else {
        AddNode(&(pCurrentNode->pLeft) <sil=0.373> ,COMMA pNewNode) <sil=0.446> ;SEMICOLON }
    }
}

void Dump(struct treeNode *pNode)
{
/*  End of declarations <sil=0.918> .PERIOD  <sil=0.386> .PERIOD  <sil=0.415> .PERIOD */
    if (pNode <sil=0.923> !EXCLAMATIONMARK = NULL) {
      Dump(pNode->pLeft) <sil=0.507> ;SEMICOLON printf("%d\n" <sil=0.321> ,COMMA pNode->data) <sil=0.506> ;SEMICOLON Dump(pNode->pRight) <sil=0.582> ;SEMICOLON }
}

      Programming Challenge 6
      _______________________
      
        Compile and link  "treesort <sil=0.973> .PERIOD c" with the debugger <sil=0.965> .PERIOD Step through and
      experiment with looking at pointers <sil=0.352> ,COMMA and looking at the things they
      point to <sil=0.596> ,COMMA e <sil=0.919> .PERIOD g <sil=0.960> .PERIOD EXAMINE *pNode <sil=0.953> .PERIOD Modify the  program so you  can add
      numbers with a single argument function call <sil=0.950> .PERIOD Sometimes it is useful to know what offset a structure member has from the start of the structure <sil=0.992> .PERIOD There is a useful macro defined in <stddef <sil=0.970> .PERIOD h> called offsetof which will calculate the offset of a structure member from that start of the structure <sil=0.997> .PERIOD byte_offset = offsetof(struct my_struct_s <sil=0.538> ,COMMA thing) <sil=0.380> ;SEMICOLON The first argument to the offsetof macro is a TYPE <sil=0.544> ,COMMA not a variable name <sil=0.963> .PERIOD An example of this is shown in the "key <sil=0.936> .PERIOD c" example program later in the course <sil=0.987> .PERIOD Typedef
The typedef statement lets you define a new name for a pre-existing type <sil=0.937> .PERIOD It doesn't create a new type itself <sil=0.911> .PERIOD An example should make the usage clear <sil=0.970> .PERIOD Imagine you wanted to store coordinates <sil=0.531> ,COMMA and initially you thought they could all fit in a short int <sil=0.985> .PERIOD You might decide to typedef the coordinate declarations like this:


    typedef  short int  Coordinate_t <sil=0.316> ;SEMICOLON  <sil=0.978> .PERIOD Coordinate_t x[MAX_POINTS] <sil=0.495> ,COMMA y[MAX_POINTS] <sil=0.431> ;SEMICOLON  <sil=0.998> .PERIOD Later on it might transpire that increased resolution means that you need more than a short int <sil=0.939> .PERIOD All you need do then is


    typedef  long int  Coordinate_t <sil=0.335> ;SEMICOLON Be careful and sparing in your use of typedef <sil=0.928> .PERIOD Don't use typedef for everything so that no-one can tell the true type of anything <sil=0.925> .PERIOD Some people like to use typedef with structures <sil=0.401> ,COMMA struct coord_s {
      int x <sil=0.420> ;SEMICOLON int y <sil=0.614> ;SEMICOLON } <sil=0.316> ;SEMICOLON typedef  struct coord_s  Coordinate_t <sil=0.590> ;SEMICOLON  <sil=0.910> .PERIOD Coordinate_t points[MAX_POINTS] <sil=0.390> ;SEMICOLON  <sil=0.980> .PERIOD points[i] <sil=0.991> .PERIOD x = 100 <sil=0.549> ;SEMICOLON points[i] <sil=0.900> .PERIOD y =  50 <sil=0.395> ;SEMICOLON  <sil=0.920> .PERIOD whereas others argue that this masks the fact that coordinates are really structures and that it would be clearer to use


    struct  coord_s  points[MAX_POINTS] <sil=0.349> ;SEMICOLON I would suggest that you put all your structure and typedefs in one place <sil=0.424> ,COMMA like in a header file <sil=0.422> ,COMMA and use whatever makes the code uncluttered and easy to follow <sil=0.941> .PERIOD One place where I think typedef does improve clarity is when defining pointers to functions <sil=0.927> .PERIOD typedef int (*verify_cb_func_ptr)( Bodget b <sil=0.416> ,COMMA PxPointer cdata <sil=0.432> ,COMMA PxCBstruct cbs ) <sil=0.628> ;SEMICOLON declares verify_cb_func_ptr as a pointer to a function returning an int <sil=0.470> ,COMMA with 3 arguments of the types shown <sil=0.999> .PERIOD Note that the type returned by the functions themselves is int <sil=0.996> .PERIOD int verify_name( Bodget b <sil=0.546> ,COMMA PxPointer cdata <sil=0.442> ,COMMA PxCBstruct cbs ) <sil=0.348> ;SEMICOLON  <sil=0.959> .PERIOD verify_cb_func_ptr vcb <sil=0.321> ;SEMICOLON  <sil=0.960> .PERIOD vcb = verify_name <sil=0.392> ;SEMICOLON i = (*vcb)( b <sil=0.588> ,COMMA cdata <sil=0.305> ,COMMA cbs) <sil=0.501> ;SEMICOLON /* Note how to call function thru pointer */ <sil=0.916> .PERIOD The brackets around the (*vcb) are needed because the function brackets () take precedence over * <sil=0.966> .PERIOD Header Files
I have cunningly tripled up the HELLO program to demonstrate the use of printf <sil=0.339> ,COMMA which is a "stdio" function <sil=0.377> ,COMMA the for ( <sil=0.515> ;SEMICOLON  <sil=0.547> ;SEMICOLON ) loop <sil=0.322> ,COMMA and the exit(EXIT_SUCCESS) end-your-program function from "stdlib" <sil=0.927> .PERIOD These functions <sil=0.494> ,COMMA or others from these two libraries <sil=0.367> ,COMMA are so commonly used that it is a good idea to always include the <stdio <sil=0.947> .PERIOD h> and <stdlib <sil=0.950> .PERIOD h> ANSI standard header files in all your programs <sil=0.943> .PERIOD Header #include files in C can be specified in two ways:

#include <stdio <sil=0.973> .PERIOD h>

and


#include "myheader <sil=0.974> .PERIOD h"

The quoted "myheader <sil=0.960> .PERIOD h" form starts searching in the same directory as the file from which it is included <sil=0.362> ,COMMA then goes on to search in an implementation defined way <sil=0.997> .PERIOD The angle bracketed <stdio <sil=0.954> .PERIOD h> form follows "an implementation defined search path" <sil=0.959> .PERIOD In practise "implementation defined search path" tends to be the system libraries <sil=0.938> .PERIOD Under VAX C <sil=0.439> ,COMMA all the header files lived as <sil=0.948> .PERIOD h files in SYS$LIBRARY: <sil=0.927> .PERIOD Under DEC C <sil=0.526> ,COMMA they live in text libraries like DECC$RTLDEF <sil=0.995> .PERIOD TLB and SYS$STARLET_C <sil=0.997> .PERIOD TLB <sil=0.991> .PERIOD On Windows using Visual C++ 6 <sil=0.952> .PERIOD 0 they are in C:\Program Files\DevStudio\VC98\Include <sil=0.574> ,COMMA assuming that you installed Visual C++ on to your C: disk <sil=0.974> .PERIOD If you want to know the full search rules for VMS <sil=0.561> ,COMMA type

$ HELP CC LANGUAGE_TOPICS PREPROCESSOR #INCLUDE
You should always use the angle bracket <> form for ANSI header files <sil=0.339> ,COMMA and use the quoted form for your own headers <sil=0.349> ,COMMA e <sil=1.000> .PERIOD g <sil=0.941> .PERIOD #include "src$par:trntyp <sil=0.956> .PERIOD h"

The # symbol is known as the preprocessor operator <sil=0.965> .PERIOD When you perform a C compilation <sil=0.530> ,COMMA the first stage it goes through is preprocessing <sil=0.578> ,COMMA where all the # directives are obeyed <sil=0.357> ,COMMA and various inclusions and substitutions are made before the code is compiled <sil=0.975> .PERIOD The # sign must always be the first non-whitespace character on the line <sil=0.582> ,COMMA and is one of the few exceptions to the general free format of C code <sil=0.948> .PERIOD You can have spaces after the # <sil=0.455> ,COMMA and these are often useful when using #if constructs <sil=0.964> .PERIOD Another common preprocessor directive is #define <sil=0.905> .PERIOD This can be used to define "parameters" which you might want to use as array bounds for example <sil=0.357> ,COMMA but in addition it lets you define macros which take arguments and produce inline code using the arguments <sil=0.994> .PERIOD For example <sil=0.567> ,COMMA /* Some defines and macro definitions */
#define PI          3 <sil=0.911> .PERIOD 14159265358979
#define MAX(a <sil=0.576> ,COMMA b) (((a)>(b)) <sil=0.886> ?QUESTIONMARK (a):(b))
#define STRING_SIZE 16 <sil=0.944> .PERIOD  <sil=0.959> .PERIOD {
    char string[STRING_SIZE] <sil=0.424> ;SEMICOLON /* Using a #define'd array bound */ <sil=0.940> .PERIOD }

Notice that there are no semicolons at the end of the #define lines <sil=0.955> .PERIOD Leading and trailing blanks before the "token sequence" (the body of the macro or definition) are discarded <sil=0.613> ,COMMA although you can use \ at the end of a line to indicate that there is more of the macro on the next line <sil=0.996> .PERIOD In the second form of macro shown above <sil=0.355> ,COMMA you cannot have a space between the identifier <sil=0.462> ,COMMA MAX <sil=0.468> ,COMMA and the first "(" <sil=0.599> ,COMMA or the preprocessor will not know that the () delimit the parameter list for the macro expansion <sil=0.961> .PERIOD Also notice that (if you are a beginner) you haven't got a clue what is going on with that MAX macro <sil=0.899> !EXCLAMATIONMARK The #if <sil=0.486> ,COMMA #else <sil=0.404> ,COMMA #elif and #endif conditional preprocessor directives are used to include code selectively during preprocessing <sil=0.979> .PERIOD They can be used to test if a particular macro name has been defined (even as an empty string) <sil=0.944> .PERIOD A common use for this is stopping the same header file contents being included more than once <sil=0.988> .PERIOD For example <sil=0.398> ,COMMA imagine you had created a header file called "utils <sil=0.912> .PERIOD h" <sil=0.947> .PERIOD /*---- My header file for my util routines <sil=0.536> ,COMMA called "tla_utils <sil=0.981> .PERIOD h" -------------*/
#if <sil=0.886> !EXCLAMATIONMARK defined( TLA_UTILS_H )   /* Could have used #ifndef TLA_UTILS_H */
#define TLA_UTILS_H <sil=0.939> .PERIOD #if defined( __VMS )          /* Could have used #ifdef __VMS */
# include "vms_specific_stuff <sil=0.916> .PERIOD h"
#elif defined( UNIX )
# include "inferior_unix_alternative <sil=0.937> .PERIOD h"
#else
# include "oh_dear_it_must_be_dos <sil=0.945> .PERIOD h"
#endif <sil=0.954> .PERIOD /*  Do some stuff that should only be done once */ <sil=0.918> .PERIOD #ifndef DEFINE_GLOBALS
# define EXT extern
#endif <sil=0.915> .PERIOD #define MY_PROGRAM_ARRAY_LIMIT 100 <sil=0.988> .PERIOD EXT int   tla_global_int <sil=0.398> ;SEMICOLON  <sil=0.961> .PERIOD EXT const float tla_global_pi
#ifdef DEFINE_GLOBALS
 = 3 <sil=0.991> .PERIOD 14159265358979
#endif <sil=0.487> ;SEMICOLON  <sil=0.938> .PERIOD EXT char  tla_title_string[]
#ifdef DEFINE_GLOBALS
 = "Program Title"
#endif <sil=0.601> ;SEMICOLON  <sil=0.925> .PERIOD int MyFunction( int meaningful_name ) <sil=0.378> ;SEMICOLON /* This is not a function definition  */
                                        /* it is a "function prototype" which */
                                        /* allows arg and return val checking */ <sil=0.932> .PERIOD #endif  /* End of TLA_UTILS_H block */

This technique is widely used to enable selection of the correct code at compile time <sil=0.911> .PERIOD Try

$ HELP CC  Language_topics  Predefined_Macros  System_Identification_Macros
which will give you some of the predefined (by the compiler) macros that let you switch code on and off depending on <sil=0.469> ,COMMA say <sil=0.423> ,COMMA whether you are on a VAX or Alpha <sil=0.963> .PERIOD See K&R II pages 91 and 232 for more information on this subject <sil=0.917> .PERIOD The definition of the EXT macro is another useful technique for ensuring that you only DEFINE a variable once (ie <sil=0.949> .PERIOD actually allocate space for <sil=0.527> ,COMMA or initialize a variable with a value) <sil=0.908> .PERIOD Macros are explained in more detail below <sil=0.583> ,COMMA but basically the text (if any) associated with the macro name is substituted wherever the macro appears <sil=0.336> ,COMMA before compilation proper begins <sil=0.943> .PERIOD In your main program <sil=0.331> ,COMMA you #define DEFINE_GLOBALS and the header file then becomes <sil=0.993> .PERIOD int tla_global_int <sil=0.353> ;SEMICOLON  <sil=0.994> .PERIOD const float tla_global_pi = 3 <sil=0.987> .PERIOD 14159265358979 <sil=0.635> ;SEMICOLON  <sil=0.975> .PERIOD whereas any files of subroutines which don't #define DEFINE_GLOBALS will process the same header fragment as <sil=0.981> .PERIOD extern int tla_global_int <sil=0.541> ;SEMICOLON  <sil=0.946> .PERIOD extern const float tla_global_pi <sil=0.376> ;SEMICOLON  <sil=0.970> .PERIOD so the values are resolved at link time <sil=0.316> ,COMMA and won't be contradictory to the main program <sil=0.997> .PERIOD This technique saves having to have two versions of your header files (which inevitably get out of step) <sil=0.978> .PERIOD Macros and the <sil=0.993> ?QUESTIONMARK operator
Macros are preprocessed by the C preprocessor <sil=0.549> ,COMMA and the text of the macro <sil=0.457> ,COMMA along with any parameters <sil=0.550> ,COMMA are substituted for the macro itself <sil=0.924> .PERIOD Hence if you invoked the MAX macro shown previously <sil=0.439> ,COMMA the preprocessor would change the invocation

#define MAX(a <sil=0.531> ,COMMA b) (((a)>(b)) <sil=0.896> ?QUESTIONMARK (a):(b)) <sil=0.902> .PERIOD maxval = MAX( maxval <sil=0.452> ,COMMA this) <sil=0.420> ;SEMICOLON  <sil=0.927> .PERIOD to this before the compiler proper ever saw it:


       maxval = (((maxval)>(this)) <sil=0.852> ?QUESTIONMARK (maxval):(this)) <sil=0.593> ;SEMICOLON Removing some of the "guard brackets" you get this slightly more readable version


       maxval = (maxval > this) <sil=0.863> ?QUESTIONMARK maxval : this <sil=0.559> ;SEMICOLON The brackets around the parameters in the expansion are necessary to keep the meaning correct if <sil=0.311> ,COMMA say <sil=0.366> ,COMMA one of the arguments is a function call <sil=0.337> ,COMMA or complex expression <sil=0.914> .PERIOD Sometimes it is advisable to create a temporary variable to avoid "using" the parameters more than once <sil=0.490> ,COMMA and this will be explained later <sil=0.939> .PERIOD See page 229 - 231 of K&R II for a fuller explanation of defining macros <sil=0.905> .PERIOD Convention dictates that macros should be totally uppercase <sil=0.903> .PERIOD This is certainly the style used in the ANSI header files <sil=0.532> ,COMMA and it is generally best to make all your macros uppercase <sil=0.952> .PERIOD The <sil=0.953> ?QUESTIONMARK operator is a ternary operator <sil=0.590> ,COMMA i <sil=0.349> .PERIOD e <sil=0.398> .PERIOD it takes three operands <sil=0.942> .PERIOD It should be used sparingly <sil=0.635> ,COMMA and is a shorthand as illustrated below:

   value = (expression_1) <sil=0.896> ?QUESTIONMARK expression_2 : expression_3 <sil=0.592> ;SEMICOLON is (more or less) equivalent to

   if ( expression_1 ) {
     value = expression_2 <sil=0.309> ;SEMICOLON } else {
     value = expression_3 <sil=0.585> ;SEMICOLON } <sil=0.423> ;SEMICOLON The reason it is handy in macros is that it is best to avoid multiple <sil=0.579> ;SEMICOLON separated statements in a macro <sil=0.591> ,COMMA because that could well change the meaning of code <sil=0.976> .PERIOD Macros tend to be invoked on the assumption that they are a single statement and code meaning could change if they weren't <sil=0.405> ,COMMA e <sil=0.939> .PERIOD g <sil=0.926> .PERIOD if ( condition ) INVOKE_MACRO( bob ) <sil=0.632> ;SEMICOLON  <sil=0.492> .PERIOD By using the <sil=0.963> ?QUESTIONMARK operator you can get a single statement that still has some switching logic in it <sil=0.951> .PERIOD There is a trick to get round the single statement restriction <sil=0.376> ,COMMA and still behave nicely:


#define MULTI_STATEMENT_MACRO( arg )   do { \
                                           first_thing <sil=0.437> ;SEMICOLON \ <sil=0.906> .PERIOD last_thing <sil=0.412> ;SEMICOLON \
                                       } while (0)  /* DONT put a <sil=0.376> ;SEMICOLON at end <sil=0.913> !EXCLAMATIONMARK */

In C <sil=0.398> ,COMMA an expression is TRUE if it is ANY nonzero value <sil=0.614> ,COMMA or in the case of pointers <sil=0.573> ,COMMA if it doesn't compare equal to NULL <sil=0.972> .PERIOD The results of logical comparisons or other built-in operators is guaranteed to be 0 or 1 <sil=0.488> ,COMMA so


   i = ( 2 > 1) <sil=0.433> ;SEMICOLON /* Sets i to be 1 */
   i = ( 1 > 2) <sil=0.594> ;SEMICOLON /* Sets i to be 0 */

So <sil=0.339> ,COMMA in our MAX example ((a)>(b)) will be 1 <sil=0.403> ,COMMA i <sil=0.481> .PERIOD e <sil=0.333> .PERIOD TRUE <sil=0.520> ,COMMA if a is greater than b <sil=0.454> ,COMMA 0 otherwise <sil=0.937> .PERIOD So "expression_1" is TRUE if a > b <sil=0.942> .PERIOD Hence the value of "expression_2" i <sil=0.970> .PERIOD e <sil=0.479> .PERIOD a will be chosen <sil=0.936> .PERIOD Otherwise "expression_3" <sil=0.501> ,COMMA in this case b will be used <sil=0.963> .PERIOD "Why define MAX as a macro at all <sil=0.928> ?QUESTIONMARK " you might ask (pause until someone asks) <sil=0.981> .PERIOD Well the reason is that if you used a function <sil=0.493> ,COMMA you would need to write a version for floating point numbers <sil=0.532> ,COMMA another for ints <sil=0.453> ,COMMA another for long ints and so on <sil=0.978> .PERIOD Of course <sil=0.546> ,COMMA a macro can circumvent type checking <sil=0.570> ,COMMA which some people don't like very much <sil=0.370> ,COMMA so in C++ macros have been effectively eliminated for most purposes by "templates" which you can learn about in my STL Course <sil=0.967> .PERIOD When using the #if test mentioned in the "Header Files" section <sil=0.328> ,COMMA you can use relational tests on constant expressions <sil=0.990> .PERIOD Here is an example of checking that you are using Motif 1 <sil=0.906> .PERIOD 2 or greater


#if (XmVERSION >= 1 && XmREVISION > 1)
    XtSetArg( argl[narg] <sil=0.312> ,COMMA XmNtearOffModel <sil=0.414> ,COMMA XmTEAR_OFF_ENABLED ) <sil=0.605> ;SEMICOLON narg++ <sil=0.405> ;SEMICOLON #endif

The expression following the #if must either use the preprocessing operator defined(identifier) (which returns 1 if identifier has been #defined <sil=0.594> ,COMMA else 0) or be a constant expression <sil=0.936> .PERIOD This can be handy for defining a number of levels of debugging information <sil=0.917> .PERIOD The #if is also the safest way to "comment out" unused code <sil=0.338> ,COMMA rather than messing about making sure you haven't illegally nested comments <sil=0.995> .PERIOD For example:


#ifdef NEW_CODE_IS_RELIABLE
/*   New code that should be faster but hasn't been tested as much as the old */ <sil=0.916> .PERIOD #else
/*   Here is the old code that worked - don't want to remove it yet */ <sil=0.976> .PERIOD #endif

Clearly the first #if test will always fail in our lifetime because the macro will never be defined <sil=0.449> ,COMMA so the old code will not be compiled <sil=0.956> .PERIOD This technique avoids problems caused by inadvertent comment nesting <sil=0.921> .PERIOD Macros can be undefined using the #undef directive <sil=0.964> .PERIOD #define DEBUG 1 <sil=0.909> .PERIOD #ifdef DEBUG
    printf("The value of x is %d in routine Funcy\n" <sil=0.485> ,COMMA x) <sil=0.480> ;SEMICOLON /* Print out debug msg*/
#endif <sil=0.917> .PERIOD #undef DEBUG <sil=0.938> .PERIOD #ifdef DEBUG
    printf("The value of x is %d in routine Gibbon\n" <sil=0.458> ,COMMA x) <sil=0.529> ;SEMICOLON /* Not printed */
#endif <sil=0.983> .PERIOD You will need to #undef a macro if you want to use it again <sil=0.916> .PERIOD Complete redefinitions aren't allowed <sil=0.951> .PERIOD You can <sil=0.376> ,COMMA however <sil=0.996> ,COMMA define a macro more than once provided the tokens it expands to are the same <sil=0.639> ,COMMA ignoring whitespace <sil=0.911> .PERIOD This is known as a "benevolent redefinition" and is often used to get identical definitions of the NULL macro in several header files <sil=0.957> .PERIOD Avoid starting your macro names with _ and in particular __ because underbars are reserved for the implementations <sil=0.457> ,COMMA and double underbars are use for macros predefined by the standard <sil=0.999> .PERIOD For example <sil=0.588> ,COMMA the standard reserves __LINE__ <sil=0.398> ,COMMA __FILE__ <sil=0.631> ,COMMA __DATE__ <sil=0.636> ,COMMA __TIME__ and __STDC__ <sil=0.931> .PERIOD Look in K&R II page 233 for the meanings of these <sil=0.910> .PERIOD Occasionally it is useful to be able to use the macro arguments as strings <sil=0.999> .PERIOD This is done by using the # directly in front of the argument <sil=0.960> .PERIOD #define DEBUG_PRINT_INT( x ) (printf("int variable "#x" is %d" <sil=0.404> ,COMMA x))

#ifdef DEBUG
    DEBUG_PRINT_INT( i ) <sil=0.372> ;SEMICOLON /* Prints "int variable i is 10" or whatever */
#endif

Concatenation of macro arguments is also possible using the ## directive <sil=0.956> .PERIOD Some people like commas in big numbers <sil=0.461> ,COMMA so you might use it like this:


#define NICKS_MEGA_INT(a <sil=0.638> ,COMMA b <sil=0.632> ,COMMA c) a##b##c <sil=0.950> .PERIOD int i <sil=0.594> ;SEMICOLON  <sil=0.993> .PERIOD i = NICKS_MEGA_INT( 10 <sil=0.616> ,COMMA 000 <sil=0.466> ,COMMA 000 ) <sil=0.424> ;SEMICOLON /* same as 10000000 after expansion */ <sil=0.925> .PERIOD Then again <sil=0.499> ,COMMA you might not <sil=0.921> .PERIOD As a final thought for this section <sil=0.501> ,COMMA I will demonstrate a couple of benign uses for the <sil=0.906> ?QUESTIONMARK operator - it's not just there for the nasty things in life <sil=0.967> .PERIOD got_space = GetSpace(how_much) <sil=0.366> ;SEMICOLON /* Returns NULL if it fails */
    printf( got_space <sil=0.882> ?QUESTIONMARK "Success\n" : "Failure\n") <sil=0.452> ;SEMICOLON  <sil=0.967> .PERIOD /*  Avoid ACCVIO if pointer is NULL */
    printf( "Name is %s\n" <sil=0.353> ,COMMA name_ptr[i] <sil=0.923> ?QUESTIONMARK name_ptr[i] : "**Unknown**" ) <sil=0.612> ;SEMICOLON  <sil=0.918> .PERIOD /*  Handle plurals */
    printf( "Found %d item%s\n" <sil=0.409> ,COMMA nitems <sil=0.592> ,COMMA (nitems <sil=0.916> !EXCLAMATIONMARK = 1) <sil=0.854> ?QUESTIONMARK "s" : "" ) <sil=0.450> ;SEMICOLON The ACCVIO avoidance works because the expression that is NOT selected is guaranteed to be "thrown away" <sil=0.394> ,COMMA so the NULL pointer is never dereferenced

Finally <sil=0.602> ,COMMA remember my mentioning that it was a good idea to only reference macro arguments once if the macro was to be used like a function <sil=0.973> ?QUESTIONMARK The X Toolkit Intrinsics macro <sil=0.542> ,COMMA XtSetArg <sil=0.332> ,COMMA doesn't follow this sound advice <sil=0.985> .PERIOD It is defined like this:


#define XtSetArg(arg <sil=0.374> ,COMMA n <sil=0.487> ,COMMA d) \
    ((void)( (arg) <sil=0.943> .PERIOD name = (n) <sil=0.433> ,COMMA (arg) <sil=0.909> .PERIOD value = (XtArgVal)(d) ))

Notice that (arg) is referenced twice <sil=0.375> ,COMMA but only appears once in the macro argument list <sil=0.960> .PERIOD Hence the intuitive usage


    XtSetArg( argl[narg++] <sil=0.406> ,COMMA XmNtearOffModel <sil=0.450> ,COMMA XmTEAR_OFF_ENABLED ) <sil=0.390> ;SEMICOLON actually increments narg by two <sil=0.380> ,COMMA not one <sil=0.973> .PERIOD It therefore has to be used something like this


    XtSetArg( argl[narg] <sil=0.503> ,COMMA XmNtearOffModel <sil=0.488> ,COMMA XmTEAR_OFF_ENABLED ) <sil=0.605> ;SEMICOLON narg++ <sil=0.344> ;SEMICOLON If they had defined it like this


#define XtSetArg(arg <sil=0.459> ,COMMA n <sil=0.392> ,COMMA d) \
    do { Arg *_targ = &(arg) <sil=0.617> ;SEMICOLON \
        ( (void)( _targ->name = (n) <sil=0.362> ,COMMA _targ->value = (XtArgVal)(d) ) <sil=0.350> ;SEMICOLON ) \
    } while (0)

you would be able to use the argl[narg++] form <sil=0.970> .PERIOD This is something to be aware of if your pre or post decrements seem to be behaving strangely <sil=0.947> .PERIOD Obviously <sil=0.474> ,COMMA you should not actually redefine standard macros <sil=0.597> ,COMMA because this can lead to even more confusion <sil=0.956> .PERIOD Create your own version <sil=0.407> ,COMMA like SETARG if you feel the need <sil=0.970> .PERIOD Logical and Relational Operators
At this point I will gratuitously introduce the relational operators <sil=0.941> .PERIOD C        Means                      Fortran

      >    -  Greater than                ( <sil=0.980> .PERIOD GT <sil=0.976> .PERIOD )     -
      >=   -  Greater than or equal to    ( <sil=0.998> .PERIOD GE <sil=0.923> .PERIOD )      | Same precedence
      <    -  Less than                   ( <sil=0.914> .PERIOD LT <sil=0.901> .PERIOD )      | as each other <sil=0.477> ,COMMA <=   -  Less than or equal to       ( <sil=0.916> .PERIOD LE <sil=0.903> .PERIOD )     -  below */+-

      ==   -  Equal                       ( <sil=0.920> .PERIOD EQ <sil=0.932> .PERIOD )     -  Same as each
                                                        | other <sil=0.483> ,COMMA just <sil=0.928> !EXCLAMATIONMARK =   -  Not equal                   ( <sil=0.934> .PERIOD NE <sil=0.970> .PERIOD )     -  below < etc <sil=0.946> .PERIOD They are left to right associative <sil=0.454> ,COMMA and represent sequence points by which side effects of expressions must be complete <sil=0.907> .PERIOD E <sil=0.936> .PERIOD g <sil=0.994> .PERIOD if ( x*3 > y ) { <sil=0.900> .PERIOD }

guarantees that x will have been multiplied by three before comparison with y <sil=0.959> .PERIOD A word of caution about the equality operator <sil=0.505> ,COMMA == <sil=0.919> .PERIOD It is very easy to miss out the second = and this will still be a legal expression <sil=0.998> .PERIOD Example:


    if ( x = 3*12 ) { <sil=0.958> .PERIOD }

will always be true <sil=0.984> .PERIOD This is because <sil=0.438> ,COMMA in C <sil=0.363> ,COMMA expressions have a value <sil=0.312> ,COMMA propagated right-to-left <sil=0.907> .PERIOD So the value of ( x = 3 ) <sil=0.450> ,COMMA which calculates the right-hand side <sil=0.515> ,COMMA 36 <sil=0.597> ,COMMA and assigns it to x <sil=0.340> ,COMMA is 36 <sil=0.475> ,COMMA which is nonzero and hence always true <sil=0.924> .PERIOD So that mistake will cause the if {} body to be always executed <sil=0.319> ,COMMA and worse than that you will have unknowingly changed the value of x <sil=0.915> .PERIOD To avoid this <sil=0.300> ,COMMA some people like to write the test the other way round <sil=0.606> ,COMMA e <sil=0.949> .PERIOD g <sil=0.979> .PERIOD if ( 3*12 == x ) { <sil=0.978> .PERIOD }

Now <sil=0.564> ,COMMA if you miss of the second = you have an illegal expressions because you cannot assign 3*12 = x <sil=0.517> ,COMMA because 3*12 is not an lvalue (a modifiable location or symbol <sil=0.346> ,COMMA which can be on the left-hand side of the = sign in an expression) <sil=0.953> .PERIOD The logical operators are (in decreasing precedence)


      C        Means                      Fortran

      &&   -  Logical AND                ( <sil=0.955> .PERIOD AND <sil=0.915> .PERIOD )  

      ||   -  Logical OR                 ( <sil=0.992> .PERIOD OR <sil=0.934> .PERIOD )  

and are below the relational operators in precedence <sil=0.901> .PERIOD Hence the expression


    if ( j > 0 && i*3 > 12  ||  i <sil=0.916> !EXCLAMATIONMARK = k ) <sil=0.904> .PERIOD  <sil=0.547> .PERIOD  <sil=0.432> .PERIOD is the same as


    if (    (  ( j > 0 )  &&  ( (i*3) > 12 )  )    ||    ( i <sil=0.938> !EXCLAMATIONMARK = k )  ) <sil=0.945> .PERIOD  <sil=0.370> .PERIOD  <sil=0.527> .PERIOD See K&R II page 52 for operator precedence <sil=0.938> .PERIOD Most people don't remember these <sil=0.340> ,COMMA but use brackets to make the meaning of more complex expressions quite clear <sil=0.986> .PERIOD The <sil=0.935> !EXCLAMATIONMARK as a unary operator is similar to Fortran <sil=0.964> .PERIOD NOT <sil=0.912> .PERIOD  <sil=0.605> ,COMMA so ( <sil=0.959> !EXCLAMATIONMARK x ) is true if x is equal to zero <sil=0.942> .PERIOD Bitwise Operators
There are 6 bit manipulation operators in C <sil=0.404> ,COMMA which can only be used with integers (signed or unsigned) <sil=0.922> .PERIOD These operators are

      << - Left shift <sil=0.440> ,COMMA bring in zero bits on right <sil=0.967> .PERIOD >> - Right shift <sil=0.920> .PERIOD Bring in 0s on left for unsigned integers <sil=0.529> ,COMMA implementation defined for signed integers <sil=0.983> .PERIOD ~  - One's complement <sil=0.905> .PERIOD Unary operator <sil=0.618> ,COMMA changes 0s to 1 <sil=0.551> ,COMMA 1's to 0 
      &  - Bitwise AND <sil=0.634> ,COMMA do not confuse with relational &&
      |  - Bitwise INclusive OR <sil=0.459> ,COMMA do not confuse with relational ||
      ^  - Bitwise EXclusive OR

Here are some examples:


    i = i << 2 <sil=0.493> ;SEMICOLON /* Multiply by 4 */
    i <<= 2 <sil=0.377> ;SEMICOLON /* Same as above */

    mask |= MSK_RW <sil=0.438> ;SEMICOLON /* Set the bits in mask that are set in MSK_RW */

    valuemask = GCForeground|GCBackground <sil=0.434> ;SEMICOLON /* Set the bits that are the OR of */
                                           /* GCForeground and GCBackground   */

    mask = ~opposite <sil=0.625> ;SEMICOLON /* mask is complementary bit pattern to opposite */

    mask |= 1UL << MSK_R_V <sil=0.527> ;SEMICOLON /* Shift unsigned long 1 left MSK_R_V bits */
                            /* and set that bit in mask                */

These are very useful for setting and unsetting flag bits <sil=0.379> ,COMMA but you must be aware of the size of object that you are dealing with <sil=0.984> .PERIOD By their very nature <sil=0.458> ,COMMA bitwise operators can make code more unportable <sil=0.961> .PERIOD Programming Challenge 7
      _______________________
      
        Use the bitwise  operators  to  determine  what your machine  does
      with  a  right   shift   of  a  negative  integer <sil=0.968> .PERIOD Write  some  bit
      manipulation and checking  functions <sil=0.963> .PERIOD Check  the  priority  of  the
      bitwise  operators and see  how this affects the  bracketing of your
      tests and expressions <sil=0.994> .PERIOD Function Prototypes
Here is an example program to determine whether signed char or unsigned char is the default on your machine <sil=0.934> .PERIOD This example introduces function prototypes <sil=0.982> .PERIOD These are very useful <sil=0.548> ,COMMA and whenever you write a set of functions you should ALWAYS create a <sil=0.994> .PERIOD h (header) file with the prototypes for those functions <sil=0.979> .PERIOD The reason prototypes are so useful is that they allow the compiler to check that you are calling a function with the right number of arguments <sil=0.557> ,COMMA and that the arguments themselves are of the correct type <sil=0.923> .PERIOD You should NEVER ignore warnings about argument numbers or types <sil=0.454> ,COMMA and you should only cast (see later <sil=0.492> ,COMMA but briefly <sil=0.502> ,COMMA the "cast" (float)3 is like the Fortran FLOAT(3) ) if you are absolutely sure what you are doing <sil=0.958> !EXCLAMATIONMARK Notice that the function prototype (for power in this example) is exactly the same as the function header <sil=0.368> ,COMMA but with a <sil=0.620> ;SEMICOLON where the body of the function would go <sil=0.954> .PERIOD The arguments named in the prototype are optional <sil=0.562> ,COMMA so we could have declared "int power( int <sil=0.603> ,COMMA int ) <sil=0.367> ;SEMICOLON " <sil=0.965> .PERIOD Don't ever do this <sil=0.914> .PERIOD Give the arguments either the same names as those in the function definition <sil=0.482> ,COMMA or maybe a more verbose name <sil=0.599> ,COMMA so that someone looking at your header file with your function prototypes can easily work out how they are meant to be called <sil=0.950> .PERIOD /*---- To sign or not to sign <sil=0.613> ,COMMA that is the example ("charsign <sil=0.935> .PERIOD c") ------------*/

/* ANSI C Headers */
#include <limits <sil=0.925> .PERIOD h>
#include <stdio <sil=0.988> .PERIOD h>
#include <stdlib <sil=0.924> .PERIOD h>

/* Function prototypes */
int power( int base <sil=0.349> ,COMMA int n ) <sil=0.639> ;SEMICOLON /* Main Program starts here */
int main( int argc <sil=0.554> ,COMMA char *argv[] )
{
    char c <sil=0.469> ;SEMICOLON unsigned char uc <sil=0.314> ;SEMICOLON /*  End of declarations <sil=0.919> .PERIOD  <sil=0.423> .PERIOD  <sil=0.418> .PERIOD */

/*  Set the top bit of both characters */
    c = power( 2 <sil=0.400> ,COMMA (CHAR_BIT-1) ) <sil=0.467> ;SEMICOLON uc = power( 2 <sil=0.513> ,COMMA (CHAR_BIT-1) ) <sil=0.457> ;SEMICOLON /*  Shift them both right by one bit <sil=0.604> ,COMMA >> is the right shift operator */
    c >>= 1 <sil=0.364> ;SEMICOLON uc >>= 1 <sil=0.382> ;SEMICOLON /*  Check for equality - check out the <sil=0.950> ?QUESTIONMARK ternary operator <sil=0.947> !EXCLAMATIONMARK */
    printf("Your computer has %ssigned char <sil=0.936> .PERIOD \n" <sil=0.303> ,COMMA ( c == uc ) <sil=0.945> ?QUESTIONMARK "un" : "" ) <sil=0.454> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.482> ;SEMICOLON }

/*---- Function to raise integer to a power <sil=0.410> ,COMMA nicked from K&R II <sil=0.450> ,COMMA page 25 -----*/
int power( int base <sil=0.518> ,COMMA int n )
{
    int i <sil=0.312> ,COMMA p <sil=0.503> ;SEMICOLON /*  End of declarations <sil=0.901> .PERIOD  <sil=0.509> .PERIOD  <sil=0.364> .PERIOD */
    p = 1 <sil=0.493> ;SEMICOLON for ( i = 1 <sil=0.380> ;SEMICOLON i <= n <sil=0.608> ;SEMICOLON i++) {
      p = p * base <sil=0.385> ;SEMICOLON }
    return( p ) <sil=0.459> ;SEMICOLON }

In this example <sil=0.414> ,COMMA power is a function that returns an int <sil=0.902> .PERIOD You can return any type except an array <sil=0.916> .PERIOD However <sil=0.489> ,COMMA you can return structures (which might contain an array) <sil=0.903> .PERIOD Similarly <sil=0.480> ,COMMA you can pass structures as arguments <sil=0.913> .PERIOD In general <sil=0.588> ,COMMA it is best to avoid passing or returning structures <sil=0.638> ,COMMA because there may be extra overhead due to structures being larger than machine registers <sil=0.632> ,COMMA hence they are often passed on the stack <sil=0.959> .PERIOD Return or pass a pointer instead <sil=0.998> .PERIOD DON'T return a pointer to a function-local <sil=0.647> ,COMMA automatic object <sil=0.919> !EXCLAMATIONMARK Either make the user pass you a maximum size and some memory into which you can write your structure/array <sil=0.499> ,COMMA or malloc() it and return that <sil=0.907> .PERIOD In the latter case you should document somewhere that it is up to the user to free() the memory when they are done with it <sil=0.925> .PERIOD If your function doesn't actually return a value <sil=0.356> ,COMMA like a Fortran SUBROUTINE <sil=0.345> ,COMMA it is declared as void <sil=0.942> .PERIOD The void keyword is also used to indicate that a function takes no arguments <sil=0.528> ,COMMA for example:


    void initialize_something(void) <sil=0.494> ;SEMICOLON would be used like this

    initialize_something() <sil=0.487> ;SEMICOLON The brackets are necessary <sil=0.323> ,COMMA even though there are no arguments <sil=0.343> ,COMMA so the compiler can tell that you intend to call a function <sil=0.962> .PERIOD Programming Challenge 8
      _______________________
      
        Hack the "charsign <sil=0.988> .PERIOD c" example to  try  and call power()  with  the
      wrong type of  argument (you might  declare a float variable and use
      that) <sil=0.985> .PERIOD See what  compiler message you  get <sil=0.911> .PERIOD Call it with  the  wrong
      number of  arguments (but  leave the prototype  unchanged) <sil=0.935> .PERIOD Create a
      new function <sil=0.601> ,COMMA powerf() that lets you raise a floating  point number
      to  any  power <sil=0.994> .PERIOD Try  HELP  CC  RUN-TIME_FUNCTIONS LOG  and  HELP  CC
      RUN-TIME_FUNCTIONS  EXP  for  clues <sil=0.971> .PERIOD The  print  format  conversion
      character  for a floating point  number  in printf  is "%f" <sil=0.992> .PERIOD Compile
      your program and wonder why you get the error
      
        %CC-I-IMPLICITFUNC <sil=0.314> ,COMMA In  this statement <sil=0.365> ,COMMA the  identifier "exp"  is
      implicitly declared as a function <sil=0.989> .PERIOD Remember  that when  you typed HELP CC  RUN-TIME_FUNCTIONS EXP  it
      told you to stick "#include <math <sil=0.940> .PERIOD h>" in your program <sil=0.956> .PERIOD Put it in and
      the error  should  go  away <sil=0.953> .PERIOD If  you  chose  to  make your  function
      something like
      

        float powerf( float base <sil=0.302> ,COMMA float exp) <sil=0.449> ;SEMICOLON Think about the fact that exp() didn't whinge when you passed it a
      float <sil=0.981> .PERIOD This is because when arguments are passed (by value always in
      C) <sil=0.394> ,COMMA they are (if possible) converted <sil=0.320> ,COMMA AS IF  BY  ASSIGNMENT <sil=0.321> ,COMMA to the
      type specified in the function prototype <sil=0.967> .PERIOD The order of evaluation of
      arguments is unspecified <sil=0.383> ,COMMA so never rely on it <sil=0.984> .PERIOD See K&R II  pages  45
      and 201-202 for a  detailed description  of this behaviour <sil=0.986> .PERIOD Finally
      when you have your powerf function  working <sil=0.547> ,COMMA think what  a git I am
      for not mentioning the "double pow(double base <sil=0.431> ,COMMA double exp) <sil=0.619> ;SEMICOLON "  which
      also exists in <math <sil=0.929> .PERIOD h> <sil=0.940> .PERIOD Casting (without the couch)
It is possible <sil=0.478> ,COMMA as mentioned earlier <sil=0.366> ,COMMA to call a function or perform an assignment to "the wrong type" <sil=0.966> .PERIOD This is called casting <sil=0.414> ,COMMA and the general form is
    (type_I_want_to_cast_to) expression_I_want_to_cast
For example

    int index <sil=0.543> ;SEMICOLON float realval <sil=0.538> ;SEMICOLON index = (int)realval <sil=0.530> ;SEMICOLON Because <sil=0.453> ,COMMA as explained in the example <sil=0.526> ,COMMA this is done by default when calling functions for which good prototypes have been declared <sil=0.376> ,COMMA it is generally only useful if calling older style "Classic C" functions where the arguments types have not been declared <sil=0.993> .PERIOD E <sil=0.991> .PERIOD g <sil=0.984> .PERIOD float funcy() <sil=0.560> ;SEMICOLON /* We know that this actually takes a double argument */ <sil=0.922> .PERIOD float f <sil=0.576> ;SEMICOLON  <sil=0.976> .PERIOD f = funcy( 100 ) <sil=0.496> ;SEMICOLON /* Unpredictable result */
    f = funcy( (double)100 ) <sil=0.468> ;SEMICOLON /* f is 10 <sil=0.908> .PERIOD 0 */

Declarations can be quite complicated <sil=0.362> ,COMMA and you should read and understand K&R II <sil=0.620> ,COMMA pages 122 to 126 <sil=0.951> .PERIOD There is a very good set of rules and a diagram for parsing declarations in "Expert C Programming" <sil=0.589> ,COMMA pages 75 to 78 <sil=0.424> ,COMMA and I strongly recommend everyone to read this <sil=0.909> .PERIOD Try to avoid casting <sil=0.627> ,COMMA except in the circumstances defined above <sil=0.491> ,COMMA and possibly when using the RTL function malloc() <sil=0.936> .PERIOD File IO Routines and Command Line Arguments
When your C program starts up <sil=0.404> ,COMMA it automatically creates three file streams for you <sil=0.978> .PERIOD These are known as stdin <sil=0.528> ,COMMA stdout and stderr <sil=0.416> ,COMMA which are usually the keyboard <sil=0.623> ,COMMA the terminal and the terminal again respectively <sil=0.960> .PERIOD If you have included <stdio <sil=0.940> .PERIOD h> (which you should have) the symbols stdin <sil=0.541> ,COMMA stdout and stderr are available for your use <sil=0.967> .PERIOD The functions from <stdio <sil=0.948> .PERIOD h> that have seen so far <sil=0.302> ,COMMA like printf <sil=0.629> ,COMMA write to stdout <sil=0.990> .PERIOD Others <sil=0.357> ,COMMA like scanf <sil=0.580> ,COMMA read from stdin <sil=0.944> .PERIOD Here is an example of using scanf to read keyboard input <sil=0.995> .PERIOD /*---- Keyboard Input C Example ("input <sil=0.902> .PERIOD c") ----------------------------------*/

/* ANSI C Headers */
#include <stdio <sil=0.922> .PERIOD h>
#include <stdlib <sil=0.966> .PERIOD h>

/* Main Program starts here */
int main( int argc <sil=0.415> ,COMMA char *argv[] )
{
    int i <sil=0.361> ;SEMICOLON float f <sil=0.554> ;SEMICOLON char string[80] <sil=0.545> ;SEMICOLON /*  End of declarations <sil=0.920> .PERIOD  <sil=0.604> .PERIOD  <sil=0.421> .PERIOD */

    printf("Enter a string <sil=0.644> ,COMMA a decimal and a real number separated by spaces\n") <sil=0.348> ;SEMICOLON scanf("%s %d %f" <sil=0.356> ,COMMA string <sil=0.602> ,COMMA &i <sil=0.621> ,COMMA &f) <sil=0.334> ;SEMICOLON /* Not good - no string length check */
    printf("You entered \"%s\" <sil=0.586> ,COMMA %d and %f\n" <sil=0.627> ,COMMA string <sil=0.522> ,COMMA i <sil=0.567> ,COMMA f) <sil=0.484> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.516> ;SEMICOLON }

Compile the program and enter some data <sil=0.932> .PERIOD Here is some example input and output <sil=0.949> .PERIOD Enter a string <sil=0.461> ,COMMA a decimal and a real number separated by spaces
  Hello 4 3 <sil=0.974> .PERIOD 14159
  You entered "Hello" <sil=0.544> ,COMMA 4 and 3 <sil=0.992> .PERIOD 141590
Each item is delimited by whitespace (which includes new lines <sil=0.477> ,COMMA of course) <sil=0.436> ,COMMA but you can use a scanset format specifier to overcome this <sil=0.388> ,COMMA "%[characters_wanted]" <sil=0.994> .PERIOD See the DEC C Run-Time Library Reference Manual <sil=0.422> ,COMMA Chapter 2 <sil=0.350> ,COMMA and Table 2-3 <sil=0.307> ,COMMA and K&R II page 246 for more information on this <sil=0.929> .PERIOD The scanf function actually returns an integer value <sil=0.580> ,COMMA which is the number of items successfully read in <sil=0.500> ,COMMA or the predefined macro value EOF if an error occurred <sil=0.984> .PERIOD Because you can't safely limit string input with scanf (which means you could unintentionally overwrite important memory locations and cause your program to crash by entering a string longer than the memory allocated for it) <sil=0.483> ,COMMA it is far better to use fgets() <sil=0.937> .PERIOD What you do is read a limited length string with fgets() <sil=0.396> ,COMMA the prototype for which is char *fgets( char *str <sil=0.550> ,COMMA int maxchar <sil=0.630> ,COMMA FILE *file_ptr) <sil=0.923> .PERIOD So if we had a first argument <sil=0.647> ,COMMA destination_string <sil=0.645> ,COMMA declared as char destination_string[STRING_SIZE] <sil=0.350> ,COMMA we would use sizeof(destination_string) for maxchar <sil=0.493> ,COMMA and stdin as the input FILE stream <sil=0.921> .PERIOD  <sil=0.995> .PERIOD char destination_string[STRING_SIZE] <sil=0.594> ;SEMICOLON char *pszResult <sil=0.355> ;SEMICOLON  <sil=0.928> .PERIOD pszResult = fgets( destination_string <sil=0.522> ,COMMA sizeof(destination_string) <sil=0.428> ,COMMA stdin ) <sil=0.519> ;SEMICOLON if ( <sil=0.904> !EXCLAMATIONMARK pszResult ) {
      /* Error or EOF (End Of File) */ <sil=0.901> .PERIOD } else {
      if ( destination_string[strlen(destination_string)-1] <sil=0.982> !EXCLAMATIONMARK = '\n' ) {
        /* Length limit means we didn't get all the input string */ <sil=0.966> .PERIOD } else {
        /* Got it all - do sscanf() or whatever */ <sil=0.960> .PERIOD }
    }

The fgets() function stops reading after the first newline character is encountered <sil=0.622> ,COMMA or <sil=0.601> ,COMMA if no newline is found <sil=0.492> ,COMMA it reads in at most maxchar-1 characters <sil=0.903> .PERIOD In either case the string is terminated with '\0' <sil=0.976> .PERIOD You can tell whether the length limit cut in by checking if the last character in the string is '\n' <sil=0.962> .PERIOD If it isn't <sil=0.305> ,COMMA then you may need to read more input <sil=0.923> .PERIOD This will require malloc()ing space enough for all the "segments" of the string and perhaps strncat()ing them together <sil=0.971> .PERIOD This is left as an exercise for the reader <sil=0.958> .PERIOD The resultant string is then parsed with sscanf() <sil=0.447> ,COMMA which takes its input from a string <sil=0.405> ;SEMICOLON destination_string in this description <sil=0.949> .PERIOD Failure to limit the length of an input string led to the infamous "finger" bug <sil=0.962> .PERIOD There is a function similar to fgets <sil=0.438> ,COMMA called gets() <sil=0.382> ,COMMA which was used in the original finger program (finger is a program which returns information about users on the target system) <sil=0.984> .PERIOD Never <sil=0.575> ,COMMA repeat never <sil=0.575> ,COMMA use gets <sil=0.926> .PERIOD It reads characters into the string pointed to by its argument <sil=0.363> ,COMMA with no length check <sil=0.990> .PERIOD This was exploited to overwrite the return address on the stack <sil=0.590> ,COMMA and make the "privileged" finger image execute some code (sent as a part of a long string) to create a command shell running with full privileges <sil=0.908> .PERIOD Programming Challenge 9
      _______________________
      
        Write  a  program  using  scanf <sil=0.541> ,COMMA or  fgets and  sscanf <sil=0.925> .PERIOD Try  out
      different conversion characters <sil=0.533> ,COMMA check the  effects  of giving  bad
      data <sil=0.961> .PERIOD The standard C file system is based on streams <sil=0.554> ,COMMA which are rather like unit numbers in Fortran <sil=0.976> .PERIOD Streams connect to devices <sil=0.586> ,COMMA such as files on disks <sil=0.561> ,COMMA terminals or printers <sil=0.958> .PERIOD By using file streams <sil=0.450> ,COMMA you are shielded from having to do the low level IO <sil=0.936> .PERIOD C recognises two types of stream which are text streams and binary streams <sil=0.958> .PERIOD Binary streams are written to and read from without any mucking about <sil=0.875> !EXCLAMATIONMARK Text streams can have <sil=0.472> ,COMMA or not have <sil=0.578> ,COMMA implementation defined line feeds and carriage returns <sil=0.999> .PERIOD Binary streams are usually used for writing out data in the machine's internal representation <sil=0.404> ,COMMA like an array of structures for example <sil=0.986> .PERIOD The type is determined when the file is opened with fopen() <sil=0.916> .PERIOD The following table show the access modes you can use with fopen() <sil=0.979> .PERIOD r   Open text file reading <sil=0.922> .PERIOD w   Open or create text file for writing <sil=0.640> ,COMMA discard previous contents <sil=0.966> .PERIOD (creates new version under VMS)
  a   Open or create for appending <sil=0.614> ,COMMA write at end of existing data <sil=0.915> .PERIOD r+  Open text file reading AND writing <sil=0.948> .PERIOD w+  Open or create text file for update <sil=0.494> ,COMMA discard previous contents <sil=0.970> .PERIOD (creates new version under VMS)
  a+  Open or create for appending <sil=0.360> ,COMMA write at end of existing data <sil=0.998> .PERIOD Add a "b" after the access mode letter <sil=0.504> ,COMMA and we are talking binary files <sil=0.937> .PERIOD Here is an example program to write and read back an array of data structure <sil=0.590> ,COMMA which will make everything remarkably clear <sil=0.936> .PERIOD /*---- File IO Example ("fileio <sil=0.987> .PERIOD c") ------------------------------------------*/

/*---- Put all #include files here -------------------------------------------*/
/* ANSI Headers */
#include <ctype <sil=0.967> .PERIOD h>    /* Character macros */
#include <errno <sil=0.904> .PERIOD h>    /* errno error codes */
#include <stdio <sil=0.934> .PERIOD h>    /* Standard I/O */
#include <stdlib <sil=0.903> .PERIOD h>   /* Standard Library */
#include <string <sil=0.951> .PERIOD h>   /* String Library */
#include <time <sil=0.951> .PERIOD h>     /* Time Library */

/*---- Put all #define statements here ---------------------------------------*/
#define PROGRAM_VERSION "1 <sil=0.921> .PERIOD 6"
#define TYPE_OF_FILE "TEST_DATA"
#define NDATA_POINTS 10

/*---- Put all structure definitions here ------------------------------------*/
/* Following structures MUST be packed tightly ie <sil=0.964> .PERIOD no member alignment -------*/
#ifdef __DECC
#pragma member_alignment save
# pragma nomember_alignment
#endif

struct file_header_s {
  char type[32] <sil=0.463> ;SEMICOLON char version[8] <sil=0.337> ;SEMICOLON char creator[20] <sil=0.466> ;SEMICOLON time_t time <sil=0.455> ;SEMICOLON } <sil=0.569> ;SEMICOLON struct data_s {
  short x <sil=0.349> ;SEMICOLON short y <sil=0.376> ;SEMICOLON char name[8] <sil=0.560> ;SEMICOLON } <sil=0.313> ;SEMICOLON #ifdef __DECC
# pragma member_alignment restore
#endif

int main(int argc <sil=0.646> ,COMMA char *argv[])
{
    struct data_s *data_ptr <sil=0.426> ;SEMICOLON struct file_header_s file_header <sil=0.341> ;SEMICOLON FILE *outfile <sil=0.333> ,COMMA *infile <sil=0.556> ;SEMICOLON int  i <sil=0.484> ,COMMA got_answer <sil=0.584> ;SEMICOLON char answer[8] <sil=0.398> ,COMMA yeno[4] <sil=0.377> ,COMMA node_user[20] <sil=0.559> ,COMMA filename[128] <sil=0.579> ;SEMICOLON char *c_ptr <sil=0.635> ;SEMICOLON long int ndata = 0 <sil=0.492> ,COMMA nitems = 0 <sil=0.435> ;SEMICOLON /*  End of declarations <sil=0.949> .PERIOD  <sil=0.411> .PERIOD  <sil=0.464> .PERIOD */

/*  Set up a default namne in case user hasn't specified one */
    if (argc < 2) {
      strcpy(filename <sil=0.413> ,COMMA "MYDATA <sil=0.904> .PERIOD DAT") <sil=0.602> ;SEMICOLON } else {
      strcpy(filename <sil=0.484> ,COMMA argv[1]) <sil=0.449> ;SEMICOLON }

/*  Get node name and user name */
#if <sil=0.952> !EXCLAMATIONMARK defined( _WIN32 )
    sprintf( node_user <sil=0.409> ,COMMA "%s%s" <sil=0.413> ,COMMA getenv("SYS$NODE") <sil=0.533> ,COMMA getenv("USER") ) <sil=0.543> ;SEMICOLON /* VMS */
#else
    sprintf( node_user <sil=0.624> ,COMMA "\\\\%s\\%s" <sil=0.341> ,COMMA getenv("COMPUTERNAME") <sil=0.393> ,COMMA getenv("USERNAME")) <sil=0.511> ;SEMICOLON #endif
/*  Convert to uppercase */
    c_ptr = node_user <sil=0.307> ;SEMICOLON while ( *c_ptr = toupper(*c_ptr) ) ++c_ptr <sil=0.579> ;SEMICOLON /* toupper lives in <ctype <sil=0.993> .PERIOD h> */

/*  Allocate data space and initialize it */
    data_ptr = (struct data_s *)malloc( sizeof(struct data_s)*NDATA_POINTS ) <sil=0.485> ;SEMICOLON if ( data_ptr ) {

      ndata = NDATA_POINTS <sil=0.528> ;SEMICOLON for ( i = 0 <sil=0.605> ;SEMICOLON i < ndata <sil=0.425> ;SEMICOLON i++) {
        data_ptr[i] <sil=0.951> .PERIOD x = data_ptr[i] <sil=0.963> .PERIOD y = i <sil=0.626> ;SEMICOLON sprintf(data_ptr[i] <sil=0.909> .PERIOD name <sil=0.371> ,COMMA "%3 <sil=0.995> .PERIOD 3d <sil=0.365> ,COMMA %3 <sil=0.937> .PERIOD 3d" <sil=0.646> ,COMMA data_ptr[i] <sil=0.903> .PERIOD x <sil=0.368> ,COMMA data_ptr[i] <sil=0.952> .PERIOD y ) <sil=0.488> ;SEMICOLON }

/*    Open the file for writing in binary mode */
      outfile = fopen(filename <sil=0.539> ,COMMA "wb") <sil=0.423> ;SEMICOLON if ( outfile <sil=0.937> !EXCLAMATIONMARK = NULL ) {

/*      Set up the header */
        strcpy(file_header <sil=0.900> .PERIOD type <sil=0.552> ,COMMA TYPE_OF_FILE) <sil=0.606> ;SEMICOLON strcpy(file_header <sil=0.986> .PERIOD version <sil=0.480> ,COMMA PROGRAM_VERSION) <sil=0.310> ;SEMICOLON sprintf(file_header <sil=0.921> .PERIOD creator <sil=0.442> ,COMMA "%s" <sil=0.431> ,COMMA node_user) <sil=0.445> ;SEMICOLON (void)time(&file_header <sil=0.911> .PERIOD time) <sil=0.326> ;SEMICOLON printf("Writing out the header\n") <sil=0.350> ;SEMICOLON /*      Items Written   Data Pointer   Size in bytes     No <sil=0.949> .PERIOD of items  stream */
/*        |                   |             |                |            |   */
/*        v                   v             v                v            v   */
        nitems = fwrite( &file_header <sil=0.585> ,COMMA sizeof(file_header) <sil=0.623> ,COMMA 1 <sil=0.554> ,COMMA outfile) <sil=0.399> ;SEMICOLON if ( ferror(outfile) ) {
          fprintf(stderr <sil=0.632> ,COMMA "Error writing file 'header':\n%s" <sil=0.620> ,COMMA strerror(errno)) <sil=0.404> ;SEMICOLON }

        printf("Writing out the number of data items <sil=0.306> ,COMMA %d\n" <sil=0.439> ,COMMA ndata) <sil=0.364> ;SEMICOLON nitems = fwrite( &ndata <sil=0.499> ,COMMA sizeof(ndata) <sil=0.520> ,COMMA 1 <sil=0.438> ,COMMA outfile) <sil=0.633> ;SEMICOLON if ( ferror(outfile) ) {
          fprintf(stderr <sil=0.406> ,COMMA "Error writing number of data items:\n%s" <sil=0.541> ,COMMA strerror(errno)) <sil=0.335> ;SEMICOLON }

        printf("Writing out the actual data data all in one chunk\n") <sil=0.602> ;SEMICOLON nitems = fwrite( data_ptr <sil=0.388> ,COMMA sizeof(struct data_s)*ndata <sil=0.522> ,COMMA 1 <sil=0.471> ,COMMA outfile) <sil=0.566> ;SEMICOLON if ( ferror(outfile) ) {
          fprintf(stderr <sil=0.606> ,COMMA "Error writing data:\n%s" <sil=0.564> ,COMMA strerror(errno)) <sil=0.570> ;SEMICOLON }

        printf("Closing output file\n") <sil=0.417> ;SEMICOLON fclose(outfile) <sil=0.413> ;SEMICOLON } else {
        fprintf(stderr <sil=0.326> ,COMMA "Error creating data file %s:\n%s" <sil=0.607> ,COMMA filename <sil=0.324> ,COMMA strerror(errno)) <sil=0.646> ;SEMICOLON }
    } else {
      fprintf(stderr <sil=0.599> ,COMMA "Couldn't allocate space for %d data structures\n" <sil=0.494> ,COMMA ndata) <sil=0.338> ;SEMICOLON }    

/*  Now optionally read the data back in and format */

    do {
      printf("\nRead data back in <sil=0.929> ?QUESTIONMARK [Y/N]: ") <sil=0.522> ;SEMICOLON fgets( yeno <sil=0.345> ,COMMA sizeof(yeno) <sil=0.604> ,COMMA stdin) <sil=0.608> ;SEMICOLON /* Reads in sizeof(yeno)-1 chars */
      got_answer = sscanf( yeno <sil=0.472> ,COMMA "%[YyNnTtFf]" <sil=0.319> ,COMMA answer) <sil=0.393> ;SEMICOLON } while ( <sil=0.900> !EXCLAMATIONMARK got_answer ) <sil=0.616> ;SEMICOLON if ( answer[0] == 'Y' ||  answer[0] == 'y' ||
         answer[0] == 'T' ||  answer[0] == 't' ) {
      printf( "Here we go <sil=0.970> .PERIOD  <sil=0.574> .PERIOD \n" ) <sil=0.426> ;SEMICOLON /*    Zero out the structures just to show there's no cheating */
      ndata = 0 <sil=0.527> ;SEMICOLON memset( &file_header <sil=0.499> ,COMMA 0 <sil=0.488> ,COMMA sizeof( file_header ) ) <sil=0.629> ;SEMICOLON memset( data_ptr <sil=0.504> ,COMMA 0 <sil=0.536> ,COMMA sizeof(struct data_s)*NDATA_POINTS ) <sil=0.609> ;SEMICOLON /*    Open the file for reading in binary mode */
      infile = fopen(filename <sil=0.404> ,COMMA "rb") <sil=0.590> ;SEMICOLON if ( infile <sil=0.904> !EXCLAMATIONMARK = NULL ) {

        printf("Reading in the header\n") <sil=0.516> ;SEMICOLON nitems = fread(&file_header <sil=0.450> ,COMMA sizeof(file_header) <sil=0.491> ,COMMA 1 <sil=0.325> ,COMMA infile) <sil=0.501> ;SEMICOLON if ( ferror(infile) ) {
          fprintf(stderr <sil=0.582> ,COMMA "Error reading file 'header':\n%s" <sil=0.489> ,COMMA strerror(errno)) <sil=0.421> ;SEMICOLON }

        printf("Header information:  file type %s\n" <sil=0.383> ,COMMA file_header <sil=0.998> .PERIOD type ) <sil=0.602> ;SEMICOLON printf("                       version %s\n" <sil=0.592> ,COMMA file_header <sil=0.943> .PERIOD version ) <sil=0.347> ;SEMICOLON printf("                    created by %s\n" <sil=0.627> ,COMMA file_header <sil=0.962> .PERIOD creator ) <sil=0.344> ;SEMICOLON printf("                            on %s\n" <sil=0.575> ,COMMA ctime( &file_header <sil=0.954> .PERIOD time ) ) <sil=0.466> ;SEMICOLON nitems = fread( &ndata <sil=0.312> ,COMMA sizeof(ndata) <sil=0.431> ,COMMA 1 <sil=0.595> ,COMMA infile) <sil=0.384> ;SEMICOLON printf("Read in the number of data items <sil=0.366> ,COMMA %d\n" <sil=0.458> ,COMMA ndata) <sil=0.580> ;SEMICOLON if ( ferror(infile) ) {
          fprintf(stderr <sil=0.379> ,COMMA "Error reading number of data items:\n%s" <sil=0.491> ,COMMA strerror(errno)) <sil=0.622> ;SEMICOLON }

        printf("Reading in the actual data data all in one chunk\n") <sil=0.432> ;SEMICOLON nitems = fread( data_ptr <sil=0.524> ,COMMA sizeof(struct data_s)*ndata <sil=0.334> ,COMMA 1 <sil=0.414> ,COMMA infile) <sil=0.475> ;SEMICOLON if ( ferror(infile) ) {
          fprintf(stderr <sil=0.573> ,COMMA "Error reading data:\n%s" <sil=0.438> ,COMMA strerror(errno)) <sil=0.440> ;SEMICOLON }

        printf("Closing intput file\n\n") <sil=0.490> ;SEMICOLON fclose(infile) <sil=0.453> ;SEMICOLON printf("Read in %d data items\n" <sil=0.588> ,COMMA ndata) <sil=0.472> ;SEMICOLON for ( i = 0 <sil=0.481> ;SEMICOLON i < ndata <sil=0.454> ;SEMICOLON i++) {
          printf("%3d) x:%3d <sil=0.423> ,COMMA y:%3d <sil=0.537> ,COMMA Label: %s\n" <sil=0.486> ,COMMA i <sil=0.309> ,COMMA data_ptr[i] <sil=0.943> .PERIOD x <sil=0.340> ,COMMA data_ptr[i] <sil=0.948> .PERIOD y <sil=0.305> ,COMMA data_ptr[i] <sil=0.953> .PERIOD name ) <sil=0.463> ;SEMICOLON }

      } else {
        fprintf(stderr <sil=0.453> ,COMMA "Error opening data file %s:\n%s" <sil=0.603> ,COMMA filename <sil=0.407> ,COMMA strerror(errno)) <sil=0.324> ;SEMICOLON }

    } else {
      printf( "OK - be like that\n" ) <sil=0.414> ;SEMICOLON }

    exit(EXIT_SUCCESS) <sil=0.368> ;SEMICOLON }

The strange #pragma directive is a standard way to do non-standard things <sil=0.350> ,COMMA like instruct the compiler to close-pack the data (i <sil=0.983> .PERIOD e <sil=0.587> .PERIOD don't use natural alignment) and is explained in §17 <sil=0.999> .PERIOD The "f" routines you can look up yourself in a book <sil=0.980> .PERIOD Several DEC system and library routines are used <sil=0.484> ,COMMA so the VMS headers <ssdef <sil=0.980> .PERIOD h> <sil=0.945> ,COMMA <starlet <sil=0.991> .PERIOD h> and <lib$routines <sil=0.927> .PERIOD h> are included <sil=0.940> .PERIOD Notice that the function calls are lowercase <sil=0.346> ,COMMA and there are no prototypes defined yet <sil=0.407> ,COMMA so you are on your own there if you get an argument wrong <sil=0.997> !EXCLAMATIONMARK This should change with future releases of DEC C <sil=0.902> .PERIOD The strerror routine is useful for getting a text error message <sil=0.982> .PERIOD After many library calls <sil=0.319> ,COMMA not just stdio calls <sil=0.538> ,COMMA an integer expression <sil=0.531> ,COMMA errno <sil=0.407> ,COMMA defined in <errno <sil=0.916> .PERIOD h> <sil=0.973> ,COMMA yields a non-zero value if an error occurs <sil=0.945> .PERIOD Be very careful making assumptions about errno <sil=0.374> ,COMMA because in many cases it isn't actually a variable but a macro <sil=0.306> ,COMMA which allows it <sil=0.307> ,COMMA for example <sil=0.360> ,COMMA to behave in a thread-safe manner <sil=0.930> .PERIOD This means <sil=0.593> ,COMMA however <sil=0.920> ,COMMA that it isn't safe to treat it as a global integer variable and take it's address and so forth <sil=0.957> .PERIOD The strerror function from <string <sil=0.992> .PERIOD h> converts the error number into a text string <sil=0.634> ,COMMA and the function value is a pointer to this string <sil=0.934> .PERIOD You must not modify this string <sil=0.401> ,COMMA and it will be overwritten by later calls to strerror <sil=0.933> .PERIOD This program reads in many bytes at a time with each read <sil=0.393> ,COMMA but there is a function <sil=0.405> ,COMMA fgetc <sil=0.551> ,COMMA to read a single character <sil=0.364> ,COMMA and a matching function <sil=0.561> ,COMMA ungetc which returns the last read character to the input stream to be read by the next fgetc <sil=0.973> .PERIOD This provides a kind of look-ahead function which is exploited by the next example program <sil=0.411> ,COMMA "calc <sil=0.967> .PERIOD c" <sil=0.626> ,COMMA provided by Neill Clift <sil=0.928> .PERIOD In this program <sil=0.470> ,COMMA getchar is used instead of fgetc <sil=0.968> .PERIOD It is equivalent to fgetc except that it reads from stdin <sil=0.921> .PERIOD This sturdy example is adapted from the very expression parser used by LID (a Y <sil=0.983> .PERIOD R <sil=0.998> .PERIOD L <sil=0.981> .PERIOD replacement for DEC's CDD <sil=0.637> ;SEMICOLON contact sales@yrl <sil=0.998> .PERIOD co <sil=0.954> .PERIOD uk if you are interested) <sil=0.950> .PERIOD /*---- Calculator expression evaluator example ("calc <sil=1.000> .PERIOD c") --------------------*/
/*
        History:
        Version         Name                    Date
        V01-001         Neill Clift             16-Mar-1995
                        Initial version
*/

/* ANSI Headers */
#include <ctype <sil=0.946> .PERIOD h>
#include <stdio <sil=0.993> .PERIOD h>
#include <stdlib <sil=0.927> .PERIOD h>

/* Function prototypes */
int parse_expression(void) <sil=0.424> ;SEMICOLON int parse_expression_factor(void) <sil=0.481> ;SEMICOLON int parse_expression_term(void) <sil=0.340> ;SEMICOLON int parse_literal(void) <sil=0.645> ;SEMICOLON int getnonwhite(void) <sil=0.539> ;SEMICOLON int match_token(int tomatch) <sil=0.442> ;SEMICOLON /* Start of main program */
int main( int argc <sil=0.407> ,COMMA char *argv[])
{
  int val <sil=0.557> ;SEMICOLON /*  End of declarations <sil=0.903> .PERIOD  <sil=0.648> .PERIOD  <sil=0.620> .PERIOD */

  printf("Enter expression terminated by <sil=0.341> ;SEMICOLON \n") <sil=0.548> ;SEMICOLON printf("Calc> ") <sil=0.446> ;SEMICOLON val = parse_expression() <sil=0.484> ;SEMICOLON if (match_token(' <sil=0.575> ;SEMICOLON ')) {
    printf("Result is %d\n" <sil=0.346> ,COMMA val) <sil=0.550> ;SEMICOLON } else {
    printf("Expression seems bust\n") <sil=0.466> ;SEMICOLON }
  exit(EXIT_SUCCESS) <sil=0.578> ;SEMICOLON }

/*---- Get the next character skipping white space ---------------------------*/
int getnonwhite(void)
{
    int c <sil=0.341> ;SEMICOLON /*  End of declarations <sil=0.975> .PERIOD  <sil=0.343> .PERIOD  <sil=0.420> .PERIOD */

    while (1) {
      c = getchar() <sil=0.626> ;SEMICOLON if (c == EOF) {
        break <sil=0.445> ;SEMICOLON } else if ( <sil=0.987> !EXCLAMATIONMARK isspace(c)) {
        break <sil=0.430> ;SEMICOLON }
    }
    return( c ) <sil=0.370> ;SEMICOLON }

/*--- Match single character against next input char <sil=0.903> .PERIOD If match then gobble ---*/
/*--- it up <sil=0.993> .PERIOD If we don't match it then push it back for future matches -------*/
int match_token(int tomatch)
{
    int c <sil=0.515> ;SEMICOLON /*  End of declarations <sil=0.921> .PERIOD  <sil=0.498> .PERIOD  <sil=0.456> .PERIOD */

    c = getnonwhite() <sil=0.515> ;SEMICOLON if (c == tomatch) {
      return( 1 ) <sil=0.453> ;SEMICOLON } else {
      ungetc(c <sil=0.337> ,COMMA stdin) <sil=0.514> ;SEMICOLON /* Put character back on input stream to be read again */
      return( 0 ) <sil=0.464> ;SEMICOLON }
}

/*---- Parse a single number from input +/- nnnnn  ---------------------------*/
int parse_literal(void)
{
    int retval <sil=0.314> ,COMMA st <sil=0.567> ;SEMICOLON /*  End of declarations <sil=0.936> .PERIOD  <sil=0.457> .PERIOD  <sil=0.360> .PERIOD */

    retval = 0 <sil=0.525> ;SEMICOLON st = scanf("%d" <sil=0.644> ,COMMA &retval) <sil=0.564> ;SEMICOLON if (st == EOF) {
      printf("Hit EOF looking for literal\n") <sil=0.355> ;SEMICOLON } else if (st == 0) {
      printf("Missing literal\n") <sil=0.553> ;SEMICOLON }

    return( retval ) <sil=0.330> ;SEMICOLON }

/*---- Syntax is:   Literal    or:   (expression)  ---------------------------*/
int parse_expression_factor(void)
{
  int retval <sil=0.389> ;SEMICOLON /*  End of declarations <sil=0.995> .PERIOD  <sil=0.641> .PERIOD  <sil=0.412> .PERIOD */

  if (match_token('(')) {
    retval = parse_expression() <sil=0.539> ;SEMICOLON if ( <sil=0.988> !EXCLAMATIONMARK match_token(')'))
      printf("Missing close bracket\n") <sil=0.377> ;SEMICOLON } else {
    retval = parse_literal() <sil=0.528> ;SEMICOLON }

  return( retval ) <sil=0.642> ;SEMICOLON }

/*---- Parse an expression term <sil=0.614> ,COMMA Syntax: <factor>{<multiplying_op><factor>} -*/
int parse_expression_term(void)
{
  int tmp <sil=0.609> ,COMMA mul <sil=0.319> ,COMMA opr <sil=0.605> ;SEMICOLON /*  End of declarations <sil=0.931> .PERIOD  <sil=0.347> .PERIOD  <sil=0.539> .PERIOD */

  tmp = parse_expression_factor() <sil=0.331> ;SEMICOLON while (1) {
    if (match_token('*')) {
      opr = 1 <sil=0.567> ;SEMICOLON } else if (match_token('/')) {
      opr = -1 <sil=0.617> ;SEMICOLON } else {
      break <sil=0.619> ;SEMICOLON }

    mul = parse_expression_factor() <sil=0.614> ;SEMICOLON if (opr == 1) {
      tmp = tmp * mul <sil=0.428> ;SEMICOLON } else if (mul == 0) {
      printf("Division by zero <sil=0.927> !EXCLAMATIONMARK \n") <sil=0.607> ;SEMICOLON } else {
      tmp = tmp / mul <sil=0.535> ;SEMICOLON }
  }
  return( tmp ) <sil=0.527> ;SEMICOLON }

/*---- Parse an expression <sil=0.316> ,COMMA Syntax: [+/-]<term>{<adding_op><term>} -----------*/
int parse_expression(void)
{
  int tmp <sil=0.538> ,COMMA mul <sil=0.601> ,COMMA add <sil=0.400> ;SEMICOLON /*  End of declarations <sil=0.920> .PERIOD  <sil=0.451> .PERIOD  <sil=0.432> .PERIOD */

  /* Check for leading + or - <sil=0.994> .PERIOD None means plus */

  if (match_token('+')) {
    mul = 1 <sil=0.623> ;SEMICOLON } else if (match_token('-')) {
    mul = -1 <sil=0.389> ;SEMICOLON } else {
    mul = 1 <sil=0.618> ;SEMICOLON }

  tmp = parse_expression_term() <sil=0.619> ;SEMICOLON tmp = tmp * mul <sil=0.342> ;SEMICOLON while (1) {
    if (match_token('+')) {
      mul = 1 <sil=0.510> ;SEMICOLON } else if (match_token('-')) {
      mul = -1 <sil=0.383> ;SEMICOLON } else {
      break <sil=0.621> ;SEMICOLON }
    add = parse_expression_term() <sil=0.470> ;SEMICOLON tmp = tmp + mul * add <sil=0.401> ;SEMICOLON } <sil=0.548> ;SEMICOLON return( tmp ) <sil=0.606> ;SEMICOLON }

A few other file routines are worth mentioning <sil=0.947> .PERIOD These are fgetpos <sil=0.608> ,COMMA fsetpos and fseek <sil=0.501> ,COMMA which generally apply to files open in binary mode <sil=0.951> .PERIOD They allow you to position to a particular byte within a file <sil=0.447> ,COMMA specified from the current position <sil=0.380> ,COMMA or the beginning or end of the file <sil=0.996> .PERIOD The fgetpos function returns the position in an object of type fpos_t <sil=0.474> ,COMMA which is only meaningful when used with fsetpos <sil=0.956> .PERIOD See K&R II page 248 for more details <sil=0.932> .PERIOD The fflush function allows you to flush cached data on an output stream if you want to do this before fclose <sil=0.438> ,COMMA which flushes anyway <sil=0.452> ,COMMA as does exit() <sil=0.919> .PERIOD To make sure that data is actually written to disk you must call a non-standard function like fsync after fflush - fflush on it's own doesn't guarantee that the data has actually been written to permanent storage <sil=0.906> .PERIOD Streams can be redirected using freopen <sil=0.419> ,COMMA and this is a commonly used method for making stdout get written to a file without having to change printf calls <sil=0.973> .PERIOD Testing for end of file is achieved by using the feof function <sil=0.934> .PERIOD A standard method for getting command line arguments is provided in C <sil=0.980> .PERIOD These are the arguments to the main program <sil=0.590> ,COMMA argc and argv <sil=0.911> .PERIOD The integer argc is the number of command line arguments <sil=0.412> ,COMMA and must be greater than or equal to zero <sil=0.994> .PERIOD The second argument <sil=0.443> ,COMMA argv <sil=0.511> ,COMMA is an array of pointers to characters <sil=0.988> .PERIOD If argc is zero <sil=0.473> ,COMMA then argv[0] must be the NULL pointer <sil=0.916> .PERIOD On most implementations <sil=0.363> ,COMMA it will be greater than zero <sil=0.462> ,COMMA and argv[0] points to the program name <sil=0.978> .PERIOD On some machines this will be a string like "myprog" <sil=0.901> .PERIOD On VMS or Windows NT systems it is the full file specification <sil=0.964> .PERIOD If the program name is not available <sil=0.314> ,COMMA argv[0] must point to the null character <sil=0.626> ,COMMA '\0' <sil=0.482> .PERIOD The elements argv[1] to argv[argc-1] <sil=0.630> ,COMMA if they exist <sil=0.403> ,COMMA point to strings which are implementation defined <sil=0.918> .PERIOD In practise <sil=0.516> ,COMMA these are usually the whitespace separated (unless "quoted") arguments supplied on the command line <sil=0.934> .PERIOD Under VMS <sil=0.358> ,COMMA command line arguments are converted to lowercase <sil=0.430> ,COMMA unless quoted <sil=0.992> .PERIOD The following example <sil=0.354> ,COMMA "args <sil=0.949> .PERIOD c" <sil=0.596> ,COMMA shows how to get the command line arguments <sil=0.971> .PERIOD /*---- Getting Command Line Arguments C Example ("args <sil=0.952> .PERIOD c") -------------------*/

/* ANSI C Headers */
#include <stdio <sil=0.950> .PERIOD h>
#include <stdlib <sil=0.971> .PERIOD h>

/* Main Program starts here */
int main( int argc <sil=0.302> ,COMMA char *argv[] )
{
    int i <sil=0.553> ;SEMICOLON /*  End of declarations <sil=0.900> .PERIOD  <sil=0.576> .PERIOD  <sil=0.612> .PERIOD */

    for ( i = 0 <sil=0.400> ;SEMICOLON i < argc <sil=0.408> ;SEMICOLON i++ ) {
      printf("Argument %d = \"%s\"\n" <sil=0.373> ,COMMA i <sil=0.433> ,COMMA argv[i] ) <sil=0.602> ;SEMICOLON }

    exit(EXIT_SUCCESS) <sil=0.409> ;SEMICOLON }

In order to make it work <sil=0.579> ,COMMA you must either run it like this (assuming you are in the directory containing the image)

$ MC SYS$DISK:[]ARGS HELLO WORLD
or define a symbol <sil=0.306> ,COMMA and invoke it as a "foreign command"

$ args:==$SYS$DISK:[]ARGS
$ args hello world again
      Programming Challenge 10
      ________________________
      
        Try the args  program <sil=0.962> .PERIOD With your  new-found skills <sil=0.570> ,COMMA modify Neill's
      calc program to take a command line argument expression <sil=0.310> ,COMMA or to behave
      in the existing manner if one is not supplied <sil=0.916> .PERIOD On VMS systems <sil=0.609> ,COMMA we often want to access keyed indexed files <sil=0.915> .PERIOD This is slightly more difficult than using the standard file functions <sil=0.327> ,COMMA because you have to set up the RMS (Record Management Structures) yourself <sil=0.946> .PERIOD If you want to do this <sil=0.409> ,COMMA you should really read the DEC C documentation about using RMS from C <sil=0.929> .PERIOD Alternatively you can ask your friendly local Clift for an example <sil=0.925> .PERIOD Here's one we prepared before the course <sil=0.619> ,COMMA "key <sil=0.944> .PERIOD c"


/*---- Keyed Index File C Demonstration Program ("key <sil=0.967> .PERIOD c") --------------------*/
/*
        History:
        Version         Name                    Date
        V01-001         Neill Clift             09-Mar-1995
                        Initial version
*/

/* ANSI Headers */
#include <stddef <sil=0.979> .PERIOD h>
#include <stdio <sil=0.996> .PERIOD h>
#include <stdlib <sil=0.990> .PERIOD h>
#include <string <sil=0.975> .PERIOD h>
#include <ctype <sil=0.920> .PERIOD h>

/* VMS Headers */
#include <rab <sil=0.952> .PERIOD h>                /* RMS RAB */
#include <rms <sil=0.973> .PERIOD h>                /* RMS access blocks etc */
#include <ssdef <sil=0.949> .PERIOD h>              /* System service completion codes */
#include <starlet <sil=0.924> .PERIOD h>
#include <lib$routines>

/* Defines and Macros */
#define NAME_SIZE  32        /* Size of person field */
#define PHONE_SIZE 20        /* Size of the phone number field */

/* Structure declarations */

struct phone_r {
/* Define the structure that will be the record of the keyed file <sil=0.957> .PERIOD */
/* It is indexed  with two keys for each of the structures fields <sil=0.971> .PERIOD */
   char name[NAME_SIZE] <sil=0.512> ;SEMICOLON char phone[PHONE_SIZE] <sil=0.625> ;SEMICOLON } <sil=0.629> ;SEMICOLON /* Global Variables - not externally visible */
static struct FAB    fab <sil=0.393> ;SEMICOLON /* FAB for file  */
static struct RAB    rab <sil=0.427> ;SEMICOLON /* RAB for file */
static struct NAM    nam <sil=0.380> ;SEMICOLON /* NAM block to report I/O errors nicely */
static struct XABKEY xabkey1 <sil=0.394> ,COMMA xabkey2 <sil=0.426> ;SEMICOLON /* XAB to define keys structure */

static char essbuf[NAM$C_MAXRSS] <sil=0.577> ;SEMICOLON /* Expanded file name */
static char rssbuf[NAM$C_MAXRSS] <sil=0.567> ;SEMICOLON /* Resultant file name */

static char keyname1[32] = "Person" <sil=0.475> ;SEMICOLON /* Name of first key */
static char keyname2[32] = "Phone" <sil=0.515> ;SEMICOLON /* Name of second key */

/*---- Routine to close the RMS file -----------------------------------------*/
int close_file( void )
{
   long int status <sil=0.457> ;SEMICOLON /* End of declarations <sil=0.986> .PERIOD  <sil=0.544> .PERIOD  <sil=0.645> .PERIOD */

   status = sys$close( &fab ) <sil=0.646> ;SEMICOLON return( status ) <sil=0.451> ;SEMICOLON }

/*---- Open/Create the keyed index file --------------------------------------*/
int create_file( char *filename )
{
   long int status <sil=0.378> ,COMMA status1 <sil=0.453> ;SEMICOLON /* End of declarations <sil=0.969> .PERIOD  <sil=0.544> .PERIOD  <sil=0.496> .PERIOD */

   fab = cc$rms_fab <sil=0.377> ;SEMICOLON /* initialise the FAB */
   fab <sil=0.942> .PERIOD fab$l_alq = 100 <sil=0.336> ;SEMICOLON /* Preallocate space */
   fab <sil=0.927> .PERIOD fab$w_deq = 100 <sil=0.364> ;SEMICOLON fab <sil=0.926> .PERIOD fab$b_fac = FAB$M_PUT|FAB$M_DEL|FAB$M_UPD <sil=0.372> ;SEMICOLON fab <sil=0.903> .PERIOD fab$l_fop = FAB$M_DFW|FAB$M_CIF <sil=0.487> ;SEMICOLON fab <sil=0.956> .PERIOD fab$b_org = FAB$C_IDX <sil=0.488> ;SEMICOLON fab <sil=0.904> .PERIOD fab$b_rfm = FAB$C_VAR <sil=0.435> ;SEMICOLON fab <sil=0.943> .PERIOD fab$l_fna = filename <sil=0.529> ;SEMICOLON fab <sil=0.946> .PERIOD fab$b_fns = strlen(filename) <sil=0.637> ;SEMICOLON fab <sil=0.989> .PERIOD fab$b_rat = FAB$M_CR <sil=0.644> ;SEMICOLON fab <sil=0.969> .PERIOD fab$l_xab = (char *) &xabkey1 <sil=0.353> ;SEMICOLON /* Init XABKEY to define key for name key */
   xabkey1 = cc$rms_xabkey <sil=0.559> ;SEMICOLON /* Initialise XABKEY structure */
   xabkey1 <sil=0.979> .PERIOD xab$b_bln  = XAB$C_KEYLEN <sil=0.623> ;SEMICOLON xabkey1 <sil=0.971> .PERIOD xab$b_cod  = XAB$C_KEY <sil=0.520> ;SEMICOLON xabkey1 <sil=0.904> .PERIOD xab$b_dtp  = XAB$C_STG <sil=0.521> ;SEMICOLON xabkey1 <sil=0.968> .PERIOD xab$b_ref  = 0 <sil=0.546> ;SEMICOLON /* Key zero */
   xabkey1 <sil=0.939> .PERIOD xab$l_knm  = (char *) &keyname1 <sil=0.639> ;SEMICOLON /* Key name */
   xabkey1 <sil=0.982> .PERIOD xab$l_nxt  = (char *) &xabkey2 <sil=0.499> ;SEMICOLON /* Next XAB in chain */
   /*
      The next two fields describe the section of the record that contain the
      key <sil=0.904> .PERIOD */
   xabkey1 <sil=0.981> .PERIOD xab$w_pos0 = offsetof(struct phone_r <sil=0.321> ,COMMA name) <sil=0.546> ;SEMICOLON xabkey1 <sil=0.944> .PERIOD xab$b_siz0 = NAME_SIZE <sil=0.390> ;SEMICOLON /* Init XABKEY to define key for phone kek */
   xabkey2 = cc$rms_xabkey <sil=0.577> ;SEMICOLON /* Initialise XABKEY structure */
   xabkey2 <sil=0.955> .PERIOD xab$b_bln  = XAB$C_KEYLEN <sil=0.569> ;SEMICOLON xabkey2 <sil=0.914> .PERIOD xab$b_cod  = XAB$C_KEY <sil=0.360> ;SEMICOLON xabkey2 <sil=0.929> .PERIOD xab$b_dtp  = XAB$C_STG <sil=0.336> ;SEMICOLON xabkey2 <sil=0.909> .PERIOD xab$b_ref  = 1 <sil=0.375> ;SEMICOLON /* Key one */
   xabkey2 <sil=0.987> .PERIOD xab$l_knm  = (char *) &keyname2 <sil=0.442> ;SEMICOLON xabkey2 <sil=0.945> .PERIOD xab$l_nxt  = 0 <sil=0.585> ;SEMICOLON xabkey2 <sil=0.994> .PERIOD xab$w_pos0 = offsetof(struct phone_r <sil=0.368> ,COMMA phone) <sil=0.551> ;SEMICOLON xabkey2 <sil=0.916> .PERIOD xab$b_siz0 = PHONE_SIZE <sil=0.387> ;SEMICOLON /*
      Init NAM block just for good file I/O error reporting <sil=0.996> .PERIOD We won't use it
      thought <sil=0.939> !EXCLAMATIONMARK */

   nam = cc$rms_nam <sil=0.502> ;SEMICOLON fab <sil=0.935> .PERIOD fab$l_nam = &nam <sil=0.587> ;SEMICOLON nam <sil=0.902> .PERIOD nam$b_rss = sizeof( rssbuf ) <sil=0.606> ;SEMICOLON nam <sil=0.996> .PERIOD nam$l_rsa = (char *) &rssbuf <sil=0.548> ;SEMICOLON nam <sil=0.919> .PERIOD nam$b_ess = sizeof( essbuf ) <sil=0.494> ;SEMICOLON nam <sil=0.923> .PERIOD nam$l_esa = (char *) &essbuf <sil=0.382> ;SEMICOLON status = sys$create( &fab ) <sil=0.568> ;SEMICOLON if ( <sil=0.908> !EXCLAMATIONMARK (status&SS$_NORMAL))
      return( status ) <sil=0.472> ;SEMICOLON rab = cc$rms_rab <sil=0.332> ;SEMICOLON /* initialise the RAB */
   rab <sil=0.976> .PERIOD rab$b_mbf = 127 <sil=0.395> ;SEMICOLON rab <sil=0.943> .PERIOD rab$b_mbc = 127 <sil=0.558> ;SEMICOLON rab <sil=0.929> .PERIOD rab$l_rop = RAB$M_WBH|RAB$M_RAH <sil=0.468> ;SEMICOLON  <sil=0.649> ;SEMICOLON rab <sil=0.947> .PERIOD rab$l_fab = &fab <sil=0.471> ;SEMICOLON status1 = sys$connect( &rab ) <sil=0.449> ;SEMICOLON if ( <sil=0.865> !EXCLAMATIONMARK (status1&SS$_NORMAL)) {
      status = status1 <sil=0.561> ;SEMICOLON sys$close( &fab ) <sil=0.547> ;SEMICOLON } <sil=0.337> ;SEMICOLON return( status ) <sil=0.485> ;SEMICOLON }

/*---- Write a record to the file --------------------------------------------*/
int put_record( char *name <sil=0.367> ,COMMA char *phone )
{
   long int status <sil=0.305> ;SEMICOLON struct phone_r phonerec <sil=0.356> ;SEMICOLON /* End of declarations <sil=0.978> .PERIOD  <sil=0.488> .PERIOD  <sil=0.415> .PERIOD */

   strncpy( phonerec <sil=0.950> .PERIOD name <sil=0.488> ,COMMA name <sil=0.337> ,COMMA sizeof(phonerec <sil=0.995> .PERIOD name) ) <sil=0.442> ;SEMICOLON strncpy( phonerec <sil=0.981> .PERIOD phone <sil=0.397> ,COMMA phone <sil=0.423> ,COMMA sizeof(phonerec <sil=0.954> .PERIOD phone) ) <sil=0.451> ;SEMICOLON rab <sil=0.927> .PERIOD rab$w_rsz = sizeof( phonerec ) <sil=0.606> ;SEMICOLON rab <sil=0.973> .PERIOD rab$l_rbf = (char *) &phonerec <sil=0.439> ;SEMICOLON rab <sil=0.915> .PERIOD rab$b_rac = RAB$C_KEY <sil=0.526> ;SEMICOLON rab <sil=0.995> .PERIOD rab$l_rop |= RAB$M_UIF <sil=0.412> ;SEMICOLON status = sys$put( &rab ) <sil=0.634> ;SEMICOLON return( status ) <sil=0.384> ;SEMICOLON }

/*---- Look a record up by name ----------------------------------------------*/
int get_record( char *name <sil=0.513> ,COMMA struct phone_r *phonerec )
{
   long int status <sil=0.452> ;SEMICOLON /* End of declarations <sil=0.975> .PERIOD  <sil=0.466> .PERIOD  <sil=0.521> .PERIOD */

   rab <sil=0.940> .PERIOD rab$w_usz = sizeof( *phonerec ) <sil=0.524> ;SEMICOLON rab <sil=0.961> .PERIOD rab$l_ubf = (char *) phonerec <sil=0.321> ;SEMICOLON rab <sil=0.952> .PERIOD rab$b_ksz = strlen( name ) <sil=0.550> ;SEMICOLON rab <sil=0.941> .PERIOD rab$l_kbf = (char *) name <sil=0.311> ;SEMICOLON rab <sil=0.941> .PERIOD rab$b_krf = 0 <sil=0.489> ;SEMICOLON rab <sil=0.913> .PERIOD rab$b_rac = RAB$C_KEY <sil=0.330> ;SEMICOLON rab <sil=0.947> .PERIOD rab$l_rop |= RAB$M_UIF <sil=0.441> ;SEMICOLON status = sys$get( &rab ) <sil=0.633> ;SEMICOLON return( status ) <sil=0.603> ;SEMICOLON }

/*---- Main Program starts here ----------------------------------------------*/
int main( int argc <sil=0.606> ,COMMA char *argv[] )
{
   long int status <sil=0.359> ;SEMICOLON struct phone_r phn <sil=0.358> ;SEMICOLON /* End of declarations <sil=0.995> .PERIOD  <sil=0.429> .PERIOD  <sil=0.304> .PERIOD */
   
   printf("Creating phone <sil=0.909> .PERIOD dat <sil=0.987> .PERIOD  <sil=0.477> .PERIOD  <sil=0.526> .PERIOD \n") <sil=0.596> ;SEMICOLON status = create_file("phone <sil=0.993> .PERIOD dat") <sil=0.428> ;SEMICOLON if ( <sil=0.880> !EXCLAMATIONMARK (status&SS$_NORMAL)) lib$signal( status ) <sil=0.637> ;SEMICOLON printf("Add record NEILL - 555 555 1417\n") <sil=0.355> ;SEMICOLON status = put_record ("NEILL" <sil=0.363> ,COMMA "555 555 1417") <sil=0.391> ;SEMICOLON if ( <sil=0.863> !EXCLAMATIONMARK (status&SS$_NORMAL)) lib$signal( status ) <sil=0.443> ;SEMICOLON printf("Add record PHIL - 555 555 6506\n") <sil=0.483> ;SEMICOLON status = put_record ("PHIL" <sil=0.364> ,COMMA "555 555 6506") <sil=0.413> ;SEMICOLON if ( <sil=0.984> !EXCLAMATIONMARK (status&SS$_NORMAL)) lib$signal( status ) <sil=0.562> ;SEMICOLON printf("Look record for PHIL\n") <sil=0.484> ;SEMICOLON status = get_record ("PHIL" <sil=0.326> ,COMMA &phn) <sil=0.417> ;SEMICOLON if ( <sil=0.913> !EXCLAMATIONMARK (status&SS$_NORMAL)) {
      lib$signal( status ) <sil=0.494> ;SEMICOLON } else {
      printf("Found %s - %s\n" <sil=0.371> ,COMMA phn <sil=0.913> .PERIOD name <sil=0.525> ,COMMA phn <sil=0.943> .PERIOD phone ) <sil=0.329> ;SEMICOLON }

   status = close_file() <sil=0.346> ;SEMICOLON if ( <sil=0.909> !EXCLAMATIONMARK (status&SS$_NORMAL)) lib$signal (status) <sil=0.327> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.427> ;SEMICOLON }

This will write out a data file <sil=0.453> ,COMMA PHONE <sil=0.966> .PERIOD DAT <sil=0.622> ,COMMA then do a lookup and find a record keyed on the name <sil=0.911> .PERIOD Try expanding the file with a few more records <sil=0.301> ,COMMA and experiment with the lookup <sil=0.901> .PERIOD Use this file to create your own database <sil=0.610> ,COMMA with different types of keys <sil=0.923> .PERIOD Miscellaneous Library Routines
The C standard specifies that the following headers and their related library routines must be available:

       <assert <sil=0.998> .PERIOD h>        <locale <sil=0.950> .PERIOD h>        <stddef <sil=0.901> .PERIOD h>
       <ctype <sil=0.926> .PERIOD h>         <math <sil=0.986> .PERIOD h>          <stdio <sil=0.996> .PERIOD h>
       <errno <sil=0.938> .PERIOD h>         <setjmp <sil=0.991> .PERIOD h>        <stdlib <sil=0.910> .PERIOD h>
       <float <sil=0.976> .PERIOD h>         <signal <sil=0.937> .PERIOD h>        <string <sil=0.970> .PERIOD h>
       <limits <sil=0.964> .PERIOD h>        <stdarg <sil=0.921> .PERIOD h>        <time <sil=0.989> .PERIOD h>

Obviously you should avoid using these names for your own header files <sil=0.916> .PERIOD In addition <sil=0.497> ,COMMA C++ also has <new <sil=0.934> .PERIOD h> and <iostream <sil=0.947> .PERIOD h> <sil=0.998> ,COMMA so don't use these either <sil=0.999> .PERIOD There are far too many routines in the standard libraries for me to describe them all <sil=0.593> ,COMMA which is as good an excuse as any not to bother <sil=0.975> .PERIOD I will <sil=0.473> ,COMMA however <sil=0.986> ,COMMA present a few program examples or program fragments for the more commonly used routines <sil=0.963> .PERIOD You should refer to the DEC C Run Time Library Manual <sil=0.518> ,COMMA using BookReader or MGBOOK to get the latest version <sil=0.480> ,COMMA and familiarize yourself with what is available <sil=0.901> .PERIOD VMS provides several Unix style functions in <unixlib <sil=0.999> .PERIOD h> and <unixio <sil=0.961> .PERIOD h> <sil=0.967> .PERIOD To be strictly accurate <sil=0.637> ,COMMA these are nonportable <sil=0.424> ,COMMA but they are available on many Unix systems <sil=0.985> .PERIOD One such function is getenv <sil=0.499> ,COMMA which <sil=0.367> ,COMMA in Unix land <sil=0.375> ,COMMA gets the string value of "environment variables" <sil=0.592> ,COMMA which roughly correspond to DCL symbols <sil=0.405> ,COMMA or logicals names <sil=0.943> .PERIOD On the VAX or Alpha <sil=0.301> ,COMMA the getenv function first looks for a logical name match <sil=0.311> ,COMMA and returns the translation if it finds one <sil=0.623> ,COMMA else it looks for a local symbol with the same name and returns the definition <sil=0.494> ,COMMA or <sil=0.519> ,COMMA if that wasn't found it looks for a global symbol <sil=0.956> .PERIOD Compile and run "symbols <sil=0.984> .PERIOD c" and try defining MYSYM as a symbol <sil=0.553> ,COMMA and as a logical name <sil=0.595> ,COMMA and see what output you get <sil=0.971> .PERIOD /*---- Getting Symbols or Logical Names C Example ("symbols <sil=0.923> .PERIOD c") --------------*/

/* ANSI C Headers */
#include <stdio <sil=0.967> .PERIOD h>
#include <stdlib <sil=0.970> .PERIOD h>

/* Main Program starts here */
int main( int argc <sil=0.435> ,COMMA char *argv[] )
{
    char *s_ptr <sil=0.541> ;SEMICOLON /*  End of declarations <sil=0.948> .PERIOD  <sil=0.648> .PERIOD  <sil=0.516> .PERIOD */

    printf("MYSYM = \"%s\"\n" <sil=0.438> ,COMMA ( s_ptr = getenv("MYSYM")) <sil=0.998> ?QUESTIONMARK s_ptr : "" ) <sil=0.639> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.307> ;SEMICOLON }

Getting the time is another commonly required function <sil=0.513> ,COMMA and C provides a number of standard routines for this purpose <sil=0.902> .PERIOD An example program demonstrates the use of various time routines <sil=0.614> ,COMMA including strftime <sil=0.324> ,COMMA which is very flexible in letting you form a formatted time string <sil=0.930> .PERIOD /*---- Getting the time ("time <sil=0.988> .PERIOD c") -------------------------------------------*/

/* ANSI C Headers */
#include <stdio <sil=0.934> .PERIOD h>
#include <stdlib <sil=0.944> .PERIOD h>
#include <time <sil=0.984> .PERIOD h>

/* Main Program starts here */
int main( int argc <sil=0.372> ,COMMA char *argv[] )
{
    time_t c_time <sil=0.518> ;SEMICOLON struct tm *c_time_rec <sil=0.328> ;SEMICOLON char string[80] <sil=0.544> ;SEMICOLON /*  End of declarations <sil=0.920> .PERIOD  <sil=0.453> .PERIOD  <sil=0.318> .PERIOD */

/*  Get the current time */
    time(&c_time) <sil=0.367> ;SEMICOLON /* c_time now contains seconds since January 1 <sil=0.471> ,COMMA 1970 */

/*  Convert this to a string using the ctime() function */
    printf("%s\n" <sil=0.402> ,COMMA ctime( &c_time ) ) <sil=0.569> ;SEMICOLON /*  Split the time into it's components - hours <sil=0.324> ,COMMA minutes <sil=0.433> ,COMMA seconds etc <sil=0.903> .PERIOD */
    c_time_rec = localtime( &c_time ) <sil=0.395> ;SEMICOLON /*  Selectively copy day of week into string */
    strftime( string <sil=0.477> ,COMMA sizeof(string)-1 <sil=0.571> ,COMMA "Today is %A" <sil=0.445> ,COMMA c_time_rec ) <sil=0.456> ;SEMICOLON /*  Print out the day of the week */
    printf("%s\n" <sil=0.444> ,COMMA string ) <sil=0.500> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.591> ;SEMICOLON }

It is important to use the standard defined types for time variables <sil=0.374> ,COMMA like time_t <sil=0.512> ,COMMA and not use <sil=0.327> ,COMMA say <sil=0.647> ,COMMA unsigned int because "you know that's what it is" <sil=0.938> .PERIOD I say this because some systems are going to have a 2038 bug <sil=0.374> ,COMMA a bit like the millenium bug <sil=0.358> ,COMMA caused by the number of seconds since January 1 <sil=0.309> ,COMMA 1970 exceeding the storage capacity of the type currently used for time_t <sil=0.947> .PERIOD Compiler vendors might well change time_t to be something completely different in future <sil=0.384> ,COMMA like a 64 bit quantity or perhaps a structure <sil=0.923> .PERIOD If you have used time_t throughout your code <sil=0.586> ,COMMA a simple recompilation and relink will be all that you need to do <sil=0.524> ,COMMA and this will avoid your name being cursed by later generations of programmers <sil=0.350> ,COMMA or your being ejected into space by HAL <sil=0.339> ;SEMICOLON -)

String-to-number conversion is a topic that frequently crops up in the comp <sil=0.935> .PERIOD lang <sil=0.910> .PERIOD c Usenet news group <sil=0.948> .PERIOD You have already met sprintf <sil=0.506> ,COMMA which is the number-to-string converter <sil=0.953> .PERIOD Other functions <sil=0.535> ,COMMA like atoi and atof convert strings to ints and floats <sil=0.645> ,COMMA and strtod and strtol convert strings to double and long respectively <sil=0.937> .PERIOD Random integer numbers <sil=0.314> ,COMMA seeded using srand <sil=0.494> ,COMMA can be obtained using the rand function <sil=0.356> ,COMMA and if you want floating point numbers <sil=0.594> ,COMMA cast the result of rand to float and divide by the macro value RAND_MAX <sil=0.505> ,COMMA also cast to float <sil=0.909> .PERIOD Searching and sorting routines <sil=0.614> ,COMMA bsearch and qsort are also provided <sil=0.966> .PERIOD They expect you to pass a pointer to a function which is used to determine whether objects compare equal <sil=0.434> ,COMMA greater than or less than <sil=0.438> ,COMMA then they do the sorting or searching <sil=0.396> ,COMMA using your function for the comparison <sil=0.946> .PERIOD The equivalent of LIB$SPAWN is the system() function <sil=0.943> .PERIOD The argument is either a command shell command <sil=0.527> ,COMMA or NULL to test whether a command shell is available <sil=0.903> .PERIOD if ( system(NULL) ) {
/*     Do VMS command */
       system("DIRECTORY")
     } else {
       fprintf(stderr <sil=0.304> ,COMMA "Sorry - no command shell available <sil=0.894> !EXCLAMATIONMARK ") <sil=0.315> ;SEMICOLON }

The atexit function lets you register exit handlers in FILO order <sil=0.519> ,COMMA which are called when the program exits <sil=0.931> .PERIOD These are useful for tidying up resources <sil=0.321> ,COMMA even if some deeply nested subroutine calls exit() <sil=0.939> .PERIOD Handlers for other types of condition can be registered using the signal() function <sil=0.967> .PERIOD In Unix <sil=0.531> ,COMMA signals are a bit like AST notifications <sil=0.987> .PERIOD They range from SIGALRM <sil=0.499> ,COMMA which lets you know when an alarm set by the alarm function has gone off <sil=0.310> ,COMMA to SIGINT which can be used to trap Ctrl C <sil=0.925> .PERIOD A pair of functions <sil=0.326> ,COMMA setjmp and longjmp provide one of the nearest thing I have seen to the mythical "comefrom" statement <sil=0.986> !EXCLAMATIONMARK An example showing you how to trap Ctrl C will demonstrate <sil=0.997> .PERIOD This program includes <signal <sil=0.940> .PERIOD h> and <setjmp <sil=0.910> .PERIOD h> <sil=0.990> ,COMMA and stores the position to which we want to return in saved_position <sil=0.453> ,COMMA which is of type jmp_buf <sil=0.955> .PERIOD You should never actually "look" at this <sil=0.535> ,COMMA because it is only meaningful as an argument to longjmp <sil=0.998> .PERIOD The second parameter to longjmp is an non-zero integer <sil=0.433> ,COMMA which will be returned as the value of setjmp when we come back to it from the longjmp <sil=0.922> .PERIOD Called directly <sil=0.428> ,COMMA setjmp returns zero <sil=0.923> .PERIOD The example "signal <sil=0.913> .PERIOD c" should make signal handling and longjmping clearer <sil=0.983> .PERIOD /*---- Signal and longjmp Example ("signal <sil=0.999> .PERIOD c") -------------------------------*/

/* ANSI C Headers */
#include <setjmp <sil=0.955> .PERIOD h>
#include <signal <sil=0.976> .PERIOD h>
#include <stdio <sil=0.943> .PERIOD h>
#include <stdlib <sil=0.950> .PERIOD h>

#if defined( _WIN32 )
# include "windows <sil=0.996> .PERIOD h"
#endif

/* Defines and macros */
#define MAX_COUNT 5

/* Global variables */
jmp_buf saved_position <sil=0.314> ;SEMICOLON /* Function prototypes */
void ctrl_c_handler( int scode ) <sil=0.470> ;SEMICOLON /* Main Program starts here */
int main( int argc <sil=0.636> ,COMMA char *argv[] )
{
    int icount <sil=0.346> ;SEMICOLON /*  End of declarations <sil=0.978> .PERIOD  <sil=0.455> .PERIOD  <sil=0.523> .PERIOD */

    icount = 0 <sil=0.316> ;SEMICOLON signal( SIGINT <sil=0.548> ,COMMA ctrl_c_handler ) <sil=0.438> ;SEMICOLON if ( <sil=0.865> !EXCLAMATIONMARK setjmp(saved_position) ) {
      for ( <sil=0.301> ;SEMICOLON icount < MAX_COUNT <sil=0.546> ;SEMICOLON ++icount ) {
        printf("At main line - looping #%d - enter Ctrl/C\n" <sil=0.601> ,COMMA icount) <sil=0.517> ;SEMICOLON #if <sil=0.924> !EXCLAMATIONMARK defined( _WIN32 )
        sleep( 10 ) <sil=0.633> ;SEMICOLON #else
        Sleep( 10000 ) <sil=0.301> ;SEMICOLON #endif
      } <sil=0.548> ;SEMICOLON } else {
      printf("Returned from Ctrl C handler - exiting early\n") <sil=0.634> ;SEMICOLON }

    exit(EXIT_SUCCESS) <sil=0.478> ;SEMICOLON }

void ctrl_c_handler( int scode )
{
/*  End of declarations <sil=0.919> .PERIOD  <sil=0.483> .PERIOD  <sil=0.307> .PERIOD */

    if ( scode == SIGINT ) {
      printf("Handling Ctrl C - return to position saved by setjmp()\n") <sil=0.495> ;SEMICOLON longjmp( saved_position <sil=0.535> ,COMMA 1 ) <sil=0.515> ;SEMICOLON /* Use any non-zero number */
    } else {
      printf("Strange - Ctrl C handler called with wrong signal code <sil=0.860> !EXCLAMATIONMARK \n") <sil=0.642> ;SEMICOLON }
}

To get "signal <sil=0.956> .PERIOD c" to link properly <sil=0.418> ,COMMA you must compile it with /PREFIX=ALL to properly prefix the nonstandard function call to sleep <sil=0.600> ,COMMA a <unixlib <sil=0.969> .PERIOD h> function <sil=0.979> .PERIOD All the recognised RTL functions are actually prefixed with "DECC$" by the compiler <sil=0.575> ,COMMA and this allows the linker to find them automatically at link time <sil=0.964> .PERIOD It is a good idea to get into the habit of using /PREFIX=ALL because this will cause warnings to be issued at link time if you inadvertently name any of your own functions so as to clash with inbuilt ones <sil=0.928> .PERIOD This example works slightly differently under Windows <sil=0.441> ,COMMA because although the Ctrl C handler is called <sil=0.302> ,COMMA the program then exits (this is the documented behaviour) <sil=0.978> .PERIOD Finally <sil=0.520> ,COMMA I will present an example of a function that can be called with variable arguments <sil=0.964> .PERIOD The C syntax for variable arguments is to use three dots <sil=0.362> ,COMMA  <sil=0.993> .PERIOD  <sil=0.451> .PERIOD  <sil=0.398> .PERIOD  <sil=0.521> ,COMMA to represent the variable arguments <sil=0.942> .PERIOD You must however <sil=0.524> ,COMMA specify at least one argument at the start of the parameter list <sil=0.903> .PERIOD In one way <sil=0.480> ,COMMA <stdarg <sil=0.912> .PERIOD h> routines are rather inferior to the nonstandard <varargs <sil=0.939> .PERIOD h> routines <sil=0.512> ,COMMA available on Unix and VMS <sil=0.469> ,COMMA because the latter can tell you how many arguments were passed <sil=0.621> ,COMMA whereas the former makes you tell the function in some way <sil=0.459> ,COMMA like the "%" conversion characters in a printf format string does <sil=0.931> .PERIOD Y <sil=0.977> .PERIOD R <sil=0.939> .PERIOD L <sil=0.986> .PERIOD programmers - for some examples of the nonstandard varargs mechanism (which you should avoid using if at all possible) see SRC$OLB:PRINTFILE <sil=0.957> .PERIOD C and FIFO <sil=0.946> .PERIOD C in GNRC <sil=0.924> .PERIOD Here is an example program using the standard stdargs mechanism <sil=0.566> ,COMMA called "vargs <sil=0.988> .PERIOD c" <sil=0.542> .PERIOD /*---- Variable Arguments C Example ("vargs <sil=0.916> .PERIOD c") ------------------------------*/

/* ANSI C Headers */
#include <stdarg <sil=0.983> .PERIOD h>
#include <stdio <sil=0.989> .PERIOD h>
#include <stdlib <sil=0.907> .PERIOD h>

/* Defines and macros */
#define END 0

/* Function prototypes */
int add_some_ints( int first <sil=0.330> ,COMMA  <sil=0.968> .PERIOD  <sil=0.483> .PERIOD  <sil=0.616> .PERIOD ) <sil=0.504> ;SEMICOLON /* Main Program starts here */
int main( int argc <sil=0.353> ,COMMA char *argv[] )
{
    int total <sil=0.422> ;SEMICOLON /*  End of declarations <sil=0.996> .PERIOD  <sil=0.462> .PERIOD  <sil=0.372> .PERIOD */

    total = add_some_ints( 1 <sil=0.394> ,COMMA 2 <sil=0.380> ,COMMA 3 <sil=0.360> ,COMMA 4 <sil=0.547> ,COMMA END) <sil=0.622> ;SEMICOLON printf("Total was %d\n" <sil=0.376> ,COMMA total ) <sil=0.517> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.344> ;SEMICOLON }

/*---- Rather pathetic function to add up some integers ----------------------*/
int add_some_ints( int first <sil=0.415> ,COMMA  <sil=0.928> .PERIOD  <sil=0.587> .PERIOD  <sil=0.316> .PERIOD )
{
    va_list ap <sil=0.567> ;SEMICOLON /* Use to point to each argument in turn */
    int inext <sil=0.350> ,COMMA sum <sil=0.449> ,COMMA icount <sil=0.403> ;SEMICOLON /*  End of declarations <sil=0.959> .PERIOD  <sil=0.643> .PERIOD  <sil=0.333> .PERIOD */

    icount = 1 <sil=0.413> ;SEMICOLON sum = first <sil=0.540> ;SEMICOLON va_start( ap <sil=0.484> ,COMMA first ) <sil=0.425> ;SEMICOLON /* Use last named argument - first in this case */

/*  End of args is marked by END <sil=0.438> ,COMMA which is zero */

    while ( inext = va_arg( ap <sil=0.418> ,COMMA int ) )  {    /* Second arg of va_arg is type */
     sum += inext <sil=0.390> ;SEMICOLON ++icount <sil=0.461> ;SEMICOLON }
    va_end( ap ) <sil=0.544> ;SEMICOLON /* Tidy up */

    printf("add_some_ints added %d integers\n" <sil=0.573> ,COMMA icount ) <sil=0.475> ;SEMICOLON return( sum ) <sil=0.378> ;SEMICOLON }

The best way to find out about the run time library functions is to look them up in K&R <sil=0.403> ,COMMA or with VMS HELP <sil=0.396> ,COMMA then have a go at using them <sil=0.966> .PERIOD Obfuscation
Obfuscation is the art of writing C so that no-one <sil=0.573> ,COMMA including the author <sil=0.552> ,COMMA has a clue what is going on <sil=0.920> .PERIOD Many people have been practising this for years in Fortran <sil=0.362> ,COMMA but C's #define definitely gives you the extra scope to really muddy the water <sil=0.955> .PERIOD Here are some examples taken from comp <sil=0.958> .PERIOD lang <sil=0.998> .PERIOD c <sil=0.910> ,COMMA compiled by conrad@student <sil=0.993> .PERIOD uni-kl <sil=0.934> .PERIOD de (Peter Conrad) <sil=0.603> ,COMMA of the contest to find the shortest C program to count from a given number i1 up to or down to a second number <sil=0.312> ,COMMA i2 <sil=0.985> .PERIOD To compile these you will need to use CC/DEFINE="o(arg)=printf(""%d"" <sil=0.422> ,COMMA arg)" <sil=0.349> ,COMMA which is a bit of a cheat <sil=0.906> .PERIOD In no particular order (they are all 69 bytes):

[01] main(a <sil=0.320> ,COMMA y <sil=0.608> ,COMMA d)int*y <sil=0.502> ;SEMICOLON {for(a=atoi(y[1]) <sil=0.590> ;SEMICOLON o(a) <sil=0.429> ,COMMA d=atoi(y[2])-a <sil=0.303> ;SEMICOLON )a+=(d|1)%2 <sil=0.607> ;SEMICOLON }
[02] main(c <sil=0.633> ,COMMA v <sil=0.352> ,COMMA x)int*v <sil=0.634> ;SEMICOLON {for(c=atoi(v[1]) <sil=0.624> ;SEMICOLON o(c) <sil=0.562> ,COMMA x=atoi(v[2])-c <sil=0.314> ;SEMICOLON c+=(x|1)%2) <sil=0.649> ;SEMICOLON }
[03] main(a <sil=0.415> ,COMMA v)int*v <sil=0.385> ;SEMICOLON {for(a=atoi(*++v) <sil=0.449> ;SEMICOLON o(a) <sil=0.497> ,COMMA *v=atoi(v[1])-a <sil=0.443> ;SEMICOLON a+=*v>>31|1) <sil=0.476> ;SEMICOLON }
[04] main(i <sil=0.632> ,COMMA v <sil=0.497> ,COMMA j)int*v <sil=0.410> ;SEMICOLON {for(i=atoi(v[1]) <sil=0.361> ;SEMICOLON o(i) <sil=0.570> ,COMMA j=atoi(v[2])-i <sil=0.393> ;SEMICOLON i+=(j|1)%2) <sil=0.589> ;SEMICOLON }
[05] main(c <sil=0.399> ,COMMA d){int*v=d <sil=0.601> ;SEMICOLON for(c=atoi(v[1]) <sil=0.626> ;SEMICOLON o(c) <sil=0.517> ,COMMA d=atoi(v[2])-c <sil=0.466> ;SEMICOLON c+=d>>31|1) <sil=0.629> ;SEMICOLON }
[06] main(d <sil=0.319> ,COMMA O <sil=0.310> ,COMMA _)int*O <sil=0.459> ;SEMICOLON {for(_=atoi(O[1]) <sil=0.573> ;SEMICOLON o(_) <sil=0.522> ,COMMA d=_-atoi(O[2]) <sil=0.500> ;SEMICOLON _-=d>>-1|1) <sil=0.509> ;SEMICOLON }
[07] main(a <sil=0.643> ,COMMA v)int*v <sil=0.344> ;SEMICOLON {for(a=atoi(v[1]) <sil=0.492> ;SEMICOLON o(a) <sil=0.329> ,COMMA *v=atoi(v[2])-a <sil=0.363> ;SEMICOLON a+=*v>>31|1) <sil=0.456> ;SEMICOLON }
[08] main(a <sil=0.634> ,COMMA b)int*b <sil=0.345> ;SEMICOLON {for(a=atoi(*++b) <sil=0.573> ;SEMICOLON o(a) <sil=0.527> ,COMMA *b=atoi(b[1])-a <sil=0.572> ;SEMICOLON a+=(*b|1)%2) <sil=0.378> ;SEMICOLON }
[09] main(a <sil=0.406> ,COMMA b)int*b <sil=0.558> ;SEMICOLON {for(a=atoi(b[1]) <sil=0.387> ;SEMICOLON o(a) <sil=0.624> ,COMMA *b=atoi(b[2])-a <sil=0.332> ;SEMICOLON a+=*b>>31|1) <sil=0.515> ;SEMICOLON }
[10] main(J <sil=0.377> ,COMMA _)int*_ <sil=0.391> ;SEMICOLON {for(J=atoi(*++_) <sil=0.318> ;SEMICOLON o(J) <sil=0.611> ,COMMA *_=atoi(_[1])-J <sil=0.630> ;SEMICOLON J+=(*_|1)%2) <sil=0.525> ;SEMICOLON }
[11] main(i <sil=0.553> ,COMMA b <sil=0.438> ,COMMA j)int*b <sil=0.478> ;SEMICOLON {for(i=atoi(b[1]) <sil=0.552> ;SEMICOLON o(i) <sil=0.583> ,COMMA j=i-atoi(b[2]) <sil=0.529> ;SEMICOLON i-=j>>31|1) <sil=0.515> ;SEMICOLON }
[12] main(k <sil=0.542> ,COMMA j <sil=0.335> ,COMMA i)int*j <sil=0.313> ;SEMICOLON {for(k=atoi(j[1]) <sil=0.581> ;SEMICOLON o(k) <sil=0.646> ,COMMA i=atoi(j[2])-k <sil=0.539> ;SEMICOLON k+=(i|1)%2) <sil=0.347> ;SEMICOLON }
[13] main(n <sil=0.503> ,COMMA a <sil=0.318> ,COMMA e)int*a <sil=0.437> ;SEMICOLON {for(n=atoi(a[1]) <sil=0.433> ;SEMICOLON o(n) <sil=0.449> ,COMMA e=atoi(a[2])-n <sil=0.581> ;SEMICOLON n+=e>>31|1) <sil=0.318> ;SEMICOLON }
[14] a <sil=0.349> ;SEMICOLON main(c <sil=0.529> ,COMMA d)int*d <sil=0.406> ;SEMICOLON {for(a=atoi(d[1]) <sil=0.481> ;SEMICOLON o(a) <sil=0.574> ,COMMA c=atoi(d[2])-a <sil=0.328> ;SEMICOLON a+=(c|1)%2) <sil=0.360> ;SEMICOLON }
[15] main(n <sil=0.546> ,COMMA c <sil=0.966> ,COMMA d)int*c <sil=0.531> ;SEMICOLON {for(n=atoi(c[1]) <sil=0.467> ;SEMICOLON o(n) <sil=0.533> ,COMMA d=atoi(c[2])-n <sil=0.488> ;SEMICOLON n+=d>>31|1) <sil=0.326> ;SEMICOLON }
[16] main(d <sil=0.357> ,COMMA a)int*a <sil=0.419> ;SEMICOLON {for(d=atoi(a[1]) <sil=0.578> ;SEMICOLON o(d) <sil=0.488> ,COMMA *a=atoi(a[2])-d <sil=0.600> ;SEMICOLON d+=(*a|1)%2) <sil=0.496> ;SEMICOLON }
[17] *p <sil=0.576> ;SEMICOLON main(i <sil=0.612> ,COMMA x){for(i=atoi((p=x)[1]) <sil=0.607> ;SEMICOLON o(i) <sil=0.520> ,COMMA x=atoi(p[2])-i <sil=0.485> ;SEMICOLON x>0 <sil=0.878> ?QUESTIONMARK i++:i--) <sil=0.561> ;SEMICOLON }
[18] main(c <sil=0.327> ,COMMA v <sil=0.433> ,COMMA d)int*v <sil=0.386> ;SEMICOLON {for(c=atoi(v[1]) <sil=0.541> ;SEMICOLON o(c) <sil=0.614> ,COMMA d=atoi(v[2])-c <sil=0.628> ;SEMICOLON c+=d>>31|1) <sil=0.431> ;SEMICOLON }
[19] main(c <sil=0.534> ,COMMA v <sil=0.318> ,COMMA d)int*v <sil=0.560> ;SEMICOLON {for(c=atoi(v[1]) <sil=0.491> ;SEMICOLON d <sil=0.315> ;SEMICOLON o(d>0 <sil=0.983> ?QUESTIONMARK c++:c--))d=atoi(v[2])-c <sil=0.354> ;SEMICOLON }
These are the winners of the 1 <sil=0.964> .PERIOD Int'l Kaiserslautern Shortest C Contest (the numbers refer to the programs above):

[01] Lars C <sil=0.992> .PERIOD Hassing <lch@cci <sil=0.913> .PERIOD dk>
[02] Stefan Bock <sbock@informatik <sil=0.969> .PERIOD uni-kl <sil=0.903> .PERIOD de>
[03] Heather Downs <heathbar@natasha <sil=0.915> .PERIOD tele <sil=0.926> .PERIOD iastate <sil=0.936> .PERIOD edu>
[04] Patrick Seemann <tele@tubul <sil=0.960> .PERIOD limmat <sil=0.971> .PERIOD net <sil=0.974> .PERIOD ch>
[05] Roland Nagel <nagel@informatik <sil=0.916> .PERIOD uni-kl <sil=0.951> .PERIOD de>
[06] Klaus Singvogel <kssingvo@immd4 <sil=0.978> .PERIOD informatik <sil=0.909> .PERIOD uni-erlangen <sil=0.946> .PERIOD de> <sil=0.419> ,COMMA Michael Schroeder <mlschroe@faui43 <sil=0.984> .PERIOD informatik <sil=0.990> .PERIOD uni-erlangen <sil=0.999> .PERIOD de> <sil=0.594> ,COMMA Markus Kuhn <mskuhn@cip <sil=0.904> .PERIOD informatik <sil=0.986> .PERIOD uni-erlangen <sil=0.924> .PERIOD de>
[07] Markus Simmer <simmer@iml <sil=0.980> .PERIOD fhg <sil=0.965> .PERIOD de>
[08] Willy Seibert <ws@osix <sil=0.916> .PERIOD materna <sil=0.904> .PERIOD de>
[09] Oliver Bianzano <oli@ap-pc818c <sil=0.997> .PERIOD physik <sil=0.989> .PERIOD uni-karlsruhe <sil=0.926> .PERIOD de>
[10] Jens Schweikhardt <jenssch@ibhinfo <sil=0.961> .PERIOD hemminger-gdv <sil=0.962> .PERIOD de>
[11] Thomas Omerzu <omerzu@quantum <sil=0.965> .PERIOD de> <sil=0.454> ,COMMA Matthias Sachs <sachs@quantum <sil=0.942> .PERIOD de> <sil=0.366> ,COMMA Udo Salewski <salewski@quantum <sil=0.941> .PERIOD de>
[12] Jahn Rentmeister <WIJARE@wi <sil=0.965> .PERIOD uni-muenster <sil=0.917> .PERIOD de>
[13] Gregor Hoffleit <flight@mathi <sil=0.969> .PERIOD uni-heidelberg <sil=0.987> .PERIOD de>
[14] John Rochester <jr@cs <sil=0.909> .PERIOD mun <sil=0.937> .PERIOD ca>
[15] Markus Siegert <siegertm@nemeter <sil=0.939> .PERIOD dinoco <sil=0.972> .PERIOD de>
[16] Siegmar Zaeske <zaeske@detlef <sil=0.999> .PERIOD informatik <sil=0.980> .PERIOD uni-dortmund <sil=0.933> .PERIOD de>
[17] Arnd Gerns <gerns@informatik <sil=0.934> .PERIOD uni-hildesheim <sil=0.975> .PERIOD de> <sil=0.486> ,COMMA Dirk Eiden <eiden@informatik <sil=0.938> .PERIOD uni-hildesheim <sil=0.916> .PERIOD de> <sil=0.600> ,COMMA Steffen Moeller <moeller@informatik <sil=0.988> .PERIOD uni-hildesheim <sil=0.991> .PERIOD de>
[18] James C <sil=0.945> .PERIOD Hu <jxh@pride <sil=0.927> .PERIOD cs <sil=0.988> .PERIOD wustl <sil=0.930> .PERIOD edu>
[19] Frank Neblung <neblung@informatik <sil=0.922> .PERIOD uni-kl <sil=0.903> .PERIOD de>
I think you would agree that these would not be much fun to maintain <sil=0.904> !EXCLAMATIONMARK Another favourite pastime for obfuscators is the self-producing program <sil=0.988> .PERIOD Here is one of my favourites - strictly ANSI compliant <sil=0.588> ,COMMA including all headers <sil=0.543> ,COMMA by Ashley Roll <sil=0.959> .PERIOD #include <stdio <sil=0.945> .PERIOD h> /* Ashley Roll aroll@gucis <sil=0.931> .PERIOD cit <sil=0.977> .PERIOD gu <sil=0.924> .PERIOD edu <sil=1.000> .PERIOD au */
main(){char *s <sil=0.319> ,COMMA *a <sil=0.322> ,COMMA *t <sil=0.441> ;SEMICOLON for(t=s="7}|wzarq6*gbr}{<~ <sil=0.436> ,COMMA 6 <sil=0.523> ;SEMICOLON @6Ug~zqm6H{zz6uh{zzVsaw}g<\\\
w}b<sa<qra<ua6@ <sil=0.320> ;SEMICOLON yu}|>=ow~uh6@g:@u:@b/t{h>b)g)8_8/@g/g <sil=0.860> ?QUESTIONMARK  <sil=0.318> ?QUESTIONMARK = }t>@g))3K3=t{h>u)b\\\
/@u/u <sil=0.905> ?QUESTIONMARK  <sil=0.602> ?QUESTIONMARK =o@u))3JJ3+fh}|bt>8JJJJJJJ|8=0fabw~uh>@u=/i qzgq@g5)3JJ3+fabw~uh>@g9%\\\
L(%=0%/i6 <sil=0.415> ;SEMICOLON @6Sh}tt}b~6A|}dqhg}bm:6Xh}gxu|q6Uagbhuz}u6@ <sil=0.336> ;SEMICOLON " <sil=0.611> ;SEMICOLON *s <sil=0.405> ;SEMICOLON s++)
if(*s=='_')for(a=t <sil=0.452> ;SEMICOLON *a <sil=0.436> ;SEMICOLON a++){*a=='\\' <sil=0.959> ?QUESTIONMARK printf("\\\\\\\n"):putchar(*a) <sil=0.499> ;SEMICOLON }
else*s <sil=0.908> !EXCLAMATIONMARK ='\\' <sil=0.964> ?QUESTIONMARK putchar(*s-1^21):1 <sil=0.486> ;SEMICOLON } /* Griffith University <sil=0.451> ,COMMA Brisbane Australia */

This is in the course directory <sil=0.497> ,COMMA called "self <sil=0.934> .PERIOD c" <sil=0.615> .PERIOD As a final treat <sil=0.590> ,COMMA here is a festive Christmas program <sil=0.382> ,COMMA "xmas <sil=0.993> .PERIOD c" <sil=0.584> ,COMMA by eeibht@eeiud <sil=1.000> .PERIOD ericsson <sil=0.962> .PERIOD se (Brendan Hassett) <sil=0.623> ,COMMA based on the more traditional <sil=0.581> ,COMMA but equally obfuscated program by Ian Phillipps <sil=0.916> .PERIOD /*
From: eeibht@eeiud <sil=0.966> .PERIOD ericsson <sil=0.991> .PERIOD se (Brendan Hassett)
+------------------------------------------------------------------+
| Brendan Hassett      Tel +353-902-74601 ext 1109    ECN 830-1109 |
| eeibht@eeiud <sil=0.952> .PERIOD ericsson <sil=0.935> .PERIOD se   EEI <sil=0.907> .PERIOD EEIBHT@memo <sil=0.956> .PERIOD ericsson <sil=0.925> .PERIOD se     ~~~   |
| Ericsson Systems Expertise Ltd <sil=0.615> ,COMMA Athlone <sil=0.512> ,COMMA Ireland <sil=0.628> ,COMMA EU <sil=0.910> .PERIOD ( o o ) |
+--------------------------------------------------------ooO-(_)-Ooo
#include <disclaimer <sil=0.905> .PERIOD h>
*/

/*
  Based on an original program by Ian Phillipps <sil=0.619> ,COMMA Cambridge Consultants Ltd <sil=0.981> .PERIOD  <sil=0.581> ,COMMA Cambridge <sil=0.301> ,COMMA England
*/

#include <stdio <sil=0.913> .PERIOD h>
#define __ main

__(t <sil=0.404> ,COMMA _ <sil=0.353> ,COMMA a)
char
*
a <sil=0.556> ;SEMICOLON {
	return <sil=0.942> !EXCLAMATIONMARK 0<t <sil=0.965> ?QUESTIONMARK t<3 <sil=0.927> ?QUESTIONMARK __(-79 <sil=0.458> ,COMMA -13 <sil=0.360> ,COMMA a+
__(-87 <sil=0.548> ,COMMA 1-_ <sil=0.506> ,COMMA __(-86 <sil=0.644> ,COMMA 0 <sil=0.465> ,COMMA a+1 )


+a)):

1 <sil=0.598> ,COMMA t<_ <sil=0.988> ?QUESTIONMARK __(t+1 <sil=0.573> ,COMMA _ <sil=0.558> ,COMMA a )
:3 <sil=0.476> ,COMMA __ ( -94 <sil=0.520> ,COMMA -27+t <sil=0.601> ,COMMA a )
&&t == 2 <sil=0.934> ?QUESTIONMARK _
<13 <sil=0.941> ?QUESTIONMARK __ ( 2 <sil=0.627> ,COMMA _+1 <sil=0.640> ,COMMA "%s %d %d\n" )

:9:16:
t<0 <sil=0.999> ?QUESTIONMARK t<-72 <sil=0.937> ?QUESTIONMARK __( _ <sil=0.457> ,COMMA t <sil=0.571> ,COMMA "k <sil=0.427> ,COMMA #n'+ <sil=0.636> ,COMMA #'/\
*{}w+/\
w#cdnr/\
+ <sil=0.641> ,COMMA {}r/\
*de}+ <sil=0.437> ,COMMA /\
*{*+ <sil=0.617> ,COMMA /\
w{%+ <sil=0.363> ,COMMA /\
w#q#n+ <sil=0.535> ,COMMA /\
#{l <sil=0.422> ,COMMA + <sil=0.443> ,COMMA /\
n{n+ <sil=0.612> ,COMMA /\
+#n+ <sil=0.507> ,COMMA /# <sil=0.593> ;SEMICOLON \
#q#n+ <sil=0.320> ,COMMA /\
+k# <sil=0.559> ;SEMICOLON *+ <sil=0.492> ,COMMA /\
'-el' ))# }#r]'K:'K n l#}'w {r'+d'K# <sil=0.883> !EXCLAMATIONMARK /\
+# <sil=0.622> ;SEMICOLON  <sil=0.400> ;SEMICOLON '+ <sil=0.612> ,COMMA #K'{+w' '*# +e}#] <sil=0.885> !EXCLAMATIONMARK /\
w :'{+w'nd+'we))d}+#r] <sil=0.893> !EXCLAMATIONMARK /\
c <sil=0.486> ,COMMA nl#'+ <sil=0.649> ,COMMA #'rdceK#n+ +{dn] <sil=0.925> !EXCLAMATIONMARK /\
- <sil=0.394> ;SEMICOLON K#'{+'dn'+ <sil=0.521> ,COMMA #' <sil=0.380> ,COMMA }rk }#] <sil=0.933> !EXCLAMATIONMARK /\
*{nr' 'k :' }denr'{+] <sil=0.863> !EXCLAMATIONMARK /\
w :'+ <sil=0.463> ,COMMA #:'n##r' n'e)l} r#] <sil=0.941> !EXCLAMATIONMARK /\
}#{nw+ <sil=0.349> ;SEMICOLON  <sil=0.406> ;SEMICOLON '+ <sil=0.559> ,COMMA #'wd*+k }#] <sil=0.917> !EXCLAMATIONMARK /\
 w['*d}' 'reK)] <sil=0.999> !EXCLAMATIONMARK /\
ew#' 'r#-ell#}] <sil=0.912> !EXCLAMATIONMARK /\
+}:'+d'}#)}drec#'{+] <sil=0.963> !EXCLAMATIONMARK /\
 w['+ <sil=0.362> ,COMMA #K' <sil=0.350> ,COMMA dk'+ <sil=0.480> ,COMMA #:'r{r'{+] <sil=0.884> !EXCLAMATIONMARK /\
w##'{*'{+' <sil=0.448> ,COMMA ))#nw' l {n( <sil=0.985> !EXCLAMATIONMARK  <sil=0.365> !EXCLAMATIONMARK /")
:
t<-50 <sil=0.987> ?QUESTIONMARK _==*a <sil=0.965> ?QUESTIONMARK putchar(a[31]):

__(-65 <sil=0.437> ,COMMA _ <sil=0.503> ,COMMA a+1)
:
__((*a == '/') + t <sil=0.438> ,COMMA _ <sil=0.390> ,COMMA a + 1 )
:

0<t <sil=0.996> ?QUESTIONMARK __ ( 2 <sil=0.523> ,COMMA 2 <sil=0.493> ,COMMA "%s")
:*a=='/'||

__(0 <sil=0.359> ,COMMA __(-61 <sil=0.559> ,COMMA *a <sil=0.550> ,COMMA " <sil=0.909> !EXCLAMATIONMARK ek <sil=0.573> ;SEMICOLON dc i@bK'(q)-[w]*\
%n+r3#l <sil=0.647> ,COMMA {}:\nuwloca-O\ <sil=0.641> ;SEMICOLON m <sil=0.947> .PERIOD vpbks <sil=0.620> ,COMMA fxntdCeghiry") <sil=0.381> ,COMMA a+1) <sil=0.592> ;SEMICOLON }

Beat that <sil=0.907> .PERIOD This evokes a slight whinge in DEC C's strictest ANSI mode <sil=0.536> ,COMMA because main takes more than two parameters <sil=0.435> ,COMMA but compile <sil=0.340> ,COMMA link <sil=0.454> ,COMMA run and enjoy <sil=0.962> !EXCLAMATIONMARK Changing from VAX C or K&R C to ANSI Compliant DEC C
The main change with DEC C for VAX or Alpha is that it is much stricter than K&R/VAX C <sil=0.963> .PERIOD I have found this to be a very good thing (apart from the pain of bug fixing <sil=0.892> !EXCLAMATIONMARK ) because it has brought to light hitherto undiscovered errors - the type of thing that causes intermittent faults <sil=0.914> !EXCLAMATIONMARK You tend to get a lot of informational messages about "implicitly declared functions" (like exit) where people have been lazy and not included <stdlib <sil=0.927> .PERIOD h> and <stdio <sil=0.949> .PERIOD h> <sil=0.972> .PERIOD You can always turn informational warnings off <sil=0.527> ,COMMA but this is a bit suspect because you then don't get alerted to other problems that might be important <sil=0.973> .PERIOD I usually just ensure that every bit of code has

#include <stdlib <sil=0.911> .PERIOD h>
#include <stdio <sil=0.995> .PERIOD h>

at the top <sil=0.993> .PERIOD Make sure that all exit()s are exit(EXIT_SUCCESS) or exit(EXIT_FAILURE) <sil=0.968> .PERIOD Avoid "magic number" exit codes <sil=0.929> .PERIOD Unix programmers often think that everyone understands that exit(0) means no problems <sil=0.345> ,COMMA and often don't use the ANSI exit(EXIT_SUCCESS) which will be correct for any O <sil=0.922> .PERIOD S <sil=0.906> .PERIOD  <sil=0.626> .PERIOD If you specifically want to return a VMS status (other than normal successful completion) then use #ifdef __VMS for the VMS specific part where possible <sil=0.984> .PERIOD In a nutshell <sil=0.462> ,COMMA make sure that you write ANSI C <sil=0.918> .PERIOD All the programs that I have converted to ANSI C have still worked under VAX C <sil=0.538> ,COMMA provided I use #pragma in certain places (see later) <sil=0.941> .PERIOD I prefer #pragma solutions to just adding global qualifiers <sil=0.554> ,COMMA because they are closer to the machine-specific code <sil=0.628> ,COMMA and flag the fact that you are doing something special <sil=0.995> .PERIOD Using Object Libraries
On VMS platforms you might well be putting several main programs in one library and hence want to use the MAIN_PROGRAM macro to show that myprog( <sil=0.962> .PERIOD  <sil=0.495> .PERIOD  <sil=0.547> .PERIOD ) is really main( <sil=0.946> .PERIOD  <sil=0.601> .PERIOD  <sil=0.357> .PERIOD ) <sil=0.930> .PERIOD The use of MAIN_PROGRAM is nonportable <sil=0.452> ,COMMA and hence the compiler will whinge <sil=0.915> .PERIOD Similarly you might be using variant_unions for <sil=0.310> ,COMMA say <sil=0.498> ,COMMA VMS item lists <sil=0.604> ,COMMA which are so VMS specific that you are happy to use the nonportable extension in that (limited) portion of code because it is convenient <sil=0.916> .PERIOD To stop complaints about this sort of thing <sil=0.545> ,COMMA I do the following (which works with VAX C and DEC C) <sil=0.961> .PERIOD  <sil=0.566> .PERIOD  <sil=0.326> .PERIOD #ifdef __VMS
#  ifdef __DECC
#    pragma message save
#    pragma message disable portable
#  endif

int myprog(int argc <sil=0.590> ,COMMA char *argv[])
MAIN_PROGRAM /* VMS specific macro to identify main() */

#  ifdef __DECC
#    pragma message restore
#  endif
#else

int main(int argc <sil=0.376> ,COMMA char *argv[]) /* Standard C version */

#endif

Here is an example of a VMS item list for system service calls <sil=0.992> .PERIOD  <sil=0.410> .PERIOD  <sil=0.353> .PERIOD #ifdef __DECC
# pragma message save
# pragma message disable portable
#endif
/*  VMS Item List structure */
struct item_list {
  variant_union {
    variant_struct {
      short int w_buflen <sil=0.634> ;SEMICOLON short int w_code <sil=0.421> ;SEMICOLON long int *l_bufptr <sil=0.362> ;SEMICOLON long int *l_retlenptr <sil=0.475> ;SEMICOLON } list_structure <sil=0.646> ;SEMICOLON int end_list <sil=0.442> ;SEMICOLON } whole_list <sil=0.479> ;SEMICOLON } <sil=0.484> ;SEMICOLON #ifdef __DECC
# pragma message restore
#endif

Obviously <sil=0.395> ,COMMA completely nonportable constructs should be used sparingly <sil=0.330> ,COMMA because although we have turned the error off <sil=0.448> ,COMMA they are still nonstandard <sil=0.944> !EXCLAMATIONMARK Structure Alignment
Watch out for arrays of structures <sil=0.381> ,COMMA or structures populated by data reads from disk <sil=0.931> .PERIOD DEC C for Alpha likes to have structure members aligned on natural boundaries which will confuse your code if (say) you read in from disk some data written out by a VAX C or DEC C on VAX program <sil=0.964> .PERIOD Make sure that structures like this are tightly packed <sil=0.937> .PERIOD I tend to do this <sil=0.959> .PERIOD  <sil=0.390> .PERIOD  <sil=0.377> .PERIOD /* Following structures MUST be packed tightly ie <sil=0.912> .PERIOD no member alignment */
#ifdef __DECC
# pragma member_alignment save /* Push current default alignment on to 'stack'*/
# pragma nomember_alignment
#endif

struct my_struct_s    my_struct <sil=0.349> ;SEMICOLON struct other_struct_s other_struct <sil=0.607> ;SEMICOLON #ifdef __DECC
# pragma member_alignment restore /* Restore previous default alignment */
#endif

Don't be tempted to force nomember_alignment for everything <sil=0.970> .PERIOD Restrict it to individual structures as shown above <sil=0.983> .PERIOD Imposing it globally is likely to cause performance penalties <sil=0.393> ,COMMA or mysterious crashes if you call routines that expect natural alignment <sil=0.904> .PERIOD Accessing Fortran Common Blocks
External models have changed between VAX C and DEC C <sil=0.584> ,COMMA so C code that accesses Fortran common blocks should beware <sil=0.952> .PERIOD On the Alpha <sil=0.570> ,COMMA the default for Fortran common blocks is now NOSHR <sil=0.958> .PERIOD VAX Fortran uses SHR as the default <sil=0.935> .PERIOD DEC C on the other hand <sil=0.427> ,COMMA wants RELAXED_REFDEF <sil=0.956> .PERIOD Try the following for a "normal" common block <sil=0.358> ,COMMA ie <sil=0.929> .PERIOD not a global section <sil=0.930> .PERIOD  <sil=0.395> .PERIOD  <sil=0.413> .PERIOD /* FORTRAN common blocks are extern to everything -----------------------*/
#ifdef __DECC
# pragma extern_model save
#endif

#ifdef __DECC
# ifdef __ALPHA
/* Default if not overridden by options file is NOSHR for Alpha Fortran common*/
#  pragma extern_model common_block noshr
# else
/* Default if not overridden by options file is SHR for VAX Fortran common */
#  pragma extern_model common_block shr
# endif
#endif

extern struct {
  int a <sil=0.500> ;SEMICOLON /* These names don't matter <sil=0.409> ,COMMA type/size must be correct */
  int b <sil=0.545> ;SEMICOLON int c <sil=0.614> ;SEMICOLON char string[40] <sil=0.460> ;SEMICOLON } COMBLK <sil=0.628> ;SEMICOLON /* Case matters if linker is case sensitive */

#ifdef __DECC
# pragma extern_model restore
#endif

Then if your Fortran common block looked like this <sil=0.907> .PERIOD  <sil=0.452> .PERIOD  <sil=0.650> .PERIOD *
*     Common:
*
      INTEGER A
      INTEGER B
      INTEGER C
      CHARACTER*40 STRING
      COMMON /COMBLK/ A <sil=0.348> ,COMMA B <sil=0.338> ,COMMA C <sil=0.369> ,COMMA STRING <sil=0.929> .PERIOD  <sil=0.625> .PERIOD  <sil=0.500> .PERIOD your C function would access the members thus


void SET_FORTRAN_COMMON(void)
{
    COMBLK <sil=0.957> .PERIOD a = 1 <sil=0.634> ;SEMICOLON COMBLK <sil=0.982> .PERIOD b = 2 <sil=0.584> ;SEMICOLON COMBLK <sil=0.902> .PERIOD c = 3 <sil=0.581> ;SEMICOLON sprintf(COMBLK <sil=0.980> .PERIOD string <sil=0.434> ,COMMA "Hello World") <sil=0.646> ;SEMICOLON }

Accessing Global Sections
If you were trying to access a global section <sil=0.617> ,COMMA named PATSEC in this example <sil=0.445> ,COMMA you would have to look at the options file to see the PSECT attributes (or if you were lucky <sil=0.359> ,COMMA the attributes might be specified in the <sil=0.941> .PERIOD CMN file itself with a $CDEC compiler directive) <sil=0.905> .PERIOD For PATSEC <sil=0.628> ,COMMA you need the NOSHR option <sil=0.935> .PERIOD  <sil=0.498> .PERIOD  <sil=0.335> .PERIOD #ifdef __DECC
# pragma extern_model common_block noshr
#endif <sil=0.940> .PERIOD extern struct {struct patsec patsec <sil=0.511> ;SEMICOLON } ZZZZ_PATSEC <sil=0.609> ;SEMICOLON  <sil=0.961> .PERIOD #ifdef __DECC
# pragma extern_model restore
#endif

Then you can refer to it like this <sil=0.934> .PERIOD  <sil=0.557> .PERIOD  <sil=0.476> .PERIOD num = ZZZZ_PATSEC <sil=0.964> .PERIOD patsec <sil=0.964> .PERIOD ckp <sil=0.943> .PERIOD apt[ndx-1] <sil=0.952> .PERIOD patrol <sil=0.470> ;SEMICOLON Here the common block _containing_ the patsec structure is called ZZZZ_PATSEC <sil=0.435> ,COMMA but we need to specify <sil=0.991> .PERIOD patsec even though the common block in that case only contains one item (Previous example had <sil=0.949> .PERIOD a <sil=0.609> ,COMMA  <sil=0.934> .PERIOD b <sil=0.571> ,COMMA  <sil=0.924> .PERIOD c and <sil=0.959> .PERIOD string) <sil=0.987> .PERIOD Passing Fortran style strings
Fortran expects strings to be passed by descriptor <sil=0.646> ,COMMA or <sil=0.421> ,COMMA more precisely <sil=0.575> ,COMMA it expects to receive the address of a descriptor <sil=0.408> ,COMMA which is a structure containing a pointer to a string <sil=0.423> ,COMMA its length and its type and class <sil=0.918> .PERIOD A string descriptor structure looks like this <sil=0.992> .PERIOD  <sil=0.457> .PERIOD  <sil=0.346> .PERIOD struct  dsc$descriptor_s
{
  unsigned short  dsc$w_length <sil=0.429> ;SEMICOLON /* length of data item in bytes <sil=0.578> ,COMMA or if dsc$b_dtype is DSC$K_DTYPE_V <sil=0.411> ,COMMA bits <sil=0.355> ,COMMA or if dsc$b_dtype is DSC$K_DTYPE_P <sil=0.602> ,COMMA digits (4 bits each) */
  unsigned char   dsc$b_dtype <sil=0.498> ;SEMICOLON /* data type code */
  unsigned char   dsc$b_class <sil=0.368> ;SEMICOLON /* descriptor class code = DSC$K_CLASS_S */
  char            *dsc$a_pointer <sil=0.364> ;SEMICOLON /* address of first byte of data storage */
} <sil=0.490> ;SEMICOLON It is often convenient to use the $DESCRIPTOR macro defined in >descrip <sil=0.993> .PERIOD h< to set up a descriptor <sil=0.999> .PERIOD This expects the address of the string to be _constant_ so you must declare the string referred to by the descriptor as static to avoid compilation warnings <sil=0.935> .PERIOD Example:


    static char user[16] <sil=0.301> ;SEMICOLON $DESCRIPTOR( user_dsc <sil=0.370> ,COMMA user ) <sil=0.400> ;SEMICOLON  <sil=0.948> .PERIOD istatus = CALL_FORTRAN_ROUTINE( &user_dsc ) <sil=0.410> ;SEMICOLON  <sil=0.936> .PERIOD Be aware that the $DESCRIPTOR macro will set the string length to be one less than sizeof(string) to allow for the fact that C may have a terminating null character <sil=0.902> .PERIOD Hence <sil=0.639> ,COMMA in the example above <sil=0.536> ,COMMA CALL_FORTRAN_ROUTINE will think it has been passed a CHARACTER*15 string <sil=0.940> .PERIOD VMS Message Codes
In Fortran we often use EXTERNAL CARS__ERROPEN to get the linker to pull in the correct message code as a "global value" <sil=0.920> .PERIOD In C <sil=0.498> ,COMMA this is how to do the same thing portably <sil=0.976> .PERIOD #ifdef __DECC
# pragma extern_model save
# pragma extern_model globalvalue
#else
# ifdef VAXC
#  define extern globalvalue
# endif
#endif

/* Put _declarations_ of message parameters here */
extern  cars__erropen <sil=0.517> ,COMMA cars__errconn <sil=0.586> ,COMMA cars__errread <sil=0.431> ,COMMA cars__errwrite <sil=0.496> ;SEMICOLON #ifdef __DECC
# pragma extern_model restore
#else
# ifdef VAXC
#  undef extern
# endif
#endif

If you wanted to use the same codes on a different machine <sil=0.332> ,COMMA you could then define the integer error code values in a separate <sil=0.980> .PERIOD c file and link against the error code object <sil=0.953> .PERIOD Why learn C <sil=0.896> ?QUESTIONMARK C is the most commonly used programming language for writing operating systems <sil=0.902> .PERIOD The first operating system written in C is Unix <sil=0.971> .PERIOD Later operating systems like GNU/Linux were all written in C <sil=0.900> .PERIOD Not only is C the language of operating systems <sil=0.458> ,COMMA it is the precursor and inspiration for almost all of the most popular high-level languages available today <sil=0.928> .PERIOD In fact <sil=0.538> ,COMMA Perl <sil=0.587> ,COMMA PHP <sil=0.532> ,COMMA Python and Ruby are all written in C <sil=0.926> .PERIOD By way of analogy <sil=0.611> ,COMMA let's say that you were going to be learning Spanish <sil=0.491> ,COMMA Italian <sil=0.608> ,COMMA French <sil=0.465> ,COMMA or Romanian <sil=0.905> .PERIOD Do you think knowing Latin would be helpful <sil=0.983> ?QUESTIONMARK Just as Latin was the basis of all of those languages <sil=0.595> ,COMMA knowing C will enable you to understand and appreciate an entire family of programming languages built upon the traditions of C <sil=0.986> .PERIOD Knowledge of C enables freedom <sil=0.917> .PERIOD Why C <sil=0.381> ,COMMA and not assembly language <sil=0.979> ?QUESTIONMARK While assembly language can provide speed and maximum control of the program <sil=0.644> ,COMMA C provides portability <sil=0.931> .PERIOD Different processors are programmed using different Assembly languages and having to choose and learn only one of them is too arbitrary <sil=0.974> .PERIOD In fact <sil=0.612> ,COMMA one of the main strengths of C is that it combines universality and portability across various computer architectures while retaining most of the control of the hardware provided by assembly language <sil=0.967> .PERIOD For example <sil=0.452> ,COMMA C programs can be compiled and run on the HP 50g calculator (ARM11 processor) <sil=0.537> ,COMMA the TI-89 calculator (6800012 processor) <sil=0.566> ,COMMA Palm OS Cobalt smartphones (ARM processor) <sil=0.510> ,COMMA the original iMac (PowerPC13) <sil=0.561> ,COMMA the Arduino (Atmel AVR14) <sil=0.639> ,COMMA and the Intel iMac (Intel15 Core 2 Duo) <sil=0.972> .PERIOD Each of these devices has its own assembly language that is completely incompatible with the assembly language of any other <sil=0.977> .PERIOD Assembly <sil=0.444> ,COMMA while extremely powerful <sil=0.404> ,COMMA is simply too difficult to program large applications and hard to read or interpret in a logical way <sil=0.953> .PERIOD C is a compiled language <sil=0.443> ,COMMA which creates fast and efficient executable files <sil=0.931> .PERIOD It is also a small “what you see is all you get” language: a C statement corresponds to at most a handful of assembly statements <sil=0.597> ,COMMA everything else is provided by library functions <sil=0.984> .PERIOD So is it any wonder that C is such a popular language <sil=0.973> ?QUESTIONMARK Like toppling dominoes <sil=0.634> ,COMMA the next generation of programs follows the trend of its ancestors <sil=0.962> .PERIOD Operating systems designed in C always have system libraries designed in C <sil=0.937> .PERIOD Those system libraries are in turn used to create higher-level libraries (like OpenGL <sil=0.380> ,COMMA or GTK) <sil=0.448> ,COMMA and the designers of those libraries often decide to use the language the system libraries used <sil=0.939> .PERIOD Application developers use the higher-level libraries to design word processors <sil=0.545> ,COMMA games <sil=0.569> ,COMMA media players and the like <sil=0.947> .PERIOD Many of them will choose to program in the language that the higher level library uses <sil=0.926> .PERIOD And the pattern continues on and on and on <sil=0.964> .PERIOD  <sil=0.400> .PERIOD  <sil=0.520> .PERIOD Why C <sil=0.399> ,COMMA and not another language <sil=0.996> ?QUESTIONMARK The primary design of C is to produce portable code while maintaining performance and minimizing footprint (CPU time <sil=0.305> ,COMMA memory usage <sil=0.553> ,COMMA disk I/O <sil=0.420> ,COMMA etc <sil=0.976> .PERIOD ) <sil=0.478> .PERIOD This is useful for operating systems <sil=0.560> ,COMMA embedded systems or other programs where performance matters a lot (“high-level” interface would affect performance) <sil=0.957> .PERIOD With C it’s relatively easy to keep a mental picture of what a given line really does <sil=0.337> ,COMMA because most of the things are written explicitly in the code <sil=0.980> .PERIOD C has a big codebase for low level applications <sil=0.943> .PERIOD It is the “native” language of UNIX <sil=0.635> ,COMMA which makes it flexible and portable <sil=0.944> .PERIOD It is a stable and mature language which is unlikely to disappear for a long time and has been ported to most <sil=0.648> ,COMMA if not all <sil=0.322> ,COMMA platforms <sil=0.935> .PERIOD One powerful reason is memory allocation <sil=0.997> .PERIOD Unlike most programming languages <sil=0.383> ,COMMA C allows the programmer to write directly to memory <sil=0.901> .PERIOD Key constructs in C such as structs <sil=0.548> ,COMMA pointers and arrays are designed to structure and manipulate memory in an efficient <sil=0.420> ,COMMA machine independent fashion <sil=0.944> .PERIOD In particular <sil=0.365> ,COMMA C gives control over the memory layout of data structures <sil=0.946> .PERIOD Moreover dynamic memory allocation is under the control of the programmer (which also means that memory deallocation has to be done by the programmer) <sil=0.967> .PERIOD Languages like Java and Perl shield the programmer from having to manage most details of memory allocation and pointers (except for memory leaks and some other forms of excess memory usage) <sil=0.984> .PERIOD This can be useful since dealing with memory allocation when building a high-level program is a highly error-prone process <sil=0.995> .PERIOD However <sil=0.455> ,COMMA when dealing with low-level code such as the part of the OS that controls a device <sil=0.471> ,COMMA C provides a uniform <sil=0.599> ,COMMA clean interface <sil=0.935> .PERIOD These capabilities just do not exist in most other languages <sil=0.929> .PERIOD While Perl <sil=0.440> ,COMMA PHP <sil=0.417> ,COMMA Python and Ruby may be powerful and support many features not provided by default in C <sil=0.632> ,COMMA they are not normally implemented in their own language <sil=0.956> .PERIOD Rather <sil=0.433> ,COMMA most such languages initially relied on being written in C (or another high-performance programming language) <sil=0.592> ,COMMA and would require their implementation be ported to a new platform before they can be used <sil=0.999> .PERIOD As with all programming languages <sil=0.414> ,COMMA whether you want to choose C over another high-level language is a matter of opinion and both technical and business requirements could dictate which language is required <sil=0.940> .PERIOD History 
The field of computing as we know it today started in 1947 with three scientists at Bell Telephone Laboratories—William Shockley <sil=0.614> ,COMMA Walter Brattain <sil=0.557> ,COMMA and John Bardeen —and their groundbreaking invention: the transistor <sil=0.949> .PERIOD In 1956 <sil=0.561> ,COMMA the first fully transistor-based computer <sil=0.551> ,COMMA the TX-0 <sil=0.581> ,COMMA was completed at MIT <sil=0.962> .PERIOD The first integrated circuit was created in 1958 by Jack Kilby at Texas Instruments <sil=0.403> ,COMMA but the first high-level programming language existed even before then <sil=0.930> .PERIOD ”The Fortran project” was originally developed in 1954 by IBM <sil=0.988> .PERIOD A shortening of ”The IBM Mathematical Formula Translating System” <sil=0.378> ,COMMA the project had the purpose of creating and fostering development of a procedural <sil=0.617> ,COMMA imperative programming language that was especially suited to numeric computation and scientific computing <sil=0.985> .PERIOD It was a breakthrough in terms of productivity and programming ease (compared to assembly language) and speed (Fortran programs ran nearly as fast as <sil=0.402> ,COMMA and in some cases <sil=0.302> ,COMMA just as fast as <sil=0.557> ,COMMA programs written in assembly) <sil=0.981> .PERIOD Furthermore <sil=0.642> ,COMMA Fortran was written at a high-enough level (and thus was machine independent enough) to become the first widely adopted programming language <sil=0.922> .PERIOD The Algorithmic Language (Algol 58) was derived from Fortran in 1958 and evolved into Algol 6010 in 1960 <sil=0.950> .PERIOD The Combined Programming Language (CPL) was then created out of Algol 60 in 1963 <sil=0.998> .PERIOD In 1967 <sil=0.622> ,COMMA it evolved into Basic CPL <sil=0.545> ,COMMA which was itself <sil=0.313> ,COMMA the base for B13 in 1969 <sil=0.934> .PERIOD Finally <sil=0.592> ,COMMA B <sil=0.494> ,COMMA the root of C <sil=0.553> ,COMMA was created in 1971 <sil=0.986> .PERIOD C was the direct successor of B <sil=0.634> ,COMMA a stripped down version of BCPL <sil=0.631> ,COMMA created by Ken Thompson at Bell Labs <sil=0.537> ,COMMA that was also a compiled language - User's Reference to B <sil=0.599> ,COMMA used in early internal versions of the UNIX operating system <sil=0.979> .PERIOD As noted in Ritchie's C History: ”The B compiler on the PDP-7 did not generate machine instructions <sil=0.497> ,COMMA but instead 'threaded code' <sil=0.370> ,COMMA an interpretive scheme in which the compiler's output consists of a sequence of addresses of code fragments that perform the elementary operations <sil=0.993> .PERIOD The operations typically — in particular for B — act on a simple stack machine” <sil=0.955> .PERIOD Thompson and Dennis Ritchie <sil=0.528> ,COMMA also working at Bell Labs <sil=0.301> ,COMMA improved B and called the result NB <sil=0.988> .PERIOD Further extensions to NB created its logical successor <sil=0.520> ,COMMA C <sil=0.934> .PERIOD Most of UNIX was rewritten in NB <sil=0.427> ,COMMA and then C <sil=0.610> ,COMMA which resulted in a more portable operating system <sil=0.907> .PERIOD The portability of UNIX was the main reason for the initial popularity of both UNIX and C <sil=0.960> .PERIOD Rather than creating a new operating system for each new machine <sil=0.599> ,COMMA system programmers could simply write the few system-dependent parts required for the machine <sil=0.440> ,COMMA and then write a C compiler for the new system <sil=0.948> .PERIOD Since most of the system utilities were thus written in C <sil=0.351> ,COMMA it simply made sense to also write new utilities in C <sil=0.964> .PERIOD The American National Standards Institute began work on standardizing the C language in 1983 <sil=0.608> ,COMMA and completed the standard in 1989 <sil=0.908> .PERIOD The standard <sil=0.617> ,COMMA ANSI X3 <sil=0.930> .PERIOD 159-1989 ”Programming Language C” <sil=0.517> ,COMMA served as the basis for all implementations of C compilers <sil=0.931> .PERIOD The standards were later updated in 1990 and 1999 <sil=0.544> ,COMMA allowing for features that were either in common use <sil=0.414> ,COMMA or were appearing in C++ <sil=0.924> .PERIOD What you need before you can learn
Getting Started
The goal of this book is to introduce you to and teach you the C programming language <sil=0.939> .PERIOD Basic computer literacy is assumed <sil=0.438> ,COMMA but no special knowledge is needed <sil=0.907> .PERIOD Before you can start programming in C <sil=0.480> ,COMMA you will need a C compiler <sil=0.994> .PERIOD A compiler is a program that converts C code into executable machine code <sil=0.975> .PERIOD The minimum software requirements to program in C is a text editor18 <sil=0.600> ,COMMA as opposed to a word processor <sil=0.920> .PERIOD A plain text Notepad editor can be used but it does not offer any advanced capabilities such as syntax highlighting and code completion <sil=0.958> .PERIOD There are many text editors (see List of Text Editors) <sil=0.638> ,COMMA among the most popular are Notepad++21 for Windows as well as Atom <sil=0.626> ,COMMA Sublime Text <sil=0.468> ,COMMA gedit <sil=0.520> ,COMMA Vim and Emacs which are also available on other operating systems (“cross-platform”) <sil=0.941> .PERIOD These text editors come with syntax highlighting and line numbers <sil=0.512> ,COMMA which makes code easier to read at a glance <sil=0.409> ,COMMA and to spot syntax errors <sil=0.949> .PERIOD Though not absolutely needed <sil=0.545> ,COMMA many programmers prefer and recommend using an Integrated development environment (IDE) instead of a text editor <sil=0.943> .PERIOD An IDE is a suite of programs that developers need <sil=0.552> ,COMMA combined into one convenient package <sil=0.477> ,COMMA usually with a graphical user interface <sil=0.934> .PERIOD These programs include a text editor and file browser and are sometimes bundled with an easily accessible compiler <sil=0.944> .PERIOD They also typically include a debugger <sil=0.318> ,COMMA a tool that will enable you to do such things as step through the program you develop manually one source code line at a time <sil=0.538> ,COMMA or alter data as an aid to finding and correcting programming errors <sil=0.938> .PERIOD Many IDEs do not offer their users a console-based interface to the compiler and for executing the developed program but offer only graphical buttons <sil=0.991> .PERIOD For beginners it is recommended not to use such an IDE <sil=0.536> ,COMMA since it hides most of what is going on <sil=0.964> .PERIOD Using the command line builds up familiarity with the toolchain <sil=0.984> .PERIOD Such an IDE may still be useful to somebody with programming experience who knows how the IDE works <sil=0.970> .PERIOD So as a general guideline: Do not use an IDE unless you know what the IDE does <sil=0.973> !EXCLAMATIONMARK On GNU/Linux <sil=0.430> ,COMMA GCC is almost always included by default <sil=0.942> .PERIOD On Microsoft Windows <sil=0.476> ,COMMA Dev-C++ is recommended for beginners because it is easy to use <sil=0.517> ,COMMA free <sil=0.647> ,COMMA and simple to install <sil=0.913> .PERIOD Although the initial developer (Bloodshed) hasn’t updated it since 2005 <sil=0.567> ,COMMA a new version appeared in 2011 <sil=0.618> ,COMMA made by an independent programmer <sil=0.596> ,COMMA and is being actively developed <sil=0.914> .PERIOD An alternate option for those working only in the Windows environment is the proprietary Microsoft Visual Studio Express which is free of charge and has an excellent debugger <sil=0.970> .PERIOD On Mac OS X <sil=0.547> ,COMMA the Xcode IDE provides the compilers needed to compile various source files <sil=0.912> .PERIOD The newer versions do not include the command line tools <sil=0.931> .PERIOD They need to be downloaded via Xcode->Preferences->Downloads <sil=0.912> .PERIOD Using a Compiler
Dev-C++
Dev C++ is an Integrated Development Environment (IDE) for the C++ programming language <sil=0.351> ,COMMA available from Bloodshed Software <sil=0.936> .PERIOD An updated version is available at Orwell Dev-C++ <sil=0.909> .PERIOD C++ is a programming language which contains within itself most of the C language <sil=0.543> ,COMMA plus extensions <sil=0.922> .PERIOD Most C++ compilers will compile C programs <sil=0.333> ,COMMA sometimes with a few adjustments (like invoking them with a different name or command line switch) <sil=0.993> .PERIOD Therefore <sil=0.634> ,COMMA you can use Dev C++ for C development <sil=0.979> .PERIOD However <sil=0.632> ,COMMA Dev C++ is not the compiler <sil=0.903> .PERIOD It is designed to use the MinGW or Cygwin versions of GCC - both of which can be obtained as part of the Dev C++ package <sil=0.444> ,COMMA although they are completely different projects <sil=0.943> .PERIOD Dev C++ simply provides an editor <sil=0.305> ,COMMA syntax highlighting <sil=0.432> ,COMMA some facilities for the visualisation of code (like class and package browsing) and a graphical interface to the chosen compiler <sil=0.987> .PERIOD Because Dev C++ analyses the error messages produced by the compiler and attempts to distinguish the line numbers from the errors themselves <sil=0.476> ,COMMA the use of other compiler software is discouraged since the format of their error messages is likely to be different <sil=0.976> .PERIOD The latest version of Dev-C++ is a beta for version 5 <sil=0.967> .PERIOD However <sil=0.603> ,COMMA it still has a significant number of bugs <sil=0.969> .PERIOD All the features are there <sil=0.492> ,COMMA and it is quite usable <sil=0.924> .PERIOD It is considered one of the best free software C IDEs available for Windows <sil=0.948> .PERIOD A version of Dev C++ for Linux is in the pipeline <sil=0.997> .PERIOD It is not quite usable yet <sil=0.364> ,COMMA however <sil=0.949> .PERIOD Linux users already have a wealth of IDEs available <sil=0.946> .PERIOD (e <sil=0.932> .PERIOD g <sil=0.957> .PERIOD KDevelop and Anjuta) <sil=0.960> .PERIOD Most of the graphical text editors <sil=0.543> ,COMMA and other common editors such as emacs and vim <sil=0.635> ,COMMA support syntax highlighting <sil=0.921> .PERIOD GCC The GNU Compiler Collection (GCC) is a free/libre set of compilers developed by the Free Software Foundation <sil=0.916> .PERIOD Steps for Obtaining the GCC Compiler if You're on GNU/Linux On GNU/Linux <sil=0.497> ,COMMA Installing the GNU C Compiler can vary in method from distribution to distribution <sil=0.906> .PERIOD (Type in cc -v to see if it is installed already <sil=0.977> .PERIOD ) 
• For Ubuntu <sil=0.584> ,COMMA install the GCC compiler (along with other necessary tools) by using sudo apt-get install build-essential <sil=0.435> ,COMMA or by using Synaptic <sil=0.901> .PERIOD You do not need Universe enabled <sil=0.957> .PERIOD • For Debian <sil=0.584> ,COMMA install the GCC compiler (as root) by using apt-get install gcc <sil=0.933> .PERIOD • For Fedora Core <sil=0.632> ,COMMA install the GCC compiler (as root) by using yum install gcc <sil=0.937> .PERIOD • For Redhat <sil=0.391> ,COMMA get a GCC RPM <sil=0.569> ,COMMA e <sil=0.968> .PERIOD g <sil=0.956> .PERIOD using Rpmfind and then install (as root) using rpm -ivh gcc-version-release <sil=0.946> .PERIOD arch <sil=0.917> .PERIOD rpm 
• For Mandrake <sil=0.489> ,COMMA install the GCC compiler (as root) by using urpmi gcc 
• For Slackware <sil=0.470> ,COMMA the package is available on their website - simply download <sil=0.405> ,COMMA and type installpkg gcc-xxxxx <sil=0.957> .PERIOD tgz 
• For Gentoo <sil=0.647> ,COMMA you should already have GCC installed as it will have been used when you first installed <sil=0.915> .PERIOD To update it run (as root) emerge -uav gcc <sil=0.973> .PERIOD • For Arch Linux <sil=0.488> ,COMMA install the GCC compiler (as root) by using pacman -S gcc <sil=0.918> .PERIOD • If you cannot become root <sil=0.399> ,COMMA get the GCC tarball from ftp://ftp <sil=0.925> .PERIOD gnu <sil=0.997> .PERIOD org/ and follow the instructions in it to compile and install in your home directory <sil=0.940> .PERIOD Be warned though <sil=0.328> ,COMMA you need a C compiler to do that - yes <sil=0.438> ,COMMA GCC itself is written in C <sil=0.936> .PERIOD • You can use some commercial C compiler/IDE <sil=0.970> .PERIOD Steps for Obtaining the GCC Compiler if You're on BSD Family Systems
• For Mac OS X <sil=0.584> ,COMMA FreeBSD <sil=0.461> ,COMMA NetBSD <sil=0.572> ,COMMA OpenBSD <sil=0.410> ,COMMA DragonFly BSD <sil=0.384> ,COMMA Darwin the port of GNU gcc is available in the base system <sil=0.304> ,COMMA or it could be obtained using the ports collection or pkgsrc <sil=0.943> .PERIOD Steps for Obtaining the GCC Compiler if You're on Windows There are two ways to use GCC on Windows: Cygwin and MinGW <sil=0.936> .PERIOD Applications compiled with Cygwin will not run on any computer without Cygwin <sil=0.517> ,COMMA so MinGW is recommended <sil=0.903> .PERIOD MinGW is simpler to install <sil=0.362> ,COMMA and takes less disk space <sil=0.959> .PERIOD To get MinGW <sil=0.591> ,COMMA do this: 
1 Go to http://sourceforge <sil=0.989> .PERIOD net/projects/mingw/ download and save this to your hard drive <sil=0.918> .PERIOD 2 Once the download is finished <sil=0.516> ,COMMA open it and follow the instructions <sil=0.984> .PERIOD You can also choose to install additional compilers <sil=0.464> ,COMMA or the tool Make <sil=0.402> ,COMMA but these aren't necessary <sil=0.985> .PERIOD 3 Now you need to set your PATH <sil=0.903> .PERIOD Right-click on ”My computer” and click ”Properties” <sil=0.955> .PERIOD Go to the ”Advanced” tab and click on ”Environment variables” <sil=0.902> .PERIOD Go to the ”System variables” section and scroll down until you see ”Path” <sil=0.911> .PERIOD Click on it <sil=0.439> ,COMMA then click ”edit” <sil=0.956> .PERIOD Add ” <sil=0.305> ;SEMICOLON C:\mingw\bin\” (without the quotes) to the end <sil=0.933> .PERIOD 4 To test if GCC works <sil=0.555> ,COMMA open a command prompt and type ”gcc” <sil=0.974> .PERIOD You should get the message ”gcc: fatal error: no input files compilation terminated” <sil=0.908> .PERIOD If you get this message <sil=0.421> ,COMMA GCC is installed correctly <sil=0.954> .PERIOD To get Cygwin <sil=0.563> ,COMMA do this: 
1 Go to http://www <sil=0.928> .PERIOD cygwin <sil=0.964> .PERIOD com and click on the ”Install Cygwin Now” button in the upper right corner of the page <sil=0.929> .PERIOD 2 Click ”run” in the window that pops up <sil=0.304> ,COMMA and click ”next” several times <sil=0.358> ,COMMA accepting all the default settings <sil=0.977> .PERIOD 3 Choose any of the Download sites (”ftp <sil=0.924> .PERIOD easynet <sil=0.905> .PERIOD be” <sil=0.580> ,COMMA etc <sil=0.974> .PERIOD ) when that window comes up <sil=0.512> ;SEMICOLON press ”next” and the Cygwin installer should start downloading <sil=0.912> .PERIOD 4 When the ”Select Packages” window appears <sil=0.534> ,COMMA scroll down to the heading ”Devel” and click on the ”+” by it <sil=0.907> .PERIOD In the list of packages that now displays <sil=0.601> ,COMMA scroll down and find the ”gcc-core” package <sil=0.470> ;SEMICOLON this is the compiler <sil=0.916> .PERIOD Click once on the word ”Skip” <sil=0.568> ,COMMA and it should change to some number like ”3 <sil=0.936> .PERIOD 4” etc <sil=0.953> .PERIOD (the version number) <sil=0.535> ,COMMA and an ”X” will appear next to ”gcc-core” and several other related packages that will now be downloaded <sil=0.917> .PERIOD 5 Click ”next” and the compiler as well as the Cygwin tools should start downloading <sil=0.514> ;SEMICOLON this could take a while <sil=0.912> .PERIOD While you're waiting for the installation to finish <sil=0.481> ,COMMA download any text-editor designed for programming <sil=0.913> .PERIOD While Cygwin does include some <sil=0.480> ,COMMA you may prefer doing a web search to find other alternatives <sil=0.919> .PERIOD While using a stock text editor is possible <sil=0.395> ,COMMA it is not ideal <sil=0.908> .PERIOD 6 Once the Cygwin downloads are finished and you have clicked ”next” <sil=0.451> ,COMMA etc <sil=0.926> .PERIOD to finish the installation <sil=0.332> ,COMMA double-click the Cygwin icon on your desktop to begin the Cygwin ”command prompt” <sil=0.913> .PERIOD Your home directory will automatically be set up in the Cygwin folder <sil=0.361> ,COMMA which now should be at ”C:\cygwin” (the Cygwin folder is in some ways like a small unix/linux computer on your Windows machine -- not technically of course <sil=0.339> ,COMMA but it may be helpful to think of it that way) <sil=0.942> .PERIOD 7 Type ”gcc” at the Cygwin prompt and press ”enter” <sil=0.348> ;SEMICOLON if ”gcc: no input files” or something like it appears you have succeeded and now have the gcc compiler on your computer (and congratulations -- you have also just received your first error message <sil=0.976> !EXCLAMATIONMARK ) <sil=0.340> .PERIOD The current stable (usable) version of GCC is 4 <sil=0.931> .PERIOD 9 <sil=0.939> .PERIOD 1 published on 2014-07-16 <sil=0.531> ,COMMA which supports several platforms <sil=0.963> .PERIOD In fact <sil=0.317> ,COMMA GCC is not only a C compiler <sil=0.358> ,COMMA but a family of compilers for several languages <sil=0.338> ,COMMA such as C++ <sil=0.347> ,COMMA Ada <sil=0.398> ,COMMA Java <sil=0.499> ,COMMA and Fortran <sil=0.935> .PERIOD Embedded systems
• Most CPUs are microcontrollers in embedded systems <sil=0.649> ,COMMA often programmed in C <sil=0.408> ,COMMA but most of the compilers mentioned above (except GCC) do not support such CPUs <sil=0.942> .PERIOD For specialized compilers that do support embedded systems <sil=0.336> ,COMMA see Embedded Systems/C Programming <sil=0.956> .PERIOD Other C compilers
We have a long list of C compilers in a much later section of this Wikibook <sil=0.910> .PERIOD Which of those compilers would be suitable for beginning C programmers <sil=0.587> ,COMMA that we should say a few words about getting started with that particular compiler in this section of this Wikibook <sil=0.868> ?QUESTIONMARK Beginning C
Intro exercise
The ”Hello <sil=0.562> ,COMMA World <sil=0.948> !EXCLAMATIONMARK ” Program 
Tradition dictates that we begin with a very simple program <sil=0.302> ,COMMA which simply displays the characters ”Hello <sil=0.393> ,COMMA World <sil=0.858> !EXCLAMATIONMARK ” on the screen and immediately exits <sil=0.949> .PERIOD Type the following source code in your preferred text editor/IDE and save this in a file named hello <sil=0.992> .PERIOD c <sil=0.950> .PERIOD #include <stdio <sil=0.963> .PERIOD h>
int main(void) 
{
printf("Hello <sil=0.557> ,COMMA World <sil=0.884> !EXCLAMATIONMARK \n") <sil=0.572> ;SEMICOLON return 0 <sil=0.638> ;SEMICOLON }
Source code analysis
Below are described the parts the program is composed of <sil=0.958> .PERIOD The various details will be introduced and explained in later chapters <sil=0.975> .PERIOD #include <stdio <sil=0.986> .PERIOD h>
This is a preprocessor directive <sil=0.975> .PERIOD Preprocessor directives instruct a part of the compiler - the preprocessor - to modify the code we've written before it is compiled <sil=0.923> .PERIOD In this case <sil=0.587> ,COMMA the #include directive is retrieving C code from the standard stdio <sil=0.982> .PERIOD h file <sil=0.903> .PERIOD Files used in this way are called header files and are saved with the <sil=0.929> .PERIOD h extension <sil=0.952> .PERIOD In this program <sil=0.599> ,COMMA the only part we needed from stdio <sil=0.909> .PERIOD h is the printf function <sil=0.970> .PERIOD int main(void)
The function named main is the starting point of all C programs <sil=0.989> .PERIOD In computer science <sil=0.375> ,COMMA the term function tends to be used a bit more loosely than in mathematics <sil=0.514> ,COMMA since functions often express imperative ideas (as in the case of C) - that is <sil=0.362> ,COMMA how-to processes instead of declarations <sil=0.949> .PERIOD For now <sil=0.617> ,COMMA it suffices to say that functions let us define a complex process that we want to reference frequently <sil=0.941> .PERIOD printf("Hello World <sil=0.875> !EXCLAMATIONMARK \n") <sil=0.537> ;SEMICOLON This line is of particular interest <sil=0.545> ,COMMA because it produces the actual output on the console (also known as the terminal in the context of Unix-like operating systems) <sil=0.630> ,COMMA a traditional text based interface to system utilities and programs <sil=0.991> .PERIOD return 0 <sil=0.356> ;SEMICOLON Finally <sil=0.382> ,COMMA we consider this line <sil=0.943> .PERIOD When terminating our program <sil=0.507> ,COMMA it is useful to be able to let the operating system know whether or not the program succeeded <sil=0.931> .PERIOD We do this with an exit status <sil=0.636> ,COMMA which we send to the operating system with a return statement in the main function <sil=0.969> .PERIOD In this case <sil=0.390> ,COMMA we provide an exit status of 0 to indicate that execution succeeded without error <sil=0.972> .PERIOD As our programs grow in complexity <sil=0.632> ,COMMA we can use other integers as codes to indicate various types of errors <sil=0.963> .PERIOD This style of providing exit statuses is a long standing convention <sil=0.927> .PERIOD Compiling
Unix-like
If you are using a Unix(-like) system <sil=0.400> ,COMMA such as GNU/Linux <sil=0.626> ,COMMA Mac OS X <sil=0.503> ,COMMA or Solaris <sil=0.362> ,COMMA it will probably have GCC installed <sil=0.995> .PERIOD Open the virtual console or a terminal emulator and enter the following:
gcc hello <sil=0.928> .PERIOD c
Then run the program by typing: <sil=0.902> .PERIOD /a <sil=0.944> .PERIOD out
You should see Hello <sil=0.505> ,COMMA World <sil=0.979> !EXCLAMATIONMARK printed after the last prompt <sil=0.967> .PERIOD To see the exit status of the last program you ran <sil=0.461> ,COMMA type:
echo $ <sil=0.854> ?QUESTIONMARK This shows the value the main function has returned <sil=0.463> ,COMMA which is 0 in the above example <sil=0.936> .PERIOD There are a lot of options you can use with the gcc compiler <sil=0.917> .PERIOD For example <sil=0.648> ,COMMA if you want the output to have a name other than a <sil=0.947> .PERIOD out <sil=0.593> ,COMMA you can use the -o option <sil=0.982> .PERIOD The following shows a few examples:
-o
indicates that the next parameter is the name of the resulting program (or library) <sil=0.913> .PERIOD If this option is not specified <sil=0.533> ,COMMA the compiled program will <sil=0.626> ,COMMA for historic reasons <sil=0.323> ,COMMA end up in a file called ”a <sil=0.953> .PERIOD out” or ”a <sil=0.940> .PERIOD exe” (for cygwin users) <sil=0.979> .PERIOD -Wall
indicates that gcc should warn about many types of suspicious code that are likely to be incorrect <sil=0.977> .PERIOD You can use these options to create a program called ”helloworld” instead of ”a <sil=0.959> .PERIOD out” by typing:
gcc -o helloworld hello <sil=0.944> .PERIOD c -Wall
Now you can run it by typing: <sil=0.920> .PERIOD /helloworld
All the options are well documented in the manual for GCC <sil=0.994> .PERIOD On IDEs
If you are using an IDE you may have to select console project <sil=0.308> ,COMMA and to compile you just select build from the menu or the toolbar <sil=0.964> .PERIOD The executable will appear inside the project folder <sil=0.348> ,COMMA but you should have a menu button so you can just run the executable from the IDE <sil=0.961> .PERIOD The process is roughly the same on all IDEs <sil=0.926> .PERIOD Preliminaries
Before learning C syntax and programming constructs <sil=0.403> ,COMMA it is important to learn the meaning of a few key terms that are central in understanding C <sil=0.970> .PERIOD Block Structure <sil=0.487> ,COMMA Statements <sil=0.356> ,COMMA Whitespace <sil=0.575> ,COMMA and Scope
Note: Sentences delimited with '/*' and '*/' are comments <sil=0.398> ,COMMA and the compiler ignores them <sil=0.932> .PERIOD They are described in Programming Structure and Style <sil=0.958> .PERIOD Now we are about to discuss the basic structure of a C program <sil=0.946> .PERIOD If you're familiar with PASCAL <sil=0.412> ,COMMA you may have heard it referred to as a block-structured language <sil=0.928> .PERIOD C does not have complete block structure (and you'll find out why when you go over functions in detail) but it is still very important to understand what blocks are and how to use them <sil=0.998> .PERIOD So what is in a block <sil=0.993> ?QUESTIONMARK Generally <sil=0.480> ,COMMA a block consists of executable statements <sil=0.943> .PERIOD Before blocks are explained <sil=0.610> ,COMMA what is a statement <sil=0.898> ?QUESTIONMARK One way to put it is that statements are the text the compiler will attempt to turn into executable instructions <sil=0.332> ,COMMA and the whitespace that surrounds them <sil=0.959> .PERIOD An easier way to put it is that statements are bits of code that do things <sil=0.490> ,COMMA like this:
int i = 6 <sil=0.544> ;SEMICOLON This declares a variable of type integer <sil=0.617> ,COMMA initializes it to the value 6 <sil=0.525> ,COMMA which can be later accessed with the identifier 'i' <sil=0.909> .PERIOD The various data types are introduced in the chapter Variables <sil=0.902> .PERIOD You might have noticed the semicolon at the end of the statement <sil=0.970> .PERIOD Statements in C always end with a semicolon ( <sil=0.536> ;SEMICOLON ) character <sil=0.928> .PERIOD Leaving off the semicolon is a common mistake that a lot of people make <sil=0.464> ,COMMA beginners and experts alike <sil=0.997> !EXCLAMATIONMARK So until it becomes second nature <sil=0.451> ,COMMA be sure to double check your statements <sil=0.942> !EXCLAMATIONMARK Since C is a ”free-format” language <sil=0.304> ,COMMA several statements can share a single line in the source file <sil=0.496> ,COMMA like so:
/* this declares the variables 'i' <sil=0.390> ,COMMA 'test' <sil=0.438> ,COMMA 'foo' <sil=0.640> ,COMMA and 'bar' note that ONLY 'bar' is set to six <sil=0.959> !EXCLAMATIONMARK */ 
int i <sil=0.506> ,COMMA test <sil=0.386> ,COMMA foo <sil=0.343> ,COMMA bar = 6 <sil=0.398> ;SEMICOLON There are several kinds of statements <sil=0.532> ,COMMA and you've seen some of them <sil=0.610> ,COMMA such as the assignment (i = 6 <sil=0.624> ;SEMICOLON ) <sil=0.620> .PERIOD A substantial portion of this book deals with statement construction <sil=0.937> .PERIOD Now back to blocks <sil=0.955> .PERIOD In C <sil=0.313> ,COMMA blocks begin with an opening brace "{" and end with a closing brace "}" <sil=0.965> .PERIOD Blocks can contain other blocks which can contain their own blocks <sil=0.376> ,COMMA and so on <sil=0.905> .PERIOD Let's show an example of blocks <sil=0.987> .PERIOD int main(void) 
{ /* this is a 'block' */ 
int i = 5 <sil=0.416> ;SEMICOLON { 
/* this is also a 'block' <sil=0.635> ,COMMA nested inside the outer block */ 
int i = 6 <sil=0.405> ;SEMICOLON } 
return 0 <sil=0.559> ;SEMICOLON }
You can use blocks with preceding statements <sil=0.599> ,COMMA such as the main function declaration (and other statements to be taught) <sil=0.526> ,COMMA but you can also use blocks by themselves <sil=0.936> .PERIOD Whitespace refers to the tab <sil=0.388> ,COMMA space and newline characters that separate the text characters that make up the source code <sil=0.958> .PERIOD Like many things in life <sil=0.605> ,COMMA it's hard to appreciate whitespace until it's gone <sil=0.938> .PERIOD To a C compiler <sil=0.536> ,COMMA the source code
printf("Hello world") <sil=0.616> ;SEMICOLON return 0 <sil=0.539> ;SEMICOLON is the same as 
printf("Hello world") <sil=0.338> ;SEMICOLON return 0 <sil=0.633> ;SEMICOLON which is also the same as 
printf ( "Hello world") <sil=0.527> ;SEMICOLON return 0 <sil=0.514> ;SEMICOLON The compiler simply ignores most whitespace (except when it separates e <sil=0.957> .PERIOD g <sil=0.971> .PERIOD return from 0) <sil=0.991> .PERIOD However <sil=0.550> ,COMMA it is common practice to use spaces (or tabs) to organize source code for human readability <sil=0.908> .PERIOD Most of the time we do not want other functions or other programmer's routines accessing data that we are currently manipulating <sil=0.982> .PERIOD This is why it is important to understand the concept of scope <sil=0.996> .PERIOD Scopes describes the level at which a piece of data or a function is visible <sil=0.952> .PERIOD There are two kinds of scopes in C <sil=0.386> ,COMMA local and global <sil=0.996> .PERIOD When we speak of something being global <sil=0.379> ,COMMA we speak of something that can be seen or manipulated from anywhere in the program <sil=0.916> .PERIOD When we speak of something being local <sil=0.359> ,COMMA we speak of something that can be seen or manipulated only within the block it was declared <sil=0.938> .PERIOD Let's show some examples <sil=0.343> ,COMMA to give a better picture of the idea of scopes <sil=0.907> .PERIOD int i = 5 <sil=0.424> ;SEMICOLON /* this is a 'global' variable <sil=0.302> ,COMMA it can be accessed from anywhere in the program */ 
/* this is a function <sil=0.302> ,COMMA all variables inside of it are "local" to the function <sil=0.954> .PERIOD */
int main(void) 
{ 
int i = 6 <sil=0.468> ;SEMICOLON /* 'i' now equals 6 */ printf("%d\n" <sil=0.421> ,COMMA i) <sil=0.532> ;SEMICOLON /*prints a '6' to the screen <sil=0.445> ,COMMA instead of the global variable of 'i' <sil=0.496> ,COMMA which is 5 */
 return 0 <sil=0.345> ;SEMICOLON }
That shows a decent example of local and global <sil=0.355> ,COMMA but what about different scopes inside of functions <sil=0.957> ?QUESTIONMARK (you'll learn more about functions later <sil=0.317> ,COMMA for now <sil=0.581> ,COMMA just focus on the ”main” part <sil=0.933> .PERIOD )
/* the main function */ 
int main(void)
{ 
/* this is the beginning of a 'block' <sil=0.583> ,COMMA you read about those above */
int i = 6 <sil=0.530> ;SEMICOLON /* this is the first variable of this 'block' <sil=0.470> ,COMMA 'i' */
{ 
/* this is a new 'block' <sil=0.412> ,COMMA and because it's a different block <sil=0.568> ,COMMA it has its own scope */
/* this is also a variable called 'i' <sil=0.334> ,COMMA but in a different 'block' <sil=0.383> ,COMMA because it's in a different 'block' than the old 'i' <sil=0.621> ,COMMA it doesn't affect the old one <sil=0.930> !EXCLAMATIONMARK */
int i = 5 <sil=0.594> ;SEMICOLON printf("%d\n" <sil=0.383> ,COMMA i) <sil=0.526> ;SEMICOLON /* prints a '5' onto the screen */
} 
/* now we're back into the old block */
printf("%d\n" <sil=0.430> ,COMMA i) <sil=0.386> ;SEMICOLON /* prints a '6' onto the screen */ 
return 0 <sil=0.537> ;SEMICOLON }
Basics of Using Functions
Functions are a big part of programming <sil=0.906> .PERIOD A function is a special kind of block that performs a well-defined task <sil=0.946> .PERIOD If a function is well-designed <sil=0.638> ,COMMA it can enable a programmer to perform a task without knowing anything about how the function works <sil=0.913> .PERIOD The act of requesting a function to perform its task is called a function call <sil=0.935> .PERIOD Many functions require a caller to hand it certain pieces of data needed to perform its task <sil=0.419> ;SEMICOLON these are called arguments <sil=0.931> .PERIOD Many functions also return a value to the caller when they're finished <sil=0.410> ;SEMICOLON this is called a return value (the return value in the above program is 0) <sil=0.972> .PERIOD The things you need to know before calling a function are: 
• What the function does 
• The data type (discussed later) of the arguments and what they mean 
• The data type of the return value and what it means
Many functions use the return value for the result of a computation <sil=0.977> .PERIOD Some functions use the return value to indicate whether they successfully completed their work <sil=0.946> .PERIOD As you have seen in the intro exercise <sil=0.628> ,COMMA the main function uses the return value to provide an exit status to the operating system <sil=0.925> .PERIOD All code other than global data definitions and declarations needs to be a part of a function <sil=0.943> .PERIOD Usually <sil=0.604> ,COMMA you're free to call a function whatever you wish to <sil=0.995> .PERIOD The only restriction is that every executable program needs to have one <sil=0.471> ,COMMA and only one <sil=0.454> ,COMMA main function <sil=0.504> ,COMMA which is where the program begins executing <sil=0.980> .PERIOD We will discuss functions in more detail in a later chapter <sil=0.441> ,COMMA C Programming/Procedures and functions <sil=0.963> .PERIOD The Standard Library
In 1983 <sil=0.522> ,COMMA when C was in the process of becoming standardized <sil=0.413> ,COMMA the American National Standards Institute (ANSI) formed a committee to establish a standard specification of C known as ”ANSI C” <sil=0.918> .PERIOD That standard specification created a basic set of functions common to each implementation of C <sil=0.461> ,COMMA which is referred to as the Standard Library <sil=0.976> .PERIOD The Standard Library provides functions for tasks such as input/output <sil=0.637> ,COMMA string manipulation <sil=0.465> ,COMMA mathematics <sil=0.388> ,COMMA files <sil=0.445> ,COMMA and memory allocation <sil=0.965> .PERIOD The Standard Library does not provide functions that are dependent on specific hardware or operating systems <sil=0.608> ,COMMA like graphics <sil=0.392> ,COMMA sound <sil=0.422> ,COMMA or networking <sil=0.949> .PERIOD In the ”Hello <sil=0.412> ,COMMA World” program <sil=0.478> ,COMMA a Standard Library function is used (printf) which outputs lines of text to the standard output stream <sil=0.930> .PERIOD Compiling
Having covered the basic concepts of C programming <sil=0.564> ,COMMA we can now briefly discuss the process of compilation <sil=0.983> .PERIOD Like any programming language <sil=0.645> ,COMMA C by itself is completely incomprehensible to a microprocessor <sil=0.980> .PERIOD Its purpose is to provide an intuitive way for humans to provide instructions that can be easily converted into machine code that is comprehensible to a microprocessor <sil=0.968> .PERIOD The compiler is what takes this code <sil=0.627> ,COMMA and translates it into the machine code <sil=0.981> .PERIOD To those new to programming <sil=0.349> ,COMMA this seems fairly simple <sil=0.994> .PERIOD A naive compiler might read in every source file <sil=0.557> ,COMMA translate everything into machine code <sil=0.368> ,COMMA and write out an executable <sil=0.987> .PERIOD This could work <sil=0.406> ,COMMA but has two serious problems <sil=0.930> .PERIOD First <sil=0.405> ,COMMA for a large project <sil=0.343> ,COMMA the computer may not have enough memory to read all of the source code at once <sil=0.997> .PERIOD Second <sil=0.607> ,COMMA if you make a change to a single source file <sil=0.432> ,COMMA you would rather not have to recompile the entire application <sil=0.964> .PERIOD To deal with these problems <sil=0.472> ,COMMA compilers break their job down into steps <sil=0.339> ;SEMICOLON for each source file (each <sil=0.994> .PERIOD c file) <sil=0.618> ,COMMA the compiler reads the file <sil=0.546> ,COMMA reads the files it references with #include <sil=0.585> ,COMMA and translates it to machine code <sil=0.927> .PERIOD The result of this is an ”object file” ( <sil=0.965> .PERIOD o) <sil=0.994> .PERIOD Once every object file is made <sil=0.374> ,COMMA a ”linker” collects all of the object files and writes the actual program <sil=0.964> .PERIOD This way <sil=0.496> ,COMMA if you change one source file <sil=0.330> ,COMMA only that file needs to be recompiled and then the application needs to be re-linked <sil=0.961> .PERIOD Without going into the painful details <sil=0.504> ,COMMA it can be beneficial to have a superficial understanding of the compilation process <sil=0.997> .PERIOD Preprocessor
The preprocessor provides the ability for the inclusion of header files <sil=0.364> ,COMMA macro expansions <sil=0.501> ,COMMA conditional compilation <sil=0.384> ,COMMA and line control <sil=0.982> .PERIOD Many times you will need to give special instructions to your compiler <sil=0.988> .PERIOD This is done by inserting preprocessor directives2 into your code <sil=0.916> .PERIOD When you begin compiling your code <sil=0.381> ,COMMA a special program called the preprocessor scans the source code and performs simple substitution of tokenized strings for others according to predefined rules <sil=0.987> .PERIOD The C preprocessor is not a part of the C language <sil=0.974> .PERIOD All preprocessor directives begin with the hash character (#) <sil=0.937> .PERIOD You can see one preprocessor directive in the Hello world program3 <sil=0.991> .PERIOD Example: 
#include <stdio <sil=0.904> .PERIOD h>
This directive causes the header to be included into your program <sil=0.930> .PERIOD Other directives such as #pragma control compiler settings and macros <sil=0.928> .PERIOD The result of the preprocessing stage is a text string <sil=0.975> .PERIOD You can think of the preprocessor as a non-interactive text editor that prepares your code for the compilation step <sil=0.917> .PERIOD The language of preprocessor directives is agnostic to the grammar of C <sil=0.639> ,COMMA so the C preprocessor can also be used independently to process other kinds of text files <sil=0.979> .PERIOD Syntax Checking 
This step ensures that the code is valid and will sequence into an executable program <sil=0.930> .PERIOD Under most compilers <sil=0.312> ,COMMA you may get messages or warnings indicating potential issues with your program (such as a conditional statement always being true or false <sil=0.447> ,COMMA etc <sil=0.925> .PERIOD ) 
When an error is detected in the program <sil=0.638> ,COMMA the compiler will normally report the file name and line that is preventing compilation <sil=0.912> .PERIOD Object Code 
The compiler produces a machine code equivalent of the source code that can then be linked into the final program <sil=0.910> .PERIOD The code itself can't be executed yet <sil=0.424> ,COMMA as it has to complete the linking stage <sil=0.987> .PERIOD It's important to note after discussing the basics that compilation is a ”one way street” <sil=0.956> .PERIOD That is <sil=0.577> ,COMMA compiling a C source file into machine code is easy <sil=0.506> ,COMMA but ”decompiling” (turning machine code into the C source that creates it) is not <sil=0.909> .PERIOD Decompilers for C do exist <sil=0.402> ,COMMA but the code they create is hard to understand and only useful for reverse engineering <sil=0.945> .PERIOD Linking 
Linking combines the separate object codes into one complete program by integrating libraries and the code and producing either an executable program6 or a library <sil=0.902> .PERIOD Linking is performed by a linker <sil=0.450> ,COMMA which is often part of a compiler <sil=0.920> .PERIOD Common errors during this stage are either missing functions <sil=0.490> ,COMMA or duplicate functions <sil=0.909> .PERIOD Automation 
For large C projects <sil=0.345> ,COMMA many programmers choose to automate compilation <sil=0.410> ,COMMA both in order to reduce user interaction requirements and to speed up the process by only recompiling modified files <sil=0.968> .PERIOD Most integrated development environments have some kind of project management <sil=0.631> ,COMMA which makes such automation very easy <sil=0.959> .PERIOD However <sil=0.557> ,COMMA the project management files are often only usable for users of the same integrated development environment <sil=0.632> ,COMMA so all developers would need to use the same IDE <sil=0.916> .PERIOD On UNIX-like systems <sil=0.619> ,COMMA make and Makefiles are often used to accomplish the same <sil=0.967> .PERIOD Make is traditional and flexible and is available as one of the standard developer tools on most Unix and GNU distributions <sil=0.981> .PERIOD Makefiles have been extended by the GNU Autotools <sil=0.608> ,COMMA composed of Automake and Autoconf for making software compilable <sil=0.370> ,COMMA testable <sil=0.381> ,COMMA translatable and configurable on many different kinds of machines <sil=0.943> .PERIOD Automake and Autoconf are described in detail in their respective manuals <sil=0.972> .PERIOD The Autotools are often perceived to be complicated and various simpler build systems have been developed <sil=0.969> .PERIOD Many components of the GNOME project12 now use the declarative Meson build system13 which is less flexible but instead focuses on providing the features most commonly needed from a build system in a simple way <sil=0.936> .PERIOD Other popular build systems for programs written in the C language include CMake14 and Waf15 <sil=0.968> .PERIOD Once gcc is installed <sil=0.425> ,COMMA it can be called with a list of c source files that have been written but not yet compiled <sil=0.951> .PERIOD eg <sil=0.965> .PERIOD there is a main <sil=0.914> .PERIOD c file that includes some functions described in myfun <sil=0.912> .PERIOD h and implemented in myfun_a <sil=0.909> .PERIOD c and myfun_b <sil=0.964> .PERIOD c <sil=0.394> ,COMMA then it is enough to write 
gcc main <sil=0.926> .PERIOD c myfun_a <sil=0.907> .PERIOD c myfun_b <sil=0.932> .PERIOD c
myfun <sil=0.941> .PERIOD h is included in main <sil=0.991> .PERIOD c <sil=0.977> ,COMMA but if is in a separate header files directory <sil=0.378> ,COMMA then that directory can be listed after a ”-I ” switch <sil=0.908> .PERIOD In larger programs <sil=0.507> ,COMMA Makefiles and gnu make program can compile c files into intermediate files ending with suffix <sil=0.984> .PERIOD o which can be linked by gcc <sil=0.956> .PERIOD How to compile each object file is usually described in the Makefile with the object file as a label ending with a colon followed by two spaces (tabs are often bad characters) followed by a list of other files that are dependencies <sil=0.523> ,COMMA eg <sil=0.926> .PERIOD  <sil=0.915> .PERIOD c files and <sil=0.959> .PERIOD o files compiled in another section <sil=0.588> ,COMMA and on the next line <sil=0.480> ,COMMA the invocation of gcc that is required <sil=0.984> .PERIOD Typing man make or info make often gives the information needed to jog the memory on how to use make <sil=0.466> ,COMMA and the same goes for gcc <sil=0.454> ,COMMA although gcc has a lot of option switches <sil=0.616> ,COMMA the main ones being -g to generate debugging for gdb to allow it to show source code during stepping through of the machine code program <sil=0.996> .PERIOD gdb has a 'h' command that shows what it can do <sil=0.321> ,COMMA and is usually started with 'gdb a <sil=0.969> .PERIOD out' if a <sil=0.972> .PERIOD out is the anonymous executable machine code file that was compiled by gcc <sil=0.993> .PERIOD Structure and style
C Structure and Style 
This is a basic introduction to a good code style in the C Programming Language <sil=0.928> .PERIOD It is designed to provide information on how to effectively use indentation <sil=0.525> ,COMMA comments <sil=0.407> ,COMMA and other elements that will make your C code more readable <sil=0.996> .PERIOD It is not a tutorial on actually programming in C <sil=0.996> .PERIOD As a beginning programmer <sil=0.617> ,COMMA the point of creating structure in the programs' code might not be clear <sil=0.529> ,COMMA as the compiler doesn't care about the difference <sil=0.931> .PERIOD However <sil=0.409> ,COMMA as programs become complex <sil=0.552> ,COMMA chances are that writing the program has become a joint effort <sil=0.923> .PERIOD (Or others might want to see how it was accomplished <sil=0.988> .PERIOD Or you may have to read it again years later <sil=0.902> .PERIOD )
Wellwritten code also helps you get an overview of what the code does <sil=0.969> .PERIOD Therefore <sil=0.515> ,COMMA the code is no longer designed purely for a compiler to read <sil=0.966> .PERIOD In the following sections <sil=0.432> ,COMMA we will attempt to explain good programming practices that will in turn make your programs clearer <sil=0.901> .PERIOD Introduction In C <sil=0.510> ,COMMA programs are composed of statements <sil=0.945> .PERIOD These statements are terminated with a semicolon <sil=0.511> ,COMMA and are collected in sections known as functions <sil=0.936> .PERIOD By convention <sil=0.647> ,COMMA a statement should be kept on its own line <sil=0.344> ,COMMA as shown in the example below: 
#include <stdio <sil=0.967> .PERIOD h> 
int main(void) 
{ 
printf("Hello <sil=0.397> ,COMMA World <sil=0.880> !EXCLAMATIONMARK \n") <sil=0.400> ;SEMICOLON return 0 <sil=0.563> ;SEMICOLON } 
The following block of code is essentially the same: while it contains exactly the same code <sil=0.563> ,COMMA and will compile and execute with the same result <sil=0.448> ,COMMA the removal of spacing causes an essential difference <sil=0.453> ,COMMA making it harder to read: 
#include <stdio <sil=0.931> .PERIOD h>
int main(void) 
{
printf("Hello <sil=0.616> ,COMMA World <sil=0.884> !EXCLAMATIONMARK \n") <sil=0.373> ;SEMICOLON return 0 <sil=0.429> ;SEMICOLON } 
The simple use of indents and line breaks can greatly improve the readability of the code <sil=0.486> ;SEMICOLON without making any impact whatsoever on how the code performs <sil=0.926> .PERIOD By having readable code <sil=0.589> ,COMMA it is much easier to see where functions and procedures end <sil=0.459> ,COMMA and which lines are part of which loops and procedures <sil=0.915> .PERIOD This lesson is going to focus on improving the coding style of an example piece of code which applies a formula and prints the result <sil=0.960> .PERIOD You will later see how to write code for such tasks in more detail <sil=0.362> ,COMMA but for now you should focus on how the code looks and not on what it does <sil=0.937> .PERIOD Line Breaks and Indentation 
The addition of white space inside your code is arguably the most important part of good code structure <sil=0.922> .PERIOD Effective use of white space can create a visual scale of how your code flows <sil=0.414> ,COMMA which can be very important when returning to your code when you want to maintain it <sil=0.972> .PERIOD Line Breaks
With minimal line breaks <sil=0.448> ,COMMA code is barely readable by humans <sil=0.645> ,COMMA and may be hard to debug or understand: 
1 #include <stdio <sil=0.930> .PERIOD h>
2 int main(void) { int revenue = 80 <sil=0.502> ;SEMICOLON int cost = 50 <sil=0.512> ;SEMICOLON int roi <sil=0.451> ;SEMICOLON roi = (100 * (revenue - cost)) / cost <sil=0.444> ;SEMICOLON 3 if (roi >= 0) { printf ("%d\n" <sil=0.559> ,COMMA roi) <sil=0.595> ;SEMICOLON } return 0 <sil=0.406> ;SEMICOLON } 
Rather than putting everything on one line <sil=0.346> ,COMMA it is much more readable to break up long lines so that each statement and declaration goes on its own line <sil=0.971> .PERIOD After inserting line breaks <sil=0.593> ,COMMA the code will look like this: 
1 #include <stdio <sil=0.915> .PERIOD h>
2 int main(void) { 
3 int revenue = 80 <sil=0.529> ;SEMICOLON 4 int cost = 50 <sil=0.605> ;SEMICOLON 5 int roi <sil=0.648> ;SEMICOLON 6 roi = (100 * (revenue - cost)) / cost <sil=0.349> ;SEMICOLON 7 if (roi >= 0) { 
8 printf ("%d\n" <sil=0.398> ,COMMA roi) <sil=0.423> ;SEMICOLON 9 } 
10 return 0 <sil=0.317> ;SEMICOLON 11 }
Blank Lines 
Blank lines should be used to offset the main components of your code <sil=0.966> .PERIOD Always use them 
• After precompiler declarations <sil=0.903> .PERIOD • After new variables are declared <sil=0.978> .PERIOD • Use your own judgment for finding other places where components should be separated <sil=0.912> .PERIOD Based on these two rules <sil=0.362> ,COMMA there should now be at least two line breaks added <sil=0.900> .PERIOD • After line 1 <sil=0.612> ,COMMA because line 1 has a preprocessor directive <sil=0.991> .PERIOD • After line 5 <sil=0.641> ,COMMA because line 5 contains a variable declaration <sil=0.943> .PERIOD This will make the code much more readable than it was before: 
The following lines of code have line breaks between functions <sil=0.311> ,COMMA but without indentation <sil=0.923> .PERIOD 1 #include 
2 
3 int main(void) { 
4 
5 int revenue = 80 <sil=0.362> ;SEMICOLON 6 int cost = 50 <sil=0.365> ;SEMICOLON 7 
8 int roi <sil=0.382> ;SEMICOLON 9 
10 roi = (100 * (revenue - cost)) / cost <sil=0.478> ;SEMICOLON 11 
12 if (roi >= 0) { 
13 printf ("%d\n" <sil=0.425> ,COMMA roi) <sil=0.582> ;SEMICOLON 14 } 
15 
16 return 0 <sil=0.522> ;SEMICOLON 17 } 
But this still isn't as readable as it can be <sil=0.936> .PERIOD Indentation
Note: Many text editors automatically indent appropriately when you hit the enter/return key <sil=0.923> .PERIOD Although adding simple line breaks between key blocks of code can make code easier to read <sil=0.441> ,COMMA it provides no information about the block structure of the program <sil=0.908> .PERIOD Using the tab key can be very helpful now: indentation visually separates paths of execution by moving their starting points to a new column in the line <sil=0.955> .PERIOD This simple practice will make it much easier to read and understand code <sil=0.961> .PERIOD Indentation follows a fairly simple rule: 
• All code inside a new block should be indented by one tab more than the code in the previous path <sil=0.953> .PERIOD Based on the code from the previous section <sil=0.436> ,COMMA there are two blocks requiring indentation: 
• Lines 4 to 16 
• Line 13 
1 #include 
2 
3 int main(void) { 
4 
5 int revenue = 80 <sil=0.439> ;SEMICOLON 6 int cost = 50 <sil=0.321> ;SEMICOLON 7 
8 int roi <sil=0.592> ;SEMICOLON 9 
10 roi = (100 * (revenue - cost)) / cost <sil=0.322> ;SEMICOLON 11 
12 if (roi >= 0) { 
13 printf ("%d\n" <sil=0.448> ,COMMA roi) <sil=0.361> ;SEMICOLON 14 } 
15 
16 return 0 <sil=0.432> ;SEMICOLON 17 } 
It is now fairly obvious as to which parts of the program fit inside which blocks <sil=0.927> .PERIOD You can tell which parts of the program the coder has intended to be conditional <sil=0.366> ,COMMA and which ones he or she has not <sil=0.918> .PERIOD Although it might not be immediately noticeable <sil=0.548> ,COMMA once many nested paths get added to the structure of the program <sil=0.330> ,COMMA the use of indentation can be very important <sil=0.925> .PERIOD This indentation makes the structure of your program clear <sil=0.950> .PERIOD It is claimed that research has shown that an indentation size between 2 to 4 characters is easier to read than 8 character indents <sil=0.943> .PERIOD However <sil=0.545> ,COMMA an indent of 8 characters may still be in use for some systems <sil=0.916> .PERIOD Comments 
Comments in code can be useful for a variety of purposes <sil=0.951> .PERIOD They provide the easiest way to set off specific parts of code (and their purpose) <sil=0.572> ;SEMICOLON as well as providing a visual ”split” between various parts of your code <sil=0.938> .PERIOD Having good comments throughout your code will make it much easier to remember what specific parts of your code do <sil=0.919> .PERIOD Comments in modern flavors of C (and many other languages) can come in two forms: 
1 //Single Line Comments (added by C99 standard <sil=0.578> ,COMMA famously known as c++ style of 
2 comments) 
and
1 /*Multi-Line 
2 Comments 
3 (only form of comments supported by C89 standard)*/ 
Note that Single line comments are a more recent addition to C <sil=0.564> ,COMMA so some compilers may not support them <sil=0.976> .PERIOD A recent version of GCC will have no problems supporting them <sil=0.987> .PERIOD This section is going to focus on the various uses of each form of commentary <sil=0.961> .PERIOD Single-line Comments Single-line comments are most useful for simple 'side' notes that explain what certain parts of the code do <sil=0.989> .PERIOD The best places to put these comments are next to variable declarations <sil=0.514> ,COMMA and next to pieces of code that may need explanation <sil=0.931> .PERIOD Comments should make clear the intention and ideas behind the corresponding code <sil=0.974> .PERIOD What is immediately obvious from reading the code does not belong in a comment <sil=0.942> .PERIOD Based on our previous program <sil=0.382> ,COMMA there are various good places to place comments 
• Line 5 and/or 6 <sil=0.461> ,COMMA to explain what 'int revenue' and 'int cost' represent <sil=0.644> ,COMMA • Line 8 <sil=0.448> ,COMMA to explain what the variable 'roi' is going to be used for <sil=0.465> ,COMMA • Line 10 <sil=0.556> ,COMMA to explain the idea of the calculation <sil=0.596> ,COMMA • Line 12 <sil=0.501> ,COMMA to explain the purpose of the 'if' <sil=0.981> .PERIOD This will make our program look something like 
#include int main(void)
{ 
int revenue = 80 <sil=0.448> ;SEMICOLON // as of 2016 
int cost = 50 <sil=0.507> ;SEMICOLON int roi <sil=0.498> ;SEMICOLON // return on investment in percent 
roi = (100 * (revenue - cost)) / cost <sil=0.615> ;SEMICOLON // formula from accounting book 
if (roi >= 0) { // we don't care about negative roi 
printf ("%d\n" <sil=0.566> ,COMMA roi) <sil=0.382> ;SEMICOLON } 
return 0 <sil=0.467> ;SEMICOLON }
Multi-line Comments
Multi-line comments are most useful for long explanations of code <sil=0.949> .PERIOD They can be used as copyright/licensing notices <sil=0.318> ,COMMA and they can also be used to explain the purpose of a block of code <sil=0.996> .PERIOD This can be useful for two reasons: 
They make your functions easier to understand <sil=0.307> ,COMMA and they make it easier to spot errors in code <sil=0.976> .PERIOD If you know what a block is supposed to do <sil=0.590> ,COMMA then it is much easier to find the piece of code that is responsible if an error occurs <sil=0.928> .PERIOD As an example <sil=0.638> ,COMMA suppose we had a program that was designed to print ”Hello <sil=0.476> ,COMMA World <sil=0.956> !EXCLAMATIONMARK ” a certain number of lines <sil=0.347> ,COMMA a specified number of times <sil=0.931> .PERIOD There would be many for loops in this program <sil=0.923> .PERIOD For this example <sil=0.425> ,COMMA we shall call the number of lines i <sil=0.539> ,COMMA and the number of strings per line as j <sil=0.905> .PERIOD A good example of a multi-line comment that describes 'for' loop is purpose would be: 
/* For Loop (int i)
Loops the following procedure i times (for number of lines) <sil=0.988> .PERIOD Performs 'for' loop j on each loop <sil=0.303> ,COMMA and prints a new line at end of each loop <sil=0.987> .PERIOD */ 
This provides a good explanation of what is purpose is <sil=0.350> ,COMMA whilst not going into detail of what j does <sil=0.934> .PERIOD By going into detail over what the specific path does (and not ones inside it) <sil=0.474> ,COMMA it will be easier to troubleshoot the path <sil=0.949> .PERIOD Similarly <sil=0.335> ,COMMA you should always include a multi-line comment before each function <sil=0.340> ,COMMA to explain the role <sil=0.529> ,COMMA preconditions and postconditions of each function <sil=0.942> .PERIOD Always leave the technical details to the individual blocks inside your program - this makes it easier to troubleshoot <sil=0.950> .PERIOD A function descriptor should look something like: 
/* Function : int hworld (int i <sil=0.385> ,COMMA int j)
	Input	: int i (Number of lines) <sil=0.404> ,COMMA int j (Number of instances per line)
Output : 0 (on success)
  Procedure: Prints "Hello <sil=0.404> ,COMMA World <sil=0.909> !EXCLAMATIONMARK " j times <sil=0.451> ,COMMA and a new line to standard output over i lines <sil=0.963> .PERIOD */
This system allows for an at-a-glance explanation of what the function should do <sil=0.934> .PERIOD You can then go into detail over how each aspect of the program is achieved later on in the program <sil=0.918> .PERIOD Finally <sil=0.611> ,COMMA if you like to have aesthetically-pleasing source code <sil=0.405> ,COMMA the multi-line comment system allows for the easy addition of comment boxes <sil=0.987> .PERIOD These make the comments stand out much more than they would without otherwise <sil=0.956> .PERIOD They look like this <sil=0.937> .PERIOD /***************************************
* This is a multi line comment* That is nearly surrounded by a * Cool <sil=0.430> ,COMMA starry border <sil=0.930> !EXCLAMATIONMARK ***************************************/
Applied to our original program <sil=0.563> ,COMMA we can now include a much more descriptive and readable source code:
#include <stdio <sil=0.949> .PERIOD h>
int main(void){ /****
********************************************************************************
* Function: int main(void)
* Input	: none
* Output : Returns 0 on success
    * Procedure: Prints 2016's return on investment in percent if it is notnegative <sil=0.999> .PERIOD ***** *******************************************************************************/ int revenue = 80 <sil=0.561> ;SEMICOLON // as of 2016
int cost = 50 <sil=0.301> ;SEMICOLON int roi <sil=0.339> ;SEMICOLON // return on investment in percent
roi = (100 * (revenue - cost)) / cost <sil=0.508> ;SEMICOLON // formula from accounting book
if (roi >= 0) {	// we don't care about negative roi printf ("%d\n" <sil=0.351> ,COMMA roi) <sil=0.349> ;SEMICOLON }
   return 0 <sil=0.442> ;SEMICOLON }
This will allow any outside users of the program an easy way to comprehend what the code functions are and how they operate <sil=0.910> .PERIOD It also inhibits uncertainty with other like-named functions <sil=0.931> .PERIOD A few programmers add a column of stars on the right side of a block comment:
/***************************************
* This is a multi line comment	*
* that is completely surrounded by a *
* cool <sil=0.324> ,COMMA starry border <sil=0.998> !EXCLAMATIONMARK *
***************************************/
But most programmers don't put any stars on the right side of a block comment <sil=0.925> .PERIOD They feel that aligning the right side is a waste of time <sil=0.927> .PERIOD Comments written in source files can be used for documenting source code automatically by using popular tools like Doxygen <sil=0.916> .PERIOD Variables
Like most programming languages <sil=0.503> ,COMMA C is able to use and process named variables and their contents <sil=0.967> .PERIOD Variables are simply names used to refer to some location in memory – a location that holds a value with which we are working <sil=0.972> .PERIOD It may help to think of variables as a placeholder for a value <sil=0.982> .PERIOD You can think of a variable as being equivalent to its assigned value <sil=0.987> .PERIOD So <sil=0.358> ,COMMA if you have a variable i that is initialized (set equal) to 4 <sil=0.404> ,COMMA then it follows that i + 1 will equal 5 <sil=0.912> .PERIOD Since C is a relatively low-level programming language <sil=0.468> ,COMMA before a C program can utilize memory to store a variable it must claim the memory needed to store the values for a variable <sil=0.949> .PERIOD This is done by declaring variables <sil=0.981> .PERIOD Declaring variables is the way in which a C program shows the number of variables it needs <sil=0.550> ,COMMA what they are going to be named <sil=0.306> ,COMMA and how much memory they will need <sil=0.959> .PERIOD Within the C programming language <sil=0.365> ,COMMA when managing and working with variables <sil=0.633> ,COMMA it is important to know the type of variables and the size of these types <sil=0.967> .PERIOD A type’s size is the amount of computer memory required to store one value of this type <sil=0.908> .PERIOD Since C is a fairly lowlevel programming language <sil=0.501> ,COMMA the size of types can be specific to the hardware and compiler used – that is <sil=0.541> ,COMMA how the language is made to work on one type of machine can be different from how it is made to work on another <sil=0.996> .PERIOD All variables in C are typed <sil=0.975> .PERIOD That is <sil=0.329> ,COMMA every variable declared must be assigned as a certain type of variable <sil=0.970> .PERIOD Declaring <sil=0.325> ,COMMA Initializing <sil=0.387> ,COMMA and Assigning Variables
Here is an example of declaring an integer <sil=0.326> ,COMMA which we've called some_number <sil=0.981> .PERIOD (Note the semicolon at the end of the line <sil=0.618> ;SEMICOLON that is how your compiler separates one program statement from another <sil=0.974> .PERIOD ) 
int some_number <sil=0.481> ;SEMICOLON This statement means we're declaring some space for a variable called some_number <sil=0.454> ,COMMA which will be used to store integer data <sil=0.973> .PERIOD Note that we must specify the type of data that a variable will store <sil=0.978> .PERIOD There are specific keywords to do this – we'll look at them in the next section <sil=0.974> .PERIOD Multiple variables can be declared with one statement <sil=0.509> ,COMMA like this:
int anumber <sil=0.478> ,COMMA anothernumber <sil=0.416> ,COMMA yetanothernumber <sil=0.363> ;SEMICOLON We can also declare and assign some content to a variable at the same time <sil=0.923> .PERIOD int some_number = 3 <sil=0.533> ;SEMICOLON This is called initialization <sil=0.973> .PERIOD In early versions of C <sil=0.391> ,COMMA variables had to be declared at the beginning of a block <sil=0.914> .PERIOD In C99 it is allowed to mix declarations and statements arbitrarily – but doing so is not usual <sil=0.383> ,COMMA because it is rarely necessary <sil=0.394> ,COMMA some compilers still don’t support C99 (portability) <sil=0.468> ,COMMA and it may <sil=0.422> ,COMMA because it is uncommon yet <sil=0.648> ,COMMA irritate fellow programmers (maintainability) <sil=0.960> .PERIOD After declaring variables <sil=0.326> ,COMMA you can assign a value to a variable later on using a statement like this: some_number = 3 <sil=0.545> ;SEMICOLON You can also assign a variable the value of another variable <sil=0.641> ,COMMA like so:
anumber = anothernumber <sil=0.362> ;SEMICOLON Or assign multiple variables the same value with one statement: 
anumber = anothernumber = yetanothernumber = 3 <sil=0.575> ;SEMICOLON This is because the assignment x = y returns the value of the assignment <sil=0.951> .PERIOD x = y = z is really shorthand for x = (y = z) <sil=0.923> .PERIOD Naming Variables
Variable names in C are made up of letters (upper and lower case) and digits <sil=0.991> .PERIOD The underscore character (”_”) is also permitted <sil=0.998> .PERIOD Names must not begin with a digit <sil=0.961> .PERIOD Unlike some languages (such as Perl and some BASIC dialects) <sil=0.636> ,COMMA C does not use any special prefix characters on variable names <sil=0.987> .PERIOD Some examples of valid (but not very descriptive) C variable names:
foo Bar BAZ foo_bar _foo42
_
QuUx
Some examples of invalid C variable names:
2foo	(must not begin with a digit) my foo (spaces not allowed in names) $foo	($ not allowed -- only letters <sil=0.395> ,COMMA and _) while (language keywords cannot be used as names)
As the last example suggests <sil=0.579> ,COMMA certain words are reserved as keywords in the language <sil=0.638> ,COMMA and these cannot be used as variable names <sil=0.994> .PERIOD It is not allowed to use the same name for multiple variables in the same scope <sil=0.956> .PERIOD When working with other developers <sil=0.311> ,COMMA you should therefore take steps to avoid using the same name Literals for global variables or function names <sil=0.918> .PERIOD Some large projects adhere to naming guidelines to avoid duplicate names and for consistency <sil=0.949> .PERIOD In addition there are certain sets of names that <sil=0.379> ,COMMA while not language keywords <sil=0.641> ,COMMA are reserved for one reason or another <sil=0.917> .PERIOD For example <sil=0.593> ,COMMA a C compiler might use certain names ”behind the scenes” <sil=0.547> ,COMMA and this might cause problems for a program that attempts to use them <sil=0.960> .PERIOD Also <sil=0.301> ,COMMA some names are reserved for possible future use in the C standard library <sil=0.930> .PERIOD The rules for determining exactly what names are reserved (and in what contexts they are reserved) are too complicated to describe here <sil=0.568> ,COMMA and as a beginner you don't need to worry about them much anyway <sil=0.927> .PERIOD For now <sil=0.581> ,COMMA just avoid using names that begin with an underscore character <sil=0.939> .PERIOD The naming rules for C variables also apply to naming other language constructs such as function names <sil=0.431> ,COMMA struct tags <sil=0.404> ,COMMA and macros <sil=0.624> ,COMMA all of which will be covered later <sil=0.910> .PERIOD Literals
Anytime within a program in which you specify a value explicitly instead of referring to a variable or some other form of data <sil=0.323> ,COMMA that value is referred to as a literal <sil=0.959> .PERIOD In the initialization example above <sil=0.560> ,COMMA 3 is a literal <sil=0.997> .PERIOD Literals can either take a form defined by their type (more on that soon) <sil=0.613> ,COMMA or one can use hexadecimal (hex) notation to directly insert data into a variable regardless of its type <sil=0.907> .PERIOD Hex numbers are always preceded with 0x <sil=0.923> .PERIOD For now <sil=0.533> ,COMMA though <sil=0.932> ,COMMA you probably shouldn't be too concerned with hex <sil=0.931> .PERIOD The Four Basic Data Types 
In Standard C there are four basic data types <sil=0.920> .PERIOD They are int <sil=0.562> ,COMMA char <sil=0.433> ,COMMA float <sil=0.633> ,COMMA and double <sil=0.911> .PERIOD We will briefly describe them here <sil=0.607> ,COMMA then go into more detail in C Programming/Types <sil=0.987> .PERIOD The int type
The int type stores integers in the form of ”whole numbers” <sil=0.938> .PERIOD An integer is typically the size of one machine word <sil=0.303> ,COMMA which on most modern home PCs is 32 bits (4 octets) <sil=0.931> .PERIOD Examples of literals are whole numbers (integers) such as 1 <sil=0.630> ,COMMA 2 <sil=0.353> ,COMMA 3 <sil=0.339> ,COMMA 10 <sil=0.477> ,COMMA 100 <sil=0.979> .PERIOD  <sil=0.634> .PERIOD  <sil=0.368> .PERIOD When int is 32 bits (4 octets) <sil=0.570> ,COMMA it can store any whole number (integer) between -2147483648 and 2147483647 <sil=0.956> .PERIOD A 32 bit word (number) has the possibility of representing any one number out of 4294967296 possibilities (2 to the power of 32) <sil=0.914> .PERIOD If you want to declare a new int variable <sil=0.439> ,COMMA use the int keyword <sil=0.906> .PERIOD For example:
int numberOfStudents <sil=0.467> ,COMMA i <sil=0.490> ,COMMA j=5 <sil=0.337> ;SEMICOLON In this declaration we declare 3 variables <sil=0.333> ,COMMA numberOfStudents <sil=0.347> ,COMMA i and j <sil=0.458> ,COMMA j here is assigned the literal 5 <sil=1.000> .PERIOD The char type
The char type is capable of holding any member of the execution character set <sil=0.971> .PERIOD It stores the same kind of data as an int (i <sil=0.965> .PERIOD e <sil=0.590> .PERIOD integers) <sil=0.641> ,COMMA but typically has a size of one byte <sil=0.938> .PERIOD The size of a byte is specified by the macro CHAR_BIT which specifies the number of bits in a char (byte) <sil=0.932> .PERIOD In standard C it never can be less than 8 bits <sil=0.941> .PERIOD A variable of type char is most often used to store character data <sil=0.346> ,COMMA hence its name <sil=0.914> .PERIOD Most implementations use the ASCII character set as the execution character set <sil=0.620> ,COMMA but it's best not to know or care about that unless the actual values are important <sil=0.938> .PERIOD Examples of character literals are 'a' <sil=0.414> ,COMMA 'b' <sil=0.592> ,COMMA '1' <sil=0.415> ,COMMA etc <sil=0.992> .PERIOD  <sil=0.531> ,COMMA as well as some special characters such as '\0' (the null character) and '\n' (newline <sil=0.450> ,COMMA recall ”Hello <sil=0.463> ,COMMA World”) <sil=0.941> .PERIOD Note that the char value must be enclosed within single quotations <sil=0.991> .PERIOD When we initialize a character variable <sil=0.445> ,COMMA we can do it two ways <sil=0.923> .PERIOD One is preferred <sil=0.626> ,COMMA the other way is bad programming practice <sil=0.959> .PERIOD The first way is to write char letter1 = 'a' <sil=0.496> ;SEMICOLON This is good programming practice in that it allows a person reading your code to understand that letter1 is being initialized with the letter 'a' to start off with <sil=0.948> .PERIOD The second way <sil=0.450> ,COMMA which should not be used when you are coding letter characters <sil=0.601> ,COMMA is to write char letter2 = 97 <sil=0.390> ;SEMICOLON /* in ASCII <sil=0.564> ,COMMA 97 = 'a' */
This is considered by some to be extremely bad practice <sil=0.336> ,COMMA if we are using it to store a character <sil=0.398> ,COMMA not a small number <sil=0.350> ,COMMA in that if someone reads your code <sil=0.372> ,COMMA most readers are forced to look up what character corresponds with the number 97 in the encoding scheme <sil=0.940> .PERIOD In the end <sil=0.587> ,COMMA letter1 and letter2 store both the same thing – the letter 'a' <sil=0.548> ,COMMA but the first method is clearer <sil=0.405> ,COMMA easier to debug <sil=0.638> ,COMMA and much more straightforward <sil=0.923> .PERIOD One important thing to mention is that characters for numerals are represented differently from their corresponding number <sil=0.539> ,COMMA i <sil=0.553> .PERIOD e <sil=0.643> .PERIOD '1' is not equal to 1 <sil=0.983> .PERIOD In short <sil=0.490> ,COMMA any single entry that is enclosed within 'single quotes' <sil=0.979> .PERIOD There is one more kind of literal that needs to be explained in connection with chars: the string literal <sil=0.936> .PERIOD A string is a series of characters <sil=0.618> ,COMMA usually intended to be displayed <sil=0.978> .PERIOD They are surrounded by double quotations (” ” <sil=0.523> ,COMMA not ' ') <sil=0.988> .PERIOD An example of a string literal is the ”Hello <sil=0.378> ,COMMA World <sil=0.862> !EXCLAMATIONMARK \n” in the ”Hello <sil=0.374> ,COMMA World” example <sil=0.913> .PERIOD The string literal is assigned to a character array <sil=0.530> ,COMMA arrays are described later <sil=0.915> .PERIOD Example:
const char MY_CONSTANT_PEDANTIC_ITCH[] = "learn the usage context <sil=0.947> .PERIOD \n" <sil=0.313> ;SEMICOLON printf("Square brackets after a variable name means it is a pointer to a string
of memory blocks the size of the type of the array element <sil=0.902> .PERIOD \n") <sil=0.333> ;SEMICOLON The float type
float is short for floating point <sil=0.943> .PERIOD It stores inexact representations of real numbers <sil=0.639> ,COMMA both integer and non-integer values <sil=0.992> .PERIOD It can be used with numbers that are much greater than the greatest possible int <sil=0.986> .PERIOD float literals must be suffixed with F or f <sil=0.911> .PERIOD Examples are: 3 <sil=0.954> .PERIOD 1415926f <sil=0.606> ,COMMA 4 <sil=0.443> .PERIOD 0f <sil=0.376> ,COMMA 6 <sil=0.988> .PERIOD 022e+23f <sil=0.934> .PERIOD It is important to note that floating-point numbers are inexact <sil=0.916> .PERIOD Some numbers like 0 <sil=0.936> .PERIOD 1f cannot be represented exactly as floats but will have a small error <sil=0.916> .PERIOD Very large and very small numbers will have less precision and arithmetic operations are sometimes not associative or distributive because of a lack of precision <sil=0.906> .PERIOD Nonetheless <sil=0.591> ,COMMA floating-point numbers are most commonly used for approximating real numbers and operations on them are efficient on modern microprocessors <sil=0.960> .PERIOD Floating-point arithmetic is explained in more detail on Wikipedia <sil=0.919> .PERIOD float variables can be declared using the float keyword <sil=0.900> .PERIOD A float is only one machine word in size <sil=0.968> .PERIOD Therefore <sil=0.604> ,COMMA it is used when less precision than a double provides is required <sil=0.965> .PERIOD The double type
The double and float types are very similar <sil=0.959> .PERIOD The float type allows you to store singleprecision floating point numbers <sil=0.334> ,COMMA while the double keyword allows you to store doubleprecision floating point numbers – real numbers <sil=0.490> ,COMMA in other words <sil=0.930> .PERIOD Its size is typically two machine words <sil=0.376> ,COMMA or 8 bytes on most machines <sil=0.987> .PERIOD Examples of double literals are 3 <sil=0.920> .PERIOD 1415926535897932 <sil=0.584> ,COMMA 4 <sil=0.490> .PERIOD 0 <sil=0.371> ,COMMA 6 <sil=0.944> .PERIOD 022e+23 (scientific notation) <sil=0.963> .PERIOD If you use 4 instead of 4 <sil=0.958> .PERIOD 0 <sil=0.348> ,COMMA the 4 will be interpreted as an int <sil=0.959> .PERIOD The distinction between floats and doubles was made because of the differing sizes of the two types <sil=0.905> .PERIOD When C was first used <sil=0.643> ,COMMA space was at a minimum and so the judicious use of a float instead of a double saved some memory <sil=0.978> .PERIOD Nowadays <sil=0.413> ,COMMA with memory more freely available <sil=0.494> ,COMMA you rarely need to conserve memory like this – it may be better to use doubles consistently <sil=0.996> .PERIOD Indeed <sil=0.626> ,COMMA some C implementations use doubles instead of floats when you declare a float variable <sil=0.979> .PERIOD If you want to use a double variable <sil=0.380> ,COMMA use the double keyword <sil=0.937> .PERIOD sizeof
If you have any doubts as to the amount of memory actually used by any variable (and this goes for types we'll discuss later <sil=0.648> ,COMMA also) <sil=0.615> ,COMMA you can use the sizeof operator to find out for sure <sil=0.995> .PERIOD (For completeness <sil=0.472> ,COMMA it is important to mention that sizeof is a unary operator <sil=0.560> ,COMMA not a function <sil=0.362> .PERIOD ) Its syntax is:
sizeof object sizeof(type)
The two expressions above return the size of the object and type specified <sil=0.459> ,COMMA in bytes <sil=0.492> .PERIOD The return type is size_t (defined in the header <stddef <sil=0.977> .PERIOD h>) which is an unsigned value <sil=0.944> .PERIOD Here's an example usage:
size_t size <sil=0.514> ;SEMICOLON int i <sil=0.484> ;SEMICOLON size = sizeof(i) <sil=0.612> ;SEMICOLON size will be set to 4 <sil=0.402> ,COMMA assuming CHAR_BIT is defined as 8 <sil=0.469> ,COMMA and an integer is 32 bits wide <sil=0.992> .PERIOD The value of sizeof's result is the number of bytes <sil=0.988> .PERIOD Note that when sizeof is applied to a char <sil=0.345> ,COMMA the result is 1 <sil=0.591> ;SEMICOLON that is:
sizeof(char) always returns 1 <sil=0.982> .PERIOD Data type modifiers
One can alter the data storage of any data type by preceding it with certain modifiers <sil=0.909> .PERIOD long and short are modifiers that make it possible for a data type to use either more or less memory <sil=0.938> .PERIOD The int keyword need not follow the short and long keywords <sil=0.932> .PERIOD This is most commonly the case <sil=0.904> .PERIOD A short can be used where the values fall within a lesser range than that of an int <sil=0.534> ,COMMA typically -32768 to 32767 <sil=0.923> .PERIOD A long can be used to contain an extended range of values <sil=0.976> .PERIOD It is not guaranteed that a short uses less memory than an int <sil=0.632> ,COMMA nor is it guaranteed that a long takes up more memory than an int <sil=0.969> .PERIOD It is only guaranteed that sizeof(short) <= sizeof(int) <= sizeof(long) <sil=0.914> .PERIOD Typically a short is 2 bytes <sil=0.427> ,COMMA an int is 4 bytes <sil=0.493> ,COMMA and a long either 4 or 8 bytes <sil=0.921> .PERIOD Modern C compilers also provide long long which is typically an 8 byte integer <sil=0.981> .PERIOD In all of the types described above <sil=0.510> ,COMMA one bit is used to indicate the sign (positive or negative) of a value <sil=1.000> .PERIOD If you decide that a variable will never hold a negative value <sil=0.633> ,COMMA you may use the unsigned modifier to use that one bit for storing other data <sil=0.439> ,COMMA effectively doubling the range of values while mandating that those values be positive <sil=0.994> .PERIOD The unsigned specifier also may be used without a trailing int <sil=0.379> ,COMMA in which case the size defaults to that of an int <sil=0.925> .PERIOD There is also a signed modifier which is the opposite <sil=0.525> ,COMMA but it is not necessary <sil=0.439> ,COMMA except for certain uses of char <sil=0.391> ,COMMA and seldom used since all types (except char) are signed by default <sil=0.996> .PERIOD To use a modifier <sil=0.468> ,COMMA just declare a variable with the data type and relevant modifiers:
unsigned short int usi <sil=0.325> ;SEMICOLON /* fully qualified -- unsigned short int */
short si <sil=0.415> ;SEMICOLON /* short int */
unsigned long uli <sil=0.416> ;SEMICOLON /* unsigned long int */
const qualifier
When the const qualifier is used <sil=0.571> ,COMMA the declared variable must be initialized at declaration <sil=0.937> .PERIOD It is then not allowed to be changed <sil=0.948> .PERIOD While the idea of a variable that never changes may not seem useful <sil=0.350> ,COMMA there are good reasons to use const <sil=0.913> .PERIOD For one thing <sil=0.609> ,COMMA many compilers can perform some small optimizations on data when it knows that data will never change <sil=0.911> .PERIOD For example <sil=0.314> ,COMMA if you need the value of <sil=0.928> ?QUESTIONMARK in your calculations <sil=0.571> ,COMMA you can declare a const variable of pi <sil=0.464> ,COMMA so a program or another function written by someone else cannot change the value of pi <sil=0.926> .PERIOD Note that a Standard conforming compiler must issue a warning if an attempt is made to change a const variable - but after doing so the compiler is free to ignore the const qualifier <sil=0.997> .PERIOD Magic numbers
When you write C programs <sil=0.487> ,COMMA you may be tempted to write code that will depend on certain numbers <sil=0.964> .PERIOD For example <sil=0.610> ,COMMA you may be writing a program for a grocery store <sil=0.999> .PERIOD This complex program has thousands upon thousands of lines of code <sil=0.982> .PERIOD The programmer decides to represent the cost of a can of corn <sil=0.301> ,COMMA currently 99 cents <sil=0.384> ,COMMA as a literal throughout the code <sil=0.932> .PERIOD Now <sil=0.313> ,COMMA assume the cost of a can of corn changes to 89 cents <sil=0.998> .PERIOD The programmer must now go in and manually change each entry of 99 cents to 89 <sil=0.988> .PERIOD While this is not that big of a problem <sil=0.466> ,COMMA considering the ”global find-replace” function of many text editors <sil=0.463> ,COMMA consider another problem: the cost of a can of green beans is also initially 99 cents <sil=0.946> .PERIOD To reliably change the price <sil=0.309> ,COMMA you have to look at every occurrence of the number 99 <sil=0.959> .PERIOD C possesses certain functionality to avoid this <sil=0.935> .PERIOD This functionality is approximately equivalent <sil=0.326> ,COMMA though one method can be useful in one circumstance <sil=0.411> ,COMMA over another <sil=0.983> .PERIOD Using the const keyword
The const keyword helps eradicate magic numbers <sil=0.954> .PERIOD By declaring a variable const corn at the beginning of a block <sil=0.586> ,COMMA a programmer can simply change that const and not have to worry about setting the value elsewhere <sil=0.914> .PERIOD There is also another method for avoiding magic numbers <sil=0.931> .PERIOD It is much more flexible than const <sil=0.463> ,COMMA and also much more problematic in many ways <sil=0.932> .PERIOD It also involves the preprocessor <sil=0.600> ,COMMA as opposed to the compiler <sil=0.971> .PERIOD Behold <sil=0.941> .PERIOD  <sil=0.339> .PERIOD  <sil=0.459> .PERIOD #define
When you write programs <sil=0.627> ,COMMA you can create what is known as a macro <sil=0.585> ,COMMA so when the computer is reading your code <sil=0.379> ,COMMA it will replace all instances of a word with the specified expression <sil=0.941> .PERIOD Here's an example <sil=0.935> .PERIOD If you write
#define PRICE_OF_CORN 0 <sil=0.939> .PERIOD 99
when you want to <sil=0.457> ,COMMA for example <sil=0.487> ,COMMA print the price of corn <sil=0.439> ,COMMA you use the word PRICE_OF_CORN instead of the number 0 <sil=0.991> .PERIOD 99 – the preprocessor will replace all instances of PRICE_OF_CORN with 0 <sil=0.922> .PERIOD 99 <sil=0.335> ,COMMA which the compiler will interpret as the literal double 0 <sil=0.933> .PERIOD 99 <sil=0.413> .PERIOD The preprocessor performs substitution <sil=0.595> ,COMMA that is <sil=0.639> ,COMMA PRICE_OF_CORN is replaced by 0 <sil=0.917> .PERIOD 99 so this means there is no need for a semicolon <sil=0.910> .PERIOD It is important to note that #define has basically the same functionality as the ”find-andreplace” function in a lot of text editors/word processors <sil=0.928> .PERIOD For some purposes <sil=0.428> ,COMMA #define can be harmfully used <sil=0.517> ,COMMA and it is usually preferable to use const if #define is unnecessary <sil=0.917> .PERIOD It is possible <sil=0.375> ,COMMA for instance <sil=0.346> ,COMMA to #define <sil=0.404> ,COMMA say <sil=0.483> ,COMMA a macro DOG as the number 3 <sil=0.418> ,COMMA but if you try to print the macro <sil=0.633> ,COMMA thinking that DOG represents a string that you can show on the screen <sil=0.344> ,COMMA the program will have an error <sil=0.905> .PERIOD #define also has no regard for type <sil=0.980> .PERIOD It disregards the structure of your program <sil=0.612> ,COMMA replacing the text everywhere (in effect <sil=0.589> ,COMMA disregarding scope) <sil=0.599> ,COMMA which could be advantageous in some circumstances <sil=0.536> ,COMMA but can be the source of problematic bugs <sil=0.916> .PERIOD You will see further instances of the #define directive later in the text <sil=0.957> .PERIOD It is good convention to write #defined words in all capitals <sil=0.578> ,COMMA so a programmer will know that this is not a variable that you have declared but a #defined macro <sil=0.945> .PERIOD It is not necessary to end a preprocessor directive such as #define with a semicolon <sil=0.456> ;SEMICOLON in fact <sil=0.510> ,COMMA some compilers may warn you about unnecessary tokens in your code if you do <sil=0.906> .PERIOD Scope 
In the Basic Concepts section <sil=0.565> ,COMMA the concept of scope was introduced <sil=0.905> .PERIOD It is important to revisit the distinction between local types and global types <sil=0.341> ,COMMA and how to declare variables of each <sil=0.935> .PERIOD To declare a local variable <sil=0.340> ,COMMA you place the declaration at the beginning (i <sil=0.927> .PERIOD e <sil=0.540> .PERIOD before any non-declarative statements) of the block to which the variable is intended to be local <sil=0.921> .PERIOD To declare a global variable <sil=0.617> ,COMMA declare the variable outside of any block <sil=0.971> .PERIOD If a variable is global <sil=0.529> ,COMMA it can be read <sil=0.470> ,COMMA and written <sil=0.548> ,COMMA from anywhere in your program <sil=0.995> .PERIOD Global variables are not considered good programming practice <sil=0.436> ,COMMA and should be avoided whenever possible <sil=0.970> .PERIOD They inhibit code readability <sil=0.541> ,COMMA create naming conflicts <sil=0.628> ,COMMA waste memory <sil=0.648> ,COMMA and can create difficult-to-trace bugs <sil=0.962> .PERIOD Excessive usage of globals is usually a sign of laziness or poor design <sil=0.941> .PERIOD However <sil=0.644> ,COMMA if there is a situation where local variables may create more obtuse and unreadable code <sil=0.549> ,COMMA there's no shame in using globals <sil=0.973> .PERIOD Other Modifiers
Included here <sil=0.648> ,COMMA for completeness <sil=0.426> ,COMMA are more of the modifiers that standard C provides <sil=0.938> .PERIOD For the beginning programmer <sil=0.588> ,COMMA static and extern may be useful <sil=0.994> .PERIOD volatile is more of interest to advanced programmers <sil=0.937> .PERIOD register and auto are largely deprecated and are generally not of interest to either beginning or advanced programmers <sil=0.972> .PERIOD static
static is sometimes a useful keyword <sil=0.922> .PERIOD It is a common misbelief that the only purpose is to make a variable stay in memory <sil=0.920> .PERIOD When you declare a function or global variable as static <sil=0.512> ,COMMA you cannot access the function or variable through the extern (see below) keyword from other files in your project <sil=0.979> .PERIOD This is called static linkage <sil=0.943> .PERIOD When you declare a local variable as static <sil=0.371> ,COMMA it is created just like any other variable <sil=0.928> .PERIOD However <sil=0.342> ,COMMA when the variable goes out of scope (i <sil=0.927> .PERIOD e <sil=0.419> .PERIOD the block it was local to is finished) the variable stays in memory <sil=0.632> ,COMMA retaining its value <sil=0.938> .PERIOD The variable stays in memory until the program ends <sil=0.929> .PERIOD While this behaviour resembles that of global variables <sil=0.393> ,COMMA static variables still obey scope rules and therefore cannot be accessed outside of their scope <sil=0.954> .PERIOD This is called static storage duration <sil=0.911> .PERIOD Variables declared static are initialized to zero (or for pointers <sil=0.343> ,COMMA NULL<ref name=””NULLor-zero>http://c-faq <sil=0.928> .PERIOD com/null/nullor0 <sil=0.900> .PERIOD html - NULL or 0 <sil=0.377> ,COMMA which should you use <sil=0.910> ?QUESTIONMARK ) by default <sil=0.907> .PERIOD They can be initialized explicitly on declaration to any constant value <sil=0.960> .PERIOD The initialization is made just once <sil=0.330> ,COMMA at compile time <sil=0.929> .PERIOD You can use static in (at least) two different ways <sil=0.922> .PERIOD Consider this code <sil=0.488> ,COMMA and imagine it is in a file called jfile <sil=0.926> .PERIOD c:
#include <stdio <sil=0.997> .PERIOD h> static int j = 0 <sil=0.627> ;SEMICOLON void up(void) {
/* k is set to 0 when the program starts <sil=0.983> .PERIOD The line is then "ignored"
* for the rest of the program (i <sil=0.908> .PERIOD e <sil=0.580> .PERIOD * k is not set to 0 every time up()
* is called)
*/
static int k = 0 <sil=0.378> ;SEMICOLON j++ <sil=0.360> ;SEMICOLON k++ <sil=0.575> ;SEMICOLON printf("up() called <sil=0.983> .PERIOD k= %2d <sil=0.314> ,COMMA j= %2d\n" <sil=0.320> ,COMMA k <sil=0.519> ,COMMA j) <sil=0.372> ;SEMICOLON }
void down(void)
{
static int k = 0 <sil=0.342> ;SEMICOLON j-- <sil=0.423> ;SEMICOLON k-- <sil=0.503> ;SEMICOLON printf("down() called <sil=0.998> .PERIOD k= %2d <sil=0.450> ,COMMA j= %2d\n" <sil=0.530> ,COMMA k <sil=0.641> ,COMMA j) <sil=0.399> ;SEMICOLON }
int main(void)
{ int i <sil=0.325> ;SEMICOLON /* call the up function 3 times <sil=0.584> ,COMMA then the down function 2 times */
for (i = 0 <sil=0.517> ;SEMICOLON i < 3 <sil=0.370> ;SEMICOLON i++) up() <sil=0.606> ;SEMICOLON for (i = 0 <sil=0.381> ;SEMICOLON i < 2 <sil=0.584> ;SEMICOLON i++) down() <sil=0.318> ;SEMICOLON return 0 <sil=0.336> ;SEMICOLON }
The j variable is accessible by both up and down and retains its value <sil=0.948> .PERIOD The k variables also retain their value <sil=0.452> ,COMMA but they are two different variables <sil=0.320> ,COMMA one in each of their scopes <sil=0.945> .PERIOD Static variables are a good way to implement encapsulation <sil=0.387> ,COMMA a term from the object-oriented way of thinking that effectively means not allowing changes to be made to a variable except through function calls <sil=0.915> .PERIOD Running the program above will produce the following output:
up() called <sil=0.985> .PERIOD k= 1 <sil=0.608> ,COMMA j= 1 up() called <sil=0.908> .PERIOD k= 2 <sil=0.540> ,COMMA j= 2 up() called <sil=0.982> .PERIOD k= 3 <sil=0.494> ,COMMA j= 3 down() called <sil=0.932> .PERIOD k= -1 <sil=0.421> ,COMMA j= 2 down() called <sil=0.949> .PERIOD k= -2 <sil=0.344> ,COMMA j= 1
Features of static variables :
* Keyword used	- static
* Storage	- Memory
* Default value	- Zero
* Scope	- Local to the block in which it is declared
* Lifetime	- Value persists between different function calls
* Keyword optionality - Mandatory to use the keyword
extern
extern is used when a file needs to access a variable in another file that it may not have #included directly <sil=0.937> .PERIOD Therefore <sil=0.411> ,COMMA extern does not actually carve out space for a new variable <sil=0.445> ,COMMA it just provides the compiler with sufficient information to access the remote variable <sil=0.985> .PERIOD Features of extern variable : 
  * Keyword used	- extern
  * Storage	- Memory
  * Default value	- Zero
  * Scope	- Global (all over the program)
  * Lifetime	- Value persists till the program's execution comes to an end
  * Keyword optionality - Optional if declared outside all the functions
volatile
volatile is a special type of modifier which informs the compiler that the value of the variable may be changed by external entities other than the program itself <sil=0.920> .PERIOD This is necessary for certain programs compiled with optimizations – if a variable were not defined volatile then the compiler may assume that certain operations involving the variable are safe to optimize away when in fact they aren't <sil=0.977> .PERIOD volatile is particularly relevant when working with embedded systems (where a program may not have complete control of a variable) and multi-threaded applications <sil=0.935> .PERIOD auto
auto is a modifier which specifies an ”automatic” variable that is automatically created when in scope and destroyed when out of scope <sil=0.994> .PERIOD If you think this sounds like pretty much what you've been doing all along when you declare a variable <sil=0.598> ,COMMA you're right: all declared items within a block are implicitly ”automatic” <sil=0.959> .PERIOD For this reason <sil=0.323> ,COMMA the auto keyword is more like the answer to a trivia question than a useful modifier <sil=0.333> ,COMMA and there are lots of very competent programmers that are unaware of its existence <sil=0.954> .PERIOD Features of automatic variables :
  * Keyword used	- auto
  * Storage	- Memory
  * Default value	- Garbage value (random value)
  * Scope	- Local to the block in which it is defined
  * Lifetime	- Value persists while the control remains within the block
  * Keyword optionality – Optional
register
register is a hint to the compiler to attempt to optimize the storage of the given variable by storing it in a register of the computer's CPU when the program is run <sil=0.915> .PERIOD Most optimizing compilers do this anyway <sil=0.506> ,COMMA so use of this keyword is often unnecessary <sil=0.951> .PERIOD In fact <sil=0.431> ,COMMA ANSI C states that a compiler can ignore this keyword if it so desires – and many do <sil=0.934> .PERIOD Microsoft Visual C++ is an example of an implementation that completely ignores the register keyword <sil=0.955> .PERIOD Features of register variables :
  * Keyword used	- register
  * Storage	- CPU registers (values can be retrieved faster than from memory)
  * Default value	- Garbage value
  * Scope	- Local to the block in which it is defined
  * Lifetime	- Value persists while the control remains within the block
  * Keyword optionality - Mandatory to use the keyword
Concepts
• Variables
• Types
• Data Structures
• Arrays
Error handling
C does not provide direct support for error handling (also known as exception handling) <sil=0.964> .PERIOD By convention <sil=0.378> ,COMMA the programmer is expected to prevent errors from occurring in the first place <sil=0.510> ,COMMA and test return values from functions <sil=0.922> .PERIOD For example <sil=0.594> ,COMMA -1 and NULL are used in several functions such as socket() (Unix socket programming) or malloc() respectively to indicate problems that the programmer should be aware about <sil=0.943> .PERIOD In a worst case scenario where there is an unavoidable error and no way to recover from it <sil=0.390> ,COMMA a C programmer usually tries to log the error and ”gracefully” terminate the program <sil=0.941> .PERIOD There is an external variable called ”errno” <sil=0.502> ,COMMA accessible by the programs after including <errno <sil=0.949> .PERIOD h> - that file comes from the definition of the possible errors that can occur in some Operating Systems (e <sil=0.907> .PERIOD g <sil=0.926> .PERIOD Linux - in this case <sil=0.420> ,COMMA the definition is in include/asm-generic/errno <sil=0.944> .PERIOD h) when programs ask for resources <sil=0.970> .PERIOD Such variable indexes error descriptions accessible by the function 'strerror( errno )' <sil=0.965> .PERIOD The following code tests the return value from the library function malloc to see if dynamic memory allocation completed properly:
#include <stdio <sil=0.954> .PERIOD h>
/* perror */
#include <errno <sil=0.992> .PERIOD h>
/* errno */
#include <stdlib <sil=0.905> .PERIOD h>
/* malloc <sil=0.564> ,COMMA free <sil=0.449> ,COMMA exit */
int main(void)
{
/* Pointer to char <sil=0.367> ,COMMA requesting dynamic allocation of 2 <sil=0.591> ,COMMA 000 <sil=0.358> ,COMMA 000 <sil=0.613> ,COMMA 000
* storage elements (declared as an integer constant of type
* unsigned long int) <sil=0.959> .PERIOD * (If your system has less than 2 GB of memory
* available <sil=0.428> ,COMMA then this call to malloc will fail <sil=0.963> .PERIOD )
 */ char *ptr = malloc(2000000000UL) <sil=0.517> ;SEMICOLON if (ptr == NULL) {
perror("malloc failed") <sil=0.307> ;SEMICOLON /* here you might want to exit the program or compensate for that you don't have 2GB available
*/
} else {
/* The rest of the code hereafter can assume that 2 <sil=0.636> ,COMMA 000 <sil=0.480> ,COMMA 000 <sil=0.457> ,COMMA 000 * chars were successfully allocated <sil=0.978> .PERIOD  <sil=0.473> .PERIOD  <sil=0.546> .PERIOD */ free(ptr) <sil=0.405> ;SEMICOLON }
exit(EXIT_SUCCESS) <sil=0.568> ;SEMICOLON /* exiting program */
}
The code snippet above shows the use of the return value of the library function malloc to check for errors <sil=0.966> .PERIOD Many library functions have return values that flag errors <sil=0.530> ,COMMA and thus should be checked by the astute programmer <sil=0.940> .PERIOD In the snippet above <sil=0.608> ,COMMA a NULL pointer returned from malloc signals an error in allocation <sil=0.403> ,COMMA so the program exits <sil=0.921> .PERIOD In more complicated Error handling implementations <sil=0.354> ,COMMA the program might try to handle the error and try to recover from the failed memory allocation <sil=0.983> .PERIOD Preventing divide by zero errors
A common pitfall made by C programmers is not checking if a divisor is zero before a division command <sil=0.906> .PERIOD The following code will produce a runtime error and in most cases <sil=0.445> ,COMMA exit <sil=0.969> .PERIOD int dividend = 50 <sil=0.571> ;SEMICOLON int divisor = 0 <sil=0.409> ;SEMICOLON int quotient <sil=0.588> ;SEMICOLON quotient = (dividend/divisor) <sil=0.554> ;SEMICOLON /* This will produce a runtime error <sil=0.941> !EXCLAMATIONMARK */ 
For reasons beyond the scope of this document <sil=0.417> ,COMMA you must check or make sure that a divisor is never zero <sil=0.996> .PERIOD Alternatively <sil=0.567> ,COMMA for *nix processes <sil=0.440> ,COMMA you can stop the OS from terminating your process by blocking the SIGFPE signal <sil=0.961> .PERIOD The code below fixes this by checking if the divisor is zero before dividing <sil=0.956> .PERIOD #include <stdio <sil=0.912> .PERIOD h> /* for fprintf and stderr */
#include <stdlib <sil=0.986> .PERIOD h> /* for exit */ int main( void )
{ int dividend = 50 <sil=0.501> ;SEMICOLON int divisor = 0 <sil=0.475> ;SEMICOLON int quotient <sil=0.471> ;SEMICOLON if (divisor == 0) {
/* Example handling of this error <sil=1.000> .PERIOD Writing a message to stderr <sil=0.509> ,COMMA and * exiting with failure <sil=0.996> .PERIOD */ fprintf(stderr <sil=0.514> ,COMMA "Division by zero <sil=0.964> !EXCLAMATIONMARK Aborting <sil=0.992> .PERIOD  <sil=0.613> .PERIOD  <sil=0.350> .PERIOD \n") <sil=0.617> ;SEMICOLON exit(EXIT_FAILURE) <sil=0.444> ;SEMICOLON /* indicate failure <sil=0.903> .PERIOD */
}
quotient = dividend / divisor <sil=0.363> ;SEMICOLON exit(EXIT_SUCCESS) <sil=0.621> ;SEMICOLON /* indicate success <sil=0.926> .PERIOD */
}
Signals
In some cases <sil=0.626> ,COMMA the environment may respond to a programming error in C by raising a signal <sil=0.975> .PERIOD Signals are events raised by the host environment or operating system to indicate that a specific error or critical event has occurred (e <sil=0.938> .PERIOD g <sil=0.968> .PERIOD a division by zero <sil=0.409> ,COMMA interrupt <sil=0.371> ,COMMA and so on <sil=0.920> .PERIOD ) However <sil=0.341> ,COMMA these signals are not meant to be used as a means of error catching <sil=0.312> ;SEMICOLON they usually indicate a critical event that will interfere with normal program flow <sil=0.983> .PERIOD To handle signals <sil=0.347> ,COMMA a program needs to use the signal <sil=0.975> .PERIOD h header file <sil=0.968> .PERIOD A signal handler will need to be defined <sil=0.368> ,COMMA and the signal() function is then called to allow the given signal to be handled <sil=0.963> .PERIOD Some signals that are raised to an exception within your code (e <sil=0.996> .PERIOD g <sil=0.928> .PERIOD a division by zero) are unlikely to allow your program to recover <sil=0.956> .PERIOD These signal handlers will be required to instead ensure that some resources are properly cleaned up before the program terminates <sil=0.970> .PERIOD This example creates a signal handler and raises the signal:
#include <signal <sil=0.997> .PERIOD h>
#include <stdio <sil=0.958> .PERIOD h> #include <stdlib <sil=0.920> .PERIOD h>
static void catch_function(int signal) { puts("Interactive attention signal caught <sil=0.903> .PERIOD ") <sil=0.500> ;SEMICOLON }
int main(void) { if (signal(SIGINT <sil=0.397> ,COMMA catch_function) == SIG_ERR) { fputs("An error occurred while setting a signal handler <sil=0.990> .PERIOD \n" <sil=0.490> ,COMMA stderr) <sil=0.478> ;SEMICOLON return EXIT_FAILURE <sil=0.620> ;SEMICOLON }
puts("Raising the interactive attention signal <sil=0.995> .PERIOD ") <sil=0.579> ;SEMICOLON if (raise(SIGINT) <sil=0.992> !EXCLAMATIONMARK = 0) { fputs("Error raising the signal <sil=0.974> .PERIOD \n" <sil=0.476> ,COMMA stderr) <sil=0.355> ;SEMICOLON return EXIT_FAILURE <sil=0.386> ;SEMICOLON }
puts("Exiting <sil=0.916> .PERIOD ") <sil=0.315> ;SEMICOLON return 0 <sil=0.496> ;SEMICOLON }
setjmp
The setjmp function can be used to emulate the exception handling feature of other programming languages <sil=0.902> .PERIOD The first call to setjmp provides a reference point to returning to a given function <sil=0.568> ,COMMA and is valid as long as the function containing setjmp() doesn't return or exit <sil=0.977> .PERIOD A call to longjmp causes the execution to return to the point of the associated setjmp call <sil=0.975> .PERIOD #include <stdio <sil=0.903> .PERIOD h> #include <setjmp <sil=0.991> .PERIOD h> jmp_buf test1 <sil=0.618> ;SEMICOLON void tryjump()
{ longjmp(test1 <sil=0.520> ,COMMA 3) <sil=0.565> ;SEMICOLON }
int main (void)
{ if (setjmp(test1)==0) { printf ("setjmp() returned 0 <sil=0.968> .PERIOD ") <sil=0.594> ;SEMICOLON tryjump() <sil=0.334> ;SEMICOLON } else { printf ("setjmp returned from a longjmp function call <sil=0.961> .PERIOD ") <sil=0.613> ;SEMICOLON }
}
The values of non-volatile variables may be corrupted when setjmp returns from a longjmp call <sil=0.985> .PERIOD While setjmp() and longjmp() may be used for error handling <sil=0.356> ,COMMA it is generally preferred to use the return value of a function to indicate an error <sil=0.430> ,COMMA if possible <sil=0.975> .PERIOD Simple Input and Output
When you take time to consider it <sil=0.531> ,COMMA a computer would be pretty useless without some way to talk to the people who use it <sil=0.912> .PERIOD Just like we need information in order to accomplish tasks <sil=0.560> ,COMMA so do computers <sil=0.924> .PERIOD And just as we supply information to others so that they can do tasks <sil=0.415> ,COMMA so do computers <sil=0.913> .PERIOD These supplies and returns of information to a computer are called input and output <sil=0.995> .PERIOD 'Input' is information supplied to a computer or program <sil=0.995> .PERIOD 'Output' is information provided by a computer or program <sil=0.968> .PERIOD Frequently <sil=0.313> ,COMMA computer programmers will lump the discussion in the more general term input/output or simply <sil=0.507> ,COMMA I/O <sil=0.964> .PERIOD In C <sil=0.548> ,COMMA there are many different ways for a program to communicate with the user <sil=0.989> .PERIOD Amazingly <sil=0.627> ,COMMA the most simple methods usually taught to beginning programmers may also be the most powerful <sil=0.927> .PERIOD In the Hello <sil=0.572> ,COMMA World <sil=0.884> !EXCLAMATIONMARK 1 example at the beginning of this text <sil=0.528> ,COMMA we were introduced to a Standard Library file stdio <sil=0.929> .PERIOD h <sil=0.986> ,COMMA and one of its functions <sil=0.599> ,COMMA printf() <sil=0.979> .PERIOD Here we discuss more of the functions that stdio <sil=0.994> .PERIOD h gives us <sil=0.996> .PERIOD Output using printf()
Recall from the beginning of this text the demonstration program duplicated below:
#include <stdio <sil=0.992> .PERIOD h>
int main(void)
{ printf("Hello <sil=0.524> ,COMMA World <sil=0.915> !EXCLAMATIONMARK ") <sil=0.332> ;SEMICOLON return 0 <sil=0.327> ;SEMICOLON }
If you compile and run this program <sil=0.324> ,COMMA you will see the sentence below show up on your screen:
Hello <sil=0.590> ,COMMA world <sil=0.871> !EXCLAMATIONMARK This amazing accomplishment was achieved by using the function printf() <sil=0.999> .PERIOD A function is like a ”black box” that does something for you without exposing the internals inside <sil=0.919> .PERIOD We can write functions ourselves in C <sil=0.631> ,COMMA but we will cover that later <sil=0.906> .PERIOD You have seen that to use printf() one puts text <sil=0.529> ,COMMA surrounded by quotes <sil=0.365> ,COMMA in between the parentheses <sil=0.934> .PERIOD We call the text surrounded by quotes a literal string (or just a string) <sil=0.533> ,COMMA and we call that string an argument to printf <sil=0.931> .PERIOD Simple Input and Output
As a note of explanation <sil=0.322> ,COMMA it is sometimes convenient to include the open and closing parentheses after a function name to remind us that it is <sil=0.308> ,COMMA indeed <sil=0.311> ,COMMA a function <sil=0.965> .PERIOD However usually when the name of the function we are talking about is understood <sil=0.419> ,COMMA it is not necessary <sil=0.945> .PERIOD As you can see in the example above <sil=0.345> ,COMMA using printf() can be as simple as typing in some text <sil=0.348> ,COMMA surrounded by double quotes (note that these are double quotes and not two single quotes) <sil=0.926> .PERIOD So <sil=0.623> ,COMMA for example <sil=0.640> ,COMMA you can print any string by placing it as an argument to the printf() function:
printf(”This sentence will print out exactly as you see it <sil=0.953> .PERIOD  <sil=0.464> .PERIOD  <sil=0.503> .PERIOD ”) <sil=0.565> ;SEMICOLON And once it is contained in a proper main() function <sil=0.519> ,COMMA it will show:
This sentence will print out exactly as you see it <sil=0.928> .PERIOD  <sil=0.618> .PERIOD  <sil=0.629> .PERIOD Printing numbers and escape sequences
Placeholder codes
The printf() function is a powerful function <sil=0.418> ,COMMA and is probably the most-used function in C programs <sil=0.914> .PERIOD For example <sil=0.504> ,COMMA let us look at a problem <sil=0.933> .PERIOD Say we don't know what 19 + 31 is <sil=0.912> .PERIOD Let's use C to get the answer <sil=0.960> .PERIOD We start writing
#include "stdio <sil=0.962> .PERIOD h" // this is important <sil=0.393> ,COMMA since printf
// can't be used without this header
int main(void)
{ printf("19+31 is") <sil=0.400> ;SEMICOLON But here we are stuck <sil=0.954> !EXCLAMATIONMARK printf() only prints strings <sil=0.865> !EXCLAMATIONMARK Thankfully <sil=0.407> ,COMMA printf has methods for printing numbers <sil=0.921> .PERIOD What we do is put a placeholder format code in the string <sil=0.987> .PERIOD We write:
printf("19+31 is '''%d'''" <sil=0.360> ,COMMA 19+31) <sil=0.567> ;SEMICOLON The placeholder %d literally ”holds the place” for the actual number that is the result of adding 19 to 31 <sil=0.994> .PERIOD These placeholders are called format specifiers <sil=0.919> .PERIOD Many other format specifiers work with printf() <sil=0.944> .PERIOD If we have a floating-point number <sil=0.528> ,COMMA we can use %f to print out a floating-point number <sil=0.446> ,COMMA decimal point and all <sil=0.923> .PERIOD Other format specifiers are:
• %d - int (same as %i)
• %ld - long int (same as %li)
• %f – float
• %lf – double 
• %c - char
• %s - string
• %x - hexadecimal
A complete listing of all the format specifiers for printf() is on Wikipedia <sil=0.948> .PERIOD Tabs and newlines
printf() will not put line breaks in at the end of each statement: we must do this ourselves <sil=0.964> .PERIOD But how <sil=0.900> ?QUESTIONMARK What we can do is use the newline escape character <sil=0.914> .PERIOD An escape character is a special character that we can write but will do something special onscreen <sil=0.305> ,COMMA such as make a beep <sil=0.458> ,COMMA write a tab <sil=0.648> ,COMMA and so on <sil=0.922> .PERIOD To write a newline we write \n <sil=0.903> .PERIOD All escape characters start with a backslash <sil=0.924> .PERIOD So to achieve the output above <sil=0.386> ,COMMA we write
printf(" 1905\n312 +\n-----\n") <sil=0.390> ;SEMICOLON or to be a bit more clear <sil=0.452> ,COMMA we can break this long printf statement over several lines <sil=0.943> .PERIOD So our program will be
#include <stdio <sil=0.902> .PERIOD h>
int main(void)
{ printf(" 1905\n") <sil=0.576> ;SEMICOLON printf("312 +\n") <sil=0.449> ;SEMICOLON printf("-----\n") <sil=0.534> ;SEMICOLON printf("%d" <sil=0.307> ,COMMA 1905+312) <sil=0.365> ;SEMICOLON return 0 <sil=0.411> ;SEMICOLON }
There are other escape characters we can use <sil=0.961> .PERIOD Another common one is to use \t to write a tab <sil=0.957> .PERIOD You can use \a to ring the computer's bell <sil=0.535> ,COMMA but you should not use this very much in your programs <sil=0.596> ,COMMA as excessive use of sound is not very friendly to the user <sil=0.920> .PERIOD Simple Input and Output
Other output methods
puts()
The puts() function is a very simple way to send a string to the screen when you have no placeholders to be concerned about <sil=0.958> .PERIOD It works very much like the printf() function we saw in the ”Hello <sil=0.624> ,COMMA World <sil=0.901> !EXCLAMATIONMARK ” example:
puts("Print this string <sil=0.968> .PERIOD ") <sil=0.471> ;SEMICOLON will print to the screen:
Print this string <sil=0.949> .PERIOD followed by the newline character (as discussed above) <sil=0.990> .PERIOD (The puts function appends a newline character to its output <sil=0.981> .PERIOD )
Input using scanf()
The scanf() function is the input method equivalent to the printf() output function - simple yet powerful <sil=0.905> .PERIOD In its simplest invocation <sil=0.510> ,COMMA the scanf format string holds a single placeholder representing the type of value that will be entered by the user <sil=0.918> .PERIOD These placeholders are mostly the same as the printf() function - %d for ints <sil=0.485> ,COMMA %f for floats <sil=0.464> ,COMMA and %lf for doubles <sil=0.903> .PERIOD There is <sil=0.535> ,COMMA however <sil=0.966> ,COMMA one variation to scanf() as compared to printf() <sil=0.954> .PERIOD The scanf() function requires the memory address of the variable to which you want to save the input value <sil=0.992> .PERIOD While pointers (variables storing memory addresses) can be used here <sil=0.323> ,COMMA this is a concept that won't be approached until later in the text <sil=0.934> .PERIOD Instead <sil=0.627> ,COMMA the simple technique is to use the address-of operator <sil=0.434> ,COMMA & <sil=0.529> .PERIOD For now it may be best to consider this ”magic” before we discuss pointers <sil=0.944> .PERIOD A typical application might be like this:
#include "stdio <sil=0.911> .PERIOD h"
int main(void)
{ int a <sil=0.409> ;SEMICOLON printf("Please input an integer value: ") <sil=0.300> ;SEMICOLON scanf("%d" <sil=0.426> ,COMMA &a) <sil=0.451> ;SEMICOLON printf("You entered: %d\n" <sil=0.418> ,COMMA a) <sil=0.457> ;SEMICOLON return 0 <sil=0.428> ;SEMICOLON }
If you were to describe the effect of the scanf() function call above <sil=0.588> ,COMMA it might read as: ”Read in an integer from the user and store it at the address of variable a ” <sil=0.942> .PERIOD If you are trying to input a string using scanf <sil=0.476> ,COMMA you should not include the & operator <sil=0.995> .PERIOD The code below will produce a runtime error and the program will likely crash <sil=0.929> .PERIOD scanf("%s" <sil=0.564> ,COMMA &a) <sil=0.343> ;SEMICOLON The correct usage would be:
scanf("%s" <sil=0.443> ,COMMA a) <sil=0.403> ;SEMICOLON This is because <sil=0.484> ,COMMA whenever you use a format specifier for a string (%s) <sil=0.598> ,COMMA the variable that you use to store the value will be an array and <sil=0.540> ,COMMA the array names (in this case - a) themselves point out to their base address and hence <sil=0.564> ,COMMA the address of operator is not required <sil=0.991> .PERIOD (Although <sil=0.374> ,COMMA this is vulnerable to Buffer overflow <sil=0.937> .PERIOD fgets() is preferred to scanf()) <sil=0.913> .PERIOD Note on inputs: When data is typed at a keyboard <sil=0.561> ,COMMA the information does not go straight to the program that is running <sil=0.982> .PERIOD It is first stored in what is known as a buffer - a small amount of memory reserved for the input source <sil=0.918> .PERIOD Sometimes there will be data left in the buffer when the program wants to read from the input source <sil=0.416> ,COMMA and the scanf() function will read this data instead of waiting for the user to type something <sil=0.930> .PERIOD Some may suggest you use the function fflush(stdin) <sil=0.609> ,COMMA which may work as desired on some computers <sil=0.596> ,COMMA but isn't considered good practice <sil=0.535> ,COMMA as you will see later <sil=0.995> .PERIOD Doing this has the downfall that if you take your code to a different computer with a different compiler <sil=0.440> ,COMMA your code may not work properly <sil=0.911> .PERIOD Simple math
Arithmetic Operators
In C <sil=0.608> ,COMMA simple math is very easy to handle <sil=0.975> .PERIOD The following operators exist: + (addition) <sil=0.599> ,COMMA - (subtraction) <sil=0.614> ,COMMA * (multiplication) <sil=0.458> ,COMMA / (division) <sil=0.333> ,COMMA and % (modulus) <sil=0.575> ;SEMICOLON You likely know all of them from your math classes - except <sil=0.409> ,COMMA perhaps <sil=0.399> ,COMMA modulus <sil=0.903> .PERIOD It returns the remainder of a division (e <sil=0.999> .PERIOD g <sil=0.989> .PERIOD 5 % 2 = 1) <sil=0.989> .PERIOD (Modulus is not defined for floating-point numbers <sil=0.352> ,COMMA but the math <sil=0.919> .PERIOD h library has an fmod function <sil=0.998> .PERIOD )
Care must be taken with the modulus <sil=0.366> ,COMMA because it's not the equivalent of the mathematical modulus: (-5) % 2 is not 1 <sil=0.408> ,COMMA but -1 <sil=0.997> .PERIOD Division of integers will return an integer <sil=0.344> ,COMMA and the division of a negative integer by a positive integer will round towards zero instead of rounding down (e <sil=0.910> .PERIOD g <sil=0.928> .PERIOD (-5) / 3 = -1 instead of -2) <sil=0.966> .PERIOD However <sil=0.508> ,COMMA it is always true that for all integer a and nonzero integer b <sil=0.561> ,COMMA ((a / b) * b) + (a % b) == a <sil=0.993> .PERIOD There is no inline operator to do exponentiation (e <sil=0.971> .PERIOD g <sil=0.969> .PERIOD 5 ^ 2 is not 25 [it is 7 <sil=0.429> ;SEMICOLON ^ is the exclusive-or operator] <sil=0.410> ,COMMA and 5 ** 2 is an error) <sil=0.463> ,COMMA but there is a power function <sil=0.984> .PERIOD The mathematical order of operations does apply <sil=0.919> .PERIOD For example (2 + 3) * 2 = 10 while 2 + 3 * 2 = 8 <sil=0.915> .PERIOD Multiplicative operators have precedence over additive operators <sil=0.973> .PERIOD #include <stdio <sil=0.919> .PERIOD h>
int main(void)
{
int i = 0 <sil=0.313> ,COMMA j = 0 <sil=0.556> ;SEMICOLON /* while i is less than 5 AND j is less than 5 <sil=0.582> ,COMMA loop */ while( (i < 5) && (j < 5) )
{
/* postfix increment <sil=0.507> ,COMMA i++
* the value of i is read and then incremented
 */ printf("i: %d\t" <sil=0.481> ,COMMA i++) <sil=0.380> ;SEMICOLON /*
* prefix increment <sil=0.574> ,COMMA ++j
* the value of j is incremented and then read
 */ printf("j: %d\n" <sil=0.310> ,COMMA ++j) <sil=0.440> ;SEMICOLON } printf("At the end they have both equal values:\ni: %d\tj: %d\n" <sil=0.592> ,COMMA i <sil=0.593> ,COMMA j) <sil=0.430> ;SEMICOLON getchar() <sil=0.432> ;SEMICOLON /* pause */ return 0 <sil=0.375> ;SEMICOLON }
will display the following:
i: 0	j: 1 i: 1	j: 2 i: 2	j: 3 i: 3	j: 4 i: 4	j: 5
At the end they have both equal values: i: 5	j: 5
Assignment Operators
The assignment operators are = <sil=0.323> ,COMMA *= <sil=0.627> ,COMMA /= <sil=0.544> ,COMMA %= <sil=0.604> ,COMMA += <sil=0.391> ,COMMA -= <sil=0.492> ,COMMA <<= <sil=0.339> ,COMMA >>= <sil=0.389> ,COMMA &= <sil=0.369> ,COMMA ^= <sil=0.468> ,COMMA and |= <sil=0.912> .PERIOD The = operator stores the value of the right operand into the location determined by the left operand <sil=0.618> ,COMMA which must be an lvalue (a value that has an address <sil=0.428> ,COMMA and therefore can be assigned to) <sil=0.908> .PERIOD For the others <sil=0.569> ,COMMA x op= y is shorthand for x = x op (y <sil=0.960> .PERIOD Hence <sil=0.343> ,COMMA the following expressions are the same:
1 <sil=0.983> .PERIOD x += y	-	x = x+y
2 <sil=0.999> .PERIOD x -= y	-	x = x-y
3 <sil=0.986> .PERIOD x *= y	-	x = x*y
4 <sil=0.971> .PERIOD x /= y	-	x = x/y
5 <sil=0.935> .PERIOD x %= y	-	x = x%y
The value of the assignment expression is the value of the left operand after the assignment <sil=0.905> .PERIOD Thus <sil=0.630> ,COMMA assignments can be chained <sil=0.614> ;SEMICOLON e <sil=0.971> .PERIOD g <sil=0.941> .PERIOD the expression a = b = c = 0 <sil=0.495> ;SEMICOLON would assign the value zero to all three variables <sil=0.948> .PERIOD Logical Operators
The logical operators are && (and) <sil=0.471> ,COMMA and || (or) <sil=0.964> .PERIOD Both of these operators produce 1 if the relationship is true and 0 for false <sil=0.992> .PERIOD Both of these operators short-circuit <sil=0.502> ;SEMICOLON if the result of the expression can be determined from the first operand <sil=0.563> ,COMMA the second is ignored <sil=0.924> .PERIOD The && operator has higher precedence than the || operator <sil=0.938> .PERIOD && is used to evaluate expressions left to right <sil=0.353> ,COMMA and returns a 1 if both statements are true <sil=0.967> .PERIOD int x = 7 <sil=0.554> ;SEMICOLON int y = 5 <sil=0.644> ;SEMICOLON if(x == 7 && y == 5) { <sil=0.980> .PERIOD  <sil=0.385> .PERIOD  <sil=0.455> .PERIOD }
Here <sil=0.646> ,COMMA the && operator checks the left-most expression <sil=0.579> ,COMMA then the expression to its right <sil=0.935> .PERIOD If there were more than two expressions chained (e <sil=0.906> .PERIOD g <sil=0.935> .PERIOD x && y && z) <sil=0.442> ,COMMA the operator would Relational and Equality Operators check x first <sil=0.383> ,COMMA then y <sil=0.466> ,COMMA then continue rightwards to z if neither x or y is zero <sil=0.932> .PERIOD Since both statements return true <sil=0.406> ,COMMA the && operator returns true <sil=0.490> ,COMMA and the code block is executed <sil=0.905> .PERIOD if(x == 5 && y == 5) { <sil=0.913> .PERIOD  <sil=0.333> .PERIOD  <sil=0.362> .PERIOD }
The && operator checks in the same way as before <sil=0.319> ,COMMA and finds that the first expression is false <sil=0.944> .PERIOD The && operator stops evaluating as soon as it finds a statement to be false <sil=0.441> ,COMMA and returns a false <sil=0.916> .PERIOD || is used to evaluate expressions left to right <sil=0.355> ,COMMA and returns a 1 if either of the expressions are true <sil=0.902> .PERIOD /* Use the same variables as before <sil=0.965> .PERIOD */
if(x == 2 || y == 5) { // the || statement checks both expressions <sil=0.368> ,COMMA finds
that the latter is true <sil=0.418> ,COMMA and returns true <sil=0.969> .PERIOD  <sil=0.577> .PERIOD  <sil=0.494> .PERIOD }
The || operator here checks the left-most expression <sil=0.607> ,COMMA finds it false <sil=0.576> ,COMMA but continues to evaluate the next expression <sil=0.991> .PERIOD It finds that the next expression returns true <sil=0.552> ,COMMA stops <sil=0.477> ,COMMA and returns a 1 <sil=0.906> .PERIOD Much how the && operator ceases when it finds an expression that returns false <sil=0.432> ,COMMA the || operator ceases when it finds an expression that returns true <sil=0.914> .PERIOD It is worth noting that C does not have Boolean values (true and false) commonly found in other languages <sil=0.949> .PERIOD It instead interprets a 0 as false <sil=0.521> ,COMMA and any nonzero value as true <sil=0.992> .PERIOD The conditional operator
The ternary <sil=0.929> ?QUESTIONMARK : operator is the conditional operator <sil=0.971> .PERIOD The expression (x <sil=0.899> ?QUESTIONMARK y : z) has the value of y if x is nonzero <sil=0.328> ,COMMA z otherwise <sil=0.930> .PERIOD Example:
int x = 0 <sil=0.415> ;SEMICOLON int y <sil=0.452> ;SEMICOLON y = (x <sil=0.891> ?QUESTIONMARK 10 : 6) <sil=0.417> ;SEMICOLON /* The parentheses are technically not necessary as assignment
has a lower precedence than the conditional operator <sil=0.388> ,COMMA but it's there for clarity <sil=0.971> .PERIOD */
The expression x evaluates to 0 <sil=0.981> .PERIOD The ternary operator then looks for the ”if-false” value <sil=0.434> ,COMMA which in this case <sil=0.500> ,COMMA is 6 <sil=0.907> .PERIOD It returns that <sil=0.642> ,COMMA so y is equal to six <sil=0.929> .PERIOD Had x been a non-zero <sil=0.502> ,COMMA then the expression would have returned a 10 <sil=0.932> .PERIOD Relational and Equality Operators
The relational binary operators < (less than) <sil=0.438> ,COMMA > (greater than) <sil=0.390> ,COMMA <= (less than or equal) <sil=0.517> ,COMMA and >= (greater than or equal) operators return a value of 1 if the result of the operation is true <sil=0.433> ,COMMA 0 if false <sil=0.918> .PERIOD The equality binary operators == (equals) and <sil=0.950> !EXCLAMATIONMARK = (not equals) operators are similar to the relational operators except that their precedence is lower <sil=0.948> .PERIOD Type Casting
A parenthesized type name followed by a cast expression is a cast expression <sil=0.983> .PERIOD The parenthesized type name has the effect of forcing the cast expression into the type specified by the type name in parentheses <sil=0.933> .PERIOD For arithmetic types <sil=0.577> ,COMMA this either does not change the value of the expression <sil=0.357> ,COMMA or truncates the value of the expression if the expression is an integer and the new type is smaller than the previous type <sil=0.926> .PERIOD An example of casting a float as an int:
float pi = 3 <sil=0.941> .PERIOD 141592 <sil=0.349> ;SEMICOLON int truncated_pi = (int)pi <sil=0.486> ;SEMICOLON // truncated_pi == 3 An example of casting a char as an int:
char my_char = 'A' <sil=0.550> ;SEMICOLON int my_int = (int)my_char <sil=0.510> ;SEMICOLON // my_int == 65 <sil=0.402> ,COMMA which is the ASCII value of 'A' 
The Shift Operators (which may be used to rotate bits)
Shift functions are often used in low-level I/O hardware interfacing <sil=0.913> .PERIOD Shift and rotate functions are heavily used in cryptography and software floating point emulation <sil=0.947> .PERIOD Other than that <sil=0.556> ,COMMA shifts can be used in place of division or multiplication by a power of two <sil=0.915> .PERIOD Many processors have dedicated function blocks to make these operations fast -- see Microprocessor Design/Shift and Rotate Blocks <sil=0.947> .PERIOD On processors which have such blocks <sil=0.476> ,COMMA most C compilers compile shift and rotate operators to a single assembly-language instruction -- see X86 Assembly/Shift and Rotate <sil=0.914> .PERIOD shift left
The << operator shifts the binary representation to the left <sil=0.483> ,COMMA dropping the most significant bits and appending it with zero bits <sil=0.938> .PERIOD The result is equivalent to multiplying the integer by a power of two <sil=0.971> .PERIOD unsigned shift right
The unsigned shift right operator <sil=0.507> ,COMMA also sometimes called the logical right shift operator <sil=0.901> .PERIOD It shifts the binary representation to the right <sil=0.557> ,COMMA dropping the least significant bits and prepending it with zeros <sil=0.951> .PERIOD The >> operator is equivalent to division by a power of two for unsigned integers <sil=0.954> .PERIOD signed shift right
The signed shift right operator <sil=0.307> ,COMMA also sometimes called the arithmetic right shift operator <sil=0.967> .PERIOD It shifts the binary representation to the right <sil=0.515> ,COMMA dropping the least significant bit <sil=0.359> ,COMMA but prepending it with copies of the original sign bit <sil=0.936> .PERIOD The >> operator is not equivalent to division for signed integers <sil=0.906> .PERIOD In C <sil=0.378> ,COMMA the behavior of the >> operator depends on the data type it acts on <sil=0.969> .PERIOD Therefore <sil=0.350> ,COMMA a signed and an unsigned right shift looks exactly the same <sil=0.640> ,COMMA but produces a different result in some cases <sil=0.958> .PERIOD Contrary to popular belief <sil=0.498> ,COMMA it is possible to write C code that compiles down to the ”rotate” assembly language instruction (on CPUs that have such an instruction) <sil=0.948> .PERIOD Most compilers recognize this idiom:
  unsigned int x <sil=0.302> ;SEMICOLON unsigned int y <sil=0.490> ;SEMICOLON /* <sil=0.933> .PERIOD  <sil=0.347> .PERIOD  <sil=0.518> .PERIOD */ y = (x >> shift) | (x << (32 - shift)) <sil=0.401> ;SEMICOLON and compile it to a single 32 bit rotate instruction <sil=0.978> .PERIOD On some systems <sil=0.484> ,COMMA this may be ”#define”ed as a macro or defined as an inline function called something like ”rightrotate32” or ”rotr32” or ”ror32” in a standard header file like ”bitops <sil=0.926> .PERIOD h” <sil=0.927> .PERIOD rotate left
Most compilers recognize this idiom:
unsigned int x <sil=0.644> ;SEMICOLON unsigned int y <sil=0.501> ;SEMICOLON /* <sil=0.941> .PERIOD  <sil=0.420> .PERIOD  <sil=0.473> .PERIOD */ y = (x << shift) | (x >> (32 - shift)) <sil=0.351> ;SEMICOLON and compile it to a single 32 bit rotate instruction <sil=0.915> .PERIOD On some systems <sil=0.307> ,COMMA this may be ”#define”ed as a macro or defined as an inline function called something like ”leftrotate32” or ”rotl32” in a header file like ”bitops <sil=0.976> .PERIOD h” <sil=0.908> .PERIOD Relational and equality operators
The relational binary operators < (less than) <sil=0.320> ,COMMA > (greater than) <sil=0.376> ,COMMA <= (less than or equal) <sil=0.306> ,COMMA and >= (greater than or equal) operators return a value of 1 if the result of the operation is true <sil=0.528> ,COMMA 0 if false <sil=0.931> .PERIOD The equality binary operators == (equals) and <sil=0.994> !EXCLAMATIONMARK = (not equals) operators are similar to the relational operators except that their precedence is lower <sil=0.918> .PERIOD Bitwise Operators
The bitwise operators are & (and) <sil=0.643> ,COMMA ^ (exclusive or) and | (inclusive or) <sil=0.939> .PERIOD The & operator has higher precedence than ^ <sil=0.317> ,COMMA which has higher precedence than | <sil=0.992> .PERIOD The values being operated upon must be integral <sil=0.435> ;SEMICOLON the result is integral <sil=0.948> .PERIOD One use for the bitwise operators is to emulate bit flags <sil=0.921> .PERIOD These flags can be set with OR <sil=0.353> ,COMMA tested with AND <sil=0.640> ,COMMA flipped with XOR <sil=0.600> ,COMMA and cleared with AND NOT <sil=0.973> .PERIOD For example:
/* This code is a sample for bitwise operations <sil=0.901> .PERIOD */
#define BITFLAG1	(1)
#define BITFLAG2	(2)
#define BITFLAG3	(4) /* They are powers of 2 */
unsigned bitbucket = 0U <sil=0.318> ;SEMICOLON /* Clear all */
bitbucket |= BITFLAG1 <sil=0.347> ;SEMICOLON /* Set bit flag 1 */
bitbucket &= ~BITFLAG2 <sil=0.350> ;SEMICOLON /* Clear bit flag 2 */
bitbucket ^= BITFLAG3 <sil=0.341> ;SEMICOLON /* Flip the state of bit flag 3 from off to on or vice versa */
if (bitbucket & BITFLAG3) { /* bit flag 3 is set */
} else {
/* bit flag 3 is not set */
}
Comma Operator
The operator with the least precedence is the comma operator <sil=0.936> .PERIOD The value of the expression x <sil=0.614> ,COMMA y will evaluate both x and y <sil=0.365> ,COMMA but provides the value of y <sil=0.935> .PERIOD This operator is useful for including multiple actions in one statement (e <sil=0.901> .PERIOD g <sil=0.972> .PERIOD within a for loop conditional) <sil=0.934> .PERIOD Here are some small examples of the comma operator:
int i <sil=0.369> ,COMMA x <sil=0.433> ;SEMICOLON /* Declares two ints <sil=0.384> ,COMMA i and x <sil=0.525> ,COMMA in one declaration <sil=0.928> .PERIOD Technically <sil=0.472> ,COMMA this is not the comma operator <sil=0.981> .PERIOD */
/* this loop initializes x and i to 0 <sil=0.531> ,COMMA then runs the loop */
for (x = 0 <sil=0.498> ,COMMA i = 0 <sil=0.611> ;SEMICOLON i <= 6 <sil=0.305> ;SEMICOLON i++) { printf("x = %d <sil=0.459> ,COMMA and i = %d\n" <sil=0.427> ,COMMA x <sil=0.530> ,COMMA i) <sil=0.435> ;SEMICOLON }
Further math
The <math <sil=0.964> .PERIOD h> header contains prototypes for several functions that deal with mathematics <sil=0.954> .PERIOD In the 1990 version of the ISO standard <sil=0.308> ,COMMA only the double versions of the functions were specified <sil=0.597> ;SEMICOLON the 1999 version added the float and long double versions <sil=0.961> .PERIOD To use these math functions <sil=0.335> ,COMMA you must link your program with the math library <sil=0.936> .PERIOD For some compilers (including GCC) <sil=0.486> ,COMMA you must specify the additional parameter -lm <sil=0.986> .PERIOD The math functions may produce one of two kinds of errors <sil=0.983> .PERIOD Domain errors occur when the parameters to the functions are invalid <sil=0.584> ,COMMA such as a negative number as a parameter to sqrt (the square root function) <sil=0.977> .PERIOD Range errors occur when the result of the function cannot be expressed in that particular floating-point type <sil=0.396> ,COMMA such as pow(1000 <sil=0.901> .PERIOD 0 <sil=0.607> ,COMMA 1000 <sil=0.904> .PERIOD 0) if the maximum value of a double is around 10308 <sil=0.973> .PERIOD The functions can be grouped into the following categories:
Trigonometric functions
The acos and asin functions
The acos functions return the arccosine of their arguments in radians <sil=0.585> ,COMMA and the asin functions return the arcsine of their arguments in radians <sil=0.948> .PERIOD All functions expect the argument in the range [-1 <sil=0.619> ,COMMA +1] <sil=0.935> .PERIOD The arccosine returns a value in the range [0 <sil=0.324> ,COMMA  <sil=0.384> ?QUESTIONMARK ] <sil=0.445> ;SEMICOLON the arcsine returns a value in the range [- <sil=0.885> ?QUESTIONMARK /2 <sil=0.396> ,COMMA + <sil=0.578> ?QUESTIONMARK /2] <sil=0.961> .PERIOD #include <math <sil=0.987> .PERIOD h> float asinf(float x) <sil=0.337> ;SEMICOLON /* C99 */ float acosf(float x) <sil=0.337> ;SEMICOLON /* C99 */ double asin(double x) <sil=0.573> ;SEMICOLON double acos(double x) <sil=0.566> ;SEMICOLON long double asinl(long double x) <sil=0.311> ;SEMICOLON /* C99 */ long double acosl(long double x) <sil=0.412> ;SEMICOLON /* C99 */
The atan and atan2 functions
The atan functions return the arctangent of their arguments in radians <sil=0.490> ,COMMA and the atan2 function return the arctangent of y/x in radians <sil=0.960> .PERIOD The atan functions return a value in the range [- <sil=0.958> ?QUESTIONMARK /2 <sil=0.602> ,COMMA + <sil=0.404> ?QUESTIONMARK /2] (the reason why ± <sil=0.965> ?QUESTIONMARK /2 are included in the range is because the floating-point value may represent infinity <sil=0.620> ,COMMA and atan(± <sil=0.964> ?QUESTIONMARK ) = ± <sil=0.946> ?QUESTIONMARK /2) <sil=0.331> ;SEMICOLON the atan2 functions return a value in the range [- <sil=0.873> ?QUESTIONMARK  <sil=0.624> ,COMMA + <sil=0.524> ?QUESTIONMARK ] <sil=0.533> .PERIOD For atan2 <sil=0.489> ,COMMA a domain error may occur if both arguments are zero <sil=0.924> .PERIOD #include <math <sil=0.952> .PERIOD h> float atanf(float x) <sil=0.587> ;SEMICOLON /* C99 */ float atan2f(float y <sil=0.356> ,COMMA float x) <sil=0.509> ;SEMICOLON /* C99 */
double atan(double x) <sil=0.526> ;SEMICOLON double atan2(double y <sil=0.631> ,COMMA double x) <sil=0.309> ;SEMICOLON long double atanl(long double x) <sil=0.373> ;SEMICOLON /* C99 */ long double atan2l(long double y <sil=0.476> ,COMMA long double x) <sil=0.417> ;SEMICOLON /* C99 */

The cos <sil=0.613> ,COMMA sin <sil=0.381> ,COMMA and tan functions
The cos <sil=0.559> ,COMMA sin <sil=0.615> ,COMMA and tan functions return the cosine <sil=0.433> ,COMMA sine <sil=0.497> ,COMMA and tangent of the argument <sil=0.614> ,COMMA expressed in radians <sil=0.901> .PERIOD #include <math <sil=0.930> .PERIOD h> float cosf(float x) <sil=0.614> ;SEMICOLON /* C99 */ float sinf(float x) <sil=0.614> ;SEMICOLON /* C99 */ float tanf(float x) <sil=0.510> ;SEMICOLON /* C99 */ double cos(double x) <sil=0.591> ;SEMICOLON double sin(double x) <sil=0.630> ;SEMICOLON double tan(double x) <sil=0.329> ;SEMICOLON long double cosl(long double x) <sil=0.382> ;SEMICOLON /* C99 */ long double sinl(long double x) <sil=0.476> ;SEMICOLON /* C99 */ long double tanl(long double x) <sil=0.469> ;SEMICOLON /* C99 */
Hyperbolic functions
The cosh <sil=0.487> ,COMMA sinh and tanh functions compute the hyperbolic cosine <sil=0.474> ,COMMA the hyperbolic sine <sil=0.355> ,COMMA and the hyperbolic tangent of the argument respectively <sil=0.941> .PERIOD For the hyperbolic sine and cosine functions <sil=0.375> ,COMMA a range error occurs if the magnitude of the argument is too large <sil=0.986> .PERIOD The acosh functions compute the inverse hyperbolic cosine of the argument <sil=0.927> .PERIOD A domain error occurs for arguments less than 1 <sil=0.979> .PERIOD The asinh functions compute the inverse hyperbolic sine of the argument <sil=0.936> .PERIOD The atanh functions compute the inverse hyperbolic tangent of the argument <sil=0.927> .PERIOD A domain error occurs if the argument is not in the interval [-1 <sil=0.364> ,COMMA +1] <sil=0.920> .PERIOD A range error may occur if the argument equals -1 or +1 <sil=0.972> .PERIOD #include <math <sil=0.995> .PERIOD h> float coshf(float x) <sil=0.641> ;SEMICOLON /* C99 */ float sinhf(float x) <sil=0.617> ;SEMICOLON /* C99 */ float tanhf(float x) <sil=0.513> ;SEMICOLON /* C99 */ double cosh(double x) <sil=0.380> ;SEMICOLON double sinh(double x) <sil=0.355> ;SEMICOLON double tanh(double x) <sil=0.482> ;SEMICOLON long double coshl(long double x) <sil=0.520> ;SEMICOLON /* C99 */ long double sinhl(long double x) <sil=0.605> ;SEMICOLON /* C99 */ long double tanhl(long double x) <sil=0.584> ;SEMICOLON /* C99 */ float acoshf(float x) <sil=0.528> ;SEMICOLON /* C99 */ float asinhf(float x) <sil=0.348> ;SEMICOLON /* C99 */ float atanhf(float x) <sil=0.641> ;SEMICOLON /* C99 */ double acosh(double x) <sil=0.606> ;SEMICOLON /* C99 */
atanh(double x) <sil=0.623> ;SEMICOLON /* C99 */ long double acoshl(long double x) <sil=0.609> ;SEMICOLON /* C99 */ long double asinhl(long double x) <sil=0.565> ;SEMICOLON /* C99 */ long double atanhl(long double x) <sil=0.600> ;SEMICOLON /* C99 */
Exponential and logarithmic functions
The exp <sil=0.455> ,COMMA exp2 <sil=0.643> ,COMMA and expm1 functions
The exp functions compute the base-e exponential function of x (ex) <sil=0.938> .PERIOD A range error occurs if the magnitude of x is too large <sil=0.925> .PERIOD The exp2 functions compute the base-2 exponential function of x (2x) <sil=0.915> .PERIOD A range error occurs if the magnitude of x is too large <sil=0.917> .PERIOD The expm1 functions compute the base-e exponential function of the argument <sil=0.355> ,COMMA minus 1 <sil=0.943> .PERIOD A range error occurs if the magnitude of x is too large <sil=0.963> .PERIOD #include <math <sil=0.964> .PERIOD h> float expf(float x) <sil=0.457> ;SEMICOLON /* C99 */ double exp(double x) <sil=0.604> ;SEMICOLON long double expl(long double x) <sil=0.609> ;SEMICOLON /* C99 */ float exp2f(float x) <sil=0.422> ;SEMICOLON /* C99 */ double exp2(double x) <sil=0.358> ;SEMICOLON /* C99 */ long double exp2l(long double x) <sil=0.376> ;SEMICOLON /* C99 */ float expm1f(float x) <sil=0.621> ;SEMICOLON /* C99 */ double expm1(double x) <sil=0.457> ;SEMICOLON /* C99 */ long double expm1l(long double x) <sil=0.459> ;SEMICOLON /* C99 */
The frexp <sil=0.309> ,COMMA ldexp <sil=0.391> ,COMMA modf <sil=0.350> ,COMMA scalbn <sil=0.377> ,COMMA and scalbln functions
These functions are heavily used in software floating-point emulators <sil=0.619> ,COMMA but are otherwise rarely directly called <sil=0.904> .PERIOD Inside the computer <sil=0.621> ,COMMA each floating point number is represented by two parts:
• The significand is either in the range [1/2 <sil=0.603> ,COMMA 1) <sil=0.472> ,COMMA or it equals zero <sil=0.970> .PERIOD • The exponent is an integer <sil=0.910> .PERIOD The value of a floating point number v is v = significand×2exponent <sil=0.965> .PERIOD The frexp functions break the argument floating point number value into those two parts <sil=0.535> ,COMMA the exponent and significand <sil=0.960> .PERIOD After breaking it apart <sil=0.352> ,COMMA it stores the exponent in the int object pointed to by ex <sil=0.556> ,COMMA and returns the significand <sil=0.997> .PERIOD In other words <sil=0.405> ,COMMA the value returned is a copy of the given floating point number but with an exponent replaced by 0 <sil=0.917> .PERIOD If value is zero <sil=0.377> ,COMMA both parts of the result are zero <sil=0.981> .PERIOD The ldexp functions multiply a floating-point number by a integral power of 2 and return the result <sil=0.994> .PERIOD In other words <sil=0.348> ,COMMA it returns copy of the given floating point number with the exponent increased by ex <sil=0.915> .PERIOD A range error may occur <sil=0.948> .PERIOD The modf functions break the argument value into integer and fraction parts <sil=0.471> ,COMMA each of which has the same sign as the argument <sil=0.934> .PERIOD They store the integer part in the object pointed to by *iptr and return the fraction part <sil=0.900> .PERIOD The *iptr is a floating-point type <sil=0.451> ,COMMA rather than an ”int” type <sil=0.648> ,COMMA because it might be used to store an integer like 1 000 000 000 000 000 000 000 which is too big to fit in an int <sil=0.959> .PERIOD The scalbn and scalbln compute x × FLT_RADIXn <sil=0.912> .PERIOD FLT_RADIX is the base of the floatingpoint system <sil=0.423> ;SEMICOLON if it is 2 <sil=0.635> ,COMMA the functions are equivalent to ldexp <sil=0.962> .PERIOD #include <math <sil=0.908> .PERIOD h> float frexpf(float value <sil=0.603> ,COMMA int *ex) <sil=0.379> ;SEMICOLON /* C99 */ double frexp(double value <sil=0.367> ,COMMA int *ex) <sil=0.443> ;SEMICOLON long double frexpl(long double value <sil=0.377> ,COMMA int *ex) <sil=0.399> ;SEMICOLON /* C99 */ float ldexpf(float x <sil=0.594> ,COMMA int ex) <sil=0.607> ;SEMICOLON /* C99 */ double ldexp(double x <sil=0.553> ,COMMA int ex) <sil=0.509> ;SEMICOLON long double ldexpl(long double x <sil=0.312> ,COMMA int ex) <sil=0.643> ;SEMICOLON /* C99 */ float modff(float value <sil=0.459> ,COMMA float *iptr) <sil=0.391> ;SEMICOLON /* C99 */ double modf(double value <sil=0.406> ,COMMA double *iptr) <sil=0.373> ;SEMICOLON long double modfl(long double value <sil=0.400> ,COMMA long double *iptr) <sil=0.610> ;SEMICOLON /* C99 */

float scalbnf(float x <sil=0.511> ,COMMA int ex) <sil=0.545> ;SEMICOLON /* C99 */ double scalbn(double x <sil=0.309> ,COMMA int ex) <sil=0.404> ;SEMICOLON /* C99 */ long double scalbnl(long double x <sil=0.564> ,COMMA int ex) <sil=0.334> ;SEMICOLON /* C99 */ float scalblnf(float x <sil=0.625> ,COMMA long int ex) <sil=0.433> ;SEMICOLON /* C99 */ double scalbln(double x <sil=0.389> ,COMMA long int ex) <sil=0.399> ;SEMICOLON /* C99 */ long double scalblnl(long double x <sil=0.617> ,COMMA long int ex) <sil=0.570> ;SEMICOLON /* C99 */

Most C floating point libraries also implement the IEEE754-recommended nextafter() <sil=0.399> ,COMMA nextUp( ) <sil=0.604> ,COMMA and nextDown( ) functions <sil=0.919> .PERIOD The log <sil=0.518> ,COMMA log2 <sil=0.543> ,COMMA log1p <sil=0.459> ,COMMA and log10 functions
The log functions compute the base-e natural (not common) logarithm of the argument and return the result <sil=0.913> .PERIOD A domain error occurs if the argument is negative <sil=0.924> .PERIOD A range error may occur if the argument is zero <sil=0.994> .PERIOD The log1p functions compute the base-e natural (not common) logarithm of one plus the argument and return the result <sil=0.927> .PERIOD A domain error occurs if the argument is less than -1 <sil=0.982> .PERIOD A range error may occur if the argument is -1 <sil=0.991> .PERIOD The log10 functions compute the common (base-10) logarithm of the argument and return the result <sil=0.977> .PERIOD A domain error occurs if the argument is negative <sil=0.962> .PERIOD A range error may occur if the argument is zero <sil=0.930> .PERIOD The log2 functions compute the base-2 logarithm of the argument and return the result <sil=0.970> .PERIOD A domain error occurs if the argument is negative <sil=0.913> .PERIOD A range error may occur if the argument is zero <sil=0.916> .PERIOD #include <math <sil=0.974> .PERIOD h> float logf(float x) <sil=0.414> ;SEMICOLON /* C99 */ double log(double x) <sil=0.332> ;SEMICOLON long double logl(long double x) <sil=0.596> ;SEMICOLON /* C99 */ float log1pf(float x) <sil=0.617> ;SEMICOLON /* C99 */ double log1p(double x) <sil=0.520> ;SEMICOLON /* C99 */ long double log1pl(long double x) <sil=0.447> ;SEMICOLON /* C99 */ float log10f(float x) <sil=0.451> ;SEMICOLON /* C99 */ double log10(double x) <sil=0.580> ;SEMICOLON long double log10l(long double x) <sil=0.362> ;SEMICOLON /* C99 */ float log2f(float x) <sil=0.631> ;SEMICOLON /* C99 */ double log2(double x) <sil=0.569> ;SEMICOLON /* C99 */ long double log2l(long double x) <sil=0.503> ;SEMICOLON /* C99 */
The ilogb and logb functions
The ilogb functions extract the exponent of x as a signed int value <sil=0.953> .PERIOD If x is zero <sil=0.440> ,COMMA they return the value FP_ILOGB0 <sil=0.632> ;SEMICOLON if x is infinite <sil=0.375> ,COMMA they return the value INT_MAX <sil=0.308> ;SEMICOLON if x is not-anumber they return the value FP_ILOGBNAN <sil=0.401> ;SEMICOLON otherwise <sil=0.564> ,COMMA they are equivalent to calling the corresponding logb function and casting the returned value to type int <sil=0.921> .PERIOD A range error may occur if x is zero <sil=0.918> .PERIOD FP_ILOGB0 and FP_ILOGBNAN are macros defined in math <sil=0.998> .PERIOD h <sil=0.920> ;SEMICOLON INT_MAX is a macro defined in limits <sil=0.906> .PERIOD h <sil=0.995> .PERIOD The logb functions extract the exponent of x as a signed integer value in floating-point format <sil=0.966> .PERIOD If x is subnormal <sil=0.442> ,COMMA it is treated as if it were normalized <sil=0.391> ;SEMICOLON thus <sil=0.562> ,COMMA for positive finite x <sil=0.497> ,COMMA 1 <sil=0.485> ?QUESTIONMARK x × FLT_RADIX-logb(x) < FLT_RADIX <sil=0.957> .PERIOD FLT_RADIX is the radix for floating-point numbers <sil=0.485> ,COMMA defined in the float <sil=0.928> .PERIOD h header <sil=0.967> .PERIOD #include <math <sil=0.925> .PERIOD h> int ilogbf(float x) <sil=0.567> ;SEMICOLON /* C99 */ int ilogb(double x) <sil=0.431> ;SEMICOLON /* C99 */ int ilogbl(long double x) <sil=0.405> ;SEMICOLON /* C99 */

float logbf(float x) <sil=0.451> ;SEMICOLON /* C99 */ double logb(double x) <sil=0.467> ;SEMICOLON /* C99 */ long double logbl(long double x) <sil=0.609> ;SEMICOLON /* C99 */

Power functions
The pow functions
The pow functions compute x raised to the power y and return the result <sil=0.987> .PERIOD A domain error occurs if x is negative and y is not an integral value <sil=0.919> .PERIOD A domain error occurs if the result cannot be represented when x is zero and y is less than or equal to zero <sil=0.940> .PERIOD A range error may occur <sil=0.959> .PERIOD #include <math <sil=0.902> .PERIOD h>
float powf(float x <sil=0.639> ,COMMA float y) <sil=0.346> ;SEMICOLON /* C99 */ double pow(double x <sil=0.629> ,COMMA double y) <sil=0.313> ;SEMICOLON long double powl(long double x <sil=0.555> ,COMMA long double y) <sil=0.641> ;SEMICOLON /* C99 */

The sqrt functions
The sqrt functions compute the positive square root of x and return the result <sil=0.902> .PERIOD A domain error occurs if the argument is negative <sil=0.917> .PERIOD #include <math <sil=0.998> .PERIOD h> float sqrtf(float x) <sil=0.647> ;SEMICOLON /* C99 */ double sqrt(double x) <sil=0.501> ;SEMICOLON long double sqrtl(long double x) <sil=0.459> ;SEMICOLON /* C99 */

The cbrt functions
The cbrt functions compute the cube root of x and return the result <sil=0.999> .PERIOD #include <math <sil=0.937> .PERIOD h> float cbrtf(float x) <sil=0.399> ;SEMICOLON /* C99 */ double cbrt(double x) <sil=0.493> ;SEMICOLON /* C99 */ long double cbrtl(long double x) <sil=0.371> ;SEMICOLON /* C99 */

The hypot functions
The hypot functions compute the square root of the sums of the squares of x and y <sil=0.387> ,COMMA without overflow or underflow <sil=0.468> ,COMMA and return the result <sil=0.970> .PERIOD #include <math <sil=0.914> .PERIOD h>
float hypotf(float x <sil=0.646> ,COMMA float y) <sil=0.513> ;SEMICOLON /* C99 */ double hypot(double x <sil=0.501> ,COMMA double y) <sil=0.499> ;SEMICOLON /* C99 */ long double hypotl(long double x <sil=0.463> ,COMMA long double y) <sil=0.495> ;SEMICOLON /* C99 */

Nearest integer <sil=0.629> ,COMMA absolute value <sil=0.600> ,COMMA and remainder functions
The ceil and floor functions
The ceil functions compute the smallest integral value not less than x and return the result <sil=0.515> ;SEMICOLON the floor functions compute the largest integral value not greater than x and return the result <sil=0.957> .PERIOD #include <math <sil=0.933> .PERIOD h> float ceilf(float x) <sil=0.647> ;SEMICOLON /* C99 */ double ceil(double x) <sil=0.327> ;SEMICOLON long double ceill(long double x) <sil=0.442> ;SEMICOLON /* C99 */ float floorf(float x) <sil=0.413> ;SEMICOLON /* C99 */ double floor(double x) <sil=0.538> ;SEMICOLON long double floorl(long double x) <sil=0.522> ;SEMICOLON /* C99 */
The fabs functions
The fabs functions compute the absolute value of a floating-point number x and return the result <sil=0.974> .PERIOD #include <math <sil=0.974> .PERIOD h> float fabsf(float x) <sil=0.621> ;SEMICOLON /* C99 */ double fabs(double x) <sil=0.379> ;SEMICOLON long double fabsl(long double x) <sil=0.620> ;SEMICOLON /* C99 */

The fmod functions
The fmod functions compute the floating-point remainder of x/y and return the value x i * y <sil=0.625> ,COMMA for some integer i such that <sil=0.576> ,COMMA if y is nonzero <sil=0.603> ,COMMA the result has the same sign as x and magnitude less than the magnitude of y <sil=0.973> .PERIOD If y is zero <sil=0.346> ,COMMA whether a domain error occurs or the fmod functions return zero is implementation-defined <sil=0.906> .PERIOD #include <math <sil=0.929> .PERIOD h>
float fmodf(float x <sil=0.632> ,COMMA float y) <sil=0.497> ;SEMICOLON /* C99 */ double fmod(double x <sil=0.565> ,COMMA double y) <sil=0.338> ;SEMICOLON long double fmodl(long double x <sil=0.591> ,COMMA long double y) <sil=0.483> ;SEMICOLON /* C99 */

The nearbyint <sil=0.302> ,COMMA rint <sil=0.468> ,COMMA lrint <sil=0.327> ,COMMA and llrint functions
The nearbyint functions round their argument to an integer value in floating-point format <sil=0.559> ,COMMA using the current rounding direction and without raising the ”inexact” floating-point exception <sil=0.975> .PERIOD The rint functions are similar to the nearbyint functions except that they can raise the ”inexact” floating-point exception if the result differs in value from the argument <sil=0.911> .PERIOD The lrint and llrint functions round their arguments to the nearest integer value according to the current rounding direction <sil=0.958> .PERIOD If the result is outside the range of values of the return type <sil=0.436> ,COMMA the numeric result is undefined and a range error may occur if the magnitude of the argument is too large <sil=0.937> .PERIOD #include <math <sil=0.949> .PERIOD h> float nearbyintf(float x) <sil=0.503> ;SEMICOLON /* C99 */ double nearbyint(double x) <sil=0.470> ;SEMICOLON /* C99 */ long double nearbyintl(long double x) <sil=0.472> ;SEMICOLON /* C99 */ float rintf(float x) <sil=0.336> ;SEMICOLON /* C99 */ double rint(double x) <sil=0.366> ;SEMICOLON /* C99 */ long double rintl(long double x) <sil=0.546> ;SEMICOLON /* C99 */ long int lrintf(float x) <sil=0.542> ;SEMICOLON /* C99 */ long int lrint(double x) <sil=0.645> ;SEMICOLON /* C99 */ long int lrintl(long double x) <sil=0.430> ;SEMICOLON /* C99 */ long long int llrintf(float x) <sil=0.389> ;SEMICOLON /* C99 */ long long int llrint(double x) <sil=0.449> ;SEMICOLON /* C99 */ long long int llrintl(long double x) <sil=0.390> ;SEMICOLON /* C99 */
The round <sil=0.394> ,COMMA lround <sil=0.508> ,COMMA and llround functions
The round functions round the argument to the nearest integer value in floating-point format <sil=0.344> ,COMMA rounding halfway cases away from zero <sil=0.596> ,COMMA regardless of the current rounding direction <sil=0.985> .PERIOD The lround and llround functions round the argument to the nearest integer value <sil=0.635> ,COMMA rounding halfway cases away from zero <sil=0.527> ,COMMA regardless of the current rounding direction <sil=0.999> .PERIOD If the result is outside the range of values of the return type <sil=0.646> ,COMMA the numeric result is undefined and a range error may occur if the magnitude of the argument is too large <sil=0.929> .PERIOD #include <math <sil=0.974> .PERIOD h> float roundf(float x) <sil=0.341> ;SEMICOLON /* C99 */ double round(double x) <sil=0.495> ;SEMICOLON /* C99 */ long double roundl(long double x) <sil=0.306> ;SEMICOLON /* C99 */ long int lroundf(float x) <sil=0.314> ;SEMICOLON /* C99 */ long int lround(double x) <sil=0.551> ;SEMICOLON /* C99 */ long int lroundl(long double x) <sil=0.451> ;SEMICOLON /* C99 */ long long int llroundf(float x) <sil=0.589> ;SEMICOLON /* C99 */ long long int llround(double x) <sil=0.647> ;SEMICOLON /* C99 */ long long int llroundl(long double x) <sil=0.404> ;SEMICOLON /* C99 */
The trunc functions
The trunc functions round their argument to the integer value in floating-point format that is nearest but no larger in magnitude than the argument <sil=0.918> .PERIOD #include <math <sil=0.956> .PERIOD h> float truncf(float x) <sil=0.553> ;SEMICOLON /* C99 */ double trunc(double x) <sil=0.441> ;SEMICOLON /* C99 */ long double truncl(long double x) <sil=0.490> ;SEMICOLON /* C99 */

The remainder functions
The remainder functions compute the remainder x REM y as defined by IEC 60559 <sil=0.960> .PERIOD The definition reads <sil=0.545> ,COMMA ”When y <sil=0.979> ?QUESTIONMARK 0 <sil=0.329> ,COMMA the remainder r = x REM y is defined regardless of the rounding mode by the mathematical reduction r = x - ny <sil=0.379> ,COMMA where n is the integer nearest the exact value of x/y <sil=0.404> ;SEMICOLON whenever |n - x/y| = ½ <sil=0.319> ,COMMA then n is even <sil=0.982> .PERIOD Thus <sil=0.621> ,COMMA the remainder is always exact <sil=0.949> .PERIOD If r = 0 <sil=0.489> ,COMMA its sign shall be that of x <sil=0.953> .PERIOD ” 
This definition is applicable for all implementations <sil=0.924> .PERIOD #include <math <sil=0.994> .PERIOD h> float remainderf(float x <sil=0.630> ,COMMA float y) <sil=0.321> ;SEMICOLON /* C99 */ double remainder(double x <sil=0.341> ,COMMA double y) <sil=0.474> ;SEMICOLON /* C99 */ long double remainderl(long double x <sil=0.597> ,COMMA long double y) <sil=0.650> ;SEMICOLON /* C99 */

The remquo functions
The remquo functions return the same remainder as the remainder functions <sil=0.946> .PERIOD In the object pointed to by quo <sil=0.546> ,COMMA they store a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y <sil=0.364> ,COMMA where n is an implementation-defined integer greater than or equal to 3 <sil=0.978> .PERIOD #include <math <sil=0.958> .PERIOD h>
float remquof(float x <sil=0.601> ,COMMA float y <sil=0.462> ,COMMA int *quo) <sil=0.399> ;SEMICOLON /* C99 */ double remquo(double x <sil=0.567> ,COMMA double y <sil=0.344> ,COMMA int *quo) <sil=0.381> ;SEMICOLON /* C99 */ long double remquol(long double x <sil=0.465> ,COMMA long double y <sil=0.411> ,COMMA int *quo) <sil=0.341> ;SEMICOLON /* C99 */

Error and gamma functions
The erf functions compute the error function of the argument t2 dt <sil=0.589> ;SEMICOLON the erfc functions compute the complimentary error function of the argument (that is <sil=0.548> ,COMMA 1 erf x) <sil=0.947> .PERIOD For the erfc functions <sil=0.512> ,COMMA a range error may occur if the argument is too large <sil=0.998> .PERIOD The lgamma functions compute the natural logarithm of the absolute value of the gamma of the argument (that is <sil=0.467> ,COMMA loge| <sil=0.912> ?QUESTIONMARK (x)|) <sil=0.991> .PERIOD A range error may occur if the argument is a negative integer or zero <sil=0.948> .PERIOD The tgamma functions compute the gamma of the argument (that is <sil=0.496> ,COMMA  <sil=0.915> ?QUESTIONMARK (x)) <sil=0.965> .PERIOD A domain error occurs if the argument is a negative integer or if the result cannot be represented when the argument is zero <sil=0.920> .PERIOD A range error may occur <sil=0.970> .PERIOD #include <math <sil=0.940> .PERIOD h> float erff(float x) <sil=0.302> ;SEMICOLON /* C99 */ double erf(double x) <sil=0.528> ;SEMICOLON /* C99 */ long double erfl(long double x) <sil=0.648> ;SEMICOLON /* C99 */ float erfcf(float x) <sil=0.361> ;SEMICOLON /* C99 */ double erfc(double x) <sil=0.634> ;SEMICOLON /* C99 */ long double erfcl(long double x) <sil=0.533> ;SEMICOLON /* C99 */ float lgammaf(float x) <sil=0.459> ;SEMICOLON /* C99 */ double lgamma(double x) <sil=0.545> ;SEMICOLON /* C99 */ long double lgammal(long double x) <sil=0.353> ;SEMICOLON /* C99 */ float tgammaf(float x) <sil=0.448> ;SEMICOLON /* C99 */
double tgamma(double x) <sil=0.383> ;SEMICOLON /* C99 */ long double tgammal(long double x) <sil=0.494> ;SEMICOLON /* C99 */
Control
Very few programs follow exactly one control path and have each instruction stated explicitly <sil=0.983> .PERIOD In order to program effectively <sil=0.466> ,COMMA it is necessary to understand how one can alter the steps taken by a program due to user input or other conditions <sil=0.407> ,COMMA how some steps can be executed many times with few lines of code <sil=0.310> ,COMMA and how programs can appear to demonstrate a rudimentary grasp of logic <sil=0.937> .PERIOD C constructs known as conditionals and loops grant this power <sil=0.914> .PERIOD From this point forward <sil=0.337> ,COMMA it is necessary to understand what is usually meant by the word block <sil=0.924> .PERIOD A block is a group of code statements that are associated and intended to be executed as a unit <sil=0.917> .PERIOD In C <sil=0.435> ,COMMA the beginning of a block of code is denoted with { (left curly) <sil=0.607> ,COMMA and the end of a block is denoted with } <sil=0.956> .PERIOD It is not necessary to place a semicolon after the end of a block <sil=0.960> .PERIOD Blocks can be empty <sil=0.586> ,COMMA as in {} <sil=0.982> .PERIOD Blocks can also be nested <sil=0.534> ;SEMICOLON i <sil=0.353> .PERIOD e <sil=0.415> .PERIOD there can be blocks of code within larger blocks <sil=0.936> .PERIOD Conditionals
There is likely no meaningful program written in which a computer does not demonstrate basic decision-making skills <sil=0.985> .PERIOD It can actually be argued that there is no meaningful human activity in which some sort of decision-making <sil=0.574> ,COMMA instinctual or otherwise <sil=0.459> ,COMMA does not take place <sil=0.900> .PERIOD For example <sil=0.412> ,COMMA when driving a car and approaching a traffic light <sil=0.457> ,COMMA one does not think <sil=0.490> ,COMMA ”I will continue driving through the intersection <sil=0.902> .PERIOD ” 
Rather <sil=0.544> ,COMMA one thinks <sil=0.490> ,COMMA ”I will stop if the light is red <sil=0.486> ,COMMA go if the light is green <sil=0.616> ,COMMA and if yellow go only if I am traveling at a certain speed a certain distance from the intersection <sil=0.979> .PERIOD ”
These kinds of processes can be simulated in C using conditionals <sil=0.973> .PERIOD A conditional is a statement that instructs the computer to execute a certain block of code or alter certain data only if a specific condition has been met <sil=0.971> .PERIOD The most common conditional is the If-Else statement <sil=0.609> ,COMMA with conditional expressions and Switch-Case statements typically used as more shorthanded methods <sil=0.931> .PERIOD Before one can understand conditional statements <sil=0.480> ,COMMA it is first necessary to understand how C expresses logical relations <sil=0.935> .PERIOD C treats logic as being arithmetic <sil=0.966> .PERIOD The value 0 (zero) represents false <sil=0.412> ,COMMA and all other values represent true <sil=0.911> .PERIOD If you chose some particular value to represent true and then compare values against it <sil=0.537> ,COMMA sooner or later your code will fail when your assumed value (often 1) turns out to be incorrect <sil=0.906> .PERIOD Code written by people uncomfortable with the C language can often be identified by the usage of #define to make a ”TRUE” value <sil=0.978> .PERIOD Because logic is arithmetic in C <sil=0.472> ,COMMA arithmetic operators and logical operators are one and the same <sil=0.943> .PERIOD Nevertheless <sil=0.328> ,COMMA there are a number of operators that are typically associated with logic:
Relational and Equivalence Expressions:
a < b
 1 if a is less than b <sil=0.539> ,COMMA 0 otherwise <sil=0.979> .PERIOD a > b
 1 if a is greater than b <sil=0.639> ,COMMA 0 otherwise <sil=0.985> .PERIOD a <= b
 1 if a is less than or equal to b <sil=0.391> ,COMMA 0 otherwise <sil=0.926> .PERIOD a >= b
 1 if a is greater than or equal to b <sil=0.642> ,COMMA 0 otherwise <sil=0.927> .PERIOD a == b
 1 if a is equal to b <sil=0.349> ,COMMA 0 otherwise <sil=0.952> .PERIOD a <sil=0.475> !EXCLAMATIONMARK = b
1 if a is not equal to b <sil=0.394> ,COMMA 0 otherwise
New programmers should take special note of the fact that the ”equal to” operator is == <sil=0.600> ,COMMA not = <sil=0.927> .PERIOD This is the cause of numerous coding mistakes and is often a difficult-to-find bug <sil=0.397> ,COMMA as the expression (a = b) sets a equal to b and subsequently evaluates to b <sil=0.521> ;SEMICOLON but the expression (a == b) <sil=0.456> ,COMMA which is usually intended <sil=0.360> ,COMMA checks if a is equal to b <sil=0.901> .PERIOD It needs to be pointed out that <sil=0.465> ,COMMA if you confuse = with == <sil=0.334> ,COMMA your mistake will often not be brought to your attention by the compiler <sil=0.952> .PERIOD A statement such as if (c = 20) {}is considered perfectly valid by the language <sil=0.356> ,COMMA but will always assign 20 to c and evaluate as true <sil=0.978> .PERIOD A simple technique to avoid this kind of bug (in many <sil=0.484> ,COMMA not all cases) is to put the constant first <sil=0.900> .PERIOD This will cause the compiler to issue an error <sil=0.403> ,COMMA if == got misspelled with = <sil=0.903> .PERIOD Note that C does not have a dedicated boolean type as many other languages do <sil=0.930> .PERIOD 0 means false and anything else true <sil=0.949> .PERIOD So the following are equivalent:
if (foo()) {
  // do something }
and
if (foo() <sil=0.904> !EXCLAMATIONMARK = 0) {
  // do something }
Often #define TRUE 1 and #define FALSE 0 are used to work around the lack of a boolean type <sil=0.932> .PERIOD This is bad practice <sil=0.338> ,COMMA since it makes assumptions that do not hold <sil=0.988> .PERIOD It is a better idea to indicate what you are actually expecting as a result from a function call <sil=0.329> ,COMMA as there are many different ways of indicating error conditions <sil=0.496> ,COMMA depending on the situation <sil=0.935> .PERIOD if (strstr("foo" <sil=0.555> ,COMMA bar) >= 0) { // bar contains "foo" }
Here <sil=0.516> ,COMMA strstr returns the index where the substring foo is found and -1 if it was not found <sil=0.986> .PERIOD Note that this would fail with the TRUE definition mentioned in the previous paragraph <sil=0.982> .PERIOD It would also not produce the expected results if we omitted the >= 0 <sil=0.994> .PERIOD One other thing to note is that the relational expressions do not evaluate as they would in mathematical texts <sil=0.988> .PERIOD That is <sil=0.413> ,COMMA an expression myMin < value < myMax does not evaluate as you probably think it might <sil=0.974> .PERIOD Mathematically <sil=0.597> ,COMMA this would test whether or not value is between myMin and myMax <sil=0.997> .PERIOD But in C <sil=0.519> ,COMMA what happens is that value is first compared with myMin <sil=0.964> .PERIOD This produces either a 0 or a 1 <sil=0.990> .PERIOD It is this value that is compared against myMax <sil=0.919> .PERIOD Example:
int value = 20 <sil=0.616> ;SEMICOLON /* <sil=0.947> .PERIOD  <sil=0.324> .PERIOD  <sil=0.609> .PERIOD */ if (0 < value < 10) { // don't do this <sil=0.943> !EXCLAMATIONMARK it always evaluates to "true" <sil=0.975> !EXCLAMATIONMARK /* do some stuff */
}
Because value is greater than 0 <sil=0.405> ,COMMA the first comparison produces a value of 1 <sil=0.925> .PERIOD Now 1 is compared to be less than 10 <sil=0.358> ,COMMA which is true <sil=0.582> ,COMMA so the statements in the if are executed <sil=0.916> .PERIOD This probably is not what the programmer expected <sil=0.917> .PERIOD The appropriate code would be
int value = 20 <sil=0.633> ;SEMICOLON /* <sil=0.967> .PERIOD  <sil=0.532> .PERIOD  <sil=0.439> .PERIOD */ if (0 < value && value < 10) {	// the && means "and" /* do some stuff */
}
Logical Expressions
a || b when EITHER a or b is true (or both) <sil=0.400> ,COMMA the result is 1 <sil=0.437> ,COMMA otherwise the result is 0 <sil=0.903> .PERIOD a && b when BOTH a and b are true <sil=0.335> ,COMMA the result is 1 <sil=0.328> ,COMMA otherwise the result is 0 <sil=0.998> .PERIOD  <sil=0.922> !EXCLAMATIONMARK a when a is true <sil=0.582> ,COMMA the result is 0 <sil=0.502> ,COMMA when a is 0 <sil=0.582> ,COMMA the result is 1 <sil=0.393> .PERIOD Here's an example of a larger logical expression <sil=0.919> .PERIOD In the statement:
e = ((a && b) || (c > d)) <sil=0.428> ;SEMICOLON e is set equal to 1 if a and b are non-zero <sil=0.486> ,COMMA or if c is greater than d <sil=0.923> .PERIOD In all other cases <sil=0.337> ,COMMA e is set to 0 <sil=0.942> .PERIOD C uses short circuit evaluation of logical expressions <sil=0.952> .PERIOD That is to say <sil=0.396> ,COMMA once it is able to determine the truth of a logical expression <sil=0.350> ,COMMA it does no further evaluation <sil=0.932> .PERIOD This is often useful as in the following:
int myArray[12] <sil=0.385> ;SEMICOLON  <sil=0.934> .PERIOD  <sil=0.587> .PERIOD  <sil=0.332> .PERIOD  <sil=0.393> .PERIOD if (i < 12 && myArray[i] > 3) { <sil=0.954> .PERIOD  <sil=0.650> .PERIOD  <sil=0.545> .PERIOD  <sil=0.622> .PERIOD In the snippet of code <sil=0.350> ,COMMA the comparison of i with 12 is done first <sil=0.925> .PERIOD If it evaluates to 0 (false) <sil=0.503> ,COMMA i would be out of bounds as an index to myArray <sil=0.919> .PERIOD In this case <sil=0.330> ,COMMA the program never attempts to access myArray[i] since the truth of the expression is known to be false <sil=0.914> .PERIOD Hence we need not worry here about trying to access an out-of-bounds array element if it is already known that i is greater than or equal to zero <sil=0.911> .PERIOD A similar thing happens with expressions involving the or || operator <sil=0.945> .PERIOD while (doThis() || doThat()) <sil=0.940> .PERIOD  <sil=0.384> .PERIOD  <sil=0.409> .PERIOD doThat() is never called if doThis() returns a non-zero (true) value <sil=0.982> .PERIOD Bitwise Boolean Expressions
The bitwise operators work bit by bit on the operands <sil=0.916> .PERIOD The operands must be of integral type (one of the types used for integers) <sil=0.997> .PERIOD The six bitwise operators are & (AND) <sil=0.418> ,COMMA | (OR) <sil=0.311> ,COMMA ^ (exclusive OR <sil=0.357> ,COMMA commonly called XOR) <sil=0.395> ,COMMA ~ (NOT <sil=0.373> ,COMMA which changes 1 to 0 and 0 to 1) <sil=0.635> ,COMMA << (shift left) <sil=0.351> ,COMMA and >> (shift right) <sil=0.950> .PERIOD The negation operator is a unary operator which precedes the operand <sil=0.987> .PERIOD The others are binary operators which lie between the two operands <sil=0.973> .PERIOD The precedence of these operators is lower than that of the relational and equivalence operators <sil=0.481> ;SEMICOLON it is often required to parenthesize expressions involving bitwise operators <sil=0.979> .PERIOD For this section <sil=0.446> ,COMMA recall that a number starting with 0x is hexadecimal <sil=0.310> ,COMMA or hex for short <sil=0.959> .PERIOD Unlike the normal decimal system using powers of 10 and digits 0123456789 <sil=0.355> ,COMMA hex uses powers of 16 and digits 0123456789abcdef <sil=0.970> .PERIOD Hexadecimal is commonly used in C programs because a programmer can quickly convert it to or from binary (powers of 2 and digits 01) <sil=0.923> .PERIOD C does not directly support binary notation <sil=0.309> ,COMMA which would be really verbose anyway <sil=0.915> .PERIOD a & b
bitwise boolean and of a and b
  0xc & 0xa produces the value 0x8 (in binary <sil=0.404> ,COMMA 1100 & 1010 produces 1000) a | b
bitwise boolean or of a and b
0xc | 0xa produces the value 0xe (in binary <sil=0.529> ,COMMA 1100 | 1010 produces 1110)
a ^ b
bitwise xor of a and b
0xc ^ 0xa produces the value 0x6 (in binary <sil=0.568> ,COMMA 1100 ^ 1010 produces 0110)
~a
bitwise complement of a <sil=0.976> .PERIOD ~0xc produces the value -1-0xc (in binary <sil=0.339> ,COMMA ~1100 produces <sil=0.976> .PERIOD  <sil=0.365> .PERIOD  <sil=0.364> .PERIOD 11110011 where ” <sil=0.966> .PERIOD  <sil=0.506> .PERIOD  <sil=0.433> .PERIOD ” may be many more 1 bits) a << b
shift a left by b (multiply a by 2b)
 0xc << 1 produces the value 0x18 (in binary <sil=0.383> ,COMMA 1100 << 1 produces the value 11000) a >> b
shift a right by b (divide a by 2b)
0xc >> 1 produces the value 0x6 (in binary <sil=0.324> ,COMMA 1100 >> 1 produces the value 110)
The If-Else statement
If-Else provides a way to instruct the computer to execute a block of code only if certain conditions have been met <sil=0.990> .PERIOD The syntax of an If-Else construct is:
if (/* condition goes here */) {
/* if the condition is non-zero (true) <sil=0.468> ,COMMA this code will execute */
} else {
  /* if the condition is 0 (false) <sil=0.334> ,COMMA this code will execute */ }
The first block of code executes if the condition in parentheses directly after the if evaluates to non-zero (true) <sil=0.388> ;SEMICOLON otherwise <sil=0.442> ,COMMA the second block executes <sil=0.932> .PERIOD The else and following block of code are completely optional <sil=0.930> .PERIOD If there is no need to execute code if a condition is not true <sil=0.370> ,COMMA leave it out <sil=0.956> .PERIOD Also <sil=0.467> ,COMMA keep in mind that an if can directly follow an else statement <sil=0.932> .PERIOD While this can occasionally be useful <sil=0.431> ,COMMA chaining more than two or three if-elses in this fashion is considered bad programming practice <sil=0.903> .PERIOD We can get around this with the Switch-Case construct described later <sil=0.972> .PERIOD Two other general syntax notes need to be made that you will also see in other control constructs: First <sil=0.585> ,COMMA note that there is no semicolon after if or else <sil=0.935> .PERIOD There could be <sil=0.515> ,COMMA but the block (code enclosed in { and }) takes the place of that <sil=0.972> .PERIOD Second <sil=0.421> ,COMMA if you only intend to execute one statement as a result of an if or else <sil=0.619> ,COMMA curly braces are not needed <sil=0.969> .PERIOD However <sil=0.399> ,COMMA many programmers believe that inserting curly braces anyway in this case is good coding practice <sil=0.997> .PERIOD The following code sets a variable c equal to the greater of two variables a and b <sil=0.442> ,COMMA or 0 if a and b are equal <sil=0.950> .PERIOD if (a > b) {
c = a <sil=0.588> ;SEMICOLON } else if (b > a) { c = b <sil=0.616> ;SEMICOLON } else { c = 0 <sil=0.620> ;SEMICOLON }
Consider this question: why can't you just forget about else and write the code like:
if (a > b) {
c = a <sil=0.493> ;SEMICOLON }
if (a < b) {
c = b <sil=0.523> ;SEMICOLON }
if (a == b) {
c = 0 <sil=0.541> ;SEMICOLON }
There are several answers to this <sil=0.998> .PERIOD Most importantly <sil=0.499> ,COMMA if your conditionals are not mutually exclusive <sil=0.552> ,COMMA two cases could execute instead of only one <sil=0.976> .PERIOD If the code was different and the value of a or b changes somehow (e <sil=0.979> .PERIOD g <sil=0.936> .PERIOD : you reset the lesser of a and b to 0 after the comparison) during one of the blocks <sil=0.935> ?QUESTIONMARK You could end up with multiple if statements being invoked <sil=0.349> ,COMMA which is not your intent <sil=0.949> .PERIOD Also <sil=0.372> ,COMMA evaluating if conditionals takes processor time <sil=0.970> .PERIOD If you use else to handle these situations <sil=0.306> ,COMMA in the case above assuming (a > b) is non-zero (true) <sil=0.416> ,COMMA the program is spared the expense of evaluating additional if statements <sil=0.901> .PERIOD The bottom line is that it is usually best to insert an else clause for all cases in which a conditional will not evaluate to non-zero (true) <sil=0.968> .PERIOD The conditional expression
A conditional expression is a way to set values conditionally in a more shorthand fashion than If-Else <sil=0.974> .PERIOD The syntax is:
(/* logical expression goes here */) <sil=0.906> ?QUESTIONMARK (/* if non-zero (true) */) : (/* if 0 (false) */)
The logical expression is evaluated <sil=0.934> .PERIOD If it is non-zero (true) <sil=0.539> ,COMMA the overall conditional expression evaluates to the expression placed between the <sil=0.980> ?QUESTIONMARK and : <sil=0.626> ,COMMA otherwise <sil=0.644> ,COMMA it evaluates to the expression after the : <sil=0.974> .PERIOD Therefore <sil=0.501> ,COMMA the above example (changing its function slightly such that c is set to b when a and b are equal) becomes:
c = (a > b) <sil=0.900> ?QUESTIONMARK a : b <sil=0.522> ;SEMICOLON Conditional expressions can sometimes clarify the intent of the code <sil=0.966> .PERIOD Nesting the conditional operator should usually be avoided <sil=0.966> .PERIOD It's best to use conditional expressions only when the expressions for a and b are simple <sil=0.999> .PERIOD Also <sil=0.562> ,COMMA contrary to a common beginner belief <sil=0.393> ,COMMA conditional expressions do not make for faster code <sil=0.995> .PERIOD As tempting as it is to assume that fewer lines of code result in faster execution times <sil=0.469> ,COMMA there is no such correlation <sil=0.912> .PERIOD The Switch-Case statement
Say you write a program where the user inputs a number 1-5 (corresponding to student grades <sil=0.466> ,COMMA A(represented as 1)-D(4) and F(5)) <sil=0.352> ,COMMA stores it in a variable grade and the program responds by printing to the screen the associated letter grade <sil=0.920> .PERIOD If you implemented this using If-Else <sil=0.605> ,COMMA your code would look something like this:
if (grade == 1) { printf("A\n") <sil=0.355> ;SEMICOLON } else if (grade == 2) { printf("B\n") <sil=0.322> ;SEMICOLON } else if /* etc <sil=0.956> .PERIOD etc <sil=0.987> .PERIOD */
Having a long chain of if-else-if-else-if-else can be a pain <sil=0.391> ,COMMA both for the programmer and anyone reading the code <sil=0.917> .PERIOD Fortunately <sil=0.497> ,COMMA there's a solution: the Switch-Case construct <sil=0.317> ,COMMA of which the basic syntax is:
switch (/* integer or enum goes here */) { case /* potential value of the aforementioned int or enum */:
  /* code */ case /* a different potential value */: /* different code */
/* insert additional cases as needed */ default:
/* more code */
}
The Switch-Case construct takes a variable <sil=0.330> ,COMMA usually an int or an enum <sil=0.472> ,COMMA placed after switch <sil=0.370> ,COMMA and compares it to the value following the case keyword <sil=0.938> .PERIOD If the variable is equal to the value specified after case <sil=0.446> ,COMMA the construct ”activates” <sil=0.381> ,COMMA or begins executing the code after the case statement <sil=0.937> .PERIOD Once the construct has ”activated” <sil=0.495> ,COMMA there will be no further evaluation of cases <sil=0.963> .PERIOD Switch-Case is syntactically ”weird” in that no braces are required for code associated with a case <sil=0.921> .PERIOD Very important: Typically <sil=0.358> ,COMMA the last statement for each case is a break statement <sil=0.958> .PERIOD This causes program execution to jump to the statement following the closing bracket of the switch statement <sil=0.385> ,COMMA which is what one would normally want to happen <sil=0.916> .PERIOD However if the break statement is omitted <sil=0.649> ,COMMA program execution continues with the first line of the next case <sil=0.466> ,COMMA if any <sil=0.982> .PERIOD This is called a fall-through <sil=0.965> .PERIOD When a programmer desires this action <sil=0.458> ,COMMA a comment should be placed at the end of the block of statements indicating the desire to fall through <sil=0.912> .PERIOD Otherwise another programmer maintaining the code could consider the omission of the 'break' to be an error <sil=0.342> ,COMMA and inadvertently 'correct' the problem <sil=0.988> .PERIOD Here's an example:
switch (someVariable) { case 1: printf("This code handles case 1\n") <sil=0.558> ;SEMICOLON break <sil=0.463> ;SEMICOLON case 2:
printf("This prints when someVariable is 2 <sil=0.628> ,COMMA along with <sil=0.918> .PERIOD  <sil=0.332> .PERIOD  <sil=0.594> .PERIOD \n") <sil=0.491> ;SEMICOLON /* FALL THROUGH */ case 3: printf("This prints when someVariable is either 2 or 3 <sil=0.985> .PERIOD \n" ) <sil=0.433> ;SEMICOLON break <sil=0.418> ;SEMICOLON }
If a default case is specified <sil=0.514> ,COMMA the associated statements are executed if none of the other cases match <sil=0.991> .PERIOD A default case is optional <sil=0.904> .PERIOD Here's a switch statement that corresponds to the sequence of if - else if statements above <sil=0.979> .PERIOD Back to our example above <sil=0.940> .PERIOD Here's what it would look like as Switch-Case:
switch (grade) { case 1:
  printf("A\n") <sil=0.393> ;SEMICOLON break <sil=0.586> ;SEMICOLON case 2: printf("B\n") <sil=0.536> ;SEMICOLON break <sil=0.362> ;SEMICOLON case 3:
printf("C\n") <sil=0.507> ;SEMICOLON break <sil=0.626> ;SEMICOLON case 4:
  printf("D\n") <sil=0.484> ;SEMICOLON break <sil=0.616> ;SEMICOLON default: printf("F\n") <sil=0.356> ;SEMICOLON break <sil=0.491> ;SEMICOLON }
A set of statements to execute can be grouped with more than one value of the variable as in the following example <sil=0.957> .PERIOD (the fall-through comment is not necessary here because the intended behavior is obvious)
switch (something) { case 2: case 3:
case 4:
/* some statements to execute for 2 <sil=0.613> ,COMMA 3 or 4 */ break <sil=0.340> ;SEMICOLON case 1:
default:
  /* some statements to execute for 1 or other than 2 <sil=0.312> ,COMMA 3 <sil=0.348> ,COMMA and 4 */ break <sil=0.373> ;SEMICOLON }
Switch-Case constructs are particularly useful when used in conjunction with user defined enum data types <sil=0.984> .PERIOD Some compilers are capable of warning about an unhandled enum value <sil=0.398> ,COMMA which may be helpful for avoiding bugs <sil=0.928> .PERIOD Loops
Often in computer programming <sil=0.436> ,COMMA it is necessary to perform a certain action a certain number of times or until a certain condition is met <sil=0.929> .PERIOD It is impractical and tedious to simply type a certain statement or group of statements a large number of times <sil=0.448> ,COMMA not to mention that this approach is too inflexible and unintuitive to be counted on to stop when a certain event has happened <sil=0.999> .PERIOD As a real-world analogy <sil=0.649> ,COMMA someone asks a dishwasher at a restaurant what he did all night <sil=0.967> .PERIOD He will respond <sil=0.444> ,COMMA ”I washed dishes all night long <sil=0.985> .PERIOD ” 
He is not likely to respond <sil=0.597> ,COMMA ”I washed a dish <sil=0.377> ,COMMA then washed a dish <sil=0.336> ,COMMA then washed a dish <sil=0.345> ,COMMA then <sil=0.943> .PERIOD  <sil=0.419> .PERIOD  <sil=0.506> .PERIOD ” <sil=0.969> .PERIOD The constructs that enable computers to perform certain repetitive tasks are called loops <sil=0.966> .PERIOD While loops
A while loop is the most basic type of loop <sil=0.916> .PERIOD It will run as long as the condition is non-zero (true) <sil=0.924> .PERIOD For example <sil=0.541> ,COMMA if you try the following <sil=0.588> ,COMMA the program will appear to lock up and you will have to manually close the program down <sil=0.928> .PERIOD A situation where the conditions for exiting the loop will never become true is called an infinite loop <sil=0.937> .PERIOD int a = 1 <sil=0.468> ;SEMICOLON while (42) { a = a * 2 <sil=0.461> ;SEMICOLON }
Here is another example of a while loop <sil=0.982> .PERIOD It prints out all the powers of two less than 100 <sil=0.921> .PERIOD int a = 1 <sil=0.480> ;SEMICOLON while (a < 100) {
printf("a is %d \n" <sil=0.314> ,COMMA a) <sil=0.477> ;SEMICOLON a = a * 2 <sil=0.493> ;SEMICOLON }
The flow of all loops can also be controlled by break and continue statements <sil=0.956> .PERIOD A break statement will immediately exit the enclosing loop <sil=0.978> .PERIOD A continue statement will skip the remainder of the block and start at the controlling conditional statement again <sil=0.950> .PERIOD For example:
int a = 1 <sil=0.613> ;SEMICOLON while (42) { // loops until the break statement in the loop is executed
printf("a is %d " <sil=0.304> ,COMMA a) <sil=0.606> ;SEMICOLON a = a * 2 <sil=0.460> ;SEMICOLON if (a > 100) { break <sil=0.474> ;SEMICOLON } else if (a == 64) { continue <sil=0.630> ;SEMICOLON // Immediately restarts at while <sil=0.607> ,COMMA skips next step
}
  printf("a is not 64\n") <sil=0.573> ;SEMICOLON }
In this example <sil=0.600> ,COMMA the computer prints the value of a as usual <sil=0.436> ,COMMA and prints a notice that a is not 64 (unless it was skipped by the continue statement) <sil=0.961> .PERIOD Similar to If above <sil=0.403> ,COMMA braces for the block of code associated with a While loop can be omitted if the code consists of only one statement <sil=0.473> ,COMMA for example:
int a = 1 <sil=0.498> ;SEMICOLON while (a < 100) a = a * 2 <sil=0.345> ;SEMICOLON This will merely increase a until a is not less than 100 <sil=0.946> .PERIOD When the computer reaches the end of the while loop <sil=0.589> ,COMMA it always goes back to the while statement at the top of the loop <sil=0.620> ,COMMA where it re-evaluates the controlling condition <sil=0.999> .PERIOD If that condition is ”true” at that instant -- even if it was temporarily 0 for a few statements inside the loop -- then the computer begins executing the statements inside the loop again <sil=0.334> ;SEMICOLON otherwise the computer exits the loop <sil=0.917> .PERIOD The computer does not ”continuously check” the controlling condition of a while loop during the execution of that loop <sil=0.936> .PERIOD It only ”peeks” at the controlling condition each time it reaches the while at the top of the loop <sil=0.982> .PERIOD It is very important to note <sil=0.606> ,COMMA once the controlling condition of a While loop becomes 0 (false) <sil=0.349> ,COMMA the loop will not terminate until the block of code is finished and it is time to reevaluate the conditional <sil=0.944> .PERIOD If you need to terminate a While loop immediately upon reaching a certain condition <sil=0.521> ,COMMA consider using break <sil=0.964> .PERIOD A common idiom is to write:
int i = 5 <sil=0.390> ;SEMICOLON while (i--) {
printf("java and c# can't do this\n") <sil=0.394> ;SEMICOLON }
This executes the code in the while loop 5 times <sil=0.346> ,COMMA with i having values that range from 4 down to 0 (inside the loop) <sil=0.977> .PERIOD Conveniently <sil=0.413> ,COMMA these are the values needed to access every item of an array containing 5 elements <sil=0.934> .PERIOD For loops
For loops generally look something like this:
for (initialization <sil=0.590> ;SEMICOLON test <sil=0.519> ;SEMICOLON increment) {
/* code */ }
The initialization statement is executed exactly once - before the first evaluation of the test condition <sil=0.996> .PERIOD Typically <sil=0.650> ,COMMA it is used to assign an initial value to some variable <sil=0.402> ,COMMA although this is not strictly necessary <sil=0.921> .PERIOD The initialization statement can also be used to declare and initialize variables used in the loop <sil=0.958> .PERIOD The test expression is evaluated each time before the code in the for loop executes <sil=0.986> .PERIOD If this expression evaluates as 0 (false) when it is checked (i <sil=0.923> .PERIOD e <sil=0.336> .PERIOD if the expression is not true) <sil=0.618> ,COMMA the loop is not (re)entered and execution continues normally at the code immediately following the FOR-loop <sil=0.949> .PERIOD If the expression is non-zero (true) <sil=0.508> ,COMMA the code within the braces of the loop is executed <sil=0.934> .PERIOD After each iteration of the loop <sil=0.629> ,COMMA the increment statement is executed <sil=0.912> .PERIOD This often is used to increment the loop index for the loop <sil=0.489> ,COMMA the variable initialized in the initialization expression and tested in the test expression <sil=0.966> .PERIOD Following this statement execution <sil=0.333> ,COMMA control returns to the top of the loop <sil=0.484> ,COMMA where the test action occurs <sil=0.968> .PERIOD If a continue statement is executed within the for loop <sil=0.509> ,COMMA the increment statement would be the next one executed <sil=0.948> .PERIOD Each of these parts of the for statement is optional and may be omitted <sil=0.964> .PERIOD Because of the free-form nature of the for statement <sil=0.415> ,COMMA some fairly fancy things can be done with it <sil=0.996> .PERIOD Often a for loop is used to loop through items in an array <sil=0.616> ,COMMA processing each item at a time <sil=0.995> .PERIOD int myArray[12] <sil=0.568> ;SEMICOLON int ix <sil=0.436> ;SEMICOLON for (ix = 0 <sil=0.468> ;SEMICOLON ix < 12 <sil=0.327> ;SEMICOLON ix++) {
myArray[ix] = 5 * ix + 3 <sil=0.391> ;SEMICOLON }
The above for loop initializes each of the 12 elements of myArray <sil=0.929> .PERIOD The loop index can start from any value <sil=0.959> .PERIOD In the following case it starts from 1 <sil=0.968> .PERIOD for (ix = 1 <sil=0.402> ;SEMICOLON ix <= 10 <sil=0.354> ;SEMICOLON ix++) { printf("%d " <sil=0.326> ,COMMA ix) <sil=0.346> ;SEMICOLON }
which will print
1 2 3 4 5 6 7 8 9 10
You will most often use loop indexes that start from 0 <sil=0.323> ,COMMA since arrays are indexed at zero <sil=0.634> ,COMMA but you will sometimes use other values to initialize a loop index as well <sil=0.956> .PERIOD The increment action can do other things <sil=0.321> ,COMMA such as decrement <sil=0.903> .PERIOD So this kind of loop is common:
for (i = 5 <sil=0.472> ;SEMICOLON i > 0 <sil=0.319> ;SEMICOLON i--) { printf("%d " <sil=0.564> ,COMMA i) <sil=0.348> ;SEMICOLON }
which yields
5 4 3 2 1
Here's an example where the test condition is simply a variable <sil=0.913> .PERIOD If the variable has a value of 0 or NULL <sil=0.351> ,COMMA the loop exits <sil=0.589> ,COMMA otherwise the statements in the body of the loop are executed <sil=0.925> .PERIOD for (t = list_head <sil=0.367> ;SEMICOLON t <sil=0.554> ;SEMICOLON t = NextItem(t)) { /* body of loop */
}
A WHILE loop can be used to do the same thing as a FOR loop <sil=0.315> ,COMMA however a FOR loop is a more condensed way to perform a set number of repetitions since all of the necessary information is in a one line statement <sil=0.909> .PERIOD A FOR loop can also be given no conditions <sil=0.417> ,COMMA for example:
for ( <sil=0.483> ;SEMICOLON  <sil=0.336> ;SEMICOLON ) {
  /* block of statements */ }
This is called an infinite loop since it will loop forever unless there is a break statement within the statements of the for loop <sil=0.981> .PERIOD The empty test condition effectively evaluates as true <sil=0.916> .PERIOD It is also common to use the comma operator in for loops to execute multiple statements <sil=0.940> .PERIOD int i <sil=0.324> ,COMMA j <sil=0.492> ,COMMA n = 10 <sil=0.428> ;SEMICOLON for (i = 0 <sil=0.447> ,COMMA j = 0 <sil=0.526> ;SEMICOLON i <= n <sil=0.494> ;SEMICOLON i++ <sil=0.322> ,COMMA j += 2) {
printf("i = %d <sil=0.453> ,COMMA j = %d \n" <sil=0.441> ,COMMA i <sil=0.372> ,COMMA j) <sil=0.454> ;SEMICOLON }
Special care should be taken when designing or refactoring the conditional part <sil=0.491> ,COMMA especially whether using < or <= <sil=0.427> ,COMMA whether start and stop should be corrected by 1 <sil=0.564> ,COMMA and in case of prefix- and postfix-notations <sil=0.979> .PERIOD (On a 100 yards promenade with a tree every 10 yards there are 11 trees <sil=0.989> .PERIOD )
int i <sil=0.423> ,COMMA n = 10 <sil=0.588> ;SEMICOLON for (i = 0 <sil=0.363> ;SEMICOLON i < n <sil=0.634> ;SEMICOLON i++)
  printf("%d " <sil=0.595> ,COMMA i) <sil=0.570> ;SEMICOLON // processed n times => 0 1 2 3 <sil=0.997> .PERIOD  <sil=0.409> .PERIOD  <sil=0.582> .PERIOD (n-1) printf("\n") <sil=0.367> ;SEMICOLON for (i = 0 <sil=0.542> ;SEMICOLON i <= n <sil=0.618> ;SEMICOLON i++)
  printf("%d " <sil=0.349> ,COMMA i) <sil=0.310> ;SEMICOLON // processed (n+1) times => 0 1 2 3 <sil=0.991> .PERIOD  <sil=0.400> .PERIOD  <sil=0.434> .PERIOD n printf("\n") <sil=0.452> ;SEMICOLON for (i = n <sil=0.536> ;SEMICOLON i-- <sil=0.443> ;SEMICOLON )
  printf("%d " <sil=0.628> ,COMMA i) <sil=0.366> ;SEMICOLON // processed n times => (n-1) <sil=0.999> .PERIOD  <sil=0.422> .PERIOD  <sil=0.478> .PERIOD 3 2 1 0 printf("\n") <sil=0.467> ;SEMICOLON for (i = n <sil=0.391> ;SEMICOLON --i <sil=0.382> ;SEMICOLON )
  printf("%d " <sil=0.300> ,COMMA i) <sil=0.447> ;SEMICOLON // processed (n-1) times => (n-1) <sil=0.918> .PERIOD  <sil=0.344> .PERIOD  <sil=0.529> .PERIOD 4 3 2 1 printf("\n") <sil=0.622> ;SEMICOLON Do-While loops
A DO-WHILE loop is a post-check while loop <sil=0.344> ,COMMA which means that it checks the condition after each run <sil=0.912> .PERIOD As a result <sil=0.454> ,COMMA even if the condition is zero (false) <sil=0.354> ,COMMA it will run at least once <sil=0.962> .PERIOD It follows the form of:
do {
/* do stuff */
} while (condition) <sil=0.588> ;SEMICOLON Note the terminating semicolon <sil=0.944> .PERIOD This is required for correct syntax <sil=0.981> .PERIOD Since this is also a type of while loop <sil=0.376> ,COMMA break and continue statements within the loop function accordingly <sil=0.998> .PERIOD A continue statement causes a jump to the test of the condition and a break statement exits the loop <sil=0.986> .PERIOD It is worth noting that Do-While and While are functionally almost identical <sil=0.503> ,COMMA with one important difference: Do-While loops are always guaranteed to execute at least once <sil=0.442> ,COMMA but While loops will not execute at all if their condition is 0 (false) on the first evaluation <sil=0.901> .PERIOD One last thing: goto
goto is a very simple and traditional control mechanism <sil=0.999> .PERIOD It is a statement used to immediately and unconditionally jump to another line of code <sil=0.919> .PERIOD To use goto <sil=0.622> ,COMMA you must place a label at a point in your program <sil=0.959> .PERIOD A label consists of a name followed by a colon (:) on a line by itself <sil=0.932> .PERIOD Then <sil=0.641> ,COMMA you can type ”goto label <sil=0.383> ;SEMICOLON ” at the desired point in your program <sil=0.914> .PERIOD The code will then continue executing beginning with label <sil=0.969> .PERIOD This looks like:
MyLabel:
/* some code */ goto MyLabel <sil=0.379> ;SEMICOLON The ability to transfer the flow of control enabled by gotos is so powerful that <sil=0.371> ,COMMA in addition to the simple if <sil=0.595> ,COMMA all other control constructs can be written using gotos instead <sil=0.953> .PERIOD Here <sil=0.506> ,COMMA we can let ”S” and ”T” be any arbitrary statements:
if (''cond'') { S <sil=0.397> ;SEMICOLON } else {
T <sil=0.573> ;SEMICOLON }
/* <sil=0.925> .PERIOD  <sil=0.353> .PERIOD  <sil=0.650> .PERIOD */
The same statement could be accomplished using two gotos and two labels:
if (''cond'') goto Label1 <sil=0.562> ;SEMICOLON T <sil=0.472> ;SEMICOLON goto Label2 <sil=0.505> ;SEMICOLON Label1:
  S <sil=0.418> ;SEMICOLON Label2:
/* <sil=0.970> .PERIOD  <sil=0.310> .PERIOD  <sil=0.617> .PERIOD */
Here <sil=0.478> ,COMMA the first goto is conditional on the value of ”cond” <sil=0.948> .PERIOD The second goto is unconditional <sil=0.938> .PERIOD We can perform the same translation on a loop:
while (''cond1'') { S <sil=0.355> ;SEMICOLON if (''cond2'')
break <sil=0.643> ;SEMICOLON T <sil=0.411> ;SEMICOLON }
/* <sil=0.996> .PERIOD  <sil=0.500> .PERIOD  <sil=0.485> .PERIOD */
Which can be written as:
Start: if ( <sil=0.992> !EXCLAMATIONMARK ''cond1'') goto End <sil=0.551> ;SEMICOLON S <sil=0.350> ;SEMICOLON if (''cond2'') goto End <sil=0.304> ;SEMICOLON T <sil=0.624> ;SEMICOLON goto Start <sil=0.437> ;SEMICOLON End:
/* <sil=0.928> .PERIOD  <sil=0.586> .PERIOD  <sil=0.588> .PERIOD */
As these cases demonstrate <sil=0.339> ,COMMA often the structure of what your program is doing can usually be expressed without using gotos <sil=0.916> .PERIOD Undisciplined use of gotos can create unreadable <sil=0.499> ,COMMA unmaintainable code when more idiomatic alternatives (such as if-elses <sil=0.540> ,COMMA or for loops) can better express your structure <sil=0.965> .PERIOD Theoretically <sil=0.599> ,COMMA the goto construct does not ever have to be used <sil=0.347> ,COMMA but there are cases when it can increase readability <sil=0.369> ,COMMA avoid code duplication <sil=0.545> ,COMMA or make control variables unnecessary <sil=0.903> .PERIOD You should consider first mastering the idiomatic solutions <sil=0.569> ,COMMA and use goto only when necessary <sil=0.947> .PERIOD Keep in mind that many <sil=0.456> ,COMMA if not most <sil=0.540> ,COMMA C style guidelines strictly forbid use of goto <sil=0.407> ,COMMA with the only common exceptions being the following examples <sil=0.989> .PERIOD One use of goto is to break out of a deeply nested loop <sil=0.971> .PERIOD Since break will not work (it can only escape one loop) <sil=0.545> ,COMMA goto can be used to jump completely outside the loop <sil=0.959> .PERIOD Breaking outside of deeply nested loops without the use of the goto is always possible <sil=0.610> ,COMMA but often involves the creation and testing of extra variables that may make the resulting code far less readable than it would be with goto <sil=0.908> .PERIOD The use of goto makes it easy to undo actions in an orderly fashion <sil=0.362> ,COMMA typically to avoid failing to free memory that had been allocated <sil=0.967> .PERIOD Another accepted use is the creation of a state machine <sil=0.910> .PERIOD This is a fairly advanced topic though <sil=0.351> ,COMMA and not commonly needed <sil=1.000> .PERIOD Examples
#include <errno <sil=0.963> .PERIOD h>
#include <stdio <sil=0.912> .PERIOD h> 
#include <stdlib <sil=0.972> .PERIOD h>
int main(void)
{ int years <sil=0.401> ;SEMICOLON printf("Enter your age in years : ") <sil=0.509> ;SEMICOLON fflush(stdout) <sil=0.340> ;SEMICOLON errno = 0 <sil=0.421> ;SEMICOLON if (scanf("%d" <sil=0.319> ,COMMA &years) <sil=0.977> !EXCLAMATIONMARK = 1 || errno) return EXIT_FAILURE <sil=0.622> ;SEMICOLON printf("Your age in days is %d\n" <sil=0.494> ,COMMA years * 365) <sil=0.455> ;SEMICOLON return 0 <sil=0.495> ;SEMICOLON }

Procedures and functions
In C programming <sil=0.368> ,COMMA all executable code resides within a function <sil=0.917> .PERIOD A function is a named block of code that performs a task and then returns control to a caller <sil=0.964> .PERIOD Note that other programming languages may distinguish between a ”function” <sil=0.499> ,COMMA ”subroutine” <sil=0.365> ,COMMA ”subprogram” <sil=0.601> ,COMMA ”procedure” <sil=0.417> ,COMMA or ”method” -- in C <sil=0.491> ,COMMA these are all functions <sil=0.965> .PERIOD A function is often executed (called) several times <sil=0.593> ,COMMA from several different places <sil=0.314> ,COMMA during a single execution of the program <sil=0.934> .PERIOD After finishing a subroutine <sil=0.458> ,COMMA the program will branch back (return) to the point after the call <sil=0.942> .PERIOD Functions are a powerful programming tool <sil=0.983> .PERIOD As a basic example <sil=0.418> ,COMMA suppose you are writing code to print out the first 5 squares of numbers <sil=0.420> ,COMMA do some intermediate processing <sil=0.541> ,COMMA then print the first 5 squares again <sil=0.914> .PERIOD We could write it like this:
#include <stdio <sil=0.993> .PERIOD h>
int main(void)
{ int i <sil=0.453> ;SEMICOLON for(i=1 <sil=0.485> ;SEMICOLON i <= 5 <sil=0.441> ;SEMICOLON i++)
{ printf("%d " <sil=0.582> ,COMMA i*i) <sil=0.515> ;SEMICOLON }
for(i=1 <sil=0.644> ;SEMICOLON i <= 5 <sil=0.641> ;SEMICOLON i++)
{ printf("%d " <sil=0.324> ,COMMA i*i) <sil=0.590> ;SEMICOLON } return 0 <sil=0.504> ;SEMICOLON }
We have to write the same loop twice <sil=0.943> .PERIOD We may want to somehow put this code in a separate place and simply jump to this code when we want to use it <sil=0.941> .PERIOD This would look like:
#include <stdio <sil=0.917> .PERIOD h>
void Print_Squares(void)
{ int i <sil=0.643> ;SEMICOLON for(i=1 <sil=0.444> ;SEMICOLON i <=5 <sil=0.581> ;SEMICOLON i++)
{ printf("%d " <sil=0.614> ,COMMA i*i) <sil=0.464> ;SEMICOLON }
}
int main(void)
{
Print_Squares() <sil=0.567> ;SEMICOLON Print_Squares() <sil=0.649> ;SEMICOLON return 0 <sil=0.468> ;SEMICOLON }
This is precisely what functions are for <sil=0.926> .PERIOD More on functions
A function is like a black box <sil=0.999> .PERIOD It takes in input <sil=0.448> ,COMMA does something with it <sil=0.597> ,COMMA then spits out an answer <sil=0.919> .PERIOD Note that a function may not take any inputs at all <sil=0.635> ,COMMA or it may not return anything at all <sil=0.914> .PERIOD In the above example <sil=0.300> ,COMMA if we were to make a function of that loop <sil=0.404> ,COMMA we may not need any inputs <sil=0.594> ,COMMA and we aren't returning anything at all (Text output doesn't count - when we speak of returning we mean to say meaningful data that the program can use) <sil=0.937> .PERIOD We have some terminology to refer to functions:
• A function <sil=0.575> ,COMMA call it f <sil=0.633> ,COMMA that uses another function g <sil=0.551> ,COMMA is said to call g <sil=0.969> .PERIOD • For example <sil=0.458> ,COMMA f calls g to print the squares of ten numbers <sil=0.960> .PERIOD • A function's inputs are known as its arguments <sil=0.963> .PERIOD • A function g that gives some kind of answer back to f is said to return that answer <sil=0.959> .PERIOD • For example <sil=0.407> ,COMMA g returns the sum of its arguments <sil=0.920> .PERIOD Writing functions in C
It's always good to learn by example <sil=0.998> .PERIOD Let's write a function that will return the square of a number <sil=0.915> .PERIOD int square(int x)
{ int square_of_x <sil=0.627> ;SEMICOLON square_of_x = x * x <sil=0.418> ;SEMICOLON return square_of_x <sil=0.463> ;SEMICOLON }
To understand how to write such a function like this <sil=0.605> ,COMMA it may help to look at what this function does as a whole <sil=0.903> .PERIOD It takes in an int <sil=0.462> ,COMMA x <sil=0.528> ,COMMA and squares it <sil=0.592> ,COMMA storing it in the variable square_of_x <sil=0.924> .PERIOD Now this value is returned <sil=0.981> .PERIOD The first int at the beginning of the function declaration is the type of data that the function returns <sil=0.942> .PERIOD In this case when we square an integer we get an integer <sil=0.431> ,COMMA and we are returning this integer <sil=0.524> ,COMMA and so we write int as the return type <sil=0.908> .PERIOD Next is the name of the function <sil=0.912> .PERIOD It is good practice to use meaningful and descriptive names for functions you may write <sil=0.936> .PERIOD It may help to name the function after what it is written to do <sil=0.971> .PERIOD In this case we name the function ”square” <sil=0.311> ,COMMA because that's what it does - it squares a number <sil=0.913> .PERIOD Next is the function's first and only argument <sil=0.393> ,COMMA an int <sil=0.353> ,COMMA which will be referred to in the function as x <sil=0.994> .PERIOD This is the function's input <sil=0.946> .PERIOD In between the braces is the actual guts of the function <sil=0.925> .PERIOD It declares an integer variable called square_of_x that will be used to hold the value of the square of x <sil=0.956> .PERIOD Note that the variable square_of_x can only be used within this function <sil=0.360> ,COMMA and not outside <sil=0.999> .PERIOD We'll learn more about this sort of thing later <sil=0.374> ,COMMA and we will see that this property is very useful <sil=0.928> .PERIOD We then assign x multiplied by x <sil=0.527> ,COMMA or x squared <sil=0.555> ,COMMA to the variable square_of_x <sil=0.330> ,COMMA which is what this function is all about <sil=0.924> .PERIOD Following this is a return statement <sil=0.902> .PERIOD We want to return Writing functions in C the value of the square of x <sil=0.571> ,COMMA so we must say that this function returns the contents of the variable square_of_x <sil=0.941> .PERIOD Our brace to close <sil=0.535> ,COMMA and we have finished the declaration <sil=0.999> .PERIOD Written in a more concise manner <sil=0.599> ,COMMA this code performs exactly the same function as the above:
int square(int x)
{
return x * x <sil=0.374> ;SEMICOLON }
Note this should look familiar - you have been writing functions already <sil=0.477> ,COMMA in fact - main is a function that is always written <sil=0.908> .PERIOD In general
In general <sil=0.451> ,COMMA if we want to declare a function <sil=0.362> ,COMMA we write
type name(type1 arg1 <sil=0.620> ,COMMA type2 arg2 <sil=0.569> ,COMMA  <sil=0.918> .PERIOD  <sil=0.614> .PERIOD  <sil=0.383> .PERIOD ) {
/* code */ }

We've previously said that a function can take no arguments <sil=0.373> ,COMMA or can return nothing <sil=0.450> ,COMMA or both <sil=0.960> .PERIOD What do we write if we want the function to return nothing <sil=0.945> ?QUESTIONMARK We use C's void keyword <sil=0.960> .PERIOD void basically means ”nothing” - so if we want to write a function that returns nothing <sil=0.305> ,COMMA for example <sil=0.555> ,COMMA we write
void sayhello(int number_of_times)
{ int i <sil=0.565> ;SEMICOLON for(i=1 <sil=0.340> ;SEMICOLON i <= number_of_times <sil=0.633> ;SEMICOLON i++) { printf("Hello <sil=0.924> !EXCLAMATIONMARK \n") <sil=0.497> ;SEMICOLON }
}
Notice that there is no return statement in the function above <sil=0.994> .PERIOD Since there's none <sil=0.401> ,COMMA we write void as the return type <sil=0.952> .PERIOD (Actually <sil=0.388> ,COMMA one can use the return keyword in a procedure to return to the caller before the end of the procedure <sil=0.340> ,COMMA but one cannot return a value as if it were a function <sil=0.963> .PERIOD )
What about a function that takes no arguments <sil=0.984> ?QUESTIONMARK If we want to do this <sil=0.312> ,COMMA we can write for example
float calculate_number(void)
{ float to_return=1 <sil=0.470> ;SEMICOLON int i <sil=0.391> ;SEMICOLON for(i=0 <sil=0.600> ;SEMICOLON i < 100 <sil=0.638> ;SEMICOLON i++) { to_return += 1 <sil=0.387> ;SEMICOLON to_return = 1/to_return <sil=0.492> ;SEMICOLON }
return to_return <sil=0.391> ;SEMICOLON }
Notice this function doesn't take any inputs <sil=0.543> ,COMMA but merely returns a number calculated by this function <sil=0.938> .PERIOD Naturally <sil=0.310> ,COMMA you can combine both void return and void in arguments together to get a valid function <sil=0.357> ,COMMA also <sil=0.934> .PERIOD Recursion
Here's a simple function that does an infinite loop <sil=0.934> .PERIOD It prints a line and calls itself <sil=0.423> ,COMMA which again prints a line and calls itself again <sil=0.568> ,COMMA and this continues until the stack overflows and the program crashes <sil=0.958> .PERIOD A function calling itself is called recursion <sil=0.402> ,COMMA and normally you will have a conditional that would stop the recursion after a small <sil=0.471> ,COMMA finite number of steps <sil=0.916> .PERIOD // don't run this <sil=0.957> !EXCLAMATIONMARK void infinite_recursion()
{ printf("Infinite loop <sil=0.978> !EXCLAMATIONMARK \n") <sil=0.561> ;SEMICOLON infinite_recursion() <sil=0.532> ;SEMICOLON }
A simple check can be done like this <sil=0.910> .PERIOD Note that ++depth is used so the increment will take place before the value is passed into the function <sil=0.923> .PERIOD Alternatively you can increment on a separate line before the recursion call <sil=0.942> .PERIOD If you say print_me(3 <sil=0.617> ,COMMA 0) <sil=0.387> ;SEMICOLON the function will print the line Recursion 3 times <sil=0.904> .PERIOD void print_me(int j <sil=0.587> ,COMMA int depth)
{ if(depth < j) { printf("Recursion <sil=0.956> !EXCLAMATIONMARK depth = %d j = %d\n" <sil=0.309> ,COMMA depth <sil=0.436> ,COMMA j) <sil=0.551> ;SEMICOLON //j keeps its value print_me(j <sil=0.644> ,COMMA ++depth) <sil=0.455> ;SEMICOLON }
}
Recursion is most often used for jobs such as directory tree scans <sil=0.352> ,COMMA seeking for the end of a linked list <sil=0.583> ,COMMA parsing a tree structure in a database and factorising numbers (and finding primes) among other things <sil=0.973> .PERIOD Static functions
If a function is to be called only from within the file in which it is declared <sil=0.346> ,COMMA it is appropriate to declare it as a static function <sil=0.906> .PERIOD When a function is declared static <sil=0.371> ,COMMA the compiler will now compile to an object file in a way that prevents the function from being called from code in other files <sil=0.938> .PERIOD Example:
static int compare( int a <sil=0.308> ,COMMA int b )
{
return (a+4 < b) <sil=0.893> ?QUESTIONMARK a : b <sil=0.376> ;SEMICOLON }
Using C functions
We can now write functions <sil=0.416> ,COMMA but how do we use them <sil=0.950> ?QUESTIONMARK When we write main <sil=0.546> ,COMMA we place the function outside the braces that encompass main <sil=0.972> .PERIOD When we want to use that function <sil=0.564> ,COMMA say <sil=0.333> ,COMMA using our calculate_number function above <sil=0.584> ,COMMA we can write something like
float f <sil=0.581> ;SEMICOLON f = calculate_number() <sil=0.457> ;SEMICOLON If a function takes in arguments <sil=0.376> ,COMMA we can write something like
int square_of_10 <sil=0.464> ;SEMICOLON square_of_10 = square(10) <sil=0.543> ;SEMICOLON If a function doesn't return anything <sil=0.472> ,COMMA we can just say
 say_hello() <sil=0.472> ;SEMICOLON since we don't need a variable to catch its return value <sil=0.998> .PERIOD Functions from the C Standard Library
While the C language doesn't itself contain functions <sil=0.495> ,COMMA it is usually linked with the C Standard Library <sil=0.977> .PERIOD To use this library <sil=0.342> ,COMMA you need to add an #include directive at the top of the C file <sil=0.588> ,COMMA which may be one of the following:
•	<assert <sil=0.936> .PERIOD h> 
•	<ctype <sil=0.906> .PERIOD h>
 • 	<errno <sil=0.991> .PERIOD h> 
•	<float <sil=0.925> .PERIOD h> 
The functions avail able are:
	•	<limits <sil=0.994> .PERIOD h> 
•	<locale <sil=0.920> .PERIOD h> 
•	<math <sil=0.933> .PERIOD h> 
•	<setjmp <sil=0.906> .PERIOD h> 
	•	<signal <sil=0.926> .PERIOD h> 
•	<stdarg <sil=0.948> .PERIOD h> 
•	<stddef <sil=0.931> .PERIOD h> 
•	<stdio <sil=0.906> .PERIOD h>	
•	<stdlib <sil=0.903> .PERIOD h> 
•	<string <sil=0.907> .PERIOD h> 
•	<time <sil=0.958> .PERIOD h> 
•	<complex <sil=0.921> .PERIOD h>
		•	<assert <sil=0.909> .PERIOD h>
		•	<limits <sil=0.911> .PERIOD h>
		•	<signal <sil=0.989> .PERIOD h>
		•	<stdlib <sil=0.905> .PERIOD h>


Variable-length argument lists
Functions with variable-length argument lists are functions that can take a varying number of arguments <sil=0.974> .PERIOD An example in the C standard library is the printf function <sil=0.464> ,COMMA which can take any number of arguments depending on how the programmer wants to use it <sil=1.000> .PERIOD C programmers rarely find the need to write new functions with variable-length arguments <sil=1.000> .PERIOD If they want to pass a bunch of things to a function <sil=0.629> ,COMMA they typically define a structure to hold all those things -- perhaps a linked list <sil=0.503> ,COMMA or an array -- and call that function with the data in the arguments <sil=0.984> .PERIOD However <sil=0.342> ,COMMA you may occasionally find the need to write a new function that supports a variable-length argument list <sil=0.998> .PERIOD To create a function that can accept a variable-length argument list <sil=0.415> ,COMMA you must first include the standard library header stdarg <sil=0.957> .PERIOD h <sil=0.910> .PERIOD Next <sil=0.625> ,COMMA declare the function as you would normally <sil=0.999> .PERIOD Next <sil=0.302> ,COMMA add as the last argument an ellipsis (” <sil=0.934> .PERIOD  <sil=0.547> .PERIOD  <sil=0.490> .PERIOD ”) <sil=0.538> .PERIOD This indicates to the compiler that a variable list of arguments is to follow <sil=0.900> .PERIOD For example <sil=0.629> ,COMMA the following function declaration is for a function that returns the average of a list of numbers: float average (int n_args <sil=0.575> ,COMMA  <sil=0.905> .PERIOD  <sil=0.650> .PERIOD  <sil=0.432> .PERIOD ) <sil=0.483> ;SEMICOLON Note that because of the way variable-length arguments work <sil=0.575> ,COMMA we must somehow <sil=0.361> ,COMMA in the arguments <sil=0.424> ,COMMA specify the number of elements in the variable-length part of the arguments <sil=0.901> .PERIOD In the average function here <sil=0.628> ,COMMA it's done through an argument called n_args <sil=0.905> .PERIOD In the printf function <sil=0.311> ,COMMA it's done with the format codes that you specify in that first string in the arguments you provide <sil=0.956> .PERIOD Now that the function has been declared as using variable-length arguments <sil=0.554> ,COMMA we must next write the code that does the actual work in the function <sil=0.947> .PERIOD To access the numbers stored in the variable-length argument list for our average function <sil=0.626> ,COMMA we must first declare a variable for the list itself: va_list myList <sil=0.310> ;SEMICOLON The va_list type is a type declared in the stdarg <sil=0.994> .PERIOD h header that basically allows you to keep track of your list <sil=0.946> .PERIOD To start actually using myList <sil=0.512> ,COMMA however <sil=0.986> ,COMMA we must first assign it a value <sil=0.983> .PERIOD After all <sil=0.633> ,COMMA simply declaring it by itself wouldn't do anything <sil=0.930> .PERIOD To do this <sil=0.440> ,COMMA we must call va_start <sil=0.583> ,COMMA which is actually a macro defined in stdarg <sil=0.908> .PERIOD h <sil=0.999> .PERIOD In the arguments to va_start <sil=0.356> ,COMMA you must provide the va_list variable you plan on using <sil=0.412> ,COMMA as well as the name of the last variable appearing before the ellipsis in your function declaration:
#include <stdarg <sil=0.907> .PERIOD h> float average (int n_args <sil=0.574> ,COMMA  <sil=0.938> .PERIOD  <sil=0.565> .PERIOD  <sil=0.566> .PERIOD )
{ va_list myList <sil=0.534> ;SEMICOLON va_start (myList <sil=0.409> ,COMMA n_args) <sil=0.613> ;SEMICOLON va_end (myList) <sil=0.349> ;SEMICOLON }
Now that myList has been prepped for usage <sil=0.308> ,COMMA we can finally start accessing the variables stored in it <sil=0.930> .PERIOD To do so <sil=0.622> ,COMMA use the va_arg macro <sil=0.516> ,COMMA which pops off the next argument on the list <sil=0.996> .PERIOD In the arguments to va_arg <sil=0.305> ,COMMA provide the va_list variable you're using <sil=0.306> ,COMMA as well as the primitive data type (e <sil=0.967> .PERIOD g <sil=0.917> .PERIOD int <sil=0.522> ,COMMA char) that the variable you're accessing should be:
#include <stdarg <sil=0.997> .PERIOD h> float average (int n_args <sil=0.406> ,COMMA  <sil=0.936> .PERIOD  <sil=0.647> .PERIOD  <sil=0.338> .PERIOD )
{ va_list myList <sil=0.420> ;SEMICOLON va_start (myList <sil=0.608> ,COMMA n_args) <sil=0.400> ;SEMICOLON int myNumber = va_arg (myList <sil=0.513> ,COMMA int) <sil=0.372> ;SEMICOLON va_end (myList) <sil=0.373> ;SEMICOLON }
By popping n_args integers off of the variable-length argument list <sil=0.380> ,COMMA we can manage to find the average of the numbers:
#include <stdarg <sil=0.955> .PERIOD h> float average (int n_args <sil=0.340> ,COMMA  <sil=0.947> .PERIOD  <sil=0.324> .PERIOD  <sil=0.343> .PERIOD )
{ va_list myList <sil=0.343> ;SEMICOLON va_start (myList <sil=0.415> ,COMMA n_args) <sil=0.548> ;SEMICOLON int numbersAdded = 0 <sil=0.432> ;SEMICOLON int sum = 0 <sil=0.392> ;SEMICOLON while (numbersAdded < n_args) { int number = va_arg (myList <sil=0.503> ,COMMA int) <sil=0.501> ;SEMICOLON // Get next number from list sum += number <sil=0.611> ;SEMICOLON numbersAdded += 1 <sil=0.321> ;SEMICOLON } va_end (myList) <sil=0.361> ;SEMICOLON float avg = (float)(sum) / (float)(numbersAdded) <sil=0.487> ;SEMICOLON // Find the average return avg <sil=0.460> ;SEMICOLON }
By calling average (2 <sil=0.483> ,COMMA 10 <sil=0.412> ,COMMA 20) <sil=0.335> ,COMMA we get the average of 10 and 20 <sil=0.473> ,COMMA which is 15 <sil=0.987> .PERIOD Preprocessor
Preprocessors are a way of making text processing with your C program before they are actually compiled <sil=0.970> .PERIOD Before the actual compilation of every C program it is passed through a Preprocessor <sil=0.922> .PERIOD The Preprocessor looks through the program trying to find out specific instructions called Preprocessor directives that it can understand <sil=0.961> .PERIOD All Preprocessor directives begin with the # (hash) symbol <sil=0.939> .PERIOD C++ compilers use the same C preprocessor <sil=0.904> .PERIOD The preprocessor is a part of the compiler which performs preliminary operations (conditionally compiling code <sil=0.584> ,COMMA including files etc <sil=0.928> .PERIOD  <sil=0.303> .PERIOD  <sil=0.345> .PERIOD ) to your code before the compiler sees it <sil=0.975> .PERIOD These transformations are lexical <sil=0.509> ,COMMA meaning that the output of the preprocessor is still text <sil=0.991> .PERIOD Directives
Directives are special instructions directed to the preprocessor (preprocessor directive) or to the compiler (compiler directive) on how it should process part or all of your source code or set some flags on the final object and are used to make writing source code easier (more portable for instance) and to make the source code more understandable <sil=0.977> .PERIOD Directives are handled by the preprocessor <sil=0.434> ,COMMA which is either a separate program invoked by the compiler or part of the compiler itself <sil=0.913> .PERIOD #include
C has some features as part of the language and some others as part of a standard library <sil=0.573> ,COMMA which is a repository of code that is available alongside every standard-conformant C compiler <sil=0.978> .PERIOD When the C compiler compiles your program it usually also links it with the standard C library <sil=0.916> .PERIOD For example <sil=0.439> ,COMMA on encountering a #include <stdio <sil=0.976> .PERIOD h> directive <sil=0.612> ,COMMA it replaces the directive with the contents of the stdio <sil=0.939> .PERIOD h header file <sil=0.917> .PERIOD When you use features from the library <sil=0.493> ,COMMA C requires you to declare what you would be using <sil=0.910> .PERIOD The first line in the program is a preprocessing directive which should look like this:
#include <stdio <sil=0.939> .PERIOD h>
The above line causes the C declarations which are in the stdio <sil=0.987> .PERIOD h header to be included for use in your program <sil=0.976> .PERIOD Usually this is implemented by just inserting into your program the contents of a header file called stdio <sil=0.932> .PERIOD h <sil=0.999> ,COMMA located in a system-dependent location <sil=0.995> .PERIOD The location of such files may be described in your compiler's documentation <sil=0.914> .PERIOD A list of standard C header files is listed below in the Headers table <sil=0.946> .PERIOD The stdio <sil=0.933> .PERIOD h header contains various declarations for input/output (I/O) using an abstraction of I/O mechanisms called streams <sil=0.952> .PERIOD For example there is an output stream object called stdout which is used to output text to the standard output <sil=0.363> ,COMMA which usually displays the text on the computer screen <sil=0.928> .PERIOD If using angle brackets like the example above <sil=0.583> ,COMMA the preprocessor is instructed to search for the include file along the development environment path for the standard includes <sil=0.924> .PERIOD #include "other <sil=0.976> .PERIOD h"
If you use quotation marks (" ") <sil=0.486> ,COMMA the preprocessor is expected to search in some additional <sil=0.467> ,COMMA usually user-defined <sil=0.525> ,COMMA locations for the header file <sil=0.571> ,COMMA and to fall back to the standard include paths only if it is not found in those additional locations <sil=0.961> .PERIOD It is common for this form to include searching in the same directory as the file containing the #include directive <sil=0.914> .PERIOD #pragma
The pragma (pragmatic information) directive is part of the standard <sil=0.398> ,COMMA but the meaning of any pragma depends on the software implementation of the standard that is used <sil=0.960> .PERIOD The #pragma directive provides a way to request special behavior from the compiler <sil=0.948> .PERIOD This directive is most useful for programs that are unusually large or that need to take advantage of the capabilities of a particular compiler <sil=0.998> .PERIOD Pragmas are used within the source program <sil=0.969> .PERIOD #pragma token(s)
pragma is usually followed by a single token <sil=0.440> ,COMMA which represents a command for the compiler to obey <sil=0.942> .PERIOD You should check the software implementation of the C standard you intend on using for a list of the supported tokens <sil=0.978> .PERIOD Not surprisingly <sil=0.327> ,COMMA the set of commands that can appear in #pragma directives is different for each compiler <sil=0.360> ;SEMICOLON you'll have to consult the documentation for your compiler to see which commands it allows and what those commands do <sil=0.967> .PERIOD For instance one of the most implemented preprocessor directives <sil=0.364> ,COMMA #pragma once when placed at the beginning of a header file <sil=0.512> ,COMMA indicates that the file where it resides will be skipped if included several times by the preprocessor <sil=0.986> .PERIOD #define
The #define directive is used to define values or macros that are used by the preprocessor to manipulate the program source code before it is compiled <sil=0.944> .PERIOD Because preprocessor definitions are substituted before the compiler acts on the source code <sil=0.588> ,COMMA any errors that are introduced by #define are difficult to trace <sil=0.953> .PERIOD By convention <sil=0.589> ,COMMA values defined using #define are named in uppercase <sil=0.938> .PERIOD Although doing so is not a requirement <sil=0.304> ,COMMA it is considered very bad practice to do otherwise <sil=0.919> .PERIOD This allows the values to be easily identified when reading the source code <sil=0.976> .PERIOD Today <sil=0.456> ,COMMA #define is primarily used to handle compiler and platform differences <sil=0.916> .PERIOD E <sil=0.984> .PERIOD g <sil=0.951> .PERIOD  <sil=0.412> ,COMMA a define might hold a constant which is the appropriate error code for a system call <sil=0.972> .PERIOD The use of #define should thus be limited unless absolutely necessary <sil=0.464> ;SEMICOLON typedef statements and constant variables can often perform the same functions more safely <sil=0.927> .PERIOD Another feature of the #define command is that it can take arguments <sil=0.324> ,COMMA making it rather useful as a pseudo-function creator <sil=0.961> .PERIOD Consider the following code:
#define ABSOLUTE_VALUE( x ) ( ((x) < 0) <sil=0.968> ?QUESTIONMARK -(x) : (x) ) <sil=0.907> .PERIOD  <sil=0.567> .PERIOD  <sil=0.531> .PERIOD int x = -1 <sil=0.531> ;SEMICOLON while( ABSOLUTE_VALUE( x ) ) { <sil=0.926> .PERIOD  <sil=0.642> .PERIOD  <sil=0.475> .PERIOD }
It's generally a good idea to use extra parentheses when using complex macros <sil=0.972> .PERIOD Notice that in the above example <sil=0.300> ,COMMA the variable ”x” is always within its own set of parentheses <sil=1.000> .PERIOD This way <sil=0.318> ,COMMA it will be evaluated in whole <sil=0.519> ,COMMA before being compared to 0 or multiplied by -1 <sil=0.921> .PERIOD Also <sil=0.634> ,COMMA the entire macro is surrounded by parentheses <sil=0.630> ,COMMA to prevent it from being contaminated by other code <sil=0.952> .PERIOD If you're not careful <sil=0.396> ,COMMA you run the risk of having the compiler misinterpret your code <sil=0.980> .PERIOD Because of side-effects it is considered a very bad idea to use macro functions as described above <sil=0.951> .PERIOD int x = -10 <sil=0.409> ;SEMICOLON int y = ABSOLUTE_VALUE( x++ ) <sil=0.430> ;SEMICOLON If ABSOLUTE_VALUE() were a real function 'x' would now have the value of '-9' <sil=0.408> ,COMMA but because it was an argument in a macro it was expanded twice and thus has a value of -8 <sil=0.905> .PERIOD (# <sil=0.570> ,COMMA ##)
The # and ## operators are used with the #define macro <sil=0.963> .PERIOD Using # causes the first argument after the # to be returned as a string in quotes <sil=0.976> .PERIOD For example <sil=0.508> ,COMMA the command
#define as_string( s ) # s
	
will make the compiler turn this command
puts( as_string( Hello World <sil=0.925> !EXCLAMATIONMARK ) ) <sil=0.416> ;SEMICOLON Into
puts( "Hello World <sil=0.968> !EXCLAMATIONMARK " ) <sil=0.641> ;SEMICOLON Using ## concatenates what's before the ## with what's after it <sil=0.968> .PERIOD For example <sil=0.502> ,COMMA the command
#define concatenate( x <sil=0.543> ,COMMA y ) x ## y <sil=0.982> .PERIOD  <sil=0.351> .PERIOD  <sil=0.616> .PERIOD int xy = 10 <sil=0.400> ;SEMICOLON  <sil=0.916> .PERIOD  <sil=0.349> .PERIOD  <sil=0.615> .PERIOD will make the compiler turn	
printf( "%d" <sil=0.581> ,COMMA concatenate( x <sil=0.383> ,COMMA y )) <sil=0.521> ;SEMICOLON into	
printf( "%d" <sil=0.566> ,COMMA xy) <sil=0.499> ;SEMICOLON which will <sil=0.639> ,COMMA of course <sil=0.393> ,COMMA display 10 to standard output <sil=0.942> .PERIOD It is possible to concatenate a macro argument with a constant prefix or suffix to obtain a valid identifier as in
#define make_function( name ) int my_ ## name (int foo) {} make_function( bar )
which will define a function called my_bar() <sil=0.938> .PERIOD But it isn't possible to integrate a macro argument into a constant string using the concatenation operator <sil=0.993> .PERIOD In order to obtain such an effect <sil=0.416> ,COMMA one can use the ANSI C property that two or more consecutive string constants are considered equivalent to a single string constant when encountered <sil=0.940> .PERIOD Using this property <sil=0.550> ,COMMA one can write
#define eat( what ) puts( "I'm eating " #what " today <sil=0.915> .PERIOD " ) eat( fruit )
which the macro-processor will turn into
puts( "I'm eating " "fruit" " today <sil=0.919> .PERIOD " )
which in turn will be interpreted by the C parser as a single string constant <sil=0.905> .PERIOD The following trick can be used to turn a numeric constants into string literals
#define num2str(x) str(x)
#define str(x) 
#x 
#define CONST 23 puts(num2str(CONST)) <sil=0.328> ;SEMICOLON This is a bit tricky <sil=0.526> ,COMMA since it is expanded in 2 steps <sil=0.962> .PERIOD First num2str(CONST)is replaced with str(23) <sil=0.469> ,COMMA which in turn is replaced with "23" <sil=0.984> .PERIOD 