Now <sil=0.414> ,COMMA for a recursive function this means that you must show or argue that there is a base case whose solution is computed without calling the function recursively <sil=0.966> .PERIOD So <sil=0.487> ,COMMA for example <sil=0.346> ,COMMA in the factorial function the base case was n equal to 1 or n equal to 0 <sil=0.921> .PERIOD In the case of the GCD function the base case was when the two given numbers are equal <sil=0.981> .PERIOD So <sil=0.410> ,COMMA we have to ensure that there is a base case in which the recursive function is not called and in other cases when the recursive call is made then the recursive call is made for one or more problem instances that are closer to the base case <sil=0.932> .PERIOD So <sil=0.499> ,COMMA for example <sil=0.463> ,COMMA in the factorial function the recursive call is made for n minus 1 factorial <sil=0.902> .PERIOD Now <sil=0.609> ,COMMA n minus 1 is closer to the base case which is n equal to 0 then the given value n clearly and so this process will finally end <sil=0.981> .PERIOD So <sil=0.619> ,COMMA we have to argue that the recursive call is being made for a problem instance or for multiple problem instances that are all closer to the base case then the given instance <sil=0.960> .PERIOD So <sil=0.322> ,COMMA once we have argued that the function actually terminates then what we need to show is that whatever answer it does that the function computes for a given instance of the problem is the correct answer <sil=0.939> .PERIOD And the way to argue that for recursive functions is very simple use well known and familiar to you principle of mathematical induction you show that in the base case the answer is computed correctly and in the other cases the what you do in proving something by induction is that you assume an induction hypothesis and then show in the induction step that the solution to the given instance of the problem is correct <sil=0.913> .PERIOD So <sil=0.531> ,COMMA as the induction hypothesis you would assume that the solution to the simpler instances of the problem for which you are using recursion they result in the right answer and if the result in the right answer in the induction step we need to show that the solution to the given instance of the problem is computed correctly <sil=0.953> .PERIOD So <sil=0.643> ,COMMA let us look at the factorial function and the DCD functions and again and try to apply these kinds of argument <sil=0.908> .PERIOD So <sil=0.360> ,COMMA for the factorial function arguing that the function terminates is easy you can see that there is a base case is the base case and in the other cases where also in the base case no recursive called the same function is made and in the other cases the call is made for a smaller value of n and so which is which is closer to the base case than the given value of n and therefore <sil=0.518> ,COMMA the function will certainly terminate and the other thing that we need to argue is that if when the function terminates it returns to the right value <sil=0.972> .PERIOD Now <sil=0.380> ,COMMA again we use principle of mathematical induction for n equal to 0 which is the base case the answer is correct because by definition n factorial is equal to 1 and of course <sil=0.560> ,COMMA for other cases it is also correct because if we assume that the factorial of n minus 1 is computed correctly then it is easy to see that the factorial of n which is computed as n times factorial of n minus 1 is also computed correctly <sil=0.912> .PERIOD So <sil=0.590> ,COMMA this happens to be particularly simple example where arguing correctness is quite easy <sil=0.962> .PERIOD Let us look at the GCD function next <sil=0.936> .PERIOD Now <sil=0.621> ,COMMA it is easy to argue that the result computed by the function is correct because we are directly using the properties of the GCD function that we know to be correct <sil=0.991> .PERIOD It is a little harder to argue that the function indeed terminates because we need to show that when we made a recursive call the recursive call is for a problem in sense which is closer to the base case <sil=0.942> .PERIOD Now <sil=0.369> ,COMMA for the base case if you look at the magnitude of the difference of the two numbers given that is 0 because in the base case is equal to 2 <sil=0.908> .PERIOD Now <sil=0.343> ,COMMA in the other cases you can see that the recursive call is made for a instance in which the absolute value of the difference of the two numbers actually is less than the difference of the two given numbers <sil=0.921> .PERIOD So <sil=0.623> ,COMMA let us say a is greater than b <sil=0.935> .PERIOD If a is greater than b then the difference of the two numbers in the instance of the problem that we are solving recursively is a minus b minus b is equal to a minus 2 b and which is less than a minus b <sil=0.901> .PERIOD So <sil=0.595> ,COMMA we have got we have gone closer to the base case because the difference between the two numbers has actually reduced <sil=0.970> .PERIOD Similarly <sil=0.499> ,COMMA if a happens to be less than b then the absolute value of the difference between the two numbers is b minus originally b minus a and which is greater than the new difference which is b minus a minus a is equal to b minus 2 a and so again from the difference b minus a we have gone to the difference b minus 2 a <sil=0.950> .PERIOD So <sil=0.640> ,COMMA the difference between the two numbers absolute value of the difference between the two numbers has decreased and so finally <sil=0.331> ,COMMA the difference will become 0 because in each step it is certainly decreasing and therefore <sil=0.503> ,COMMA finally <sil=0.401> ,COMMA it will become 0 in which case will have reached the base case <sil=0.968> .PERIOD So <sil=0.504> ,COMMA that is how you argue the correctness of recursive functions <sil=0.944> .PERIOD I will see in the next lecture how the recursive functions work <sil=0.339> ,COMMA but even without understanding fully how recursive functions work we should be able to use these principles to develop and argue the correctness of recursive function <sil=0.910> .PERIOD Now <sil=0.608> ,COMMA the question is what you want to use recursion at all <sil=0.905> ?QUESTIONMARK So <sil=0.315> ,COMMA as I said in many cases the problems are very difficult to solve without using recursion <sil=0.367> ,COMMA but are quite simple to solve by using recursion <sil=0.929> .PERIOD The examples that you just saw the factorial function and the d c d function these were not really very good examples of recursion because as you know these functions can be these functions can be implemented quite easily without using recursion also <sil=0.644> ,COMMA but we will see some other problems which are very easy to solve recursively and comparatively harder to use comparatively harder to solve without using recursion <sil=0.921> .PERIOD So <sil=0.480> ,COMMA let us see an example this is the famous accurment function which is defined as follows <sil=0.987> .PERIOD So <sil=0.414> ,COMMA again it is defined for a for 2 parameter m and n which are both greater than 0 and a of m n is equal to n if m is equal to 0 is equal to a of m minus 1 comma 1 if m is greater than 0 and n is equal to 0 and it is equal to a of m minus 1 comma a of m comma minus 1 if both m and n are greater than 0 <sil=0.991> .PERIOD So <sil=0.581> ,COMMA as an exercise you can try to implement the accurment function without using recursion you will find that it is extremely hard <sil=0.636> ,COMMA but as you can see if you directly use this definition then using recursion the function is extremely easy to define <sil=0.935> .PERIOD So <sil=0.605> ,COMMA here is the possible implementation for the accurment function if m is equal to 0 return n if m is greater than 0 and n is equal to 0 return accurment of m minus 1 comma 1 otherwise return accurment of m minus 1 comma accurment of m comma n minus 1 as you can see that this implementation of the function follows directly from the definition of the function itself and we did not have to think at all about implementation <sil=0.981> .PERIOD On the other hand if you want to implement a non-recurricular solution to this problem that extremely hard even though in principle it can be done <sil=0.970> .PERIOD So <sil=0.565> ,COMMA let us now look at another example of using recursion suppose we did not have useful printf function to print integers for us and let us say we then wanted to print an integers and let us assume that the only library function for printing something on the screen is the put care function which can print a single character given its f key value <sil=0.941> .PERIOD So <sil=0.336> ,COMMA essentially the problem is to write a function which given an integer n prints that integer on the screen using only the put care library function <sil=0.928> .PERIOD Now <sil=0.461> ,COMMA how do you go about printing an integer <sil=0.856> ?QUESTIONMARK You can print only one character at a time <sil=0.947> .PERIOD So <sil=0.561> ,COMMA what we need to do is to find all the digits of the number successively one by one and then print them using the put care function <sil=0.948> .PERIOD Now <sil=0.610> ,COMMA so the problem is easy if the number is a single digit number <sil=0.926> .PERIOD So <sil=0.397> ,COMMA for example if n happens to be 6 all you have to do is to call put care with the f key value of the character 6 <sil=0.909> .PERIOD But if the number is larger than 10 then you have to successively divide 8 by 0 and in every step take the remainder you have to repeatedly divide the number by 10 and in every step take the remainder and that gives you one digit of the number and this process has to be repeated till the number which comes equal to 0 <sil=0.988> .PERIOD Now <sil=0.412> ,COMMA this process gives you all the digits of the number but in the reverse order <sil=0.956> .PERIOD So <sil=0.466> ,COMMA for example <sil=0.332> ,COMMA if the number happen to be 123 when you divide it first by 10 and take the remainder you get 3 and then if you then the number remaining is 12 and then if you take again the remainder with 10 then you get 1 then you get 2 and the number left is 1 and that of course is less than 10 <sil=0.992> .PERIOD So <sil=0.374> ,COMMA you get all the 3 digits but in the reverse order <sil=0.953> .PERIOD So <sil=0.583> ,COMMA if you print them as soon as you take the remainder you will get the wrong result because the digits will be printed in the reverse order <sil=0.924> .PERIOD Now <sil=0.341> ,COMMA if you want to print them in the correct order then what we need to do is to store these digits that you obtain in an array and then later print the elements of the array in the reverse order <sil=0.978> .PERIOD Now <sil=0.636> ,COMMA using recursion we can actually make this problem simpler <sil=0.908> .PERIOD So <sil=0.328> ,COMMA let us think about this problem recursively for negative integers of course <sil=0.372> ,COMMA are not difficult to handle <sil=0.911> .PERIOD If n is negative to print it all we have to do is to print a minus sign the minus correct and then set to set n to minus n <sil=0.956> .PERIOD So <sil=0.342> ,COMMA we do not have to worry too much about negative numbers therefore <sil=0.555> ,COMMA let us assume that the number is greater than equal to 0 <sil=0.933> .PERIOD Now <sil=0.405> ,COMMA the base case is when the number is a single digit number in in other words n is less than 10 <sil=0.940> .PERIOD Now <sil=0.410> ,COMMA when n is less than 10 it is easy to print the number using put care <sil=0.959> .PERIOD So <sil=0.404> ,COMMA if the number is n then what we need to do is to find the sq value of the character of the character n <sil=0.987> .PERIOD Now <sil=0.407> ,COMMA how do we do that <sil=0.870> ?QUESTIONMARK That is quite easy if you take the sq value of 0 and add n to it that will give you the sq value of the character n provided then of course is less than 10 <sil=0.964> .PERIOD So <sil=0.323> ,COMMA for example <sil=0.400> ,COMMA if n happens to be 6 then the sq value of 0 plus the integer 6 will give you the sq value of the character 6 and that is because if you recall the sq values of all digits from 0 to 9 are contiguous to each other and in the increasing order <sil=0.930> .PERIOD So <sil=0.331> ,COMMA the sq value of 6 is actually 6 more than the sq value of the character 0 and so on <sil=0.924> .PERIOD So <sil=0.417> ,COMMA in the base case printing a single digit number is easy <sil=0.931> .PERIOD Now <sil=0.345> ,COMMA suppose we have given a number which is not a single digit number let us assume it is a k digit number and where k is less is greater than 1 <sil=0.941> .PERIOD Now <sil=0.505> ,COMMA how do we go about printing this number <sil=0.885> ?QUESTIONMARK Well <sil=0.390> ,COMMA you can see that we need to first print the value n by 10 <sil=0.959> .PERIOD Now <sil=0.633> ,COMMA how do we print n by 10 <sil=0.901> ?QUESTIONMARK n by 10 in general n by 10 is always going to be a k minus 1 digit number and k minus 1 may also be more than 1 <sil=0.922> .PERIOD So <sil=0.446> ,COMMA how do we print this k minus 1 digit number <sil=0.912> ?QUESTIONMARK Well <sil=0.349> ,COMMA we use recursion to solve this simpler instance of the same problem <sil=0.977> .PERIOD This is a simpler instance of the same problem because the number of digits has reduced by 1 and the base case is and the number of digits is just 1 <sil=0.995> .PERIOD So <sil=0.621> ,COMMA having printed recursively the number n by 10 then we print the last digit of n which is nothing but n percent n that is a remainder left and n is divided by 0 <sil=0.969> .PERIOD So <sil=0.480> ,COMMA let us say again the number happen to be 123 <sil=0.932> .PERIOD So <sil=0.350> ,COMMA let us assume that n by 10 can somehow be printed <sil=0.978> .PERIOD So <sil=0.509> ,COMMA n by 10 in this case is nothing but 12 and by making recursive call to the same function let us assume that number 12 gets printed somehow and once that is done all we have to do is now print the last digit of the number which is nothing but n percent n and we know how to print a single digit <sil=0.922> .PERIOD So <sil=0.431> ,COMMA we can do that easily <sil=0.929> .PERIOD So <sil=0.465> ,COMMA let us look at the implementation of this function now <sil=0.947> .PERIOD Where is the implementation <sil=0.851> ?QUESTIONMARK So <sil=0.504> ,COMMA we are I am calling the function print under 4 n the return type is void because it does not return any value it just print a given integer n and n is the parameter which is given integer which needs to be printed <sil=0.976> .PERIOD So <sil=0.462> ,COMMA if n is less than 0 then we print the minus sign using the put care function and set n to minus n <sil=0.914> .PERIOD So <sil=0.395> ,COMMA that is it now this is the base case if n is less than n then we know what to do all we have to do is to compute the sq value of the digit that represents n and print that using put care <sil=0.918> .PERIOD So <sil=0.553> ,COMMA that is what we do here otherwise n is greater than equal to 10 which means that n has at least 2 digits <sil=0.963> .PERIOD So <sil=0.542> ,COMMA we recursively print the number n by 10 which is guaranteed to have 1 digit less than the original number n and finally <sil=0.318> ,COMMA after doing that we print the last digit of n which is nothing but n percent n <sil=0.969> .PERIOD So <sil=0.462> ,COMMA we obtain h sq value by adding the sq value of 0 to it and print that <sil=1.000> .PERIOD So <sil=0.385> ,COMMA again you can argue the correctness and termination property of this function in a way similar to what we have argued earlier you can see this function terminates because every time when we make recursive calls the number of digits in the number decreases by 1 <sil=0.377> ,COMMA strictly decreases by 1 and finally <sil=0.457> ,COMMA the number of digits in the number will reduce to 1 in which case the number is printed without calling the function recursively <sil=0.907> .PERIOD And of course <sil=0.638> ,COMMA you know that to print a k digit number all you need to do is to first print the first k minus 1 digit which are represented by n by 10 and then print the kth digit <sil=0.960> .PERIOD So <sil=0.503> ,COMMA assuming that recursive call to print the k minus 1 digit number works correctly it is easy to see that the given k digit number will also be printed correctly <sil=0.967> .PERIOD So <sil=0.465> ,COMMA we will stop the lecture here today and in the next lecture we will talk about how recursion actually works and that will give us a better insight also into how to use recursion in our problem solving exercises <sil=0.964> .PERIOD In the last lecture we have talked about input and output facilities in C and we had looked at the printers <sil=0.357> ,COMMA canvels <sil=0.344> ,COMMA get-sare <sil=0.476> ,COMMA input-sare functions <sil=0.923> .PERIOD Today we will start looking at another very important topic that is control statement <sil=0.927> .PERIOD We are already familiar with control statements and we have been using them in most of the programs that we have written statements like the ifs and ifs and the world statements are known as control statements <sil=0.966> .PERIOD Usually program execution starts with first statement and to see it sequentially downwards but in any but most simple program this is not sufficient and we want the controls go to take more complicated form <sil=0.920> .PERIOD Usually for example we might want to do one thing or the other depending on some condition or we might want to repeatedly execute some block of code <sil=0.977> .PERIOD For that we need what are known as control statements <sil=0.986> .PERIOD We have as I said already seen these control statements in action and use them in all the programs that we have written so far but we will now in this lecture and in the next lecture look at some of these statements in more detail <sil=0.985> .PERIOD So there are two basic control flow statements or the control flow structures which are the first one is for conditional execution which is either do this or do that <sil=0.969> .PERIOD This is implemented using the if and the ifs condition statements that we have already seen and other useful kind of control structure is one of repeated execution wherein we want to keep doing certain action repeatedly till some condition is satisfied <sil=0.991> .PERIOD So this lecture will look at the conditional and vacation structures in more detail in particular will look at the EFEFEL statements and the fifth statement which we have not used in program so far <sil=0.942> .PERIOD So <sil=0.433> ,COMMA let us look at the if statement first <sil=0.927> .PERIOD The in the simplest form the if statement has the fintech shown here there is a condition and there is a statement following it and the meaning of this kind of a statement is that if the condition is true then the statement is executed <sil=0.994> .PERIOD If the condition evaluates to fall then the statement is not executed <sil=0.981> .PERIOD There are two important points about this particular concept <sil=0.946> .PERIOD First is that the statement which is shown here must be a single C statement which means that it cannot be a sequence of several assignments for example <sil=0.920> .PERIOD Now of course <sil=0.622> ,COMMA in practice we would like this block of code to be executed condition is satisfied to consist of more than one statement but that is very easy which is because as we have already noticed in our earlier lectures is as of statements if they are in close and braces then that becomes a single compound statement <sil=0.968> .PERIOD So <sil=0.533> ,COMMA this statement has to be single statement but of course <sil=0.557> ,COMMA it can be a compound statement meaning that if you put enough sequence of statements within braces since that must use a single compound statement we can use that here <sil=0.997> .PERIOD So <sil=0.620> ,COMMA the meaning of this statement is first evaluate the condition note that the condition may have side effects which you have already talked about and so those side effects will happen and finally <sil=0.354> ,COMMA the result of the condition evaluates to true and remember that in C true is any value which is non-zero then the given statement is executed otherwise it is not executed <sil=0.909> .PERIOD Here is a simple example to illustrate that side effects may take place during the condition evaluation <sil=0.902> .PERIOD So <sil=0.304> ,COMMA in this example X is initially 0 and Y is initially 1 and the statement is X plus plus then Y minus minus <sil=0.905> .PERIOD Now <sil=0.513> ,COMMA plus plus remember is the post increment operator and minus minus is the post decrement operator <sil=0.955> .PERIOD So <sil=0.417> ,COMMA when the condition which is in this case X plus is evaluated the result of the expression is 0 which is the old value of X and the new value of X becomes 1 <sil=0.949> .PERIOD So <sil=0.641> ,COMMA since the result of the expression evaluation is 0 which is false in C therefore <sil=0.586> ,COMMA the statement Y minus minus does not get executed which means that the end of the execution of the statement the value of X becomes 1 because of the side effects in the evaluation of the condition X plus and the value of Y remains 1 because Y minus minus does not get executed <sil=0.924> .PERIOD So <sil=0.307> ,COMMA let us take another somewhat more realistic example <sil=0.947> .PERIOD Suppose you want to write a simple program that takes is input the marks obtained by some student in some exam order funded and output field is the marks are less than 40 is of course <sil=0.622> ,COMMA a very very simple program <sil=0.935> .PERIOD So <sil=0.326> ,COMMA the usual things we declare variable marks and read the value of marks nothing that nothing strange here and here is the main part of the program is marks less than 40 then print a statement <sil=0.922> .PERIOD Note that print a fail this is a single statement and therefore <sil=0.594> ,COMMA we do not really need to put it in places to make it the body of the statement <sil=0.998> .PERIOD So <sil=0.521> ,COMMA when this program executes we read the value of marks and if the value of marks are less than 40 then this print a statement executes and frame is printed on the output <sil=0.903> .PERIOD But if the marks are 40 or more then nothing happens no print statement is executed and therefore <sil=0.599> ,COMMA there is no output from the program in that case <sil=0.977> .PERIOD So <sil=0.314> ,COMMA that is probably not what we wanted suppose we want to have our program written in such a session that it wants to express a fail depending on where the marks are 40 or above or not <sil=0.914> .PERIOD So <sil=0.515> ,COMMA print a if the marks are 40 or more or print frame is the marks are less than 40 <sil=0.980> .PERIOD So <sil=0.602> ,COMMA in this case what we need is an if a statement which essentially says do this or that depending on the result of a condition <sil=0.971> .PERIOD So <sil=0.355> ,COMMA you only evaluate a condition in this case as a marks are more than 40 or more or not and if that is true then execute some statement otherwise execute some other statement <sil=0.985> .PERIOD This is again a statement that we have already seen in practice in many programs that we have written earlier <sil=0.948> .PERIOD So <sil=0.600> ,COMMA here is the syntax <sil=0.944> .PERIOD There is again a condition if and else are result words of keyword is condition statement 1 L statement 2 <sil=0.552> ,COMMA statement 1 and statement 2 again have to be single statement but of course <sil=0.498> ,COMMA they can be compound statements or indeed as we will see they can themselves be control statements like statement 1 and statement 2 itself could be another statement <sil=0.903> .PERIOD So <sil=0.572> ,COMMA for this particular example the code looks very simple a marks less than 40 print S fail L print S half <sil=0.975> .PERIOD So <sil=0.623> ,COMMA suppose we also want to check whether the input marks given by the user are read between 0 and 100 and if not we should print invalid input remember we talked about program the first lesson in an earlier lecture and we should test all inputs to make sure that they have sensible values <sil=0.981> .PERIOD So <sil=0.386> ,COMMA you want to do this then what we need is a nested if a structure because the first thing we check is whether the marks are between 0 and 100 <sil=0.943> .PERIOD If not then we print invalid input otherwise we need to check whether the marks are less than 40 or not <sil=0.958> .PERIOD So <sil=0.398> ,COMMA say results the program might look like if marks are less than 0 or marks are greater than 100 then we print invalid input otherwise the code that we wrote earlier the entire thing if marks are less than 40 till the same L print S half <sil=0.922> .PERIOD Note that this entire F L statement is a single C statement which we are using as the statement for the L part of the outer F L statement <sil=0.988> .PERIOD Again since this is a single C statement we do not need to put traces around it so use it as the part of another EF statement <sil=0.967> .PERIOD Also note that the indentation makes it very clear that this EF statement is within the L and this print S is within the S which is of course within the L <sil=0.944> .PERIOD So <sil=0.402> ,COMMA now let us take the example little further and make it little more complicated suppose you want to assign grade to students depending on their marks <sil=0.952> .PERIOD So <sil=0.318> ,COMMA if marks are less than 40 let us say you want to give the grade F if the marks are more than 40 but less than 50 grade D between 50 and 60 that is 50 or more but less than 60 then grade C 60 or more but less than 80 than the grade B and if 80 or more marks are obtained then you want to give the grade A <sil=0.911> .PERIOD So <sil=0.512> ,COMMA you might use a sequence of nested EF statement <sil=0.909> .PERIOD So <sil=0.618> ,COMMA if marks are less than 0 or marks are greater than 100 between invalid input otherwise now this entire thing is a single EF statement that is L part the L statement of this outer EF statement <sil=0.977> .PERIOD So <sil=0.491> ,COMMA this says if marks are less than 40 print the grade to be F L if marks are less than 50 then print the grade B L if the marks are less than 60 grade D <sil=0.396> ,COMMA L marks if marks less than 80 grade B L the grade is A <sil=0.968> .PERIOD Now <sil=0.572> ,COMMA you can see that each successive EF statement is the L part of the outer EF statement <sil=0.948> .PERIOD So <sil=0.483> ,COMMA for example <sil=0.577> ,COMMA this EF statement is part of the statement for the L part of this EF statement and similarly this EF statement is the L part of the outer one which is this one and similarly this EF statement is part of this entire thing and so <sil=0.314> ,COMMA each of these is a single statement and therefore <sil=0.473> ,COMMA we do not need basis any where also note that while education when we assign the grade D <sil=0.371> ,COMMA we have said that the marks are less than 50 but we have not checked whether the marks are more than 40 or more or not <sil=0.948> .PERIOD This is because we will execute this statement only if this condition marks less than 40 is false that because this is in the L part of the EF statement whose condition is marks less than 40 this means that if we are executing this particular EF L statement then the marks are guarantees to be 40 or more and of course <sil=0.522> ,COMMA if we are executing any of these statements then we know that the marks are between 0 and 100 and similarly if we execute this EF statement that means that the marks must be 60 or more and so <sil=0.481> ,COMMA if they are less than 60 then we do the grade C and so on so forth <sil=0.977> .PERIOD So <sil=0.622> ,COMMA that this has become little cumbersome because the nesting level of the EFs has become little deep <sil=0.941> .PERIOD We have an EF statement within which we have a second one within which we have a third one within which we have a fourth one and within which we have a fifth one and correspondingly the indentation is becoming more and more <sil=0.952> .PERIOD Now <sil=0.567> ,COMMA this may make it both may the program both easier harder to write as well as harder to read <sil=0.923> .PERIOD It has the indentation has become quite clumsy <sil=0.936> .PERIOD However <sil=0.392> ,COMMA you will find that in lectures such kind of nested EFs statements are quite common and they are called actually EFs letters <sil=0.928> .PERIOD So <sil=0.453> ,COMMA for these EFs letters we prefer an alternate indentation style which is more readable but of course <sil=0.377> ,COMMA can be exactly the same thing <sil=0.915> .PERIOD Let us see that in the next slide <sil=0.903> .PERIOD So <sil=0.355> ,COMMA this is the preferred indentation style for EFs letters where essentially what has happened is that the EF condition the EF statement which is the part of the previous EF statement is written in the same line the condition is written in the same line as the keyword else at all levels <sil=0.948> .PERIOD So <sil=0.525> ,COMMA what has happened with this indentation style is that regardless of what is the nesting level of the EFs is the indentation remains only at one level and also this indentation style makes it very clear for the reader to understand that exactly one of these statements will get executed that is either this statement will execute or this statement will execute or this statement will execute and so on and so forth <sil=0.966> .PERIOD So <sil=0.603> ,COMMA let us now consider a common problem associated with EFs statement and let us call the dangling else problem let us consider the following program if n is greater than 0 then within that if n is equal to 0 <sil=0.640> ,COMMA print f n is 0 <sil=0.364> ,COMMA else print f and is negative <sil=0.944> .PERIOD So <sil=0.473> ,COMMA the question I want to ask is what will be the output of this program segment for initial values of n equal to 5 and for n equal to minus 5 <sil=0.900> .PERIOD Now <sil=0.612> ,COMMA the answer to that will depend upon whether this S is paired with this S or with this S <sil=0.949> .PERIOD So <sil=0.412> ,COMMA let us assume that it is the former that is this that this S is associated with this S as indeed this indentation style suggest because this S I have written at the same level as this S <sil=0.903> .PERIOD So <sil=0.539> ,COMMA the indentation style suggests that this S matches with this S <sil=0.996> .PERIOD So <sil=0.439> ,COMMA what happens is that is a K <sil=0.961> .PERIOD So <sil=0.582> ,COMMA suppose the value of n is 5 we check whether n is greater than 0 which it is <sil=0.977> .PERIOD So <sil=0.632> ,COMMA we execute this statement because the condition is evaluated to 2 to 2 <sil=0.910> .PERIOD So <sil=0.501> ,COMMA therefore <sil=0.548> ,COMMA we will execute the if part of the if element statement rather than the else part <sil=0.998> .PERIOD So <sil=0.314> ,COMMA this is the statement that we execute and this says if n is equal to 0 <sil=0.439> ,COMMA print f n is 0 now n is not equal to 0 <sil=0.936> .PERIOD So <sil=0.359> ,COMMA therefore <sil=0.327> ,COMMA this is not executed <sil=0.967> .PERIOD But suppose this S what to be associated with this inner if what could happen in that case <sil=0.923> .PERIOD Now <sil=0.538> ,COMMA suppose again that the value of n was 5 <sil=0.988> .PERIOD So <sil=0.395> ,COMMA when we execute when we evaluate this condition that of course <sil=0.489> ,COMMA values to prove <sil=0.950> .PERIOD So <sil=0.455> ,COMMA we have to now execute the statement in the if part which is now this entire if L statement <sil=0.959> .PERIOD So <sil=0.430> ,COMMA now if n is 5 n equal to 0 value is to fall and therefore <sil=0.432> ,COMMA the L part is print is executed which print n is negative that is for n equal to 5 what the program print is n is negative which is of course <sil=0.373> ,COMMA probably not what we wanted <sil=0.955> .PERIOD And similarly <sil=0.336> ,COMMA we will see that for n is equal to minus 5 if this L is associated with this if then the result is not what we expect because if n is minus 5 then we first execute this n is greater than 0 <sil=0.937> .PERIOD It is not and there is no L for this if so <sil=0.410> ,COMMA nothing happens <sil=0.972> .PERIOD Whereas <sil=0.574> ,COMMA if this L is x is associated then what happens is that if n is equal to 0 if n equal to if n greater than 0 value is to fall and since there is no L part transfer to that question will depend upon whether this L is considered by the compiler to be paired with this S or with this S <sil=0.991> .PERIOD Let us consider first n is equal to 5 and let us assume that this S is paired with this S <sil=0.988> .PERIOD So <sil=0.638> ,COMMA if that happens what happens <sil=0.957> ?QUESTIONMARK If the condition n greater than 0 is evaluated which of course <sil=0.563> ,COMMA evaluates to true and then this statement gets executed and since n is equal to n is not equal to 0 nothing is printed <sil=0.997> .PERIOD But suppose on the other hand if this if happen to be associated with this then for the same value of n the result will be different <sil=0.971> .PERIOD So <sil=0.313> ,COMMA again the condition n greater than 0 will be evaluated which evaluates to true again and now since that in the case this entire if L statement which is within the if part will be executed <sil=0.911> .PERIOD Now <sil=0.618> ,COMMA this condition again evaluates to fall because n is not equal to 0 and what is what execute is this statement which brings on the that n is negative for n is equal to 5 and similarly for n is equal to minus 5 you will find if you trace a program that if this L is associated with the outer if then the output is n is negative whereas <sil=0.541> ,COMMA if this L is paired with the inner if then there is no output at all <sil=0.964> .PERIOD So <sil=0.367> ,COMMA there is an ambiguity here because it is not clear whether this L is associated with the outer if or with the inner if as a example the C language defines that when such an ambiguity occurs or such dangling else is here in the program that is then it is always assumed to be paired with the inner most eligible if <sil=0.961> .PERIOD So <sil=0.492> ,COMMA in the example that is a soft regardless of how we invented this particular else will be assumed to be paired with the inner most if which is this one <sil=0.906> .PERIOD So <sil=0.549> ,COMMA which means that this program is probably not doing what we wanted to do because for great for positive values of n it actually prints n is negative and for negative values of n it just does not print a meeting <sil=0.987> .PERIOD So <sil=0.381> ,COMMA if this is not what we want as in this example what we can do is we should that we can use braces to tell the compiler what the correct pairing is <sil=0.994> .PERIOD So <sil=0.624> ,COMMA if this is the pairing we want that this L should be paired with the outer if and what we have done is that this is statement which does not have corresponding else we have enclosed in braces <sil=0.990> .PERIOD And now the there is no longer that ambiguity of a dangling else because this L cannot possibly be associated with this F because this statement is entirely within this type of braces whereas <sil=0.487> ,COMMA this else is outside the braces <sil=0.974> .PERIOD So <sil=0.624> ,COMMA not the program behaves as we accept it to behave <sil=0.939> .PERIOD Okay we will not talk about the next important condition statement which is the switch statement and in many cases it allows us to write programs very elegantly we can of course do whatever the switch statement can do with if else and if else later as always but in many cases the switch statement makes a program much more elegant and similar to it <sil=0.984> .PERIOD Essentially when we have an expression and for different values of the expression that are known in advance we want to perform different actions that is where the switch statement is useful <sil=0.983> .PERIOD So <sil=0.359> ,COMMA this is what the syntax for the switch statement is you have keyword switch followed by an expression in bracket followed by within curly braces the curly braces here are essential you have multiple cases <sil=0.998> .PERIOD So <sil=0.556> ,COMMA case value 1 <sil=0.338> ,COMMA case value 2 <sil=0.487> ,COMMA case value n and could be anything and then a default and for each case you could have a block <sil=0.900> .PERIOD Now this block is a sequence of statements need not be a single statement and essential idea is what this statement captures is that if the values expression turns out to be equal to that of the if the values expression turns out to be equal to value 1 then we want the set of statements block 1 to be executed if it is equal to value 2 then we want the set of statements block 2 to be executed and so on and if the value this question does not match either of these n values then we want this default block to be executed <sil=0.912> .PERIOD But there are some there are some faculties in this description that I just mentioned and we will look at them in a minute <sil=0.957> .PERIOD But before that at the syntactic level this expression must be of an integer type and these values must be constant expressions <sil=0.952> .PERIOD So <sil=0.333> ,COMMA these cannot be for example things like x plus y where x or y or both are variables this has to be a value which can be evaluated at compile time and as I said each block need not be a single statement it can unlike the ifs and if statements it can be a sequence of statements and even if there are multiple statements in any block there are no braces needed around the block <sil=0.944> .PERIOD So <sil=0.481> ,COMMA let us see exactly what this statement does <sil=0.913> .PERIOD First the expression that we gave is going to be evaluated and then it is going to be compared to value 1 remember of course <sil=0.411> ,COMMA at the expression evaluation itself may result in some side effects which will of course <sil=0.421> ,COMMA say immediate effect <sil=0.972> .PERIOD So <sil=0.353> ,COMMA first the result is compared to value 1 if it is true if it is indeed equal to value 1 then the set of statements in block 1 block 2 up to block n and followed with the statements in the default block they will all be executed in that sequence <sil=0.943> .PERIOD Now that seems little unusual for that has its uses and we will look at them <sil=0.963> .PERIOD If the value of the expression is not equal to value 1 then the result is compared to value 2 and if the result is equal to value 2 then block 2 block 3 etcetera are executed again up to block n and including then finally <sil=0.450> ,COMMA the default block and solve this procedure if the result is not equal to value 2 either then it will be compared with value 3 and so on and finally <sil=0.562> ,COMMA if the result matches none of the values value 1 to value n then the default block alone will get executed <sil=0.985> .PERIOD So <sil=0.330> ,COMMA essentially that means that if the value of the expression is equal to value 1 then block 1 block 2 up to block n and then the default block get executed if it is equal to value 2 then block 2 block 3 to block n and the default block is executed if value is equal to value n then block n and the default block are executed and if the value of the expression is not equal to any of these and only the default block is executed <sil=0.987> .PERIOD But of course <sil=0.517> ,COMMA usually in fact this one one is that we want usually only block i to be executed if the value of the expression matches value i <sil=0.920> .PERIOD So <sil=0.648> ,COMMA if you want that to happen then we need to put a break statement at the end of block i <sil=0.922> .PERIOD So <sil=0.491> ,COMMA in whenever a break statement is encountered in any block within the fish then the execution stops right there <sil=0.942> .PERIOD Let us now see an example of the use of a fit statement and we will take the same example as before that of assigning grades depending on the mass <sil=0.978> .PERIOD Let us assume that we have already checked that the mass are within 0 to 0 to 100 and we want to assign the grade and we do not do it using a fit statement instead of nested essences <sil=0.984> .PERIOD Note that we cannot really give Boolean expressions here we can only give a fixed constant value for each case <sil=0.949> .PERIOD Now <sil=0.514> ,COMMA you want to do that and use the fit statement for the grading problem then one possibility is that we could have a case for every possible mass between 0 and 100 that is a case for case for mass equal to 0 case for mass equal to 1 case for mass equal to 2 and so on up to case for mass equal to 100 and that of course will make the program extremely unwieldy <sil=0.990> .PERIOD But fortunately in this example you will recall that the grades are the grade changes at multiples of 10 <sil=0.909> .PERIOD So <sil=0.431> ,COMMA the transition from the D grade to C grade happens at mass when the mass become more than 50 or 50 <sil=0.984> .PERIOD So <sil=0.403> ,COMMA we can exploit that <sil=0.979> .PERIOD So <sil=0.509> ,COMMA if we divide the mass by 10 and then look at the various cases if we divide the mass by 10 then the resulting value can only be between 10 and 0 <sil=0.979> .PERIOD So <sil=0.485> ,COMMA we can exploit that fact to reduce the number of cases <sil=0.934> .PERIOD Now <sil=0.394> ,COMMA if we recall that is the mass are 80 or more then we want to assign the A grade <sil=0.970> .PERIOD So <sil=0.586> ,COMMA the mass are 80 or more in the mass divided by 10 remember that mass is an integer variable and therefore <sil=0.611> ,COMMA mass per 10 gives us only the quotient <sil=0.952> .PERIOD So <sil=0.511> ,COMMA if for example <sil=0.397> ,COMMA the mass happen to be 87 then mass per 10 will be 8 and it will not be 8 <sil=0.963> .PERIOD 7 <sil=0.933> .PERIOD So <sil=0.569> ,COMMA in these three cases no one will assign the grade A because in these three cases the mass are at least 80 and up to 100 <sil=0.982> .PERIOD So <sil=0.610> ,COMMA in this case 10 what we have done is we have not put any statement in the corresponding block <sil=0.952> .PERIOD Similarly <sil=0.609> ,COMMA in case 9 we have not put any statement in the corresponding block and in case 8 we assign the variable grade to A and then the break statement <sil=0.913> .PERIOD So <sil=0.310> ,COMMA what that means is that suppose the value of mass happen to be let us say 95 <sil=0.951> .PERIOD So <sil=0.344> ,COMMA mass per 10 will evaluate to 9 which does not match 10 but it matches 9 <sil=0.926> .PERIOD So <sil=0.465> ,COMMA the statements in the block corresponding to case 9 will execute it there is no statement over here and remember that there is no break statement over here either <sil=0.959> .PERIOD So <sil=0.434> ,COMMA which means that control falls through as it is called to the next case without really worrying about whether the value in the next case is equal to the value of expression or not <sil=0.918> .PERIOD So <sil=0.478> ,COMMA even if the value of mass per 10 is 9 this block corresponding to case 8 still gets executed because in the block for case 9 there is no break statement <sil=0.945> .PERIOD So <sil=0.437> ,COMMA which means that the value of grade becomes A and then there is a break statement which means that immediately after sending the value of grade to A the execution of the fifth statement finishes and the control comes to the next statement following the switch which prints the value of the grade and similarly if the mass score exactly 100 the candidate got a perfect score then the statements in the block corresponding to case 10 would be executed there are no statements here <sil=0.916> .PERIOD So <sil=0.616> ,COMMA nothing happen and there is no break statement <sil=0.906> .PERIOD So <sil=0.550> ,COMMA the control falls through automatically to the next case which is case 9 again there are no statements to be executed here <sil=0.979> .PERIOD So <sil=0.548> ,COMMA nothing happen and there is no break statement which means that the control falls through again to the next case <sil=0.946> .PERIOD So <sil=0.637> ,COMMA grade is assigned A and then if break happens which means switch statement finishes executing and similarly if the value of mass by 10 is 7 or 6 then we assign the grade B which means that from arc from 60 to 79 the grade B will be assigned if the value by 10 is 5 which means that mass are between 50 and 59 when the grade is C if the mass are between 40 and 40 when the grade is C and we do not have to have separate cases for 0 to 3 they can all be covered with the default case because if the value of mass by 10 is not 4 5 6 7 8 9 or 10 then it has to be 0 1 2 or 3 because as we said we are assuming that we already checked that the value of mass is at least 0 is at least 0 and at most 100 <sil=0.904> .PERIOD So <sil=0.408> ,COMMA in the different case which means that the value of mass by 10 is anything other than 4 to 10 which in this case will mean that it has to be between 0 and 3 the grade is F and this break statement in the last block is not really required because there is no next block after this regardless of whether there is a break or not it is no difference will be there in the execution <sil=0.970> .PERIOD But as a good programming it is a good idea to put a break statement even at the end of the last block because if later one adds some blocks then we might forget to add the break at that point in time <sil=0.923> .PERIOD So <sil=0.637> ,COMMA finally this is the end of the 6 statement and this 6 statement will hurt in assigning the grade A to F to the variable grade and this in the statement simply tends to fade <sil=0.995> .PERIOD So <sil=0.498> ,COMMA since the end of this lecture in the next lecture we will look at in more detail the statement the control statement 6 can be used to implement loops we have already seen the while loop in the programs that we have written we will see more kind of loop statement and certain other statements it can alter the behavior of control flow within a loop and so on so forth <sil=0.906> .PERIOD In the previous lecture we had familiarized our lecture and we have also tried these things of the lecture and are now comfortable using the Linux environment <sil=0.919> .PERIOD In this lecture we will look at the basic components of the computer and try to understand how it works <sil=0.934> .PERIOD At a very low level the computer consists of very large number of complex electronics circuits <sil=0.607> ,COMMA but we are interested in this lecture in a more abstract high level view of the computer <sil=0.957> .PERIOD So let us look at what the main components of the computer at this high level are <sil=0.949> .PERIOD The first component is the system bus which connects all the other major components of the computer <sil=0.939> .PERIOD You can think of this bus as the nervous system of the computer which transmits signals from one place to the other <sil=0.948> .PERIOD The two most important components are the CPU and the memory <sil=0.983> .PERIOD The CPU stands for central processing unit and it is this circuit which executes and understands all programs at the computer executes <sil=0.956> .PERIOD The memory shows all data that is needed to run this program <sil=0.973> .PERIOD We will look at some details of the memory and the CPU shortly <sil=0.943> .PERIOD Apart from the CPU and memory the computer also has a number of input output devices some of which we have already come across in the previous lecture <sil=0.944> .PERIOD For example <sil=0.627> ,COMMA we are already familiar with the keyboard <sil=0.464> ,COMMA the mouse and the monitor <sil=0.930> .PERIOD There are two more IOD devices namely the hard disk and the feedback drive <sil=0.938> .PERIOD Both of these are mass storage media that is they can store large volumes of data for a long time <sil=0.994> .PERIOD These are in contrast with memory <sil=0.962> .PERIOD The memory is much smaller in size as compared to the hard disk and feedback drive but is much quicker to access for the central processing unit <sil=0.982> .PERIOD Also an important difference between memory and hard disk and feedback drive is that the data in memory is volatile <sil=0.995> .PERIOD What this means is that if the power is switched off the data is raised <sil=0.921> .PERIOD Whereas the data stored on the hard disk and the feedback drive remains even if the power to the computer is switched off <sil=0.946> .PERIOD So all the files and directories that we had talked about in the last lecture are actually stored on the hard disk and the feedback drive <sil=0.990> .PERIOD Let us first discuss the memory in some detail <sil=0.915> .PERIOD Memory is essentially a correct collection of large number of memory cells and each cell can store what is known as a bit <sil=0.965> .PERIOD Bit is a binary digit which means that its value is either 0 or 1 and the memory of the computer is nothing but a collection of a large number of memory cells each of which can store just one bit that is either 0 or 1 <sil=0.979> .PERIOD And the reason for this storing bit is that the current electronic technology is on the survey and transistors can be in two states either on or off and the two states essentially represent the numbers 0 or 1 <sil=0.907> .PERIOD For efficiency data is usually accessed from the memory in terms of why that is group of 8 bits which is known as a byte is accessed at one time <sil=0.927> .PERIOD Data may also be accessed from memory in larger units for example 2 bytes or 4 bytes or on some computer C1 each byte <sil=0.967> .PERIOD Now you can see that the memory consists of a large number of bytes <sil=0.991> .PERIOD So for example <sil=0.353> ,COMMA you might have heard the term that a computer has 256 megabytes of memory <sil=0.929> .PERIOD What that means is that in this computer the number of bytes in the memory is 256 into 2 to the power 20 roughly speaking this is 256 million bytes <sil=0.936> .PERIOD So when the C2 needs to access the particular byte of data from the memory it has to specify to the memory circuit somehow which byte out of these 256 million bytes it wants to access and for this reason every byte has a distinct address <sil=0.942> .PERIOD So the addresses of these bytes will start from 0 <sil=0.483> ,COMMA 1 <sil=0.478> ,COMMA 2 and go up to 256 million or so <sil=0.980> .PERIOD It is important to note that both programs as well as the data for these programs is stored in memory <sil=0.974> .PERIOD So as you can see that since at the lowest level we can only store 0s and 1s in memory it is necessary that all the kinds of data that we are interested in dealing with are represented as sequences of less 0s and 1 <sil=0.951> .PERIOD So we need encoding for all kinds of data such as integers <sil=0.576> ,COMMA real numbers <sil=0.383> ,COMMA characters and so on so forth <sil=0.990> .PERIOD So in this lecture we will only look at the coding use for integers and we will not write not talk about when coding use for real numbers and text characters and so on <sil=0.952> .PERIOD We will talk about them in subsequent lecture <sil=0.906> .PERIOD So let us look at how integers are represented inside a computer <sil=0.987> .PERIOD So we are dealing only with non-negative integers as you know any integers can be converted to its binary representation that is the base 2 representation which then becomes just a sequence of 0s and 1 for example <sil=0.934> .PERIOD 113 that is the decimal number 113 when represented in binary is 111 0 0 0 1 and you can verify this because as you can see this binary number in decimal is equivalent to 1 into 2 to the power 6 plus 1 into 2 to the power 5 etcetera up to 1 into 2 to the power 0 <sil=0.996> .PERIOD This is because the binary system is a positional system and this entire expression evaluates to the number 113 <sil=0.975> .PERIOD But what if we want to represent both positive as well as negative numbers <sil=0.965> ?QUESTIONMARK One possible way is that out of the number of bits available to us we use one of the bits to store or represent the sign of the number that is plus or minus <sil=1.000> .PERIOD So for example we can have the convention that if left most bits is 1 that denotes a negative number and if it is 0 then it denotes a positive number and the rest of the bits gives the magnitude of the number <sil=0.998> .PERIOD Given this information you can observe some facts if you are using 8 bits to represent an integer and let us say we are presenting only non-negative integers then the largest integers that we can store would be 255 <sil=0.939> .PERIOD Why is that <sil=0.879> ?QUESTIONMARK Because the largest binary number in 8 bits that we can have is 111 178 times and which in decimal is equal to 255 and if we are storing both positive and negative numbers then we have to use one bit for the sign which means we have only 7 bits for the magnitude and in this case the maximum positive number that we will be able to store will be 127 which is 247 minus 1 and as you can see that if you just use one byte for storing an integer we cannot store a very large range of integers and therefore usually a number of bytes are actually used to store single integer <sil=0.931> .PERIOD Typically most computers would use a group of consecutive four bytes in memory to store an integer so four bytes means 32 bits because each byte is 8 bits which means that is we are storing both positive and negative numbers 31 bits are used for the magnitude and which means in turn that the largest positive number that we can store is 2 to the power 31 minus 1 <sil=0.920> .PERIOD Okay let us now come to the CPU <sil=0.962> .PERIOD The CPU as I said is the brain of the computer it is the component that understands and executes our program <sil=0.913> .PERIOD However CPU can understand and executes only very simple instructions of the time add a1 comma a2 comma a3 in this example what this instruction represents is the instruction to the computer to add the contents of the memory location whose addresses are a1 and a2 respectively add these two values and store the in the third memory location whose address is a3 <sil=0.903> .PERIOD So instructions of this kind constitute the machine language of the CPU and the CPU can only understand and execute programs which are written in this machine language <sil=0.926> .PERIOD So as you can imagine writing even reasonably complicated programs in such a language is an extremely cumbersome task <sil=0.965> .PERIOD For example try to imagine what a program for computing the factorial in machine language would look like <sil=0.996> .PERIOD We would have to worry about what addresses to assign to various variables and we would not be able to use high level instructions such as loops and assignments and so on so forth and therefore we require some tools to that the cast of programming is somewhat easier and that is the role of what are known as high level programming languages <sil=0.988> .PERIOD High level programming languages make programming easier because they offer higher level or more abstract programming constructs such as variables <sil=0.922> .PERIOD We have already seen what these variables are <sil=0.919> .PERIOD There are other high level abstract constructs that programming languages offer that we will see throughout this course <sil=0.910> .PERIOD There are large number of high level programming languages which have been in use over a number of years for example C <sil=0.510> ,COMMA 4th ran <sil=0.434> ,COMMA Java and so on so forth <sil=0.923> .PERIOD In this particular course we will learn the programming language C but please know that the focus of this course is on learning the concepts of programming <sil=0.937> .PERIOD The choice of programming language is only a vehicle to actually implement those concepts in practice <sil=0.996> .PERIOD So even though we are learning C in this course you might actually be required to write programs later on in your professional career in other programming languages possibly 4th ran or Java but having learned the concepts of programming you will find that it will not be a very difficult task to migrate from C to some other programming language <sil=0.997> .PERIOD Now the problem is that program programming is high level programming languages cannot be directly understood by the machine and therefore we need some tools using which we can actually run this program and that is where tools called compilers come in <sil=0.908> .PERIOD So a compiler essentially translates a program in a high level language such as C to an equivalent machine language program for a particular kind of CPU <sil=0.955> .PERIOD So a compiler as you can see is specific to both the high level language that it translates from and to the kind of CPU whose machine language it translates the program to <sil=0.912> .PERIOD So this program called a compiler automatically performs the translation from a high level language to the machine language of the computer <sil=0.928> .PERIOD So therefore when we write a program we will write it in a high level language in this course we will write all our programs in C then we will compile it using compiler for this language <sil=0.976> .PERIOD So in this course we will use the C compiler and then we will execute the generated machine language program the compiler will automatically translate our C program into the machine language program for our computer and this machine language program that will be able to execute directly on the computer and it will have the same effect as what we intended in our C program <sil=0.925> .PERIOD So let us now see what the factorial program written in C looks like <sil=0.949> .PERIOD So I have already written this program and let us add it this file tag <sil=0.996> .PERIOD c which contains the C program for computing factorial and this is what it looks like in this lecture we will not go into the details of the C syntax but you can still note that this program in C looks very similar to the algorithm that we have written informally <sil=0.997> .PERIOD So here we are saying that while n is greater than 1 we have to repeat these two statements <sil=0.988> .PERIOD Note that the assignment operation in C is denoted by an equal sign <sil=0.993> .PERIOD So this particular statement result is equal to result star n should actually be read as result assigned results star n like the equal symbol here denotes not equality but assignment <sil=0.995> .PERIOD So therefore saying that result is equal to result star n does not mean that n is necessarily 1 and similarly in the in the next line we are not stating or claiming that n is equal to n minus 1 which is of course third we are saying that the new value of n becomes sole value of n minus 1 <sil=0.945> .PERIOD Here we are initializing result to 1 here we are reading the value of n we will see the details of all these statements later on in the course and here we are finally printing the value of the result <sil=0.943> .PERIOD So let us now actually compile this program and try to run it <sil=0.991> .PERIOD To compile this program we need to use the C compiler and the command for the C compiler is cc cc <sil=0.980> .PERIOD So the arguments that I have given to the Cc command are first of all minus O minus O says that the equivalent machine language program which is generated for the C program should go in the file which is named after minus O <sil=0.980> .PERIOD So what this is saying is that the generated machine language program for completed factorial should be stored in a file called track and track <sil=0.985> .PERIOD c is the name of the file which contains a C program for computing the factorial <sil=0.924> .PERIOD It is a convention that the names of all files containing C program and then dot C <sil=0.970> .PERIOD So let us just execute this command by fitting the return key <sil=0.916> .PERIOD We do not get any error messages which means that the compiler accepted our program and now you can check that a file called track has been generated and this file actually contains the machine language program which is equal to the C program that we wrote for completing factorial <sil=0.933> .PERIOD Let us now execute this program <sil=0.975> .PERIOD Since this is in the current directory the relative path to this file is dot slash track and to execute this program I just need to give the command dot slash track and when I hit enter actually nothing happens and this is so because the program is waiting for us to type a number whose factorial is to be computed <sil=0.948> .PERIOD So let us enter some numbers let us say file hit the enter or the return key and the result which is 120 is printed <sil=0.973> .PERIOD Let us write with some more number <sil=0.949> .PERIOD So this is the factorial of 14 <sil=0.908> .PERIOD Let us try to compute the factorial of 20 and you see that the output is a negative number <sil=0.932> .PERIOD This is obviously wrong and this has happened because the factorial of 20 is too large to be stored in an integer <sil=0.910> .PERIOD In this machine the representation of an integer uses 4 bytes that means 32 bits and since both positive and negative integers are represented that means the largest positive number that we can represent in this rotation is 2 to the power 31 minus 1 and the factorial of 20 actually happens to be much larger than this number that is 2 to the power 31 minus 1 and therefore we are getting some concentric results <sil=0.957> .PERIOD In this lecture we have looked at the basic components of the computer and how they interact with each other <sil=0.913> .PERIOD We also saw the notions of machine language <sil=0.486> ,COMMA high and high level languages and the role of compiler and finally we saw our first C program and we saw how to compile and execute this program <sil=0.911> .PERIOD From the next lecture onwards we will start looking at the C language in more detail and start developing programs which are somewhat more complex than the simple P program that we have seen so far <sil=0.945> .PERIOD Today <sil=0.513> ,COMMA we will discuss a very important concept in programming and that is the concept of breaking up a large problem into smaller sub problems and then be able to write independent small program fragments for solving these problems and then be being later as able to assemble them to form the solution to the overall problem <sil=0.999> .PERIOD In C <sil=0.469> ,COMMA this is achieved by using what known as functions <sil=0.987> .PERIOD We have already used various library functions in our programs that we have written so far <sil=0.929> .PERIOD Today <sil=0.320> ,COMMA we will see how we can write and define our own functions which can be used for simplifying the problem by breaking it up into small problems and so on <sil=0.971> .PERIOD So the problem is that in contrast to a small program that we have been writing so far <sil=0.524> ,COMMA when one is developing very large programs <sil=0.496> ,COMMA then we need to make the task of programming much more manageable <sil=0.954> .PERIOD Many large programs are needed because many real life problems are very complex and obviously they require complex solutions <sil=0.913> .PERIOD But the capabilities of the human mind are limited so the human mind cannot really focus on all the details of a very complex problem all at the same time and therefore to ease the process of programming or developing a program what one needs to do is to divide up the problem into smaller parts and then try to solve the smaller problems individually and then later on assemble the solution to the overall problem from the solutions of these individual smaller problems <sil=0.901> .PERIOD Of course <sil=0.543> ,COMMA it may turn out that even the smaller sub problems that we identify are still very complex <sil=0.931> .PERIOD In that case <sil=0.643> ,COMMA we need to further break them up into smaller sub problems yet and then try to solve them at that level and this process has to continue till the problems that we have reached are sufficiently simple that we can focus on solving one problem at a time <sil=0.930> .PERIOD So <sil=0.416> ,COMMA this entire process in C is accomplished using what are known as function and essentially functions allow us to do the kind of breaking up of problems into smaller problems and then assembling the overall solution from the solutions to the smaller problems in the way that we have been talking about using functions we can focus on solving a sub problem without really worrying too much about how the solution to the problem will be used in the solution to the overall problem and when we are solving or assembling the solutions to the sub problems to form the solution to the entire problem <sil=0.530> ,COMMA we should not have to worry about how the individual sub problems were actually solved <sil=0.992> .PERIOD So <sil=0.606> ,COMMA both these kind of abstraction the functions allow us to perform <sil=0.939> .PERIOD So <sil=0.588> ,COMMA there are two using using this idea of breaking up and breaking up the problem into smaller problems and so on there are two major ways in which one can design solutions or programs for a given problem and these are fairly intuitive in their nature <sil=0.917> .PERIOD So <sil=0.388> ,COMMA let us look at one of them first that is the bottom up design approach <sil=0.953> .PERIOD So <sil=0.471> ,COMMA here essentially what you do is that given a problem we identified the sub problems <sil=0.939> .PERIOD So <sil=0.313> ,COMMA let us say we have identified these two sub problems and then I will say these sub problems may themselves be still quite complex <sil=0.950> .PERIOD So <sil=0.602> ,COMMA we do this breaking up still further <sil=0.902> .PERIOD So <sil=0.480> ,COMMA maybe we have divided both these sub problems into two sub sub problems each and now supposing that the smallest problems that we have identified are small enough or simple enough that we can solve each of it in its entirety <sil=0.915> .PERIOD You can think about each of these sub problems in its entirety then we start up solving these problems bottom up <sil=0.946> .PERIOD So <sil=0.363> ,COMMA we might solve this problem first and then this problem and then using the solution to these sub problems we might assemble the solution so to speak of the larger problem and similarly then we will solve this problem and this problem and then assemble the solution to this problem and having finally solve these two sub problems we assemble the solution to the overall problem <sil=0.919> .PERIOD So <sil=0.599> ,COMMA the solution the problems are solved in the upward direction while the identification is in the downward direction <sil=0.998> .PERIOD In contrast to that one can think about a top down approach where the procedure is slightly different <sil=0.964> .PERIOD So <sil=0.647> ,COMMA again from the overall problem we identify sub problems and not just identify the sub problems assume at a certain level that the sub problems have already been solved and then assuming the solution to the sub problem exists try to solve the overall problem first <sil=0.941> .PERIOD So <sil=0.417> ,COMMA here let us say we identify two sub problems and without having solved these problems at this level we assume that the sub problems have already been solved and design a solution to this problem assuming a solution for these smaller sub problems and then of course in the next step we need to solve both of these sub problems <sil=0.935> .PERIOD So <sil=0.323> ,COMMA if they are still complex enough we again break them up into smaller parts and now this sub problem would be solved assuming that these two smaller sub problems have already been solved and so on so forth <sil=0.971> .PERIOD So <sil=0.403> ,COMMA that is the top down approach <sil=0.921> .PERIOD Let us not take a somewhat more complex program than the ones we have been looking at so far to illustrate the ideas that we have been talking about <sil=0.979> .PERIOD So <sil=0.465> ,COMMA we will use the top down approach to solve this particular problem which is actually still not very very complex <sil=0.514> ,COMMA but it will have to illustrate the points that we are trying to make <sil=0.985> .PERIOD So <sil=0.328> ,COMMA in this problem we are supposed to write a program that given an input in P j n which is greater than 1 greater than or equal to 1 the program is supposed to print all numbers i which are less than equal to n such that i is equal to the sum of the factorials of its digits <sil=0.980> .PERIOD So <sil=0.487> ,COMMA let us now take a simple example problem to illustrate the design approaches that we have been talking about will use the top down design approach in the solution to this problem <sil=0.956> .PERIOD This problem is still not very complex <sil=0.370> ,COMMA but it does have to illustrate the points that we have been trying to make and it will also illustrate how we can define functions in our program and use them and so on so forth <sil=0.976> .PERIOD So <sil=0.487> ,COMMA the problem is very simple we are supposed to write a program which takes an input in P j n as the input and is supposed to be more than equal to 1 and the program is required to print all integers i which are less than or equal to n such that i is equal to the sum of the factorial of its digits <sil=0.950> .PERIOD So <sil=0.549> ,COMMA for example <sil=0.342> ,COMMA 145 is equal to 1 factorial plus 4 factorial plus 5 factorial you can easily verify that 5 factorial is 120 <sil=0.563> ,COMMA 4 factorial is 24 and 1 factorial of course is 1 <sil=0.957> .PERIOD So <sil=0.398> ,COMMA 1 factorial plus 4 factorial plus 5 factorial is equal to 145 <sil=0.949> .PERIOD So <sil=0.528> ,COMMA the program is supposed to print all such numbers less than equal to n and n is taken as an input <sil=0.986> .PERIOD So <sil=0.369> ,COMMA let us use a top known approach to solve this problem and to do that we need to first break up the problem and identify smaller or simpler sub problem <sil=0.942> .PERIOD So <sil=0.384> ,COMMA the sub problem of this problem that we can immediately identify is given an integer i find the sum of factorial of its digits <sil=0.903> .PERIOD Now <sil=0.397> ,COMMA in the top known approach instead of going and solving this sub problem first let us assume that the solution to this problem is already available to us <sil=0.989> .PERIOD So <sil=0.505> ,COMMA let us assume that a library function digit fact sum is already available which given an integer i returns the sum of the factorial of the digits of i <sil=0.993> .PERIOD Of course <sil=0.547> ,COMMA as we know there is no such library function will have to write that ourselves and that will constitute the solution of the sub problem that we have identified <sil=0.970> .PERIOD But at this stage we assume that this solution is available to us in the words there is already one such function that is available to us and all we have to do is to use this function in finding the solution to the overall problem <sil=0.915> .PERIOD And you can see that given this useful function the overall problem is quite easy to solve and here is the main what the main program might look like <sil=0.920> .PERIOD We have declared three variables n i and r and will be the input integer that will read and i will be used to run a loop from 1 to n to check which number satisfy the given properties <sil=0.963> .PERIOD The variable r will use to hold the return value of scan F which we discussed last time <sil=0.902> .PERIOD If you recall we said that scan F actually returns the number of items successfully assigned <sil=0.947> .PERIOD So <sil=0.342> ,COMMA we will use and we should use this return value to check that whatever kind of input we were actually expecting the user did actually give that kind of input <sil=0.907> .PERIOD And so here is a familiar do while loop to read an input integer n and we want to make sure that the input integer n is at least 1 <sil=0.931> .PERIOD So <sil=0.452> ,COMMA as long as n is less than equal to 0 we give the prompt to the user and then read the value of n and r is the return value of scan F <sil=0.965> .PERIOD So <sil=0.522> ,COMMA note that the value of r will be other than 1 if the input was not proper that is something other than digits and the plus minus sign etcetera was entered <sil=0.982> .PERIOD So <sil=0.648> ,COMMA if r is not 1 that means the user did not give a proper input and therefore <sil=0.363> ,COMMA we should ask him to give the input again <sil=0.907> .PERIOD So <sil=0.428> ,COMMA therefore <sil=0.598> ,COMMA this while loop is running as long as r is not equal to 1 which implies that improper input was given by the user or n is less than equal to 0 which means that some integer was entered but it was less than equal to 0 whereas <sil=0.433> ,COMMA we want a positive integer which is at least 1 and so therefore <sil=0.472> ,COMMA the user is prompt it again <sil=0.922> .PERIOD But that is the simpler part this is the main part of the program all we need to do is to run a loop from i equal to 1 to i equal to n and for each i if the sum of the factorial of the digits of i is equal to i then we print that i <sil=0.950> .PERIOD Note that we are assuming that this function digit fact sum i is already available to us and we are simply using that function without worrying about how the sum of the factorial of the digits of this number i is being computed <sil=0.901> .PERIOD Note also that the call to this function is exactly the same as we have been calling the library functions so far just have to give the name of the function and within bracket we have to give the argument for this function <sil=0.967> .PERIOD So that is not the end of the program development because the function digit fact sum is not there in the library so we have to write that ourselves and that is the next step in the development of the program <sil=0.997> .PERIOD So how do we solve the problem of finding the fact sum of the factorial of the digits of the given number well you can immediately see that it has a simpler sub problem and that is the finding out the factorial of a given number i <sil=0.961> .PERIOD So suppose we have the solution to this problem again in the form of a function which given and i find i factorial so let us assume a factorial i function exists which for a given value of i returns i factorial and given this function finding out the sum of the factorial of the digits is quite straightforward <sil=0.944> .PERIOD So this is what the code for that doing that might look like <sil=0.927> .PERIOD So let us initialize a variable sum to 0 which is going to hold the sum of the factorial of the digits of the number and let us assume that n is the number for which we have to compute the sum of the factorial <sil=0.984> .PERIOD So what we are doing here is that as long as the number is greater than 0 we find the least significant digit of n and that is easily obtained by taking the remainder after dividing n by n by 10 that is given by the expression n percent n <sil=0.932> .PERIOD So this n percent n represents the last digit or the least significant digit of the number n and so we take the factorial of that note that we are assuming that the factorial function already exists and whatever is the answer we add that to sum and after that we divide n by 10 and remember this is integer division because n is an integer and n is also an integer <sil=0.973> .PERIOD So what this will do is that n will become the same number as previously except that the last digit will get removed <sil=0.966> .PERIOD So for example if n was 527 then in the first iteration n percent n would be 7 and we will add 7 factorial to sum and then sum and then n will become n by 10 which is 52 <sil=0.985> .PERIOD So in the next iteration 2 factorial will be computed and added to sum and n will become 5 <sil=0.943> .PERIOD In the next iteration 5 factorial we add it to sum and n will become 5 by 0 which is equal to 5 which is equal to 0 <sil=0.915> .PERIOD So and when that happens this loop will terminate because it will run as long as and if greater than 0 and n has become 0 as a matter of fact <sil=0.918> .PERIOD So the writing the code is simple enough and it requires only the knowledge of principles that we have already seen but now what we need to do next is to wrap this code up and make it into a function <sil=0.985> .PERIOD So to do that we need to add some more stuff to this already existing code <sil=0.978> .PERIOD So this particular thing says that this is a function that we are defining this is the function header as it is called and this has three components <sil=0.920> .PERIOD The first component is the name of the function which is digit fact sum the second component is the type of the return value that is what kind of value does this function resultant and in this case that is an integer and so the return type is an int and the last part is what is the name of the parameter and its type <sil=0.972> .PERIOD So this function takes one parameter which is being called n and its type is int and the entire code for the function is enclosed in braces and of course this place has to close somewhere so we will do that next but after the sum has been computed we need to somehow say that this sum that we have computed is in fact the result of evaluating this function or in the words this is the return value of this function <sil=0.969> .PERIOD So for doing that we need to add a return statement this is a return statement and this has two functions first is that the expression that is given along with the return statement in this case which is simply the variable sum the value of this expression is the return value or the result of a evaluating this function <sil=0.931> .PERIOD So in this case we have computed the result in the variable sum and so we are saying that the result to be returned to the caller whoever has whichever function has called this function the result that this function will get will be the value of the variable sum that is what we are saying here and the other thing that return statement does is that whenever the return statement is executed the function immediately terminates the execution of this function immediately terminates and control goes to wherever the function was called form well look at that in more detail with the help of some examples in the later slide and finally this variable sum which we have declared within the definition of this function is called a local variable of the function that we just defined which is the digit fact sum <sil=0.980> .PERIOD Okay so having written the digit fact some function we need to now write the factorial function this is a fairly simple function that we already know about and using what we have learnt now this is what the definition of the factorial function will look like this code is very familiar to you from the competition of the factorial which we have been taking as an example in numerous programs <sil=0.901> .PERIOD So this loop essentially multiplies numbers from 2 up to n this should be I less than equal to n and the result is told in the variable p and this p is the final result of evaluating this function and that is the return value again the name of the function is factorial the return type of the function is in it has one argument which is called n and whose type is an in <sil=0.941> .PERIOD Okay so you might be surprised to know or maybe not so surprised that the main program that we write the main is also a function you might have noticed the similarity between how the main code starts and how a function is defined and that similarity is not coincidental it is because of the fact that main is also the name of a function except it is the same as any other function the only difference is that it is a special function in the sense that execution always starts at this function <sil=0.977> .PERIOD Okay let us now talk a little bit about local variables so we have already seen in the functions digit fact I digit fact some and the function factorial that we can declare variables within the within the body of a particular function and these variables are said to be local to that particular function <sil=0.925> .PERIOD So what local means is that a function declared within a particular function is not visible outside this function that is known as the scope of the function which we will talk about in more detail in the next lecture and the second important point about local variable is that this variable has existence only while this particular function of which this is a local variable is executing <sil=0.926> .PERIOD So while this function is not executing nobody has called this function and this variable does not exist at all there is no space allocated for this variable in the memory of the machine <sil=0.925> .PERIOD So this idea is called the lifetime of a variable we will talk about lifetime of variables also in the next lecture <sil=0.930> .PERIOD What is important to note is that it is possible that two functions have local variables which have the same name <sil=0.928> .PERIOD For example <sil=0.322> ,COMMA this function factorial had a variable called i and the function main also had a local variable i <sil=0.914> .PERIOD Now these two is have nothing too do with each other the i declared within the function factorial is local to the function factorial and similarly the i declared within the function main is local to the function main <sil=0.930> .PERIOD So within main whenever we refer to the variable i what is meant is a reference to be variable i which is declared within the function main whereas within the function factorial when we referred to the to the variable i what is meant is a reference to the variable i declared within be function factorial <sil=0.913> .PERIOD Okay <sil=0.392> ,COMMA let us now look at parameters and argument <sil=0.955> .PERIOD So <sil=0.599> ,COMMA we saw that when we declare a function <sil=0.327> ,COMMA we have to declare what its parameters are <sil=0.972> .PERIOD We have seen so far only functions with one parameter <sil=0.519> ,COMMA but in general a function may have more than one parameter <sil=0.918> .PERIOD Each of those parameters in the function definition has to be given in name <sil=0.967> .PERIOD For example <sil=0.467> ,COMMA in the factorial function the parameter was called n and it has to be given a type in the case of the factorial function that was the type was n <sil=0.980> .PERIOD When we call a function at that time an actual argument for that function has to be supplied <sil=0.983> .PERIOD We will talk about the relationship between parameters and arguments shortly <sil=0.947> .PERIOD But the important point to understand at this point in time is that a parameter declared for a function can be used pretty much like a local variable of that function <sil=0.959> .PERIOD It behaves like a local variable <sil=0.972> .PERIOD In fact <sil=0.647> ,COMMA in terms of both scope and lifetime it is similar to local variables <sil=0.948> .PERIOD What that means is that this variable is not visible outside this function and comes into existence only when that function gets called <sil=0.983> .PERIOD So <sil=0.447> ,COMMA for example <sil=0.496> ,COMMA in the program that we just developed the factorial function had a parameter called n and the main function had a local variable called n <sil=0.916> .PERIOD Now <sil=0.646> ,COMMA these two n are again completely independent of each other and have nothing to do with each other <sil=0.954> .PERIOD Let us now try to understand what happens when a function is called <sil=0.946> .PERIOD So <sil=0.416> ,COMMA when a function is called some parameters are supplied some arguments are supplied for that function <sil=0.907> .PERIOD So <sil=0.507> ,COMMA the arguments are supplied for each parameter that the function has <sil=0.908> .PERIOD If the function has two parameters then there must be two arguments <sil=0.947> .PERIOD If it has three parameters then there must be three arguments <sil=0.992> .PERIOD What happens first is that these arguments are evaluated <sil=0.933> .PERIOD These arguments have to be expressions and the evaluation of these expressions results in some value <sil=0.984> .PERIOD And then for the function which is being called the compiler creates space in memory for the local variables and parameters of this function <sil=0.920> .PERIOD And next step is that the parameter the space that has been created for the parameters of this function <sil=0.957> .PERIOD Those parameters are initialized for their given values which are equal to the values of the corresponding argument expressions <sil=0.992> .PERIOD So <sil=0.436> ,COMMA we will see that as an example and the important point to note is that the value that the parameter gets is a copy of the value of the corresponding argument <sil=0.911> .PERIOD So <sil=0.529> ,COMMA let us try to understand what is happening when a function is being called and some arguments are being passed to it with the help of an example <sil=0.966> .PERIOD I have scribbled here the definitions of the digit fact sum and the main function that we just wrote <sil=0.991> .PERIOD So <sil=0.629> ,COMMA let us focus on this called from the main function to the digit fact sum function <sil=0.942> .PERIOD So <sil=0.362> ,COMMA while the main function is executing the variables the local variables of main are in existence <sil=0.941> .PERIOD So <sil=0.457> ,COMMA let us say this is this is the space created for these local variables and I and R let us assume that at some point in time and happens to be 5 and maybe I happens to be 2 <sil=0.931> .PERIOD Now <sil=0.576> ,COMMA the function digit fact sum is not executing right now and so therefore <sil=0.647> ,COMMA the variables of the function digit fact sum do not exist at this point in time <sil=0.910> .PERIOD Now <sil=0.644> ,COMMA when this function is called from this statement the argument passed to this function is the expression I <sil=0.984> .PERIOD So <sil=0.396> ,COMMA what is going to happen is that this expression I will be evaluated and that of course <sil=0.576> ,COMMA results in the value 2 and now since this function digit fact sum is being called space is created for the variables and parameters of this function <sil=0.954> .PERIOD So <sil=0.603> ,COMMA there is one parameter n and there is one local variable sum <sil=0.994> .PERIOD Note that n is also a local variable of the function main but this n and this n have really nothing to do with each other <sil=0.928> .PERIOD So <sil=0.433> ,COMMA this box is also called n because the name of this parameter is also n <sil=0.933> .PERIOD So <sil=0.409> ,COMMA what is going to happen is that the value of this expression which has resulted in the value 2 is going to be copied into the value of n over here and now the digit fact function will start executing and finally <sil=0.611> ,COMMA as you will as you know the value of sum will become 2 and the value of n becomes 0 because in every iteration we are dividing n by 10 <sil=0.923> .PERIOD So <sil=0.484> ,COMMA in the first iteration itself n will become 0 <sil=0.971> .PERIOD So <sil=0.431> ,COMMA the value of n is 0 <sil=0.910> .PERIOD Note that the value of this n which is the parameter of the function digit fact sum which has become 0 the value of I in the main function remains 2 that does not get changed and similarly the value of n in the main function that also does not get changed and it remains 5 <sil=0.930> .PERIOD Now <sil=0.633> ,COMMA when this function is about to return this expression which is the expression corresponding to the return value is evaluated and the value of that expression is 2 <sil=0.936> .PERIOD So <sil=0.445> ,COMMA the value of this expression is what will become the value of this entire expression in the main function <sil=0.947> .PERIOD So <sil=0.414> ,COMMA when this function returns the control goes back to the main function and execution within the main function continues from the point just after where the digit fact sum function was called <sil=0.930> .PERIOD So <sil=0.644> ,COMMA this function the main function of continues and the value of this entire expression comes out to be 2 which is the return value of the digit fact sum function and then of course <sil=0.590> ,COMMA we check whether it is equal to I or not the value of I is also 2 and so <sil=0.375> ,COMMA since we were equal the printf happens and 2 gets printed on the output and so on <sil=0.936> .PERIOD So <sil=0.353> ,COMMA what we just saw is that when a function is called from another function the arguments for each parameter have to be supplied these arguments are evaluated and result in some values <sil=0.997> .PERIOD Then the next step is to create space for each of the parameters and the local variables of the function which is being called and the values of the arguments are copied into the respective parameters and then the function body executes and finally <sil=0.576> ,COMMA at the end it returns a value and the value is taken as the value of the call expression that is the call to the function is treated as an expression and the value of that expression is nothing <sil=0.622> ,COMMA but the return value that the function returned and the execution starts in the function from which the function had been called at the point just after where the call was made <sil=0.921> .PERIOD So <sil=0.613> ,COMMA this is the end of this lecture and in the next lecture we will continue our discussion on functions and look at some more details involved with writing of functions <sil=0.947> .PERIOD Hello <sil=0.430> ,COMMA in the last lecture we had looked at some C program and without really discussing the season text formally <sil=0.514> ,COMMA tried to write some simple C programs and examine them and how they work <sil=0.902> .PERIOD As I mentioned in the last class <sil=0.548> ,COMMA starting today we will start discussing the season text and the various intricacies of the language from today and today we will first look at variables and types <sil=0.909> .PERIOD So <sil=0.446> ,COMMA we have already used several variables in the programs that we have written so far <sil=0.313> ,COMMA but there are restrictions on what the variable names can be <sil=0.947> .PERIOD So far we have been using simple names like A <sil=0.355> ,COMMA B <sil=0.450> ,COMMA C <sil=0.352> ,COMMA I and J <sil=0.457> ,COMMA but actually the variable names can be pretty much as long as you like <sil=0.545> ,COMMA but the restriction on the variable names is that it can only contain letters <sil=0.529> ,COMMA lower or upper case <sil=0.323> ,COMMA that is A to Z or numerals <sil=0.355> ,COMMA 0 to 9 or the special underscore characters <sil=0.939> .PERIOD It cannot contain any other character on the keyboard <sil=0.918> .PERIOD In addition <sil=0.440> ,COMMA the variable name cannot start with a numeral <sil=0.488> ,COMMA that is it cannot start with a digit from 0 to 9 <sil=0.955> .PERIOD So <sil=0.436> ,COMMA let us see some examples of valid and invalid variable names <sil=0.967> .PERIOD There are some invalid variable names <sil=0.357> ,COMMA CX <sil=0.411> ,COMMA F <sil=0.396> ,COMMA F <sil=0.312> ,COMMA F <sil=0.594> ,COMMA F <sil=0.563> ,COMMA F <sil=0.435> ,COMMA F <sil=0.447> ,COMMA F <sil=0.627> ,COMMA F <sil=0.525> ,COMMA F <sil=0.411> ,COMMA F <sil=0.369> ,COMMA F <sil=0.614> ,COMMA F <sil=0.447> ,COMMA F <sil=0.483> ,COMMA F <sil=0.452> ,COMMA F <sil=0.336> ,COMMA F <sil=0.457> ,COMMA F <sil=0.493> ,COMMA F <sil=0.525> ,COMMA F <sil=0.305> ,COMMA F <sil=0.517> ,COMMA F <sil=0.358> ,COMMA F <sil=0.529> ,COMMA F <sil=0.396> ,COMMA F <sil=0.398> ,COMMA F <sil=0.467> ,COMMA F <sil=0.483> ,COMMA F <sil=0.542> ,COMMA F <sil=0.649> ,COMMA F <sil=0.618> ,COMMA F <sil=0.303> ,COMMA F <sil=0.443> ,COMMA F <sil=0.458> ,COMMA F <sil=0.452> ,COMMA F <sil=0.629> ,COMMA F <sil=0.582> ,COMMA F <sil=0.436> ,COMMA F <sil=0.630> ,COMMA F <sil=0.312> ,COMMA F <sil=0.544> ,COMMA F <sil=0.400> ,COMMA F <sil=0.338> ,COMMA N <sil=0.465> ,COMMA is illegal because of these parentheses <sil=0.536> ,COMMA the bracket characters <sil=0.951> .PERIOD This one is also <sil=0.860> ?QUESTIONMARK  <sil=0.971> ?QUESTIONMARK  <sil=0.872> ?QUESTIONMARK  <sil=0.965> ?QUESTIONMARK  <sil=0.943> ?QUESTIONMARK  <sil=0.863> ?QUESTIONMARK  <sil=0.974> ?QUESTIONMARK  <sil=0.993> ,COMMA because it has the bracket characters in it <sil=0.555> ,COMMA as well as the minus sign <sil=0.324> ,COMMA no that the minus sign is different from the under core characters <sil=0.916> .PERIOD There are some valid variable names instead of three X <sil=0.574> ,COMMA we could have called it X <sil=0.390> ,COMMA three <sil=0.902> .PERIOD There is an example <sil=0.311> ,COMMA where the variable name contains an underscore character f1 to score n or f1 to score fn under score 1 <sil=0.968> .PERIOD So <sil=0.325> ,COMMA this is the restriction imposed by the language on what the variable name can be <sil=0.495> ,COMMA but also when we are writing programs as I have said earlier also we must make sure that our programs are readable so that they can be later understood by ourselves and by other people who are reading the programs and one very important aspect of program availability is that we should use descriptive variable name that is the variable name themselves should suggest what the purpose of the variable is <sil=0.959> .PERIOD Okay <sil=0.453> ,COMMA here are some more constraints on what the variable name cannot be <sil=0.966> .PERIOD She has certain what are known as keywords or verb words which cannot be used as variable names because these words are special meaning <sil=0.947> .PERIOD We have already seen examples of these keywords they have appeared in our program <sil=0.934> .PERIOD If you recall is type integer and so that the keyword cannot be used as a variable name what that means is that we cannot have a variable name and similarly we saw that while if else etc were special words that we use in our program so they cannot be used as variable name either <sil=0.538> ,COMMA but any other there are a whole lot of other keywords as well <sil=0.451> ,COMMA but other than the keywords any combination of factors containing only alphabet <sil=0.639> ,COMMA numerals and not starting with the numerals could be a valid variable name <sil=0.316> ,COMMA but it means there is a game that you should choose our variable name carefully so that we represent the purpose of having that variable <sil=0.973> .PERIOD Okay <sil=0.321> ,COMMA let us now look at types we have already encountered types in the programs that we have been so far we have only seen one type so far which was the integer type represented by the keyword int <sil=0.577> ,COMMA but there are other types also available in C large number of them actually <sil=0.954> .PERIOD So the types are mostly because our programs as well as the computer can deal with data of really a time integers are just one example it could deal with real numbers it could deal with strings made up of characters and so on so forth and in general the values of different types are stored differently on the computer internally for example integers and real numbers are stored very differently they have already seen in an earlier lecture that integers are stored in their binary representation we shortly see roughly how the real numbers are stored inside the computer and you will see that the way they are stored are very different and as you can imagine different types may have different operations defined on them for example for integers as well as for real numbers we have the arithmetic operations defined like addition and so on but for some other types some other operations may be defined which may not make sense for integers in general even similar operations on different types may be implemented differently internally by the computer for example addition is defined for both real numbers and integers but because the representation of integers and real numbers is very different the computer has to perform addition of integers very differently from the way it performs addition of two real numbers and therefore the compiler leads to know the type of every variable or value that is being manipulated by the program that is because it has to generate the right machine code to manipulate these values or the variables <sil=0.944> .PERIOD So <sil=0.534> ,COMMA at first discuss integers types and see in more detail we have already seen the type 8 which can be used for storing integers but as we will shortly find out see actually defines a number of flavors of the digit type with slightly different properties <sil=0.918> .PERIOD So integers can be either unsigned or signed what that means is that whether negative integers can be stored or not so an unsigned integers variable cannot store the negative integers value whereas a signed integer variable can store both positive as well as negative integer values <sil=0.923> .PERIOD The integers can be of different sizes these are the various sizes of integers can see each short long or the regular integers will soon see what the different sizes mean and what is the practical implication of this <sil=0.970> .PERIOD So let us first focus our attention on signed and unsigned integers <sil=0.950> .PERIOD So if we prefix the word unsigned unsigned infinitely is another keyword it is a new keyword that we are introducing now if we prefix this to an integer type then that is a human integer type but it indicates a type where only non negative integers can be stored that is either 0 or positive integers and if we will unsigned if we use the prefix sign or no prefix at all that indicates that both negative and non negative integers can be stored <sil=0.988> .PERIOD So for example unsigned int would denote an integer type which can store only non negative integers on the other hand signed int or simply int would denote an integer type which can store both negative as well as non negative integers <sil=0.914> .PERIOD So here are the examples which are just the sign int is the same as just int both negative and non negative integers can be stored unsigned int on the other hand denote some integer type that can only hold non negative integers <sil=0.994> .PERIOD So we cannot assign really a negative integer to a variable of type and it will result in some kind of an error <sil=0.916> .PERIOD And as we said integers can also be of various sizes apart from being signed or unsigned <sil=0.928> .PERIOD So the size of a type here really denotes the number of bits used to store the values of a particular type <sil=0.958> .PERIOD If you recall from the earlier lecture we had seen that the integers are stored internally in their binary form and the number of bits available for storing the integers really determine what is the largest integers that can be stored in that particular type <sil=0.984> .PERIOD So a type for the bigger size can store a larger range of integers <sil=0.909> .PERIOD The different size integers integer types in the care shorting which can be used as just short <sil=0.579> ,COMMA int and longing <sil=0.321> ,COMMA longing there are same as just long <sil=0.996> .PERIOD There are the integer types of various sizes in C we will discuss their sizes in a minute <sil=0.982> .PERIOD And in addition each of these can be signed or unsigned <sil=0.981> .PERIOD So here is a list of all integer types in C we can have just the plain integer which can be signed in or just in <sil=0.918> .PERIOD We can have an unsigned integer which we can write as unsigned or just unsigned <sil=0.942> .PERIOD We can have a long integer which is written as longing or just long and unsigned long integer or just unsigned long <sil=0.962> .PERIOD A shorting integer is written as shorting or just short and unsigned shorting is signed character which is written as signed care or just care <sil=0.999> .PERIOD Do not really get misled by the fact that the name here is care is low fin <sil=0.939> .PERIOD This is there for a specific reason which we will discuss later on when we talk about representation of characters inside a computer <sil=0.903> .PERIOD We will see that the same type is actually used for representing the characters also but it is actually just another integer type <sil=0.918> .PERIOD So this can be just another integer type <sil=0.942> .PERIOD So we will just think of it right now as an integer type and the unsigned care type <sil=0.933> .PERIOD Let us see what their sizes are and what the size has to do with the smallest and largest integers that can be stored in a variable of a certain type <sil=0.937> .PERIOD So if you have a signed integer type with size n bit then it can store integers from minus 2 to the power n minus 1 to plus 2 to the power n minus 1 minus 1 both inclusive <sil=0.905> .PERIOD We will just state that and not really show while it is true <sil=0.993> .PERIOD On the other hand if we are talking about an unsigned integer type again a size n bit then the largest integers that can be stored is 2 to the power n minus 1 and of course the smallest integer is 0 <sil=0.956> .PERIOD Remember that in the unsigned integer type you cannot store negative numbers <sil=0.958> .PERIOD Now out of the different integers types of various sizes that we have seen so far care <sil=0.563> ,COMMA short <sil=0.577> ,COMMA int and long the C standard definition <sil=0.354> ,COMMA the C language definition defines only the size of the cat type which is 8 bits which is if you recall the same as 1 right a group of 8 bits is called a byte and it does not define the sizes of the other size like short <sil=0.519> ,COMMA int and long and so the size of these types may vary from different computer to different computers from one computer to another <sil=0.960> .PERIOD So on one kind of the computers the short may be 16 bits on another it might be the state bits and so on but what the language that is getting used is that short is at least as big as care int is at least as big as short and long is at least as big as int <sil=0.966> .PERIOD So on a typical PC which is running Linux which is the kind of machine that we are using in this course these are the typical sizes of the various types care as always of course is 8 bits remember that care is 8 bits on every machine and on a PC with Linux short is 16 bits or 2 bytes int and long are both 32 bits or 4 bytes <sil=0.972> .PERIOD So on this particular machine it does not really matter whether I declare it variable as int or long because both are 32 bits but remember on a different machine it might make a difference because on a different machine for example int could be 32 bits and long could be 64 bits or maybe int 16 bits and long is 32 bits <sil=0.926> .PERIOD Therefore we have to use the correct types choose the correct types of our variables depending on how large we think the value of that variable is likely to be <sil=0.917> .PERIOD Now since the sizes of these types can vary from system to system there is a way for C programs to find out what is the size of a given size within the program itself and that is done using the size of operator in C <sil=0.936> .PERIOD So if for example if I use the expression size of int then this will have the value 4 on a PC running Linux <sil=0.908> .PERIOD So we can let me illustrate this with a small program <sil=0.925> .PERIOD Here is a small program which prints the sizes of various integer types <sil=0.928> .PERIOD So note that this program has no import it does not print any import from the user <sil=0.945> .PERIOD Just print it has a 4 20th statement and each line print the size of a particular type is so many bytes <sil=0.951> .PERIOD So this personally if you remember would be replaced by the value of the parameter which in this case would be size of S <sil=0.948> .PERIOD which of course as we know is going to be 1 byte and in this case it will be replaced by size of short size of int size of long and so on <sil=0.909> .PERIOD Note that the size of unsigned short is the same as short and in this size of unsigned int is the same as the size of int and so on <sil=0.985> .PERIOD So we do not really need to find out the sizes of unsigned int and unsigned short separately <sil=0.911> .PERIOD So let us compile this program and see what output it is <sil=0.983> .PERIOD Okay so this confirms the fact that I just told you that on this particular machine this kind of a machine which is a PC running Linux the care has side 1 byte <sil=0.996> .PERIOD This member will have a system but on this system short size 2 byte and int and long have size 4 byte which may be different on different system but remember that the guarantee we have from the C language is that the short will have size at least as much as care int will have size at least as much as short and long will have size at least as much as int <sil=0.982> .PERIOD Okay so let us now go back to another type that will be quite useful and that is the type of type of real number <sil=0.970> .PERIOD So we have been dealing only with integers in the programs that we have written so far but as you can imagine oftentimes we might need to deal with real numbers especially when you want to do scientific competition and as I said earlier real numbers are represented very differently inside the computer form and integer <sil=0.986> .PERIOD So real number is really represented as a sign whether the number is positive or negative and exponent which is some power of 2 and the main piece or the fractional part of the integer we do not really need to know the ideas behind this in great details the point that we are trying to make at this point in time is simply that the representation of integers is very different from that for real number and the implication of this particular kind of representation is that real numbers can only be represented approximately that is we have only a finite number of bits to represent the main piece or the fractional part of the real number and so the accuracy is limited <sil=0.934> .PERIOD On the other hand the integers are stored absolutely precisely but the differences that while integers types have a relatively smaller range so for example on the machine that we just saw the size of integer type is 4 by 32 bits so that means that the largest integers that we can store in an int type would be 2 to the power 31 minus 1 the range of real numbers on the other hand is much larger but the precision is restricted <sil=0.963> .PERIOD Let us now look at the real number types that are available in C there are two of them really they are called float and double the world float comes from the fact that the representation of real number that we just saw is called the floating point representation and the world double comes from the fact that the double type has about twice the precision as that of the float type <sil=0.933> .PERIOD So <sil=0.385> ,COMMA you said double has much more precision than the type float but both have about the same range that is the smallest and the largest real number types in the stored are about equal in both these types <sil=0.951> .PERIOD The difference remember is in the precision so the double type is typically used in scientific applications that require a high degree of precision <sil=0.931> .PERIOD Let us now write a small program to illustrate the float type and this program is to compute the area of the circle fairly simple program given the radius of the circle <sil=0.949> .PERIOD So <sil=0.521> ,COMMA obviously we want to represent both the radius and the area of the circle by real number <sil=0.950> .PERIOD So <sil=0.382> ,COMMA here is the program remember that hash include the city I O dot H will be present in pretty much all programs that we write this just says that we are going to use some standard input and standard output library function in the standard I O library <sil=0.949> .PERIOD So <sil=0.531> ,COMMA here are the variables that we are going to use the variable radius is represent the radius of the circle that the user will input the variable area will represent the computed area of the circle <sil=0.909> .PERIOD High of course <sil=0.536> ,COMMA is the well known mathematical constant and we are using its value 3 <sil=0.936> .PERIOD 141 9 of course <sil=0.596> ,COMMA we could have used a more precise value for phi <sil=0.952> .PERIOD So <sil=0.494> ,COMMA this program is quite simple as you can see we enter we use the user from to enter the radius and then we have to read the radius from the user <sil=0.901> .PERIOD Now <sil=0.503> ,COMMA that radius is a floating point variable or a float of a float we cannot use kns percent D to read it <sil=0.907> .PERIOD We still use kns to read the value of radius but instead of using D we will use percent F and remember that in kns the variables have to be predicted by the sample send <sil=0.905> .PERIOD So <sil=0.645> ,COMMA once we know the value of the radius the value of the area is very simple to compute it says phi r square or phi 10 radius 10 radius and then we are printing the output which is the area of the circle with radius so much is so much <sil=0.929> .PERIOD So <sil=0.549> ,COMMA again note that to print a floating point value or a real value we are using percent F instead of currently as we did for printing integers and we are using the same print statement actually to print 2 real values along with some text <sil=0.951> .PERIOD So <sil=0.469> ,COMMA we have 2 percent F in the format string and first percent F will be replaced by the value of the radius and second percent F will be replaced by the value of the area <sil=0.925> .PERIOD So <sil=0.515> ,COMMA let us compile this program <sil=0.983> .PERIOD Let us say we gave the radius as 2 <sil=0.934> .PERIOD 56 whatever the radius is and let us give the correct area of the circle which is 2 <sil=0.988> .PERIOD 59 075 size which you can easily verify using a calculator <sil=0.968> .PERIOD One more point I would like to make using the same program let us add it again and that is that in this program the variable phi is actually not really a variable in the sense that we will never want to change it once we have given it a value <sil=0.995> .PERIOD Note that one more new thing that we have done in this program is that the variable has been utilized at the same time as when it has been declared <sil=0.999> .PERIOD This is the first time we have been doing this <sil=0.952> .PERIOD So <sil=0.538> ,COMMA float phi is equal to 3 <sil=0.945> .PERIOD 1419 so we can mix the initialization of a variable with the declaration as we really do not want to modify the value of phi ever in our program <sil=0.953> .PERIOD So <sil=0.429> ,COMMA to indicate this we could prefix this declaration by the keyword prompt <sil=0.924> .PERIOD The keyword prompt has the compiler that this variable is really constant which will not be modified by the program <sil=0.949> .PERIOD So <sil=0.328> ,COMMA it can only be initialized along with the declaration it cannot be given a value later on <sil=0.942> .PERIOD So <sil=0.364> ,COMMA the point of doing this is that if inadvertently by the sake our program happens to modify the value of such a variable the compiler will give us an error message <sil=0.967> .PERIOD Let us try to do that actually <sil=0.906> .PERIOD Let us say phi 0 <sil=0.929> .PERIOD 46 <sil=0.985> .PERIOD So <sil=0.457> ,COMMA as we will see this is a variable given error <sil=0.927> .PERIOD Assignment of the variable phi so this is not permitted <sil=0.907> .PERIOD So <sil=0.543> ,COMMA that is the advantage of declaring variables as constants and we do not really want to modify the values <sil=0.961> .PERIOD So <sil=0.403> ,COMMA this program will compile okay and will work the same as before <sil=0.963> .PERIOD Very bad answer <sil=0.985> .PERIOD Okay <sil=0.479> .PERIOD So <sil=0.415> ,COMMA let us turn this lecture with a problem for you <sil=0.956> .PERIOD The problem is that we will compute the value of phi 0 given the value of x to a certain accuracy <sil=0.943> .PERIOD Let us say a epsilon which is also given <sil=0.961> .PERIOD The accuracy basically means that the value of phi 0 must not that is computed by the program must not differ from the actual value of phi 0 by more than this amount <sil=0.997> .PERIOD Now <sil=0.450> ,COMMA the way you are going to do this is to use the dealer expansion for sine x <sil=0.944> .PERIOD We call that sine of x is equal to x minus x cube by f factorial plus x to cos phi by f factorial minus x to cos 7 by 7 factorial and so on <sil=0.980> .PERIOD So <sil=0.634> ,COMMA you have to use the same error series to compute the value of sine x given the value of x and since you have computed for the accuracy of epsilon that means that you should stop adding the terms of the sequence once the absolute difference between the last two terms that have been computed is less than epsilon <sil=0.933> .PERIOD So <sil=0.356> ,COMMA let us say gn is the last term that we have computed and tn minus epsilon was the term that we computed before that then when the difference is less than epsilon that look different is less than epsilon then we can stop computing and the sum that we have a complicate so far is the value of sine x to the desired accuracy <sil=0.964> .PERIOD Also note that you can in every iteration when you want to compute some x to the power 2 k plus 1 by 2 k plus 1 factorial we do not need to raise x again to the power 2 k plus 1 and compute 2 k plus 1 factorial you can use the fact that in the previous iteration use you computed the term x to the power 2 k minus 1 divided by 2 k minus 1 factorial <sil=0.960> .PERIOD So <sil=0.479> ,COMMA given this value to compute the next term which is this all you need to do is you need to multiply this by x square and divide by 2 k times 2 k plus 1 <sil=0.969> .PERIOD So <sil=0.608> ,COMMA you can see this will become x to the power 2 k plus 1 into 2 k plus 1 factorial and that will give you the value of the next term <sil=0.913> .PERIOD So <sil=0.528> ,COMMA try to solve this problem and try to see program for computing the value of sine x will see the solution to this problem in the beginning of the next lecture <sil=0.921> .PERIOD Thank you <sil=0.990> .PERIOD you you you you you <sil=0.986> .PERIOD In the last lecture we had talked about C expressions and operator <sil=0.991> .PERIOD We had looked at arithmetic <sil=0.649> ,COMMA relational and logical operators <sil=0.990> .PERIOD We will continue that discussion today with operators which have side effects <sil=0.911> .PERIOD So <sil=0.544> ,COMMA far the operators that we have seen when an expression with these operators is evaluated it results in a value <sil=0.620> ,COMMA but as a result of the evaluation of the expression the value of the variable of any variable does not change <sil=0.936> .PERIOD On the other hand there are second operators that we discussed today where the evaluation of an expression containing such an operator can also result in a change in the value of some variable <sil=0.982> .PERIOD So <sil=0.428> ,COMMA these kinds of changes are called side effects and such operators are called operators with side effects <sil=0.965> .PERIOD Let us start with a very similar operator <sil=0.440> ,COMMA the assignment operator <sil=0.934> .PERIOD We have already used the assignment statement in all the programs that we have written so far <sil=0.991> .PERIOD You will be surprised to know that assignment is actually an operator in C and it has two operands <sil=0.953> .PERIOD The left operand always has to be a variable <sil=0.407> ,COMMA that is the variable whose value has to be assigned and the right hand side of the right operand can be in an arbitrary expression <sil=0.944> .PERIOD So <sil=0.391> ,COMMA what does it mean to evaluate the assignment operator <sil=0.941> ?QUESTIONMARK We have to define the effect of evaluating such an expression in terms of what is the value of the expression as well as what is the side effect of evaluating such an expression <sil=0.964> .PERIOD So <sil=0.410> ,COMMA as an example consider the expression x assigned e if we evaluate this expression what is going to happen is that the expression e gets evaluated to some value that value becomes the new value of x that is the side effect of evaluating this particular expression and the value that was obtained by evaluating the expression e is also the value of the expression <sil=0.990> .PERIOD So <sil=0.584> ,COMMA the value of the expression is the same as the value of x which is the value of the expression e <sil=0.996> .PERIOD So <sil=0.555> ,COMMA let us see some examples <sil=0.918> .PERIOD So <sil=0.462> ,COMMA compare the expression x assigned y minus 2 let us assume that y has value 10 <sil=0.936> .PERIOD So <sil=0.577> ,COMMA when we evaluate this expression the expression on the right hand side y minus 2 get evaluated which results in the value 8 and so the side effect of the expression evaluation is that the value of x becomes 8 as well as the value of the entire expression x is equal to y minus 2 is also 8 as a slightly more complicated example consider this expression z assigned x assigned y minus 2 <sil=0.907> .PERIOD So <sil=0.535> ,COMMA we will have to first see what this expression really means the equal to operator of the assignment operator has a precedence less than that of the minus operator will see the complete list of operator precedence is in the specificity slightly later on and the equal to operator associate right to left not left to right as is the case with the most arithmetic operator <sil=0.912> .PERIOD So <sil=0.516> ,COMMA which means that the subtraction will be performed first and then the two assignments will happen and the assignment on the right will happen first because the creativity of assignment is right to left not left to right and so therefore <sil=0.363> ,COMMA this expression is the same as this bracketed expression first y minus 2 is evaluated that is assigned to x and the resulting value of the expression x assigned y minus 2 is assigned to the values x <sil=0.974> .PERIOD So <sil=0.455> ,COMMA when y minus 2 is evaluated the value that we get of course <sil=0.308> ,COMMA is 8 again in this case assuming that the old value of y is 10 and that assigned to the variable x the value of x becomes 8 <sil=0.917> .PERIOD Now <sil=0.396> ,COMMA the value of this smaller assignment expression is also went to the is also went to the 8 which is the final value of the variable x and that is the value that gets assigned to the variable z and so z also gets the value of 8 and the value of the overall expression also happens to be 8 which is the final value of z <sil=0.904> .PERIOD Now <sil=0.566> ,COMMA the reason we were able to use assignment as statement is general rule in G which is that any C expression can actually be used as a statement by adding a semicolon abstract <sil=0.906> .PERIOD So <sil=0.398> ,COMMA we just saw the expression x assigned y minus 2 if we add a semicolon after this then it becomes a valed C statement <sil=0.966> .PERIOD Now <sil=0.531> ,COMMA when we use such a statement the meaning is that the expression is evaluated and its value is discarded that is the value of the expression is discarded <sil=0.924> .PERIOD So <sil=0.484> ,COMMA this makes sense this is useful only if the expression has certain satisfaction because it has most satisfaction only its value is important then it does not make sense to use that expression as a statement because the value is discarded anyway <sil=0.975> .PERIOD The most common example of course <sil=0.310> ,COMMA is the assignment statement which is which is very common in all C program and as we understand now the assignment statement is actually nothing but an assignment expression followed by a semicolon which converts it into a statement <sil=0.984> .PERIOD So <sil=0.315> ,COMMA as a fact in such a case expression is evaluated and its value is discarded but whatever side effects happened as a result of evaluating the expression state <sil=0.944> .PERIOD So <sil=0.340> ,COMMA as you can see it is clearly not useful to use an expression that has no satisfaction as a statement for example <sil=0.624> ,COMMA consider the statement x plus y semicolon <sil=0.963> .PERIOD Now <sil=0.368> ,COMMA this in itself is a valed C statement because x plus y is a valed C expression but this is quite useless a C statement because the value of the expression x plus y is the target and expression has no side effects <sil=0.914> .PERIOD So <sil=0.575> ,COMMA whether or not we put such a statement in the program that makes absolutely no difference to the working of the program <sil=0.951> .PERIOD So <sil=0.400> ,COMMA we now have to talk about type conversion or we must emphasize implicit type conversion in assignment expression <sil=0.907> .PERIOD The rules for type conversion in assignment are slightly different from those that happen in the other arithmetic operators and so on <sil=0.909> .PERIOD So <sil=0.382> ,COMMA if you recall in operators such as plus minus etcetera the rule was that if the two operands are of different types then the operand which is of the lower type its value gets promoted or gets converted to the higher type <sil=0.968> .PERIOD In assignment on the other hand what happens is that regardless of which of the two types is lower or higher the value of the right hand operand always gets converted to the type of the left hand operand because it is the the left hand operand is a variable and it is into this variable that the value is going to get stored <sil=0.941> .PERIOD Therefore <sil=0.642> ,COMMA whatever the value we get as a result of evaluating drag inside operand must be converted to whatever is the type of the variable <sil=0.914> .PERIOD Of course <sil=0.478> ,COMMA this may in general result in loss of information or accuracy for example <sil=0.520> ,COMMA suppose x is an integer variable and we have an assignment x to send 5 <sil=0.968> .PERIOD 2 you know that 5 <sil=0.943> .PERIOD 2 is a constant literal of floating point time and its type there 4 is double <sil=0.953> .PERIOD Now <sil=0.530> ,COMMA the double type is higher than the integer type as you know <sil=0.304> ,COMMA but because of the special rule in assignment the type of the expression on the right hand side is going to get converted to the type of the of the variable on the left hand which means that the type of the expression 5 <sil=0.929> .PERIOD 2 which is double is going to get converted to an integer before that value is stored in the variable x <sil=0.983> .PERIOD So <sil=0.583> ,COMMA variable x cannot of course <sil=0.434> ,COMMA stored the value 5 <sil=0.950> .PERIOD 2 <sil=0.950> .PERIOD So <sil=0.559> ,COMMA when 5 <sil=0.967> .PERIOD 2 double value is converted to an integer <sil=0.352> ,COMMA the fractional part is dropped off and the resultant value is just the integer type and that what gets assigned to the variable x <sil=0.947> .PERIOD So <sil=0.322> ,COMMA in this case what is happening is a loss of information from 5 <sil=0.942> .PERIOD 2 the original value what actually gets assigned to x is just 5 <sil=0.983> .PERIOD So <sil=0.380> ,COMMA while using this kind of assignment where the two operands are of different type one has to be aware of this <sil=0.975> .PERIOD Similarly <sil=0.503> ,COMMA if on the right hand side we happen to have a long integer and on the left hand side we happen to have a variable of type simple int then it is possible that the value of the right side may not actually fit in the in in an integer <sil=0.900> .PERIOD If the value happens to be large and it cannot fit in an integer then what will happen is that some of the bits will get dropped off and the result will probably not be what we expect <sil=0.940> .PERIOD So <sil=0.572> ,COMMA one has to be careful in making such an assignment <sil=0.928> .PERIOD Okay <sil=0.602> ,COMMA here is another example of the same kind <sil=0.905> .PERIOD So <sil=0.320> ,COMMA in this example x is an integer variable and y is a floating point variable and we have the statement y assigned x assigned 7 point 0 divided by 5 and of course <sil=0.506> ,COMMA as you know the flash operator has the highest position <sil=0.976> .PERIOD So <sil=0.488> ,COMMA the bright thing is going to look something like this <sil=0.991> .PERIOD The second assignment is going to be evaluated first because the assignment operator associates from right to left and not left to right <sil=0.916> .PERIOD So <sil=0.391> ,COMMA the division is carried out first <sil=0.968> .PERIOD Now <sil=0.533> ,COMMA in division one of the options is of type double let's run point 0 <sil=0.956> .PERIOD The other is int <sil=0.911> .PERIOD So <sil=0.564> ,COMMA if you remember the rules what happens <sil=0.923> ?QUESTIONMARK The value 5 gets promoted to a double so that becomes 5 <sil=0.978> .PERIOD 0 and we divide 7 <sil=0.925> .PERIOD 0 by 5 <sil=0.979> .PERIOD 0 that gives us the value 1 <sil=0.914> .PERIOD 4 <sil=0.918> .PERIOD Now <sil=0.387> ,COMMA if you look at this assignment which is carried out next <sil=0.437> ,COMMA the left hand side x is of type int whereas <sil=0.353> ,COMMA the expression on the right hand side as a type double and value 1 <sil=0.931> .PERIOD 4 <sil=0.926> .PERIOD So <sil=0.502> ,COMMA what we have to happen in this case according to the rules for assignment is that the value on the right hand side is going to get converted to an integer which means that the sectional part will be removed <sil=0.950> .PERIOD So <sil=0.521> ,COMMA 1 <sil=0.435> .PERIOD 4 will get converted simply to 1 <sil=0.917> .PERIOD So <sil=0.332> ,COMMA the value that x gets is 1 and the value overall expression x is equal to 7 <sil=0.909> .PERIOD 0 divided by 5 is also 1 and the type is an integer <sil=0.959> .PERIOD Now <sil=0.636> ,COMMA that the first assignment why you find the rest of it this happens <sil=0.981> .PERIOD Now <sil=0.558> ,COMMA the right hand side of this expression has already been evaluated and that has been evaluated to the value 1 of type integers <sil=0.901> .PERIOD On the left hand side we have a variable y which is of type flow <sil=0.982> .PERIOD So <sil=0.556> ,COMMA the value 1 of type integer is going to get converted to a flow that becomes 1 <sil=0.961> .PERIOD 0 <sil=0.997> .PERIOD So <sil=0.617> ,COMMA y gets the value 1 <sil=0.954> .PERIOD 0 <sil=0.931> .PERIOD So <sil=0.337> ,COMMA in this example both x and y get the value 1 <sil=0.935> .PERIOD On the other hand suppose the assignment was x assigned y assigned 7 <sil=0.904> .PERIOD 0 divided by 5 <sil=0.938> .PERIOD So <sil=0.621> ,COMMA what will happen in this case <sil=0.967> ?QUESTIONMARK This assignment is going to happen first <sil=0.949> .PERIOD Now <sil=0.559> ,COMMA 7 <sil=0.957> .PERIOD 0 divided by 5 is evaluated it again evaluates to double value 1 <sil=0.989> .PERIOD 4 <sil=0.983> .PERIOD Now <sil=0.360> ,COMMA y is a flow the double value 1 <sil=0.937> .PERIOD 4 gets converted to the flow value 1 <sil=0.964> .PERIOD 4 and that is the value that gets assigned to the variable y <sil=0.946> .PERIOD So <sil=0.528> ,COMMA y gets the value 1 <sil=0.989> .PERIOD 4 and the value of this overall expression is 1 <sil=0.989> .PERIOD 4 of type double of type flow and then this assignment happens <sil=0.948> .PERIOD Now <sil=0.313> ,COMMA here the left hand side is of type integer and the right hand side is of type flow <sil=0.926> .PERIOD So <sil=0.387> ,COMMA the right hand side value gets converted to an integer <sil=0.941> .PERIOD So <sil=0.563> ,COMMA 1 <sil=0.351> .PERIOD 4 when it gets converted to an integer the fractional part is dropped off and the right hand value is 1 <sil=0.951> .PERIOD So <sil=0.369> ,COMMA the value of x becomes 1 and of course <sil=0.643> ,COMMA that also the value of the overall expression <sil=0.949> .PERIOD So <sil=0.558> ,COMMA in this case y would get the value 1 <sil=1.000> .PERIOD 4 while x would get the value 1 <sil=0.909> .PERIOD Now <sil=0.628> ,COMMA let us now look at some more operators which are similar to assignments they all have side effects and in fact <sil=0.365> ,COMMA can be described in terms of the assignment operator <sil=0.918> .PERIOD So <sil=0.413> ,COMMA there are 5 of these plus equal to minus equal to star equal to slash equal to n percent equal to and essentially these combine assignment with some arithmetic operation like plus or minus or multiplication or division or remainder and so on <sil=0.994> .PERIOD Of these 5 the first 4 can be used with protein point as well as integer quantities while the fifth one can be used only with integer quantities <sil=0.963> .PERIOD So <sil=0.565> ,COMMA in all these cases again the left hand operand must be a variable and the right hand operand can be any expression <sil=0.902> .PERIOD So <sil=0.448> ,COMMA for example <sil=0.482> ,COMMA let us look at an expression x plus equal to e <sil=0.948> .PERIOD This is exactly the same in terms of both value as well as the side effect as the expression x assigned x plus e <sil=0.911> .PERIOD So <sil=0.597> ,COMMA therefore <sil=0.435> ,COMMA the side effect is to add the value of e to the current value of x and the new value of x is the value of the expression and the same is the case with the other operator that you listed here <sil=0.986> .PERIOD The only difference is that instead of this plus this could get replaced with subtraction multiplication division or remainder operation as the case might be <sil=0.921> .PERIOD However <sil=0.471> ,COMMA two commonly used operators in C are the instrument and detachment operator <sil=0.960> .PERIOD These are denoted by the plus plus and the minus minus inverse <sil=0.936> .PERIOD There should not be any space between the two pluses or the two minuses <sil=0.958> .PERIOD Both are unary operators that is there is only one operand and the operand must be a variable <sil=0.942> .PERIOD And interestingly is that both can be used in prefix as well as the post-fix form <sil=0.556> ,COMMA but the meaning in the two cases is different <sil=0.996> .PERIOD Prefix form means that the operator comes before the operand and the post-fix means that the operand comes before the operator <sil=0.988> .PERIOD So <sil=0.326> ,COMMA let us see what these operator really means <sil=0.964> .PERIOD Let us assume that x is the variable of type n with some initial value x 0 <sil=0.910> .PERIOD So <sil=0.617> ,COMMA if you look at the expression x plus plus the value of the expression is x 0 and the side effect is to increment the value of x by 1 that is the new value of x is the old value x 0 plus 1 <sil=0.912> .PERIOD So <sil=0.420> ,COMMA this is the post-fix form of the plus plus operator <sil=0.991> .PERIOD In the prefix form the value of the expression is x 0 plus 1 and the side effect is the same which is to add one to the old value of x <sil=0.907> .PERIOD So <sil=0.541> ,COMMA the new value of x becomes the old value that is x 0 plus 1 <sil=0.928> .PERIOD So <sil=0.366> ,COMMA the only difference really in these two is the value of the overall expression <sil=0.925> .PERIOD One way to understand this is that in the post-fix form you could say that the value of x is used as the value of the expression and then the side effect happens that is the value of x then gets incremented once the value of the expression has been computed <sil=0.952> .PERIOD Whereas in the prefix case here the value of x or gets incremented that is the side effect for this happens and then the new value of x is used as the value of the expression <sil=0.965> .PERIOD So <sil=0.404> ,COMMA to clarify these operators let us take some examples you can see that the minus minus operator is exactly the same as the plus plus operator except that these pluses are replaced with minuses <sil=0.987> .PERIOD That is the side effect is to decrement the value of x by 1 and the value of the expression is either the old value of x or the new value of x which will be the old value of x minus 1 <sil=0.930> .PERIOD So <sil=0.333> ,COMMA here are some examples to clarify this <sil=0.980> .PERIOD Let us assume that x and y are integer variables and the initial value of y is 5 <sil=0.974> .PERIOD So <sil=0.482> ,COMMA let us assume that the expression x is equal to y plus plus is evaluated <sil=0.933> .PERIOD So <sil=0.553> ,COMMA now if you look at this expression y plus plus the value of this expression is same as the old value of y <sil=0.908> .PERIOD Because this is the post-fix form of the plus plus operator so the value is same as the old value <sil=0.964> .PERIOD So <sil=0.464> ,COMMA the value of the expression y plus plus is the old value of y of y which is 5 and the side effect is to increment the value of y by 1 <sil=0.975> .PERIOD So <sil=0.544> ,COMMA now what gets assigned into x is the value of the expression y plus plus which is the old value of y which is 5 and so x gets the value of y while x while y gets the value of 6 after the entire expression has been evaluated <sil=0.902> .PERIOD Now <sil=0.392> ,COMMA on the other hand if we had evaluated with the same ah declarations the expression x is equal to plus plus y <sil=0.967> .PERIOD Now <sil=0.395> ,COMMA what is going to happen is that when plus plus y is evaluated it the value of y is in 3 by 1 it becomes 6 and the value of this expression is the new value of y which is also 6 and so therefore <sil=0.386> ,COMMA the value that x gets is in this case 6 and not 5 <sil=0.958> .PERIOD Let us consider some more freaky example look at this program fragment x and y are declared to be integer variables and y has initial value 10 and you have the assignment statement x assigned plus plus y plus minus minus y <sil=0.929> .PERIOD The question is after the evaluation of this statement or after the execution of this statement what are going to the values of the variable x and y <sil=0.901> .PERIOD Now <sil=0.640> ,COMMA with respect to y you can see that there is one instrument and one decrement happening to the value of y which means that the value of y is going to be 10 it is going to remain 10 because 10 plus 1 becomes 11 and 10 minus 11 minus 1 again becomes 10 <sil=0.920> .PERIOD So <sil=0.458> ,COMMA regardless of the order in which the two ah expressions two sub expressions plus plus y and minus minus y get evaluated the final value of y will be 10 but what about the value of x <sil=0.967> .PERIOD Now <sil=0.476> ,COMMA the value of x as it turns out will vary depending on which of these two expressions is evaluated first right <sil=0.947> .PERIOD Note that plus plus and minus minus both have high precedence higher than that of the binary plus operator and higher also than the precedence of the assignment operator <sil=0.981> .PERIOD So <sil=0.349> ,COMMA therefore <sil=0.627> ,COMMA these are going to get evaluated before the plus operator but if you recall the C language is not specified for a plus operator which of the two operands is evaluated first and as it turns out in this example the answer for the final value of x will be different depending on which of these two is the case <sil=0.977> .PERIOD So <sil=0.470> ,COMMA let us assume that plus plus y happens first <sil=0.983> .PERIOD So <sil=0.452> ,COMMA if plus plus y is evaluated first then what happens after the evaluation of this expression the value of y becomes 11 and the value of this entire expression plus plus y is also 11 because remember this is free increment that is the instrument happens before the value of this expression is computed <sil=0.932> .PERIOD So <sil=0.538> ,COMMA the value of this expression is 11 and y has also changed to 11 and then the expression minus minus y gets computed which means that y gets incremented from 11 to 10 and the value of the expression minus minus y also is the final value of y which is 10 which means that x gets assigned 11 plus 10 this expression gets evaluated to 11 and this expression gets evaluated to 10 so the result is 21 <sil=0.983> .PERIOD Only other hand suppose minus minus y was to be evaluated first <sil=0.932> .PERIOD So <sil=0.606> ,COMMA that is it would result in the value 9 and 10 plus plus y when it gets evaluated results in the value 10 <sil=0.983> .PERIOD So <sil=0.629> ,COMMA the final value of x becomes 10 plus 9 that is 90 <sil=0.989> .PERIOD So <sil=0.434> ,COMMA in this case as you can see the final value of x will depend upon which of these two expression gets evaluated first and the C language does not specify as to which one will happen <sil=0.987> .PERIOD So <sil=0.365> ,COMMA except for these two operators these two exceptions you had noted in the last lecture we will come back these shortly except for these two operators C does not specify the order in which the operands of a particular operator are evaluated this is left to the compiler <sil=0.959> .PERIOD So <sil=0.550> ,COMMA which means that some compilers may evaluate the left hand operand first and some compilers may evaluate the right hand operand first <sil=0.975> .PERIOD And if you are using an expression in which the final result can vary depending on in which order depending on the order in which the two operands are evaluated then what that means is that depending on the compiler that is being used the result might be different <sil=0.904> .PERIOD So <sil=0.345> ,COMMA so construct like the one that we saw just now plus plus y plus minus minus minus y they are inherently ambiguous what that means is that they can be interpreted in two different ways which are not the same and therefore <sil=0.336> ,COMMA we must avoid them because our intent is only one of these two possible interpretations but on a different machine with a different compilers the same program may actually give a different result and so therefore <sil=0.386> ,COMMA these expressions and these construct should be strictly avoided <sil=0.913> .PERIOD For the logical and in the logical or operator the C language does define the order in which the two operands are evaluated and as a matter of fact the left operand is always evaluated first and the right hand operand is evaluated only if the result of the expression cannot be computed based only on the value of the left operand <sil=0.957> .PERIOD So <sil=0.539> ,COMMA if you remember that for the logical and operator if the first operand the left operand evaluates to hall then the entire expression must evaluate to hall because for it evaluate to true both the operand must be true <sil=0.960> .PERIOD So <sil=0.379> ,COMMA the first operand evaluates to hall then the second operand will not be evaluated at all and if the second operand happen to have some side effect and those side effects will not take place simply because the second operand does not get evaluated at all and similarly for the logical or operator if the first operand evaluates to true then regardless of the value of the second operand the entire expression will get the value true and therefore <sil=0.408> ,COMMA the second operand will not get evaluated at all and again if it has side effects then those side effects will not take place <sil=0.986> .PERIOD So <sil=0.395> ,COMMA therefore <sil=0.529> ,COMMA again with these operators one has to be careful as to what the final value of the various variables are going to be <sil=0.940> .PERIOD So <sil=0.314> ,COMMA let us take this simple example here x is initialized to 10 and y is initialized to 20 and we have when it is conditional if x plus plus or y plus plus <sil=0.975> .PERIOD So <sil=0.391> ,COMMA this is a logical or operator what is going to happen is at the first operand which is x plus plus is going to get evaluated first <sil=0.910> .PERIOD Now <sil=0.585> ,COMMA the value of x plus plus will be 10 because this is whole sentiment and of course <sil=0.543> ,COMMA the side effect is that the value of x becomes 11 <sil=0.944> .PERIOD So <sil=0.617> ,COMMA since the value of this expression turns out to be 10 which is non-zero and therefore <sil=0.361> ,COMMA consolidated as true <sil=0.976> .PERIOD So <sil=0.387> ,COMMA therefore <sil=0.416> ,COMMA the second operand need not be evaluated at all that is the expression y plus plus will not get evaluated at all <sil=0.948> .PERIOD So <sil=0.481> ,COMMA and the entire expression will result in the value true because the first operand evaluated to true <sil=0.971> .PERIOD So <sil=0.590> ,COMMA which means that the end of the evaluation of this entire expression will result will be true the value of x will become 11 and the value of y will remain 20 <sil=0.991> .PERIOD On the other hand if instead of the or logical or operator we had the logical and operator then what would have happened is that x plus plus is evaluated that result in the value 10 and x is implemented to 11 <sil=0.921> .PERIOD But since this is true the second operand must also be evaluated because if the second operand turns out to be false then the overall result will be false and if the second operand turns out to be true then the overall result will be true <sil=0.915> .PERIOD So <sil=0.367> ,COMMA y plus plus would also get evaluated in that case <sil=1.000> .PERIOD So <sil=0.340> ,COMMA y plus plus would of course <sil=0.556> ,COMMA result in the value 20 and y would get implemented to 21 <sil=0.947> .PERIOD So <sil=0.615> ,COMMA since both are true the overall result would be true but both x and y would get implemented in that case <sil=0.937> .PERIOD Similarly <sil=0.407> ,COMMA the order of evaluation of argument for a function called is not specified as e <sil=0.984> .PERIOD You know that we use several library functions in most of our program <sil=0.998> .PERIOD And when we first parameter or argument to be function the order in which these arguments are evaluated is again not specified by the C language it is up to the compiler <sil=0.975> .PERIOD So <sil=0.641> ,COMMA let see an example <sil=0.903> .PERIOD So <sil=0.457> ,COMMA here x has the x is a variable of type double with value 24 and the printer statement print 2 double number <sil=0.962> .PERIOD The percent f is used in print f to print double quantity <sil=0.969> .PERIOD The first quantity is x the value of expression x plus plus and the second quantity is the value of the expression square root x <sil=0.958> .PERIOD Now <sil=0.331> ,COMMA as I said the C language does not specify in what order these two operands are going to be evaluated <sil=0.952> .PERIOD Now <sil=0.562> ,COMMA suppose the argument x plus plus is evaluated first which means that x gets implemented to 25 and the value of this expression is 24 <sil=0.927> .PERIOD And so and then afterwards the square root x is computed <sil=0.903> .PERIOD Now <sil=0.577> ,COMMA here the square root of 25 will be computed because x has already become 25 <sil=0.973> .PERIOD So <sil=0.318> ,COMMA which will force the result in the value 5 and therefore <sil=0.447> ,COMMA the output will be 24 <sil=0.904> .PERIOD 0 for this parameter followed by 5 <sil=0.953> .PERIOD 0 for this value <sil=0.911> .PERIOD On the other hand if the square root x was evaluated first then that would be square root of 24 which will be something like 4 <sil=0.990> .PERIOD 89897 <sil=0.999> .PERIOD And then suppose the second parameter was to be evaluated that would again result in the value 24 because the evaluation of the first expression did not have any side effects x remained 24 <sil=0.981> .PERIOD So <sil=0.370> ,COMMA when this gets evaluated again the value is 24 and side effects is to increment x to make 25 <sil=0.982> .PERIOD So <sil=0.446> ,COMMA the output would be 24 <sil=0.927> .PERIOD 0 followed by 4 <sil=0.961> .PERIOD 89897 and not 5 <sil=0.968> .PERIOD 0 <sil=0.938> .PERIOD Okay <sil=0.615> ,COMMA so we have introduced many new operators in this lecture <sil=0.973> .PERIOD So <sil=0.304> ,COMMA here is the summary of the precedence and associativity rules <sil=0.979> .PERIOD As usual the precedence is decreasing from top to bottom <sil=0.905> .PERIOD The highest precedence operators are the unary operator <sil=0.931> .PERIOD We had seen the logical not the unary plus and unary minus in the last lecture and the instrument and decrement operators are the two new unary operator sets we have seen in this lecture <sil=0.974> .PERIOD So <sil=0.386> ,COMMA all these unary operators have the same precedence and they associate from right to left <sil=0.994> .PERIOD Then come the arithmetic operators multiplication division to mean the associativity is left to right <sil=0.948> .PERIOD Then the addition subtraction again left to right <sil=0.913> .PERIOD Then less than less than equal to greater than greater than equal to left to right again <sil=0.939> .PERIOD Then equals and not equals left to right <sil=0.953> .PERIOD The logical and the logical or both associate left to right <sil=0.992> .PERIOD And finally <sil=0.374> ,COMMA the assignment and assignment like operators like equals assignment plus equals minus equals star equals and so on <sil=0.960> .PERIOD Here is a little exercise at the end of this lecture <sil=0.905> .PERIOD Please look at this program <sil=0.982> .PERIOD You can out of it and try to find out what it does <sil=0.924> .PERIOD So <sil=0.520> ,COMMA you will see that the first parts are fairly straight forward <sil=0.979> .PERIOD We declare two variables N and P <sil=0.950> .PERIOD Please initialize to 1 <sil=0.924> .PERIOD The value of N is right from the terminal <sil=0.942> .PERIOD And while N is greater than 1 <sil=0.645> ,COMMA the loop is executed and the loop body is T star equal to N minus minus Cn equal and note that the star equal to is an operator <sil=0.991> .PERIOD And therefore <sil=0.521> ,COMMA this entire thing is an expression <sil=0.970> .PERIOD And therefore <sil=0.528> ,COMMA we are putting this Cn equal and after it <sil=0.498> ,COMMA we can use it as a simple three statement <sil=0.973> .PERIOD So <sil=0.368> ,COMMA try to figure out what this program is doing <sil=0.970> .PERIOD You will find that it does something very familiar <sil=0.959> .PERIOD So <sil=0.368> ,COMMA as a caution at the end of the lecture <sil=0.367> ,COMMA you have been introduced to many interesting operators which had effect <sil=0.956> .PERIOD And as you start using these operators <sil=0.337> ,COMMA you will find that the use of these operators can make the program very compact and elegant in many cases <sil=0.906> .PERIOD However <sil=0.340> ,COMMA over use of such operators is not advisable because if you use these operators too often <sil=0.388> ,COMMA you tend to make the expressions very very complicated and hard to understand <sil=0.971> .PERIOD So <sil=0.427> ,COMMA that will mean that the program itself can become very hard to understand <sil=0.974> .PERIOD And therefore <sil=0.302> ,COMMA of course <sil=0.361> ,COMMA one should strive to strike a balance between elegance and understandability <sil=0.980> .PERIOD In the last lecture we had talked about arrays and we saw how arrays can be used to store and systematically manipulate large number of data elements <sil=0.905> .PERIOD Today we will see another very useful constructed data type that known as strings <sil=0.972> .PERIOD Strings are useful for manipulating non-numeric information as we said in one of our earlier lectures one of the major powers of the computer drives from the fact that computers can deal not only with numeric information that is they can deal not only with numbers but they can also deal with information in a wide variety of other formats for example the text characters and sound and audio and so on <sil=0.970> .PERIOD So <sil=0.425> ,COMMA today we will look at strings which allow us to write programs that can deal with text characters in the input <sil=0.930> .PERIOD So <sil=0.312> ,COMMA essentially a string is a sequence of characters and in C when we want to declare a string variable we will declare it as an array of cars and the spatial property of the string as an array of cars is that it ends with an null character <sil=0.905> .PERIOD That is after the number of characters that we want to store in the array the next character that is stored is a null character which has as we call 0 and is also represented in the programs with this notation which is within codes backslash 0 and constant strings are represented as a sequence of characters and closed in the double codes characters <sil=0.942> .PERIOD So <sil=0.580> ,COMMA I said string variable would be declared as array of characters the size for the array that we need to declare should be at least one more than the maximum expected length of the string and that one more is required because the string will store not just the characters that you want to store in the string but also the terminating null character and therefore <sil=0.530> ,COMMA its length must be at least one more than the length of the maximum string that we expect to store in that array <sil=0.952> .PERIOD So <sil=0.482> ,COMMA here are a couple of examples of declarations of strings <sil=0.921> .PERIOD So <sil=0.567> ,COMMA the variable my name is a string width size 20 and so as you can see the theory is declared as an array of car of size 20 <sil=0.948> .PERIOD So <sil=0.582> ,COMMA this means that I can use this variable to store any string which has at most 19 characters followed by one null character and of course <sil=0.537> ,COMMA these variables can be manipulated just like other arrays can be but we will see that there are some special library functions and special notation for manipulating strings as a whole <sil=0.958> .PERIOD Similarly <sil=0.577> ,COMMA here is another string variable declared address which has the size 100 that means that it can have strings of length up to 99 <sil=0.948> .PERIOD Strings can be initialized just like arrays can be initialized as we saw in the last class <sil=0.935> .PERIOD One way of initializing a string variable is to initialize it using the notation that we use for initializing arrays that is we enclose the characters in the string within curly braces <sil=0.929> .PERIOD So <sil=0.465> ,COMMA in this example what is being done is that this variable my name is being initialized to a string which is my name deeper Gupta <sil=0.928> .PERIOD So <sil=0.625> ,COMMA I have created an array in this notation comprising of characters from my name and plus character is the null character <sil=0.963> .PERIOD Note that even though I have given the length of the array as 20 but the number of characters that will be specified here is actually much less the size of my name including the blank space is just 12 characters and including the null character that 13 characters <sil=0.900> .PERIOD So <sil=0.619> ,COMMA I have initialized only the first 13 elements of this array the remaining 7 elements are left uninitialized and here is another way of doing this this is special to strings this cannot be done with other kinds of arrays I could have initialized this to the string deeper Gupta by putting the string simply like this within double code and this has the same effect as earlier initialization <sil=0.917> .PERIOD Another thing is that in both these kinds of declarations I can leave out the array size and the compiler will automatically compute what should be the correct size <sil=0.995> .PERIOD In fact <sil=0.486> ,COMMA that is a general rule for initializing arrays in general for example <sil=0.326> ,COMMA if I declare an array as the following <sil=0.916> .PERIOD So <sil=0.443> ,COMMA in this case the compiler will automatically assign the size 2 to the array x and similarly in this case I could have initialized this variable in the following rotation without the following rotation without giving any size of the array over here and the compiler would automatically compute that there are 12 characters in the string plus one character is needed for the null character and so the array created would have size 13 characters <sil=0.935> .PERIOD Note that in this case the string would have size 13 and later on we would not be able to store any string in this array which is of size more than 12 characters whereas <sil=0.333> ,COMMA when we have explicitly declared the length as 20 then later on we can change this string and store in this variable a larger string up to the size of 19 characters <sil=0.933> .PERIOD So <sil=0.435> ,COMMA strings we have seen are the same as character arrays but with a difference you can have a array of characters with no null character anywhere in it <sil=0.991> .PERIOD Now <sil=0.521> ,COMMA the strings have a special property that they are character arrays but they are terminated by null characters that is the last character at the end of the string is a null character and this property is useful because this allows various library functions as we will see to find out what is the actual length of the string <sil=0.909> .PERIOD The actual length of the string should be carefully distinguished from the declared length of the array <sil=0.938> .PERIOD So <sil=0.492> ,COMMA for example <sil=0.477> ,COMMA when you want to print a string <sil=0.426> ,COMMA you want to print the actual number of characters in the string and not the entire array because some part of the array may not be getting used <sil=0.944> .PERIOD So <sil=0.458> ,COMMA this null character at the end of the other characters in the string is helpful in determining the actual length of the string and so when we say a string we actually mean a character array which is terminated by the null character <sil=0.998> .PERIOD As we will see there are several useful library functions for dealing with strings <sil=0.958> .PERIOD All of them assume that the strings even to them as input contain the null character that is the end with the null character <sil=0.995> .PERIOD So <sil=0.526> ,COMMA let us start seeing some of these useful library functions for dealing with strings <sil=0.945> .PERIOD Here is the first function which is the familiar scan F and we have seen how scan F can be to read integers and floating point numbers and so on so forth <sil=0.958> .PERIOD scan F as a matter of fact can also be used to read strings and all we have to do to read strings using scan F is to use the percent S specifier instead of the percent D specifier as for an integer or percent F for a float and so on so forth <sil=0.966> .PERIOD So <sil=0.332> ,COMMA in this example we have declared a string of size 20 and we are using scan F percent S to read a value into the string <sil=0.965> .PERIOD So <sil=0.438> ,COMMA first of all note that there is no M percent before the variable name my name in the scan F call this is different from the notation used for reading integers and so on <sil=0.956> .PERIOD The reason for this will become clear later on but the only thing you have to remember right now is that when you are reading strings you do not put the M percent here in the call to scan F <sil=0.985> .PERIOD So <sil=0.521> ,COMMA exactly what this scan F call will do is I will read characters from the input till a white space character is seen <sil=0.981> .PERIOD We call that white space characters are the blank character the tab and the new line characters and so on and whatever characters have been read till the first white space character was seen they will be assigned to the string variable and of course <sil=0.639> ,COMMA the scan F will also put it terminating null character after these characters in the string <sil=0.953> .PERIOD Now <sil=0.341> ,COMMA one question that you might ask is that what happens in this example if the world that is type of the user has more than 19 characters in it well in that case the string given will not fit in the string variable my name but will not the compiler will not be able to detect this happening at compile time or at runtime and therefore <sil=0.416> ,COMMA it is really the programmer's responsibility to ensure that this never happens and the string variable is large enough to hold the largest expected input that the user might case because if the string is not large enough then the results are really unpredictable <sil=0.964> .PERIOD So <sil=0.459> ,COMMA as we just saw scan F with the format specified percent S can be used to read a world from the input <sil=0.988> .PERIOD If you want to read an entire line from the input we can use the get S function instead and using the get S function is considerably simple simpler than using scan F all we need to do is to pass the string variable name as the argument to the get S function <sil=0.946> .PERIOD So <sil=0.473> ,COMMA this function will read an entire line of input and assign it to the string variable S and as usual it will put the null character at the end and once again the variable S must have enough space to hold the given input otherwise results are likely to be unpredictable <sil=0.992> .PERIOD Printing strings can again be done with the familiar function print F with the same format specified percent S that we used for scan F <sil=0.968> .PERIOD So <sil=0.411> ,COMMA print F percent S some string variable name will print that string on the output we will see an example of this in the example program that we take up today <sil=0.958> .PERIOD Alternatively <sil=0.468> ,COMMA put S can be used with the string variable as an argument <sil=0.918> .PERIOD So <sil=0.577> ,COMMA here are a couple of examples one of printing the same variable print F on this on the string one using print F function and the other using the put S function <sil=0.969> .PERIOD So <sil=0.537> ,COMMA the print F function we have used the format specified percent S and the corresponding argument is the name of the string variable and for put S the only argument is the string variable <sil=0.940> .PERIOD So <sil=0.608> ,COMMA these functions it is important to realize print the string till the null character is seen in the string <sil=0.956> .PERIOD So <sil=0.456> ,COMMA that is how they determine how much data to be pray how many characters are there to be printed <sil=0.917> .PERIOD If suppose the character array that is passed is argument be functions does not contain an in null character then again the result is going to be unpredictable and that should never be attempted <sil=0.979> .PERIOD Let us now look at some functions which are useful for manipulating strings <sil=0.971> .PERIOD There are no built in operators in C for dealing with strings for example <sil=0.342> ,COMMA for integers we have the plus minus and comparison operators and even assignment <sil=0.905> .PERIOD So <sil=0.649> ,COMMA all those kinds of operators are not there for strings <sil=0.944> .PERIOD Fortunately <sil=0.405> ,COMMA there are number of useful library functions that can be used for performing all these common operations on string and we will look at some of these string functions <sil=0.976> .PERIOD But first before using any of these string functions we need to put this statement at the top in our program just like we include S a D i O dot H to use the standard I O library functions we need to include the file string dot H in our program for using the string functions that we are going to look at soon <sil=0.924> .PERIOD So <sil=0.424> ,COMMA the first function that we are going to look at is the S T R length function <sil=0.374> ,COMMA where it is which can be used to find simply the length of the string and again note that it returns the actual length of the string and not the declared size of the array and the actual length of the string is the number of characters before the first null character in the string <sil=0.908> .PERIOD So <sil=0.599> ,COMMA in this example we have again declared a variable my name of size 20 and it is initialized to the string D perk which as you can see has 6 characters in this <sil=0.997> .PERIOD So <sil=0.347> ,COMMA if you call S T R length on the string my name it will return 6 <sil=0.928> .PERIOD We can also compare strings and the way to do that is to use the library function S T R C MP <sil=0.903> .PERIOD Now <sil=0.564> ,COMMA what a string comparison really mean when do we say that a string is larger than another string we say that a string is larger than another string if the first string would appear later in a dictionary as compared to the first string <sil=0.986> .PERIOD So <sil=0.393> ,COMMA this order is called the dictionary order or the lexical graphic order and function string compare or S T R C MP compares to given strings in this order <sil=0.959> .PERIOD So <sil=0.362> ,COMMA the arguments to S T R C MP are the two strings S 1 and S 2 that we need to compare <sil=0.958> .PERIOD This function returns 0 if S 1 is the same as the string S 2 and it returns a negative value if S 1 is less than the string S 2 meaning that S 1 would appear first in the dictionary as compared to S 2 <sil=0.953> .PERIOD Note that of course <sil=0.541> ,COMMA in the dictionary all the words have only alphabet characters whereas <sil=0.455> ,COMMA the strings S 1 and S 2 in general can have other characters as well <sil=0.956> .PERIOD So <sil=0.513> ,COMMA how do we compare two individual characters to determine which comes first in the lexical graphic order well a character is smaller than another character if it is F K code is smaller and as we have already seen that the F K codes of small a small b small c etcetera they are all contiguous they are one after the other <sil=0.915> .PERIOD So <sil=0.374> ,COMMA this ordering is consistent with the dictionary ordering and finally <sil=0.342> ,COMMA string compare S 1 S 2 returns a positive integer if S 1 is greater than in the dictionary order or the lexical graphic order than the string S 2 <sil=0.934> .PERIOD So <sil=0.341> ,COMMA this function can be used for comparing string there are some variance of this function for example <sil=0.634> ,COMMA S T R K C MP compared to string ignoring case that is whenever it is comparing to alphabetical character it ignored the case that is small a and capital A are treated as the same whereas <sil=0.564> ,COMMA the string compare function would treat them differently that is they would not be treated as equal <sil=0.979> .PERIOD The other useful string comparison function is S T R N C MP function where you can specify a third argument which is an integer to the function and this says that compare at most the first n characters of the strings S 1 and S 2 <sil=0.991> .PERIOD So <sil=0.424> ,COMMA here is a function which can be used to concatenate a string to another string the function name is S T R K C <sil=0.937> .PERIOD The arguments are two strings S 1 and S 2 and the result of calling this function S T R K C is at is that the string S 2 would be offended at the end of the string S 1 that is a string S 1 would change and at the end of it the string S 2 would be offended and naturally for this operation there must be enough extra space in S 1 to hold the concatenated string otherwise again the result will be unpredictable <sil=0.920> .PERIOD Here is a simple example <sil=0.956> .PERIOD So <sil=0.617> ,COMMA we have the variable X of size 20 containing the string just ABC which is of size length 3 of course and here is another variable string variable Y of size 10 which has a string D E F <sil=0.988> .PERIOD Now <sil=0.388> ,COMMA if you perform the operation S T R K at X comma Y then it will place the contents of the string Y which is the string D E F at the end of the string contained in X which is ABC <sil=0.959> .PERIOD So <sil=0.368> ,COMMA at the end of this operation the final value of X will be the string ABC D E F <sil=0.938> .PERIOD So <sil=0.344> ,COMMA if you note what is happening here is that the string X contained A followed by B followed by C followed by null character and the string Y contained the character T E F followed by the null character and the string concatenation operator would replace this null character by the first character with the string Y and then this will be followed by E F followed by F and then the null character will come at the end <sil=0.938> .PERIOD So <sil=0.467> ,COMMA finally <sil=0.454> ,COMMA the value of X will be the string ABC D E F <sil=0.914> .PERIOD We can also copy strings from one variable to another variable <sil=0.958> .PERIOD We cannot simply use assignment to do that in the case of strings as we do it for integers and so on <sil=0.979> .PERIOD We cannot say X assigned Y where X and Y are string variables <sil=0.952> .PERIOD In fact <sil=0.517> ,COMMA if you do that the compiler will give an error <sil=0.921> .PERIOD So <sil=0.427> ,COMMA if you want to copy strings from one variable to another you have to use the library function S T R C P Y which stands for string copies <sil=0.931> .PERIOD So <sil=0.629> ,COMMA S T R C P Y S 1 S 2 copies the string S 2 to S 1 and whatever the well whatever string the variable S 1 initially contained will be overwritten and S 1's length or S 1 size <sil=0.939> .PERIOD Must be at least as much as the length of S 2 plus 1 plus 1 because the null character also has to be stored <sil=0.984> .PERIOD And similarly <sil=0.420> ,COMMA we have the function S T R M C P Y and this has an additional argument N which is an integer <sil=0.985> .PERIOD This says copy at most N character from the string S 2 to the string S 1 <sil=0.994> .PERIOD So <sil=0.606> ,COMMA at the end of this lecture let us take a simple and develop a simple program to understand and reinforce the concepts that we have learnt in this lecture <sil=0.925> .PERIOD And this program is very simple what we are supposed to do is to read words from the input till the end of the input is reached and then we are supposed to the program is supposed to print the longest and the largest word in the input <sil=0.920> .PERIOD The longest word is the one which has the largest length and the largest word is the one which is lexicographically large at among all the words in the input <sil=0.973> .PERIOD So <sil=0.530> ,COMMA the algorithm is reasonably straightforward as you can imagine as long as we keep getting more words in the input we read a word and we compute its length and we compare it compare the length of this word with the length of the longest word that we have seen so far <sil=0.901> .PERIOD And if the length of this word is larger or long if this word is longer than the previous longest word then we replace the previous longest word with this word and we say it is length also <sil=0.964> .PERIOD So <sil=0.597> ,COMMA we say this word and it is length as the longest seen so far and similarly we maintain the largest word seen so far and if this word that we just saw is larger than the previous largest then we say this word as the largest <sil=0.999> .PERIOD So <sil=0.571> ,COMMA let us now put this algorithm into practice by writing a C program for this <sil=0.992> .PERIOD So <sil=0.452> ,COMMA here is the initial part of the program as you can see we have included the file string dot h as well because we are going to use some functions from the string library <sil=0.921> .PERIOD We have defined a constant max size which is equal to 20 which we expect to be the longest word size actually the longest word size we expect is to be 19 because one character as you know is a needed extra of storing the null character and these are the variable declarations <sil=0.907> .PERIOD This variable length we are going to use to store the length of the world that we have most recently seen <sil=0.982> .PERIOD The variable max length is the length of the longest word that we have seen so far and this is initialized to 0 <sil=0.909> .PERIOD So <sil=0.399> ,COMMA essentially what we are going to do is that we are going to compute the length of the world seen just now and compare it with max length and if length happens to be greater than max length then max length will become length and the longest word will become the one that we have seen so far <sil=0.902> .PERIOD And there are three string variables that we are declaring these are all of the size max size <sil=0.990> .PERIOD The first variable world will be used to store the world that we have most recently read in the loop <sil=0.929> .PERIOD The string longest will be used to store the longest word that we have seen so far and largest will be used to store the largest word that we have seen so far <sil=0.989> .PERIOD Recall how we are going to maintain the largest word seen so far we are going to compare every world with the previous largest word and if the current word is larger than the previous largest then the largest will become the current word <sil=0.981> .PERIOD So <sil=0.578> ,COMMA therefore <sil=0.444> ,COMMA we need to initialize this to some world which is smaller than any other world <sil=0.967> .PERIOD So <sil=0.507> ,COMMA that the very first world that we see becomes the largest at the end of the first iteration <sil=0.902> .PERIOD Now <sil=0.376> ,COMMA the smallest possible string that you can think of is the null string which has no correctness inside it <sil=0.936> .PERIOD So <sil=0.609> ,COMMA it is just contains the two double codes without anything between them <sil=0.903> .PERIOD And here is the rest of the program and you can see it is fairly straight forward all the way are using some new techniques in this program that I will explain <sil=0.984> .PERIOD So <sil=0.539> ,COMMA we are using scan F percent S to read a world as we already seen it reads a word from the input <sil=0.957> .PERIOD Now <sil=0.323> ,COMMA the question is that this loop must terminate when the end of the input has been reached <sil=0.954> .PERIOD Recall that the end of the input is typically indicated by the user to the program by typing a control D <sil=0.927> .PERIOD But how would our program know that there are no words <sil=0.533> ,COMMA no more words to be read from the input <sil=0.939> .PERIOD If we were using a function like get care that would have returned E O F on seeing the end of input <sil=0.985> .PERIOD But with scan F we will do something different <sil=0.945> .PERIOD In fact <sil=0.425> ,COMMA so far whenever we have been using scan F we are assuming that scan F only has side effects and scan F expression has no value <sil=0.940> .PERIOD In other words the scan F function does not return any value <sil=0.947> .PERIOD That is not actually true <sil=0.996> .PERIOD scan F function actually does return a value which we have been discarding so far in our program <sil=0.945> .PERIOD And the value returned by scan F is nothing but the number of items successfully assigned to some variables or the number of values successfully assigned to some variables <sil=0.983> .PERIOD So <sil=0.613> ,COMMA if you look at this particular use of scan F what we expected to do is to assign some value to the string variable world <sil=0.982> .PERIOD And therefore <sil=0.408> ,COMMA if scan F succeeds we expect where it should return the value 1 <sil=0.931> .PERIOD Now if it does not return the value 1 that could only mean in this case that the input really ended <sil=0.937> .PERIOD scan F actually returns E O F when the end of input is reached <sil=0.971> .PERIOD So <sil=0.529> ,COMMA we could have terminated this loop also by checking that the return value of scan F is not E O F which is actually minus 1 <sil=0.980> .PERIOD Note that when you are using scan F with some other format specified <sil=1.000> .PERIOD For example <sil=0.310> ,COMMA suppose you do scan F percent D ampersand X then scan F could return a value other than 1 <sil=0.981> .PERIOD In fact it could return 0 also which is neither 1 nor E O F and that would happen in the case when the input characters that were read actually did not form an integer that is they did not comprise of only digits and plus or minus sign <sil=0.913> .PERIOD So <sil=0.628> ,COMMA in that case also it would return something less than the number of items that we expect to be assigned <sil=0.958> .PERIOD And that in fact is a very useful feature which we have not been using really in our program so far whenever we so far in our program <sil=0.466> ,COMMA read an integer using scan F we assume that some integer was always read <sil=0.904> .PERIOD But that is not actually true <sil=0.997> .PERIOD Suppose instead of typing some integer the user types some arbitrary characters like X Y Z what happens in that case what is the integer value that is assigned to the variable <sil=0.938> .PERIOD In fact no value is assigned by scan F in that case and scan F just indicates that the input was not appropriate for the format conversion specified by returning a value by returning a value which could be less than the number of X Y Z to scan F <sil=0.989> .PERIOD And that is something that we should actually make a habit of checking that when we read an input integer from the input we actually successfully do read it <sil=0.926> .PERIOD So <sil=0.504> ,COMMA in the programs that will write from now on we will make a habit to put that into practice <sil=0.976> .PERIOD Anyway coming back to this program if we have read a word successfully then we use the string length function to find its length and store that in the integer variable length <sil=0.929> .PERIOD And if length is more than max length then as I said max length is assigned to length <sil=0.918> .PERIOD So <sil=0.629> ,COMMA that the next word whenever it is read its length can be compared to the new max length <sil=0.915> .PERIOD And the longest word is now the word that we just read and so string copy is used to assign or to copy the current word into the longest word <sil=0.989> .PERIOD So <sil=0.638> ,COMMA that takes your longest word and we also have to compare the current word with the largest word so far <sil=0.944> .PERIOD So <sil=0.505> ,COMMA we used the string compare function to check that <sil=0.973> .PERIOD So <sil=0.355> ,COMMA if S <sil=0.391> ,COMMA C <sil=0.521> ,COMMA R <sil=0.448> ,COMMA C <sil=0.570> ,COMMA P word comma largest is greater than 0 <sil=0.353> ,COMMA the S value which is greater than 0 that means that word is greater than largest <sil=0.908> .PERIOD And in that case we copy the current word into the largest word and at the end of this loop we simply print the longest word and the largest word using the familiar print F function note that we are using percent S to print these two string variables <sil=0.951> .PERIOD So <sil=0.438> ,COMMA that is the end of this lecture in the next lecture we will start looking at a very powerful facility in C and in fact in most programming languages and that is the ability to define our own functions <sil=0.991> .PERIOD When programs get considerably more complex than the simple ones that we have been writing so far then we need certain amount of discipline in how we design the program and how we implement the programs and we will see that it then becomes useful to break down the problem into smaller sub problems and so on <sil=0.946> .PERIOD And then define individual program units for each of those smaller sub problems these smaller program units are called functions and in fact we have been using library functions we will see how we can define our own function in the next lecture <sil=0.970> .PERIOD Thank you <sil=0.955> .PERIOD In today's lecture we will talk about a very important and useful feature provided by the C programming language and that is notion of structures <sil=0.963> .PERIOD So essentially the use of structures is that using structures you can put several pieces of related information at the same place in a single variable instead of spreading them around the program in different variables <sil=0.946> .PERIOD And so as you can see a structure is also a composite type because it is a structure is comprised of smaller units of data <sil=0.996> .PERIOD However the difference between an array and a structure is the following <sil=0.992> .PERIOD An array is also a composite type like structure except that all elements of an array are of the same type whereas with structures we can have different elements of different types <sil=0.949> .PERIOD The other difference between array and structure is that in areas the individual elements of the array are accessed using numerical index which is an integer whereas the different elements in structure are accessed by different names <sil=0.962> .PERIOD We can give different names to different elements and that makes it very useful <sil=0.944> .PERIOD And as I said the other difference is that the different elements of a structure can have different types whereas the elements of an array all have to have the same type <sil=0.958> .PERIOD So let us consider a simple example where we might want to use structures <sil=0.975> .PERIOD So because we are writing a program that is maintaining student records and so on and so we need to maintain various pieces of information about every student <sil=0.999> .PERIOD So we could define a structure for storing the information about the student in the structure declaration might look like this <sil=0.931> .PERIOD So this entire declaration defines a new type whose name is Strap Student <sil=0.942> .PERIOD The keyword Strap indicates that this is a structure that we are defining and the world student is a name for the structure type and then within the process follow the declarations of the various components of the structure and we can have arbitrary types <sil=0.905> .PERIOD So the first element in this case is name that is the name of the element which is store the name of the student and the type of this element is an array of 20 characters <sil=0.919> .PERIOD So that shows that can have arbitrary types inside the structure so the elements can really have any other type <sil=0.966> .PERIOD The next element of the structure is a field called role number which is of type end so this will probably be used to store the role number of the student and finally we have an array of two integers for storing maybe the exam marks of the particular student <sil=0.964> .PERIOD So if we look at such complex structure let us first create some examples involving simpler structure <sil=0.965> .PERIOD So suppose we need to write a program that deals with complex numbers <sil=0.929> .PERIOD So as you already know the complex number has two parts <sil=0.502> ,COMMA a real part and imaginary part and to represent a complex number essentially we need to store both these parts <sil=0.949> .PERIOD So the ideal representation of a complex number would be we have a single variable stores both these parts and so therefore we declare a struct complex which defines a new type for complex numbers and we can see that there are two elements or two fields of this structure with name <sil=0.483> ,COMMA real and image and both are of type float <sil=0.990> .PERIOD So this complex number will have two parts <sil=0.545> ,COMMA a real part and imaginary part which are both flotic point numbers <sil=0.962> .PERIOD So once you have a declaration like this you can now declare as many variables of this type as we want <sil=0.923> .PERIOD So this thing that declaration does not declare any new variables it just declares a new type <sil=0.961> .PERIOD This is the first time that you are seeing such a notion <sil=0.932> .PERIOD But once you have declared such a type so a tau struct complex is now available to us and we can declare any number of variables of this type <sil=0.937> .PERIOD So for example this declaration declares two variables C1 and C2 which are birth of type of complex which means that C1 as well as C2 will birth have their own real parts and their own imaginary parts <sil=0.981> .PERIOD Now we use the dot operator to access individual fields of its structure <sil=0.954> .PERIOD So obviously we are given a structure we need to be able to manipulate the different fields of the structure <sil=0.905> .PERIOD And the dot operator is used to obtain an element of structure given the structure itself <sil=0.937> .PERIOD So as an example let's assume the same structure complex declaration <sil=0.994> .PERIOD So let's say C1 is available which we have declared to be of type structure complex and now we can access it as well and imaginary parts as shown <sil=0.958> .PERIOD So essentially C1 dot real will denote the real part of the structure C1 and C2 C1 dot image will denote the imaginary part of the structure <sil=0.963> .PERIOD So essentially C1 is a variable which comprises of two boxes which are large enough to hold an integer <sil=0.983> .PERIOD And the names of these boxes you could think of as being C1 dot real and C1 dot image <sil=0.935> .PERIOD And as these assignment statements show these expressions can be used on either side of an assignment <sil=0.938> .PERIOD So C1 dot real is equal to 10 <sil=0.903> .PERIOD 53 would essentially assign the value of the real part of the structure C1 to 10 <sil=0.996> .PERIOD 53 and C2 dot image assign C1 dot image will copy the value of C1 dot image that is imaginary part of the variable C1 to the imaginary part of the variable C2 <sil=0.953> .PERIOD So C2 is also let's assume is of a similar type <sil=0.927> .PERIOD So this assignment statement will copy the value to this value <sil=0.935> .PERIOD So whatever this happened to be at say 5 <sil=0.985> .PERIOD 0 then this also becomes 5 <sil=0.984> .PERIOD 0 <sil=0.978> .PERIOD And as you can see the types of those expressions will be types declared for these fields <sil=0.944> .PERIOD So we had declared real to be of type float and image also to be of type float and therefore C1 dot real will have the type float and C2 dot image will also have the type float <sil=0.974> .PERIOD Now structures are full-fledged types and we can do all the usual kinds of operations that we can do with other types <sil=0.943> .PERIOD In particular we can pass structures as arguments and we can also write functions which return structures as return values <sil=0.957> .PERIOD So as an example for passing structures as arguments and returning structures as return values let's consider a function to add two complex numbers <sil=0.901> .PERIOD So we have a function add complex which is supposed to add two complex numbers <sil=0.986> .PERIOD There are two parameters C1 and C2 birth of type struct complex and the returns are also struct complex <sil=0.992> .PERIOD Now how do you add two complex numbers <sil=0.865> ?QUESTIONMARK Well that's very easy you just have to add up the real parts and the imaginary parts separately <sil=0.958> .PERIOD So that's where this function does <sil=0.971> .PERIOD It declares a local variable called sum of type struct complex and sum dot real is assigned value C1 dot real plus C2 dot real and sum dot image is assigned value C1 dot image plus C2 dot image and finally the value of sum is returned <sil=0.985> .PERIOD So here is a function add complex to add the two complex numbers <sil=0.934> .PERIOD It has two parameters C1 and C2 birth are of type struct complex that is C1 and C2 are birth complex numbers and the return type is also struct complex <sil=0.946> .PERIOD That is we are going to return another complex number from this function <sil=0.900> .PERIOD So it declares local variable called sum which is also of type struct complex and now to add C1 and C2 all we need to do is to separately add the real and imaginary parts and that's what this two lines of code are doing <sil=0.981> .PERIOD The variable sum after these two assignments will have the will represent the complex number C1 plus C2 <sil=0.942> .PERIOD So sum dot real is C1 dot real plus C2 dot real sum dot image is C1 dot image plus C2 dot image and finally function returns the value of sum which is C1 plus C2 <sil=0.943> .PERIOD Okay now one thing that we need to understand about structure as opposed to arrays are that structures are passed by value <sil=0.994> .PERIOD That is when a declared structure variable that variable represents the structure itself and not the address of the structure and therefore when structure is passed as an argument to a function its value is copied to the parameter and its value is nothing but the values of all its components for all of its fields <sil=0.917> .PERIOD So the values of all its fields are copied to the corresponding spaces in the parameter and this is different than for arrays as you know when you pass an array what is actually getting passed is starting at the array and not the values of the elements of the array <sil=0.995> .PERIOD And therefore the implication of the fact is that if the call function modifies the field of the parameter which happened to be a structure and the fact is not visible in the called function <sil=0.944> .PERIOD We will see an example using a variant of the complex function that we just saw and if you remember when structure is returned from a function a copy of its value is made and that copy is what is returned to the calling function <sil=0.917> .PERIOD So let us assume an example as the user's left to the different version of the complex function that we just saw so where we do not have a local variable sum and what is going on is the sum is being computed in the parameter 3 on itself <sil=0.992> .PERIOD So C1 <sil=0.987> .PERIOD Ruel plus U2 <sil=0.933> .PERIOD Ruel that means the value of C2 <sil=0.997> .PERIOD Ruel is added to the existing value of C1 <sil=0.985> .PERIOD Ruel and similarly C2 <sil=0.960> .PERIOD Ruel is added to C1 <sil=0.984> .PERIOD Ruel and finally the value of C1 is returned <sil=0.995> .PERIOD And this is how the function is getting called from the main program <sil=0.928> .PERIOD We have three local variables C1 <sil=0.551> ,COMMA C2 <sil=0.556> ,COMMA C3 of main and we call add complex C1 <sil=0.566> ,COMMA C2 and the return value is stored in the variable C3 <sil=0.945> .PERIOD So let us assume that the function add complex is called this is where the three variable C1 <sil=0.377> ,COMMA C2 <sil=0.352> ,COMMA C3 of the main function look like C1 have a real part and imaginary part and similarly C2 <sil=0.437> ,COMMA C3 and let us say C1 <sil=0.463> ,COMMA 5 plus 7 i and C2 is 6 plus 3 i and C3 is unvegized <sil=0.921> .PERIOD So when the function is called <sil=0.566> ,COMMA you know what happens first is that C1 is created for the parameters of the called function which in this case happen to be C1 and C2 <sil=0.976> .PERIOD So the first parameter C1 and parameter C2 of the function add complex has been created <sil=0.993> .PERIOD Next what is going to happen is that the values of the arguments are copied into the corresponding parameters <sil=0.963> .PERIOD So the arguments are expression C1 and C2 when C1 is evaluated <sil=0.348> ,COMMA it evaluates to the entire structure 5 and 7 and similarly when C2 is evaluated <sil=0.344> ,COMMA it evaluates to the structure containing 6 and 3 <sil=0.931> .PERIOD So when this copy happens <sil=0.569> ,COMMA this structure value is copied to C1 of add complex and this value of C2 is copied to the parameter C2 of add complex <sil=0.931> .PERIOD So C1 gets the value 5 plus 7 i and C2 all C2 gets the value 6 plus 3 i <sil=1.000> .PERIOD Now when this statement is executed <sil=0.490> ,COMMA C1 dot real is plus equal to C2 dot real <sil=0.975> .PERIOD We are executing within the function add complex and therefore C1 refers to this C1 and not to this C1 and similarly C2 refers to this C2 and not to this C2 <sil=0.923> .PERIOD So this statement will modify the real part of this C1 which is this value <sil=0.974> .PERIOD So this value will become 5 plus 6 at 11 and imaginary part will become 7 plus 3 which is 10 <sil=0.916> .PERIOD So the next step C1 dot real becomes 11 and in the next step C1 dot imaginary becomes 10 and finally the value of C1 is returned <sil=0.996> .PERIOD So when this value of C1 is returned <sil=0.617> ,COMMA this value will be copied into the variable which is going to hold the return value in this case C3 and so this copy is made and now the function add complex as returned <sil=0.971> .PERIOD So as you know this source for its local variables and parameters will be removed or DL located so these variables will now cease to exist and C3 has become the sum of C1 and C2 but the important point is that these changes to C1 did not affect the value of the variable C1 in the calling function <sil=0.967> .PERIOD Now let us look at some other operations on structures and the basic operation that we can do is that a structure can be assigned to a new structure variable of the same type <sil=0.904> .PERIOD So let us go in C1 and C2 are variables of type structure complex that is a complex number <sil=0.982> .PERIOD So this assignment is valid <sil=0.959> .PERIOD Note that the left hand side is a variable which is a structure type and the right hand side is also an expression which has the same structure type <sil=0.946> .PERIOD So the C1 assigned C2 is valid and whatever is the value of the complex number C2 that gets copied into the complex number C1 <sil=0.990> .PERIOD Again contrast goes with the arrows <sil=0.940> .PERIOD With arrows an arrow variable cannot appear on the left hand side of an assignment expression because an array variable as an expression denotes the starting address of the array and not the contents of the array itself <sil=0.997> .PERIOD And the starting address of an array is safe <sil=0.906> .PERIOD It is assigned by the compiler that can't be changed and therefore an array variable cannot appear on the left hand side of an assignment <sil=0.977> .PERIOD Therefore in the case of structures a structure variable represents the contents of the structure and not its starting address <sil=0.932> .PERIOD And therefore it can appear on the left side of an assignment like this <sil=0.946> .PERIOD So if C2 happened to have the value 5 plus 7i then after this assignment statement C1 will also have the value 5 plus 7i and this value gets copied here <sil=0.979> .PERIOD So let's now look at some more complex structures and the simple structures that we have seen <sil=0.927> .PERIOD So let's recall the student structure that we already saw <sil=0.937> .PERIOD Struct student will contain three fields near the student <sil=0.519> ,COMMA the role number and the two exam marks and let's assume that we declared a variable S of the abstract students <sil=0.957> .PERIOD Now what if S sort exam marks represent <sil=0.985> ?QUESTIONMARK S sort of exam marks represent this component of the structure S which is an array <sil=0.918> .PERIOD So therefore S sort of exam marks represent really a pointer to an array of two integers <sil=0.971> .PERIOD And so S sort of exam marks 0 and S sort of exam marks 1 will represent the two elements of this array <sil=0.966> .PERIOD Note that S sort of exam marks itself is an array and where S sort as for errors it represents the starting address of the array rather than the contents of the array <sil=0.980> .PERIOD So if you now happen to pass S sort of exam marks as an argument to a function then it is the starting address of this array which is being passed <sil=0.906> .PERIOD So remember look at the structure pictorially <sil=0.952> .PERIOD This is where it looks like it has an error S 22 character which is field called name <sil=0.953> .PERIOD And then it has a single integer called role number and then it has an array of two integers called exam marks <sil=0.997> .PERIOD And S is the name of the entire structure that is a variable <sil=0.956> .PERIOD And so therefore S sort of name is an error type it is an array of 20 characters and therefore the variable itself represents the starting address of this array <sil=0.996> .PERIOD This expression S sort name represents starting address of this array and again it cannot appear on the left side of an assignment because the starting address of this array is fixed <sil=0.975> .PERIOD So S sort of number can assign on the left side of an assignment because this represents just an integer variable this particular variable <sil=0.910> .PERIOD And so this could be assigned to the value 123 or whatever as it happens to be <sil=0.992> .PERIOD And similarly S sort exam marks represents an array and therefore the starting address of that array <sil=0.938> .PERIOD And so the usual rules for arrays will apply whereas for S sort of role number the rules for integers would apply <sil=0.904> .PERIOD Okay now we can also have structures inside structure <sil=0.937> .PERIOD So we can have one structure type as a field or a component of another more complex structure type <sil=0.956> .PERIOD As an example consider a program that deals with geometric objects <sil=0.970> .PERIOD So for this program we need to represent we need types to represent points <sil=0.609> ,COMMA lines and so on so forth <sil=0.993> .PERIOD So we could represent a point by just its xy coordinate <sil=0.960> .PERIOD So here is a declaration for a structure which represents a point <sil=0.972> .PERIOD Now a line perhaps is represented by two end points or a line segment is represented by two end points which are birth points <sil=0.932> .PERIOD So this structure contains two fields P1 <sil=0.454> ,COMMA P2 which are of type struct point <sil=0.977> .PERIOD So therefore if you look at the pictorial representation of your line it will have inside it two structures called P1 and P2 and these in turn contain two fields each so called x and y <sil=0.433> ,COMMA x and y <sil=0.936> .PERIOD So now if we have declared L as a variable of struct line then L dot P1 represents this entire structure and therefore L dot P1 dot f represents the x part or the x coordinate of this particular point P1 of the line L and similarly L dot P2 dot y will represent the y coordinate of the second end point of the line and so on so forth <sil=0.940> .PERIOD We could also have arrows of structure not only could we have structures containing arrows but we could also have arrows of structure and the structure itself in turn could actually have other areas within them <sil=0.993> .PERIOD So you can see that using these kinds of building blocks we can build some very complicated data structure <sil=0.972> .PERIOD So let us sum that to the student structure that we were talking about earlier <sil=0.915> .PERIOD Now suppose a program needs to maintain records of all the students in a particular class <sil=0.930> .PERIOD So we probably need to maintain these two in records of the various students in a array <sil=0.979> .PERIOD So where we have declared an array called my students which is a self-hundred and the self of each element of the array my students is struct student <sil=0.988> .PERIOD So therefore my students is an array each of whose element is a student structure and so for example if I have this expression my students I dot well number <sil=0.992> .PERIOD So my students I will be the I have element of the array my students which happens to be a student structure and therefore my students I will dot well number the notes the role number of the I have student in this array and similarly my students I dot name what represent the name of the I have student and so on so forth <sil=0.996> .PERIOD We can also of course have pointers to structures like we can have pointers to other kinds of variables and these pointers to structures work in the same way that pointers to other kinds of variables work <sil=0.950> .PERIOD So for example suppose we have a variable C1 of type struct complex and what we are declaring here is a variable P which is of type struct complex star and what that means is that P as a type which is a pointer to a struct complex and now what we are doing is star P1 dot well assigns and so what does this mean this should be star P not star P1 <sil=0.945> .PERIOD So star so P is a pointer to a structure and so therefore star P represents that structure and therefore star P by real represents the real of the field called real of that structure <sil=0.929> .PERIOD So in terms of a picture this is what is really happening here the C1 variable C1 is a structure with a real part and an imaginary part and a variable P is a pointer which points to this structure C1 and so star P will represent this structure and where star P dot well will represent this field of this structure and that is getting assigned the value 10 <sil=0.965> .PERIOD So this assignment statement causes C1 dot real to become sen because P points to the variable C1 and therefore star P dot real represent the same thing as C1 dot real <sil=0.954> .PERIOD Now this is a very common operation that I would have do as an pointer to obtain the structure to be the pointer point and then refer to a particular field of that structure <sil=0.987> .PERIOD So these two are applied together C provides a shortcut so the operator error will conclude that the operator error will be the same as C1 dot real <sil=0.975> .PERIOD So this is what we use it P error will use exactly the same as C1 dot real so we could have written this statement as P error real assign 10 and of course we could also have used it on the right hand side of an assignment and so on so forth <sil=0.905> .PERIOD Okay having looked at structures you will wrap up this lecture by briefly talking about input and output from file <sil=0.959> .PERIOD So far we have been doing all our input output from the terminal that is all the inputs that the program expected the user had type and the terminal and all the output again went back to a terminal <sil=0.913> .PERIOD Now in general when we are writing programs that require large number of inputs and the output is also volume in us we want the program to be able to directly read in right file instead of expecting all the input from the terminal and that of course can be done and there is actually very similar to the way input and output is done from the terminal we will shortly see the library function for doing that but the basic difference between IO from a terminal and IO from a file is that before we can read or write a file from our C program we need to search and it first <sil=0.978> .PERIOD And when we open a file what we get is what is known as a file handle <sil=0.312> ,COMMA a handle for a file or in C it is also called a file pointer <sil=0.961> .PERIOD The type of group file pointer or file handle in C is file star file is a type which is defined by the standard IO library of C and file star is a type for the file handle which is returned to us when we open a file and now once we have once we have opened the file and obtained a file handle for the file then we can read or write to the file depending on how the file was opened and whenever we want to read or write the file we need to specify the file handle for the file instead of the file name for the file in every call <sil=0.947> .PERIOD When we open the file that is the only time that we really specify the file handle for the file name for the file and finally when the program is finished reading or writing the file it should close the file again by specifying the file handle we will see the function to do all this in the next slide <sil=0.906> .PERIOD So first for opening the file is easy you need to use the F open function of the standard IO library <sil=0.938> .PERIOD There are two arguments the first is a string which is the name of the file that we wish to open and the setting is a mode again string which represents the kind of operations that we are going to read do to the file <sil=0.956> .PERIOD For example are we going to read the file or write the file and so on so forth and the return type is file star which as we have seen is the name is the type for the file handle <sil=0.993> .PERIOD Now the verb should be a string containing the characteristic R if you want to read the file it should be W if the file is to be written <sil=0.958> .PERIOD So this the file W as the mode for the file that means that the file will be created automatically if it does not already exist and if it already exists then whatever data it already contain will be deleted and whatever now this program writes will be the only surviving contents of the file <sil=0.909> .PERIOD So that means the existing contents of the file will be removed and whatever the data that our program writes to the file that will override the existing contents <sil=0.995> .PERIOD And if you don't want to go right if you don't want to delete the existing contents of the file we can open the file for appending by specifying string containing A as the mode and in that case whatever data the program writes will be appended to the file <sil=0.922> .PERIOD And of course the green of the file does not already exist and the file will be created <sil=0.990> .PERIOD But when we know to go when we want to read the file then the file must already exist otherwise it will be an error and we will not get a proper file handle <sil=0.958> .PERIOD So whatever reason to file cannot be opened <sil=0.907> .PERIOD For example we are trying to open it for reading in the file does not exist or if we are trying to open the file for writing and we don't have permission to write to the file or maybe the file does not exist and we don't have permission to create the file and so on or maybe we are trying to read the file and we don't have permission to read the file <sil=0.949> .PERIOD If anything wrong and the file cannot be opened then after that returns a social pointer value null which will also have occasion to see in the next lecture this is a very useful pointer value <sil=0.904> .PERIOD But essentially this is a social pointer value it does not point to any legal memory location <sil=0.934> .PERIOD So the pointer is that whenever we open a file we must check the file handle that has been obtained and if that is equal to null that means we are not able to successfully open the file and so we should print a error message in the program should exit if that is what is appropriate <sil=0.961> .PERIOD So once we have obtained the file handle to a file with a now use this file handle for doing actual IO on the file and the function for reading and writing files as you will see are very similar to the ones for reading and writing from the terminal <sil=0.941> .PERIOD For example we have the S-Pen-F function which is actually the same as it can function that we have already seen <sil=0.990> .PERIOD So the S-Pen-F function reads from the terminal whereas the S-Pen-F function reads from a file <sil=0.967> .PERIOD The only difference in the argument is that the first argument has to be the file pointer and then before matching as usual the format thing has exactly the same meaning as in the S-Pen-F <sil=0.905> .PERIOD Then the function S-Pen-F is again the same as the function gets our for reading one character from the terminal <sil=0.949> .PERIOD The file for return three is sent to return one character from the file and the argument is the file pointer <sil=0.952> .PERIOD S-Pen-F is the equivalent of the getters function <sil=0.964> .PERIOD You set the file pointer to and character array where the data has to be read <sil=0.971> .PERIOD Now there are two additional arguments in this case <sil=0.900> .PERIOD The third argument is the file pointer and the second argument is the size of the array which has been specified here and the F-Pen-F function ensures that no more than this many bytes are actually returned to this array <sil=0.999> .PERIOD Otherwise of course as you know there is an array of points bound violation <sil=0.990> .PERIOD The better function does not actually check that array of points violation <sil=0.962> .PERIOD For adding to a file the functions are again similar to the functions for writing to the terminal <sil=0.981> .PERIOD The F-Pen-F function is actually the same as the printer function except there is an extra for argument which is the file pointer of the file to which we want to write <sil=0.961> .PERIOD This file pointer must be opened for writing or for a pending <sil=0.960> .PERIOD Similar to the put-clare function we have the F-Pen-F function which takes a character and additionally a file pointer of the file to which this character has to be written <sil=0.979> .PERIOD The F-Pen-F function is the equivalent of the put-F function which writes a string to a particular file <sil=0.951> .PERIOD And finally the F-Pen-F function is used to close a file as I said once the program is finished reading or writing the file it should properly close the file and you use the F-Pen-F function for doing that <sil=0.970> .PERIOD All the unit will specify ESD file handle or the file pointer as the argument <sil=0.968> .PERIOD Okay so this will be end of this lecture but before we start here is a simple exercise for you to try using the concepts that we have learned in the last couple of lectures <sil=0.976> .PERIOD So the file is to write a program that will read an insert file name and an output file name from the terminal that is the user will type the name of the input file and the output file <sil=0.935> .PERIOD The insert file is supposed to contain two written records of the type that just saw one for line <sil=0.957> .PERIOD So the program will read the student records from the file <sil=0.947> .PERIOD So this is what the records the whole number using the sorting algorithm that we have already seen and finally write the sorted student records in the order of the whole number to the output file <sil=0.932> .PERIOD In the next lecture we will talk about another very important technique in programming and that's a technique of dynamic memory allocation which allows us to overcome some of the limitations of arrays <sil=0.907> .PERIOD In the last lecture we had talked about the technique of recursion for problem solving and we saw that essentially using recursion a function can call itself and we can exploit this capability by defining the solution to a given instance of a problem in terms of a simpler instance of the same problem and we saw several examples of using recursion for solving simple problem <sil=0.997> .PERIOD Today we will talk about how recursion actually works and what happens really when a function calls itself and how the what is really happening inside the machine when a function is calling itself and all the whole thing works <sil=0.948> .PERIOD Let us first recapitulate what happens when a function is called by another function <sil=0.997> .PERIOD So recollect when a function is called the following things happen <sil=0.416> ,COMMA base is created for the local variables in parameters of the function which is being called <sil=0.920> .PERIOD The parameters are initialized with the values of the corresponding argument and the return address in the calling function is told <sil=0.940> .PERIOD What we mean by return address is the place in the calling function where control will go back once the called function returns and this is just the statement or part of the expression following the function calls <sil=0.990> .PERIOD And when a function returns the space which had been created for the for the local variables in parameters of this function that is destroyed the control goes back to the told return address where it was supposed to go back in the calling function and the return value of the function is used as the value of the call expression <sil=0.933> .PERIOD Now with recursion exactly the same thing happens when recursive call is made there is no difference in terms of the kind of things happening when the when a normal non recursive call is made <sil=0.909> .PERIOD But the important thing to understand is that in the case of recursive function multiple instances of the same function may be simultaneously acted <sil=0.917> .PERIOD What that means is the following consider for example the factorial function <sil=0.998> .PERIOD And you call factorial n let us assume we have defined factorial recursively as we saw in the last lecture <sil=0.939> .PERIOD So when factorial n is called before this this instance of the call to the factorial function finishes that is before it returns a call is made again to the factorial function this time with the parameter n minus 1 and before that finishes again a call is made to the factorial function with the parameter n minus 2 and so on <sil=0.978> .PERIOD So at the same point in time is possible that multiple instances of the factorial function or of the whatever the recursive function is they are simultaneously active that is they are not yet finished <sil=0.930> .PERIOD Of course only one is currently executing but the others are suspended and waiting for the call function to return <sil=0.982> .PERIOD Now each has instant has its own copy of local variables parameters and they return at it <sil=0.988> .PERIOD In other words if factorial n was called and that call factorial n minus 1 that call factorial n minus 2 and so on for each of these instances of the factorial function which are simultaneously active each will have its own copy of the parameter n there were no local variables in the definition and also of the return address where the control is supposed to go back once that instance of the of this is called the factorial function return <sil=0.963> .PERIOD So all these things the local variables the parameters and the return address for a particular function call instance are stored in what is known as a stack frame for the function and it will become clear shortly why it is called a stack frame <sil=0.913> .PERIOD So essentially at runtime what is known as a function called stack is maintained by the system <sil=0.995> .PERIOD So it is a stack of a stack frame what you mean by a stack is what you normally mean by a stack in English usage a stack is essentially a pile of things placed one on top of the other and when you want to remove something from the pile you remove it from the top of the pile and when you place something on the pile you place it on the top of the pile <sil=0.905> .PERIOD So the function call stack is similar <sil=0.902> .PERIOD So let us say the function f called the function g and f itself was called by the main function <sil=0.913> .PERIOD So the function call stack will capture this stack <sil=0.903> .PERIOD So each element in the stack is a stack frame so at the bottom is the stack frame for main and on top of that is the stack frame for f and on top of that is the stack frame for the now the stack frame for any function will contain space for the local variables of the function parameters of the function and the return address from the function where control is supposed to go back once the function returns <sil=0.996> .PERIOD So let us now see in terms of an actual recursive function what is really happening at runtime <sil=0.978> .PERIOD So the example I have taken is the print function from the last lecture which print say given integer n <sil=0.916> .PERIOD So let us assume that the main function calls print with the parameter value minus 123 and let us say the control is just before the call to the print in print function in main <sil=0.971> .PERIOD So at this point in time this is what the stack looks like <sil=0.922> .PERIOD Only the stack frame for main is on the stack we are not concerned too much about what it really contains will be more concerned with what the stack frame for the print in function contain and this arrow points to the stack frame at the top of the stack this called the stack pointer and as functions get called the stack frame will get pushed on top of the stack and so the stack pointer will move upward and when function return the stack frame will be removed from the stack and the stack pointer will move downwards <sil=0.946> .PERIOD So in the first step when the call to the print in function is made what will happen is that a stack frame for the print in function will be created and that will contain space for the parameter n there are no local variables of this function and the value of n in the stack frame will be initialized to the value of the argument being passed to this function which in this example happens to be minus 123 <sil=0.969> .PERIOD In addition the stack frame will also contain the return address where control is supposed to go back once this invocation of the function print in return <sil=0.969> .PERIOD Now print in print is being called from this location in the function main and once print in return execution should continue at the next statement <sil=0.906> .PERIOD So I am calling this location in the program as R1 so when main calls printed the return address told in the stack frame for print in will be R1 and that indicates where the program should resume execution once the print in function return <sil=0.911> .PERIOD So when the function print in the call the stack frame for the function print in has been created as you can see it has space for the parameter n of the function print in and the return address is R1 which happens to be dislocation in the program and the value of n is minus 123 which was the argument which was passed to the function and the control has gone to the first statement in the print in function <sil=0.928> .PERIOD So let us now trace the execution of the print in function for this value of n and see exactly how the recursive calls are going to work <sil=0.963> .PERIOD So the first statement is if n is less than 0 <sil=0.981> .PERIOD Now n is minus 123 which is indeed less than 0 so this condition value is to true so the control goes back to the goes to the next to the first statement in the then part of the if statement which is put care the minus sign and so when we do this in the output the minus character will appear nothing else changes so that is all that happen and then the next statement is n assign minus n when that execute of course the value of this n here just changes to plus 123 so that what happens <sil=0.961> .PERIOD Now the next statement checks if n is less than n which of course in this case is false so we start executing the body of the L part <sil=0.960> .PERIOD Now here is recursive call to the print in function now again what is going to happen is that a stack frame for this call to print in will be created that will also have space for n and for the return address and the value of n for that call to print in will be the value of this expression which is being passed as the argument now the value of this expression happens to be 123 divided by n which is 12 so the stack frame which gets created will have space for another instance of the parameter n which will have the value 12 and that will be the top top stack frame and the return address will be this address R2 because once this call to print in return the control is supposed to come back here and execute this put care statement which follows the call to the print in function <sil=0.906> .PERIOD So that is what happens when this function is called and of course as soon as the function gets called apart from the stack frame etcetera being created control will again go back to the first statement of the print in function <sil=0.936> .PERIOD So this is what happens this is the new stack frame which has been created note that it also has a parameter n here but this time it is it has the value 12 which is the argument which was passed from the previous invocation of print in and the return address is also different the return address is this location R2 and now we are executing we have started to execute another instance of the function print in while this previous instance is still not finished that is what happens in the question <sil=0.929> .PERIOD So again we start executing this call but but note that the value of n is now the n in the top most stack frame and which is 12 at this point in time and the value of n is no longer 123 <sil=0.961> .PERIOD So even though in the program it is the same n but at runtime these are two different n because each instance of the function call has its own copy of the local variables and the parameters <sil=0.936> .PERIOD So let us see so again the control will slow the same way since n is not less than 0 and is 12 in this case so this statement is kept and is not less than 10 so we start executing the as part and again there is a recursive call to print in with the argument n by 10 <sil=0.962> .PERIOD Now this n now evaluates to 12 because that is the value of n in the top most stack frame so whenever local variable or a parameter is accessed its value is the value for that variable or parameter in the top most stack frame even though below that stack frame there may be other stack frame for the same function which also have the variable n or which have also the same variable or the parameter <sil=0.914> .PERIOD So the value of n here is currently 12 and n by 10 would evaluate therefore to 1 <sil=0.992> .PERIOD So again the same thing happens when this time print in this call to curfably a new stack frame is created which space for n and return address for return address is again R2 because again the print in has been called from this location and therefore when it returns the control should come back to this statement R2 and once again the function start getting executed from the beginning now for a value of n is equal to 1 <sil=0.946> .PERIOD So again n is not less than 0 but n is less than 10 so put care n plus 0 that means put care the as he code of 0 plus 1 which gives the as he code of 1 and so the put care statement results in the character 1 being printed on the output and this L part is of course skipped and the control goes to the end of the function <sil=0.903> .PERIOD Now the function has finished or to be more precise this instance of the function execution has finished and the function is about to return <sil=0.953> .PERIOD Now when the function is going to return what going to happen is that this stack frame is going to be destroyed or it is going to be popped off from the stack this will again become the top most stack frame and the control will go back to the location R2 in other words to this location which is the statement immediately following the call to print in the calling function which also happened with print in this case <sil=0.963> .PERIOD So when this instance of print and return that is what happened the stack frame for the top most print is destroyed and control goes to the return address which was stored in that stack frame <sil=0.924> .PERIOD So we are now again executing the second instance of the print in function which was suspended when it made recursive call to itself <sil=0.920> .PERIOD So now the value of n here in this expression is again 12 because the top most stack frame is this one and that has a value of 12 for n <sil=0.958> .PERIOD So when this state when this put care statement executes n percent n gives value to that plus the sq code of 0 gives the sq code of the character 2 and put care print stack character on this screen and now this instance of the function is also about to return and when the return happens again the same thing happen this stack frame will be deleted this stack frame will become the top stack frame and control will go back to this return address which again is the address of this put care statement <sil=0.927> .PERIOD So that is what happened now we are back in the very first invocation of the print in function the value of n is now again 123 that gets printed that is divided by 10 and the remainder comes out to be 3 plus sq code of 0 gives the s code of 3 that gets printed and this invocation of print is also now about to return and this time when the return happens the control will go back to the location r1 which is the end of the function main <sil=0.948> .PERIOD So the main function will return or if there was some other statement in the main function after print end then those statements who have started executing and the stack frame for main would now become the top most stack frame <sil=0.974> .PERIOD So the function has returned so finally we are back in the main function all invocations of the print end including all recursive invocations have finished and the output is minus 123 as expected <sil=0.935> .PERIOD Okay let us now take another very interesting problem which can be solved very elegantly using recursion and which is actually quite difficult to solve without using recursion this is like a puzzle and it is called the problem of 3 towers of annoying <sil=0.972> .PERIOD So essentially in this problem you have these 3 towers let us call them 12 and 3 and initially in the within the tower number 1 there are these end disks which are placed on top of the other each disk has a hole within it so it can be put inside the tower and the disk at the bottom has the largest diameter and the diameter is decreasing as we go up <sil=0.902> .PERIOD So this picture shows 3 disks but in general there could be any number of so we assume that there are end disks in general <sil=0.975> .PERIOD Now the task is to move these end disks from tower 1 to tower 3 and in one move what can be done is that the top top most disk from any tower can be removed and it can be placed on top of the stack on any other tower but we have to always follow the constraint that a larger disk can never be placed on a smaller disk <sil=0.984> .PERIOD Now this actually appears to be a very difficult problem and for large values of n it can be actually very difficult to solve if you try hard you might be able to obtain a solution for n equal to 3 but you will find that as the value of n becomes larger the solution becomes harder and harder to obtain and without using without thinking about recursion in general algorithm is not all that is to obtain but let us think about this problem using recursion <sil=0.904> .PERIOD So the task is to move end disks from some tower s to some tower d and this third tower is there because so that we can place some disk on this tower during the process as an intermediate stop for these disks <sil=0.935> .PERIOD So from the tower s to the tower d we have to move these end disks <sil=0.968> .PERIOD Now how can we do that <sil=0.939> ?QUESTIONMARK If you think about it recursively well the base case is simple the base case is when n is equal to 1 and when n is equal to 1 all we have to do is take the disk from the tower s and place it on the tower d that is not a problem at all but if n is more than 1 then let us think about this problem recursively <sil=0.931> .PERIOD So suppose n is more than 1 <sil=0.919> .PERIOD Now suppose somehow by magic the top n minus 1 disk can be moved from the can be moved from one tower to the another to another tower somehow and of course that somehow is is not really mysterious it can be achieved by using recursion <sil=0.993> .PERIOD So the first step is to recursively move the top n minus 1 disk from the tower s to the tower t that is the temporary tower using the tower d as an intermediary <sil=0.981> .PERIOD So whenever we want to move some disk we have to specify one intermediate tower where disk can be stored on their way to the final destination <sil=0.955> .PERIOD So suppose somehow we are able to do that that is we are able to move the top n minus 1 disk from the source to the temporary tower using the destination as a temporary <sil=0.938> .PERIOD So suppose somebody allows us to do that or shows us how to do this step then the next step is to move this bottom disk from the source to the destination <sil=0.915> .PERIOD So this is an easy step this we can always perform and finally now again the task is to move these two disks from this intermediate tower to the final destination tower and for this move we can use now this original source as an intermediate tower because it is it is now empty <sil=0.956> .PERIOD Now again how do we move these two disks from here to here it is a simpler instance of the same problem so we can use recursion <sil=0.979> .PERIOD So let us assume that by doing recursion we can do that but once you do that you can see that the problem is finished and we have obtained the solution <sil=0.993> .PERIOD So as you can see using recursion the solution to this problem is extremely simple to obtain as a matter of fact <sil=0.978> .PERIOD So let us write a program to do this <sil=0.937> .PERIOD So I have written this function move which which solves the tower of an OI problem it has four parameters and is the number of disks which have to be moved S is the source tower which could be 1 2 or 3 and B is the destination tower which could again be 1 2 or 3 and T is the intermediate tower or the temporary tower <sil=0.945> .PERIOD So initially if the disks are in tower one and they have to move to the tower three then we will call this function as move value of n whatever the number of disks is 1 comma 3 comma 2 the source is 1 the destination is 3 and the time 3 or the intermediate tower is 2 <sil=0.978> .PERIOD So this is the base case if n is equal to 1 then we just print the move to move the top disk source to destination directly this can be complete in a single step otherwise when n is greater than 1 we use recursion <sil=0.993> .PERIOD So first move n minus the top n minus 1 disk from the source to the temporary using the destination D as the intermediate <sil=0.990> .PERIOD So at the end of this step the configuration will look something like this is the source this is the destination and this is the temporary <sil=0.996> .PERIOD So the top n minus 1 disk have been moved to the temporary and then move a disk from source to destination so this disk goes here and finally move these n minus 1 disk from the temporary to the final destination these three disks go here <sil=0.946> .PERIOD So that is all <sil=0.968> .PERIOD So the solution is actually extremely simple once you think about it you can see <sil=0.940> .PERIOD And limit is an exercise for you to trace the solution using the technique that you just saw for the printin function and convince yourself actually for small values of n like 2 or 3 that it does work correctly by tracing the sequence of the recursive function calls and creating stack frames and putting values of the parameters and so on <sil=0.981> .PERIOD So that is the end of this lecture in this next lecture we will continue our discussion on recursion and talk about some situation where we should not use recursion and how we should not use recursion in appropriately or inefficiently because as we will see it is easy often to write programs which are extremely inefficient when not written properly using recursion <sil=0.915> .PERIOD In the last lecture we had talked about expressions and operators with side effects <sil=0.924> .PERIOD In today's lecture we will discuss a very important aspects of all programs that is input and output <sil=0.999> .PERIOD We have already seen how basic input and output of data is done in the simple program that we have written so far <sil=0.922> .PERIOD Today we will go into some more details of how input and output is done in C <sil=0.957> .PERIOD So <sil=0.378> ,COMMA C has no built-in primitive or statements for input and output <sil=0.947> .PERIOD For all input and output that is I O we have to use library functions <sil=0.977> .PERIOD We have already seen several of these library functions in action <sil=0.931> .PERIOD For example <sil=0.633> ,COMMA we have seen scan s for reading values from the terminal and print s for printing some output on the terminal <sil=0.913> .PERIOD In this lecture we will restrict our system to input and output only from the terminal although in general programs need to read data from and write data to files as well <sil=0.986> .PERIOD But we will discuss that in later lecture <sil=0.981> .PERIOD Today we will restrict ourselves to input and output from the terminal only <sil=0.973> .PERIOD But as we will see using something called I O redirecting facilities of UNIX we can actually use the same techniques to do simple input and output from files as well <sil=0.952> .PERIOD So <sil=0.635> ,COMMA the two library functions for input that we will discuss today are scan s and get the scan s we have discussed also we have seen examples of usage of scan s already and the output library functions that we will discuss today are print s and put cards <sil=0.947> .PERIOD Again print s we have seen some examples of <sil=0.952> .PERIOD So <sil=0.484> ,COMMA let us start with the print f function as you know this is used to print some data on the terminal <sil=0.904> .PERIOD We have seen several examples of usage of this function <sil=0.979> .PERIOD The first argument is what is known as a format string which specify essentially what is going to be printed on the screen and how it is going to be formatted <sil=0.914> .PERIOD The format string may contain ordinary characters like alphabets and numerals or other special characters which are printed as they are on the screen as they appear in the format string <sil=0.902> .PERIOD Plus we can have escape sequences such as that flash and for the new line character and so on <sil=0.934> .PERIOD And when you go to print some values whose actual value is not part of the string what is specified by some expression which is an additional argument to print f we use what is known as a format conversion specifier which starts with a person character in the format string <sil=0.987> .PERIOD The person character specifies that a value to be printed is supplied as an additional argument to the printer function and the character following the person character in the format string specifies what is the type of the value and how it is to be printed <sil=0.944> .PERIOD So we have already seen examples of person D when we use person D in the format string of printers then the argument which follows is assumed to be of type int and it is printed like an integer <sil=0.946> .PERIOD If you want to print an unsigned int we should use person U in set and similarly person LD for long person UL for unsigned long person S3 for short person S U for unsigned short person S for double person LF for long double and so on <sil=0.937> .PERIOD The person C specifies that the corresponding argument is of type integer but it is not to be printed as an integer but the character whose SQ code is this integer that character should be printed <sil=0.954> .PERIOD We will see examples of this and since percent has a special meaning in the format string if we want to print the person character itself we can use percent percent to indicate that we want to print 1 percent character <sil=0.945> .PERIOD So here is a simple example which demonstrates some of these specifiers that we have seen <sil=0.934> .PERIOD So in this example we have several variables <sil=0.912> .PERIOD The variable C is a type care and is initialized to the character A remember that a variable of type care is actually an integer and the value assigned to the character C in this initialization is the ac code of the character capital A <sil=0.939> .PERIOD i is a variable of type integer with the value 5 x is a double with value 5 <sil=0.938> .PERIOD 0 y is a float of with value 10 <sil=0.995> .PERIOD 0 <sil=0.929> .PERIOD We call that literal constants of this type have by default a type double and we have put an F of rate to indicate that we want this value to be of type float <sil=0.934> .PERIOD Now here is a print of statement and this first argument here is the format string <sil=0.968> .PERIOD Now this has a percent C percent F percent F and since there are 4 format conversion specifiers percent C percent F and percent F they have to be 4 arguments <sil=0.915> .PERIOD Now the first argument corresponds to the first argument following the formatting that is corresponds to the convergence specifier percent D and so therefore it should be of type int we have given the expression here as simply i which means that the value of i will be printed as an integer that is the value 5 will be printed and then the next specifier is percent C which means we want a character to be printed and the corresponding argument that is the second argument following the following the format string has to be of type int and it should be the as he code of the character that we want to print <sil=0.901> .PERIOD Now he happens to be of type care actually but what is expected is a length <sil=0.926> .PERIOD So therefore we have to explicitly say that we want this value to be converted to a value of type integer <sil=0.929> .PERIOD So that is why this ink within the bracket indicates that we want this explicit type conversion to be done <sil=0.991> .PERIOD This is also called type quotient <sil=0.952> .PERIOD They have already seen that in expression sometimes automatic type conversion happens if the operands of a operator happen to be of different type and so on <sil=0.914> .PERIOD Sometimes you also need to explicitly perform type conversion in this case it is called type quotient <sil=0.974> .PERIOD The third argument is x which corresponds to the percent f here and percent f requires the corresponding argument to be of type double which x is so that is all right but the next one is again percent f which means that we have to supply a double what we want to print is y which is of type flow and so therefore we have again explicitly converted this value to double by doing a type quotient here <sil=0.906> .PERIOD So these two are examples of type quotient <sil=0.940> .PERIOD So what will the output look like <sil=0.861> ?QUESTIONMARK Well this percent d in format string will get replaced by the actual value of this integer i which is 5 and then after that the character corresponding to the as he code <sil=0.410> ,COMMA the character whose as he code is supplied as the next argument will be printed that happens to be a <sil=0.900> .PERIOD So a is printed note that there is no blank between 5 and a because there is no blend between percent d and percent c in the format string and after that the two double values will be printed which are 5 <sil=0.980> .PERIOD 0 and 10 <sil=0.908> .PERIOD 0 <sil=0.956> .PERIOD So it is important to understand at this point in time what exactly is going on when we are using printers <sil=0.950> .PERIOD Now it comes out that when we do input and outsource that input and outsource can always only be in terms of characters only characters can be printed on a terminal <sil=0.992> .PERIOD So that means that to print anything on the terminal the terminal must be sent a sequence of characters that is as he codes of characters and the corresponding characters are what will what what are going to be printed on the terminal <sil=0.973> .PERIOD So therefore if you want to print the integer 50 then we have to send two bytes to the terminal the as he codes for the character 5 followed by the as he code of the character 0 <sil=0.915> .PERIOD So as he code of character 5 happens with the 53 and as he code of the character 0 happens to be 48 <sil=0.921> .PERIOD Therefore to print the integer 50 actually two bytes which are 53 followed by 48 have to be sent to the terminal but internally the integer i is represented as the binary equivalent of the decimal number 50 <sil=0.924> .PERIOD So this conversion has to happen and this conversion is what is being done by the useful library function print s <sil=0.978> .PERIOD And the the the way it performs the conversion it is guided by the conversion specified <sil=0.916> .PERIOD For example <sil=0.397> ,COMMA pretend he says that an integer is specified and it has to be converted to a sequence of bytes corresponding to the digits in that integer <sil=0.937> .PERIOD Okay let us now come to a simpler output function that is the put care function <sil=0.930> .PERIOD So this function can be used instead of print s when we want to print just one single character on the terminal and we would usually prefer to use put care instead of print s because put care is usually faster <sil=0.974> .PERIOD So if what we want to print is just a single character we can use put care instead of print s <sil=0.980> .PERIOD The argument to print to put care is an integer of type int which must be the fc code of the character that we want to print <sil=0.995> .PERIOD So for example <sil=0.601> ,COMMA we want to print x on the terminal then we can use this kind of statement <sil=0.917> .PERIOD Put care within rackets int followed by within code x <sil=0.913> .PERIOD Now this within code x remember denote the fc code of the character x but the type is care since put care expects an integer as an argument we have explicitly converted it to an integer before supplying it to put care <sil=0.921> .PERIOD So this statement will print x on the terminal <sil=0.955> .PERIOD Let us now look at the scan f function for reading input from the terminal scan f is the analog of print f or input <sil=0.942> .PERIOD Again the input is in terms of character only <sil=0.909> .PERIOD Now what we type on the keyboard when we are supplying input as a user are characters for example when I type 5 and 0 what is actually being sent to the program is a sequence of 2 bytes which is the fc code of the character 5 followed by the fc code of the character 0 <sil=0.939> .PERIOD Now if I want this value 50 to be stored in integer variable we must convert this sequence of fc codes into the binary equivalent of the decimal number 50 <sil=0.998> .PERIOD So this reverse conversion is what is being done by the scan f function <sil=0.907> .PERIOD The use of scan f we have seen earlier in examples it is fairly similar to print f the first argument again is the format string which specified how the input is to be converted whether we expect an integer or a real number or whatever it is and the remaining argument specified where that is in which variable this input data is to be stored <sil=0.955> .PERIOD So the conversion specified code nf are fairly similar to those for print f with some minor differences <sil=0.952> .PERIOD For example <sil=0.629> ,COMMA certainly read an integer <sil=0.998> .PERIOD Now what that means remember is that it reads fc code it reads characters and expects characters which constitute an integer <sil=0.905> .PERIOD For example an integer really means that you should have optionally a plus or minus sign followed by a sequence of digits and scan f what it does is it reads characters keeps initial wide-space characters <sil=0.581> ,COMMA wide-space characters are like the blanks are the new line characters on the tab character and it starts converting once it finds a character which could be sparked off an integer <sil=0.915> .PERIOD So it plus or a minus sign or a or a a a a inumoral and then it keeps reading till it reaches the end of the number and then converts the sequence of write as read so far into a single integer and a sign set or source set in the variable which is supplied as the corresponding argument for the conversion specified <sil=0.911> .PERIOD In this case <sil=0.358> ,COMMA the argument must be a pointer to a variable of type int <sil=0.995> .PERIOD We have not really discussed what pointers are <sil=0.995> .PERIOD We will discuss that in subsequent lectures later on <sil=0.497> ,COMMA but a pointer to a variable essentially is obtained by pre-sixing the M-perfect sign before the variable name <sil=0.933> .PERIOD So <sil=0.462> ,COMMA in usage of KF as we have already seen that the argument subsequently for matching are M percent followed by some variable name <sil=0.964> .PERIOD So <sil=0.427> ,COMMA this M percent is required because the argument must be a pointer to a variable of the appropriate type <sil=0.974> .PERIOD So <sil=0.389> ,COMMA in this case <sil=0.621> ,COMMA I must be an integer and we have to use first M percent I as the argument for KF corresponding to presently <sil=0.964> .PERIOD There are minor differences from the printf specified <sil=0.909> .PERIOD For example <sil=0.519> ,COMMA percent X is first load instead of double and percent L S is used for double instead <sil=0.930> .PERIOD Similarly <sil=0.555> ,COMMA for percent C because corresponding argument must be a variable <sil=0.374> ,COMMA must be pointed to a variable of type KF not int <sil=0.962> .PERIOD And in this case <sil=0.481> ,COMMA what happens is that Sennheff read-se character and assign it value which is the acicode of the character to the variable which has been specified <sil=0.972> .PERIOD Note that no character's escape in this case as opposed to when reading an integer <sil=0.306> ,COMMA when reading an integer <sil=0.643> ,COMMA the initial white space character's escape <sil=0.936> .PERIOD But when you when you are reading a character <sil=0.550> ,COMMA no character's escape because even white space characters are characters <sil=0.995> .PERIOD So <sil=0.432> ,COMMA if the first character type was a blank space for example <sil=0.550> ,COMMA the variable will be assigned as ac code of the blank character <sil=0.958> .PERIOD The get-car function is similar to the put-car function <sil=0.937> .PERIOD It can be used when we want to just read a single character from the input <sil=0.938> .PERIOD There are no arguments <sil=0.381> ,COMMA the return value which means the value of the get-car expression is off-site int and it is simply the ac code of the next character in the input <sil=0.973> .PERIOD So <sil=0.619> ,COMMA for example <sil=0.644> ,COMMA if you want to read just one character from the input <sil=0.328> ,COMMA we declare a variable X off-site int and use the Sennheff and assignment statement X to sign get-car <sil=0.927> .PERIOD This will read the next character from the input and assign it as a code to it <sil=0.933> .PERIOD Note that when a character has been read from the input <sil=0.541> ,COMMA the next time when we call get-car again <sil=0.435> ,COMMA it will return the next character in the input <sil=0.948> .PERIOD That is the character which is read here has been in some sense consumed by get-car <sil=0.989> .PERIOD So <sil=0.479> ,COMMA when we call get-car again or indeed scan F or any other function for reading from the input <sil=0.443> ,COMMA then this character since it has already been consumed is no longer available <sil=0.973> .PERIOD So <sil=0.371> ,COMMA for example <sil=0.536> ,COMMA if we use a type X Y Z and then we call get-car three times <sil=0.621> ,COMMA then we successfully get the ac code for the character of X Y and Z <sil=0.904> .PERIOD One important point to note is that the variable which is used to store the return value of get-car must be of type int always <sil=0.989> .PERIOD We will come to the reason why this is so in a little while <sil=0.412> ,COMMA but never use a variable of type-car or something else to store the result of get-car <sil=0.925> .PERIOD Okay <sil=0.425> ,COMMA let us now use what we have learnt today to write a couple of simple programs <sil=0.948> .PERIOD In the first example is particularly simple <sil=0.944> .PERIOD All you have to do is to write a program which copies its input to output <sil=0.945> .PERIOD That is whatever is the input <sil=0.315> ,COMMA the output is exactly the same <sil=0.917> .PERIOD So <sil=0.490> ,COMMA the way we are going to write this program is fairly simple <sil=0.971> .PERIOD We are going to use get-car to read characters again and again <sil=0.447> ,COMMA we will call this in a while loop <sil=0.941> .PERIOD Till the end of input is reached and for each character red <sil=0.410> ,COMMA we will use put-car to output-it <sil=0.905> .PERIOD Now <sil=0.451> ,COMMA how do we know that the end of input has been reached <sil=0.996> ?QUESTIONMARK We will know that when get-car returns this special value <sil=0.600> ,COMMA UF <sil=0.956> .PERIOD UF stands for end of file <sil=0.963> .PERIOD So <sil=0.465> ,COMMA this indicates the end of end of the terminal as well <sil=0.984> .PERIOD And on the terminal <sil=0.565> ,COMMA how does the user indicate that he finished giving the input when he does that by typing control D online by itself <sil=0.876> ?QUESTIONMARK Now <sil=0.318> ,COMMA the reason as I said earlier <sil=0.586> ,COMMA the return value of get-car should be stored in a variable of type integer is that the value UF is minus 1 <sil=0.984> .PERIOD It is a negative value <sil=0.942> .PERIOD So <sil=0.643> ,COMMA that is why it must be stored in an integer <sil=0.977> .PERIOD Okay <sil=0.441> ,COMMA so let us now see this program and try to execute it <sil=0.986> .PERIOD Okay <sil=0.423> ,COMMA here is the program <sil=0.955> .PERIOD Very simple program <sil=0.315> ,COMMA but there are some structure points about this program <sil=0.925> .PERIOD So <sil=0.578> ,COMMA we declare a variable of type int <sil=0.458> ,COMMA we call the variable C <sil=0.911> .PERIOD This will hold the correctors that we read from the input 1 by 1 <sil=0.937> .PERIOD And this loop says read a character <sil=0.590> ,COMMA if it is not end of file <sil=0.496> ,COMMA use put-car to print the same correctors <sil=0.963> .PERIOD Note that we have used an expression with side effect in this particular loop condition <sil=0.935> .PERIOD So <sil=0.324> ,COMMA if you look at this particular expression <sil=0.529> ,COMMA C assign get-car <sil=0.510> ,COMMA what it does is that it calls get-car to get the s-code of the next character <sil=0.587> ,COMMA that is assign to the variable C <sil=0.944> .PERIOD And the value of this expression itself is the value that has just been assigned to the variable C <sil=0.970> .PERIOD Now <sil=0.359> ,COMMA that value is what is compared against UF <sil=0.918> .PERIOD And effect value is not UF <sil=0.461> ,COMMA that is end of file has not been read <sil=0.998> .PERIOD Then we use put-car to print the character C <sil=0.958> .PERIOD So <sil=0.451> ,COMMA this is a very common idiom and this often simplifies the loop condition to use assignment to a variable and then compare the value that has just been seen with something else <sil=0.971> .PERIOD Okay <sil=0.616> ,COMMA so let us now run this program <sil=0.993> .PERIOD I have already compiled this <sil=0.961> .PERIOD So <sil=0.618> ,COMMA let us hear some input <sil=0.952> .PERIOD You can see that we have type several characters <sil=0.562> ,COMMA but no output has appeared so far <sil=0.978> .PERIOD Output will appear as soon as we press return character <sil=0.952> .PERIOD As soon as we press return character <sil=0.319> ,COMMA you see that all the characters that we have typed so far they appear on the output exactly the same as they were in the input <sil=0.982> .PERIOD Let us give some more input <sil=0.949> .PERIOD And when we want to indicate the end of file <sil=0.425> ,COMMA we can simply press control D on the line by itself <sil=0.904> .PERIOD That will cause get-car to return the UF value and which will terminate the loop and the program will accept <sil=0.913> .PERIOD Okay <sil=0.403> ,COMMA now we have written this program to read input from the terminal <sil=0.531> ,COMMA but unique as a facility called input output read direction using which we can make the program believe that it is input is actually coming from the file <sil=0.946> .PERIOD So <sil=0.413> ,COMMA for example <sil=0.323> ,COMMA if we use this notation to execute the program <sil=0.442> ,COMMA we need some input file to let us say copy <sil=0.934> .PERIOD c itself <sil=0.993> .PERIOD Then the contents of the file copy <sil=0.997> .PERIOD c which is the program that we just wrote has been printed on the screen <sil=0.910> .PERIOD So <sil=0.317> ,COMMA what is happening in this case is that the input is coming from this file <sil=0.996> .PERIOD The program does not need to change in order to do that <sil=0.941> .PERIOD The operating system ensures that when the program reads from what it believes is a terminal <sil=0.301> ,COMMA the input actually comes from the file <sil=0.998> .PERIOD And of course <sil=0.548> ,COMMA the file does not contain- does not need to contain the control D character because the file has a finite length <sil=0.972> .PERIOD And when it finishes <sil=0.346> ,COMMA the end of file is indicated to the program by the operating system automatically <sil=0.908> .PERIOD So <sil=0.321> ,COMMA this way we can actually- we can write any program that is expected to take input from the terminal and we can supply input from the file insects <sil=0.944> .PERIOD And similarly <sil=0.440> ,COMMA we can actually redirect the output of the program to a file instead of the terminal <sil=0.996> .PERIOD So <sil=0.460> ,COMMA for example <sil=0.539> ,COMMA suppose we do something like this <sil=0.922> .PERIOD So <sil=0.461> ,COMMA in this case what we are saying is this greater than sign says that the output of the program is being redirected from the terminal to a file called XXX <sil=0.964> .PERIOD That is whatever the program prints as output will not appear on the terminal but will go in this file insect <sil=0.902> .PERIOD So <sil=0.447> ,COMMA let us see if some input <sil=0.990> .PERIOD You see that it does not appear on the terminal at all <sil=0.982> .PERIOD And if you see now <sil=0.432> ,COMMA we already have a file called XXX <sil=0.978> .PERIOD We can see what the contents of this file are <sil=0.968> .PERIOD This is exactly what we type as the input <sil=0.944> .PERIOD And in fact <sil=0.353> ,COMMA we can combine both input and output redirections <sil=0.991> .PERIOD Let me first delete the file XXX <sil=0.965> .PERIOD We can actually combine the input and output redirections both so that the input comes from a file and the output goes to a different file <sil=0.908> .PERIOD If we do that <sil=0.615> ,COMMA we can actually use the program that we just wrote in a very useful manner to copy files <sil=0.931> .PERIOD So <sil=0.626> ,COMMA for example <sil=0.617> ,COMMA we want to make a copy of the file copy <sil=0.949> .PERIOD c <sil=0.905> .PERIOD We can do this like this <sil=0.922> .PERIOD So <sil=0.481> ,COMMA what we are selling the operating system in this case is that when the program copy is run <sil=0.498> ,COMMA its input should actually come from the file copy <sil=0.911> .PERIOD c and its output must go to the file copy2 <sil=0.985> .PERIOD c <sil=0.902> .PERIOD Of course <sil=0.321> ,COMMA you must not use the same file name for both the input and the output redirection that will just corrupt both the files <sil=0.909> .PERIOD So <sil=0.351> ,COMMA if we just do this <sil=0.423> ,COMMA you see that there is nothing better for you from the terminal <sil=0.904> .PERIOD And we did not have to give any input either <sil=0.902> .PERIOD But the file copy2 <sil=0.972> .PERIOD c now contains a copy of the file copy <sil=0.909> .PERIOD c <sil=0.910> .PERIOD So <sil=0.458> ,COMMA we can use as you have seen the copy program <sil=0.586> ,COMMA this very simple program that we wrote to see the contents of a file by doing input redirection <sil=0.940> .PERIOD We can use it to enter some contents into a file by doing output redirection and we can use it to copy <sil=0.371> ,COMMA make a copy of the file into another file by doing both input and output redirection <sil=0.980> .PERIOD So <sil=0.527> ,COMMA as we saw <sil=0.584> ,COMMA one of the observations that you made by me cooking this program is that for input from the terminal <sil=0.309> ,COMMA the program receives the characters only after the user ends the line <sil=0.959> .PERIOD We saw that as soon as we type the character it ends up here again on the output that is because the program received all the characters that we typed only after we ended the line by pressing the enter key <sil=0.990> .PERIOD And similarly <sil=0.396> ,COMMA although it is not really apparent from this execution <sil=0.352> ,COMMA the output also appears only after a new line is printed by the program <sil=0.992> .PERIOD So <sil=0.427> ,COMMA this is called buffering which is done by the operating system <sil=0.973> .PERIOD And we have seen that programs have read input from the terminal and print output to the terminal can be used with files easily using the IOD direction facility of Linux <sil=0.972> .PERIOD In later lectures <sil=0.614> ,COMMA we will discuss in more detail how the program can directly work with file because in many cases the simple IOD direction is not sufficient <sil=0.938> .PERIOD The program may want to open and read several files and write different outputs to different files and so on <sil=0.364> ,COMMA which is the simple IOD direction facility is not sufficient <sil=0.323> ,COMMA but we will come to that in a later lecture <sil=0.989> .PERIOD Okay <sil=0.309> ,COMMA here is the example too <sil=0.922> .PERIOD We want to write a program which counts the number of characters <sil=0.602> ,COMMA the number of words and the number of lines in the input <sil=0.967> .PERIOD How do we do that <sil=0.961> ?QUESTIONMARK The idea is very similar to what we have just seen <sil=0.929> .PERIOD We again read the input character by character <sil=0.901> .PERIOD How do we count the character <sil=0.907> ?QUESTIONMARK That is quite easy <sil=0.927> .PERIOD For each character that we read <sil=0.500> ,COMMA we increment the character count by 1 <sil=0.577> ,COMMA which of course initialize to 0 <sil=0.960> .PERIOD For each new line character that we see <sil=0.538> ,COMMA that is the back flash and within code <sil=0.331> ,COMMA that is how we will use it in our program <sil=0.996> .PERIOD We instrument the line count by 1 <sil=0.961> .PERIOD So <sil=0.631> ,COMMA we are maintaining a word count <sil=0.558> ,COMMA the character count <sil=0.345> ,COMMA line count and three different variables <sil=0.333> ,COMMA all three initialize to 0 <sil=0.950> .PERIOD For each character see <sil=0.615> ,COMMA we increment the character count by 1 <sil=0.620> ,COMMA for each new line character that we see <sil=0.361> ,COMMA we increment the line count by 1 <sil=0.464> ,COMMA but what about words <sil=0.850> ?QUESTIONMARK Well <sil=0.407> ,COMMA we will assume that the words are separated by white space character <sil=0.942> .PERIOD Between two words <sil=0.501> ,COMMA there must be some white space character <sil=0.914> .PERIOD Any number of white space character <sil=0.301> ,COMMA remember white space characters are blank <sil=0.327> ,COMMA characters <sil=0.380> ,COMMA the tab character and the new line character <sil=0.917> .PERIOD So <sil=0.646> ,COMMA how do we count the words <sil=0.902> ?QUESTIONMARK Well <sil=0.455> ,COMMA what we are going to do in this program is that we are going to instrument the word count when a new word starts <sil=0.956> .PERIOD Now <sil=0.311> ,COMMA when does the new word start <sil=0.948> ?QUESTIONMARK A new word starts when we see a non-white space character followed by a white space character <sil=0.999> .PERIOD That means that a new word has started <sil=0.634> ,COMMA where white space character of course is a blank or a new line or a tab <sil=0.964> .PERIOD Or a world also starts if the first character in the input itself is a non-white space character <sil=0.970> .PERIOD For example <sil=0.302> ,COMMA if the input starts with the character X <sil=0.497> ,COMMA then a word has started <sil=0.374> ,COMMA so we must count that as 1 <sil=0.942> .PERIOD Which means that in addition to storing the current character that we are costing right now <sil=0.528> ,COMMA we must keep track of whether or not the previous character was a white space character <sil=0.904> .PERIOD Because if what we have just seen is a non-white space character <sil=0.538> ,COMMA then we must instrument the count only if the previous character was a white space character and not otherwise <sil=0.950> .PERIOD Because if we have a blank followed by X followed by Y <sil=0.403> ,COMMA then when we see the X <sil=0.611> ,COMMA we should instrument the word count <sil=0.999> .PERIOD But when we see the Y <sil=0.348> ,COMMA we must not instrument the word count because it is not part of a new word <sil=0.991> .PERIOD So <sil=0.494> ,COMMA how do we keep track of whether the previous character that we saw was a white space character or not <sil=0.900> ?QUESTIONMARK Very easy <sil=0.369> ,COMMA we can use the Boolean variable to keep track of that <sil=0.957> .PERIOD So <sil=0.309> ,COMMA we will use this Boolean flag to keep track of whether the previous character was a white space character or not and we will have to initialize it properly <sil=0.998> .PERIOD Initially <sil=0.611> ,COMMA it will be true because if the first character itself is a non-white space character <sil=0.508> ,COMMA we must assume that it is starting a new word and therefore <sil=0.412> ,COMMA count 1 <sil=0.983> .PERIOD So <sil=0.463> ,COMMA we will initialize it to true and subsequently it will be true or false depending on whether the previous character that we saw was a white space character or not <sil=0.981> .PERIOD Okay <sil=0.411> ,COMMA so let us look at this program now <sil=0.960> .PERIOD Here is the program <sil=0.368> ,COMMA this is slightly more complicated program <sil=0.915> .PERIOD So <sil=0.494> ,COMMA note that I have put a large comment which describes what the program does <sil=0.910> .PERIOD We are going to use of course <sil=0.341> ,COMMA integer values 1 and 0 as to a false <sil=0.970> .PERIOD So <sil=0.478> ,COMMA we have as for our usual practice put defines for true and false <sil=0.986> .PERIOD Okay <sil=0.541> ,COMMA and here the main program start <sil=0.432> ,COMMA start there are three variables <sil=0.646> ,COMMA line <sil=0.547> ,COMMA cache and count <sil=0.473> ,COMMA line <sil=0.393> ,COMMA cache and words <sil=0.913> .PERIOD These are the counts of the lines and the characters and the words that we have seen so far <sil=0.953> .PERIOD They are all initialize to 0 <sil=0.972> .PERIOD Now <sil=0.606> ,COMMA this instance is the Boolean variable that we are talking about and this is meant to be true initially and when the previous character that was seen was a white space character <sil=0.953> .PERIOD Remember that a Boolean variable can be implemented by using a neat digit type <sil=0.977> .PERIOD So <sil=0.646> ,COMMA we have chosen to use a type cache <sil=0.504> ,COMMA we could have used a neat or a short instead that would be perfectly fine too <sil=0.967> .PERIOD So <sil=0.570> ,COMMA instances will be true if the last character scene was a white space character and it will be true initially otherwise it will be false <sil=0.944> .PERIOD And this variable C of type int of course <sil=0.520> ,COMMA is variable that will hold the ac code of the character that we have just seen <sil=0.990> .PERIOD The loop condition looks very similar to what we had for the copy program <sil=0.458> ,COMMA read a character and compare it with end of file <sil=0.920> .PERIOD If we get the end of file as a result of calling cache then the loop terminate otherwise C is assigned the character that we have just seen and we switch to execute the loop body <sil=0.967> .PERIOD So <sil=0.477> ,COMMA now the first thing that we do is increment the character count we are seen one more character <sil=0.934> .PERIOD So <sil=0.395> ,COMMA immediately increment the number of characters that we have seen so far and if what we are seeing is a new line character then we increment the number of lines seen so far <sil=0.955> .PERIOD That part is very easy <sil=0.977> .PERIOD What remains is to figure out whether this is a new word which is starting or not and appropriately update the in-space Boolean variable <sil=0.974> .PERIOD So <sil=0.427> ,COMMA for doing that we need to first figure out whether the character that we have just seen is a white space character or not <sil=0.983> .PERIOD So <sil=0.485> ,COMMA if C is equal to the blank character or the tab character or the new line character then we have just seen a white space character <sil=0.904> .PERIOD In this case we need to set in-space to true <sil=0.996> .PERIOD Note that it might have already been true because the previous character we saw might also have been a white space character but that does not really matter whenever we see a white space character in-space must be true in the next iteration so that is why we are making it true <sil=0.900> .PERIOD Otherwise if we have seen a character which is not a white space character now we have to decide whether this is the starting of a new word or whether it is the continuation of an old word and the distinction between the two is that a new word is starting if the previous character was a white space character in other words if in-space was true earlier then this is the starting of a new character of a new word <sil=0.955> .PERIOD Note that in this case we have not changed in-space to true <sil=0.917> .PERIOD We have changed in-space to true in this iteration only if this character was a white space character and of course a character cannot be both a white space character and an on-white space character <sil=0.980> .PERIOD So <sil=0.604> ,COMMA if in-space is true that means that what we have seen is either the first character in main input or the previous character was a white space character and now of course in-space should become false because certainly this character is not a white space character so in the next iteration of the loop in-space must be false so that if we encounter another non-white space character in the next iteration we do not count that as a bringing of another word and since this has been a new word we must instrument the count of the number of words <sil=0.914> .PERIOD Note that we have used the instrument operator plus plus to increment the values of line scales and words I1 <sil=0.983> .PERIOD We have already seen what the operator does in the previous lecture it increments the variable and this is the post increment so what it returns is the old value of the variable but in any case we are using this as a statement and so therefore we are starting the value of the expression itself and depending on the preference you know we could have used the free increment or the post increment operators the result would have been exactly the same because the side effect of both is to increment the variable by 1 and return value is the only thing which is different and the return value or the value of the expression is being ignored in this particular case in any case <sil=0.925> .PERIOD So <sil=0.501> ,COMMA that is all there is to the program and when when the loop ends we have the count of the characters words and lines so we can just print that so we print f using this format string <sil=0.912> .PERIOD So <sil=0.534> ,COMMA this format string note that the characters C as A R as colon blank will get printed as here the the character's first and D will be actually replaced by the value of the variable's here and again these characters get printed as here this percent D is replaced by the value of the variable words these characters get printed as here and this percent D gets replaced by the value of the variable line and this new line character is printed as it is which means that the culture comes on to the next line and the program ends <sil=0.975> .PERIOD So <sil=0.426> ,COMMA let us now try out this program I already compiled it again so let us just execute it and let us see some input we already know how to terminate the input <sil=0.925> .PERIOD Note that no output will appear till we actually end the output because we are not outputting anything for every character in the input <sil=0.943> .PERIOD So <sil=0.643> ,COMMA let us terminate the input now <sil=0.945> .PERIOD What this says is that there were 104 characters that we typed note that this will include the blank spaces in the new line characters that we typed <sil=0.916> .PERIOD Number of words is 17 we can count that is really enough to ensure that this is correct on the first line we have five words six on the second one <sil=0.457> ,COMMA right the level and six on the third one that makes it 17 and there are three lines and again we can use IO-RE direction to count the number of words in some other files in some file <sil=0.919> .PERIOD So <sil=0.397> ,COMMA as before let us count the number of words in this file word count or C itself which contains a program that we just wrote and the program tells us that this file contains 985 characters 178 words and 41 lines and we can actually verify this output by using the standard word count things as utility in Munich <sil=0.982> .PERIOD So <sil=0.448> ,COMMA there is a program called WC which does pretty much the same as a simple word count program <sil=0.926> .PERIOD So <sil=0.369> ,COMMA we use the standard WC utility to count the number of words lines characters etcetera in the file word count or C we find that we get the same output <sil=0.986> .PERIOD The WC program prints the number of lines then words and then characters <sil=0.932> .PERIOD So <sil=0.362> ,COMMA we see that it prints it says 95 characters 178 words and 41 lines which is precisely what we also what our program also produce for same files <sil=0.984> .PERIOD Okay <sil=0.433> .PERIOD So <sil=0.603> ,COMMA at the end of the lecture here is a simple exercise for you <sil=0.957> .PERIOD We write the copy program yourself but this time we want to make small changes to it so that the case of all alphabet letters is changed that is all lower case letters in the input are converted to the corresponding upper case letters and the upper case letters in the input should be converted to the corresponding lower case letters and the other characters like social characters for lines for new lines etcetera should remain as they are <sil=0.946> .PERIOD Now <sil=0.640> ,COMMA here are a couple of hints for to help you with writing this program <sil=0.940> .PERIOD So <sil=0.546> ,COMMA we need to do two things in this program really when we read a character we need to check whether or not it is a lower case letter if it is a lower case letter then we need to output the corresponding upper case letter and similarly if the character happens to be an upper case letter we need to output the corresponding lower case letter and if the character is neither lower case nor upper case then we output the character as it is <sil=0.937> .PERIOD So <sil=0.595> ,COMMA now how do we check whether for example the character C is a lower case letter of the alphabet we do not need to compare the value of C with all the lower case alphabet letters from A to Z because remember that in the Fck codes of the various characters the characters of the codes for the characters A to Z are one after the other that is B the Fck codes for B is one more than A then the Fck code of the character C is one more than the Fck code of character C of character B and so on so forth <sil=0.919> .PERIOD So <sil=0.317> ,COMMA it is given the property of the Fck codes it is enough to check that if C is greater than equal to the character A and it is less than equal to the character Z then it must be some lower case letter and similarly you can check whether a character is an upper case letter or not <sil=0.917> .PERIOD So <sil=0.385> ,COMMA having checked whether a character is let us say lower case letter we need to find the corresponding upper case letter now how do we compute that <sil=0.989> .PERIOD Now again we use the same property that the Fck codes for small a to small Z are contiguous and similarly Fck codes for capital A to capital Z are contiguous now which means that Fck is indeed a lower case letter then if you subtract a C code of A from it then what we will get will be the place of the letter C of the character C in the alphabet starting with 0 <sil=0.938> .PERIOD So <sil=0.628> ,COMMA if C happened to be the character A itself this will give us 0 if C happened to be character B this will give the value 1 if it happened to be character C it will give the value 2 and so on and remember that we can do this arithmetic on characters because characters really are nothing but small integers we are only storing the Fck codes of these characters <sil=0.976> .PERIOD So <sil=0.382> ,COMMA once you know this the place of the of the particular lower case character that we have seen in the alphabet now to that place value if we just add the Fck code of capital A that will give us the corresponding upper case letter for example suppose C happened to be the lower case letter D now D minus A will give us the value 3 because D minus A will give us 1 C minus A will give us 2 and D minus A will give us 3 and if we add 3 to the Fck code for character A that we give us the Fck code for the character D <sil=0.984> .PERIOD So <sil=0.424> ,COMMA this way we can find out what is the Fck code for the upper case letter corresponding to a certain lower case letter and similarly we want to find the lower case letter corresponding to an upper case letter because this is very similar we subtract the Fck code of capital A and add the Fck code of small A <sil=0.957> .PERIOD So <sil=0.613> ,COMMA this finishes today's lecture in the next lecture we will start looking at the control statements like the if statement and the while statement and so on in more detail and we will introduce some more useful control statements <sil=0.926> .PERIOD you you you you you you you you you you you you you you you you you you you you <sil=0.979> .PERIOD The last two lectures we talked about recursion and we saw that several problems can be solved very easily and very elegantly using recursion and in the last lecture we saw how recursion actually works and what happens at runtime where recursive function executes and so on <sil=0.902> .PERIOD So in today's lecture we will talk about how and when not to use recursion and we will see that in many cases recursion is not appropriate and also in many cases if we carelessly use recursion we can actually end up with extremely inefficient programs <sil=0.903> .PERIOD We will also introduce some notation for analyzing the performance of programs which is very important to understand because our programs should not just work but we should also try to make them as efficient as possible <sil=0.922> .PERIOD So as we have already seen recursive algorithms for many problems are much simpler and more natural than iterative solutions and we have seen number of examples in the last two lecture but when we discuss how recursive function works would recall that when a the number of function calls that happens is very large depending on the depth of recursion and each function call and return has a substantial overhead because return address and local variables etcetera have to be create space for local variables and return address has to be created etcetera the parameters have to be initialized and so on so forth and this overhead can become substantial in certain cases especially if the recursion is very deep <sil=0.974> .PERIOD So and also in terms of usage of memory recursion is more expensive because we have to create a stack frame for all the simultaneous invocations of the recursive function <sil=0.971> .PERIOD So there is a trade off between using recursion and writing an equivalent non recursive or non iterative function for solving the same problem <sil=0.998> .PERIOD So the ideal solution is that where the problem is very simple and the non recursive solution can be implemented as well as understood easily then we should always prefer not using recursion because recursion as we have seen as a substantial overhead <sil=0.944> .PERIOD However in certain cases the problem itself may be very difficult to solve or the solution may be very difficult to understand if recursion is not used for example the tower of an oe problem that is all last time and in such cases certainly we should use recursion but for problems such as factorial and g c d which can be easily solved and the solution can be easily understood even if it is not recursive solution recursion is not really appropriate for these kinds of problems <sil=0.936> .PERIOD Now <sil=0.453> ,COMMA see how careless uses of recursion can lead to extremely inefficient programs and while some certain days will also introduce analysis of programs for analyzing how much time a program takes to solve a given problem as a function of the size of the problem in the sense and to do all that let us consider the following problem as an example <sil=0.919> .PERIOD You have to write a function to compute x to power n for given values of x and n x can be a floating point number or an integer it does not really matter but n is a non-negative integer that is n is an integer which is greater than equal to 0 <sil=0.992> .PERIOD Now <sil=0.541> ,COMMA how do we compute x to power n <sil=0.869> ?QUESTIONMARK The naive simplest solution is start with 1 and keep multiplying the answer by x till you do it n times <sil=0.913> .PERIOD So <sil=0.343> ,COMMA start with 1 and multiply it by x and times <sil=0.953> .PERIOD So <sil=0.424> ,COMMA this obviously requires n multiplication and the time taken by the algorithm would obviously proportional to the number of times the multiplication operation is performed <sil=0.976> .PERIOD Now <sil=0.592> ,COMMA if we think a little bit about this problem we will find that we can actually do substantially better than n multiplication <sil=0.966> .PERIOD So <sil=0.339> ,COMMA let us see how <sil=0.907> .PERIOD Consider the following facts which all of us know about exponentiation x to power 0 is 1 for any value of x <sil=0.984> .PERIOD x to power 2 n is the same as x to power n squared and similarly x to power 2 n plus 1 is equal to x times x to power n squared and we can use these facts to very easily come up with a efficient recursive solution to this problem of exponentiation and to see what this algorithm will be we have to simply utilize these properties that we just saw <sil=0.917> .PERIOD If the exponent value that is given to us that is the power that we have to raise x to if it happens to be even then what we can do is we can raise x to half that power and then simply square the result and if the power is odd then we have the power obtain the result square it and then multiply by x that is what is happening in this case and that can very easily lead to a recursive solution to this problem we will see the recursive solution in a little while <sil=0.939> .PERIOD But let us try to analyze how many multiplication will be required if we do that <sil=0.978> .PERIOD So <sil=0.440> ,COMMA let us say we denote the number of multiplications needed to compute x to power n in the worst case as t n where t where t is a function of n clearly the number of multiplication required will be a function of n and we have to find what this function t n is <sil=0.922> .PERIOD So <sil=0.393> ,COMMA clearly you can see that t 0 is 0 because x to power 0 is 1 and we can compute that without using any multiplication and to compute t n what we need to do is compute t to power to compute x to power n what we need to compute is x to power n by 2 and then square it and if n happen to be even that is the answer and if n happen to be odd then we have to multiply it once again by x <sil=0.930> .PERIOD So <sil=0.609> ,COMMA how many multiplications are needed to obtain t to power n by 2 the time taken would the number of multiplication would be t of n by 2 we are using flow because n by 2 would give us only the integer component which will be the flow of n by 2 in general and then we have to square that that is one more multiplication and then possibly we have to multiply the result again by x <sil=0.955> .PERIOD So <sil=0.626> ,COMMA in the worst case we require 2 more multiplications and so t of n is t of n by 2 plus 2 for all values of n greater than equal to 1 <sil=0.952> .PERIOD So <sil=0.311> ,COMMA now this function t has been expressed as a recurrence relation and we can actually easily solve this recurrence relation by keeping on expanding the terms t of n by 2 writing that in terms of t of n by 4 and so on so forth <sil=0.981> .PERIOD So <sil=0.412> ,COMMA let us do that exercise <sil=0.930> .PERIOD So <sil=0.440> ,COMMA for n equal to 1 and greater than equal to 1 as we just saw t n is equal to t n by 2 plus 2 and then in the next step t of n by 2 using the same relation we can write as t of n by 4 plus 2 and so that becomes t of n by 4 plus 2 times 2 and in the next step it becomes equal to t of n by 8 plus 3 times 2 and so on so forth <sil=0.927> .PERIOD So <sil=0.528> ,COMMA now in every step we are dividing further dividing n further by 2 and finally <sil=0.582> ,COMMA this value n by 2 4 8 16 32 etcetera finally <sil=0.562> ,COMMA this value will become 1 and in how many steps will it become 1 <sil=0.952> .PERIOD So <sil=0.630> ,COMMA we are dividing by 2 for 1 2 for 2 2 2 for 3 and so on and so finally <sil=0.528> ,COMMA write by 2 for log 2 times n then this value will become 1 and so the point is that in that expression we will get t 1 plus 2 how many times log n times the floor of log n times and so t 1 we of course <sil=0.432> ,COMMA know to be again t n by the same relation is t 0 plus 2 <sil=0.954> .PERIOD So <sil=0.428> ,COMMA we add to one more time so finally <sil=0.598> ,COMMA the number of multiplication turns out to be 2 times the floor of log n plus 1 <sil=0.908> .PERIOD Note that this is a logarithmic function of n whereas <sil=0.527> ,COMMA in the naive algorithm we have to perform n multiplication which is a linear function of n whereas <sil=0.381> ,COMMA using this square and multiply algorithm we require only the number of multiplication required is only a multiple of the logarithm of n and naturally for large values of n the even 2 times logarithm of n is always going to be less than n <sil=0.959> .PERIOD So <sil=0.464> ,COMMA that is how we analyze the running time of an algorithm and in fact <sil=0.385> ,COMMA so essentially what we need to do is to find the running time of the algorithm in its worst case because that is what we are usually interested in <sil=0.952> .PERIOD So <sil=0.428> ,COMMA the worst case time taken is express function of the input of the input or of the input size <sil=0.910> .PERIOD So <sil=0.473> ,COMMA in this case we have express t n which is the number of multiplication but really the running time of the algorithm would also be proportional to t n <sil=0.936> .PERIOD Note that we are not really bothered with the actual running time of the algorithm on a particular machine on any given machine the actual running time of a particular program will depend on so many factors like how exactly the algorithm was implemented and what was the compiler used and how fast is the machine how much memory it has and so on <sil=0.902> .PERIOD So <sil=0.534> ,COMMA for number of factors which cannot really be analyzed very easily but this notation so this notation gives us a way of analyzing the running time without really worrying about these constants <sil=0.927> .PERIOD So <sil=0.377> ,COMMA that is a big old notation that we are going to talk about <sil=0.932> .PERIOD So <sil=0.586> ,COMMA the running time in the running time expression that we obtain using the kind of analysis that we just saw usually the multiplicative constants are ignored because they would vary from different machine to different machine <sil=0.936> .PERIOD So <sil=0.505> ,COMMA those are not important and we cannot predict those constants really and also the lower order terms are not so important for reasons that we will just see <sil=0.927> .PERIOD So <sil=0.541> ,COMMA in the in the previous example we saw that the running time is a constant times log n plus a constant <sil=0.987> .PERIOD So <sil=0.476> ,COMMA both the value of the constant and the additive constant both are really unimportant in the big old notation <sil=0.935> .PERIOD So <sil=0.453> ,COMMA the big old notation used to express the order of the time taken or in general of any function <sil=0.996> .PERIOD So <sil=0.391> ,COMMA in this particular example the time taken by the square and multiply algorithm in the big old notation is order log n which is written in this fashion big old and within brackets function log n and this informally means that the time taken is some constant times log n plus plus terms which are lower order than log n <sil=0.902> .PERIOD Now <sil=0.331> ,COMMA the big old notation is very significant because it abstracts away the constants and the lower order terms and it is important to understand that if the order of an algorithm is greater than that of another algorithm <sil=0.964> .PERIOD So <sil=0.313> ,COMMA for example <sil=0.565> ,COMMA order n is greater than order log n then the second algorithm which has a smaller order will always be faster than the first algorithm which has a higher order for large enough input values regardless of the values of the constants and lower order terms involved <sil=0.945> .PERIOD So <sil=0.349> ,COMMA for example <sil=0.647> ,COMMA an order log n algorithm will always be faster than an order n algorithm for a large enough value of n <sil=0.978> .PERIOD So <sil=0.380> ,COMMA what this means is that if you have an order log n algorithm in the running time of the algorithm is some constant times log n plus lower order terms and for the order n algorithm the running time is some constant times n plus lower order terms <sil=0.918> .PERIOD Now <sil=0.306> ,COMMA regardless of what these constants and the lower order terms are we can always find a value of n beyond which the time taken by the order log n algorithm will be less than the time taken by the order n algorithm <sil=0.901> .PERIOD So <sil=0.368> ,COMMA let us see this in terms let us see this by plotting some of these functions <sil=0.937> .PERIOD So <sil=0.329> ,COMMA this plot shows three curves the blue curve plots 1000 times log x <sil=0.958> .PERIOD So <sil=0.385> ,COMMA this is an order log x function note that the multiplicative constant is 1000 the pink curve is a linear function of x it is 100 times x notes that even though the constant is 10 times smaller in this case <sil=0.591> ,COMMA but still the linear function that is a straight line always overtakes this log x curve and this will be two regardless of what the relative what the constants what the magnitude of these constants are <sil=0.971> .PERIOD And the third curve we have plotted is a parabola which is 5 x square and again the multiplicative constant is very very small compared to the other and it will also always overtake the linear the straight line as well as the log x curve regardless of the relative magnitudes of the constants involved <sil=0.956> .PERIOD And that is why you know when we talk about the running time of an algorithm or the complexity of an algorithm <sil=0.341> ,COMMA we talk about really the asymptotic complexity as it is called where we talk about very large values of the input size <sil=0.953> .PERIOD And for very large values of input size as as these curves show the actual values of the constants and lower order terms are not really important it is really the most dominating term or the greatest order term which is really important that is what the bigotation really represents <sil=0.914> .PERIOD So <sil=0.602> ,COMMA we have got an efficient algorithm for exponentiation <sil=0.444> ,COMMA but suppose we implement this algorithm in recursive fashion as shown in this code <sil=0.906> .PERIOD So <sil=0.611> ,COMMA x and n are given as parameter and the function is if n is equal to 1 return 1 as if n is even then return x to power n by 2 into x to power n by 2 <sil=0.978> .PERIOD Otherwise n is odd and so we return x into x to power n by 2 into x to power n by 2 <sil=0.946> .PERIOD So <sil=0.471> ,COMMA this correctly computes the value of x to power n <sil=0.362> ,COMMA but what is really wrong with this implementation <sil=0.909> ?QUESTIONMARK What is wrong with this implementation is that we are computing the same value twice <sil=0.945> .PERIOD So <sil=0.514> ,COMMA if you look at for example <sil=0.498> ,COMMA this statement we are computing x to power n by 2 once here and then we are again calling the same function recursively with the same parameter once again <sil=0.965> .PERIOD So <sil=0.314> ,COMMA we are recomputing x to power n by 2 <sil=0.945> .PERIOD So <sil=0.336> ,COMMA this is obviously inefficient because we needed to compute this value just once and then we could have reused this value to multiply it with itself <sil=0.977> .PERIOD So <sil=0.475> ,COMMA what we have seen is that x to power n by 2 is being computed twice <sil=0.948> .PERIOD Now <sil=0.354> ,COMMA for each computation of x to power n by 2 will have to compute x to power n by 4 twice which means overall x to power n by 4 will be computed 4 times <sil=0.918> .PERIOD Similarly <sil=0.618> ,COMMA x to power n by 8 will get computed 8 times x to power n by 16 will get computed 16 times and so on so forth <sil=0.923> .PERIOD So <sil=0.525> ,COMMA clearly this is extremely inefficient <sil=0.990> .PERIOD Let us see precisely how inefficient it is by trying to analyze the time taken by this particular implementation <sil=0.924> .PERIOD So <sil=0.647> ,COMMA let us denote the time taken to be T n for where n is the exponent <sil=0.928> .PERIOD So <sil=0.582> ,COMMA when n is 0 clear is the time taken is a constant some constant C 1 and for n greater than 0 T n is 2 times T of n by 2 because we are calling the function power x n by 2 twice plus a constant and so this constant would be the time taken to multiply x into the power of x to power n by 2 into x to power n by 2 and so on so forth <sil=0.920> .PERIOD So <sil=0.383> ,COMMA as I said these actual values of the constant C 1 and C 2 are not really important <sil=0.932> .PERIOD So <sil=0.351> ,COMMA what I have seen from the previous explanation in the previous explanation this factor of 2 was not present <sil=0.947> .PERIOD But <sil=0.536> ,COMMA before this factor 2 has come suddenly this the time taken by this algorithm has gone back from being a logarithmic function of x of n to a linear function of n <sil=0.953> .PERIOD So <sil=0.348> ,COMMA I will leave it as an exercise for you to show that T n is actually all the n <sil=0.988> .PERIOD So <sil=0.510> ,COMMA this is not really a good implementation of the square and multiply algorithm the algorithm is good but <sil=0.486> ,COMMA we have not really implemented it properly we have not used recursion carefully enough and if you really want to get the benefit of the speed up that the square and multiply algorithm offers us then we have to make sure that we from within a function we make only one recursive call to the function and reuse the return value <sil=0.912> .PERIOD So <sil=0.423> ,COMMA that is quite easy to do <sil=0.960> .PERIOD So <sil=0.374> ,COMMA here what you are doing is we if n is even we call power again to compute x to power n by 2 and save the return value in a variable T and then multiply T by T to compute x to power n by 2 times x to power n by 2 <sil=0.990> .PERIOD And similarly if n is odd we compute we save x to power n by 2 in a variable T and then compute x times T times T <sil=0.921> .PERIOD So <sil=0.328> ,COMMA there are in this function still there are two calls to the power function <sil=0.954> .PERIOD But <sil=0.345> ,COMMA for a given value of n it is easy to see that either this call will be made or this call will be made both of them cannot be simultaneously made because clearly n can be either even or odd it can be both <sil=0.983> .PERIOD Of course <sil=0.392> ,COMMA we could have we could have called power somewhere outside this statement in both the cases at a common place and then then use that value in both these but that would not really has been an indifference <sil=0.977> .PERIOD So <sil=0.315> ,COMMA this particular implementation of the power function now actually correctly and efficiently implement square and multiply algorithm for exponentiation and it does give the speed of benefit and has running time of order log n <sil=0.931> .PERIOD Let us now take another example to see how recursion should not be used <sil=0.959> .PERIOD So <sil=0.371> ,COMMA let us consider the computation of Fibonacci numbers <sil=0.944> .PERIOD The Fibonacci series is defined as follows F of 0 is 0 F of 1 is 1 and for n greater than 1 F of n is F of n minus 1 plus F of n minus 2 <sil=0.922> .PERIOD So <sil=0.424> ,COMMA essentially any term in the series is the sum of the last two terms <sil=0.985> .PERIOD Now <sil=0.592> ,COMMA suppose you want to write a function to compute the nth Fibonacci number that is to compute F of n <sil=0.919> .PERIOD You can see that we can write a very simple iterative algorithm to compute F of n <sil=0.928> .PERIOD All we have to do is we have to remember the last two terms in the series and keep adding the last two terms to obtain the next term and in the next iteration the newly obtained term and the last term because become the last two terms and we keep doing this till we have obtained F n <sil=0.902> .PERIOD So <sil=0.322> ,COMMA here is the implementation of the simple iterative algorithm that we discussed as now <sil=0.900> .PERIOD Cur and prev are the last two terms that have been computed in the Fibonacci series and we always maintain i such that curve is F of i and trev is F of i minus 1 <sil=0.982> .PERIOD So <sil=0.315> ,COMMA if n is equal to 0 we return 0 otherwise as long as n is greater than i that means we have not yet computed F of n because the last term that we computed was F of i <sil=0.967> .PERIOD So <sil=0.512> ,COMMA we add up the two terms and that becomes the new value of curve and the value of previous is the old value of curve which we saved in t and then assigned it later to previous and then we increment i because now one more term in the series has been computed and finally <sil=0.555> ,COMMA when n becomes equal to i we return the value of curve because that will be the value of F of n <sil=0.918> .PERIOD Now <sil=0.602> ,COMMA so that is simple enough but looking at this looking at this recurrence relation one might be tempted to implement the algorithm recursively by just adding up the values of F of n minus 1 and F of n minus 2 and use recursion to compute these two values and we will just see that that would be extremely inefficient <sil=0.926> .PERIOD But let us first analyze the iterative algorithm that we just wrote and see how much time it takes <sil=0.910> .PERIOD So <sil=0.392> ,COMMA note that each iteration of this loop takes a constant amount of time it does not really depend on the value of n and the number of iterations is n minus 1 and so therefore <sil=0.540> ,COMMA the total time taken by this function is order n where n is the parameter supplied to the function <sil=0.928> .PERIOD So <sil=0.517> ,COMMA let us say we write that straightforward naive recursive function to implement Fibonacci <sil=0.915> .PERIOD So <sil=0.477> ,COMMA this is easy to write that it as it turns out it is extremely inefficient and we will see why it is inefficient <sil=0.986> .PERIOD So <sil=0.365> ,COMMA if n is equal to 0 or 1 we return the value of n because F of 0 is 0 and F of n is 1 <sil=0.909> .PERIOD Otherwise this function simply makes two recursive calls to itself compute Sibonacci of n minus 1 and Fibonacci of n minus 2 and returns there some <sil=0.916> .PERIOD Now <sil=0.544> ,COMMA why is this implementation really inefficient <sil=0.947> ?QUESTIONMARK This is inefficient because the same values are again being computed multiple times <sil=0.970> .PERIOD F of n minus 1 is computed only one but F of n minus 2 is computed twice because when F of n is called it calls F of n minus 1 and F of n minus 2 and F of n minus 1 again calls F of n minus 2 and F of n minus 3 <sil=0.921> .PERIOD So <sil=0.414> ,COMMA if we try to see how the recursive calls to F are happening see that F of n calls F of n minus 1 and F of n minus 2 and this calls again F of n minus 2 and F of n minus 3 and this calls F of n minus 3 and F of n minus 4 <sil=0.952> .PERIOD So <sil=0.477> ,COMMA see that F of n minus 2 is being called twice and F of n minus 3 will actually get called 3 times because F of n minus 2 will again call F of n minus 3 <sil=0.927> .PERIOD So <sil=0.607> ,COMMA F of n minus 3 is called once here once here and once here and if you look at F of n minus 4 that will be actually called 5 times because it will be called from here and it will be called from here and from here and from here and so as the value of I increases F of n minus I is called an increasing number of times <sil=0.965> .PERIOD So <sil=0.355> ,COMMA this is obviously grossly inefficient and if we write a recurrence relation to understand the time taken by this implementation we will find that for n equal to 0 and n equal to 1 clearly the time taken is a constant but for n greater than 1 T n is T of n minus 1 plus T of n minus 2 plus a constant will not try to mathematically solve this second installation but it can be shown that T n T of n is actually order a constant time constant to trace to the power of n <sil=0.966> .PERIOD So <sil=0.356> ,COMMA what that means is that the time taken by this algorithm by this implementation of the Shibunachi series completion the time taken grows exponentially as a function of n rather than as a linear function of n as in the case of the simple iterative solution <sil=0.971> .PERIOD So <sil=0.580> ,COMMA that is extremely inefficient <sil=0.990> .PERIOD This is the end of today's lecture in the next lecture we will talk about a couple of very important and frequently encountered problems these are the problems of searching and sorting and we will try to develop some simple algorithms to solve these problems and try to analyze these algorithms to find their time complexity <sil=0.962> .PERIOD Thank you <sil=0.960> .PERIOD In the last lecture we have talked about functions and we saw how the use of functions can help us manage the task of solving complex problems and developing large and complicated programs to solve these problems <sil=0.988> .PERIOD Today we will discuss more about function <sil=0.595> ,COMMA but before that we will start with the summary of what we had discussed last time <sil=0.914> .PERIOD So <sil=0.513> ,COMMA here is how a function can be defined <sil=0.905> .PERIOD You start with the return type of the function which could be any of the types that we have seen so far <sil=0.983> .PERIOD This is followed by the function name and then within brackets we have to specify what are the parameters for the function <sil=0.938> .PERIOD For each parameter we have to specify the name of the parameter and the type of the parameter <sil=0.915> .PERIOD The parameter type can be again any of the types that we have seen so far and then the entire function body is enclosed within braces and which follows just after the function header <sil=0.951> .PERIOD Usually the definition of any function should proceed any call to a function in the program <sil=0.955> .PERIOD So <sil=0.601> ,COMMA this really means that if the function f calls the function g then usually it is better to place the definition of the function g before the definition of the function f <sil=0.971> .PERIOD This is not always necessary and we will see later on why we may need to make exception to this rule <sil=0.399> ,COMMA but at this point in time there is something we can always do <sil=0.961> .PERIOD We also saw the return statement <sil=0.906> .PERIOD The return statement has the purpose of specifying the value of the function execution or as it is called the return value of the function <sil=0.949> .PERIOD So <sil=0.649> ,COMMA along with the return keyword we also specify an expression and the value of the expression is what is returned to the calling function as the return value from the function and also recollect that when within a function the return statement is executing the execution of that function terminates immediately <sil=0.939> .PERIOD Regardless of where the function body has been finished or not and control returns to the place where this function had been called from the calling function <sil=0.942> .PERIOD So <sil=0.517> ,COMMA here is how we make a function call that is how we use a function <sil=0.980> .PERIOD So <sil=0.584> ,COMMA we specify a function name the function that we want to call and then for each of the parameters we have to supply a corresponding argument <sil=0.963> .PERIOD The arguments must of course be of the right type that is the argument one must be of the type that is expected for the parameter one that is declared for the parameter one and similarly argument two must be of the same type as parameter two and so on so forth <sil=0.903> .PERIOD These arguments have to be expressions <sil=0.943> .PERIOD They can be arbitrary expressions of the appropriate type and this entire piece of code is treated by the C language as an expression and this expression the type of this expression is the same as the return type of the function that we are calling <sil=0.973> .PERIOD This means that this entire expression can be used wherever value or variable wherever value of the type which is the return type of the function is expected <sil=0.928> .PERIOD For example <sil=0.642> ,COMMA if the return type is integer then this entire expression can be used wherever an integer is expected <sil=0.994> .PERIOD Of course <sil=0.403> ,COMMA as you know you can also convert expressions into statements by putting a semicolon after them in which case the return the value of the expression is discarded <sil=0.983> .PERIOD The same is true for these kinds of expressions also if you put a semicolon after such an expression then it becomes a statement and essentially the return value of the function is being ignored and the only effect that the function call has in that case is the side effects that the function can might have made <sil=0.971> .PERIOD We have not really discussed side effects and functions will look at that in today's lecture <sil=0.987> .PERIOD Then we talked about local variables in function a variable which is defined within the body of a function is said to be local to that particular function and we talked about the scope and lifetime informally of variables we will talk more about scope and lifetime by the scope of a variable we mean the portion of the program code where that variable is visible to people where it can be used <sil=0.983> .PERIOD So <sil=0.452> ,COMMA local variables are visible only within the function in which they are defined <sil=0.981> .PERIOD So <sil=0.336> ,COMMA that scope of local variable and by lifetime we mean for how long does the variable exist and the variable exist a local variable exist only while the function is executing <sil=0.902> .PERIOD We will make these ideas more concrete with the help of some examples later on in the lecture and parameters are similar to local variables in scope and lifetime which means that a parameter exists like a local variable it is visible only within the function body is created when the function is called and is destroyed when the function returns <sil=0.955> .PERIOD So <sil=0.418> ,COMMA what happens during a function call is that the argument for the function are evaluated space is created for the parameters and local variables of the function which is being called now as we saw in the last lecture and then the parameters are initialized with the values of the corresponding expressions which are being passed as arguments and then the function starts executing when the function returns we control returns back to the place in the calling function where the function was called note that we saw last time that if in some case the argument to a function happens to be a variable and in the function body we happen to change the value of the corresponding parameter then this change has no effect on the value of the original variable in the calling function when that function returns <sil=0.929> .PERIOD Let us now discuss the scope of variables little more formally <sil=0.901> .PERIOD So <sil=0.314> ,COMMA the scope of variable is defined as the portion of the program where references to that variable are permitted <sil=0.991> .PERIOD So <sil=0.563> ,COMMA as we have already seen the scope of local variables extend to the body of the function within which the variable is defined and the same is true for scope of parameter the scope of a parameter to a function f is also within the body of the function f <sil=0.936> .PERIOD So <sil=0.437> ,COMMA scope is a property of the program itself that is you can examine a program and demarcate portions of the code where a particular variable is in scope or is not in the scope and so on <sil=0.905> .PERIOD So <sil=0.634> ,COMMA we say that it is a static property of the program <sil=0.999> .PERIOD The lifetime of a variable on the other hand is a dynamic property because it refers to the execution time of the program <sil=0.988> .PERIOD So <sil=0.383> ,COMMA by lifetime what we really mean is the time during which a particular variable exists so to speak <sil=0.943> .PERIOD So <sil=0.481> ,COMMA variables are created and they get destroyed <sil=0.946> .PERIOD The time from the time when the variable was created to the time when it was destroyed is called the lifetime of the particular variable <sil=0.980> .PERIOD For local variables in parameters as we discussed last time the lifetime is the time for which the function is active <sil=0.971> .PERIOD Now <sil=0.309> ,COMMA what do we really mean by a function being active we have not really discussed this in detail in the last lecture <sil=0.908> .PERIOD Let us do that now with the help of a simple example <sil=0.926> .PERIOD Consider this program <sil=0.969> .PERIOD So <sil=0.511> ,COMMA we have a function main with local variable x <sil=0.926> .PERIOD The function main calls a function f with some argument which are not important for this example <sil=0.925> .PERIOD Here is the definition of the function f it has a local variable y and it calls another function g and within g we have declared a local variable z <sil=0.910> .PERIOD Now <sil=0.536> ,COMMA let us see the execution of this program on a timeline and see what is happening and when are variables getting created and destroyed <sil=0.958> .PERIOD So <sil=0.498> ,COMMA this is our timeline <sil=0.937> .PERIOD So <sil=0.595> ,COMMA when the function starts executing as you know the main function gets automatically called and so when the main function gets called the variable x gets created <sil=0.914> .PERIOD So <sil=0.589> ,COMMA when at this point in time the function main has been called and the variable x has been created <sil=0.971> .PERIOD Now <sil=0.382> ,COMMA the function f is called from main <sil=0.916> .PERIOD So <sil=0.317> ,COMMA f is called and y is created <sil=0.946> .PERIOD Note that when f is called the body of the function f starts executing and f is the currently executing function <sil=0.319> ,COMMA but that does not mean that the main function is not active because the function f has been called from main and when main returns execution will go back to main <sil=0.963> .PERIOD So <sil=0.368> ,COMMA main is not finished yet it is still active <sil=0.911> .PERIOD So <sil=0.500> ,COMMA at this point in time the variable x still exists it has not been destroyed <sil=0.626> ,COMMA but because of the limitations of this scope it cannot be accessed right now because from within f the variable x cannot be accessed <sil=0.973> .PERIOD The scope of the variable x is only the body of the function main <sil=0.907> .PERIOD So <sil=0.309> ,COMMA within the function f the variable x cannot be accessed <sil=0.426> ,COMMA but it still exists it has not yet been destroyed <sil=0.983> .PERIOD So <sil=0.647> ,COMMA when the function f calls g similarly the variable z gets created and again the function f and the function main are still active because when g returns the execution will go back to f and when f returns the execution will go back to main and so the variables x and y they still exist <sil=0.970> .PERIOD Though of course <sil=0.553> ,COMMA again they cannot be accessed from within the function g because of because the scope of these variables does not include the body of the function g <sil=0.912> .PERIOD So <sil=0.504> ,COMMA when finally g returns at that point in time the variable z gets destroyed <sil=0.992> .PERIOD So <sil=0.618> ,COMMA this is because the function g is finished it is no longer active and so the variable z is destroyed it does not exist <sil=0.987> .PERIOD So <sil=0.594> ,COMMA the lifetime of the variable z is this period during which the variable z existed <sil=0.911> .PERIOD And similarly now the control has gone back to be function f and finally <sil=0.452> ,COMMA the function f also returns and at that point in time y also gets destroyed <sil=0.940> .PERIOD So <sil=0.584> ,COMMA the lifetime of the variable y is the time from which f was called to the time when f returns when main returns and the program actually terminates and that time the variable x gets destroyed <sil=0.968> .PERIOD So <sil=0.425> ,COMMA the lifetime of the variable x is the entire time for which the program was executing because as long as the program is executing the function main is always active <sil=0.949> .PERIOD Now <sil=0.544> ,COMMA what are the implications of this kind of a lifetime <sil=0.861> ?QUESTIONMARK Let us try to understand that using another simple example <sil=0.996> .PERIOD So <sil=0.340> ,COMMA I have a program here in which the function main calls to function f twice once with the argument 1 and once with the argument 2 here is the body of the function f the parameter is called x and there is a local variable called y <sil=0.915> .PERIOD So <sil=0.569> ,COMMA what happens let in this function f what happens is that if the parameter has the value 1 then y is assigned 10 otherwise it is not assigned anything and then finally <sil=0.319> ,COMMA the value of y is printed <sil=0.964> .PERIOD So <sil=0.626> ,COMMA now when f is called the first time it is called with the parameter with argument 1 <sil=0.904> .PERIOD So <sil=0.633> ,COMMA the value of x is 1 <sil=0.953> .PERIOD So <sil=0.567> ,COMMA y gets assigned 10 and the value 10 gets printed <sil=0.999> .PERIOD The question is what happens when f is called again with argument 2 <sil=0.923> .PERIOD So <sil=0.413> ,COMMA in the second execution of f is the variable y which is not assigned any value in the second execution because x would have the value 2 what value would it print <sil=0.972> .PERIOD So <sil=0.558> ,COMMA the answer really is that it is unpredictable <sil=0.977> .PERIOD Let us see why that is unpredictable <sil=0.985> .PERIOD So <sil=0.576> ,COMMA let us again draw the timeline and see how this program executes <sil=0.925> .PERIOD So <sil=0.563> ,COMMA when main is called and then f is called and at that point in time x y are created is the first call to f then y is assigned the value 10 10 is printed then f return x and y are destroyed <sil=0.936> .PERIOD Now <sil=0.603> ,COMMA when f returns and control goes back to main f is called again and so x and y are created again <sil=0.993> .PERIOD But <sil=0.606> ,COMMA because they have been created again this means that this x and this y are not necessarily the same as this x and this y even though they are the same variable of the same function <sil=0.942> .PERIOD On a timeline this x is not the same as this x and similarly this y is not the same as this y <sil=0.901> .PERIOD So <sil=0.575> ,COMMA now the y assigned 10 had assigned a value 10 to this y <sil=0.534> ,COMMA but this variable has been destroyed and another variable which also happens to be called y has been created <sil=0.972> .PERIOD There is no guarantee that the new variable y which has been created would be created at the same place where the old y also existed and therefore <sil=0.416> ,COMMA there is no guarantee that this time the y variable y will retain its old value of 10 <sil=0.942> .PERIOD So <sil=0.439> ,COMMA what that implies is that the second output of this program is unpredictable <sil=0.930> .PERIOD The first output will always be 10 of course <sil=0.393> ,COMMA because x is given the value 1 and y is assigned and then it is immediately printed <sil=0.916> .PERIOD So <sil=0.562> ,COMMA the first output will always be 10 <sil=0.331> ,COMMA but the second output is unpredictable <sil=0.923> .PERIOD So <sil=0.519> ,COMMA essentially the idea is that a local variable of a function does not retain its value across multiple calls to the same function <sil=0.919> .PERIOD That is a point that we have to remember we cannot assume that the value that we assigned to a particular local variable of a function the variable will have the same value when the function is called again at some other place <sil=0.967> .PERIOD Let us not talk about variable which are known as global variables and these variables differ in scope as well as in lifetime from the kind of variables that we have seen so far <sil=0.967> .PERIOD The situation where you only use global variables is one where we have a large number of functions which all need to access the same variable <sil=0.907> .PERIOD Now of course <sil=0.466> ,COMMA one way of doing that is that you could pass the same variable as argument to all the functions <sil=0.934> .PERIOD Now that of course <sil=0.629> ,COMMA might make the program cumbersome because for these functions the number of arguments may be very large because the number of variables need to be accessed by a number of functions <sil=0.954> .PERIOD So <sil=0.515> ,COMMA in those cases what you might prefer to do is to make these variables global and making a variable global implies that the variable is accessible from all functions in the program and to make a function global what you need to do is to declare it outside any function that is the declaration of the variable is not within the body of the function of any function it is outside any function <sil=0.942> .PERIOD And if you do that then the variable becomes automatically becomes global <sil=0.952> .PERIOD Now in terms of scope the scope of a global variable is all functions or all hearts of the program which appear after the declaration that is in the program if we declare a global variable at a certain point then below that point in the entire program that variable is accessible everywhere <sil=0.959> .PERIOD So <sil=0.405> ,COMMA it differs in scope from local variables because as you already saw the scope of a local variable extends only to the body of the function within which the local variable is defined <sil=0.953> .PERIOD And the global variable also differs from a local variable in the lifetime the lifetime of a global variable is the same as the lifetime of the program that is it is it gets created when the program begins execution and is destroyed only when the program really terminates <sil=0.992> .PERIOD So <sil=0.455> ,COMMA the essential idea of the global variables then is that it is a variable which can be accessed anywhere in the program because if you declare it right in the beginning of the program then it is accessible everywhere below it which means in the rest of the program <sil=0.963> .PERIOD And remains in existence throughout the execution of the program that is regardless of which functions are called and which functions return and so on this variable always exists and has the same value as what was assigned to it mostly sent <sil=0.933> .PERIOD So <sil=0.438> ,COMMA therefore <sil=0.301> ,COMMA this variable can be used pretty much anywhere in the program when when we take up a large example of using functions to solve a complicated problem we will see examples of global variables as well <sil=0.949> .PERIOD But now with global variables there can be a problem of overlapping scope and what that means is the following that there will be two variables with the same name whose scope may be overlapping <sil=0.936> .PERIOD So <sil=0.563> ,COMMA let us consider this example <sil=0.950> .PERIOD So <sil=0.483> ,COMMA here we have declared a global variable x note that this variable is declared outside the body of any function and therefore <sil=0.409> ,COMMA it is automatically a global variable and in this function f we have declared also a local variable whose name is also x <sil=0.971> .PERIOD Now <sil=0.322> ,COMMA the scope of this function of this variable x is the rare program starting from this declaration downward and this scope of this variable x is the function body which means this particular piece of the program code <sil=0.997> .PERIOD So <sil=0.311> ,COMMA now if you look at this portion of the program this x as well as this x are in the scope <sil=0.999> .PERIOD So <sil=0.506> ,COMMA the question is if we use the variable x within this part of the program that is within the function body of the function f which x are we referring to is it this x that we are referring to or is it this x that we are referring to <sil=0.922> .PERIOD So <sil=0.498> ,COMMA the rule for that is that if there are two variables both of which are in scope at a given point in time at a given point in the program then at that point in program if a reference to that variable is made these two variables have the same name and if at that point in the program if a reference that variable is made then the reference will always refer to the variable which has been declared innermost or in other words whose declaration is closest to the point of use <sil=0.906> .PERIOD So <sil=0.582> ,COMMA in this particular example here is the reference to x this is one candidate declaration and this is the other candidate declaration this declaration is closer to this use of x and so therefore <sil=0.479> ,COMMA this reference to x really means this x and this is the node this x <sil=0.927> .PERIOD So <sil=0.468> ,COMMA essentially the inner declaration hides the outer declaration within the scope of the inner declaration <sil=0.931> .PERIOD Let us now discuss functions in which we do not necessarily wish to return any value <sil=0.991> .PERIOD So <sil=0.370> ,COMMA in some cases we may not really bother about returning any value from the function <sil=0.967> .PERIOD For example <sil=0.546> ,COMMA we may only want to call a function for its side effects the side effect might be to modify some global variable or it might be for example <sil=0.306> ,COMMA to print something on the screen <sil=0.981> .PERIOD For example <sil=0.612> ,COMMA suppose we want to write a function which prints a given character a given number of times using a simple for loop or something of that kind <sil=0.994> .PERIOD Now <sil=0.605> ,COMMA this function does not really have anything useful to return <sil=0.957> .PERIOD So <sil=0.606> ,COMMA this function would not have any return type and no return value would be returned from this function <sil=0.913> .PERIOD So <sil=0.348> ,COMMA in such a case what we could do is that we should declare the return type of such a function to be void and again we will see examples later on <sil=0.933> .PERIOD Also note that within such a function the return statement is not really necessary because no return value has to be returned from the function and the function will automatically return when its body is finished that is the execution of the entire body is finished <sil=0.906> .PERIOD Of course <sil=0.425> ,COMMA we can still have a return statement within such a function also without any return value specified <sil=0.963> .PERIOD So <sil=0.542> ,COMMA the use of that would be that we want to return from the function prematurely or before the execution of its entire body is finished <sil=0.985> .PERIOD We could do that by executing the return statement and in the function of this kind the return statement would simply be the return key world followed by the semicolon no return value would be specified <sil=0.975> .PERIOD And similarly we might want to define sometimes functions which do not have any parameters and this might be required for example <sil=0.545> ,COMMA if all the information that the function needs to access is available as global variables <sil=0.966> .PERIOD So <sil=0.428> ,COMMA in that case again the function would be declared as shown here all you have to say is that there are no parameters and so just put a void the key world void where the parameters are expected <sil=0.980> .PERIOD So <sil=0.471> ,COMMA let us end this lecture with a problem for you to think about will not solve this problem in this lecture will do that in the next lecture <sil=0.923> .PERIOD So <sil=0.497> ,COMMA here is the problem we want to write a program to find a path through a maze <sil=0.973> .PERIOD So <sil=0.441> ,COMMA we are given a maze and you must have seen puzzles of this kind in very in popular magazines <sil=0.917> .PERIOD So <sil=0.364> ,COMMA we are given a maze and we are given entry point through the maze and there is possibly another exit point in the maze and we want this program to find a path from the entry point to the exit point and in some case it is possible that there is no other exit point <sil=0.998> .PERIOD So <sil=0.433> ,COMMA in that case the path should bring us back to the entry point itself and which and we should get out from the entry point itself <sil=0.940> .PERIOD But if there is another exit in the maze then the program should take us to that particular exit <sil=0.913> .PERIOD So <sil=0.573> ,COMMA the maze is given as an input by the user and the entry point is also given as an input by the user <sil=0.980> .PERIOD So <sil=0.376> ,COMMA let us assume that the maze is represented as a two dimensional grid of characters where a star represents a part of the wall and a blank space represents an open space through which movement is possible <sil=0.998> .PERIOD The maze is rectangular in shape and at any from any position in the maze one can go in any of the four directions provided that one does not run into a wall <sil=0.981> .PERIOD So <sil=0.571> ,COMMA the entry point into the maze is also given by the user and the path should take one from the entry point to some exit other than the entry point and of course <sil=0.344> ,COMMA if no other exit exists in the maze the path should bring one out of the maze through the entry point itself <sil=0.991> .PERIOD So <sil=0.604> ,COMMA here is an example maze for you to think about <sil=0.930> .PERIOD So <sil=0.524> ,COMMA this is a 5 cross 5 maze <sil=0.990> .PERIOD So <sil=0.541> ,COMMA there are 5 characters on the x axis and 5 on the y axis for ease of convenience we have labeled the two directions as x and y axis <sil=0.995> .PERIOD So <sil=0.580> ,COMMA these stars represent a walls in the maze and these blank spaces represent open path in the maze <sil=0.907> .PERIOD So <sil=0.417> ,COMMA let us assume that the entry point is one comma two in the familiar Cartesian coordinate system <sil=0.998> .PERIOD So <sil=0.642> ,COMMA which we which will mean that the entry point is x is one and y is two <sil=0.940> .PERIOD So <sil=0.461> ,COMMA and here is another exit from the maze <sil=0.931> .PERIOD So <sil=0.510> ,COMMA the path from the entry point should take us out of the maze through this particular exit point <sil=0.958> .PERIOD So <sil=0.605> ,COMMA the path will look like we start from one two which is this and we go to two two which is this <sil=0.956> .PERIOD So <sil=0.306> ,COMMA we move in this way then we go to two three this way then three three four three four four four five and then finally <sil=0.317> ,COMMA we come out of the maze here which is four comma six <sil=0.929> .PERIOD So <sil=0.474> ,COMMA the algorithm for this problem is reasonably simple <sil=0.619> ,COMMA but just think about this and you will find that even though the algorithm is simple when you actually try to implement this it becomes quite a bit complicated and one has to use several functions and so on <sil=0.950> .PERIOD So <sil=0.538> ,COMMA we will take up this example in detail and develop a program for this problem in the next lecture in the meanwhile please think about this problem <sil=0.900> .PERIOD In the last lecture we had talked about the Boolean type and the collector type and in this lecture we will start talking a little more formally about the season text we will see what expression in CR and how they were evaluated <sil=0.995> .PERIOD So <sil=0.415> ,COMMA an expression is essentially a denotation of a simple computation <sil=0.342> ,COMMA we are also familiar with expression from our high school arithmetic <sil=0.946> .PERIOD In C every expression has a type <sil=0.391> ,COMMA the types are the kind of types that we have already seen like integers <sil=0.503> ,COMMA long integers <sil=0.600> ,COMMA short <sil=0.360> ,COMMA care and so on <sil=0.910> .PERIOD The type is always determined at compile time by the compiler for any given expression and the expression evaluates to a value that is the value of the expression and that is essentially known only at runtime when the expression gets evaluated <sil=0.913> .PERIOD For example <sil=0.590> ,COMMA if you look at the expression x plus y where x is the value 3 and y has the value 5 <sil=0.645> ,COMMA then the value of the expression x plus y will be 8 nothing very unfamiliar about this <sil=0.907> .PERIOD So <sil=0.515> ,COMMA an expression in general could be simply variable for example <sil=0.476> ,COMMA x or y or whatever variable <sil=0.994> .PERIOD So <sil=0.505> ,COMMA a simple variable is also an expression and expression could also be a constant literal such as the number 10 or the number 3 <sil=0.901> .PERIOD 1417 etc etc <sil=0.979> .PERIOD And the more complicated expressions are formed out of these kinds of simpler expressions by using operators <sil=0.931> .PERIOD So <sil=0.524> ,COMMA we are already familiar with some arithmetic operators like plus minus division <sil=0.533> ,COMMA multiplication and so on <sil=0.955> .PERIOD Every operator has some operands most of the operators that you have seen so far are binary operators which means that they have two operands <sil=0.997> .PERIOD So <sil=0.404> ,COMMA in this example x plus y is an expression plus is the operator and x and y are the operands for this expression <sil=1.000> .PERIOD Let us talk a little bit more about the constant literal of various kinds <sil=0.922> .PERIOD The integer and coding point constant literal service familiar notation will not deliver the syntax of these integer and coding point constants <sil=0.910> .PERIOD They are very familiar to you already <sil=0.925> .PERIOD There are some examples minus 2 is an integer literal so R 25 and 47 etc <sil=0.959> .PERIOD So <sil=0.529> ,COMMA an integer literal essentially the sequence of digit optionally followed optionally proceeded with a plus or minus sign and here are some examples of coding point literal 5 <sil=0.917> .PERIOD 0 there can be a sign plus or minus minus 10 <sil=0.962> .PERIOD 45 for example <sil=0.943> .PERIOD And we could also use the familiar exponent notation <sil=0.927> .PERIOD So <sil=0.349> ,COMMA for example 3 <sil=0.937> .PERIOD 0 E minus 12 is same as 3 <sil=0.900> .PERIOD 0 into 10 to power minus 12 <sil=0.935> .PERIOD These are also coding point literal <sil=0.929> .PERIOD By default integer literals of this kind have the type int and coding point literal of these kinds as the type double <sil=0.997> .PERIOD But we can say that the particular integer literal or a coding point literal has a different type as follows <sil=0.937> .PERIOD So <sil=0.488> ,COMMA for an integer literal constant if you suffix the letter L then the type is declared to be long rather than the default type int <sil=0.934> .PERIOD Similarly <sil=0.466> ,COMMA if you suffix U after the literal then the type becomes unsigned and if you suffix U L then the type becomes unsigned long <sil=0.910> .PERIOD So <sil=0.450> ,COMMA for example 5 has type int 45 L has the type long and 45 U L would have the type unsigned long <sil=0.978> .PERIOD Similarly <sil=0.502> ,COMMA for a coding point literal if we use F or L as a suffix after the constant then we are forcing it to be off type float or long double respectively <sil=0.981> .PERIOD Remember that the default type for coding point constant literals is double <sil=0.955> .PERIOD So <sil=0.359> ,COMMA for example just 5 <sil=0.997> .PERIOD 4 has a type double <sil=0.998> .PERIOD 5 <sil=0.903> .PERIOD 4 F has a type float and 5 <sil=0.964> .PERIOD 4 L has a type long double <sil=0.931> .PERIOD We will be wondering why the type of these constant literals is important as we will see soon the type of the various components of an expression determines the type of the overall expression and in some cases depending on the type even the value of the expression machine and so therefore <sil=0.595> ,COMMA it is important to talk about the types of these constant literals as well as any other kinds of components that expression might have <sil=0.989> .PERIOD We had talked about the character type or the cat type in the last lecture <sil=0.982> .PERIOD You can also have a constant of type cat <sil=0.905> .PERIOD Remember that characters are stored by the F key codes inside the machine <sil=0.992> .PERIOD So <sil=0.595> ,COMMA a character constant is denoted by the character that we wish to use within the single code character <sil=0.962> .PERIOD So <sil=0.531> ,COMMA for example <sil=0.448> ,COMMA the A within the codes or C capital C within the codes etcetera these are all different constant literals of type characters <sil=0.921> .PERIOD Note that such a constant literals denotes an integer of type cat and the value of the integer is the C code of the character <sil=0.993> .PERIOD Recall that the type cat is actually just an integer type of a byte of size 1 byte or 8 bits <sil=0.945> .PERIOD So <sil=0.315> ,COMMA these are also actually integers <sil=0.362> ,COMMA but the integer that this particular constant denotes has the value which is seen as the ac code of the corresponding character A or capital C or 5 etcetera etcetera <sil=0.968> .PERIOD So <sil=0.508> ,COMMA therefore <sil=0.397> ,COMMA it is important to note that the value of the constant literals 5 within codes is the integer 53 which is the ac code of the character 5 and not 5 itself <sil=0.959> .PERIOD So <sil=0.607> ,COMMA we had put no codes around the character 5 then it could have the value 5 and of course <sil=0.512> ,COMMA all such character literals have the type cat <sil=0.907> .PERIOD Now <sil=0.406> ,COMMA there are apart from these usual characters there are certain characters which are not printable or for some other reason cannot be easily denoted in this notation that we have seen <sil=0.932> .PERIOD So <sil=0.417> ,COMMA these are denoted using certain S H sequences as they are called <sil=0.954> .PERIOD For example <sil=0.575> ,COMMA within code within single code characters that slash followed by N denotes the new line character which is the character corresponding to the enter key on the keyboard <sil=0.912> .PERIOD Similarly <sil=0.449> ,COMMA backslash T within codes notes the tab character and so on <sil=0.966> .PERIOD If you want to use the backslash character itself then you have to use backslash backslash that is two backslashes within codes and the single code character is denoted by a single code followed by backslash and then two single codes <sil=0.906> .PERIOD So <sil=0.419> ,COMMA in other words within single codes backslash code denotes the single code character and still there is a double code character is denoted by backslash double code within the code character <sil=0.971> .PERIOD Okay <sil=0.608> ,COMMA let us move on to operators now and let us begin with arithmetic operator <sil=0.945> .PERIOD We are already familiar with some of the basic arithmetic operators like plus minus star with strength of multiplication and slash with strength of division etcetera <sil=0.934> .PERIOD These are all binary operators that is they have just they have two operands <sil=0.969> .PERIOD The operator plus and minus can also be used in the unary form that is with just one operand <sil=0.953> .PERIOD So <sil=0.343> ,COMMA for example <sil=0.496> ,COMMA plus x is in this expression plus x we are using plus as the unary operator plus and similarly minus x is an expression where the unary minus operator is being used <sil=0.974> .PERIOD Of these operators all of them can be used for integer as well as floating point operands but the behavior is slightly different especially in the case of the division operation that is the slash operator <sil=0.901> .PERIOD In the slash operator with the slash operator the result differs depending on the type of operands <sil=0.907> .PERIOD So <sil=0.648> ,COMMA if the operands are digitized then the result of doing the division is the quotient obtained by dividing the two numbers whereas if the two numbers are of floating point kind then the exact value is the one that is the result of the expression <sil=0.905> .PERIOD So <sil=0.579> ,COMMA for example <sil=0.442> ,COMMA 5 for 5 slash 2 would be 2 because 5 into 2 are integer and therefore <sil=0.600> ,COMMA 5 slash 2 evaluate to the quotient of the division which is 2 and 5 slash 2 <sil=0.916> .PERIOD 0 for example <sil=0.329> ,COMMA 5 <sil=0.909> .PERIOD 0 slash 2 <sil=0.944> .PERIOD 0 would result in the value 2 <sil=0.959> .PERIOD 5 because in this case the two operands are floating point operands <sil=0.944> .PERIOD There is another operator called the percent operator which applicable only to integer type and this essentially returns the remainder of the division operation <sil=0.971> .PERIOD So <sil=0.409> ,COMMA for example <sil=0.536> ,COMMA the value of the expression 5 percent 2 would be 1 because if you divide 5 by 2 the quotient is 2 and the remainder is 1 <sil=0.909> .PERIOD So <sil=0.577> ,COMMA the 5 percent 2 expression evaluate to the remainder which in this case is 1 <sil=0.940> .PERIOD So <sil=0.500> ,COMMA so far we had been assuming that the two operands involved in a particular expression are of the same type but in general it is possible that the two operands are of different type <sil=0.944> .PERIOD So <sil=0.434> ,COMMA for example <sil=0.361> ,COMMA what is the value and indeed what is the size of the expression 5 slash 2 <sil=0.904> .PERIOD 0 is the result of type floating point with the value 2 <sil=0.908> .PERIOD 5 or is the result an integer with the value 2 <sil=0.959> .PERIOD So <sil=0.606> ,COMMA that is the question that we need to answer and the answer is that in such cases where the two operands for an operator are of different type then the value of the operand of the lower type is promoted to that of the higher type <sil=0.908> .PERIOD This is known as implicit type conversion will discuss what the higher and lower types mean in a minute <sil=0.984> .PERIOD Essentially the higher of the two types is roughly taking the one which can store a larger set of values <sil=0.976> .PERIOD So <sil=0.534> ,COMMA for example <sil=0.427> ,COMMA the type float would be higher than the type in <sil=0.915> .PERIOD So <sil=0.623> ,COMMA in this particular example you see that the two operands are 5 and 2 <sil=0.920> .PERIOD 0 as you know by now by default the type of the integer literal 5 is in whereas <sil=0.301> ,COMMA that of the floating point literal 2 <sil=0.930> .PERIOD 0 is double <sil=0.981> .PERIOD So <sil=0.584> ,COMMA now double is a higher type than in and so therefore <sil=0.371> ,COMMA what is going to happen is that the value 5 is going to get promoted to a double and that will result in the value 5 <sil=0.973> .PERIOD 0 and the result of the operation therefore <sil=0.491> ,COMMA would also be a double since both the operands are now of the type double and of course <sil=0.485> ,COMMA the floating point division is going to get used since both the operands are of type double and the answer would be 2 <sil=0.983> .PERIOD 5 of type double <sil=0.947> .PERIOD Note that in this implicit type conversion if one of the operands happens to be for example <sil=0.397> ,COMMA a variable then it is not the type of the variable that is itself getting changed <sil=0.913> .PERIOD So <sil=0.301> ,COMMA if you had the in this case instead of 5 divided by 2 <sil=0.943> .PERIOD 0 we had 5 divided by x where x is of type float and the value is 2 <sil=0.965> .PERIOD 0 <sil=0.947> .PERIOD For example <sil=0.349> ,COMMA in this expression 5 divided by 2 <sil=0.951> .PERIOD 0 suppose you had a slightly different expression <sil=0.921> .PERIOD Let us say we had an integer variable called x of the value 5 and then we had the expression x divided by 2 <sil=0.906> .PERIOD 0 <sil=0.947> .PERIOD Then the type of x would not change as a result of the implicit type conversion that is x would continue to have the value 5 and the type int but the value of x as used in this expression that is what is going to get changed <sil=0.981> .PERIOD So <sil=0.627> ,COMMA the value will become 5 <sil=0.995> .PERIOD 0 and the type will become floating point but let me state it once again <sil=0.984> .PERIOD It is not the type of x which is changing it is only the value of x as used in this expression whose type is being changed <sil=0.994> .PERIOD So <sil=0.505> ,COMMA let us look at this type hierarchy of higher and lower type <sil=0.934> .PERIOD So <sil=0.532> ,COMMA as we accept the roughly speaking that the higher type is one which can hold a larger range of values <sil=0.979> .PERIOD So <sil=0.481> ,COMMA you can imagine that the type hierarchy is going to look something like this <sil=0.901> .PERIOD Long double is the highest type followed by double then float <sil=0.488> ,COMMA then unsigned long <sil=0.522> ,COMMA then long <sil=0.400> ,COMMA then unsigned it and int <sil=0.965> .PERIOD Note that unsigned long does not really hold a larger set of values then long for example <sil=0.346> ,COMMA because the only difference is that the unsigned long type does not allow for negative integers whereas long does allow for negative integers <sil=0.962> .PERIOD But the largest positive value that can be stored in the type unsigned long is larger than the largest integer that can be stored in type long <sil=0.920> .PERIOD But still the language defines the type unsigned long to be higher than the type long <sil=0.934> .PERIOD Now <sil=0.538> ,COMMA the types which are smaller than int which are these types these are types like short <sil=0.567> ,COMMA unsigned <sil=0.638> ,COMMA short <sil=0.400> ,COMMA care and unsigned care <sil=0.917> .PERIOD These are always promoted to type int before being used in an arithmetic operation <sil=0.961> .PERIOD So <sil=0.594> ,COMMA for example <sil=0.585> ,COMMA if you had two short let us say x and y of with values 5 and 2 respectively then x divided by y in the expression x divided by y both the values would actually get promoted to the type int <sil=0.935> .PERIOD And so <sil=0.331> ,COMMA this expression would be equivalent to integer 5 divided by integer 2 which would result in an integer value of integer value 2 <sil=0.975> .PERIOD So <sil=0.585> ,COMMA in the expression 5 plus 2 <sil=0.932> .PERIOD 5 is the apply these rules 5 has type int 2 <sil=0.957> .PERIOD 5 has type double <sil=0.916> .PERIOD So <sil=0.374> ,COMMA the 5 gets promoted to double and it becomes double 5 <sil=0.947> .PERIOD 0 divided by double 2 <sil=0.916> .PERIOD 5 and therefore <sil=0.622> ,COMMA the result is the value 2 <sil=0.929> .PERIOD 0 which is double <sil=0.930> .PERIOD Okay <sil=0.605> ,COMMA let us not talk about another important notion associated with expressions and operators that is the notion of precedence and associativity <sil=0.952> .PERIOD Now <sil=0.491> ,COMMA again this is something that should be familiar to you from your high school arithmetic <sil=0.957> .PERIOD As you know in some expression we need to use bracket to unambiguously specify the operands for each operator in the expression <sil=0.997> .PERIOD And where brackets are not used as you know some convention is used to determine which operator will be evaluated first <sil=0.965> .PERIOD If you recall you had the BODMAS rules from school which trace at the precedences <sil=0.994> .PERIOD Brakets are evaluated first followed by division multiplication addition and then subtraction <sil=0.979> .PERIOD And within the two operators of the same time the left to right rule applies that is the operator at the left is evaluated first <sil=0.999> .PERIOD So <sil=0.375> ,COMMA the three language defines similar rules for determining how the expression is to be evaluated when the operands for each operator are not clear <sil=0.912> .PERIOD So <sil=0.462> ,COMMA also operators that we have seen so far the three operators star <sil=0.539> ,COMMA slash and first hand have higher precedence than the other two operators namely plus and minus <sil=0.947> .PERIOD Here we are talking only about the binary operator <sil=0.933> .PERIOD The unary operator as we will see later later all have higher precedence than all of these binary operators and all as all of these five operators as you see it left to right <sil=0.916> .PERIOD What does that mean <sil=0.927> ?QUESTIONMARK Let us take an example to clarify this issue <sil=0.973> .PERIOD So <sil=0.326> ,COMMA let us consider the expression x minus y into z divided by 10 plus 3 <sil=0.975> .PERIOD So <sil=0.332> ,COMMA the question is what are the operands for these operators which are being used <sil=0.959> ?QUESTIONMARK There are four operators in this expression the minus the star <sil=0.455> ,COMMA the slash and slash <sil=0.991> .PERIOD To recall that the the precedence of star and slash is higher than that of minus and slash which means that star and slash are going to be evaluated before the minus and slash <sil=0.986> .PERIOD But out of these star and slash since the associativity for both of them is left to right <sil=0.953> .PERIOD Therefore <sil=0.568> ,COMMA the one which efforts on the left will be evaluated first which means that the operator star is the one that will get evaluated first followed by slash and after that minus and then plus because again the associativity of minus and plus is left to right which essentially means that at the same level at the same bread thing level the operator on the left is going to be evaluated first <sil=0.924> .PERIOD So <sil=0.407> ,COMMA therefore <sil=0.516> ,COMMA the evaluation order of these operands is star followed by slash followed by minus followed by plus and so therefore <sil=0.459> ,COMMA this expression is going to be treated as equivalent to while star left the whole thing divided by 10 x minus the result of this division and 3 is added to the result of this subtraction <sil=0.904> .PERIOD Note that the precedence and associativity rules tell us in what order the different operators within the expression are going to be evaluated <sil=0.977> .PERIOD But it does not say in what order the two operands of the particular operator are going to be evaluated <sil=0.935> .PERIOD For example <sil=0.519> ,COMMA the precedence rules do not tell us whether expression y is going to be evaluated before the expression y before the expression z <sil=0.985> .PERIOD Now <sil=0.544> ,COMMA of course of the kinds of expressions that we have seen so far this does not really make any difference but when we look at operators with side effects we will see that this sometimes may make a difference and therefore <sil=0.634> ,COMMA it is important to be clear about this point <sil=0.968> .PERIOD Similarly <sil=0.314> ,COMMA its precedence and associativity rules do not say whether x is going to be evaluated before this expression y star z slash 10 it might be either way <sil=0.971> .PERIOD So <sil=0.536> ,COMMA we will come back to this point later on when we talk about operators with side effects <sil=0.928> .PERIOD So <sil=0.397> ,COMMA we have seen the arithmetic operators now let us look at different some other kinds of operators <sil=0.956> .PERIOD Relational operators are also another important kind of operator <sil=0.978> .PERIOD Relational operators essentially compare two quantities and return a Boolean value that is through a fault <sil=0.956> .PERIOD We call that there is no Boolean type in C really and any numeric type can be used as a Boolean type <sil=0.999> .PERIOD But these operators will always result in the type in in and the result will always be either 0 or 1 <sil=0.928> .PERIOD Remember that 0 stands for false and any non-zero quantity represents true but with these operators the result will result if the school will always be the integer 1 <sil=0.990> .PERIOD So <sil=0.322> ,COMMA these are the relational operators defined by C less than less than equal to greater than greater than equal to equal to <sil=0.918> .PERIOD Now <sil=0.477> ,COMMA this is the comparison equality comparison operator which should be distinguished carefully from the single equal operator which is the assignment operator <sil=0.960> .PERIOD Note that comparing to quantities in this question does not change any anything it does not result in modification of any variable and so on <sil=0.921> .PERIOD Whereas <sil=0.513> ,COMMA the assignment operator does result in the modification of the variable on the left hand side <sil=0.991> .PERIOD So <sil=0.527> ,COMMA this is different from the assignment operator we will talk about the assignment operator in more detail stat later on and this is not equal to operator <sil=0.961> .PERIOD So <sil=0.500> ,COMMA the meaning of these things should be here for example <sil=0.356> ,COMMA x less than y will result in the value 0 if x is not less than y that is x less than y is false and for result in the value 1 if x is indeed less than y <sil=0.934> .PERIOD The precedence of all these operators is lower than that of plus and minus and associativity for all these operators is left to right <sil=0.972> .PERIOD Flat later on we will look at the precedence and associativity table of all the operator stat here seen so far <sil=0.965> .PERIOD So <sil=0.648> ,COMMA the relational operators are essentially useful because they compare quantities and they let us change the flow of control of the program depending on the result whether the result is true or false and so on and in some cases and these are used as the condition in the if statements and the while statements and so on <sil=0.915> .PERIOD In some cases as we have seen earlier in the example that we saw last time that of computing whether number is prime or not the condition that we might require in an if statement or in a while loop may be more complicated than a single comparison of two quantities <sil=0.964> .PERIOD We might want to say that if something holds and something else also then do something then otherwise do something else and so on so forth <sil=0.971> .PERIOD So <sil=0.584> ,COMMA therefore <sil=0.567> ,COMMA we need the so called logical operator and again the logical operator also result in a Boolean value that is two or false and in the three language the result in the value 0 or 1 of the type integer <sil=0.953> .PERIOD Remember that 0 stands for false and 1 stands for true and there are three logical operators we have already seen some of them in action in some examples that we saw last time <sil=0.909> .PERIOD The logical and operator is denoted by 2 m percent sign without any blank in between <sil=0.955> .PERIOD The logical or operator is 2 vertical bars and the logical not operator is the exclamation sign <sil=0.997> .PERIOD So <sil=0.356> ,COMMA we need to see what these operators really mean and in what cases do they produce the value 0 or 1 <sil=0.949> .PERIOD So <sil=0.369> ,COMMA let us discuss that in detail <sil=0.914> .PERIOD So <sil=0.451> ,COMMA let us see precisely what the value of expression even and it would be remember that even and it do are any numeric type expression and 0 denotes false and any non-zero quantity denotes true <sil=0.998> .PERIOD So <sil=0.460> ,COMMA the result of the compression even and it do can be described by what is known as a truth table <sil=0.962> .PERIOD So <sil=0.447> ,COMMA there are only four possible values for even in D2 in terms of Boolean values even in D2 can be both true or false and so there are four combinations even a true or false E2 is true or false <sil=0.910> .PERIOD Note remember that true means any non-zero quantity that is even if it has any non-zero value it is considered as true and if it has value 0 and it is considered as false <sil=0.901> .PERIOD So <sil=0.341> ,COMMA there are these four combinations possible for the values of even D2 in terms of Boolean values and correspondingly the result of the expression even and E2 is going to be true or false <sil=0.942> .PERIOD So <sil=0.372> ,COMMA the expression even and E2 is going to be true if and only if both even and E2 are true and recall that the value of the expression if it is true is always one <sil=0.907> .PERIOD So <sil=0.377> ,COMMA the value of the expression even in D2 is going to be one if both even in E2 are true that is both are non-zero if any of them is false that is any of them has the value 0 then even and E2 is false and so the value of the expression will be 0 <sil=0.975> .PERIOD Similarly <sil=0.424> ,COMMA we can define it to table for the expression even or E2 again the four possibilities <sil=0.994> .PERIOD So <sil=0.616> ,COMMA in this case the expression even or E2 is going to be true if either E1 is true or E2 is true or if both of them are true <sil=0.910> .PERIOD So <sil=0.527> ,COMMA it is going to be false in only one here when both E1 and E2 are false and so we have 0 over here and 1 in all the three entries and similarly we can talk about the truth table for the naught of data which is denoted by the exclamation sign <sil=0.999> .PERIOD So <sil=0.540> ,COMMA if we have an expression not E where is some other expression then we can also define it to table the difference is that naught is a unary operator and therefore <sil=0.530> ,COMMA there are only two possibilities for E which are true and false and correspondingly the value of naught E is going to be false and true or respectively that is if E is true then not E is false which means it has the value 0 and if E is false then not E has the value true which means that it is value is 1 <sil=0.938> .PERIOD Note that if the value of E happens to be 5 that is taken as true and so the value of naught E will be 0 but if E happens to be false that is if the value of E is 0 then the result will always be 1 and not any other non-zero value <sil=0.955> .PERIOD For the arithmetic operator set we have seen so far recall that we said that the order in which the two operands are evaluated is not defined by the precedence and associativity rules <sil=0.915> .PERIOD In the case of the AND or operators on the other hand the language does define the order in which T2 operands are evaluated <sil=0.989> .PERIOD So <sil=0.304> ,COMMA for both E1 or E2 and E1 and E2 the first operand is evaluated first <sil=0.996> .PERIOD So <sil=0.509> ,COMMA for an expression E1 and E2 the program will first evaluate expression E1 and if E1 happens to be false note that regardless of what the value of E2 is the answer is going to be 0 <sil=0.977> .PERIOD Therefore <sil=0.625> ,COMMA in the expression E1 and E2 the expression E1 is going to be evaluated first and if it turns out to be false that is 0 then the expression E2 will not get evaluated at all and the result of the entire expression will be 0 and similarly in E1 or E2 the expression E1 will be evaluated first and if its value turns out to be non-zero that is it is true then regardless of what is the value of E2 the answer of the expression even or E2 is always going to be true that is 1 and so therefore <sil=0.366> ,COMMA if E1 evaluates to true that is non-zero then E2 does not get evaluated in this case at all and the value of the entire expression is 1 <sil=0.904> .PERIOD E2 will get evaluated in this case only if the expression E1 evaluates to false that is 0 and in the case of E1 and E2 the expression E2 will get evaluated only if E1 is evaluated to true that is E1 evaluates to the value true that is any non-zero value only then E2 will get evaluated because this E1 turns out to be false and there is no need to evaluate the second operand of the expression <sil=0.991> .PERIOD This fact is not very significant right now but again as I said earlier once we see expressions with side effects then it will make a difference as to whether or not a particular expression is evaluated because that might result in changes to the values of some variable and therefore <sil=0.475> ,COMMA this fact is important to remember we will come back to this when we talk about expressions with side effects <sil=0.933> .PERIOD So <sil=0.447> ,COMMA here is a complete coincidence and associativity table for all the operator's sets we have seen so far and these operators are in the decreasing order of precedence that is the logical knot and the unary plus and the unary minus operators are have the highest coincidence and the associate right to left not left to right next higher coincidence is that of the star flash in percent operators then plus and minus and then the less than greater than etcetera of a relational operators less than less than equal to greater than greater than equal to and below that are the two equality and not equality operators equals and not equals and finally <sil=0.412> ,COMMA the logical and followed by the logical or and except for the unary operators in this table of the highest coincidence the rest all associate left to right <sil=0.957> .PERIOD So <sil=0.332> ,COMMA let us now see some examples of expressions and see how they are interpreted in accordance with this precedence and associativity table <sil=0.997> .PERIOD So <sil=0.329> ,COMMA here is the first example i less than j minus 1 this is the same as i less than within brackets a minus 1 this is because less than has a lower coincidence than the minus operator which means that minus will be evaluated first which means that the bracketing is like this <sil=0.948> .PERIOD Okay <sil=0.610> ,COMMA let us look at a slightly more complicated expression this time this expression is x less than equal to 3 and y is equal to 5 minus t or z less than 7 <sil=0.953> .PERIOD Now <sil=0.407> ,COMMA the different operators in this expression are less than equal to here and equal minus or less than so <sil=0.395> ,COMMA you go back to the table you will see that minus of these operators the minus operator has a higher coincidence followed by less than and less than equal to followed by equal followed by and followed by or which means that the operator is going to be evaluated in this order that is the minus operator is going to get evaluated first which means that we can straight away put bracket around 5 minus t <sil=0.933> .PERIOD Once that is done the next higher coincidence operators are less than equal to in less than of these since the associativity is left to right the less than equal to operator will get evaluated first <sil=0.932> .PERIOD So <sil=0.485> ,COMMA x less than equal to 3 is bracketed and then z less than 7 is bracketed and after that the next has has the coincidence operator is equal to so it gets bracketed like this and finally <sil=0.623> ,COMMA the end operator gets evaluated and after that the or of it gets evaluated <sil=0.914> .PERIOD Let us look at a general example this kind of expression is commonly used in mathematics to denote that the quantity y is between the quantities x and z that is x less than y and y is less than z but if you apply the rules that we have just seen so far we will find that in C this is not true and the expression x less than y less than z is actually not the same as the expression x less than y and y less than z <sil=0.940> .PERIOD In fact <sil=0.409> ,COMMA if you apply the associativity rules it is the same as x less than y and then they are same less than z <sil=0.930> .PERIOD So <sil=0.437> ,COMMA in this expression this is x less than y will evaluate to either 0 or 1 depending on whether x is or x is not less than y and then we are comparing red against 0 or 1 which is probably not what was intended <sil=0.940> .PERIOD So <sil=0.447> ,COMMA in this lecture we have talked about operators of various kinds in particular we have talked about arithmetic operators <sil=0.598> ,COMMA relational operators and logical operators <sil=0.902> .PERIOD They are also seen what is meant by the precedents and associativity rules for these operators <sil=0.968> .PERIOD In the next lecture we will start with operators with side effects and then go on to formally describe the control statements in C which you have already been informally introduced to like the if statement and the while is open <sil=0.965> .PERIOD you you you you you you <sil=0.930> .PERIOD Hello <sil=0.382> ,COMMA we had ended the last lecture by writing a simple C program to compute the sectoral of a given non-negative integer <sil=0.923> .PERIOD Today <sil=0.420> ,COMMA what we will do is to start again with that program and I set it and try to understand how it works <sil=0.928> .PERIOD The idea is to understand basic construct of the C language before discussing them in a more formal setting <sil=0.918> .PERIOD So <sil=0.364> ,COMMA let us look at this program again <sil=0.922> .PERIOD This is a program that we had written last time with a few modifications <sil=0.993> .PERIOD So <sil=0.619> ,COMMA let us start examining it line by line and see what is happening in this program <sil=0.917> .PERIOD So <sil=0.606> ,COMMA what we have here is what is known as a command <sil=0.967> .PERIOD A command is a piece of information which the machine will completely ignore and this is intended only as information for people who are going to read this program <sil=0.939> .PERIOD Although not very important in this particular program because this is a particularly simple program but as we write more and more complex programs it will become increasingly more important to write command so that we ourselves and those others who read our programs can understand what our program is doing and how it is doing that <sil=0.988> .PERIOD So <sil=0.386> ,COMMA you see anything enclosed between a slash star and a star slash is a command <sil=0.901> .PERIOD So <sil=0.466> ,COMMA this entire thing is a command form here to here and this command basically just gives some simple information about what this program does <sil=0.972> .PERIOD Let us come to the next line <sil=0.935> .PERIOD This is hash include acdio <sil=0.941> .PERIOD h <sil=0.949> .PERIOD We will not explain the syntax in detail here in this lecture <sil=0.939> .PERIOD But let me just explain what is the purpose of such a statement or line this program <sil=0.902> .PERIOD Actually <sil=0.518> ,COMMA there are a lot of useful library functions that are available to a C programmer to give some example we have functions to find a significant values for example the sign cosine <sil=0.558> ,COMMA tangent etcetera of a given angle and so on so forth <sil=0.968> .PERIOD Apart from that we have a number of useful functions which will start seeing slowly one there are two libraries particularly of interest to us in this course that is the standard C library and the math library the functions that I mentioned just now just like sign cosine etcetera the belong to the math library <sil=0.918> .PERIOD In this program we are going to use two functions for input and output mainly Sennash which you can see here <sil=0.972> .PERIOD This is for reading some input from the user and print S which you see here <sil=0.954> .PERIOD This is used for writing some output to the terminals and these are not defined by the C language itself but our functions made available to us by the standard C library and this slide here include acdio <sil=0.904> .PERIOD h basically tells the compiler that in our program we are going to use some functions I or related functions from the standard C library <sil=0.961> .PERIOD So <sil=0.471> ,COMMA let us now go to the next slide this main void and an opening curly base <sil=0.998> .PERIOD It is not important to understand exactly the significance of main void at this point in time we will just say that at this point in time we will just say that this line signifies the compiler that here comes my program this is where the program begins and the entire program is between this opening base or the parenthesis and this closing curly parenthesis or the closing drain <sil=0.961> .PERIOD So <sil=0.644> ,COMMA this entire thing is the body of our program as it is called within the body of the program this first line declares two variables and results <sil=0.933> .PERIOD So <sil=0.314> ,COMMA this is known as a variable declaration this line says that I am going to use two variables in my program whose names are respectively n and result and both these variables are going to hold integer value <sil=0.999> .PERIOD So <sil=0.422> ,COMMA integer is a type which is denoted in C by n there are a number of other useful types in C as well which we will see later on right now the integer type is enough for us <sil=0.941> .PERIOD So <sil=0.380> ,COMMA essentially this sign saying that we will use two variables in our program their names are n and result and both are going to hold integer value in C as in most languages before you use any variable you must declare that variable and the program most of the time the variable declaration will be first followed by the actual actions that you want the program to perform <sil=0.931> .PERIOD So <sil=0.597> ,COMMA the next line is a call to a library function called canes as explained earlier the canes is a standard field library function which is used to read some data from the user <sil=0.920> .PERIOD It has two what are known as arguments this percent D encapsulated within double code characters is the first argument and this m percent n is the second argument and this this this percent D within the double code characters is what is known as a string we will talk about strings in more detail later on in the course <sil=0.956> .PERIOD But essentially this particular piece of information which you are supplying to sanafi saying that in the input we are expecting the user to give an integer value and the second argument m percent n says where we want this value given by the user to be stored in <sil=0.932> .PERIOD So <sil=0.620> ,COMMA essentially this this entire line is saying that we are expecting an integer to be input by the user and whatever integer he gives as input should be stored in the variable called n <sil=0.962> .PERIOD This line we have already seen earlier this is just an assignment statement if you recall that by equal to sin m c is an assignment statement you call that this line is not stating that the result is equal to 1 on the other hand it is an action this is a nays the value of result to be equal to 1 <sil=0.913> .PERIOD So <sil=0.608> ,COMMA it is an initialization we are setting the result to 1 you remember the algorithm for the factorial computing factorial from the previous lecture and remember that we have to repeatedly multiply the result by n as long as n was more than 1 and in each step also decrement the value of n by 1 <sil=0.930> .PERIOD So <sil=0.621> ,COMMA this here is a while loop and this while loop says that some piece of code has to be repeatedly executed and along with the while we have to say two things how long that computation has to be repeated <sil=0.989> .PERIOD So <sil=0.454> ,COMMA this is the condition and greater than 1 which says how long the computation has to be repeated it has to be repeated as long as the value of n is greater than 1 as as soon as the value of n becomes less than 1 that is less than or equal to 0 then the computation has to be stopped and what has to be done in each step or each iteration of the while loop that is again and closed within this curly brace here and the proponing closing curly brace here <sil=0.956> .PERIOD So <sil=0.403> ,COMMA along with while we have to give a condition like this and you have to give a single C statement an assignment is a single C statement as we already see <sil=0.366> ,COMMA but here as you know we want to do two things repeatedly in every iteration of the loop namely assigning result to result into n and decrementing the value of n <sil=0.984> .PERIOD So <sil=0.376> ,COMMA these are two statements by putting them within a curly brace we make these two simple statements into what is known as a compound statement <sil=0.927> .PERIOD So <sil=0.560> ,COMMA the result is that this and as thing is now a single C statement because it has been encapsulated in this opening brace and this closing brace and the compound statement itself as you can see is a number of simple statement and close in the brace square and finally <sil=0.387> ,COMMA when this loop is done as we know the value of result contains the factorial of n <sil=0.923> .PERIOD So <sil=0.342> ,COMMA we need to print that <sil=0.910> .PERIOD So <sil=0.641> ,COMMA we are printing the value of result here in this statement using the C library function again called printer and again in printer we have to specify essentially what we want to print <sil=0.944> .PERIOD We want to print an integer so that is what this person B denotes and this backslash n denotes that after this integer has been printed the cursor should move on to the next line the backslash n stands for the new line collector in C and of course <sil=0.565> ,COMMA what integer should be printed is this value that is the value of the variable called result <sil=0.946> .PERIOD Note that in SANF when we specify where the value that has been read from the user it is replaced the variable has to be preceded by an ampersand whereas <sil=0.646> ,COMMA when printing we do not have to give this ampersand right now just remember this as a rule we will explain later why this is so <sil=0.971> .PERIOD So <sil=0.599> ,COMMA hopefully this program is correct and you have understood this let us now go ahead and make some minor modifications to this program to enhance it <sil=0.995> .PERIOD The first simple enhancement that will make to this program is that when we run this program we want the user to be told that the program is expecting an integer as an input <sil=0.947> .PERIOD As of now the user does not get this information let us compile the current program and see how it runs <sil=0.928> .PERIOD You see the program just appears to solve and the user is supposed to type some number here so let us say it type 10 and the answer is printed but the user does not really know what is going on here then the integer is expected <sil=0.951> .PERIOD So <sil=0.327> ,COMMA as we could give some message saying that we want him to input a number then that will be useful <sil=0.983> .PERIOD So <sil=0.512> ,COMMA how do we do that <sil=0.954> ?QUESTIONMARK Well we already know how to print some message using the printf function <sil=0.951> .PERIOD So <sil=0.387> ,COMMA all we need to do is to add a printf statement before this kind of statement <sil=0.954> .PERIOD So <sil=0.472> ,COMMA that before the program stops and wait for the input it prints a message on the screen saying that some integer input is expected <sil=0.901> .PERIOD So <sil=0.423> ,COMMA let us add a printer statement <sil=0.985> .PERIOD Note that we have not added a backflash and at the end of this string because after this message is printed we do not want the cursor to go to the next line <sil=0.968> .PERIOD We will see in a minute what is going to happen when we run this program let us make another simple change <sil=0.979> .PERIOD When we show the output let us also say that this number that we are printing is actually the factorial of the number that was input <sil=0.911> .PERIOD So <sil=0.489> ,COMMA we want something what we want to appear is something like 5 factorial is equal to 120 <sil=0.990> .PERIOD So <sil=0.465> ,COMMA to do that we need to print another integer and therefore <sil=0.578> ,COMMA another percent D and after this integer we want the factorial sign to come and then equals and then there the result of the factorial of the given number <sil=0.977> .PERIOD And now this printer string contains 2 percent D and therefore <sil=0.564> ,COMMA as the following arguments to the printer function call we should supply 2 integers <sil=0.999> .PERIOD The first integer is n and the second integer is result <sil=0.972> .PERIOD So <sil=0.582> ,COMMA what is going to happen is that when this line is executed this string will be printed on the screen as it is except that the first percent D will be replaced by the value of n and the second percent D will be replaced by the value of result <sil=0.948> .PERIOD So <sil=0.392> ,COMMA let us save this program completely again and see how it works the same <sil=0.939> .PERIOD You see that it is asking us to enter an integer n and because we did not end the string with the back layer n the cursor is on the same line and has not gone to the next line <sil=0.914> .PERIOD So <sil=0.527> ,COMMA let us enter again 10 <sil=0.918> .PERIOD There is an error <sil=0.956> .PERIOD So <sil=0.364> ,COMMA let us go back and correct this error <sil=0.969> .PERIOD Why has this error occurred <sil=0.899> ?QUESTIONMARK This error has actually occurred because the value of n has decimented in this loop 10 times and 9 times and has finally become 1 <sil=0.963> .PERIOD Remember that in every iteration of the loop we are decimiting n by 1 <sil=0.959> .PERIOD So <sil=0.478> ,COMMA at the end of the loop the value of n has actually become just 1 regardless of what the original value is <sil=0.924> .PERIOD We want to frame the initial value of n here it has saved the old value of n <sil=0.992> .PERIOD So <sil=0.346> ,COMMA we can save that into another variable let us call that initial n and the initial value of this will be just n <sil=0.907> .PERIOD Note that we are using a new variable now and so therefore <sil=0.318> ,COMMA we need to declare this variable as well the tight is a real integer <sil=0.900> .PERIOD So <sil=0.496> ,COMMA here is the declaration of initial n and this n must be replaced by initial n <sil=0.901> .PERIOD I think we are all done with these changes to the program <sil=0.977> .PERIOD Let us write out again some pilot again and run it again 10 and we see 10 factorial is equal to the value of 10 <sil=0.903> .PERIOD So <sil=0.543> ,COMMA here okay <sil=0.974> .PERIOD Let us now make some more changes to this program <sil=0.942> .PERIOD What happens if I when running this program is I give a negative value for 10 let us write that for n and sorry let us give minus 2 <sil=0.938> .PERIOD The result comes out to be 1 which obviously is wrong in fact the factorial of negative number is not defined at all <sil=0.997> .PERIOD So <sil=0.545> ,COMMA how did we get this result 1 <sil=0.915> ?QUESTIONMARK Well issue examine this program suppose the value of n is minus 1 what is going to happen <sil=0.969> ?QUESTIONMARK The result is initialized to 1 initial n is initialized to minus 2 and then we execute this loop while n greater than 1 and what is the value of n <sil=0.960> ?QUESTIONMARK The value of n is minus 2 which is not greater than 1 <sil=0.965> .PERIOD So <sil=0.535> ,COMMA the loop terminates right away and these two statements do not get executed even 1 and as a result the value of the variable result does not change at all it remains whatever it was before the execution of the loop which is 1 and therefore <sil=0.492> ,COMMA we are getting this around me a result minus 2 factorial equal to 1 <sil=0.938> .PERIOD What we should have program do instead is that it is a negative value for n is given it should print a message saying that the factorial function is defined only for non negative integers <sil=0.905> .PERIOD Well how do we do that <sil=0.977> ?QUESTIONMARK Well after it is quite easy after reading the value of n we have to check whether or not it is more than 0 <sil=0.984> .PERIOD If it is more than 0 or if it is greater than or equal to 0 we do all this computation otherwise we simply print a message saying that factorial is defined only for non negative integers and to do that we will need to use another statement of t which is an if-else construct which essentially does something if a condition is true and something else possibly if the condition is solved <sil=0.943> .PERIOD So <sil=0.345> ,COMMA what should be the condition here <sil=0.939> ?QUESTIONMARK The condition should be if n is greater than equal to 0 <sil=0.959> .PERIOD So <sil=0.576> ,COMMA if n is greater than equal to 0 then we want to perform all the computation from here to here <sil=0.903> .PERIOD So <sil=0.351> ,COMMA therefore <sil=0.337> ,COMMA this will be the then part of the if statement that is that is the part that will execute if this condition is indeed true that is if n is greater than equal to 0 <sil=0.978> .PERIOD Note how the greater than equal to condition is written in C with a greater than sign followed by n equal to sign and just like the while looks here along with the condition we are supposed to give a single C statement which says what should be done if the the single C statement which should be executed is the condition actually evaluate to true and since we have number of these statements here we need to include these statements again within basis to make a compound statement out of these and if the value of n is indeed less than 0 that is it is not greater than equal to 0 then we want to execute something else which is just printing a message saying that factorial is defined only for non-negative integers <sil=0.971> .PERIOD Note that in the S part there is only a single C statement that we want to execute namely this printf function and therefore <sil=0.335> ,COMMA we do not need to put this within basis even though if we did put them in basis it would be fine <sil=0.944> .PERIOD So <sil=0.498> ,COMMA this program will work but I am not quite satisfied with this because even though this is syntactically correct and it will actually work but this is hard to read <sil=0.931> .PERIOD Note that so far we have been following a style of writing a program which we have not explicitly discussed but let me now illustrate what I am trying to say <sil=0.992> .PERIOD These two statements consume the body of this while loop and because these two statements are indented to the left to the right and sorry by a certain amount that is we start here whereas <sil=0.560> ,COMMA the while started at this location <sil=0.917> .PERIOD So <sil=0.518> ,COMMA it was quite clear that these two statements are within the while loop <sil=0.987> .PERIOD This is called indentation and this is very necessary to make our program readable <sil=0.946> .PERIOD Similarly <sil=0.636> ,COMMA note that here since this printf is within the L we have started it at a horizontal location after the part after the case we are the S start <sil=0.976> .PERIOD So <sil=0.594> ,COMMA what is wrong with this program <sil=0.895> ?QUESTIONMARK Well <sil=0.551> ,COMMA if you see this entire sequence of statement is within the if statement which is a kind of proper statement for all these statements and therefore <sil=0.634> ,COMMA they should start further towards the right then the program will be much more readable <sil=0.958> .PERIOD So <sil=0.421> ,COMMA we need to insert some blank spaces here so that they start more to the right <sil=0.945> .PERIOD In C actually you can liberally you know in the first are statements with number of spaces and blank lines as we wish but a certain programming style as I said is desirable so that the program is readable <sil=0.993> .PERIOD Instead of inserting number of spaces it is usually convenient to just insert a tab character this is on the left top area of your keyboard <sil=0.910> .PERIOD So <sil=0.549> ,COMMA let us just press the tab character here and as you see the tab character is roughly equivalent to number of spaces <sil=0.929> .PERIOD So <sil=0.412> ,COMMA this statement has now gone to the left that is to the same thing with this statement with this statement what about these two these are actually within while so they should be further intended to the right <sil=0.919> .PERIOD So <sil=0.540> ,COMMA one more tab here one more tab here this brace is the ending of the while so it should be at the same level as at the while here and this printf again is at the same level as divide it is directly within the if so it should come here and now you can see the program is much more readable it is clear that these two statements for example are within if the while is within the if but these two statements are within the while this is within the if <sil=0.930> .PERIOD So <sil=0.468> ,COMMA let us now save this program again and try to compile it and hope that there are no errors <sil=0.926> .PERIOD Let us try with a normal number non-negative integer for second 20 work fine let us try with a negative integer and we get what is expected namely a message thing that the factorial function is defined only for non-negative integers <sil=0.934> .PERIOD So <sil=0.568> ,COMMA there are two things that we have learnt by doing this simple enhancement to the program the first which is very important is that the program must check that all inputs given to the program by the user are within an acceptable range because if the inputs are not within the expected range the program is likely to behave in an unpredictable fashion and the output is only likely to confuse the user <sil=0.975> .PERIOD So <sil=0.497> ,COMMA therefore <sil=0.383> ,COMMA we had to check that the value of n is indeed greater than equal to 0 <sil=0.917> .PERIOD The second thing we have learnt is the importance of indentation and we have seen how it makes the program much more readable and in all programs that we write from now on therefore <sil=0.346> ,COMMA we will consistently use the indentation side that I have introduced in this lecture <sil=0.958> .PERIOD Okay <sil=0.367> ,COMMA we will now take another example problem and try to first develop an algorithm for it and then write a C program for solving that problem <sil=0.951> .PERIOD The problem is a very famous one and it has to do with water known as Fibonacci number <sil=0.998> .PERIOD The Fibonacci sequence of numbers is defined as follows these are the numbers in the sequence and as you can observe in this sequence any number is the sum of the previous two numbers in the sequence <sil=0.971> .PERIOD So <sil=0.568> ,COMMA we can define this in mathematical terms as follows <sil=0.978> .PERIOD So <sil=0.505> ,COMMA let us say F of i denotes the I Fibonacci number so F of 0 is 0 F 1 is 1 and for I greater than 1 F of i is nothing but F of i minus 1 plus F of i minus 2 <sil=0.969> .PERIOD So <sil=0.457> ,COMMA let us say given this definition we are given and integer n greater than equal to 0 and we want to compute the value of F n that is the nth number counting from 0 in the sequence that we just saw <sil=0.938> .PERIOD So <sil=0.434> ,COMMA how do we go about solving this problem <sil=0.866> ?QUESTIONMARK So <sil=0.343> ,COMMA as you can see for solving this problem what we need to do is to remember the previous two numbers in the sequence and then if we add up these two numbers we get the next number in the sequence <sil=0.906> .PERIOD So <sil=0.305> ,COMMA let us say at any point in time we want to maintain the value of A as the value of F i and B let us say as the value of F i minus 1 <sil=0.921> .PERIOD So <sil=0.455> ,COMMA suppose at any point in time in our program for some value of i less than or equal to n the value of A is the same as the value of F i and the value of B is the same as the value of F i minus 1 and then what do we do in the next step <sil=0.924> ?QUESTIONMARK What we will do is to use these two values to compute the value of F i plus 1 which will simply be A plus C <sil=0.919> .PERIOD So <sil=0.570> ,COMMA let us say it is C as A plus C and in the next step we still want this invariant to hold that is A is F of i and B is F of i minus 1 <sil=0.921> .PERIOD So <sil=0.507> ,COMMA what we will need to do is increment i to i plus 1 and the value of A will be C and the value of B will be the old value of A <sil=0.353> ,COMMA but there is a problem where is the old value of A we have already over written it with C right <sil=0.941> .PERIOD So <sil=0.615> ,COMMA we can do these two in the reverse order practice erase this little bit and write <sil=0.996> .PERIOD So <sil=0.616> ,COMMA in every step of the program this is the conversation that we are going to perform as you can imagine this will be done repeatedly as long as i is less than n <sil=0.938> .PERIOD So <sil=0.452> ,COMMA this will be repeated as long as i is less than n because as soon as i becomes equal to n and this invariant tells us that the value of F n is nothing but A <sil=0.962> .PERIOD So <sil=0.316> ,COMMA we stop doing this computation at that point in time <sil=0.940> .PERIOD So <sil=0.443> ,COMMA note that if at this point in time it was the case that A is equal to F i and B is equal to F i minus 1 then at this point in time it will also be the case that A is equal to F i and B is equal to F i minus 1 why because we have instrumented i by 1 <sil=0.573> ,COMMA but the numbers A and B now are the old values of A plus B and the old value of A respectively that is if the value of i was i 0 to begin with A was a 0 to begin with and B was B 0 to begin with then after the end of this computation the value of i will be i 0 plus 1 the value of A will be A 0 plus B 0 because A is a sin T here which is A plus B and the value of B will be B 0 <sil=0.913> .PERIOD Now <sil=0.523> ,COMMA the value of B will be A 0 and you can observe that A 0 plus B 0 is simply F of i 0 plus 1 and A 0 of course <sil=0.429> ,COMMA is F of i 0 why is A 0 plus B 0 F of i 0 plus 1 because A 0 is F of i and B 0 is F of i minus 1 and by definition of the F of i plus F of i minus 1 is F of i plus 1 <sil=0.928> .PERIOD So <sil=0.568> ,COMMA at the end of this particular computation we will again end up with these values which satisfy the invariant that at any point in time A is equal to F i and B is equal to F of i minus 1 <sil=0.979> .PERIOD Based on these ideas we can now easily develop a C program for computing the nth number in the F of i minus 1 using the tools that we have already seen by writing the factorial program <sil=0.995> .PERIOD So <sil=0.494> ,COMMA let us go and do it now <sil=1.000> .PERIOD Okay <sil=0.464> ,COMMA so let us now write a C program based on the algorithm that we just discussed to compute the nth F of nth number <sil=0.992> .PERIOD So <sil=0.384> ,COMMA let us start a editor window name of the program is going to be C dot C <sil=0.950> .PERIOD So <sil=0.571> ,COMMA let us start with a comment explaining what this program is going to do <sil=0.940> .PERIOD So <sil=0.616> ,COMMA this is a program to compute the nth F of nth number <sil=0.926> .PERIOD And remember that this is the end of the comment the star and followed by the slash and again we are going to use the strain F and print F functions from the standard C so we include F v di O dot H as C 4 and here comes our program <sil=0.953> .PERIOD We intend all statements remember by one task phase because we are all part of the main program and first thing if you remember is that we have to declare the variable set relevant to use <sil=0.982> .PERIOD So <sil=0.617> ,COMMA given to use variables n and will hold the number that the user has given to us <sil=0.955> .PERIOD A and B will use as in the algorithm that is A will hold the I f of nth number F of i <sil=0.964> .PERIOD They will hold F of i minus 1 and I itself of course is the current index of the F of nth number that we have computed and here remember we used for computing the sum of A and B <sil=0.953> .PERIOD So <sil=0.479> ,COMMA these are the variables that we are going to use <sil=0.927> .PERIOD So <sil=0.499> ,COMMA what do we do next <sil=0.905> ?QUESTIONMARK Well let us again prompt the user that a non-negative integer is expected <sil=0.927> .PERIOD Using the print F statement and then we read the value of n as before <sil=0.994> .PERIOD And again we need to check whether n is less than 0 or greater than equal to 0 because if n is less than 0 then that is not a valid input and you must terminate the program of telling the user that you must enter a non-negative integer <sil=0.954> .PERIOD So <sil=0.379> ,COMMA that check whether n is less than 0 <sil=0.443> ,COMMA if n is less than 0 and all you want to do is to print a message saying that the number you have entered that is n not a non-negative integer <sil=0.977> .PERIOD So <sil=0.329> ,COMMA let us just write not non-negative and since you use a percent D here you must specify what actual value should be replaced should replace this percent D in that of course is that right <sil=0.982> .PERIOD So <sil=0.541> ,COMMA for example <sil=0.469> ,COMMA if the user enters minus 2 this print F statement will result in output saying minus 2 is not non-negative <sil=0.935> .PERIOD And since this is the single statement that we want to execute if the value of n is less than 0 we do not need traces here <sil=0.900> .PERIOD Otherwise that is if n is greater than equal to 0 you want to do or some patient of F n <sil=0.946> .PERIOD So <sil=0.392> ,COMMA that will require multiple statements and so therefore <sil=0.499> ,COMMA we need to enclose them in traces and make them a compound statement for our own reference let us write the definition of the function F here as a comment remember <sil=0.946> .PERIOD So <sil=0.356> ,COMMA we are ready to start <sil=0.907> .PERIOD So <sil=0.306> ,COMMA we need to initialize the integer a <sil=0.323> ,COMMA b and i the value n has already been read the c we do not need to initialize the variable c we do not need to initialize because the act will be initialize phase of the value of a and b in every iteration of the loop but a <sil=0.522> ,COMMA b and i have to be initialize and remember because we have that we must ensure that at any point in time before starting a iteration of the value of k must be equal to F of i and the value of b must be F of i minus 1 <sil=0.969> .PERIOD So <sil=0.390> ,COMMA let me slide i to 1 a to 1 which is F of 1 and b to 0 because that is F of i minus 1 since i is 1 <sil=0.393> ,COMMA i minus 1 is 0 and F of 0 is 0 <sil=0.928> .PERIOD So <sil=0.530> ,COMMA therefore <sil=0.474> ,COMMA b has to be initialize to 0 note that all these statements are within the L and therefore <sil=0.381> ,COMMA they are admitted to the right by some phase after the L and next comes our though while i is less than m we need to do certain composition why we have to do them only as long as i is less than m because remember that if i become equal to m then we have already found the answer and the answer is A <sil=0.984> .PERIOD So <sil=0.607> ,COMMA while i is less than m remember what we need to do compute F plus C n let us say C then assign b to A and A to C and of course <sil=0.583> ,COMMA increment i by i plus increment i by 1 that is make it i plus 1 and at the end of the body of the winding loop and now what do we do this again still within the L part this is the composition we are doing if n is less than if n is greater than equal to 0 <sil=0.975> .PERIOD Now <sil=0.474> ,COMMA we have found f n so <sil=0.392> ,COMMA we want to print the value of f n <sil=0.961> .PERIOD So <sil=0.579> ,COMMA let us just print again using the print statement F of n is equal to the f n that we have computed and what should go here the first person should be replaced by the value of n which in this program we have not modified anywhere as you can see after reading it from the user <sil=0.916> .PERIOD We do not need to save it in some other variable we will just use n and this should be replaced by the answer which is F of n and F of n remember now is equal to A because i has become equal to n <sil=0.925> .PERIOD So <sil=0.395> ,COMMA that is all we need to do and then this is the end of the L block and this is the end of the n program <sil=0.979> .PERIOD So <sil=0.623> ,COMMA let us save this and compile this and the so <sil=0.621> ,COMMA this forming is only because i did not add new line at the end of the program not that it matters too much <sil=0.980> .PERIOD So <sil=0.622> ,COMMA let us compile it again find this side <sil=0.998> .PERIOD So <sil=0.647> ,COMMA let us enter let say 2 F of 2 is 1 is that correct yes it is because F of 2 is F of 1 plus F of 0 which means 1 plus 0 which is 1 <sil=0.905> .PERIOD So <sil=0.355> ,COMMA let us write for some more value 3 should be 2 4 should give us some of the last 2 values this 2 plus 1 3 that is correct 5 should give us 3 plus 2 which is 5 it seems to be working all right <sil=0.958> .PERIOD Let us also try with the border cases <sil=0.956> .PERIOD The border cases are the ones in which the loops will run at most ones or not at all and so on <sil=0.949> .PERIOD So <sil=0.517> ,COMMA let us first try with minus 1 in negative integer we get the correct message minus 1 is not non negative let us not try with 1 yes write answer let us try with 0 that is wrong because that is for 0 by definition by our own definition is 0 and not 1 <sil=0.939> .PERIOD So <sil=0.301> ,COMMA what went wrong in the program <sil=0.918> .PERIOD So <sil=0.369> ,COMMA suppose n was equal to 0 then what happened it came here <sil=0.450> ,COMMA initialize i to 1 a to 1 b to 0 while i less than n i is has been initialize to 1 and the value of n is 0 <sil=0.910> .PERIOD So <sil=0.538> ,COMMA i is not less than n and in fact it is not even equal to n see here in the sprint statement we assume that at the end of the loop i will be equal to n and therefore <sil=0.407> ,COMMA F of i will be equal to F of n which will in turn be equal to a <sil=0.923> .PERIOD But here is a special case in which the value of i has not become equal to n at the end of the loop in fact i here is i here is wrong while n is 0 <sil=0.917> .PERIOD So <sil=0.325> ,COMMA in this case we should print not the value of a as the answer but the value of b which of course <sil=0.355> ,COMMA is 0 <sil=0.942> .PERIOD So <sil=0.612> ,COMMA therefore <sil=0.541> ,COMMA this sprint statement has to be changed <sil=0.989> .PERIOD So <sil=0.399> ,COMMA we want to the result is a only if n is equal to i otherwise the answer is c <sil=0.927> .PERIOD So <sil=0.508> ,COMMA therefore <sil=0.362> ,COMMA we need another if l select at that if n is equal to i <sil=0.914> .PERIOD This is the first time we are using the equality operator in c <sil=0.649> ,COMMA note that this is different from the assignment which is a single equal to and this is equality or comparison between n lie whether n is actually equal to i or not <sil=0.954> .PERIOD So <sil=0.619> ,COMMA if n is equal to i then the answer that you are previously printing is indeed correct that is F of n is equal to F of i is equal to a but if it is not the case and this case number will happen only when n is 0 <sil=0.940> .PERIOD So <sil=0.458> ,COMMA if n is 0 the answer of course <sil=0.570> ,COMMA is 0 <sil=0.943> .PERIOD So <sil=0.557> ,COMMA we can just print this or of course <sil=0.587> ,COMMA we could have taken the longer form inside print F of pretend equal to pretend that place and comma n comma b not a or comma n comma 0 <sil=0.924> .PERIOD But because we know that in this case n is going to be 0 and after 1 is also going to be 0 we can just simplify it like this <sil=0.901> .PERIOD And that should solve our problem <sil=0.571> ,COMMA so let us combine this program again and let us try it this time with 0 <sil=0.909> .PERIOD It works with 1 still works 2 3 4 5 it works for all possible integer values <sil=0.912> .PERIOD So <sil=0.338> ,COMMA the program is finally correct <sil=0.908> .PERIOD So <sil=0.342> ,COMMA in this lecture we have had a general introduction to the basic elements of the C program in language <sil=0.918> .PERIOD In the next lecture onwards we will start looking at the elements of C you will see bit more detail and somewhat more homily <sil=0.948> .PERIOD But before we end to this lecture <sil=0.578> ,COMMA I would like you to leave with an assignment that you should try out on your own very similar to the problem that we have already solved in this lecture based again on the Fibonacci number <sil=0.918> .PERIOD So <sil=0.421> ,COMMA the problem that we solved was that given an n we tried to compute the value of F of n <sil=0.947> .PERIOD But suppose we are given a C and we want to write a program which says whether or not K is a Fibonacci number that is whether there exists an i such that F of i is equal to K <sil=0.978> .PERIOD And if such an i does exist then the value of i should be printed otherwise the program should say that K is not a Fibonacci number <sil=0.945> .PERIOD And to solve this problem there is a little hint that you might want to use and the hint is that this Fibonacci number sequence is monotonically increasing that is every number except in the beginning is more than the previous number in the sequence <sil=0.996> .PERIOD So <sil=0.491> ,COMMA the essential idea of solving this problem is to generate Fibonacci number 1 by 1 still we read a number which is either equal to K or more than K <sil=0.941> .PERIOD If we get a number which is equal to K then we know that it is a Fibonacci number and by keeping track of i we should be able to say which Fibonacci number it is that is what is the corresponding i such that F of i is equal to K <sil=0.971> .PERIOD On the other hand if we directly go from a number less than K to a number greater than K then clearly K is not a Fibonacci number and then the program should say that the given value is not a Fibonacci number <sil=0.930> .PERIOD So <sil=0.353> ,COMMA before we start some new topics today <sil=0.635> ,COMMA let us look again at the problem that I had before <sil=0.942> .PERIOD use the three left side for phynex which as you know is x minus x cube by p factorial plus x bar 5 by p factorial etcetera <sil=0.902> .PERIOD So <sil=0.308> ,COMMA how do we solve this problem <sil=0.945> ?QUESTIONMARK Well <sil=0.373> ,COMMA let us say we will just keep computing terms of the three one by one and keep adding them to a sum which will be the final value of phynex and this is an infinite series we will have to solve the submission when the absolute difference of two consecutive terms becomes less than a silent <sil=0.948> .PERIOD So <sil=0.396> ,COMMA before looking at the program let us try to work out an informal algorithm for doing this <sil=0.918> .PERIOD So <sil=0.308> ,COMMA let us say we will use these variables phynex will carry the sum of the terms which will finally of course give the value of the phynex and x x x term is the most recently computed term the last computed term in this series that was computed and let us say let us use the variable phynex for the term prior to the most recent term <sil=0.988> .PERIOD So <sil=0.353> ,COMMA the difference between the two terms is term minus curve term and absolute value of phynex addition <sil=0.969> .PERIOD So <sil=0.477> ,COMMA you will have to keep computing still the value of difference becomes less than a silent <sil=0.977> .PERIOD Now <sil=0.314> ,COMMA one thing that you should note in this series is that when I am computing let us say x to the power k over k factorial where k is some odd number then I do not have to compute x to power k and k factorial all over again because if I do that I will have to multiply x k times and then also multiply k by k minus 1 k minus 2 etcetera up to 1 which is the number of multiplication <sil=0.974> .PERIOD If so <sil=0.370> ,COMMA that we can use the fact that we already know what the previous term was the previous term that we had computed was x to power k minus 2 divided by k minus 2 factorial <sil=0.965> .PERIOD So <sil=0.388> ,COMMA if you just multiply this by x twice and divided by k minus 1 and k that gives us the value for the next term <sil=0.922> .PERIOD So <sil=0.638> ,COMMA let us now try to write an informal algorithm using this idea <sil=0.929> .PERIOD So <sil=0.545> ,COMMA the main loop will look something like this while difference is less than a silent <sil=0.943> .PERIOD So <sil=0.379> ,COMMA the term that we computed in the previous iteration will become the previous term for the iteration <sil=0.994> .PERIOD So <sil=0.309> ,COMMA previous term will become equal to the current value of term and new value of term will have to compute <sil=0.984> .PERIOD It is assumed that the previous value of term used a value k that is the previous the term that we had computed earlier was x for k over k factorial <sil=0.904> .PERIOD Then the new value of term would be minus term into x into x divided by k plus 1 times k plus 2 <sil=0.921> .PERIOD This minus comes because if you observe the term in the 3 I am alternating sign plus and minus and after this the value of k will become k plus 2 <sil=0.627> ,COMMA it will get incremented by k and to the value of sin x will add the value of term and what else do we need to do <sil=0.928> ?QUESTIONMARK Well <sil=0.442> ,COMMA we need to update the value of difference <sil=0.921> .PERIOD So <sil=0.640> ,COMMA difference will now be the new value of the difference which is term minus the previous term and that is it and the end of this the value of sin x is the desired answer <sil=0.959> .PERIOD So <sil=0.505> ,COMMA let us now look at the C program to do all this <sil=0.932> .PERIOD Here then is the C program to compute sin x <sil=0.969> .PERIOD Note that we have a big comment upfront which says what the program does and how it does it <sil=0.950> .PERIOD You can remember I told you earlier in the writing comments and programs is very important because they help us understand programs even the person who has himself written the program may need to understand some difficult parts of it and comment something do that <sil=0.925> .PERIOD Okay <sil=0.440> ,COMMA before we look at the other things in the program <sil=0.348> ,COMMA let us look at the mean loop of the program <sil=0.922> .PERIOD There is the mean loop and it is quite the same as what we just discussed <sil=0.964> .PERIOD Well <sil=0.428> ,COMMA while the difference is greater than the value of a silent that is as long as the desired accuracy is not obtained <sil=0.467> ,COMMA the previous term is assigned to term because we most recent computed term will not become previous term and the new term will be computed and the new term is computed from the last computed term as minus term sin x square divided by k plus 1 sin k plus 2 <sil=0.906> .PERIOD Note that the fresh and k plus 1 sin k plus 2 has to be enclosed in the next set of bracket that is because otherwise it will become equivalent to term into x square divided by k plus 1 <sil=0.368> ,COMMA but multiplied by k plus 2 instead of multiplication by instead of division by k plus 2 <sil=0.977> .PERIOD That is because really the division and the multiplication operator have the same what is known as precedence which we will talk about in detail later on and essentially they are carried out in the left to right order <sil=0.462> ,COMMA but will not worry about this <sil=0.974> .PERIOD Let us for the ending let us just put these extra places here <sil=0.987> .PERIOD So <sil=0.524> ,COMMA the value of i next gets updated by the value of this new term just get added to the old value k becomes k plus 2 <sil=0.962> .PERIOD The new distance is term minus previous term <sil=0.459> ,COMMA but remember that we want the absolute value of difference <sil=0.990> .PERIOD So <sil=0.408> ,COMMA how do we compute that that is that is straight forward is the value of distance turns out to be less than 0 then we simply change its size <sil=0.947> .PERIOD Okay <sil=0.643> ,COMMA let us now look at the initialization fact we need to perform to start off this loop <sil=0.910> .PERIOD Now <sil=0.332> ,COMMA let us have you that we have already read the value of x and epsilon above these statements in the program and show them to you in a minute <sil=0.963> .PERIOD So <sil=0.422> ,COMMA here are the initialization <sil=0.946> .PERIOD So <sil=0.621> ,COMMA we know the first term is x <sil=0.987> .PERIOD So <sil=0.578> ,COMMA therefore <sil=0.470> ,COMMA we can assign the term to be x and the initial value of i next is also x because term is already included in that <sil=0.998> .PERIOD The previous term the one before this is of course 0 <sil=0.921> .PERIOD So <sil=0.505> ,COMMA therefore <sil=0.500> ,COMMA the value of previous term is initialized to 0 and the value of difference is also x because term is x and previous term is 0 <sil=0.962> .PERIOD So <sil=0.599> ,COMMA difference is term minus previous term which is x <sil=0.944> .PERIOD But of course <sil=0.366> ,COMMA since x can be negative so this difference can be negative as well and therefore <sil=0.626> ,COMMA if distance is less than 0 <sil=0.516> ,COMMA we change the sign of the distance and because the current value of term is x to the power 1 divided by 1 factorial therefore <sil=0.521> ,COMMA x should be initialized to 1 <sil=0.923> .PERIOD Let us now see what else we need to do <sil=0.938> .PERIOD This is the standard set of statements for reading some input <sil=0.922> .PERIOD So <sil=0.354> ,COMMA we want to read the value of x and the value of the silent <sil=0.960> .PERIOD So <sil=0.394> ,COMMA from enter value for x <sil=0.519> ,COMMA read the value of x using k and s percent f <sil=0.947> .PERIOD Note that since x is going to be a floating point number of type load <sil=0.929> .PERIOD Therefore <sil=0.431> ,COMMA we have used percent f here and similarly <sil=0.598> ,COMMA you present f to read the value of epsilon <sil=0.963> .PERIOD Here are the declarations of various variables <sil=0.933> .PERIOD x is the input value <sil=0.926> .PERIOD Note that in the program I have given a comment for explaining every variable used in the program <sil=0.996> .PERIOD This helps in understandability of the program <sil=0.978> .PERIOD So <sil=0.447> ,COMMA x is the value that is going to be input to us <sil=0.979> .PERIOD The variable sin x will hold the value of sin of x <sil=0.988> .PERIOD So <sil=0.332> ,COMMA this comment says the sin x will be equal to sin of x <sil=0.954> .PERIOD We cannot use sin of x with brackets <sil=0.988> .PERIOD It self has a variable name because remember that variable names cannot contain brackets characters <sil=0.988> .PERIOD So <sil=0.579> ,COMMA just to verify that our answer is correct <sil=0.350> ,COMMA we are also going to use the math library function sin x which is built into the c math library <sil=0.933> .PERIOD Just to verify that our answer is correct <sil=0.520> ,COMMA we will also compute the value using the sin x function from the math library <sil=0.984> .PERIOD So <sil=0.413> ,COMMA the variable lib sin x is going to contain the value of sin x of sin using the math library sin function <sil=0.965> .PERIOD A epsilon of course <sil=0.495> ,COMMA is a desired accuracy <sil=0.922> .PERIOD The term and the previous term <sil=0.388> ,COMMA we already know what they are <sil=0.921> .PERIOD Term is the current term in the Taylor series <sil=0.311> ,COMMA previous term is the previous term in the series <sil=0.996> .PERIOD Rift is the difference between term and previous term actually the absolute value of that and k is the current power of x <sil=0.917> .PERIOD So <sil=0.490> ,COMMA always term is x for k divided by k factorial <sil=0.903> .PERIOD Now <sil=0.349> ,COMMA sin x is also going to use the math function name designs from the math library <sil=0.992> .PERIOD We also have to include <sil=0.374> ,COMMA we have another include statement saying hash includes math <sil=0.922> .PERIOD h <sil=0.935> .PERIOD This statement says that we are going to use a function from the math library name design function <sil=0.988> .PERIOD Remember that the hash include actually i <sil=0.973> .PERIOD o <sil=0.951> .PERIOD s is there in almost every program that we write because in almost every program that we write <sil=0.571> ,COMMA we need to use the standard input and output function <sil=0.971> .PERIOD So <sil=0.375> ,COMMA after the loop run and terminate <sil=0.639> ,COMMA finally <sil=0.471> ,COMMA we can print the value of sin x for the computed value of sin of whatever <sil=0.998> .PERIOD We want to print the x value of x here <sil=0.525> ,COMMA we just put percent f and that we get to place where x value of f and x value is another real number <sil=0.944> .PERIOD So <sil=0.601> ,COMMA therefore <sil=0.398> ,COMMA another percent f and the corresponding value is sin of x and here we are computing the same value using the math library function sign <sil=0.985> .PERIOD So <sil=0.495> ,COMMA the lip sign x sign of x <sil=0.922> .PERIOD So <sil=0.586> ,COMMA this will directly give us the value of sin of x from the math library and we are also printing this value just to compare that the value that we have computed is correct <sil=0.976> .PERIOD Okay <sil=0.559> ,COMMA so let us compile this program and see where it was correctly <sil=0.910> .PERIOD One new thing in this command line for compiling the program that you should notice is this minus LM that we have used over here <sil=0.991> .PERIOD This minus LM is required because you have to tell the compiler that we are using a function from the math library and therefore <sil=0.536> ,COMMA the math library should be linked along with our program by the compiler <sil=0.901> .PERIOD So <sil=0.619> ,COMMA it is not necessary for the standard C library function such as print f <sil=0.443> ,COMMA k and f etcetera that we have been using because the C compiler always links the standard C library along with every program that it compiles but that is not true for the math library and many other specialized libraries that we might need to use in our program <sil=0.947> .PERIOD So <sil=0.598> ,COMMA in the case of math library for example <sil=0.450> ,COMMA we have to in the program itself <sil=0.326> ,COMMA we have the include statement that we just saw <sil=0.930> .PERIOD In addition <sil=0.446> ,COMMA we have to use this minus LM flat to tell the compiler that the math library should also be linked with the program <sil=0.976> .PERIOD Okay <sil=0.478> ,COMMA the program has been compiled <sil=0.965> .PERIOD Let us now try to run it <sil=0.904> .PERIOD So <sil=0.570> ,COMMA let us try to give some familiar values for X <sil=0.985> .PERIOD You know that X i is 0 <sil=0.935> .PERIOD So <sil=0.425> ,COMMA let us try to give the value of i as the value of X <sil=0.947> .PERIOD Actually <sil=0.320> ,COMMA you want to have an accuracy up to 5 decimal points <sil=0.913> .PERIOD We can see the answer is almost 0 and in fact <sil=0.465> ,COMMA the math library function has given precisely the same value <sil=0.945> .PERIOD Let us try some other value <sil=0.954> .PERIOD Let us say 5 by 2 <sil=0.382> ,COMMA 5 by 2 is 1 <sil=0.914> .PERIOD The value of 5 by 2 is approximately 1 <sil=0.939> .PERIOD 57 and we get to 5 by 1 this time <sil=0.993> .PERIOD Okay <sil=0.488> ,COMMA so this program is working <sil=0.941> .PERIOD Okay <sil=0.466> ,COMMA let us not talk about another couple of types of values that are very useful in program <sil=0.988> .PERIOD The first such values that we will talk about are characters <sil=0.957> .PERIOD By character <sil=0.381> ,COMMA what is meant is really all these alphabet <sil=0.336> ,COMMA numerals and other facial symbols <sil=0.347> ,COMMA colon <sil=0.422> ,COMMA semicolon <sil=0.516> ,COMMA full stop <sil=0.571> ,COMMA less than <sil=0.414> ,COMMA etcetera <sil=0.421> ,COMMA that you see on the keyboard <sil=0.985> .PERIOD One very important capability of a computer is to be is that it can deal with characters also apart from just numbers <sil=0.963> .PERIOD And in particular <sil=0.359> ,COMMA it can deal with strings which are with a string is nothing but a sequence of characters <sil=0.976> .PERIOD We will not talk too much about handling of characters in this lecture <sil=0.905> .PERIOD We will leave that to a later lecture <sil=0.912> .PERIOD But we want to talk about and let us see about the representation of characters inside the computer <sil=0.959> .PERIOD So <sil=0.355> ,COMMA how as you know that every data <sil=0.456> ,COMMA every piece of data inside the computer is represented as a sequence of bits which are nothing but zeros and one <sil=0.920> .PERIOD So <sil=0.305> ,COMMA the question is how would characters represented in Mandarin and the natural answer is that we simply assign some codes to different characters <sil=0.902> .PERIOD Let us say integer code to the various characters <sil=0.999> .PERIOD And when you own a storey character in memory <sil=0.519> ,COMMA we just store the corresponding integer code <sil=0.924> .PERIOD There are several standard coding which have been defined by various codeys and many such codeys are in use <sil=0.992> .PERIOD Some of these codeys are called S-key <sil=0.386> ,COMMA Unicode <sil=0.562> ,COMMA U-T-F-A-T <sil=0.318> ,COMMA etcetera <sil=0.492> ,COMMA etcetera <sil=0.460> .PERIOD The C programming language that you are using uses the S-C standard which essentially is a standard for defining impetus codes corresponding to all characters that you can see on the keyboard <sil=0.955> .PERIOD So <sil=0.573> ,COMMA in the S-key coding <sil=0.490> ,COMMA the different characters are assigned codes from 0 to 127 <sil=0.987> .PERIOD So <sil=0.552> ,COMMA that means the total of 128 characters can be represented <sil=0.935> .PERIOD Only the Roman alphabet is supported <sil=0.901> .PERIOD In some of the other coding schemes <sil=0.598> ,COMMA for example <sil=0.556> ,COMMA in Unicode and U-T-F-A <sil=0.613> ,COMMA you can infect support characters from many different trips like Devnagry and many other trips <sil=0.918> .PERIOD So <sil=0.475> ,COMMA but we will be focusing on S-key for this code because that is what C uses <sil=0.924> .PERIOD So <sil=0.475> ,COMMA here are some examples of S-C codes <sil=0.963> .PERIOD The codes for the characters A to Z are contiguous one after the other <sil=0.989> .PERIOD The code for small A character <sil=0.534> ,COMMA small A is 97 <sil=0.923> .PERIOD That for small Z is 122 <sil=0.937> .PERIOD B is 98 <sil=0.635> ,COMMA C is 99 and so on <sil=0.911> .PERIOD The A to A to A to Z are also one after the other <sil=0.946> .PERIOD A is 65 <sil=0.512> ,COMMA A is 66 and so on <sil=0.965> .PERIOD A is 90 <sil=0.923> .PERIOD And similarly <sil=0.429> ,COMMA the characters 0 to 9 have the S-C code 48 to 57 <sil=0.931> .PERIOD Note <sil=0.614> ,COMMA carefully that we should always be careful in distinguishing between the characters 0 and the integer 0 <sil=0.941> .PERIOD The characters 0 would be represented by the S-C code for 0 <sil=0.323> ,COMMA which is 47 <sil=0.643> ,COMMA which is 48 and sorry <sil=0.925> .PERIOD Whereas <sil=0.411> ,COMMA the integer 0 would be stored internally just as the 0 in binary <sil=0.461> ,COMMA which is all bit set to 0 <sil=0.933> .PERIOD So <sil=0.599> ,COMMA therefore <sil=0.481> ,COMMA the characters 0 and the integer 0 are very <sil=0.640> ,COMMA very different <sil=0.981> .PERIOD The C type correct R <sil=0.495> ,COMMA which we have already visited in the last lecture <sil=0.529> ,COMMA is usually used in programs to store characters that we might be reading from the input or we might be manipulating these characters and so on <sil=0.994> .PERIOD And the reason for using this type <sil=0.416> ,COMMA is remember that the cache type is an integer type for which exactly one byte is used for storage <sil=0.584> ,COMMA which means that numbers from minus 128 to 127 can be represented <sil=0.958> .PERIOD And since the S-C code has codes from 0 to 127 <sil=0.470> ,COMMA any character can be represented using the track type <sil=0.953> .PERIOD But in principle <sil=0.328> ,COMMA any integer type can be used to hold a character because <sil=0.452> ,COMMA automatically remember that a character is internally stored as an integer <sil=0.546> ,COMMA which is the S-C code for that particular character <sil=0.986> .PERIOD And we can of course <sil=0.374> ,COMMA use unsigned cache because the range for unsigned cache is going to be from 0 to 255 <sil=0.963> .PERIOD Another important type of values that we will often need to deal with in our program are what are known as Boolean value <sil=0.911> .PERIOD And Boolean value is nothing but just two or all <sil=0.945> .PERIOD We often need to remember just the truth or falsity of some condition in the program <sil=0.983> .PERIOD We will shortly see an example of the program that uses this notion <sil=0.935> .PERIOD These values which are just two or all <sil=0.325> ,COMMA they are called Boolean value <sil=0.372> ,COMMA after the famous mathematician called Boolean <sil=0.927> .PERIOD There is no Boolean type in C and really to store Boolean values that is to store through or all <sil=0.591> ,COMMA what we can do is to use any integer type <sil=0.332> ,COMMA character <sil=0.316> ,COMMA integer <sil=0.379> ,COMMA long <sil=0.355> ,COMMA short <sil=0.448> ,COMMA any of the values <sil=0.953> .PERIOD And in the integer representation for Boolean in C <sil=0.312> ,COMMA the value 0 be known called whereas <sil=0.547> ,COMMA any non-zero value which may be negative or positive denotes true <sil=0.900> .PERIOD Okay <sil=0.328> .PERIOD So <sil=0.331> ,COMMA another example problem that we are going to call today is to find out whether a given integer n which is greater than 0 is prime or not <sil=0.918> .PERIOD So <sil=0.629> ,COMMA the primary testing problem has been actually a very fascinating problem for mathematicians for a long time and people have tried to come up with a physical algorithm for solving this problem and only recently as in fact <sil=0.517> ,COMMA as recent as last year <sil=0.482> ,COMMA this problem was solved in a very efficient fashion <sil=0.996> .PERIOD Our those algorithms are fairly complicated when you will use very easy <sil=0.462> ,COMMA very easy algorithm which should be familiar to all of you for solving this problem and that algorithm follows directly from the definition of primary <sil=0.947> .PERIOD You know that the number is prime if and only if it is visible by no other number other than 1 and itself <sil=0.985> .PERIOD So <sil=0.302> ,COMMA if there is some other factor of n other than 1 and itself then n is not a prime <sil=0.918> .PERIOD So <sil=0.384> ,COMMA essentially the idea to find whether n is prime or not <sil=0.626> ,COMMA what we need to do is to test whether n has any factor other than 1 and then or not <sil=0.910> .PERIOD So <sil=0.333> ,COMMA we need to test four factors from 2 to n minus 1 <sil=0.974> .PERIOD However <sil=0.306> ,COMMA we do not need to test all these numbers to check whether there any of them is a factor of n or not because you know that if there is a factor of n let us say let us say p which is greater than square root of n then there must be another factor q which is less than square root of n <sil=0.966> .PERIOD Why is that <sil=0.867> ?QUESTIONMARK If you take simply q to be n by p since p is a factor of n therefore q must be an integer that is p only divided by n and since p is greater than square root of n and p times q is n therefore q must be less than square root of n <sil=0.949> .PERIOD What does that tell us <sil=0.883> ?QUESTIONMARK That tells us that we need to do for a divisor or a factor of n only from 2 up to square root of n <sil=0.986> .PERIOD If we cannot find a factor of n from 2 to square root of n that means there cannot be any factor greater than square root of n either apart from n of course it tells <sil=0.982> .PERIOD So <sil=0.514> ,COMMA how do we use this to use these factors to fashion the algorithm <sil=0.869> ?QUESTIONMARK So <sil=0.589> ,COMMA central idea is very simple let us use a variable called t which is the potential factor that will be test whether it is a factor of n or not <sil=0.922> .PERIOD What do we test whether p is a factor of n or not <sil=0.962> ?QUESTIONMARK We just have to check the remainder of the division of n by p and test whether the remainder is 0 or not <sil=0.958> .PERIOD So <sil=0.363> ,COMMA if p is a factor then the remainder would be 0 and you see there is an operator called the percent operator which does precisely that <sil=0.964> .PERIOD So <sil=0.426> ,COMMA n percent p will give us exactly the value of the remainder when n is divided by p <sil=0.987> .PERIOD So <sil=0.395> ,COMMA if n percent p is equal to 0 this implies that p is a factor of n <sil=0.952> .PERIOD So <sil=0.450> ,COMMA what we need to do is to have a little bit of flow run it looks from 2 to square root of n and so <sil=0.361> ,COMMA p will vary from 2 to square root of n in that loop and if at any step p is a factor of n then we should stop the loop <sil=0.998> .PERIOD So <sil=0.420> ,COMMA the loop will look like this while some condition if the remainder of n is equal to 0 <sil=0.986> .PERIOD So <sil=0.394> ,COMMA if we have a factor of dividing remainder of n by p is 0 then we know that n is not a prime indeed p is a factor of n which is other than 1 and n itself and we need to do something the we need to in fact stop the loop otherwise we just have to implement p where p plus 1 <sil=0.944> .PERIOD I have a question mark here because we do not really know what we need to write here <sil=0.933> .PERIOD So <sil=0.606> ,COMMA the question really is how long this loop should run <sil=0.986> .PERIOD Now <sil=0.610> ,COMMA clearly this loop has to keep has to has to fall as soon as the value of p becomes greater than 2 to square root of n <sil=0.988> .PERIOD So <sil=0.494> ,COMMA therefore <sil=0.306> ,COMMA it must be running only as long as p is less than equal to square root of n <sil=0.999> .PERIOD But if we find 1 factor of p 1 factor of n then we do not need to test the further integers of 2 to square root of n because <sil=0.621> ,COMMA himing 1 factor of n is good enough to say that n is not a prime <sil=0.901> .PERIOD So <sil=0.439> ,COMMA therefore <sil=0.528> ,COMMA we must stop the loop as we find a factor if we find a factor if you do not find a factor then of course <sil=0.504> ,COMMA the loop will terminate when ultimately p becomes greater than square root of n it will finally <sil=0.324> ,COMMA become greater than square root of n because <sil=0.352> ,COMMA in every iteration we are implementing p by 1 <sil=0.971> .PERIOD So <sil=0.463> ,COMMA now we need to in this case remember this growth or falsity of the condition that n percent p is equal to 0 or not <sil=0.948> .PERIOD So <sil=0.432> ,COMMA let us use a Boolean variable to to this value <sil=0.933> .PERIOD Let us call that Boolean variable as form <sil=0.986> .PERIOD So <sil=0.642> ,COMMA form will be either true or false will start out a call <sil=0.986> .PERIOD So <sil=0.642> ,COMMA true will be initialized to call and I am sorry <sil=0.624> ,COMMA form will be initialized to call and will become true as soon as we find 1 factor of n <sil=0.921> .PERIOD So <sil=0.495> ,COMMA therefore <sil=0.390> ,COMMA it should be set to true whenever we find that n percent p has become equal to 0 <sil=0.947> .PERIOD So <sil=0.308> ,COMMA this question mark should now be replaced with form the sand true and this condition which we since have not completed <sil=0.982> .PERIOD So <sil=0.611> ,COMMA you must keep running the loop as long as p is less than equal to n less than equal to square root of n and we have not found a factor because <sil=0.401> ,COMMA as soon as we find a factor we should terminate the loop <sil=0.973> .PERIOD So <sil=0.611> ,COMMA this is the basic idea of the algorithm note that we have used a Boolean variable found here which of course <sil=0.357> ,COMMA in the C program as we have the scene will be represented using a variable of type int only because <sil=0.593> ,COMMA there are no Boolean types in C and we have also used two operations on Boolean value and or hand and not <sil=0.941> .PERIOD So <sil=0.620> ,COMMA the operation mark essentially <sil=0.460> ,COMMA inverse the truth value that is the value is true not of that value is called and vice versa <sil=0.921> .PERIOD So <sil=0.622> ,COMMA if the value of found is true then not found is false and similarly <sil=0.414> ,COMMA if the value of found is false then not found is true and the operator and is a binary operator that is it has two operands <sil=0.945> .PERIOD So <sil=0.418> ,COMMA in this example here are the two operands <sil=0.908> .PERIOD He less than equal to square root n and not found <sil=0.908> .PERIOD So <sil=0.349> ,COMMA essentially what the and operator does is that it gives the value true is both the operands have the value true right <sil=0.929> .PERIOD So <sil=0.536> ,COMMA if p is less than square root of n less than equal to square root of n and not found is true meaning that found is false then this entire expression will have the value true and therefore <sil=0.548> ,COMMA if that is the case then this loop will continue whereas <sil=0.447> ,COMMA if either of these two conditions is false that is either p becomes greater than square root of n in which case we should terminate the loop because we have not been able to find any factor and we have tested all possible factors from 2 to square root of n or if we have found a factor then also we should terminate the loop because we know now that p is n is not a prime and p is a factor for n <sil=0.965> .PERIOD So <sil=0.375> ,COMMA if found is true then not found is false and since and and gives the value true only is both the operands are true it will give the value false and therefore <sil=0.324> ,COMMA the loop will terminate <sil=0.965> .PERIOD So <sil=0.579> ,COMMA let us now convert these ideas into a c program <sil=0.937> .PERIOD So <sil=0.477> ,COMMA here is a program based on the algorithm which we just discussed <sil=0.993> .PERIOD So <sil=0.634> ,COMMA start out with recommend as usual seeing what the program does <sil=0.917> .PERIOD So <sil=0.597> ,COMMA it finds other a non negative integer is trying or not by trying to find a factor for it we have to include the cdi <sil=0.997> .PERIOD x file as usual math <sil=0.913> .PERIOD x we have included because there will be use the square root function from the math library <sil=0.936> .PERIOD So <sil=0.352> ,COMMA as you know now that the c language is not defined in the Boolean type it we use integer type for Boolean as well <sil=0.975> .PERIOD So <sil=0.601> ,COMMA we are going to represent we are going to use the value 1 to represent true and 0 to represent false we call that every non 0 value is considered true and 0 is false <sil=0.988> .PERIOD So <sil=0.399> ,COMMA it is Boolean convention to use 1 as value for true and here is one more way of defining constants in the program in the program that we had written in the last lecture for concluding the area of a circle we had defined constants by declaring them as variables but to fixing the declaration with the world constant <sil=0.983> .PERIOD This is one more way <sil=0.918> .PERIOD So <sil=0.616> ,COMMA it is to say has defined true one and has defined false 0 what this essentially means is that in the rest of the program wherever the world true or the world false appeared that will be replaced by the value 0 or by the value 1 as the case might be <sil=0.902> .PERIOD So <sil=0.465> ,COMMA here is the main program this time we are using slightly different type we are using the type unsigned long for n so that n can be as big as we can manage as big as we can handle and has to be always non negative <sil=0.995> .PERIOD So <sil=0.435> ,COMMA therefore <sil=0.322> ,COMMA we can make it unsigned some lovely potential divisor is unsigned long and the initial value potential divisor is true <sil=0.957> .PERIOD So <sil=0.366> ,COMMA the potential divisor is the variable C that we had been using in that column <sil=0.909> .PERIOD So <sil=0.495> ,COMMA in the program we are using more verbose for variables longer than for variable <sil=0.902> .PERIOD So <sil=0.491> ,COMMA that we know precisely what a variable stands for and what is the function that is performing in the program and the variable found that we were using in the journalism is or found a divisor in this particular program and precisely as you can see the name precisely specified or indicate exactly what is meant by this variable what is the purpose of this variable <sil=0.993> .PERIOD Now <sil=0.485> ,COMMA this has to be conceptually if it is a type Boolean because it is only hold a two or false value <sil=0.901> .PERIOD So <sil=0.375> ,COMMA what we in see we have to use some integer type for this variable <sil=0.994> .PERIOD So <sil=0.392> ,COMMA we have used a type care we could have used any integer type but we have used a type care because a type care requires the least amount of storage among the integer type <sil=0.972> .PERIOD So <sil=0.399> ,COMMA using the type care or representing Boolean variables is a good practice because the program does not in that case use unnecessary storage and of course <sil=0.532> ,COMMA we just need to represent the value 0 and 1 <sil=0.935> .PERIOD So <sil=0.578> ,COMMA care type is good enough <sil=0.959> .PERIOD Now <sil=0.327> ,COMMA max size is going to the value of square root of n or in fact <sil=0.431> ,COMMA the number the integer which is just below the square root of n <sil=0.964> .PERIOD In other words max size is going to be the flow of square root of n <sil=0.945> .PERIOD Note that the square root of n need not be an integer <sil=0.911> .PERIOD For example <sil=0.488> ,COMMA if n is n then the square root of n is 3 point something <sil=0.929> .PERIOD So <sil=0.525> ,COMMA in that case max size should be 3 we do not need to test for any divisor above 3 because if there is a divisor above 3 then there will be divisor below 3 as well <sil=0.917> .PERIOD So <sil=0.523> ,COMMA here is the starting the program <sil=0.924> .PERIOD We read the number as usual after entering it from and similarly compute the square root of n by using the square root function in the math library <sil=0.931> .PERIOD The square root function actually gives a double value and we are assigning this double value to a variable of type unsigned long remember that max size unsigned long <sil=0.915> .PERIOD So <sil=0.419> ,COMMA here the compiler automatically converts the double value to an unsigned long value <sil=0.908> .PERIOD It is called implicit type conversion which will not talk into much detail in this structure we talk about it later <sil=0.939> .PERIOD But <sil=0.433> ,COMMA intuitively what is happening here is that out of the double value when it is converted to an unsigned long integer the fractional part of the real number will be talked off and only the integer part will be retained <sil=0.936> .PERIOD So <sil=0.325> ,COMMA here is the main loop pretty much what we saw in the algorithm <sil=0.912> .PERIOD The condition for the while look is while potential divisor is less than equal to max size and so this square of the two M percent denotes the AND logical or Boolean operation in C and this grand corrector or the exclamation mark denotes the negation operation negation Boolean operation or the not Boolean operation in C <sil=0.924> .PERIOD So <sil=0.557> ,COMMA the loop condition is while potential divisor is equal to max size and we have not so far found the divisor <sil=0.977> .PERIOD Note that the loop will terminate when either potential divisor becomes greater than max size or we find divisor <sil=0.952> .PERIOD So <sil=0.487> ,COMMA if n percent potential divisor is 0 then found divisor is said to prove otherwise potential divisor is simply implemented by one <sil=0.920> .PERIOD Note that the body of the while look is a single if-else statement <sil=0.918> .PERIOD So <sil=0.427> ,COMMA this entire thing is a single if-else statement and therefore we do not need braces around the body of the while look because this is just one statement and similarly the then part of the if statement is a single handman statement <sil=0.940> .PERIOD So <sil=0.630> ,COMMA we do not need braces here and the else part is also a single handman statement <sil=0.969> .PERIOD So <sil=0.491> ,COMMA we do not need braces around this either <sil=0.908> .PERIOD So <sil=0.396> ,COMMA of course if we put braces there is no problem with that <sil=0.983> .PERIOD So <sil=0.448> ,COMMA this is the end of the loop at the end when the loop terminates if you have found divisor that means that n is not a crime <sil=0.962> .PERIOD So <sil=0.333> ,COMMA in fact if love just saying n is not a crime we also say that n is not a crime because here is a factor of n which is not 1 and which is not n <sil=0.968> .PERIOD So <sil=0.571> ,COMMA personally is a factor of 1st person is replace the potential divisor which of course is the actual which is the actual divisor that we found or the actual factor that we found and this person is of course <sil=0.367> ,COMMA we replace for the value of n <sil=0.949> .PERIOD If the variable found divisor is all then the print that the given number n is a crime <sil=0.997> .PERIOD So <sil=0.392> ,COMMA it is a pretty straight forward program <sil=0.912> .PERIOD Let us not try to compile this and see whether it works correctly <sil=0.968> .PERIOD Again we have to use the minus lm flag to compile this program because we are using the square root function from the math library and if you remember we had also included math <sil=0.995> .PERIOD h in the program file itself <sil=0.991> .PERIOD So <sil=0.564> ,COMMA let us now just execute this program <sil=0.929> .PERIOD Let us try with some non-frient number let us say 16 <sil=0.624> ,COMMA 2 is the factor of 16 <sil=0.980> .PERIOD Let us try with the larger number 324 of course <sil=0.305> ,COMMA 2 will again be a factor <sil=0.958> .PERIOD So <sil=0.565> ,COMMA let us try 327 the same 3 is a factor <sil=0.303> ,COMMA 2 is of course a factor let us try with some prime number 17 is a prime 19 is a prime 23 is a prime and so on <sil=0.991> .PERIOD So <sil=0.419> ,COMMA the program is working correctly <sil=0.948> .PERIOD So <sil=0.514> ,COMMA this brings us to the end of this lecture <sil=0.979> .PERIOD In the next lecture we will start talking about operators in C of various times <sil=0.976> .PERIOD We will start with arithmetic operators and then talk about different other different kinds of operators like bullion operators etc <sil=0.976> .PERIOD in more detail and we will see how complicated expressions can be formed out of by using and combining these different operators in various ways <sil=0.952> .PERIOD They have already been using these operators in the programs that we have been writing <sil=0.427> ,COMMA but we will discuss them more commonly in the next lecture and also discuss some of the subtle details associated with these operators <sil=0.909> .PERIOD Thank you <sil=0.959> .PERIOD you you you you you you you <sil=0.931> .PERIOD In today's lecture we will talk about two very important problems which find applications in most application areas <sil=0.901> .PERIOD These are the problems of searching and sorting <sil=0.552> ,COMMA I will explain what these problems are and we will try to develop and analyze some algorithms for these problems <sil=0.970> .PERIOD So <sil=0.589> ,COMMA let us talk about the searching problem first <sil=0.907> .PERIOD The problem is very simple <sil=0.539> ,COMMA we are given an array of n element <sil=0.490> ,COMMA this could be of any type really and we need to find out whether another given value is present in the array or not <sil=0.930> .PERIOD And let us say if it is present in the array <sil=0.516> ,COMMA we return the index in the array at which this element is present or if it is not present in the array <sil=0.493> ,COMMA we can return minus 1 <sil=0.914> .PERIOD Now <sil=0.586> ,COMMA this problem is of course very simple as you might imagine <sil=0.978> .PERIOD All one has to do is to look at each element of the array 1 by 1 and compare it with the given element and if there is a match <sil=0.501> ,COMMA if the two values are equal <sil=0.521> ,COMMA then we have found the element in the array and we know at what place in the array it has <sil=0.959> .PERIOD And we exhaust all the elements of the array <sil=0.555> ,COMMA then clearly the element is not in the array <sil=0.918> .PERIOD So <sil=0.601> ,COMMA this algorithm is called linear search and clearly it takes time proportional to n to find the answer in the worst case because in the worst case <sil=0.490> ,COMMA we may have to look at all the elements in the array to say to find the before finding a match or before saying that the element does not exist in the array <sil=0.975> .PERIOD Let us quickly see the C function for implementing this algorithm <sil=0.979> .PERIOD So <sil=0.358> ,COMMA this is the function search <sil=0.320> ,COMMA it takes as argument an array and the size of the array <sil=0.988> .PERIOD So <sil=0.309> ,COMMA there are assumed to be n elements in the array and E is the element that we are searching for in the array A from A 0 to A of n minus 1 <sil=0.944> .PERIOD So <sil=0.318> ,COMMA the algorithm is very simple <sil=0.504> ,COMMA we have a loop that runs for I from 0 to n minus 1 that is for each index in the array and in each iteration we compare A i with E and if the value of A i is equal to the value of E <sil=0.492> ,COMMA then we return the index at which we found this element that is I <sil=0.998> .PERIOD And if this loop finishes that is become all of the loop that means that this return statement never executed and that happened because we never found a match and so therefore <sil=0.443> ,COMMA we return minus 1 to indicate that the element E is not in the array <sil=0.984> .PERIOD So <sil=0.585> ,COMMA you can see that in the worst case there will be n iterations of this for loop and each iteration takes a constant time and therefore <sil=0.429> ,COMMA clearly the worst case time complexity of the algorithm is order n <sil=0.959> .PERIOD So <sil=0.302> ,COMMA the question is can we do better than order n for searching and the answer is no if there is nothing known about the elements of the array because in the worst case we do need to look at all elements of the array at least once <sil=0.901> .PERIOD So <sil=0.533> ,COMMA therefore <sil=0.334> ,COMMA we must do time we must to effort proportional to n but if we know something about the array elements then we can do better <sil=0.940> .PERIOD So <sil=0.406> ,COMMA suppose the array is sorted that is the array elements are known to be arranged in the non in non decreasing or non increasing order <sil=0.993> .PERIOD Now <sil=0.642> ,COMMA if that is the case and that happens in many situations that the array is already arranged in certain fashion then we can actually do search in at most order log in time <sil=0.981> .PERIOD Now <sil=0.647> ,COMMA do we do that the basic idea is very simple if we compare the I's element of A with E and E happens to be greater than A i that means that E cannot be present from A 0 to A i because we know that A i is less than E and since if you are assuming that the elements are arranged in a non decreasing order that means A 0 to A minus 1 they must also be less than E <sil=0.920> .PERIOD So <sil=0.379> ,COMMA therefore <sil=0.525> ,COMMA we need to now focus our attention for searching only to the part of the array which is to the right of A i that is from A i plus 1 to A n minus 1 and similarly if A i happens to be greater than E that means that E cannot be present in A i plus 1 to A n minus 1 because the elements are assumed to be arranged in non decreasing order <sil=0.905> .PERIOD So <sil=0.371> ,COMMA if A i is greater than E then A i plus 1 A i plus 2 etcetera are also greater than E and therefore <sil=0.479> ,COMMA we do not need to look at all these elements to locate E <sil=0.917> .PERIOD So <sil=0.640> ,COMMA that is the basic idea of the well known binary search algorithm and this is how the algorithm is <sil=0.929> .PERIOD So <sil=0.376> ,COMMA in each step we compare E with the middle element of the part of the array that we are looking for that we are looking at <sil=0.958> .PERIOD So <sil=0.559> ,COMMA we basically compare E with A m where m is equal to m by 2 that is the middle element of the array <sil=0.901> .PERIOD If A E and A m are equal then clearly we have found E in the array and we have found it at index m <sil=0.995> .PERIOD So <sil=0.439> ,COMMA M is the answer if E is less than M if E is less than A m then we restrict our first two A 0 to A m minus 1 because we know that E cannot be anywhere from A m to A of n minus 1 and similarly if E is greater than A m then we restrict the search to be to the second half of the array that is from A of m plus 1 to A of n minus 1 <sil=0.920> .PERIOD And so <sil=0.540> ,COMMA in one step itself the problem one step reduces to half because in the next step we have to consider only half the array and similarly after the second step will have only one fourth of the array left that we have to search for E in <sil=0.985> .PERIOD And if we keep repeating this process in each step we keep reducing the part of the array we have to look at that we have to look at by half and so it is easy to see that in log n steps the array size will become will will reduce to 1 or 0 in which case the problem is trivially solvable in a constant amount of time <sil=0.988> .PERIOD So <sil=0.579> ,COMMA let us now implement this as a C function <sil=0.938> .PERIOD So <sil=0.533> ,COMMA again the header for the function is the same we are given the array A the size n of the array A that is it has elements from A 0 to A n minus 1 total of n elements and E is the value that we are looking for <sil=0.958> .PERIOD This variable is low and high indicate what part of the array we are currently focusing our attention on that is this is the part of the array in which we need to search for E <sil=0.930> .PERIOD And as we as we saw when we discuss the algorithm in every step this part of the array gets reduced to about half of the size that it was in the last step <sil=0.956> .PERIOD To begin with the entire array has to be looked at and therefore <sil=0.535> ,COMMA low is pointing to the very first element of the array that is low is equal to 0 and high is the index of the very last element of the array which is equal to n minus 1 <sil=0.919> .PERIOD So <sil=0.479> ,COMMA that is why low is initialized to 0 and high is initialized to 1 because we have to look at the entire array from indices 0 to n minus 1 <sil=0.923> .PERIOD The variable mid will be used to compute the index of the middle element of the part of the array that we are currently looking at <sil=0.935> .PERIOD Now <sil=0.313> ,COMMA the number of elements that we need to look at is high minus low plus 1 clearly and so if low becomes greater than high then the number of elements that we that are there in the part of the array that we are looking at will become 0 <sil=0.945> .PERIOD So <sil=0.311> ,COMMA in which case we will have found the answer if the size of the array that we need to look at becomes 0 that means <sil=0.542> ,COMMA e cannot be anywhere in the array <sil=0.999> .PERIOD So <sil=0.534> ,COMMA we know the answer is answer that we need to return e is minus 1 <sil=0.994> .PERIOD So <sil=0.395> ,COMMA where sir as long as low is less than equal to high we keep repeating this process we compute the middle index of this array fragment and if e is equal to the middle element we return this index otherwise if e is less than a of mid then so this is mid <sil=0.915> .PERIOD So <sil=0.531> ,COMMA if e happens to be less than a of mid that means e is to be find found somewhere in this part of the array <sil=0.957> .PERIOD So <sil=0.573> ,COMMA which means that high should be set to mid minus 1 whereas <sil=0.351> ,COMMA low should remain the same so that in the next step we focus only on this part of the array whereas <sil=0.528> ,COMMA if e is greater than a mid then we need to focus our attention on this part of the array in the next step which means that low should become mid plus 1 whereas <sil=0.459> ,COMMA high should remain the same <sil=0.933> .PERIOD And when the loop terminates that can only terminate and if we reach this statement we should have a return minus 1 here which I omitted by mistake <sil=0.915> .PERIOD So <sil=0.597> ,COMMA this loop terminates and we reach this statement that means <sil=0.383> ,COMMA we did not find the element anywhere in the array because otherwise we would have returned from the function using this return statement and so if we come out of the loop then we know that the element e is not in the array and so we return minus 1 <sil=0.987> .PERIOD Let us see a couple of examples using animations to see how this algorithm is working <sil=0.967> .PERIOD So <sil=0.497> ,COMMA let us say this is the given array 3 <sil=0.577> ,COMMA 4 <sil=0.489> ,COMMA 7 <sil=0.928> ,COMMA 19 <sil=0.383> ,COMMA 21 <sil=0.356> ,COMMA 23 <sil=0.529> ,COMMA 30 and what we are looking for is 4 which of course <sil=0.407> ,COMMA we know is present here <sil=0.918> .PERIOD So <sil=0.593> ,COMMA initially low is 0 <sil=0.452> ,COMMA mid is 6 <sil=0.549> ,COMMA there are 7 elements in the array I am sorry high is 6 because there are 7 elements in the array and mid is 6 plus 0 by 2 which is equal to 3 <sil=0.990> .PERIOD So <sil=0.361> ,COMMA mid is pointing here <sil=0.978> .PERIOD So <sil=0.404> ,COMMA we compare e with a mid now e 4 and a mid is 19 and so e is lesser and therefore <sil=0.544> ,COMMA in this step high moves to mid minus 1 and then mid becomes the new value of mid becomes low plus high by 2 which is 0 plus 2 by 2 which is 1 and so in the next step we again compare a mid with e and this time they are equal because a mid is 4 which is equal to the value of e <sil=0.915> .PERIOD So <sil=0.424> ,COMMA we have found the answer and the index 1 gets returned <sil=0.945> .PERIOD Let us look at another example in this case we have the same array but we are searching for the element 22 <sil=0.903> .PERIOD So <sil=0.382> ,COMMA now 22 is larger than a mid which is 19 and so <sil=0.496> ,COMMA low will move to mid plus 1 and mid will correspondingly change <sil=0.930> .PERIOD So <sil=0.539> ,COMMA low has become 4 and high is 6 so <sil=0.448> ,COMMA the new value of mid is 6 plus 4 by 2 which is 5 and this time again we come they are a mid with e which is 22 and we find 22 is lesser than 23 <sil=0.979> .PERIOD So <sil=0.625> ,COMMA high will become mid minus 1 mid is re computed <sil=0.971> .PERIOD Now <sil=0.585> ,COMMA low and high have become equal but still the loop will continue because recall that the loop condition was while low is less than equal to high <sil=0.936> .PERIOD Low is still equal to high so <sil=0.394> ,COMMA this condition is true <sil=0.970> .PERIOD So <sil=0.549> ,COMMA mid is re computed and it will return out to be 4 again because low and high are both 4 <sil=0.968> .PERIOD So <sil=0.454> ,COMMA we compare 21 which is a mid with the value of e which is 22 and e is greater than this <sil=0.979> .PERIOD So <sil=0.543> ,COMMA that means that low will become now mid plus 1 and once that happens in the next then the loop terminates because the value of high value of low has actually become higher than the value of high which means that the fragment of the array that we are now looking at has size 0 and an array of size 0 clearly cannot contain any element and so <sil=0.506> ,COMMA the loop terminates and we return a failure to find the element in the array <sil=0.906> .PERIOD Ok <sil=0.343> ,COMMA let us now analyze this algorithm that we just developed <sil=0.949> .PERIOD So <sil=0.638> ,COMMA let us say the time taken in the worst case is T n as a function of n which is the array size and as for all the first three functions as in this case we can again come up with the recurrence relation for T n because in every step we are reducing the problem size by half <sil=0.916> .PERIOD So <sil=0.595> ,COMMA if n is 0 which means low is actually greater than high then takes a constant amount of time C 1 otherwise T n is T of n by 2 plus C 2 because if the array size is n then in the next step the array size reduces to at most the floor of n by 2 <sil=0.995> .PERIOD So <sil=0.390> ,COMMA it is not really a recursive function of course <sil=0.362> ,COMMA we could have implemented the same algorithm recursively as well <sil=0.523> ,COMMA but it is still easy to express the time taken as a recurrence relation <sil=0.990> .PERIOD So <sil=0.368> ,COMMA we have done that and this recurrence relation of course <sil=0.482> ,COMMA should be familiar to you from the last lecture when we looked at the square in multi-clay algorithm this is exactly the same recurrence relation and as we saw last time we can solve it to obtain the fact that T n is order log n which means that the time being taken by this algorithm is proportional to log n instead of n and the number of elements of the array that we are looking at in the worst case is just log n instead of looking at all the n elements <sil=0.927> .PERIOD Let us now look at the second problem that we want to discuss today and that is the problem of sorting <sil=0.964> .PERIOD The problem of sorting is simply to arrange a given array of elements in some order may be the non-decreasing order or the non-increasing order will we will consider only the non-decreasing order clearly the algorithm will remain the same only the direction of comparison will really change and it does not really matter <sil=0.936> .PERIOD There are a number of sorting algorithms which have been developed for this problem <sil=0.932> .PERIOD What we will look at today is a very simple algorithm called the insertion sort not the most efficient algorithm known for this problem this is an algorithm which is commonly used by card players when they have a set of cards in their hand and they need to sort it they take the next card and insert it at the right place in the card prior to that <sil=0.934> .PERIOD So <sil=0.415> ,COMMA that is what the basic idea of the insertion sort algorithm also is <sil=0.979> .PERIOD So <sil=0.461> ,COMMA at any given step let us assume that the elements a 0 to a i minus 1 are already sorted and to begin with of course if we set i to 1 then a 0 a single element is of course always sorted if an array sequence of one element is obviously trivial is sorted <sil=0.907> .PERIOD So <sil=0.462> ,COMMA to begin with this is true for i equal to 1 but at some intermediate step let us assume that a 0 to a i minus 1 are correctly sorted but the rest of the elements are not really in the correct places <sil=0.999> .PERIOD So <sil=0.454> ,COMMA in this particular step what we are going to do is to make sure that the size of the sorted sequence becomes one larger that is at the end of this step will achieve the condition that a 0 to a i are correctly sorted <sil=0.906> .PERIOD So <sil=0.462> ,COMMA to do that what we are going to do is to insert a i in its correct position among a 0 to a i minus 1 <sil=0.949> .PERIOD So <sil=0.578> ,COMMA that after this step a 0 to a i are correctly sorted and this procedure is repeated from i for i from 1 to n minus 1 <sil=0.927> .PERIOD So <sil=0.446> ,COMMA after the first step the first two elements would get sorted after the second step the first three elements would be sorted and so on and so after the n minus 1 of step the all the n elements of the array would get sorted <sil=0.911> .PERIOD Before we write the C implementation of this algorithm let us look at the algorithm at a high level <sil=0.921> .PERIOD So <sil=0.630> ,COMMA we are given an array of size n and what we do is we run a loop for i from 1 to n minus 1 as we just saw and in each iteration of the loop we assume that a 0 to a i minus 1 are correctly sorted and a i is going to be inserted somewhere in its right place in the correct sorted order within this sequence <sil=0.916> .PERIOD So <sil=0.343> ,COMMA that the end at the end of this step the elements a 0 to a i are all correctly sorted <sil=0.962> .PERIOD So <sil=0.304> ,COMMA we need to first find where what is the correct position of a i in this sorted sequence and let us call that position as j that is a i should go at a j where j is less than or equal to i and we inferred a i at the location a j by shifting all elements which are to the right of a j by 1 position and then putting a i at the location a j this will become clear once we look at the details of the algorithm <sil=0.936> .PERIOD So <sil=0.545> ,COMMA there are two subsets here one is to do this searching of the correct position and the second step is to do this insertion <sil=0.961> .PERIOD So <sil=0.590> ,COMMA for the searching step we can use binary search because we already know that a 0 to a i minus 1 are already sorted but in the program that we will write I will not do that I will use a simpler linear search and I will leave it as an exercise for you to implement that using binary search which we have already seen <sil=0.971> .PERIOD So <sil=0.416> ,COMMA using linear search essentially what we will do is we will try to find the first j such that a of j is greater than a of i which means that a of j minus 1 was less than equal to a i but a j is greater than a i and therefore <sil=0.515> ,COMMA the correct position for a i in the sequence is at the position at the index j in the array <sil=0.915> .PERIOD And so <sil=0.440> ,COMMA a i would then be inserted in the next step next sub step at the index j note that it may turn out that j is equal to i <sil=0.941> .PERIOD Now <sil=0.529> ,COMMA j is equal to i will happen when a i is larger than all the elements a 0 to a a i minus 1 and that is it happens by chance that we sorted just the first i minus 1 element and the i s element was already in a right place <sil=0.993> .PERIOD So <sil=0.463> ,COMMA in that case of course <sil=0.507> ,COMMA nothing needs to be done but we must ensure that our algorithm works correctly even in this case <sil=0.983> .PERIOD So <sil=0.320> ,COMMA here is an example of the insertion step <sil=0.965> .PERIOD So <sil=0.513> ,COMMA let us assume that these sequences already sorted <sil=0.997> .PERIOD So <sil=0.582> ,COMMA i is 6 which means that the 6 element of the array has to be inserted at the right place and a 0 to a 5 are already sorted as you can see in this example <sil=0.909> .PERIOD Now <sil=0.377> ,COMMA j is 3 in this example because sin should really appear at this location <sil=0.946> .PERIOD Now <sil=0.508> ,COMMA the way the insertion will happen is let us move out this sin and store it in a temporary variable and then after that shift this element one step to the right again shift the next element one step to the right and shift the next element one step to the right <sil=0.991> .PERIOD So <sil=0.329> ,COMMA that now 10 can be safely stored here because the old value stored here has been shifted here the value stored here has been shifted here the value stored here has been shifted here and so 10 comes here <sil=0.923> .PERIOD So <sil=0.422> ,COMMA that is the insertion step now ready to look at the implementation of the algorithm <sil=0.901> .PERIOD So <sil=0.315> ,COMMA we have this function insertion sort which has no return value takes an array a and an integer n and sort the array a <sil=0.982> .PERIOD Note that this function is going to modify the values of elements of a but and it does not return the new value but that is all right because the array as you know is passed as the starting address of the array is really passed and when an element of that array is accessed or modified it is accessed using its address and so therefore <sil=0.386> ,COMMA the change is reflected in the array of the calling function <sil=0.990> .PERIOD So <sil=0.359> ,COMMA we have this local variables i <sil=0.386> ,COMMA g and t <sil=0.920> .PERIOD Now <sil=0.408> ,COMMA this is the outer loop which runs for i from 1 to n minus and for each value of i we have to first do the search search is quite easy <sil=0.939> .PERIOD So <sil=0.572> ,COMMA we start so essentially what we have to do is for j from 0 to i minus 1 we have to find the first value of j such that a j is greater than a of i because a of i is what we are trying to insert here <sil=0.996> .PERIOD So <sil=0.579> ,COMMA we start from 0 and we proceed towards a of i minus 1 and as soon as we find a j such that a j is greater than a i we break from the loop <sil=0.938> .PERIOD So <sil=0.504> ,COMMA when we come here either a j is greater than a i and that is why we broke from the loop or it is possible that j is equal to i if j is equal to i that means that a i is already in its correct position it is already larger than all of a 0 to a i minus 1 and nothing really needs to be done in this case <sil=0.995> .PERIOD So <sil=0.538> ,COMMA this is the insertion step note that this step happens even when i is equal to j but as we will see that it works exactly even when i is equal to j <sil=0.999> .PERIOD So <sil=0.343> ,COMMA we first move the value of a i to a temporary variable and then for all locations of the array starting from i minus 1 going back right up to j this should be k minus minus instead of plus plus we move the value of a k to the location a k plus 1 and so all the elements of the array starting from i minus 1 and going back up to j they get shifted one place right and then finally the location a j is given the value t which was the original value of a i <sil=0.924> .PERIOD Note that if i happens to be equal to j then all will happen is that t will be assigned a i and then this loop will not run at all because the initial value of k is i minus 1 j is equal to i <sil=0.979> .PERIOD So <sil=0.553> ,COMMA i minus 1 is not greater than equal to i <sil=0.962> .PERIOD So <sil=0.410> ,COMMA this condition will become false in the very first iteration and so therefore <sil=0.569> ,COMMA the loop body will not execute at all when j is equal to i and so therefore <sil=0.349> ,COMMA all that will happen will be these two assignments t assigned a i and a j assigned t <sil=0.977> .PERIOD Now <sil=0.378> ,COMMA since j is equal to i all that happens is that t assigned a i and again a i assigned t which has no effect really because the same value is assigned back into a i <sil=0.904> .PERIOD So <sil=0.569> ,COMMA that is as we want it to happen <sil=0.912> .PERIOD So <sil=0.445> ,COMMA when this outer loop terminates when it has run for all values of i from n 1 to n minus 1 the array is sorted and the function returns <sil=0.939> .PERIOD Let us now analyze this algorithm to find its time complexity <sil=0.996> .PERIOD The outer loop as we know runs for i from 1 to n minus 1 for different values of i all values of i from 1 to n minus 1 and let us look at one particular iteration of this outer loop <sil=0.981> .PERIOD So <sil=0.421> ,COMMA let us look at the iteration where for from particular value of i that is the i th iteration of the outer loop <sil=0.986> .PERIOD Now <sil=0.484> ,COMMA in the i th iteration of the outer loop this loop as well as this loop is will run at most i times because we may have to do this i times because the element which is greater than i may not be present at all in which case we need to look at all elements from a 0 to a i minus 1 and the worst case for this step happens when the value of j turns out to be 0 itself because then all elements from a 0 to a i minus 1 need to be shifted so a total of i element is shifted <sil=0.910> .PERIOD So <sil=0.481> ,COMMA and if you think carefully about this the number of times that this loop will execute plus number of times this loop will execute will actually always be equal to i <sil=0.995> .PERIOD So <sil=0.409> ,COMMA therefore <sil=0.511> ,COMMA the time taken in the i th iteration is in the worst case is c 1 times i plus c 2 that it is proportional to i plus a constant <sil=0.989> .PERIOD Note that if we had made the search step as a binary search step you will instead of using linear search if you had used a binary search over here then the amount of time taken in this step in the worst case would be log i and the amount of time taken in the worst case over here would be order i <sil=0.901> .PERIOD But if you add these 2 up that would still be order i <sil=0.937> .PERIOD So <sil=0.618> ,COMMA which means that the amount of time taken in the i th iteration would not really change in the order notation and therefore <sil=0.499> ,COMMA the overall time taken would also not really change in the order notation even though using binary searches of course slightly more efficient <sil=0.937> .PERIOD So <sil=0.521> ,COMMA for each iteration of the for i th iteration of the loop the time taken by the iteration is proportional to i or we have been noted as c 1 i plus c 2 and therefore <sil=0.383> ,COMMA the total time taken is c 1 times 1 plus c 2 for i equal to 1 plus c 1 times 2 plus c 2 for i equal to and so on up to i equal to n minus 1 and so if you add up all that c 1 will have a coefficient of 1 plus 2 plus up to n minus 1 and c 2 will have a coefficient of n minus 1 and c 3 time might be some constant 1 of time required in addition to the outer loop for example <sil=0.371> ,COMMA for initialization and overhead of the function call and so on so forth <sil=0.937> .PERIOD So <sil=0.512> ,COMMA now if you this is an arithmetic series and if you add this up it turns out to be n times n minus 1 by 2 which is a constant times n square plus lower order term and so this entire thing is constant times n square plus lower order terms and therefore <sil=0.410> ,COMMA in the big o notation this is order n square <sil=0.993> .PERIOD So <sil=0.633> ,COMMA this is the end of today's lecture in the next lecture we will talk about a new data type and see that we have not looked at so far which is the structure type <sil=0.940> .PERIOD The title of this course is in translation to computing and in this course we are going to study how to use computers effectively for solving a real life problem that will come across in a professional career <sil=0.991> .PERIOD As you know in today's work a computer is an invaluable tool to every engineer and scientist for solving problems related to his or her discipline <sil=0.968> .PERIOD For example <sil=0.317> ,COMMA if you are a civil engineer you need a computer to compute the stresses on the various structures of the building or if you are going to be an aerospace engineer then you might need to use a computer to compute the airflow around an earthouse and so it is important for all of us to understand how to use computers effectively to solve our problems and not just as users of computers we need to be able to sell the computers how to solve our problems <sil=0.940> .PERIOD So in this course we are going to basically see how to use computers to effectively solve engineering problems and as a first step we are going to try and understand what a computer is and at a very high level of what it is <sil=0.938> .PERIOD So what is a computer as the word suggests it is something that computes <sil=0.978> .PERIOD Well in that case how is it different from a simpler device that you are all familiar with namely a calculator a calculator calculates <sil=0.953> .PERIOD So are the words calculating compute any difference <sil=0.914> ?QUESTIONMARK Well let us try and consult a dictionary to find out <sil=0.985> .PERIOD Here is what calculate mean to determine something by mathematical process and here is what to compute mean to determine especially by mathematical mean <sil=0.941> .PERIOD So as you can see the meanings of the two words are quite similar and therefore one would expect a calculator to be similar to a computer <sil=0.942> .PERIOD So it is actually not the case a computer as we are going to see very soon is much more powerful and we can use it in much more flexible and interesting ways than we can use a calculator <sil=0.949> .PERIOD So allow us see what we can do using a calculator there is something that is similar to all of you <sil=0.927> .PERIOD Let me show you a calculator <sil=0.911> .PERIOD So here is what a standard calculator looks like <sil=0.953> .PERIOD As you can see it has buttons for various primitive arithmetic operation and we can use this operation to do some calculations with numbers for example 56 into 23 is 1288 <sil=0.992> .PERIOD However what we cannot use this calculator to do is to select how to combine these operations in a certain fashion so that a certain computation can be achieved <sil=0.923> .PERIOD For example how do I compute let us say the factorial of numbers using this calculator <sil=0.940> .PERIOD You might say all that is very easy if I have to calculate the factorial of 5 there is what I am going to do 5 times 4 times 3 times 2 and that 1 <sil=0.964> .PERIOD 20 is the factorial of 5 and that is correct but you cannot teach this calculator how to compute the factorial of any given number <sil=0.932> .PERIOD For any specific given number you can use this calculator to find the factorial by combining these operations in a certain way that you know but you cannot teach this calculator how to combine these operations in some way so that it can compute the factorial of any number automatically <sil=0.943> .PERIOD Well you might say if I want to do that I can use a scientific calculator which has a primitive operation for factorial but even with a scientific calculator the set of operations that you have is fixed and you still cannot select how to combine these operations automatically in a certain sequence so as to achieve a certain computation <sil=0.932> .PERIOD For example your scientific calculator might have a button for factorial but can you for example teach it to compute let us say the area of the intersection of two given circles when you find and that is the important distance between the calculator and the computer really computers you can actually select how to how to combine the various primitive operations that are available in a certain fashion so as to achieve the desired computation of the desired problem <sil=0.933> .PERIOD Okay so let us look at some terminology now which relates to the concepts that we have been talking about <sil=0.944> .PERIOD This is something the computer about how to a second task is what is called a programming and should you comment on this one before <sil=0.923> .PERIOD A program is nothing but the set of instructions that you are given to the computer to query out the certain task and the third term is programmability which is the ability of the computer to accept a set of instructions from you and to say fully carry them out and this programmability is what primarily distinguishes a computer formic calculator because a computer is programmable that is we can give it a set of instructions to solve the problem of our choice whereas we cannot to run the calculator or we cannot instruct it how to carry out a certain task <sil=0.905> .PERIOD Of course there are other important differences between computer and calculator which are also significant for example a calculator can only deal with numbers whereas a computer can deal with data in variety of forms as some of you might be aware for example it can it can handle text <sil=0.419> ,COMMA it can handle images <sil=0.435> ,COMMA it can handle sounds and it can take its input from a variety of interesting input devices and so on but the fundamental difference again is that a computer is programmable while a calculator is not <sil=0.954> .PERIOD Addiffer the program is the sequence of instructions that is applied to the computer in order to solve our problem at hand there is a related term called an algorithm which is similar to the program but different in certain details <sil=0.985> .PERIOD So an algorithm is also a sequence of sets to solve the problem but it is usually written in a natural language such as English and written precisely enough whereas to be unambiglously understood by a human a program on the other hand is essentially an algorithm translated to what is known as a programming language that a computer can understand and execute <sil=0.948> .PERIOD So that's a fundamental difference between only a algorithm and a program you might think of an algorithm as a solution to a problem whereas a program is the translation of that solution from English to a programming language that a computer can understand <sil=0.941> .PERIOD In this course we are going to talk both about how to develop algorithm for solving some simple problems which you will find useful as building blocks for solving more complex problems and at the same time we are also going to see how to express visual algorithms in a programming language and actually execute these programs on a computer <sil=0.978> .PERIOD So let's not take an example <sil=0.901> .PERIOD Let us say we stick to our old example of computing factorial and we want to write an algorithm to compute the factorial of a given number n <sil=0.943> .PERIOD Note that here n could be any number and we don't know a prime what this number n is <sil=0.933> .PERIOD So our sequence steps namely our algorithm to find the factorial of n should be such that it can handle any given n and not just a certificate <sil=0.928> .PERIOD So what do we go about finding such an algorithm <sil=0.868> ?QUESTIONMARK Well we all know how to compute factorial <sil=0.928> .PERIOD So as you know the factorial of n is nothing but n times n minus 1 times n minus 2 times n1 <sil=0.922> .PERIOD But how do I express this as an algorithm <sil=0.922> ?QUESTIONMARK Note that multiplication is fundamentally a binary operation and we can really only multiply two numbers at a time <sil=0.970> .PERIOD So how do we go about converting this knowledge of our definition of a factorial into an algorithm for a factorial <sil=0.942> ?QUESTIONMARK Well let us just think a little as you can imagine what we can do if you want to multiply numbers two at a time we can start with one let's call it for the time being as a result and our n is whatever it is and in each step let us say we multiply result by the value of n that is the first step we multiply result by the value of n and that is you was n <sil=0.932> .PERIOD So let us take an example let us say n happens to be 5 so we start with result as 1 <sil=0.946> .PERIOD In the first step we multiply the value of result by the value of n which gives us 5 and that's the new value of result and in the next step we have to multiply this result by 4 not 5 <sil=0.934> .PERIOD So therefore we decrease the value of n by 1 and make it 4 and in the next step we do the same thing multiply result by the new value of n and that gives us 20 decrease the value of n by 3 and we keep doing this so in the next step 20 becomes 60 and becomes 2 and in the next step 160 becomes 120 and and becomes 1 and how long do we keep doing this as long as and is greater than 1 <sil=0.976> .PERIOD So once you have done this we have essentially arrived at an algorithm to compute the factorial all we need to do is to now express our heart more precisely <sil=0.993> .PERIOD So here is the expression of our heart in the form of an algorithm so here is the algorithm to compute the factorial of n <sil=0.950> .PERIOD The first step is to read the value of n and in the second step as we did earlier while you are struggling set the result initially to 1 and as long as n is greater than 1 keep doing these two steps and these two steps as we have seen are multiplying the value of result by the value of n and decreasing the value of n by 1 <sil=0.914> .PERIOD So set the new value of result to the old value of result times the value of n and the second step is set the new value of n to old value of n minus 1 and keep doing this as you can see here still as long as n is greater than 1 and once you have the value of result contains the answer to our problem namely the value of n factorial and we can output the value of result <sil=0.930> .PERIOD In this algorithm I know that we are not really bothered too much about red wire it is the value of n from or red wire trained the value of the result or how do I trained the value of the result that is not something that was in the straight law it is the step 2 3 3 <sil=0.946> .PERIOD 1 and 3 <sil=0.978> .PERIOD 2 which are really important at this stage <sil=0.947> .PERIOD Okay and let us note some more things about this algorithm note that our instructions for computing the factorial of n is not just a straight line sequence of instructions to be executed by the computer 1 by 1 but there are things which have to be repeatedly done the steps 3 <sil=0.968> .PERIOD 1 and 3 <sil=0.949> .PERIOD 2 have to be repeatedly performed as long as a certain condition holds this is called a loop in the technical jargon the second thing that we should note is that we have to value we have to remember the result of intermediate computations and the intermediate computations as you can see in this particular simple example are two namely the value of result and the value of n <sil=0.971> .PERIOD So these things these values that we have to remember these are called as variable so in this example there are two variables in this algorithm result and n and show the motion of variables is similar to you from your high school algebra where you have equations like x plus y is equal to x square plus y square something like this but at mathematical motion of variables is very different from the programming motion of variables in mathematics variables such as x and y denote unknown but fixed values whereas in an algorithm variables denote values that may change over time okay <sil=0.949> .PERIOD So as you can see the values of result and n change over time as we go through this algorithm and execute itself by step and that's what the programming motion of variable is okay <sil=0.908> .PERIOD So let's now see this algorithm in action so here is the same algorithm and let's see step by step how it's going to execute and compute the desired result here's the first step read the value of n let's take an example the same example as matrices as before and let's assume that the value of n that is given to us is 5 <sil=0.908> .PERIOD So this blue arrow indicates where in the execution we are currently right so after having executed line number one we now have to execute line number two and the result of executing the line number one was that the value of n has become 5 okay <sil=0.998> .PERIOD So the second step is set the value of result to 1 and what do you think this will do as you can imagine this will do nothing but set the value of result to 1 here it is <sil=0.975> .PERIOD Now here is something the sequence of steps you need to be repeated as long as a condition holds so while n is greater than 1 do these sequence of steps well as so this this particular line in the algorithm is essentially just going to check whether or not n is greater than 1 <sil=0.900> .PERIOD The current value of n is higher which is certainly is greater than 1 and therefore the answer to this condition or the result of this condition is true and therefore we are supposed to do the step 3 <sil=0.977> .PERIOD 1 and 3 <sil=0.955> .PERIOD 2 and because the condition evaluated to prove we have come to the step 3 <sil=0.908> .PERIOD 1 which says set the new value of result to the old value result thanks to value of n and so the new value of result will be result times n which is 5 times 1 which is 5 and that caught this line in the algorithm does <sil=0.969> .PERIOD So the result becomes 5 <sil=0.976> .PERIOD Note that in this step n has not changed <sil=0.991> .PERIOD In the next step we are going to set the value new value of n to old value of n minus 1 which is 5 minus 1 namely 4 <sil=0.906> .PERIOD So we do that and note that once we have finished everything 3 <sil=0.931> .PERIOD 1 and 3 <sil=0.948> .PERIOD 2 we must come back to line number 3 and check this condition again why because remember that the step 3 <sil=0.939> .PERIOD 1 and 3 <sil=0.930> .PERIOD 2 have to be repeated as long as this condition holds and this condition will not as you can imagine continue to hold forever because in every step we are decreasing the value of n by 1 and therefore after some time certainly after the finite number of steps the value of n will become less than equal to 1 at which time we will stop repeating the steps 3 <sil=0.930> .PERIOD 1 and 3 <sil=0.955> .PERIOD 2 but at this point in time the value of n is still greater than 1 so we repeat the same step becomes here the value of result now becomes 20 5 times 4 and now the value of n becomes 3 so you go back and is still more than 1 and therefore we repeat the steps again so result now becomes 60 and n now becomes 2 which is still greater than 1 so we do this once more result now becomes 20 the value of n becomes 1 now when we test whether n is greater than 1 or not we conclude that n is not greater than 1 because we need n is equal to 1 and therefore this condition is no longer identified now and therefore the step 3 <sil=0.991> .PERIOD 1 and 3 <sil=0.981> .PERIOD 2 will not be executed now will later become 2 step 4 which is to pin the value of the result and once you do that the output is the value of the result which of course is 120 and which of course as you know is factorial of n <sil=0.912> .PERIOD And we could have all the same problem in other ways as well for example instead of multiplying 1 by n and then by n minus 1 and then by n minus 2 we could have started this process from the reverse direction that is multiply 1 by 2 and then by 3 and then by 4 and so on you could express that algorithm in a fashion similar to what we have done here and I will leave that as an exercise view and at the end of the lecture there is one more exercise for you to try yourself I wanted to write in the algorithm to compute the quotient and the remainder when if you want integer x which is more than or equal to 0 is divided by another given is a y which is known to be greater than 0 <sil=0.911> .PERIOD So for example if let the 15 is divided by 7 then the quotient should be 2 and the remainder should be 1 but as you that only addition and subtraction are the arithmetic operations available to you <sil=0.997> .PERIOD So please write a algorithm for doing that just to increase the concepts that we have learned today <sil=0.904> .PERIOD So before we end this lecture today let me summarize what we have seen so far we have seen the notions of programming a program and programmability and this notion of programming and programmability is essentially as we have seen what we have to computer it's power because we can write programs to solve our problems and tell the computer to go z programs to find the results that we need and before actually writing programs in programming languages that computers can understand we have seen what the notion of an algorithm is which is independent of any programming language and we saw simply we got them to solve the simple problem namely to find the factorial of given number n and we saw roughly how the computer would go about executing the algorithm <sil=0.984> .PERIOD you you you you <sil=0.985> .PERIOD In the last lecture we had talked about structures and also towards the end of the lecture we saw how we can write programs that read data from files and write data to files <sil=0.970> .PERIOD Today we are going to talk about them <sil=0.602> ,COMMA they are very important tool in programming and constructing interesting data structures for holding various kinds of data and that is dynamic memory allocation and link list <sil=0.957> .PERIOD So <sil=0.583> ,COMMA to motivate the use of dynamic memory allocation let us see what the problems in using arrays for storing large volumes of data are <sil=0.918> .PERIOD Arrows let us store large numbers of data items <sil=0.602> ,COMMA but as you know we have to pre-specify maximum limit <sil=0.432> ,COMMA this maximum limit has to be declared at compile time and we cannot change it at runtime <sil=0.987> .PERIOD And if we have more data items at runtime as input then be a specified limit then we cannot really handle that and we specify a very large limit and the problem is that we might end up wasting a lot of memory <sil=0.956> .PERIOD So <sil=0.603> ,COMMA dynamic memory allocation as the name suggests allows us to ask the system for more memory as in when required <sil=0.957> .PERIOD So <sil=0.422> ,COMMA we can essentially not allocate all memory at compile time itself instead depending on the inputs as in when more data items are needed to be stored we can ask for more memory <sil=0.923> .PERIOD For example <sil=0.392> ,COMMA suppose we are reading a large set of data values we can allocate memory for one item as in when we read a data item we do not even need to know in advance how many data items are going to be there <sil=0.949> .PERIOD But the problem with dynamic memory allocation is that we need to keep track of all these chunks of memory that we get dynamically allocated <sil=0.929> .PERIOD Now <sil=0.607> ,COMMA in the case of an array all the elements of the array are at contiguous memory locations <sil=0.985> .PERIOD So <sil=0.469> ,COMMA if you know the address of the first element of the array then it is easy to find the address of any array element as we know using quantum arithmetic or using the indexing mechanism for arrays <sil=0.976> .PERIOD But when we dynamically allocate large number of chunks of memory one after the other they are not guaranteed to be contiguous in memory and therefore <sil=0.422> ,COMMA we have to somehow keep track of where these chunks of memory are in memory <sil=0.992> .PERIOD And the solution to this particular problem is to use structures and pointers in combination and the basic idea is very simple <sil=0.995> .PERIOD That is why we have integers as data items which we need to store and we are using dynamic memory allocation to store them and allocate enough memory to hold an integer as and when we read an integer <sil=0.920> .PERIOD So <sil=0.517> ,COMMA what we do is that each data item is stored in a structure which besides containing the integer or whatever the type of our data item is it will also contain a pointer to the structure containing the next data item <sil=0.910> .PERIOD And so every structure will contain a pointer to the next structure containing the next data item and that one will contain a pointer to the third structure and so on so forth <sil=0.936> .PERIOD And as you can see this creates a linked list of data items let us say it better through a pictorial representation <sil=0.997> .PERIOD So <sil=0.341> ,COMMA in this example again we are assuming that it is integer values that we are interested in storing <sil=0.925> .PERIOD So <sil=0.419> ,COMMA we have declared a structure type struct item which consists of an integer value and a pointer to another struct item <sil=0.985> .PERIOD So <sil=0.328> ,COMMA note that in terms of struct item I cannot have an abstract item because then the size of this would have to be infinite <sil=0.960> .PERIOD But I can always store a pointer to a similar kind of structure within a structure itself <sil=0.943> .PERIOD These kind of structures are called recursive structures and that is possible because the size of a pointer is independent of the size of the quantity to which it points <sil=0.991> .PERIOD So <sil=0.626> ,COMMA the compiler knows at compile time that an integer will take so many bytes and storing a pointer will require so many bytes and therefore <sil=0.505> ,COMMA overall the structure will require so many bytes <sil=0.967> .PERIOD And so we have the structure which consists of an integer value that we need to store and a pointer to the next structure and let us say we have a variable p which is a pointer to an item <sil=0.978> .PERIOD Now <sil=0.382> ,COMMA consider this kind of a linked list <sil=0.911> .PERIOD So <sil=0.585> ,COMMA the variable p contains the pointer to the first element in the list <sil=0.958> .PERIOD Each of these is an element and each of these is of type struct item <sil=0.909> .PERIOD So <sil=0.524> ,COMMA p contains a pointer to the first element and the next field of the first element contains a pointer to the second element which has a value and a pointer to the next element which again contains three and the pointer value in the next element is a null pointer which we have already talked about earlier in the in some earlier lecture <sil=0.933> .PERIOD This is a special pointer value which is not the address of any legal memory location <sil=0.944> .PERIOD So <sil=0.320> ,COMMA we can use this to mark the end of the list <sil=0.547> ,COMMA but we have to be careful that we never de-reference the null pointer that is we never perform a star operation or an arrow operation on a pointer which is null <sil=0.976> .PERIOD So <sil=0.452> ,COMMA if we have this kind of a list then we need to store only in a variable we need to only store the starting address of the list or the pointer to the first element of the list because the other elements can be tracked using the chain of pointers <sil=0.904> .PERIOD So <sil=0.491> ,COMMA p is a pointer to the first element <sil=0.938> .PERIOD So <sil=0.327> ,COMMA p arrow next will be a pointer to the second element <sil=0.943> .PERIOD Similarly <sil=0.530> ,COMMA p arrow next arrow next will be a pointer to the third element and so on so forth <sil=0.988> .PERIOD Similarly <sil=0.447> ,COMMA p arrow value is the data value of the first element <sil=0.968> .PERIOD p arrow next arrow value is the data value the second element <sil=0.966> .PERIOD p arrow next arrow next arrow value is the data value of the third element in the list which is three in this particular case <sil=0.966> .PERIOD Now <sil=0.621> ,COMMA before we see how we can actually create a list let us see an example where we actually go through this list and compute some quantity or look for something or something of that kind <sil=0.938> .PERIOD So <sil=0.302> ,COMMA as an example let us assume we have such a list and we want to write a function which computes the average of the numbers in this list and of course it assumes that the number of elements is at least one <sil=0.996> .PERIOD So <sil=0.381> ,COMMA this is the function prototype <sil=0.935> .PERIOD We are going to return a float which is the average <sil=0.913> .PERIOD The argument is a p which is a type struct item star <sil=0.944> .PERIOD So <sil=0.642> ,COMMA the argument is supposed to be a pointer to the first element of the list for which we want to compute the average <sil=0.952> .PERIOD So <sil=0.556> ,COMMA we have two local variables <sil=0.924> .PERIOD Some will represent the some of the data values in the list and count will represent the number of elements in the list <sil=0.933> .PERIOD Now <sil=0.400> ,COMMA this list essentially traverses the list as long as p is not null we in every step we make p point to the next element in the list and the element that it was pointing to we add that data value to some and increment count by one <sil=0.955> .PERIOD So <sil=0.368> ,COMMA as long as p is not null some p value is added to some <sil=0.391> ,COMMA count is incremented by one and then p is made to point to the next element of the list <sil=0.924> .PERIOD And finally <sil=0.402> ,COMMA p will become null because the last element of the list will have the next value null <sil=0.961> .PERIOD At that time the slope will terminate and then some will be the sum of all the elements in the list count will be the number of elements in the list and therefore <sil=0.485> ,COMMA some divide by count will be the average <sil=0.904> .PERIOD So <sil=0.325> ,COMMA let us see with an example how this executes <sil=0.956> .PERIOD So <sil=0.306> ,COMMA in this example in the main function we have somehow created the list which we have not seen so far will look at that shortly and let us assume that p points to the first element of the list <sil=0.991> .PERIOD Let us again assume that this is what the list looks like <sil=0.964> .PERIOD So <sil=0.473> ,COMMA this variable p is the variable p in main <sil=0.972> .PERIOD Now <sil=0.340> ,COMMA when the function average is called as you know space is going to be created for the parameter p of average and the variables sum and count which are local variables of average and the parameter p will be initialized with the value of the argument which is this p and therefore <sil=0.327> ,COMMA that will be a pointer to the first element of the list as well <sil=0.923> .PERIOD So <sil=0.622> ,COMMA so <sil=0.596> ,COMMA p is created is initialized to the value of this p which is a pointer to the first element <sil=0.901> .PERIOD So <sil=0.583> ,COMMA this p also gets a pointer to the first element in the list <sil=0.981> .PERIOD Now <sil=0.560> ,COMMA let us go through the loop p is not null and so therefore <sil=0.597> ,COMMA this loop will execute loop body will execute some will become <sil=0.912> .PERIOD So <sil=0.410> ,COMMA initially first of course <sil=0.639> ,COMMA we sum in count initialized to 0 <sil=0.956> .PERIOD Now <sil=0.501> ,COMMA the first time around the loop executes some will become 5 count will become 1 and p will become p arrow next <sil=0.947> .PERIOD Now <sil=0.647> ,COMMA p is currently point in this element and p arrow next is this value which is nothing but a pointer to the second element <sil=0.978> .PERIOD So <sil=0.509> ,COMMA when this statement executes p will now be pointing to the second element of the list that is what happens <sil=0.904> .PERIOD Some becomes 5 count becomes 1 again p is not null <sil=0.903> .PERIOD So <sil=0.603> ,COMMA the next time around some becomes 12 count becomes 2 and p now points to the third element of the list again p is not null <sil=0.933> .PERIOD So <sil=0.481> ,COMMA some becomes 15 count becomes 3 and now it becomes null because p was this and p arrow next was null <sil=0.981> .PERIOD So <sil=0.518> ,COMMA now p has become null and so the loop terminates and some divided by count is of course <sil=0.516> ,COMMA 5 will be returned <sil=0.914> .PERIOD Let us see now how a list can be created <sil=0.980> .PERIOD So <sil=0.621> ,COMMA essentially in this example of seeing how we can create a list <sil=0.432> ,COMMA whenever we read a data item we are going to allocate a memory chance large enough to hold a struct item and store the data item in that field <sil=0.944> .PERIOD Now <sil=0.636> ,COMMA for allocating memory of a given size we are going to use the library called mLoc which is the library called used for dynamic memory allocation <sil=0.904> .PERIOD So <sil=0.358> ,COMMA once we have allocated the memory for a struct item dynamically then we initialize the data value in that to the value that we just read as input and the lists that we already have we insert this new item in the existing list <sil=0.950> .PERIOD So <sil=0.456> ,COMMA in the first example that we are going to see what we are going to do is that the new data item that we read will be inserted in the beginning of the list that is already there <sil=0.918> .PERIOD So <sil=0.538> ,COMMA let us see the code to do that <sil=0.967> .PERIOD Well <sil=0.393> ,COMMA for using the MLLAB function you need to include the file at the delib <sil=0.900> .PERIOD h <sil=0.971> .PERIOD So <sil=0.589> ,COMMA that has to be included in all programs that use mLoc <sil=0.950> .PERIOD Now <sil=0.422> ,COMMA for the function create list which will create a list of read a number of data items from the input and create a linked list of those data items and what it returns is a struct item star which means that it return the pointer to the first element of this list which is going to get created <sil=0.998> .PERIOD Now <sil=0.541> ,COMMA these are the local variables <sil=0.942> .PERIOD List is a local variable which is again of type struct item star <sil=0.961> .PERIOD So <sil=0.470> ,COMMA and it is initialize to null and that is because currently the list is empty and so therefore <sil=0.582> ,COMMA we have made the pointer list point to null and P will point to the structure that we get we dynamically allocate every time and value is the value that we read <sil=0.911> .PERIOD Now <sil=0.399> ,COMMA as long as reading an integer results in success <sil=0.551> ,COMMA scan if it returns one <sil=0.475> ,COMMA what we do is we allocate a chunk of memory using MLLAB <sil=0.960> .PERIOD The argument to MLLAB is the size invite that we want to of the memory chunk that we want to allocate <sil=0.964> .PERIOD Now <sil=0.479> ,COMMA recall that the size of any type can be obtained using the size of operator in C <sil=0.926> .PERIOD The size of struct item gives us the number of size in number of bytes of the type struct item <sil=0.929> .PERIOD So <sil=0.477> ,COMMA that is the number of bytes that we done weekly want to allocate <sil=0.996> .PERIOD So <sil=0.631> ,COMMA we specify that in P as the argument to MLLAB <sil=0.961> .PERIOD What MLLAB returns is a pointer to this dynamically allocated structure <sil=0.942> .PERIOD But if for some reason <sil=0.631> ,COMMA memory allocation fails for example <sil=0.643> ,COMMA if we have allocated so much memory dynamically that the system has run out of memory <sil=0.608> ,COMMA then MLLAB returns null <sil=0.986> .PERIOD So <sil=0.360> ,COMMA it is important that whenever we use MLLAB <sil=0.373> ,COMMA we check that the return value is not null because if you are careless and we use up too much memory <sil=0.423> ,COMMA then MLLAB might return null <sil=0.970> .PERIOD So <sil=0.380> ,COMMA if C is null <sil=0.597> ,COMMA we print some error message and exit <sil=0.976> .PERIOD So <sil=0.648> ,COMMA assuming P is not null <sil=0.416> ,COMMA we set P value of P to the value that we write here <sil=0.900> .PERIOD And these two are inserting this new element in the list <sil=0.978> .PERIOD Let us see how exactly that is happening <sil=0.960> .PERIOD And finally <sil=0.438> ,COMMA when the slope terminates that is when we could not read any more integer values <sil=0.601> ,COMMA then we return list <sil=0.922> .PERIOD Now <sil=0.614> ,COMMA let us see how exactly all this is really happening <sil=0.958> .PERIOD So <sil=0.344> ,COMMA we have this variables list and P list is initialized to null <sil=0.394> ,COMMA P is not initialized <sil=0.944> .PERIOD Let us say the first data value that we read is 1 <sil=0.904> .PERIOD So <sil=0.522> ,COMMA this allocates a new structure for this and stores the pointer to this structure in P <sil=0.920> .PERIOD So <sil=0.634> ,COMMA this is what happens and then we store the value that we read in the value field of this structure <sil=0.954> .PERIOD Now <sil=0.435> ,COMMA P arrow next is list <sil=0.983> .PERIOD Now <sil=0.467> ,COMMA the value of list right now is null <sil=0.938> .PERIOD So <sil=0.543> ,COMMA P arrow next will also become null <sil=0.903> .PERIOD So <sil=0.515> ,COMMA that means this value <sil=0.551> ,COMMA the next field of this structure becomes null <sil=0.918> .PERIOD And the next statement is list assigned P <sil=0.353> ,COMMA which means that list is no longer null <sil=0.580> ,COMMA list is now pointing to this element <sil=0.958> .PERIOD Now <sil=0.312> ,COMMA let us assume that we read one more integer value and let us say we happen to read the value 3 <sil=0.917> .PERIOD So <sil=0.461> ,COMMA again P is assigned M log a structure of a size struct item <sil=0.924> .PERIOD So <sil=0.375> ,COMMA again another structure of the same size is allocated somewhere in the memory and now P is pointing to this and P arrow value is initialized to 3 <sil=0.944> .PERIOD P arrow next this sign is list <sil=0.968> .PERIOD So <sil=0.509> ,COMMA what is being done is that this next field of this new element is being made to point to the first element of the existing list <sil=0.975> .PERIOD So <sil=0.334> ,COMMA now this 3 becomes the first element of the list and therefore <sil=0.347> ,COMMA the value of list is changed to point to this new first element and so on <sil=0.928> .PERIOD So <sil=0.314> ,COMMA when the next value is read another structure will be created and let us say 5 is read and the next field will be made to point to the first element of the currently existing list and the list pointer will be updated to point to this first element <sil=0.991> .PERIOD So <sil=0.434> ,COMMA that this will become the first element <sil=0.965> .PERIOD So <sil=0.398> ,COMMA if you at the end of this if you write 1 <sil=0.447> ,COMMA 3 <sil=0.534> ,COMMA 5 the list will look like this <sil=0.948> .PERIOD Please go through this example once again to make sure that you understand exactly what is happening here and finally <sil=0.474> ,COMMA the value of list is returned <sil=0.977> .PERIOD Now <sil=0.630> ,COMMA so in this code what was happening is that the list the order of elements in the list is reversed of the order of elements in of the order in which the element the values were read <sil=0.968> .PERIOD Now <sil=0.500> ,COMMA suppose you want to create the list in which the elements are in the same order as the order in which they were read <sil=0.922> .PERIOD Now <sil=0.380> ,COMMA what we have to do for achieving that what we will have to make sure is that if we have an existing list of let us say 3 items 1 <sil=0.389> ,COMMA 3 <sil=0.540> ,COMMA 5 this is null and we want to insert 7 <sil=0.961> .PERIOD So <sil=0.567> ,COMMA this is a pointer to the first element in the list let us call it the head of the list and now when we let us say read 7 now this element must be inserted at the end of the list <sil=0.945> .PERIOD So <sil=0.346> ,COMMA that means this pointer value must be updated to point to this and this pointer value must be made null <sil=0.979> .PERIOD So <sil=0.571> ,COMMA therefore <sil=0.442> ,COMMA if you want to update this field of this structure we must somehow optimal a pointer to this structure <sil=0.985> .PERIOD Now <sil=0.418> ,COMMA one way to do that could be to traverse this list once again and reach the last element and then set the next field of that element to the newly allocated structure <sil=0.620> ,COMMA but obviously that is going to be expensive <sil=0.962> .PERIOD What is better is that we maintain a pointer to the last element of the list and when we insert one more element since we already have the tail pointer all we have to do is set the next field in the structure pointed to by the tail pointer to the newly allocated structure and update to point to this structure and that is what is going to happen in the first step that we are just going to see <sil=0.450> ,COMMA but we have to be careful because if initially the list is empty so both head and tail are going to be null <sil=0.940> .PERIOD So <sil=0.476> ,COMMA if we try to set tail arrow next to P of where P is the pointer to the newly allocated element then if the value of tail is null then we are de-affirming a null pointer which will result in unpredictable behavior which will probably cause the program to crash and so this must not be done and therefore we need to specially consider the case when inserting the first item in the list <sil=0.977> .PERIOD So <sil=0.381> ,COMMA let us look at the code <sil=0.953> .PERIOD So <sil=0.365> ,COMMA we initialize head and tail to null and P will be the pointer to the newly allocated element value is as before <sil=0.978> .PERIOD So <sil=0.499> ,COMMA we read a value and we allocate a new structure for holding this value <sil=0.916> .PERIOD So <sil=0.445> ,COMMA if P is null we print another message and exit etcetera <sil=0.997> .PERIOD So <sil=0.536> ,COMMA this P points to the new value to the new structure that has been allocated <sil=0.951> .PERIOD The value field is set to whatever value we write let us say 10 <sil=0.423> ,COMMA next field is set to null and now there are two cases if tail is null that means that this is going to be the first element in the list and so head and tail are both set to P because this is the first as well as the last element of the list <sil=0.977> .PERIOD Now <sil=0.540> ,COMMA if tail is not null then tail is pointing to an existing last element of the list list has at least one element let us say this happen to be 5 <sil=0.939> .PERIOD So <sil=0.569> ,COMMA we set tool arrow next to P which means this tool arrow next was null initially <sil=0.940> .PERIOD So <sil=0.487> ,COMMA we make it now point to the newly allocated structure and tool is set to P <sil=0.955> .PERIOD So <sil=0.336> ,COMMA that now tail also points here because this element is now the last element in the list <sil=0.984> .PERIOD Now <sil=0.559> ,COMMA consider some other operations on a linked list that we might want to perform <sil=0.951> .PERIOD We might want to insert an element in the list and we might want to delete an element in the list <sil=0.953> .PERIOD Now <sil=0.359> ,COMMA when we delete an element from the list then we also need to free or deallocate the memory assigned to this particular element in the list because if we do not do that then what might happen is that we keep allocating more and more memory without deallocating any memory and ultimately we might run out of memory <sil=0.965> .PERIOD So <sil=0.416> ,COMMA it is a good practice to always free or deallocate memory as soon as it is no longer required and we will see how to do that <sil=0.934> .PERIOD Now <sil=0.594> ,COMMA when we want to insert or delete an element in the list you can see that the value of the next field in the previous element is going to change <sil=0.942> .PERIOD So <sil=0.399> ,COMMA for example <sil=0.353> ,COMMA if we have this list let us say 5 <sil=0.605> ,COMMA 3 this is and we want to delete this element from the list then what is going to happen is that this value must be changed to this value so that this structure is no longer part of the list <sil=0.952> .PERIOD So <sil=0.543> ,COMMA therefore <sil=0.513> ,COMMA if we want to modify this value we must have a pointer to this element of the list <sil=0.901> .PERIOD So <sil=0.627> ,COMMA that means we must have a pointer to the element before the one that has to be deleted and similarly when we want to insert an element in the list <sil=0.993> .PERIOD So <sil=0.516> ,COMMA let us say this is something like the following <sil=0.975> .PERIOD Now <sil=0.391> ,COMMA suppose we want to insert an element between these two elements let us say 6 <sil=0.942> .PERIOD So <sil=0.531> ,COMMA we allocate a new structure <sil=0.954> .PERIOD Now <sil=0.597> ,COMMA what will happen is that this value the value of next in the element before the position of the inserted element must be changed to point to this this must be changed to point to the next element in the list <sil=0.962> .PERIOD Now <sil=0.353> ,COMMA if we have a pointer to this then we can always obtain a pointer to the next element in the list <sil=0.988> .PERIOD So <sil=0.384> ,COMMA if we have a pointer to a particular element in the list we cannot obtain easily the pointer to the previous element in the list <sil=0.908> .PERIOD So <sil=0.464> ,COMMA therefore <sil=0.336> ,COMMA for both insertion and deletion what is easy to do is to assume that we are given a pointer to the element in the list just before the element which has to be deleted or just before just before the place where the element has to be inserted <sil=0.960> .PERIOD And the third operation that we will consider will be to free the entire list <sil=0.997> .PERIOD So <sil=0.632> ,COMMA if we are we are done with the entire list as a whole not delete or delocate all the elements of the list then we will have to go through the list and delocate each structure in the list each element in the list individually <sil=0.975> .PERIOD So <sil=0.364> ,COMMA we will look at code snippets to do all these three operations <sil=0.924> .PERIOD So <sil=0.438> ,COMMA let us take the first operation that is insertion of an element after a given element in the list <sil=0.943> .PERIOD So <sil=0.498> ,COMMA here is what the code might look like <sil=0.966> .PERIOD So <sil=0.534> ,COMMA let us assume that list is the pointer to the first element in the list and p is the pointer to the element after which the new element has to be inserted and v is the data value for the new element <sil=0.990> .PERIOD So <sil=0.598> ,COMMA that means <sil=0.497> ,COMMA that list is points to the first element in the list and p is a pointer to the element in the list after which this element has to be inserted <sil=0.958> .PERIOD Let us take an example maybe this is null and this list is pointer to the first element in the list and let us say we want to insert the new element here <sil=0.993> .PERIOD So <sil=0.511> ,COMMA p is a pointer to the element just before that <sil=0.910> .PERIOD So <sil=0.544> ,COMMA the impression is quite straightforward we have to of course <sil=0.592> ,COMMA allocate a new structure and we do that and store the pointer to that structure in the variable new set the value to v the value that needs to be inserted <sil=0.901> .PERIOD So <sil=0.395> ,COMMA let us just put the value v here <sil=0.970> .PERIOD Now <sil=0.511> ,COMMA let us assume that p is not null <sil=0.986> .PERIOD If p is null we will assume that what we want to do is to insert the new element as the first element in the list and that again will have to specially handle because we cannot dereference the pointer the null pointer <sil=0.997> .PERIOD Let us assume that the next p is not null <sil=0.920> .PERIOD So <sil=0.497> ,COMMA we execute this piece of code <sil=0.988> .PERIOD So <sil=0.424> ,COMMA what happens is that new arrow next is set p arrow next <sil=0.931> .PERIOD Now <sil=0.467> ,COMMA p is pointing to this structure and the value of p arrow next is pointer to this structure <sil=0.931> .PERIOD So <sil=0.555> ,COMMA new arrow next which is this box gets assigned a pointer to the element in the list after p and finally p arrow next is assigned new <sil=0.956> .PERIOD Now <sil=0.446> ,COMMA this structure p the next element that it should point to is a new structure <sil=0.936> .PERIOD So <sil=0.367> ,COMMA this is changed to point to new <sil=0.996> .PERIOD So <sil=0.517> ,COMMA essentially now the list looks like one followed by 3 followed by v followed by 5 followed by whatever else which might have been null <sil=0.976> .PERIOD Now <sil=0.443> ,COMMA the second case is when we want to insert the new element as the first element in the list and let us assume that in that case the value of p is specified as null <sil=0.921> .PERIOD So <sil=0.485> ,COMMA if p is null that means that we want to insert the new element as the very first element in the list <sil=0.996> .PERIOD So <sil=0.356> ,COMMA we assume that this is the existing list and we want to insert the value 1 let us say <sil=0.957> .PERIOD So <sil=0.597> ,COMMA in this case p is null <sil=0.961> .PERIOD So <sil=0.441> ,COMMA in this case possible to happen is that the value of the variable list itself needs to change because list remember back convention will always point to the first element and the new element will become the first element and the next field of the new element must point to what will become the second element and therefore <sil=0.575> ,COMMA what is the what is currently the first element of the list <sil=0.934> .PERIOD So <sil=0.374> ,COMMA new arrow next is a I am sorry new arrow next is assigned null <sil=0.998> .PERIOD So <sil=0.489> ,COMMA the value of new arrow next should be such to the current value of list <sil=0.903> .PERIOD In fact <sil=0.363> ,COMMA we will mistake here this should be list here and finally list is such to the 2 point to the new element to which new is a pointer <sil=0.907> .PERIOD So <sil=0.540> ,COMMA list is just assigned new <sil=0.923> .PERIOD So <sil=0.496> ,COMMA that inserts the element in the list after the element p <sil=0.981> .PERIOD Let us now look at deletion from a list and again we assume that list points to the first element in the list and p is a pointer to the element the one after which the element after the one pointed to by p has to be deleted <sil=0.929> .PERIOD So <sil=0.324> ,COMMA again taking an example <sil=0.926> .PERIOD If you want to delete this element then we will set p to this and if you want to delete the third element we will assume that p points to the second element <sil=0.971> .PERIOD So <sil=0.637> ,COMMA where assuming that p is pointing to the element the one after which has to be deleted <sil=0.961> .PERIOD Now <sil=0.311> ,COMMA again if p is null then we are assuming that the first item in the list should be deleted <sil=0.998> .PERIOD So <sil=0.606> ,COMMA because if p points the first element itself then the second element will get deleted <sil=0.908> .PERIOD So <sil=0.525> ,COMMA if p is null then what should be done is that list should point to the second element of the list to the second element of the existing list and the first element should be the first structure should be deallocated memory should be freed <sil=0.947> .PERIOD So <sil=0.365> ,COMMA now what we are doing is that we are using the variable q to point to the element which is being removed from the list so that we can free the memory being assigned to this element <sil=0.964> .PERIOD So <sil=0.576> ,COMMA q is such to list if p is null remember that if p is null let us say p is null <sil=0.918> .PERIOD So <sil=0.568> ,COMMA if p is null then the very first element of the list has to be deleted <sil=0.965> .PERIOD So <sil=0.518> ,COMMA q is made to point to the list <sil=0.902> .PERIOD So <sil=0.457> ,COMMA q will almost point to the element which is going to be deleted and list is assigned list arrow next <sil=0.928> .PERIOD So <sil=0.585> ,COMMA because the second element in the previous in the existing list not becomes the first element and list arrow next is a pointer to the second element <sil=0.957> .PERIOD So <sil=0.556> ,COMMA list is changed to point to the second element now this element is no longer in the list <sil=0.443> ,COMMA but we still have a pointer to this in the variable q <sil=0.906> .PERIOD Now <sil=0.429> ,COMMA if p is not null that means we do not want to delete the very first element in the list <sil=0.969> .PERIOD So <sil=0.518> ,COMMA let us assume as an example that we want to delete the second element in the list <sil=0.921> .PERIOD So <sil=0.519> ,COMMA in this case if we want to delete the second element in the list <sil=0.377> ,COMMA both list and p are pointing to the first element <sil=0.904> .PERIOD Now <sil=0.321> ,COMMA what should happen is essentially that this pointer should bypass this structure and point directly to the third element <sil=0.953> .PERIOD So <sil=0.529> ,COMMA first we set q to point to the element which is to be deleted and which will always be p arrow next because the element next to p has to be deleted <sil=0.910> .PERIOD So <sil=0.330> ,COMMA q is set to that and p arrow next is set to q arrow next <sil=0.905> .PERIOD So <sil=0.569> ,COMMA p arrow next is this box and the value of that will become q arrow next which is this pointer <sil=0.989> .PERIOD So <sil=0.395> ,COMMA essentially this pointer is removed and it points directly over here <sil=0.922> .PERIOD So <sil=0.574> ,COMMA this element has now been removed from the list <sil=0.569> ,COMMA but again we have a pointer to this element in the form of q <sil=0.921> .PERIOD And finally <sil=0.576> ,COMMA once we have removed the element from the list <sil=0.496> ,COMMA we must as I said free the memory allocated to the deleted item <sil=0.952> .PERIOD So <sil=0.335> ,COMMA to do that we use the library called free it does not return anything and the argument is simply a pointer to the chunk of memory which you want to delete <sil=0.993> .PERIOD You must be very careful that the pointer that you supply must point to a chunk of memory which was dynamically allocated using amelok <sil=0.943> .PERIOD You cannot for example <sil=0.365> ,COMMA if you specify the address of some variable in the in the memory in the program then this will have very unpredictable results <sil=0.921> .PERIOD And also once a chunk of memory has been freed now the pointer q to that chunk of memory must not be de-reference because it is now pointing to a chunk of memory which has been de-allocated <sil=0.924> .PERIOD So <sil=0.477> ,COMMA we will in the next example see the consequences of how that might erroneously happen and what might happen in that case <sil=0.950> .PERIOD So <sil=0.478> ,COMMA next what we are going to do is to try and free the entire list <sil=0.972> .PERIOD We are writing a function free list which works a pointer to the first element in the list and free the entire list that is essentially it is going to traverse the list and each element in the list is going to be freed <sil=0.933> .PERIOD So <sil=0.411> ,COMMA memory assigned to each element in the list is being de-allocated <sil=0.902> .PERIOD So <sil=0.449> ,COMMA this is our first attempt at writing this function and as this dementia there is something wrong with this <sil=0.928> .PERIOD So <sil=0.593> ,COMMA what we do is traverse the list again using the same kind of a while loop while p is not null we free p and then assigned p to point to the next element in the list <sil=0.916> .PERIOD Now <sil=0.382> ,COMMA what is wrong with this code is that p is being de-recent where after it has been freed <sil=0.980> .PERIOD So <sil=0.640> ,COMMA each unquest memory has been freed <sil=0.946> .PERIOD So <sil=0.378> ,COMMA it is no longer a phase and now if we try to do a sense of pointer pointing to this remember that p erronext is exactly the same as star p dot next <sil=0.905> .PERIOD So <sil=0.398> ,COMMA we are do a sensing p which is pointing to a piece of memory which has been de-allocated and that will lead to unpredictable results <sil=0.964> .PERIOD Let us see that more precisely through an example <sil=0.952> .PERIOD Let us assume that p is pointing to the first element in this list 5 <sil=0.404> ,COMMA 7 and 3 <sil=0.977> .PERIOD Now <sil=0.397> ,COMMA p is not null <sil=0.995> .PERIOD So <sil=0.354> ,COMMA the first time around the loop executes free p will essentially de-allocate this structure to which a pointer is being supplied as argument <sil=0.989> .PERIOD So <sil=0.438> ,COMMA this structure phases to exist in some sense <sil=0.933> .PERIOD Now <sil=0.490> ,COMMA you can see that p is pointing to a structure which no longer exists and such a pointer is called a dangling pointer and now when we try to find p erronext that will result in unpredictable behavior <sil=0.925> .PERIOD That is because the value of p is what is known as a dangling pointer <sil=0.987> .PERIOD It is not pointing to a valid region in the memory <sil=0.924> .PERIOD So <sil=0.366> ,COMMA this is the correct version <sil=0.973> .PERIOD What we have to make sure essentially is that we do not dereference a pointer once we have freed the memory pointed to by that pointer <sil=0.971> .PERIOD So <sil=0.626> ,COMMA what we are doing is that we do p assign p erronext before doing the free <sil=0.526> ,COMMA but if we do p assign p erronext then we have I will last the old value of p <sil=0.970> .PERIOD So <sil=0.437> ,COMMA what we do is to the old value of p in q and then use p q instead <sil=0.952> .PERIOD So <sil=0.582> ,COMMA that is exactly the same as before except that the dereferencing of a dangling pointer is not happening <sil=0.912> .PERIOD Let us see how it is going to execute <sil=0.929> .PERIOD So <sil=0.477> ,COMMA let us again assume that p points to be first element in this place and now p is not null <sil=0.941> .PERIOD So <sil=0.415> ,COMMA the loop body executes q is assigned p then p is assigned p erronext <sil=0.953> .PERIOD So <sil=0.309> ,COMMA p points to the second element now free q happens <sil=0.906> .PERIOD So <sil=0.385> ,COMMA the first element gets de allocated <sil=0.976> .PERIOD Now <sil=0.435> ,COMMA p is still not null <sil=0.956> .PERIOD So <sil=0.613> ,COMMA we go back to the loop condition p is still not null <sil=0.909> .PERIOD So <sil=0.305> ,COMMA the loop body will execute once more q is again assigned p <sil=0.917> .PERIOD So <sil=0.508> ,COMMA q now points to the second element p is assigned p erronext and then free q <sil=0.953> .PERIOD So <sil=0.459> ,COMMA the second element gets de allocated and then p is still not null <sil=0.906> .PERIOD So <sil=0.411> ,COMMA we will execute the loop one more time q is assigned p p is assigned p erronext <sil=0.966> .PERIOD P erronext in this case is null <sil=0.937> .PERIOD So <sil=0.448> ,COMMA p becomes null and free q results in this being last structure being de allocated and so the entire list has been free <sil=0.998> .PERIOD Now <sil=0.493> ,COMMA to summarize there are two common problems with dynamic memory allocation and you will find that unless you are careful you will easily make these mistakes and one has to be extra careful against these kind of mistakes <sil=0.984> .PERIOD The first kind of problem results when we do not free a dynamically allocated chunk of memory even when we are finished using this <sil=0.913> .PERIOD So <sil=0.364> ,COMMA first a chunk of memory is called garbage appropriately because it is still in the memory it is it is still not freed <sil=0.984> .PERIOD So <sil=0.439> ,COMMA it cannot be reused but it is not useful either <sil=0.939> .PERIOD So <sil=0.339> ,COMMA this leads to what are known as memory leaks <sil=0.919> .PERIOD Essentially <sil=0.650> ,COMMA what happens is that a program keeps an allocating memory but it does not free memory then ultimately it might run out of memory and that is like you know having the memory leaked away <sil=0.956> .PERIOD And the solution to this problem of course is to be careful and be allocate any memory chunk as soon as it uses over <sil=0.976> .PERIOD The second problem that is just is the problem of dangling pointer that is the pointer that points to a chunk of memory that has been dealocated and as we saw de-referencing dangling pointer causes unpredictable behavior and the only way to avoid this is to make sure that dangling pointer is never de-referenced and you must always be careful not to that <sil=0.993> .PERIOD So <sil=0.416> ,COMMA that is the end of produced lecture and as a matter of fact this was the last lecture in the course <sil=0.949> .PERIOD So <sil=0.586> ,COMMA that is the end of the course as well and I hope that you found the course both useful as well as interesting <sil=0.970> .PERIOD But before I take your leave I would like to remind you that programming is not something that you can learn by reading a book or by watching videos <sil=0.977> .PERIOD The only way you can learn to program is to actually write programs and not just on paper but also try out things actually on a computer you will certainly make mistakes and it shows mistakes that of course that one learns from <sil=0.957> .PERIOD So <sil=0.468> ,COMMA write lot of programs have fun doing it and thank you for watching this series <sil=0.985> .PERIOD Thank you <sil=0.973> .PERIOD In the last lecture we have talked about the notion of pointers and we saw that essentially a pointer is the address of a variable and we saw the two operator which are related to pointers that is the M percent operator which given the operand as a variable is the address of that variable and the star operator or the pointer dereferencing operator which given a pointer value as an operand gives the content of the variable or the location to which the pointer points <sil=0.984> .PERIOD So <sil=0.511> ,COMMA we will continue our discussion on pointers by exploring the relationship between arrays and pointers <sil=0.945> .PERIOD In C there is a very close relationship between arrays and pointers and as we will see in some cases arrays and pointers can be used interchangeably <sil=0.973> .PERIOD So <sil=0.492> ,COMMA to begin with consider the following two declarations in A 20 <sil=0.962> .PERIOD So <sil=0.411> ,COMMA we are declaring an array called A of 20 integers and then we are declaring a pointer variable P which is of type in star and the initial value of P is nothing but A <sil=0.933> .PERIOD Now <sil=0.408> ,COMMA in C the expression A itself where A is the name of an array is nothing but the address of the 0th element of the array and therefore <sil=0.610> ,COMMA the expression A and the expression M percent A 0 are completely equivalent which means that in this initialization P is being initialized to point to the 0th element of the array A <sil=0.902> .PERIOD So <sil=0.320> ,COMMA in terms of pictures that we saw last time which help us understand the pointer better <sil=0.972> .PERIOD So <sil=0.437> ,COMMA P is pointing to the 0th element of the array A <sil=0.927> .PERIOD So <sil=0.365> ,COMMA essentially what we are saying is that the expression A itself where A is the name of an array is the same or is equivalent to the address of the 0th element of the array <sil=0.976> .PERIOD Now <sil=0.492> ,COMMA recall that in C we said earlier that the different elements of an array are stored at contiguous or adjacent memory location <sil=0.986> .PERIOD So <sil=0.394> ,COMMA for example <sil=0.406> ,COMMA if the first element or the 0th element of the array A is at memory location 1000 and each element required 4 bytes then the first element would be at memory location 1000 4th the second element would be at 1000 8 and so on so forth <sil=0.996> .PERIOD So <sil=0.647> ,COMMA essentially <sil=0.532> ,COMMA viewed in that sense the expression A gives the starting address where the array A is stored in the memory <sil=0.986> .PERIOD And similarly <sil=0.407> ,COMMA you can see that since A and M percent A 0 are equivalent so are star A and A 0 <sil=0.975> .PERIOD This is because star of M percent X is always equivalent to X right because we are first taking the address of the variable X and then we are dereferencing that address <sil=0.939> .PERIOD So <sil=0.594> ,COMMA this is always true and so therefore <sil=0.516> ,COMMA star of M percent A 0 must be the same as A 0 and this is nothing but A <sil=0.922> .PERIOD So <sil=0.397> ,COMMA therefore <sil=0.454> ,COMMA what we get is that star A is same as A 0 <sil=0.976> .PERIOD Note that what this means is that though star A can appear on the left hand side of an expression of an assignment expression which will mean that the 0th element of the array A is being assigned some value <sil=0.952> .PERIOD The expression A itself cannot appear on the left hand side of an assignment because that would mean that the starting address of the array A is being changed which is not possible of course <sil=0.312> ,COMMA because as we saw last time the addresses of variables are fixed and they are assigned by the compiler we cannot change them <sil=0.495> ,COMMA but when an address is stored in another variable then the contents of that variable can be changed <sil=0.953> .PERIOD Now <sil=0.628> ,COMMA the next important thing to understand is that even a pointer can be used using the array notation that is derefencing using a pointer can be done even using the array notation provided that the pointer does point to an array <sil=0.991> .PERIOD So <sil=0.594> ,COMMA let us take a simple example <sil=0.947> .PERIOD So <sil=0.624> ,COMMA we have two declarations here again A is an array of five elements <sil=0.989> .PERIOD So <sil=0.340> ,COMMA that is how it is depicted and P is a pointer of type in star which means that this variable P will hold the hold a pointer to some integer <sil=0.903> .PERIOD Now <sil=0.352> ,COMMA the first assignment that is here is P assigned A <sil=0.942> .PERIOD So <sil=0.452> ,COMMA what happens when this assignment execute the address stored in the variable P is nothing but the address of the zero element of A <sil=0.953> .PERIOD Now <sil=0.479> ,COMMA when A 2 is assigned 3 now that is familiar to us what should happen is that the second element of array A will get the value 3 <sil=0.578> ,COMMA but now what is interesting is that we could use the variable P as if it is an array and that is because it is pointing to an array element <sil=0.993> .PERIOD So <sil=0.603> ,COMMA when P 3 is done that would be the same as as a matter of type A 3 assigned 5 because P and A are synonymous in the sense that the value of pay of value of the variable P is nothing but the starting address of the array A <sil=0.930> .PERIOD So <sil=0.480> ,COMMA when P 3 assigned 5 is executed the third element of the array A is assigned the value 5 <sil=0.966> .PERIOD This will become hopefully more clear using more examples that you will see as the lecture processes <sil=0.905> .PERIOD Now <sil=0.556> ,COMMA we can also pass arrays as arguments to functions and in fact we have been doing that in the case of some library functions <sil=0.950> .PERIOD For example <sil=0.396> ,COMMA we saw the string functions in the C standard C library for example <sil=0.596> ,COMMA functions to find the length of a string and so on <sil=0.902> .PERIOD So <sil=0.479> ,COMMA there when we pass a string as an argument as you know a string is nothing but an array of characters with the special property that it is terminated by an L character <sil=0.957> .PERIOD So <sil=0.585> ,COMMA what we are passing to the string length function is really an array <sil=0.984> .PERIOD So <sil=0.579> ,COMMA what we want to make explore is what happens when arrays are passed to functions and how do we define the functions and how do we call the functions and so on <sil=0.946> .PERIOD So <sil=0.462> ,COMMA let us take a very simple example <sil=0.924> .PERIOD Suppose <sil=0.529> ,COMMA we want to write a function to search for a given element in a given array <sil=0.989> .PERIOD So <sil=0.647> ,COMMA let us say we are given an array of integers and we are given the number of elements in number of elements in that integer and we are given a particular value and we want to search in the array for that value <sil=0.968> .PERIOD And if the array contains that value then we should return this function is supposed to return the index at which in the array that value is present and if that value is not present anywhere in the array then the function should return minus 1 <sil=0.926> .PERIOD So <sil=0.345> ,COMMA here is what the function would look like <sil=0.966> .PERIOD Note that n and e are integer parameters as usual <sil=0.903> .PERIOD So <sil=0.358> ,COMMA there is nothing special about them and is the actual number of elements in the array which is being passed and e is the value that we need to search for <sil=0.936> .PERIOD Now <sil=0.598> ,COMMA this is the array itself which is being passed <sil=0.994> .PERIOD So <sil=0.408> ,COMMA what is going to happen in c is that when an array is passed as an argument what is actually passed to the function is nothing but the starting address of the array <sil=0.971> .PERIOD So <sil=0.312> ,COMMA the argument a here actually denote nothing but the starting address of the array which is being passed as an argument <sil=0.947> .PERIOD So <sil=0.343> ,COMMA the function itself is quite simple <sil=0.956> .PERIOD So <sil=0.545> ,COMMA we have a for look and we examine all elements of the array a from 0 to n minus 1 and for a particular value of i a i happens to it happens to equal e then we immediately return i because at the array index i the array a contains the value e <sil=0.976> .PERIOD Note that the return statement would not just break out of the loop but would immediately cause the function to return <sil=0.919> .PERIOD So <sil=0.355> ,COMMA the next statement would not execute in that case <sil=0.992> .PERIOD So <sil=0.464> ,COMMA that means that if the array element that the value e was found there in the array then this loop will not finish as a matter of fact and this return statement will cause the function to return before the loop finishes <sil=0.956> .PERIOD And so <sil=0.643> ,COMMA if the loop does finish that implies that the array did not contain the value e at any place or at any index and therefore <sil=0.350> ,COMMA we should return the value minus 1 <sil=0.912> .PERIOD So <sil=0.594> ,COMMA important point to note is that the value of the parameter a in this function is nothing but the starting address of the array which is being passed as an argument <sil=0.999> .PERIOD The copy a copy of that array is not being passed and that also means that when we declare this array we do not need to specify the size of the array <sil=0.944> .PERIOD The reason is that when the memory is allocated for for this parameter a the amount of memory required is the amount of space needed to store just one pointer value or just one address <sil=0.906> .PERIOD And so therefore <sil=0.427> ,COMMA that does not depend on how many elements in the array that is being passed as an argument are there <sil=0.948> .PERIOD And because of this reason in fact we could have return this function slightly differently and instead of declaring a in this fashion we could have declared a in this fashion as well <sil=0.969> .PERIOD And even then the rest of the code of the function would not need to change because as we just saw even a pointer value can be used as an array <sil=0.945> .PERIOD So <sil=0.550> ,COMMA let us see now how this function could be called from some other function let us say the main function so that is not important it could be called from any function really <sil=0.997> .PERIOD So <sil=0.578> ,COMMA in this example we have two arrays a 1 and a 2 of size 100 and 200 respectively and some code initializes the values of the elements of the arrays a 1 and a 2 and also the values of the variables n 1 and n 2 <sil=0.912> .PERIOD So <sil=0.384> ,COMMA let us assume that a 1 has n 1 elements and a 2 has n 2 elements and we could use the same function search to search for some value in both of these arrays <sil=0.970> .PERIOD The fact that the sizes of these two arrays is different does not really matter because the actual size of the array or the actual number of elements in the array is being passed as an argument and when the array itself is passed then what is being passed really is only the starting address and that should be clear also from the rule about that we talked about earlier about how arguments are passed to function <sil=0.937> .PERIOD So <sil=0.578> ,COMMA the argument a 1 would be evaluated in that case and we just saw that an expression denoting just an array name evaluates to nothing but the starting address of the array <sil=0.956> .PERIOD So <sil=0.387> ,COMMA the expression a 1 evaluates to just the starting address of the array a 1 and that is passed as argument to the function search and similarly in this case the starting address of the array a 2 is passed as argument <sil=0.946> .PERIOD Let us consider now another example which modifies the array in which the function which is given an array as a parameter actually modifies some of the elements in that array <sil=0.945> .PERIOD So <sil=0.379> ,COMMA let us consider a very simple example again in which we are writing a function which is intended to double the value of every element of an array <sil=0.931> .PERIOD So <sil=0.448> ,COMMA here is what that function might look like double array is the name of the function there is no return value and so the return type is void the argument is an integer specifying how many elements are actually there in the array a which is being passed as the first argument and the code is very simple for all elements from 0 to n minus 1 of element of the array we just double the array element using this r equal to operator <sil=0.919> .PERIOD But the question is whether the change is visible in the calling function that the values of the array that we have changed here in this function in the various elements of the array is that change visible in the calling function recall that when we pass when we modify let us say an integer parameter within the function then if the actual argument happened to be a variable in the calling function then the modification to the parameter does not cause a modification in the variable which was passed as argument to it because as we know a copy of that variable of the value of that variable is made available to the parameter <sil=0.906> .PERIOD But in the case of arrays recall that it is the starting address of the array which is being passed as an argument and not a copy of the values of the element of the array <sil=0.932> .PERIOD So therefore <sil=0.419> ,COMMA when this change is being made to an array element what is actually happening is that the array element of the original array which was passed as argument that is being accessed by using its address and therefore <sil=0.396> ,COMMA the change would be visible even when the function returns to the calling function <sil=0.979> .PERIOD So <sil=0.447> ,COMMA let us try to clarify that situation with the help of this example where I have put the same function in the context of a calling function <sil=0.941> .PERIOD So <sil=0.558> ,COMMA let us assume that this function double array is being called from the function main which has an array a of five elements and an integer variable i and this loop initializes all array elements of a from index 0 to 4 to 1 and then it calls double array with a and five the number of elements in the array as the argument <sil=0.959> .PERIOD Now <sil=0.408> ,COMMA when this function call happens so this variable a is the variable a of the main function and which represent this array of five elements each of which has the value 1 and when this is passed as argument to this function double array <sil=0.971> .PERIOD So <sil=0.427> ,COMMA the parameter there is also called a but what this parameter will contain will not be this parameter a will not refer to an array itself but a pointer to the 0th element of the original array which was passed as argument <sil=0.952> .PERIOD So <sil=0.533> ,COMMA now when this function executes let us say the when this statement is executed for the value of i equal to 0 which means that a 0 star equal to 2 is executed <sil=0.966> .PERIOD Now <sil=0.593> ,COMMA what is a 0 really mean a 0 means the 0th element of the array to which the pointer a is pointing note that in the context of this function this a is not really an array but it is a pointer <sil=0.977> .PERIOD So <sil=0.303> ,COMMA a 0 would refer to the 0th element of the array to which the variable a is pointing and so when this is when this assignment is executed the 0th element of the original array a is modified to 2 and similarly in the next iteration of the loop this statement will be executed and a 1 will refer to the first element of the array to which the variable a is pointing which is this one and so this will become 2 <sil=0.986> .PERIOD And so finally <sil=0.577> ,COMMA when the function double array return this variable a will be destroyed and the control will go back to main but in the main function note that the value of the array element in a have actually changed <sil=0.966> .PERIOD So <sil=0.531> ,COMMA essentially what is happening is that when an array is passed as a parameter to a function it is the starting address of the array that gets passed and in the called function if some array element is modified then because this value is being modified using the address of the memory location containing this value the change is visible even when the function returns to the calling function <sil=0.924> .PERIOD Now <sil=0.455> ,COMMA this is different from when a normal integer variable is passed because when a simple integer variable is passed the parameter gets a copy of the value of the argument and if that parameter is changed within the body of the function and that change is not visible in the calling function <sil=0.976> .PERIOD Now <sil=0.463> ,COMMA let us now come to another related notion and that is the notion of pointer arithmetic <sil=0.951> .PERIOD You might be surprised to know that in C you can actually do some arithmetic with pointer <sil=0.972> .PERIOD The arithmetic which is allowed with pointers is very limited you can add or subtract integers to or from pointers that is you can add an integer to a pointer or you could subtract an integer from a pointer <sil=0.987> .PERIOD Now <sil=0.542> ,COMMA this makes sense only when the pointer actually points to some array element of some array <sil=0.970> .PERIOD So <sil=0.339> ,COMMA for example <sil=0.599> ,COMMA if p points to the I th element of some array a then p plus j where j is an integer points to the I plus j th element of the same array a and similarly p minus j points to the I minus j th element of the array a note that it is possible that p is not pointing to an array at all or maybe when p plus j is done the array actually does not have I plus j element or maybe if p minus j is done the value of I minus j happens to be negative which means again the array does not have an element at that particular location <sil=0.925> .PERIOD So <sil=0.509> ,COMMA the competition of the pointer resulting from the pointer arithmetic will work but when you try to be reference such a pointer which has resulted from this arithmetic that will cause unexpected result and that will be similar to an array element being accessed with an index which is out of bounds <sil=0.959> .PERIOD So <sil=0.390> ,COMMA for example <sil=0.462> ,COMMA if an array has an element and if you try to access the nth or the n plus 1th element or the minus 1th element then that is an error and result in unpredictable behavior and similarly if you try to obtain a pointer to the nth or n plus 1th element of the array or the minus 1st element of the array you can obtain a pointer but when you try to be reference it using the star operator then the result will be completely unpredictable and therefore <sil=0.318> ,COMMA it is our responsibility to make sure that this never happens that whenever we do the pointer arithmetic we always make sure that our pointer is pointing to a valid element of the array <sil=0.916> .PERIOD So <sil=0.534> ,COMMA let us see an example of pointer arithmetic now <sil=0.921> .PERIOD So <sil=0.560> ,COMMA in this example we have two again a variable A is an array of five elements and P is of type in star which means that P will contain a pointer to an integer <sil=0.903> .PERIOD Now <sil=0.595> ,COMMA the first assignment that happens is P assigned A plus 1 <sil=0.950> .PERIOD Now <sil=0.650> ,COMMA what do you think will happen <sil=0.972> ?QUESTIONMARK Note that the expression A denote the starting address of array A or in other words the address of the 0th element of A and now if you add 1 to 8 one is an integer <sil=0.939> .PERIOD So <sil=0.437> ,COMMA add 1 to the address of the 0th element of A what you get is the address of the first element of A <sil=0.976> .PERIOD So <sil=0.308> ,COMMA once this assignment executes P will point to the first element of the array A <sil=0.905> .PERIOD Now <sil=0.616> ,COMMA in the next step we have the statement P plus equal to 2 which of course <sil=0.380> ,COMMA as you know is the same as P assigned P plus 2 <sil=0.951> .PERIOD So <sil=0.543> ,COMMA in this case again what we are doing is adding 2 to a pointer value and assigning the result back to the pointer variable P <sil=0.982> .PERIOD Now <sil=0.303> ,COMMA P is currently pointing to the first element of the array A <sil=0.983> .PERIOD So <sil=0.398> ,COMMA P plus 2 will point to the third element of the array A and that pointer value is assigned back into the variable P and so after execution of this assignment P will point to the third element of the array A and in the next step we are subtracting something from the pointer we are subtracting one from the pointer which means that the pointer will move one step back in the array <sil=0.929> .PERIOD So <sil=0.604> ,COMMA P will now start pointing to the second element of the array A <sil=0.979> .PERIOD Now <sil=0.575> ,COMMA we are doing something interesting we are using P as an array and we are dereferencing some in some pointer using the array notation <sil=0.307> ,COMMA but note that P is not actually pointing to the zero earth element of the array it is pointing to some element of the array <sil=0.600> ,COMMA but that does not really matter when we say P 1 assigned 5 what is going to happen is think of an array which starts here <sil=0.919> .PERIOD So <sil=0.505> ,COMMA think of this section of the array <sil=0.938> .PERIOD So <sil=0.304> ,COMMA when we are using P as an array where P is pointing to some is element of the array then P 1 is the same as P i plus 1 if P is the same as sorry is A i plus 1 if P is the same as which is of course the same as A plus i <sil=0.946> .PERIOD So <sil=0.411> ,COMMA if P points to the I f is the same as element then P 1 would refer to the i plus 1th element of that array <sil=0.978> .PERIOD So <sil=0.641> ,COMMA therefore <sil=0.599> ,COMMA now when P 1 is assigned 5 what will happen is that the first element of this array segment will become 1 and so P 1 would be this particular cell which as you can see is the third element of the array A and that follows from this kind of rule that we just saw since P is pointing to the second element of the array then P 1 is the same as the 2 plus 1 that is the third element of the array A <sil=0.916> .PERIOD So <sil=0.456> ,COMMA P 1 assigned 5 results in this element of the array A getting the value 5 <sil=0.959> .PERIOD Now <sil=0.588> ,COMMA again talk a little bit about strings and see how strings relate to arrays we already know that strings are actually arrays of characters with the special property that the useful data in the string is terminated by an L character and as a matter of fact strings are very commonly used as pointers because as you have already seen arrays can be used as pointers <sil=0.928> .PERIOD So <sil=0.567> ,COMMA whenever in a function like for example <sil=0.335> ,COMMA print F we pass S format string as an argument or in a function like S t r length we pass string as an argument in terms of length of the string <sil=0.918> .PERIOD When we pass string as an argument to a function what we are really passing is the starting address of the character array that stores the string and this follows just from the fact that the string is really nothing but an array and when we pass an array as an argument to a function what is really passed is the starting address of the array <sil=0.976> .PERIOD Now <sil=0.320> ,COMMA strings are also different from other kinds of arrays in the sense that it is possible to have constant strings for example <sil=0.612> ,COMMA the constant string A B C here <sil=0.957> .PERIOD Now <sil=0.418> ,COMMA what kind of an array is that <sil=0.897> ?QUESTIONMARK Now <sil=0.542> ,COMMA what happens with constant strings is that the constant strings are treated by the compiler as anonymous array and anonymous means without a name <sil=0.962> .PERIOD So <sil=0.574> ,COMMA when we use a constant string in the program what happens is that the compiler creates some space somewhere in the memory which contains that string and the value of the constant string expression is nothing but the starting address of that array and we should be careful here that different declarations different ways of declarations of a string may actually mean different things <sil=0.972> .PERIOD So <sil=0.474> ,COMMA now that we know that pointers and arrays can be used interchangeably we could have these two different kinds of declarations for a string variable but the behavior is going to be slightly different in these two cases <sil=0.945> .PERIOD So <sil=0.336> ,COMMA in the first case we are declaring a pointer variable P which is initialized to the starting address of a constant string A B C <sil=0.903> .PERIOD In the second case we are declaring an array of vectors called P which is being initialized to the string A B C <sil=0.924> .PERIOD So <sil=0.370> ,COMMA in the first case if we draw this in terms of pictures what it looks like is the following that A B C is an anonymous array created in the memory somewhere by the compiler which contains a string A B C the character A B C followed by of course <sil=0.542> ,COMMA the null character and the variable P a box is created for the variable P or a memory location is assigned for the variable P and that is initialized to point to the starting address of this anonymous array <sil=0.972> .PERIOD Note that in this case we can change the value of the variable P because P is a normal variable of type character and we can reassign it to point to some other string <sil=0.915> .PERIOD Now <sil=0.417> ,COMMA if we contrast it with the other kind of declarations what is happening in this case is that we are asking the compiler to create an array called P it is no longer an anonymous array which is initialized which will have four elements in it because the size of the initializing string is four including null character and so P is the name of an array whose elements are the characters A B C and the null character <sil=0.902> .PERIOD Note that now P is the name of an array and therefore <sil=0.588> ,COMMA P cannot appear on the left side of an assignment <sil=0.998> .PERIOD So P assigned something would be wrong in this declaration whereas P assigned some other thing would be correct in this kind of a declaration because here P is associated with a point P is the name of a pointer variable whereas here P is the name of an array itself <sil=0.930> .PERIOD Now <sil=0.472> ,COMMA let us revisit some of the string handling functions that we talked about some time back and we will see that it is very easy to write the string handling functions that we use from the library <sil=0.988> .PERIOD So <sil=0.387> ,COMMA as an example let us try writing the string length function ourselves and that will illustrate how easy it is to actually write functions that manipulate a manipulate strings and so on <sil=0.902> .PERIOD So <sil=0.509> ,COMMA as you know the functionality of the string length function is simple given a string we have to return its length and to do that all we have to do is we have to count the characters in the string till we find a null character and discount is the length of the string <sil=0.956> .PERIOD Note that the length that we have to return should not include the null character itself <sil=0.901> .PERIOD So <sil=0.448> ,COMMA here is the first version of our string length implementation <sil=0.901> .PERIOD So <sil=0.468> ,COMMA we are actually using the pointer which is passed to the function as an array using the array notation <sil=0.980> .PERIOD So <sil=0.533> ,COMMA this loop initializes I to 0 and then as long as Si is not equal to the null character it increments I note that the loop body is empty <sil=0.984> .PERIOD So <sil=0.368> ,COMMA all that is happening is in this i plus plus and in the loop condition <sil=0.905> .PERIOD So <sil=0.434> ,COMMA essentially this loop will terminate as soon as we can find that Si is equal to the null character and then I will be nothing but the length of the array because note that we are incrementing I 1 for every non null character that we find in the string <sil=0.931> .PERIOD Now <sil=0.378> ,COMMA we could have written the same string handling function the same string length function using pointer arithmetic as well that is instead of using Si to access the I s element of the string I s character in the string we could have used something like star of s plus i which would be the same as Si <sil=0.977> .PERIOD So <sil=0.453> ,COMMA we could have done that and even more interestingly we could have modified the value of the variable s itself in the loop <sil=0.920> .PERIOD So <sil=0.375> ,COMMA let us look at this second implementation of the same function <sil=0.928> .PERIOD So <sil=0.618> ,COMMA this time I have chosen to declare s as a car star which of course <sil=0.327> ,COMMA is the same as declaring it as an array within the function parameter <sil=0.924> .PERIOD But <sil=0.618> ,COMMA I am going to use s as a pointer and not use it with the array notation <sil=0.905> .PERIOD So <sil=0.625> ,COMMA in this version of the function what is being done is that again i is a sin p rho that will be the count and we are checking whether s is pointing to the null character <sil=0.998> .PERIOD Now <sil=0.326> ,COMMA star s is nothing but the value of the character to which s point and as long as that is not null we keep running the loop the loop body is again empty <sil=0.975> .PERIOD But <sil=0.580> ,COMMA after every iteration of the loop we increment i by 1 of course <sil=0.444> ,COMMA to account or count for the non null character that we have just seen and we also increment the value of s <sil=0.935> .PERIOD Note that this is the same as s assigned s plus 1 <sil=0.904> .PERIOD Now <sil=0.420> ,COMMA this is not normal arithmetic this is pointer arithmetic because s is a pointer <sil=0.901> .PERIOD So <sil=0.461> ,COMMA what you are doing here interestingly is that we are modifying the pointer argument that has been passed to us <sil=0.969> .PERIOD But <sil=0.340> ,COMMA again note that it is the copy of the address that we have been given we are not actually modifying an element of the string whose address is given to us <sil=0.937> .PERIOD But <sil=0.331> ,COMMA the address of the string itself and the address of the string that we have been given is actually a copy of the original address from the calling function <sil=0.966> .PERIOD So <sil=0.307> ,COMMA the change to s will not get reflected in the calling program <sil=0.985> .PERIOD Now <sil=0.604> ,COMMA this may not be obvious to you <sil=0.338> ,COMMA but once we trace this function with a calling function and with the help of the notation that we have already seen using boxes and arrows to represent variables and pointers this will become very clear <sil=0.907> .PERIOD So <sil=0.626> ,COMMA let us go and do that <sil=0.963> .PERIOD So <sil=0.528> ,COMMA here is the same function again the string length function that we had the string and let us say this is the calling function <sil=0.931> .PERIOD So <sil=0.589> ,COMMA in this calling function we have a pointer p which is pointing to a constant string a b c <sil=0.917> .PERIOD So <sil=0.445> ,COMMA let us draw our familiar boxes and arrows <sil=0.994> .PERIOD So <sil=0.487> ,COMMA p is pointing to the 0th element of this anonymous array containing the characters a b c followed by a null character and of course <sil=0.470> ,COMMA l is a normal integer variable and then we are calling string length with the argument p and the result is assigned to l <sil=0.928> .PERIOD So <sil=0.626> ,COMMA these two are the variables of the calling function <sil=0.958> .PERIOD Now <sil=0.497> ,COMMA when this function gets called space is created for the argument for the parameter the parameter is s which is just a pointer and this will be initialized with the value of the argument which is passed <sil=0.918> .PERIOD So <sil=0.412> ,COMMA value of the argument is the value of the variable p which is a pointer to the 0th element of the string <sil=0.956> .PERIOD So <sil=0.336> ,COMMA the value of s will also be there <sil=0.947> .PERIOD Now <sil=0.413> ,COMMA when this loop run i is initialized to 0 i is a local variable of the string length function <sil=0.968> .PERIOD So <sil=0.310> ,COMMA i gets initialized here and s is already pointing to the 0th element of the string <sil=0.916> .PERIOD Now <sil=0.498> ,COMMA the check is made whether star s is equal to the null character or not star s is nothing but the character a which is not the null character <sil=0.901> .PERIOD So <sil=0.590> ,COMMA the loop body execute the loop body itself is empty and at the end of the loop body this expression is evaluated note that it is using the comma operator which means both these expressions will get evaluated <sil=0.966> .PERIOD So <sil=0.372> ,COMMA the first expression to be evaluated is s plus plus which will which is of course <sil=0.360> ,COMMA as we saw is the same as s s and s plus 1 which will mean that s will now start pointing to the first element of this character array and i will become 1 <sil=0.905> .PERIOD Now <sil=0.399> ,COMMA the next time the loop condition is again tested star s is now b which is still not the null character <sil=0.944> .PERIOD So <sil=0.556> ,COMMA s gets incremented again s start pointing here and i is incremented <sil=0.904> .PERIOD So <sil=0.501> ,COMMA i becomes 2 and then we again go back to the loop test star s is still not equal to the null character <sil=0.921> .PERIOD So <sil=0.586> ,COMMA value of s is changed to point to the next element in the array and the value of i becomes 3 and then the loop test is executed again this time star s is the null character and which is so this test failed so the loop terminates and when the loop terminates the we come to this return statement which returns the value of i which is 3 which is the correct length of the string of course <sil=0.536> ,COMMA the value 3 is returned <sil=0.950> .PERIOD But now the variables of the string length function will get d allocated and the control will go back to the calling function <sil=0.973> .PERIOD So <sil=0.306> ,COMMA l will get assigned the return value which was of course <sil=0.372> ,COMMA 3 and the important point to note is that the modification of s has not resulted in the modification of the variable of the variable p is still pointing to the 0th element of the original array <sil=0.996> .PERIOD Now <sil=0.321> ,COMMA on the other hand if we had modified an element of the array itself <sil=0.945> .PERIOD So <sil=0.608> ,COMMA for example <sil=0.417> ,COMMA if we had executed a statement like this let us say x and let us say at that point in time s happened to be pointing to the first element of the string then this would have been modified and even when the function return and s got d allocated this string this change in the string would still get reflected <sil=1.000> .PERIOD But here what is being modified is just the address which is being passed to us and since we have got a copy of this address this local copy within the string length function is being modified and the original copy of this address does not get modified <sil=0.945> .PERIOD So <sil=0.381> ,COMMA that is the end of this lecture today and before we stop I would like you to utilize the techniques that we have discussed today to try and implement some of the other string library functions that we have already used in some program <sil=0.933> .PERIOD For example <sil=0.331> ,COMMA you could implement the string cat str cat function which concatenates two string or you could implement the string comparison function str cmp which compares two strings <sil=0.980> .PERIOD In the last lecture we had started looking at the control statements in C and we had talked about the IF <sil=0.370> ,COMMA FLs and the SWIT statements <sil=0.908> .PERIOD Today we will look at another very important class of control flow statements or control statements which are the statements for implementing loops <sil=0.911> .PERIOD We have already used loops in most of the programs that we have written and by now we should already be aware that without loops only the most trivial programs can be written <sil=0.919> .PERIOD We need to in many situations postpone the decision as to how many times a certain piece of code will execute till front time that is based on the based on the inputs received by the program <sil=0.916> .PERIOD Sometimes we may need to decide how many times a particular piece of code should execute <sil=0.930> .PERIOD And for doing that of course <sil=0.462> ,COMMA we need a loop without a loop only what we can do is if it is known in advance how many times a piece of code is to be executed and we can replicate that code that many times <sil=0.905> .PERIOD But without using a loop we cannot postpone that decision to the runtime or in other words based that decision on the inputs that the program has received <sil=0.986> .PERIOD So <sil=0.604> ,COMMA here is the first statement for implementing a loop that is a wild statement <sil=0.979> .PERIOD We have already used this in many programs that we have written so for the syntax is very simple while and then we have an expression in brackets followed by a single statement <sil=0.949> .PERIOD So <sil=0.511> ,COMMA this statement again just like if an if else has to be single statement <sil=0.637> ,COMMA but if we want to have multiple statements here we can enclose them in basis and form a single compound statement <sil=0.975> .PERIOD So <sil=0.483> ,COMMA the meaning of this loop is that the expression is evaluated and if it is through the statement is executed and again the expression is evaluated if it is still through the statement is well is executed again and so on so forth and this process continues till the evaluation of expression leads to the value falls <sil=0.983> .PERIOD So <sil=0.640> ,COMMA this is just explained using a flow chart which we have in the next slide <sil=0.927> .PERIOD So <sil=0.589> ,COMMA this diagram represents the flow chart for the loop shown on the left hand side which is while E s here E is the loop condition and S is known as the body of the loop <sil=0.943> .PERIOD So <sil=0.594> ,COMMA in this flow chart the execution begins here and the first thing that happens is that E is evaluated the expression E is evaluated note that again the expression E may have side effects <sil=0.912> .PERIOD So <sil=0.468> ,COMMA evaluating the expression will mean that those side effects do certainly take place and finally <sil=0.635> ,COMMA the evaluation of E results in a value and depending on whether that is through or false again you will recall that in see any non-zero value is taken as true and 0 is taken as false <sil=0.976> .PERIOD So <sil=0.348> ,COMMA if the value turns out to be true that is any non-zero value then S is executed and after execution of S the control goes back to the beginning of the loop and E is evaluated again and this process continues <sil=0.920> .PERIOD When after sometime when E evaluates to false at that time the control takes this part and goes to the statement following the while loop <sil=0.909> .PERIOD Note that it is important to understand that E may evaluate to false the first time around itself <sil=0.906> .PERIOD If that happens then the body of the loop S will not get executed E 1 1 <sil=0.975> .PERIOD Let us now see some examples of using the while statement using familiar programs <sil=0.936> .PERIOD So <sil=0.341> ,COMMA here is a while loop for computing the factorial we have we initialize P 2 1 and while N greater than 0 P star is equal to N minus minus C is the post decrement operator that we are already familiar with and this star equal to as you know is equal into P assigned P star N minus minus <sil=0.978> .PERIOD So <sil=0.401> ,COMMA the control flow or the flowchart for this particular piece of course would look like the diagram shown on the right hand side of the slide <sil=0.926> .PERIOD So <sil=0.512> ,COMMA we first compute or execute the statement P assigned 1 <sil=0.981> .PERIOD Note that this is outside loop body and so this will be executed only once and then the loop execution starts in the loop execution we test N greater than 0 F S execute P star equal to N minus minus and then go back and test the loop condition again <sil=0.992> .PERIOD Let us try to trace this loop for some initial value of N let us assume that the initial value of N happens to be 2 <sil=0.929> .PERIOD So <sil=0.358> ,COMMA P assigned 1 and we test whether N is greater than 0 it is because N is 2 at this point in time <sil=0.980> .PERIOD So <sil=0.395> ,COMMA the answer is true and the control goes to this statement P star is equal to N minus minus what will that do that willultiply P by 2 which is the value of N minus minus remember the initial value of N was 2 <sil=0.981> .PERIOD So <sil=0.502> ,COMMA P will become 1 times 2 which is 2 and N because of the post decrement will become 1 then we go back to the loop we test again whether N is greater than 0 yes indeed it is because N is 1 now so that evaluates true <sil=0.992> .PERIOD So <sil=0.519> ,COMMA we again do this so P becomes 2 times 1 which is 2 and N becomes 0 and then we go back to the loop and test again whether N is greater than 0 now N has become 0 <sil=0.955> .PERIOD So <sil=0.527> ,COMMA this condition turns out to be false and so therefore <sil=0.359> ,COMMA we come out of the loop and the value of P as you know at the end of the slope is the value of the factorial of N <sil=0.974> .PERIOD Note that the slope will work correctly even if the value of N initially is 0 as you know by definition 0 factorial is equal to 1 <sil=0.920> .PERIOD So <sil=0.623> ,COMMA let us again look at this slow shot and see what will happen for N is equal to 0 for N is equal to 0 we will get a sign to 1 as usual and then when this loop condition is tested for the first time it will evaluate to false because because N is equal to 0 which is not greater than 0 and so the loop body which is P star is equal to N minus minus does not get executed even 1 and the control goes out out of the loop immediately and the value of P remains 1 which of course is the correct answer for factorial of 0 <sil=0.912> .PERIOD Now <sil=0.607> ,COMMA let us look at another very commonly used kind of loop construct that is a far loop and the syntax is shown here for is the key world and then within bracket there are three expressions even E 2 and E 3 which have to be separated by semicolon <sil=0.917> .PERIOD Now <sil=0.313> ,COMMA E 1 is the initialization this is what to happen once at the beginning of the loop the expression E 2 is evaluated every time as the loop test that is the loop will continue to run as long as the value of E 2 turns out to be true and E 3 is a step that is done at the end of every loop body execution that is whenever S is executed after that E 3 is evaluated and then the control goes back to the evaluation of the loop test <sil=0.972> .PERIOD So <sil=0.383> ,COMMA the flow chart for the far loop shown here looks like the one shown on the right hand side of the slide E 1 remember is the initialization <sil=0.928> .PERIOD So <sil=0.322> ,COMMA this E 1 is an expression which is evaluated only for its side effects for the simple reason that it is value that is the value of the expression E 1 is discarded <sil=0.997> .PERIOD So <sil=0.309> ,COMMA the expression E 1 would usually have some side effects <sil=0.988> .PERIOD So <sil=0.642> ,COMMA E 1 is the initialization so that happens one and after that the loop condition which is E 2 is evaluated that again of course <sil=0.490> ,COMMA may have side effects and if it happens to be true then the body of the loop S is executed followed by an evaluation of the expression E 3 <sil=0.964> .PERIOD Now <sil=0.313> ,COMMA again the value of E 3 the resulting value of E 3 is discarded <sil=0.934> .PERIOD So <sil=0.322> ,COMMA E 3 also would usually be an expression with some side effects and once E 3 is evaluated the control goes back to the loop condition note that E 1 is then just one <sil=0.906> .PERIOD So <sil=0.440> ,COMMA the control goes back and evaluates E 2 again when E 2 evaluates to false the control goes out of the loop and executes the statement after the loop <sil=0.992> .PERIOD So <sil=0.487> ,COMMA you can see that this fall loop that we have written is entirely equivalent to this while loop <sil=0.911> .PERIOD So <sil=0.368> ,COMMA imagine that we execute E 1 first as the initialization and then E 2 is the loop condition and then E 3 is something that we execute at the end of S <sil=0.924> .PERIOD Now <sil=0.529> ,COMMA the reason this E 3 is important is because many times when we are looping over numbers or when when we want to execute a loop a certain given number of times then we need to instrument a counter in every loop iteration <sil=0.928> .PERIOD So <sil=0.608> ,COMMA those kinds of loops are very neatly captured or implemented using the fall loops let us see some examples <sil=0.930> .PERIOD So <sil=0.424> ,COMMA here is a loop for computing the factorial again but this time written using the fall statement <sil=0.942> .PERIOD So <sil=0.376> ,COMMA the E 1 which is initialization is in this case the entire expression fact assigned 1 comma i is equal to 1 or i assigned 1 <sil=0.911> .PERIOD So <sil=0.369> ,COMMA this comma in fact is another operator that we have not seen so far when we have an expression like E 1 comma E 2 as in this case E 1 here is fact is equal to 1 and E 2 is i assigned 1 <sil=0.948> .PERIOD So <sil=0.345> ,COMMA when we have an expression E 1 comma E 2 what happens is that E 1 is evaluated first and its value is discarded then E 2 is evaluated and its value is the value of the overall expression <sil=0.994> .PERIOD In this particular case of course <sil=0.417> ,COMMA the value of the overall expression is being discarded so that is not really material in this case <sil=0.957> .PERIOD So <sil=0.456> ,COMMA what will happen is that when expression is evaluated there will be two side effects fact will be assigned to 1 followed by i being assigned to 1 and then this is the expression which represents the loop test i is less than n and then this is the expression that is evaluated at the end of the loop body <sil=0.917> .PERIOD So <sil=0.331> ,COMMA what is happening here is that we instead of multiplying numbers from n to 1 in the reverse direction in the decreasing order we are now multiplying numbers from 1 to n in the increasing order and we are not modifying n instead of that we are starting with the i value is equal to 1 and we are incrementing it every time so that at the end of the loop it will become n and the loop body simply is the single assignment statement fact star is equal to i which of course means that fact is multiplied by the value of i <sil=0.968> .PERIOD Note that we do not need to increment the value of i is here in like in the previous loop simply because that is taken care of by the evaluation of the expression e 3 here <sil=0.966> .PERIOD There is another way of using the forward loop for computing the factorial n this is more similar to the while loop that we wrote earlier <sil=0.901> .PERIOD So <sil=0.390> ,COMMA in this case just for illustration I have said the initialization expression e 1 as m p <sil=0.917> .PERIOD So <sil=0.349> ,COMMA actually any of the 3 e 1 e 2 e 3 may be missing but the semicolon must still be there <sil=0.977> .PERIOD Of course <sil=0.392> ,COMMA if the expression e 2 is missing that means that there is no loop test and the loop will go on forever but in that case there must be some other way of breaking out of the loop we will look at one such way later on in the lecture <sil=0.910> .PERIOD So <sil=0.519> ,COMMA fact assigned one we have done this initialization we could have done this as part of the expression e 1 here but just for illustration I have chosen to keep even empty here and the loop condition is n greater than 0 and the after the loop body and minus minus is evaluated <sil=0.950> .PERIOD So <sil=0.335> ,COMMA this is exactly the same as while loop for factorial compilation that we wrote earlier <sil=0.940> .PERIOD So <sil=0.407> ,COMMA the first kind of loop which is possible in C is what is known as a do while loop and this is what the syntax looks like and we have the flow chart on the right hand side of the slide we have the keyword do followed by a statement and then we have while within brackets some expression e which again is the loop test as usual s has to be a single statement <sil=0.938> .PERIOD But if we really want to put multiple statements we can put them to whether in braces and form a single compound statement after that as usual <sil=0.962> .PERIOD So <sil=0.332> ,COMMA the difference between this loop and the while loop is that the loop test that is expression e is evaluated after the execution of the loop body s rather than before <sil=0.973> .PERIOD So <sil=0.630> ,COMMA in terms of the flow chart this is what it looks like you first execute the statement s and then the expression e is evaluated if it turns out to be false then we break out of the loop because we are going to execute s as long as e is true <sil=0.925> .PERIOD So <sil=0.582> ,COMMA if e turns out to be true then we go back to the beginning of the loop and execute s once again and then again test e <sil=0.904> .PERIOD So <sil=0.376> ,COMMA notice that regardless of what the expression e is and whether it turns out to be true or false or whatever s is going to be executed at least one which was not the case in the which was not the case with the while loop because there if the first time the loop test evaluate to false the loop body does not execute even once <sil=0.968> .PERIOD So <sil=0.424> ,COMMA this kind of loop also has its advantages and we prefer to use the do while loop essentially where where we need to execute the body of the loop at least one <sil=0.934> .PERIOD Here is a simple example suppose we are writing a program in which we are expecting or reading some input from the user and we want to check for robustness that the input is indeed valid <sil=0.994> .PERIOD For example <sil=0.377> ,COMMA in the factorial program we might want to test whether the input number which the user has given is non negative or not if it is a negative integers then the factorial is not defined and so we want to ask for never value <sil=0.944> .PERIOD So <sil=0.414> ,COMMA we want to keep prompting the user for the input till he supplies a valid input and since we have to prompt the user at least one we must you we should use a do while loop instead of using a while loop <sil=0.948> .PERIOD So <sil=0.607> ,COMMA here as you can see this is the loop body these two statements and since two statements are not permitted as a loop body we have enclosed them in these braces so that this entire statement from this phrase to this phrase is a single compound statement which can be the loop body <sil=0.966> .PERIOD So <sil=0.495> ,COMMA this loop body prints a prompt for the user to enter a non negative integer and then reads the value of the integer that has been supplied by the user into the variable n and loop condition is n less than 0 <sil=0.978> .PERIOD So <sil=0.383> ,COMMA we want to continue doing this prompting and reading till the user supplies a non negative integer <sil=0.984> .PERIOD So <sil=0.647> ,COMMA as long as the supplied integer n is negative we have to keep doing this <sil=0.916> .PERIOD Note that again the do while loop can also be all do while loops can also be implemented using only the while loop but it might become cumbersome <sil=0.951> .PERIOD So <sil=0.401> ,COMMA as an exercise you can try to implement this functionality using a while loop you will find that it can be done but not so elegantly <sil=0.985> .PERIOD So <sil=0.440> ,COMMA these are the three kind of loop statements that we have in C <sil=0.958> .PERIOD We now look at some other statements which are useful in the context of loops <sil=0.933> .PERIOD The first is the break statement <sil=0.918> .PERIOD So <sil=0.351> ,COMMA break is a very simple statement we have already seen it in the context of the switch statement earlier in the last lecture <sil=0.905> .PERIOD So <sil=0.327> ,COMMA in the switch statement if you recall the break statement causes the execution of the switch statement to finish and go to the next statement that is within the switch statement whenever the break is executed the execution of the switch finishes then in there <sil=0.917> .PERIOD So <sil=0.384> ,COMMA similarly when used inside a loop the break statement causes the loop to terminate immediately regardless of whether the loop rest condition has become through or false and the control goes to the statement immediately following the loop <sil=0.903> .PERIOD Now of course <sil=0.345> ,COMMA it is possible that you have a loop within another loop and within that there is a break statement <sil=0.963> .PERIOD So <sil=0.355> ,COMMA whichever is the inner most loop that contains the break statement that is the one which will be terminated by the execution of the break statement <sil=0.955> .PERIOD And the reason we use break statements is that it is often useful for simplifying loop conditions <sil=0.984> .PERIOD So <sil=0.314> ,COMMA let us look at an example which we have seen earlier <sil=0.921> .PERIOD This is the example of finding whether a given number n is prime or not <sil=0.999> .PERIOD So <sil=0.442> ,COMMA you recall that the way we tested that is by trying out all all possible divisors of n from to up to the floor of square root n and if we find divisor then of course <sil=0.350> ,COMMA n is not a prime and if we do not find divisor then n is prime <sil=0.958> .PERIOD And the loop that we had written earlier in one of the initial lectures was similar to this particular loop <sil=0.993> .PERIOD Although I have changed this slightly and rewritten it as a fall loop instead of writing it as a while loop <sil=0.967> .PERIOD So <sil=0.381> ,COMMA initialization is i assigned to and found assigned false <sil=0.961> .PERIOD Falles remember is a Boolean variable which keeps track of whether we have found a divisor a founded divisor of n yet or not <sil=0.906> .PERIOD So <sil=0.510> ,COMMA initially found a false to begin with we have not found any divisor and we start looking for divisors from two onwards <sil=0.995> .PERIOD The loop condition is i less than equal to square root n <sil=0.983> .PERIOD So <sil=0.415> ,COMMA I am assuming that this variable square root n is an integer variable which contains the floor of the square root value of n <sil=0.925> .PERIOD So <sil=0.328> ,COMMA we have to continue the loop as long as i is less than equal to square root of n and not found meaning that if either of these two conditions become false we break out the loop we stop the loop execution because if i becomes greater than square root of n that means <sil=0.540> ,COMMA we have tested all divisors up to square root of n and did not find any divisor of n <sil=0.985> .PERIOD And if found becomes true that means <sil=0.320> ,COMMA we have found some divisor and therefore <sil=0.444> ,COMMA we must stop the loop execution <sil=0.909> .PERIOD And therefore <sil=0.610> ,COMMA we must keep executing the loop as long as i is less than equal to square root of n and we have not found a divisor that is we have not exhausted all the divisors all the potential divisors of n and we have not yet found the actual divisor of n <sil=0.949> .PERIOD And every time after the execution of the loop body we increment i because in the next iteration of the loop we want to try the next higher potential divisor <sil=0.916> .PERIOD And in the loop body we just test that if i divides n that is n percent i which recall gives the remainder when n is divided by i if n percent i is equal to 0 that means <sil=0.476> ,COMMA i is a divisor of n and so we have found a divisor and so we set found equal to true and the next time the loop condition will be evaluated again we will find that found is equal to true so not found is false and therefore <sil=0.321> ,COMMA this entire condition is also false and so we break out of the loop <sil=0.984> .PERIOD Note that this entire loop has become quite complicated because of the use of this Boolean variable found and the fact that the loop has consist of two independent conditions both of which need to be tested <sil=0.919> .PERIOD Instead of that suppose we use a break to break out of the loop when we find a divisor <sil=0.942> .PERIOD So <sil=0.363> ,COMMA in this version of the same loop the loop body is quite simple and the loop header which contains the expressions e 1 e 2 e 3 are also quite simple the initialization is simply i is sign 2 as before we have done away with the Boolean variable found we are not using it any longer because we will break out of the loop when we find a divisor <sil=0.996> .PERIOD So <sil=0.303> ,COMMA there is no need to use the Boolean variable and the loop test is simply i less than equal to square root n and of course at the end of the loop body we have to increment i <sil=0.941> .PERIOD So <sil=0.434> ,COMMA in the so we are no longer testing whether we have already found a divisor <sil=0.923> .PERIOD So <sil=0.472> ,COMMA that means that if we find a divisor then the loop will not stop and will keep executing because i is still less than or equal to square root n <sil=0.998> .PERIOD Therefore <sil=0.638> ,COMMA when we find a divisor we have to use some other way of stopping the loop and that we do using the break statement <sil=0.971> .PERIOD So <sil=0.410> ,COMMA if n percent i is equal to 0 we execute a break statement and this break statement will immediately terminate this loop because this is the inner most loop containing the break statement note that if is not a loop and so this break will not do anything to the execution of the if it is the far which is a loop which is the inner most loop that contains break <sil=0.979> .PERIOD So <sil=0.401> ,COMMA as soon as break is executed this for loop gets terminated and the control goes to the following instruction <sil=0.985> .PERIOD So <sil=0.324> ,COMMA of course after the end of the loop we need to find out whether we have found a divisor or not <sil=0.980> .PERIOD In the earlier case it was easy because we had this Boolean variable found and at the end of the loop if it was true that means we have found a divisor otherwise we have not found a divisor <sil=0.945> .PERIOD Here we do not have this Boolean variable but finding out whether we came out of the loop because of this break or because of this loop test is quite easy <sil=0.953> .PERIOD If we check the value of i and we find that it has become greater than square root n that means we must have come out of the loop because of this condition otherwise we must have come out of the loop because of this break in which case we found an actual divisor of n and so therefore <sil=0.592> ,COMMA n is not a prime <sil=0.938> .PERIOD Okay related to the break statement there is another statement which is called the continuous statement and the functionality of the continuous statement is that within a loop whenever a continuous statement is executed the current iteration of the loop is terminated it stops and the next iteration begins immediately that is within the loop that is the continuous statement is executed then even if there is there are more statements in the loop body those will not get executed and the next iteration of the loop will start again <sil=0.985> .PERIOD When we say the next iteration of the loop will start again what we really mean is that in the case of the do while loop and in the case of while loop the control will go back will go to the place where the loop condition is evaluated and is tested whether it is true or false but in the case of the fall loop something slightly different happen that when the continuous statement is executed the control goes back to the increment step that is the E3 which is the step which is the expression which is evaluated after the loop body is evaluated <sil=0.964> .PERIOD So essentially the way continuous statement should be thought about is that on execution of the continuous statement the loop body gets terminated and then but the loop itself does not get terminated <sil=0.954> .PERIOD So in the case of fall loop the expression E3 is evaluated again and then the control goes back to the loop test and in the case of the other two other two kinds of loops the control goes back directly to the loop test <sil=0.960> .PERIOD And the reason we need to use the continuous statement is that it can help in simplifying the loops <sil=0.911> .PERIOD For example again here is a simple situation that you might encounter in some programs that you might write <sil=0.942> .PERIOD Suppose you want to write a loop which reads 10 integers from the input and processes them one by one in certain fashion now this processing could be very simple or it could be extremely complex and the constraint is that if there is a negative integer in the input that should not be processed that should be ignored <sil=0.948> .PERIOD So suppose we are not using a continuous statement for implementing this and what we will need to do is this loop is simple for i is equal to 0 i less than 10 i plus plus so do this loop body 10 time read the value of n and if n is greater than equal to 0 then process n <sil=0.933> .PERIOD Now the problem with this kind of structure is that if the processing on n is very complicated and it has several nested control statements one inside the other then the indentation level may become very deep and we are adding to that indentation level by having to indent this entire processing by one extra level because this entire processing is within the body of the if statement <sil=0.944> .PERIOD On the other hand suppose we use a continuous statement then what we can do is after reading the value of n in the loop body if n is less than 0 then we put a continuous statement that means whatever is next in the body of the loop does not get executed and we straight away go to the next iteration of the loop remember that for the for loop when we go to the next iteration that is when we execute the continuous statement the control will first go and evaluate the expression E3 which in this case will increment i and then the loop test will be executed again which is of course we want to which is of course what we want to do because we want to read exactly 10 numbers regardless of whether we are positive or not and so if n is less than 0 we continue and otherwise we have the code for processing and note that the control will come to this place only if the value of n is greater than equal to 0 and so therefore we do not need to test whether the value of n is greater than equal to 0 it is guaranteed to be equal to 0 the difference between these two implementations of the same functionality is that the processing of n is at one lesser level of indentation when we have used continuity because this processing of n is not within any if it is directly within the for statement at the next level <sil=0.920> .PERIOD So <sil=0.366> ,COMMA at the end of the lecture here is an exercise for you and this exercise requires you to write a program to compute what is known as the greatest common divisor or the GCD of two positive integers you probably are aware of the definition of the greatest common divisor of two integers the GCD of two integers is the largest integer which divides both of them <sil=0.984> .PERIOD Historically the best known algorithm for GCD is attributed to Euclid who came up with a very efficient algorithm for GCD based on the following properties <sil=0.942> .PERIOD So <sil=0.346> ,COMMA I will list these properties explain these properties and leave it for you to design the algorithm and then implement that as a program <sil=0.954> .PERIOD So <sil=0.476> ,COMMA these are the three properties the first properties GCD of A and B is of course <sil=0.442> ,COMMA the GCD of B and A that is the arguments can be interchanged the GCD of A and A is the same as A that is if the two numbers are equal then the GCD is equal to the same number that of course <sil=0.504> ,COMMA because A is the largest integer that divides A so that is three will it true <sil=0.907> .PERIOD The third property is the most interesting is given A and B two number say and B and let us assume that A happens to be larger than B then the GCD of A and B is the same as GCD of A minus B and B that is if you subtract the smaller number from the larger number and GCD of this number resulting number and smaller number is the same as the GCD of the original two numbers <sil=0.973> .PERIOD So <sil=0.400> ,COMMA you can try and convince yourself that this property indeed holds always based on these three properties you should be able to come up with an efficient algorithm for computing the GCD the naive algorithm for computing the GCD will try to find the largest integer of A which also is a divisor of B but that is inefficient this will this these properties can lead to an Euclid to an efficient algorithm which will compute the same result in much lesser number of iterations <sil=0.977> .PERIOD So <sil=0.387> ,COMMA that is left as an exercise for today <sil=0.997> .PERIOD In the next lecture we will talk about arrays which are a very very important tool in again writing non-trivial programs and allow us to handle large volumes of data rather than small number of data items at a time <sil=0.995> .PERIOD In this session <sil=0.534> ,COMMA we will learn about one more fundamental data type in C <sil=0.992> .PERIOD So far <sil=0.647> ,COMMA we have seen in and floats <sil=0.984> .PERIOD Inns are supposed to represent integers and floats are supposed to represent real numbers <sil=0.926> .PERIOD We will see the third most important data type which is character <sil=0.999> .PERIOD So <sil=0.420> ,COMMA it is called char in C or car <sil=0.924> .PERIOD C allows a character data type to be 1 byte that is 8 bits wide and 1 byte can hold exactly 1 character <sil=0.959> .PERIOD For example <sil=0.415> ,COMMA a character may be a digit like 0 <sil=0.345> ,COMMA so on up to 9 <sil=0.941> .PERIOD It can be a lower case letter like A up to Z <sil=0.948> .PERIOD It can be an upper case letter like capital A through capital Z and so on <sil=0.955> .PERIOD Similarly <sil=0.503> ,COMMA there are other characters question mark at sharp and so on <sil=0.968> .PERIOD So <sil=0.467> ,COMMA how do you declare a character variable <sil=0.417> ,COMMA how do you assign it and how do you print or scan it <sil=0.969> .PERIOD These are the basic operations that you can do with any data type <sil=0.964> .PERIOD So <sil=0.492> ,COMMA you declare a character variable using the data type CHAR <sil=0.449> ,COMMA car CH will declare a variable of name CH and of data type car <sil=0.902> .PERIOD In order to assign it to any particular constant <sil=0.422> ,COMMA any particular character what you have to do is you write CH equal to A within single codes <sil=0.968> .PERIOD So <sil=0.389> ,COMMA this is how you would assign any character in constants <sil=0.935> .PERIOD All the characters in constants are supposed to be enclosed in this single codes <sil=0.970> .PERIOD For example <sil=0.518> ,COMMA 0 within single codes stands for the character 0 and not the number 0 <sil=0.950> .PERIOD Similarly <sil=0.465> ,COMMA A within character within single codes stands for the characters A <sil=0.932> .PERIOD Now <sil=0.525> ,COMMA how do you print a character <sil=0.960> ?QUESTIONMARK You can use the format specifier percent H C <sil=0.920> .PERIOD So <sil=0.438> ,COMMA recall that percentage D prints an integer and percentage F prints a float <sil=0.927> .PERIOD We have the third fundamental data type which is character which can be printed using a percentage C <sil=0.920> .PERIOD So <sil=0.537> ,COMMA if you say print F percentage C CH it will print A and there is also the abbreviated notation where as soon as you declare the variable <sil=0.597> ,COMMA you can initialize it using character CH equal to A <sil=0.955> .PERIOD This is similar to saying in TIE equal to 0 <sil=0.354> ,COMMA it is the same concept <sil=0.942> .PERIOD Now <sil=0.312> ,COMMA what can we do with the character data type <sil=0.979> ?QUESTIONMARK For example <sil=0.447> ,COMMA we can assign character constants to that character variables <sil=0.908> .PERIOD Now <sil=0.645> ,COMMA what does a character variable mean <sil=0.878> ?QUESTIONMARK And here is the first surprise the value of a character constant is an integer that the machine stores which is usually the ASCII set <sil=0.916> .PERIOD What does this mean <sil=0.899> ?QUESTIONMARK The machine deals with fundamentally bits <sil=0.996> .PERIOD So <sil=0.552> ,COMMA you have a data field which is 8 bits wide and this is a sequence of bits say 1 0 1 1 0 1 1 1 <sil=0.908> .PERIOD Now <sil=0.310> ,COMMA here is the bit pattern and if you say that this bit pattern is a car then the machine takes this integer takes this bit pattern as an integer and looks up a table known as the ASCII set table and sees which character it is <sil=0.976> .PERIOD So <sil=0.510> ,COMMA the value of a character constant is actually an integer and what does that integer represents <sil=0.949> ?QUESTIONMARK The integer represents a particular entry in an ASCII character table and what entry is in that particular location that is the character constant <sil=0.921> .PERIOD So <sil=0.642> ,COMMA think of it like the following the character is just an uninterpreted sequence of bits <sil=0.903> .PERIOD If you tell the machine please read this as an integer it will read this as an integer <sil=0.946> .PERIOD If you read this if you tell the machine please read this as a character it will take that integer go look up the ASCII table and see that this integer stands for the character C and prints that <sil=0.969> .PERIOD So <sil=0.300> ,COMMA by itself the bit pattern can be interpreted in multiple ways <sil=0.964> .PERIOD So <sil=0.514> ,COMMA here is a surprising thing which is different from natural language <sil=0.928> .PERIOD There are certain natural languages where if you and this does not typically happen with Indian languages <sil=0.648> ,COMMA but there are certain languages where you have a character and how you read it depends on where you saw it <sil=0.971> .PERIOD So <sil=0.393> ,COMMA if it was in the middle of a text then this is an alphabet <sil=0.919> .PERIOD If you saw this in the middle of a number sequence then it is a number what happens in the machine is somewhat similar <sil=0.951> .PERIOD You have a bit sequence and this thing is interpreted as a character by looking up the ASCII set <sil=0.986> .PERIOD ASCII stands for American standard code for information interchange and it is one of the popular encodings for characters used in computers <sil=0.986> .PERIOD So <sil=0.399> ,COMMA the code chart looks something like this you have 256 characters and the characters can be looked up in a table <sil=0.917> .PERIOD The table entries are in hexadecimal <sil=0.917> .PERIOD So <sil=0.387> ,COMMA base 16 we will call it as a table to that later in the course why base 16 is convenient <sil=0.354> ,COMMA but there are 8 rows and 16 columns in the table <sil=0.960> .PERIOD So <sil=0.350> ,COMMA in base 16 notation AS stands for 10 <sil=0.336> ,COMMA B stands for 11 <sil=0.633> ,COMMA C for 12 <sil=0.581> ,COMMA so on up to F for 15 <sil=0.913> .PERIOD So <sil=0.428> ,COMMA this is what is meant by the base 16 notation <sil=0.969> .PERIOD So <sil=0.531> ,COMMA let us look at what does the number 7a represent <sil=0.912> .PERIOD 7a is row 7 column number 10 <sil=0.950> .PERIOD So <sil=0.353> ,COMMA that is the number that I am interested in and what is 7a represent it means 7 times 16 plus 10 <sil=0.990> .PERIOD So <sil=0.348> ,COMMA in base 10 notation the number 76 let us say <sil=0.992> .PERIOD So <sil=0.423> ,COMMA if I have this number in 7 in base 10 notation this obviously stands for the numerical value 7 into 10 plus 6 <sil=0.924> .PERIOD Similarly <sil=0.365> ,COMMA in base 16 notation 7a stands for 7 into 16 plus 10 remember that A is 10 <sil=0.929> .PERIOD So <sil=0.502> ,COMMA you have 112 similarly hexadecimal 23 <sil=0.990> .PERIOD So <sil=0.382> ,COMMA row 2 column 3 for example <sil=0.319> ,COMMA hexadecimal 23 means look up 2 times 16 plus 3 the 35th entry in the table <sil=0.927> .PERIOD Now <sil=0.470> ,COMMA here is the structure of the ASCII code set that you use in C <sil=0.914> .PERIOD The first 32 characters basically from 0 0 hexadecimal to 1 F hexadecimal <sil=0.977> .PERIOD So <sil=0.540> ,COMMA these 32 characters which are shaded are what are known as special characters and they are not printable <sil=0.951> .PERIOD They are required by the computer for certain special purposes <sil=0.992> .PERIOD Code 20 that is decimal 32 <sil=0.478> ,COMMA 2 0 is 2 times 16 plus 0 <sil=0.932> .PERIOD So <sil=0.437> ,COMMA this particular entry corresponds to the space character <sil=0.988> .PERIOD So <sil=0.428> ,COMMA it is just a blank space <sil=0.958> .PERIOD Code 21 corresponds to the exclamation character and so on <sil=0.953> .PERIOD So <sil=0.470> ,COMMA the printable characters in the ASCII code are from hexadecimal 20 that is decimal 32 until 126 <sil=0.963> .PERIOD So <sil=0.403> ,COMMA what is enclosed in this green pattern this is these are all printable characters <sil=0.985> .PERIOD Now <sil=0.431> ,COMMA out of this the capital letters start from hex 41 which is 65 in decimal and go on up till decimal 90 small letters start from 97 and go on until 122 and so on <sil=0.947> .PERIOD So <sil=0.325> ,COMMA digits 0 to 9 occur before any character <sil=0.961> .PERIOD So <sil=0.581> ,COMMA why do we need this information <sil=0.977> ?QUESTIONMARK I mean this is how the characters are stored in the computer and do we really need to know it <sil=0.928> .PERIOD The point is not that you have to memorize this table <sil=0.981> .PERIOD You do not need to memorize the table <sil=0.339> ,COMMA but you need to remember certain abstract properties of the table <sil=0.950> .PERIOD We will make that precise in a moment <sil=0.913> .PERIOD We do not have to say that the ASCII code for A is 65 or 42 or that is a waste of memory <sil=0.942> .PERIOD So <sil=0.589> ,COMMA let us just see what can we do with this table without really remembering what the table looks like <sil=0.983> .PERIOD So <sil=0.562> ,COMMA there are some ideas behind the design of the table <sil=0.641> ,COMMA how the table is structured which C programmers can use <sil=0.929> .PERIOD There is no need to remember that a particular character had a particular ASCII value <sil=0.962> .PERIOD So <sil=0.354> ,COMMA let us just recall a character constant is an integer namely the ASCII code for that character <sil=0.941> .PERIOD Now <sil=0.587> ,COMMA which means that I will emphasize this with a very strange code <sil=0.968> .PERIOD I can declare character CH and say characters CH equal to A within single code <sil=0.937> .PERIOD So <sil=0.323> ,COMMA that obviously <sil=0.465> ,COMMA initializes the character to A <sil=0.978> .PERIOD It assigns the value A to the variable CH <sil=0.453> ,COMMA but I could also do the following character CH equal to 65 <sil=0.937> .PERIOD Why 65 <sil=0.964> ?QUESTIONMARK The ASCII value for A was 65 <sil=0.916> .PERIOD So <sil=0.504> ,COMMA instead of writing it as A within single code <sil=0.534> ,COMMA I can write CH equal to the number 65 and it will be the correct ASCII character anyway <sil=0.922> .PERIOD Now <sil=0.425> ,COMMA this means that the same character can also be interpreted as an integer if you really want to think of it in that way <sil=0.903> .PERIOD So <sil=0.624> ,COMMA for example <sil=0.350> ,COMMA I can say percentage C CH if I do it in print F <sil=0.355> ,COMMA it will print it as <sil=0.956> .PERIOD So <sil=0.564> ,COMMA the first print F will print A <sil=0.429> ,COMMA but I could also take a character variable and ask C to print it as an integer using percentage D <sil=0.372> ,COMMA it will print 65 <sil=0.901> .PERIOD So <sil=0.526> ,COMMA remember that the external form that we see in some sense is the letter A <sil=0.473> ,COMMA the internal representation is the number 65 <sil=0.473> ,COMMA because 65 is the entry in the ASCII table corresponding to the character A <sil=0.980> .PERIOD Now <sil=0.560> ,COMMA the one more thing is that you can print arbitrary numbers <sil=0.932> .PERIOD Even non printable characters <sil=0.347> ,COMMA you can sort of print them using C <sil=0.968> .PERIOD And one way to do that is I can print any 8 bit character with the hexadecimal representation like backslash ash <sil=0.384> ,COMMA a backslash x followed by the hexadecimal digit <sil=0.999> .PERIOD For example <sil=0.446> ,COMMA backslash x followed by 7 is the bell character <sil=0.927> .PERIOD So <sil=0.539> ,COMMA let me go back a couple of times <sil=0.447> ,COMMA couple of slides <sil=0.969> .PERIOD So <sil=0.315> ,COMMA if you look at the 7th entry in the ASCII table <sil=0.645> ,COMMA it is represented as BEL <sil=0.633> ,COMMA that is a small bell in your system <sil=0.988> .PERIOD So <sil=0.515> ,COMMA if you ask the system to print the 7th character in the ASCII table <sil=0.441> ,COMMA what will happen is that your computer will make a small beep sound <sil=0.963> .PERIOD So <sil=0.475> ,COMMA there are certain non printable characters which can also be printed directly using <sil=0.949> .PERIOD Similarly <sil=0.484> ,COMMA let us say backslash x B is the 11th number in the ASCII table <sil=0.466> ,COMMA it is a vertical space <sil=0.994> .PERIOD So <sil=0.563> ,COMMA if you print that character <sil=0.595> ,COMMA it will print a vertical space <sil=0.932> .PERIOD Similarly <sil=0.344> ,COMMA if I ask it to print hexadecimal 41 using backslash x 41 <sil=0.914> .PERIOD So <sil=0.640> ,COMMA hex 41 is 4 times 16 plus 1 <sil=0.618> ,COMMA which is 64 plus 1 <sil=0.341> ,COMMA 65 <sil=0.973> .PERIOD And we just saw that ASCII value 65 was the character A <sil=0.910> .PERIOD So <sil=0.319> ,COMMA if I ask it to print CH <sil=0.445> ,COMMA which is hexadecimal 41 as a character <sil=0.541> ,COMMA then it will print the value A <sil=0.955> .PERIOD So <sil=0.536> ,COMMA when you run this program <sil=0.352> ,COMMA what it will do is first <sil=0.352> ,COMMA because you asked it to print a bell character <sil=0.417> ,COMMA it will beep once <sil=0.412> ,COMMA it will ring a bell <sil=0.911> .PERIOD And then it will print the second character <sil=0.593> ,COMMA which is a vertical space <sil=0.952> .PERIOD So <sil=0.466> ,COMMA it will print a vertical space <sil=0.961> .PERIOD And then the third character was a printable character A <sil=0.387> ,COMMA it will print A <sil=0.923> .PERIOD So <sil=0.385> ,COMMA you can ask the system to print arbitrary entries in the ASCII table <sil=0.950> .PERIOD If it is a printable character <sil=0.413> ,COMMA it will print that corresponding character <sil=0.945> .PERIOD If it is a non printable character <sil=0.597> ,COMMA it might take a suitable action <sil=0.917> .PERIOD So <sil=0.592> ,COMMA just for information sake <sil=0.537> ,COMMA there instead of printing it as backslash x followed by the hex code <sil=0.456> ,COMMA you see provides certain escape characters <sil=0.501> ,COMMA some special sequences as well in order to print these non printable characters <sil=0.988> .PERIOD First of all <sil=0.492> ,COMMA until now we have seen one such number <sil=0.372> ,COMMA which is backslash n <sil=0.925> .PERIOD So <sil=0.473> ,COMMA backslash n is the new line character <sil=0.410> ,COMMA it is a non printable character <sil=0.533> ,COMMA but it corresponds to some ASCII character <sil=0.931> .PERIOD Similarly <sil=0.460> ,COMMA for the other non printable characters <sil=0.395> ,COMMA C has some escape characters <sil=0.944> .PERIOD For example <sil=0.384> ,COMMA backslash A is a bell character and so on <sil=0.968> .PERIOD In this session <sil=0.502> ,COMMA we will see one more feature that is present in C associated with loops <sil=0.939> .PERIOD So we will motivate these statements using the concept of an infinite loop <sil=0.982> .PERIOD Here is a drawing that is supposed to be a representation of an infinite loop <sil=0.914> .PERIOD And <sil=0.633> ,COMMA for example <sil=0.556> ,COMMA the Apple headquarters <sil=0.373> ,COMMA the address is one infinite loop <sil=0.995> .PERIOD So let us see what is an infinite loop <sil=0.923> .PERIOD So the basic <sil=0.550> ,COMMA the simplest kind of infinite loop is when you have a wild statement and the test condition <sil=0.448> ,COMMA you can see that it will never be false <sil=0.948> .PERIOD So remember that one is true in C <sil=0.950> .PERIOD So this statement means that you will enter the wild loop <sil=0.638> ,COMMA you will test the condition <sil=0.362> ,COMMA the test is true <sil=0.982> .PERIOD So you will execute the statement <sil=0.552> ,COMMA you will go back and test the condition again <sil=0.560> ,COMMA it is again true <sil=0.480> ,COMMA it has not changed <sil=0.359> ,COMMA it is one <sil=0.946> .PERIOD Therefore <sil=0.616> ,COMMA you will enter the statement again <sil=0.954> .PERIOD So you will have an infinite loop <sil=0.966> .PERIOD If the test is executed <sil=0.642> ,COMMA then the control enters the body of the loop and this happens without any change <sil=0.904> .PERIOD So let us look at this simple wild loop <sil=0.441> ,COMMA which is wild one <sil=0.650> ,COMMA the statement is printf <sil=0.594> ,COMMA I am an infinite loop <sil=0.927> .PERIOD So if you will run this code <sil=0.460> ,COMMA compile and run this code after you write the main function and all that <sil=0.400> ,COMMA then the program will keep on printing the same message over and over again <sil=0.991> .PERIOD And you cannot exit out of the program <sil=0.938> .PERIOD If you are running a Linux system <sil=0.554> ,COMMA you can press control C and the program will exit immediately <sil=0.978> .PERIOD But here is an infinite loop <sil=0.380> ,COMMA it executes an infinite number of times <sil=0.933> .PERIOD So is there a statement which helps us to exit from a loop <sil=0.882> ?QUESTIONMARK Now this is useful not just to handle infinite loops <sil=0.455> ,COMMA even when you write normal loops <sil=0.647> ,COMMA it is important to have these constructs <sil=0.523> ,COMMA they make your programming easier <sil=0.939> .PERIOD So C allows a programmer to explicitly break out of a loop using a particular statement known as break <sil=0.939> .PERIOD When the break statement is encountered <sil=0.311> ,COMMA the execution breaks out of the innermost loop <sil=0.971> .PERIOD So what is a loop <sil=0.858> ?QUESTIONMARK So far we have seen wild loop <sil=0.581> ,COMMA do wild loop and for loop <sil=0.911> .PERIOD Later we will see as construct calls switch <sil=0.928> .PERIOD So whatever is the innermost loop <sil=0.472> ,COMMA notice that we have talked about double loops <sil=0.974> .PERIOD We have talked about a wild loop within a wild loop <sil=0.363> ,COMMA we have talked about a for loop within a for loop <sil=0.997> .PERIOD Whatever is the innermost for loop within which a particular break occurs <sil=0.488> ,COMMA it will exit out of that <sil=0.950> .PERIOD So let us write a very simple program which reads all numbers till minus 1 is seen and adds them up <sil=0.532> ,COMMA minus 1 is excluded <sil=0.971> .PERIOD So you can write a wild loop <sil=0.590> ,COMMA we have written this before where the wild loops test condition was somewhat more sophisticated <sil=0.950> .PERIOD Earlier we wrote something like wild if you recall <sil=0.511> ,COMMA if we had written a loop saying wild not of a equal to minus 1 <sil=0.953> .PERIOD So this was the earlier loop that we had written and in this case let us write a similar program but with a simpler test expression which is just wild one <sil=0.911> .PERIOD So you always enter the loop <sil=0.648> ,COMMA no matter what number you read <sil=0.942> .PERIOD So initialize the variable sum to 0 <sil=0.426> ,COMMA declare the integer variable A and then you enter the wild loop because the test is true <sil=0.543> ,COMMA you scan a number and here is a use of the break statement <sil=0.989> .PERIOD If the scanned number is minus 1 <sil=0.576> ,COMMA you break out of the loop <sil=0.949> .PERIOD If it is not minus 1 <sil=0.618> ,COMMA you go to the next statement which is sum equal to sum plus A <sil=0.993> .PERIOD So you add the number <sil=0.957> .PERIOD Again you go back to the loop <sil=0.388> ,COMMA the test condition is always true so you enter and read the next number <sil=0.926> .PERIOD So the net effect of the loop is that whenever you see a minus 1 <sil=0.305> ,COMMA it immediately exits out of the loop otherwise it adds that number to the loop <sil=0.968> .PERIOD So let us look at it using a sample input <sil=0.995> .PERIOD Initially A is undefined <sil=0.563> ,COMMA it is just declared so it has some garbage value and sum is initialized to 0 <sil=0.929> .PERIOD Let us say that the input is 532 minus 1 <sil=0.901> .PERIOD Wild one so one is true therefore we enter the wild loop <sil=0.396> ,COMMA you scan the first number <sil=0.904> .PERIOD So A becomes 5 <sil=0.483> ,COMMA A is not minus 1 <sil=0.521> ,COMMA therefore you go to sum equal to sum plus A <sil=0.978> .PERIOD So sum becomes 5 and then you go back to the wild loop <sil=0.443> ,COMMA the test condition is still true while 1 <sil=0.939> .PERIOD So you read the next number 3 <sil=0.470> ,COMMA 3 is not minus 1 <sil=0.976> .PERIOD So you add it to the sum <sil=0.468> ,COMMA sum becomes 8 and you go back the same thing occurs <sil=0.990> .PERIOD So you have the third number red which is 2 <sil=0.519> ,COMMA add it to the sum and sum becomes 10 <sil=0.957> .PERIOD Then you read the next number and now A is minus 1 <sil=0.908> .PERIOD So what happens <sil=0.883> ?QUESTIONMARK The if condition <sil=0.354> ,COMMA the expression within the if statement is true and you execute the statement inside the if condition <sil=0.632> ,COMMA the statement is break <sil=0.962> .PERIOD So the recall that the rule of break says that exit out of the innermost loop <sil=0.951> .PERIOD So in particular what is the innermost loop <sil=0.915> ?QUESTIONMARK You look starting from here and imagine that you are going out towards towards the top of the state towards the top of the program <sil=0.987> .PERIOD The first loop that you will encounter on its way <sil=0.426> ,COMMA that is the loop that you will exit out of <sil=0.984> .PERIOD In particular break does not mean that exit out of the if condition <sil=0.911> .PERIOD Break means that exit out of the first loop that you see when you start from the statement and work out towards <sil=0.922> .PERIOD So that is this wild loop <sil=0.608> ,COMMA break means you will exit out of the wild loop and print this statement <sil=0.931> .PERIOD So you will print that the output is 1 <sil=0.382> ,COMMA the output is 10 <sil=0.999> .PERIOD So let us we have been dealing with integers for a long time <sil=0.945> .PERIOD Let us write a small program using characters <sil=0.902> .PERIOD So here is a problem and let us say that we are writing a very simple editor <sil=0.904> .PERIOD Now the editor has the following property <sil=0.990> .PERIOD There are a particular number of maximum characters that you can read <sil=0.953> .PERIOD Maybe it is 1000 <sil=0.983> .PERIOD So you can type in a bunch of characters until one of the two conditions occur <sil=0.966> .PERIOD Either you enter a blank line by itself which is indicating that I am done entering the text or you enter more than the maximum number of characters available <sil=0.931> .PERIOD So recall there are two conditions for exiting out of our so called editor <sil=0.900> .PERIOD You can type a lot of characters <sil=0.939> .PERIOD If your limit was 1000 and you exit 1000 then you cannot type in any more characters and you exit <sil=0.959> .PERIOD Otherwise if you are within 1000 characters but you entered a blank line that is indicating that you are done <sil=0.948> .PERIOD You have nothing more to enter then also you should exit <sil=0.986> .PERIOD So there are two conditions <sil=0.920> .PERIOD Let us try to write this code <sil=0.942> .PERIOD So you have maximum characters and let us say I scan that then I which counts how many characters I have read so far <sil=0.910> .PERIOD So I should initialize to 0 and then there is a current character and then there is a previous character <sil=0.906> .PERIOD So I will initialize current to the new line character <sil=0.952> .PERIOD Now there is a particular reason for that which will become clear later <sil=0.991> .PERIOD So you should initialize current to a particular character and then what I do is use the get-chare function <sil=0.912> .PERIOD So get-chare function reads a particular character from the input and stores it in some variable if you need to <sil=0.950> .PERIOD Instead you can also say something like scanf %hc and some into some variable <sil=0.980> .PERIOD So you can do either of these two things and they are almost equivalent <sil=0.902> .PERIOD So you read one more character <sil=0.998> .PERIOD Now what should you do <sil=0.969> ?QUESTIONMARK You initialize by starting from 0 <sil=0.981> .PERIOD So you have read no characters until so until now and until you read maximum number of characters <sil=0.987> .PERIOD So you execute this loop <sil=0.971> .PERIOD Remember that I said that for loop is good when you know the number of iterations in advance <sil=0.909> .PERIOD So we know that at most we will execute maximum number of character times because that is the maximum number of characters we are allowed to read <sil=0.996> .PERIOD So for loop is slightly better than a while loop <sil=0.954> .PERIOD You can also do it using a while loop if you want <sil=0.969> .PERIOD So you say for i equal to 0 i less than maximum characters i equal to i plus 1 <sil=0.954> .PERIOD Now we will do this programming style that we should be familiar with right now <sil=0.913> .PERIOD So previous becomes current and current becomes the next character <sil=0.927> .PERIOD So previous equal to current <sil=0.957> .PERIOD So this is will store the current character into the variable previous <sil=0.917> .PERIOD Then you read the next character using get char <sil=0.954> .PERIOD And as I said before you can also write equivalently scanf %hc and current <sil=0.919> .PERIOD So both these are almost equivalent <sil=0.942> .PERIOD There is a slight difference but we will be it is not important as of now <sil=0.955> .PERIOD Now if current is new line and the previous was new line <sil=0.919> .PERIOD So when will that happen <sil=0.882> ?QUESTIONMARK When suppose I write this is a sentence <sil=0.938> .PERIOD I will explicitly repress in the new line <sil=0.914> .PERIOD So when I press enter I will have a new line character here <sil=0.911> .PERIOD And when will a blank line occur when the next character is also new line <sil=0.947> .PERIOD So by a blank line what I mean is that the current sentence is over <sil=0.981> .PERIOD So I press a new line and the next character on the next line is also a new line <sil=0.925> .PERIOD That is what is actually meant by a blank line <sil=0.994> .PERIOD So when that happens then we know that an empty line has been encountered and here is the important thing break <sil=0.941> .PERIOD Because one of the conditions to exit out of that loop was that either maximum number of characters is encountered or a blank line is encountered <sil=0.999> .PERIOD So you may not have encountered maximum number of characters but you have encountered a blank line <sil=0.916> .PERIOD So you should exit out of the loop <sil=0.962> .PERIOD Again the rule is that break out of the innermost for loop <sil=0.592> ,COMMA innermost loop which in this case is this for loop <sil=0.920> .PERIOD So you get out of that loop and print up a new line <sil=0.938> .PERIOD Now as with many constructs in C you can avoid break all together <sil=0.953> .PERIOD You can write code if you have used break you can write equivalent logic without using break <sil=0.952> .PERIOD So here is a standard way to do it <sil=0.945> .PERIOD So here is the code that we just dealt with <sil=0.975> .PERIOD It had two exit conditions <sil=0.967> .PERIOD One is that the number of characters that you read is greater than the maximum allowed <sil=0.914> .PERIOD Another exit condition was that you had entered a blank line <sil=0.932> .PERIOD So here we used the break statement <sil=0.968> .PERIOD And now I want to write an equivalent loop without using the break statement <sil=0.950> .PERIOD And here is a very standard programmatic type <sil=0.945> .PERIOD These are known as flags <sil=0.900> .PERIOD So flag is just a variable which indicates that a particular condition has occurred <sil=0.929> .PERIOD Initialize flag to just 0 <sil=0.996> .PERIOD In our code what flag is supposed to do is that it will indicate whether a blank line has occurred or not <sil=0.958> .PERIOD So let us first look at the body of the loop without looking at the loop head first <sil=0.905> .PERIOD Let us just look at the body of the loop <sil=0.913> .PERIOD So it is similar to what went before <sil=0.935> .PERIOD Instead of the break statement what I will do is if I realize that an empty line has happened then I will set flag to 1 <sil=0.941> .PERIOD Notice that flag was initially 0 <sil=0.905> .PERIOD So flag equal to 1 will indicate that an empty line has been seen <sil=0.951> .PERIOD Now I will modify the loop as follows <sil=0.952> .PERIOD Remember that the test condition here is just that maximum number of characters has occurred <sil=0.990> .PERIOD Instead I will check for two conditions in the for loop <sil=0.978> .PERIOD I will check that maximum number of characters have not occurred and I will also check that flag is not 1 because flag is 1 means that a new line a blank line has been encountered <sil=0.978> .PERIOD So I will check for both these conditions in the for loop itself <sil=0.908> .PERIOD If either of them is true that is if either of them is false that is if I is greater than or equal to maximum characters or flag equal to 1 then the test condition will become false and you will exit out of the loop <sil=0.945> .PERIOD So here is a standard way to avoid a break and notice that this condition is negated in the for loop because the condition in the for loop is the condition for entering the loop <sil=0.945> .PERIOD So to exit out of the loop you need flag equal to 1 <sil=0.949> .PERIOD So the in summary what I want to say is that if you want to write a code using break you can also write it without using break <sil=0.961> .PERIOD One of the standard ways to do it is by using a flag variable for whatever condition that we want to check <sil=0.922> .PERIOD You can pick either of this style whichever suits you more <sil=0.932> .PERIOD So how do we decide whether to use the break statement or not <sil=0.941> ?QUESTIONMARK Sometimes the use of the break statement can simplify the exit condition and on the other hand it could also make the code a bit harder to read <sil=0.916> .PERIOD What do I mean by harder to read <sil=0.949> ?QUESTIONMARK When I see the for loop in the code on the right hand side it is clear that there are two ways to exit out of the for loop <sil=0.914> .PERIOD One is I greater than or equal to maximum characters the other is flag equal to 1 <sil=0.988> .PERIOD Just by looking at the for loop I can say that here are the two conditions for which the loop will terminate <sil=0.936> .PERIOD I greater than or equal to max caps or flag equal to 1 <sil=0.948> .PERIOD On the other hand if you look at this left hand side code I actually have to look at the body of the code to realize what are the ways of exit exiting out of the loop <sil=0.991> .PERIOD So you have to understand the body of the loop in order to see what are the conditions for the loop to exit <sil=0.972> .PERIOD It is not just I greater than or equal to max caps <sil=0.938> .PERIOD So in that sense the code with break is harder to understand than the code without break <sil=0.965> .PERIOD It is still recommended to use break when you have two or more exit conditions out of a for loop <sil=0.932> .PERIOD So typically programmers do use break and it is just a matter of style whether you will use break or not <sil=0.993> .PERIOD I myself prefer using a break <sil=0.905> .PERIOD One final thing about the break statement when you use break statement initially it is important to notice that break causes and exit immediately out of the loop <sil=0.923> .PERIOD So remember when you have a for loop the normal execution order is you initialize then you test <sil=0.905> .PERIOD So this is step 1 this is step 2 then you execute the body of the loop that step 3 and then you update this is step 4 and then go back to the test condition <sil=0.922> .PERIOD So this is the normal execution order of the loop <sil=0.947> .PERIOD When you encounter a break you exit immediately out of the loop <sil=0.928> .PERIOD In particular when you break you do not go back to the update statement <sil=0.982> .PERIOD So let us examine what this code will do <sil=0.917> .PERIOD You have I equal to 0 <sil=0.368> ,COMMA I less than 10 increment I <sil=0.946> .PERIOD So you start with I equal to 0 <sil=0.441> ,COMMA I modulo 2 will be 0 modulo 2 which is 0 <sil=0.913> .PERIOD So it will say okay fine you need not get into the if condition <sil=0.929> .PERIOD Then I equal to I plus 1 so I equal to 1 <sil=0.498> ,COMMA 1 is less than 10 you enter the for loop 1 modulo 2 is 1 so you will break <sil=0.956> .PERIOD When you break you immediately get out of the loop <sil=0.958> .PERIOD So when you print this then I will be 1 <sil=0.998> .PERIOD In particular I is not 2 which is what will happen if you go back and update I equal to I plus 1 before exiting out of the loop <sil=0.909> .PERIOD So the important thing to notice is that it is not 2 since I equal to I plus 1 is not done when you break <sil=0.938> .PERIOD When you break you get out of the loop immediately without doing the update statement <sil=0.992> .PERIOD So <sil=0.511> ,COMMA we have seen the break statement which is a statement used when you are in the middle of a loop and you encounter a condition and you want to exit the innermost loop <sil=0.948> .PERIOD There will always also be occasions in your program when you are in the middle of a loop and you encounter some condition and then you realize that you do not need to execute this iteration <sil=0.423> ,COMMA you just can go to the next iteration <sil=0.922> .PERIOD So <sil=0.494> ,COMMA skip the current iteration <sil=0.942> .PERIOD The break statement was you encounter a condition and you say I am done <sil=0.393> ,COMMA I will exit out of the innermost loop <sil=0.913> .PERIOD Here it is not exiting out of the innermost loop <sil=0.632> ,COMMA it is just skipping the current iteration <sil=0.905> .PERIOD For this we will see the continuous statement and let us motivate this by an example <sil=0.954> .PERIOD So <sil=0.647> ,COMMA continue the statement causes the next iteration of the closest and closing for while or do while loop <sil=0.940> .PERIOD Let us motivate it with a very simple example <sil=0.986> .PERIOD Let us say that we are reading numbers coming in a stream and what we have to do is to skip the negative numbers <sil=0.976> .PERIOD So <sil=0.483> ,COMMA you have to read all the positive numbers and reading should be finally over when you encounter some input which is not a number <sil=0.930> .PERIOD How do we do this <sil=0.943> ?QUESTIONMARK Let us imagine that you have the main and things like that written and the central part of the code can be analyzed as follows <sil=0.990> .PERIOD So <sil=0.643> ,COMMA you have integer variable A and let us examine the code in closer detail <sil=0.999> .PERIOD So <sil=0.372> ,COMMA what we need to do is we may have an input sequence that looks like this 1 minus 1 <sil=0.304> ,COMMA 2 and then dot <sil=0.919> .PERIOD So <sil=0.302> ,COMMA let us say that the input sequence is something like this <sil=0.920> .PERIOD What we will do is we will do the scanf operation to get the numbers <sil=0.938> .PERIOD Scanf operation will read the first entry as 1 <sil=0.647> ,COMMA it will read the second entry as 1 <sil=0.615> ,COMMA the third and as minus 1 and the third entry as 2 and so on <sil=0.986> .PERIOD So <sil=0.564> ,COMMA that is what scanf percentage D address of A <sil=0.968> .PERIOD We are already familiar with this <sil=0.936> .PERIOD But what does equal to 1 mean <sil=0.927> ?QUESTIONMARK So <sil=0.606> ,COMMA this is something that we have not encountered so far <sil=0.948> .PERIOD The scanf statement has a return value <sil=0.917> .PERIOD It gives you the number of inputs that was successfully read <sil=0.941> .PERIOD For example <sil=0.394> ,COMMA we are trying to read an integer in the percentage D specifier <sil=0.980> .PERIOD So <sil=0.635> ,COMMA when we try to read the first entry it should succeed <sil=0.923> .PERIOD So <sil=0.643> ,COMMA this will succeed <sil=0.937> .PERIOD When you try to read the second entry it should succeed <sil=0.913> .PERIOD When you try to read the third entry it should succeed <sil=0.978> .PERIOD In all these the scanf percentage D will return a 1 because 1 entry has been read correctly <sil=0.991> .PERIOD Here it will fail because it tries to read a natural number here <sil=0.915> .PERIOD But what it sees is a dot <sil=0.503> ,COMMA a full stop character <sil=0.986> .PERIOD Now <sil=0.608> ,COMMA that is not a number <sil=0.911> .PERIOD So <sil=0.456> ,COMMA scanf percentage D will simply fail <sil=0.929> .PERIOD So <sil=0.570> ,COMMA this is what I said <sil=0.987> .PERIOD It returns the number of conversions that have been successfully made <sil=0.992> .PERIOD So <sil=0.315> ,COMMA when you try to read an input like 1 minus 1 <sil=0.339> ,COMMA 2 dot it will succeed in the first three scanf's and the last scanf it will fail <sil=0.957> .PERIOD So <sil=0.601> ,COMMA that is what the scanf is supposed to do <sil=0.911> .PERIOD So <sil=0.593> ,COMMA as long as you have read a number <sil=0.963> .PERIOD So <sil=0.434> ,COMMA while you have read a number you examine whether it is a positive number <sil=0.977> .PERIOD If it is a negative number that is if a is less than 0 then you say continue which is saying that I do not need to execute the remaining part of the loop <sil=0.994> .PERIOD So <sil=0.370> ,COMMA this part of the loop will be skipped if a is less than 0 <sil=0.952> .PERIOD Continue means go from here and start executing the next iteration of the loop <sil=0.971> .PERIOD Let us go ahead and complete the code <sil=0.908> .PERIOD So <sil=0.329> ,COMMA let us modify the problem a little bit <sil=0.978> .PERIOD Read the integers until a non digit is found and let us do something with the positive integers <sil=0.985> .PERIOD Let us say that we have to find the largest of the positive integers <sil=0.913> .PERIOD So <sil=0.350> ,COMMA what should we do <sil=0.913> ?QUESTIONMARK Again <sil=0.497> ,COMMA let us try to do it by hand to get a feel for what I should be doing <sil=0.988> .PERIOD So <sil=0.482> ,COMMA I have 1 minus 1 <sil=0.602> ,COMMA 2 dot <sil=0.922> .PERIOD Let us say that I initialize the maximum to some reasonable value <sil=0.930> .PERIOD Since we are looking at the largest of the positive integers <sil=0.397> ,COMMA I can initialize maximum to 0 <sil=0.982> .PERIOD Then <sil=0.301> ,COMMA I look at the first one the maximum red so far <sil=0.965> .PERIOD So <sil=0.435> ,COMMA it is a positive entry <sil=0.928> .PERIOD So <sil=0.562> ,COMMA I will update max equal to 1 <sil=0.903> .PERIOD Then I read the next number and it is a negative number so skip it <sil=0.918> .PERIOD Then I read the third number which is a positive number so I will update the maximum to 2 <sil=0.993> .PERIOD So <sil=0.332> ,COMMA this is the part that we want to focus if it is a negative number skip <sil=0.989> .PERIOD So <sil=0.343> ,COMMA here is the code for doing that while the currently red number is while the currently red input is a number that is why the percentage D succeeded and one entry was correctly read <sil=0.979> .PERIOD So <sil=0.442> ,COMMA if a number was read check whether the number is negative <sil=0.974> .PERIOD If the number is negative continue <sil=0.639> ,COMMA continue means go to the next iteration of the loop <sil=0.927> .PERIOD Do not do what is remaining in the loop <sil=0.998> .PERIOD So <sil=0.650> ,COMMA if the currently red number is non negative <sil=0.388> ,COMMA what you will check whether the current maximum is less than the new number <sil=0.934> .PERIOD If it is less than the new number <sil=0.348> ,COMMA you reset the maximum to the new number <sil=0.984> .PERIOD So <sil=0.317> ,COMMA this is the code that we have written similar to other codes that we have seen <sil=0.986> .PERIOD So <sil=0.537> ,COMMA you update the maximum code <sil=0.333> ,COMMA maximum number and go and read the next number <sil=0.924> .PERIOD If the currently red number is negative <sil=0.601> ,COMMA then we will say continue <sil=0.938> .PERIOD So <sil=0.568> ,COMMA we will not update the maximum <sil=0.936> .PERIOD This is what the continue is supposed to be doing <sil=0.961> .PERIOD Now <sil=0.333> ,COMMA as in break <sil=0.441> ,COMMA you can also write equivalent code without using the continuous statement <sil=0.908> .PERIOD So <sil=0.304> ,COMMA let us try to do that and for doing that all we have to do is make sure that the maximum is updated only if it is a non negative number <sil=0.960> .PERIOD So <sil=0.595> ,COMMA this says if it is a negative number <sil=0.607> ,COMMA do not do the next statement <sil=0.980> .PERIOD This says if it is a non negative number <sil=0.587> ,COMMA then update maximum if necessary <sil=0.953> .PERIOD So <sil=0.537> ,COMMA it can be written with one more level of nested if <sil=0.927> .PERIOD So <sil=0.614> ,COMMA this says that if a is non negative <sil=0.614> ,COMMA then execute the next statement <sil=0.956> .PERIOD Here it says that if a is negative <sil=0.339> ,COMMA then continue which means skip the next statement <sil=0.924> .PERIOD So <sil=0.335> ,COMMA notice that these two conditions are the negations of each other <sil=1.000> .PERIOD The long and short of it is that continue is not really necessary <sil=0.575> ,COMMA but if you have it <sil=0.336> ,COMMA then it is useful and it makes the code clearer in certain occasions <sil=0.974> .PERIOD What happens to continue in a for loop <sil=0.943> ?QUESTIONMARK Notice that for loop has the following form <sil=0.923> .PERIOD You have for <sil=0.564> ,COMMA then there is an initialization expression <sil=0.907> .PERIOD Then there was a test and finally <sil=0.347> ,COMMA there was update <sil=0.962> .PERIOD And then you have the body of the loop <sil=0.532> ,COMMA what happens if you encounter a continue in the middle of the loop <sil=0.864> ?QUESTIONMARK In the case of a while loop <sil=0.321> ,COMMA it is very clear you go to the test expression <sil=0.488> ,COMMA you go to the next iteration <sil=0.942> .PERIOD The only contention is in the case of a for loop <sil=0.506> ,COMMA do you go to the update statement <sil=0.984> ?QUESTIONMARK And the answer is yes <sil=0.539> ,COMMA then you skip the remaining part of the loop <sil=0.960> .PERIOD So <sil=0.448> ,COMMA this is the part in the remaining part of the loop that you will skip <sil=0.973> .PERIOD When you skip that <sil=0.630> ,COMMA you go directly to the update statement <sil=0.909> .PERIOD Notice that when you do the break <sil=0.587> ,COMMA so if the statement was a break <sil=0.550> ,COMMA you break immediately out of the loop without doing the update <sil=0.916> .PERIOD In the case of a continue <sil=0.550> ,COMMA you have to do the update <sil=0.986> .PERIOD And as with the break statement <sil=0.629> ,COMMA the continue statement is also redundant <sil=0.973> .PERIOD You can program without using the continue statement as well <sil=0.969> .PERIOD But it is useful if there is already a few levels of nesting of the if statements inside <sil=0.967> .PERIOD We saw in the previous slide that you could avoid continue statement by using an extra level of nested if statement <sil=0.972> .PERIOD Now <sil=0.452> ,COMMA if you do not want to complicate the code in that way <sil=0.302> ,COMMA you can use a continue statement <sil=0.990> .PERIOD Otherwise <sil=0.312> ,COMMA in other cases <sil=0.597> ,COMMA you may want to exit out of the loop <sil=0.547> ,COMMA in that case <sil=0.511> ,COMMA you can use the break statement <sil=0.912> .PERIOD So <sil=0.551> ,COMMA they are extra feature that the C language <sil=0.992> .PERIOD In this video we will look at a slightly more general way of defining problems through recursion <sil=0.907> .PERIOD For the lack of a better name I will call it just two way recursion <sil=0.998> .PERIOD These are problems which are solved by calling two subinstances <sil=0.911> .PERIOD So <sil=0.350> ,COMMA this is the picture of a family tree and we will see that the call stack for a two way recursive functions looks somewhat similar to a family tree <sil=0.908> .PERIOD Let us revisit a problem that we have seen which is to find the maximum value in an integer array <sil=0.941> .PERIOD We saw that the stack depth in our earlier solution was order n because each problem of size n called one sub problem of size n minus 1 <sil=0.977> .PERIOD Now can we reduce the depth of the stack from something close to n to something smaller than n <sil=0.902> .PERIOD So <sil=0.328> ,COMMA here is an alternate way to look at the problem which can be described in a very simple way <sil=0.977> .PERIOD Instead of looking at the maximum of the first element and then the tail what I can do is take an array of size n and split it roughly into half <sil=0.906> .PERIOD So <sil=0.302> ,COMMA there is a left half and a right half each of size n over 2 <sil=0.979> .PERIOD Now imagine that you have the solution for the greatest element in the first half <sil=0.994> .PERIOD Let us call that x and imagine that you have the greatest element of the right half let us call that y <sil=0.961> .PERIOD Now whichever is greater m x and y is going to be the greatest in the whole array and this is the idea that we are going to implement right now <sil=0.906> .PERIOD So <sil=0.347> ,COMMA divide the array into about 2 equal half the first half is 0 to a n by 2 minus 1 this contains n by 2 elements and the second half is a n by 2 so on up to n minus 1 this the right half <sil=0.936> .PERIOD Now recursively find the maximum element of each half and let us say that you have x which is the maximum in the left half and y which is the maximum in the right half then you just return the larger of x and y that should be the largest element of the array <sil=0.996> .PERIOD While doing this we have to take care of the base cases this is as before for the linear case when n is 1 then the only element in the array is the maximum element <sil=0.912> .PERIOD So <sil=0.511> ,COMMA return a of 0 if n is 0 that is the array is empty you return minus infinity <sil=0.923> .PERIOD So <sil=0.623> ,COMMA let us consider a concrete array a is an integer array with these elements just to remind you the linear version was done as follows if n is 0 you return something like minus infinity a very large negative value <sil=0.946> .PERIOD Now if n is 1 you return a of 0 which is the only element in the array otherwise you have at least 2 elements and earlier what we did was you call the sub problem a plus 1 <sil=0.980> .PERIOD So <sil=0.561> ,COMMA the array which starts with the second element in the array and now the sub problem has n minus 1 elements because you are considering a 0 the first element as a separate thing <sil=0.976> .PERIOD Now what you wanted to return was maximum of whatever was return in the sub problem <sil=0.973> .PERIOD So <sil=0.576> ,COMMA let that be some max well and whichever is greater a 0 and max well that is going to be the greatest element in the array <sil=0.939> .PERIOD Now we saw that the stack depth for this problem was n because a size n problem is being reduced to a size n minus 1 problem <sil=0.998> .PERIOD So <sil=0.323> ,COMMA in each step we are reducing the size of the problem by 1 and increasing the stack depth by 1 <sil=0.914> .PERIOD So <sil=0.466> ,COMMA in total that stack depth would be n because there will be about n calls or n minus 1 calls however you want to count <sil=0.966> .PERIOD Now let us look at the 2 way recursive version <sil=0.921> .PERIOD So <sil=0.533> ,COMMA here is the algorithm that we discussed and let us just code this up <sil=0.931> .PERIOD So <sil=0.303> ,COMMA we will have int max array and then int a which is the array containing n elements and let us say that we have some constant minus infinity we have defined elsewhere in the program <sil=0.906> .PERIOD Later we will see how to do this <sil=0.921> .PERIOD Let us say that if n is equal to 0 you return minus infinity some large number some large negative value and if n is equal to 1 you return the only value in the array <sil=0.947> .PERIOD So <sil=0.509> ,COMMA these are the case cases as before <sil=0.980> .PERIOD The changes here if you have at least 2 elements then you return maximum of the values return by the 2 sub problems what are the 2 sub problems <sil=0.947> .PERIOD The first is the left half of the array which starts from a that is the first location in the array and contains n upon 2 elements <sil=0.919> .PERIOD Then we need to compute the maximum of the right half how do we find the right half <sil=0.986> .PERIOD So <sil=0.338> ,COMMA we need to skip n upon 2 elements which went to the left half to get to the first index in the right half <sil=0.918> .PERIOD So <sil=0.382> ,COMMA we do that by saying a plus n upon 2 if a is the address of the first location of the whole array then a plus n upon 2 is going to be the first address of the first location of the right half and how many elements does the right half contain n upon 2 elements went to the left <sil=0.930> .PERIOD Therefore <sil=0.615> ,COMMA what we are left with is n minus n upon 2 <sil=0.936> .PERIOD So <sil=0.361> ,COMMA notice how we call the left half starting from a and containing n upon 2 elements and the right half which is starting from a plus n upon 2 and containing n minus n upon 2 elements <sil=0.992> .PERIOD Now <sil=0.577> ,COMMA let us examine whether this is better than the previous recursive call where we reduced a problem of size n to a problem of size n upon 2 <sil=0.946> .PERIOD It was called linear recursion because we called one sub problem in order to solve the whole problem <sil=0.905> .PERIOD Here we have we are roughly dividing it into halves and then calling 2 sub problems each of size about n upon 2 <sil=0.900> .PERIOD Now <sil=0.405> ,COMMA surprisingly we will see that there is a huge improvement if you do this and this is one of the most elementary tricks in computer science it is called divide and conquer and here is a very simple example of that <sil=0.985> .PERIOD So <sil=0.525> ,COMMA if you look at the concrete array that we had and we call max array a comma 8 because this contains 8 elements <sil=0.977> .PERIOD Now <sil=0.399> ,COMMA we say that it will recursively call 2 sub problems which is maximum max array a comma 4 <sil=0.948> .PERIOD So <sil=0.414> ,COMMA that will be the first four elements starting from a 0 and then max array a plus 4 comma 4 which are the four elements starting from a 4 which is the fifth element in the array <sil=0.968> .PERIOD Now <sil=0.552> ,COMMA let us just look at the stack <sil=0.924> .PERIOD Now <sil=0.414> ,COMMA notice what I have repeatedly mentioned which is that in order to think about a recursive problem you just think about the formulation of the problem and then what you have to convince yourself is if I solve the sub problems correctly then I will get the correct solution to the problem <sil=0.953> .PERIOD So <sil=0.521> ,COMMA I will divide my work into two sub problems <sil=0.945> .PERIOD So <sil=0.335> ,COMMA both of them will report their results back to me and now what I have to do is to figure out how do I put these two solutions together in order to solve the whole sub problem <sil=0.954> .PERIOD So <sil=0.582> ,COMMA think about it in terms of the design of the algorithm and not about the execution stack <sil=0.607> ,COMMA but we will show why this is a major improvement over the linear recursion version of the same solution by looking at the stack <sil=0.912> .PERIOD So <sil=0.456> ,COMMA let us just look at the stack max array a comma 8 calls max array a comma 4 <sil=0.964> .PERIOD Now <sil=0.593> ,COMMA the way function calls in C works you will go to the second half of this problem which is a plus 4 comma 4 only after max array a comma 4 is completely done <sil=0.967> .PERIOD So <sil=0.314> ,COMMA let us now see how max a comma 4 will execute <sil=0.937> .PERIOD It has two sub problems again and let us look at the first sub problem which is max array a comma 2 that itself has a sub problem max array a comma 1 in order to abbreviate I will just put a dot there <sil=0.367> ,COMMA but that dot is supposed to signify max array <sil=0.909> .PERIOD Now <sil=0.334> ,COMMA once you have solved this suppose this is a base case now it contains only one element <sil=0.915> .PERIOD So <sil=0.617> ,COMMA the only element is the maximum <sil=0.964> .PERIOD So <sil=0.581> ,COMMA it returns that value to max array a comma 2 that is one of the sub problems for max array a comma 2 <sil=0.940> .PERIOD So <sil=0.606> ,COMMA now this max array a comma 2 calls the second sub problem that it has which is max array a plus 1 comma 1 again it is a base case it contains only one element that single element is the greatest element in that <sil=0.988> .PERIOD So <sil=0.611> ,COMMA you have two values now one coming from the left and one coming from the right and you just compare these two values and that will be the greatest value in the first two elements of the array <sil=0.913> .PERIOD So <sil=0.585> ,COMMA once you do this you return and when you return you get the value max array a comma 2 <sil=0.991> .PERIOD So <sil=0.406> ,COMMA suppose all of that happens and then you return to max array a comma 4 at this point this function will call it second component which is max array a plus 2 comma 2 and the recursion continues so as soon as a function returns its stack will be erased I am showing that by dimming out that particular function call and this proceeds <sil=0.976> .PERIOD So <sil=0.540> ,COMMA once this values obtained you can return to max array a plus 2 comma 2 now this function is finished because it has called both its sub problems <sil=0.966> .PERIOD So <sil=0.333> ,COMMA this will return and this problem has return has finished with both its sub problems <sil=0.986> .PERIOD So <sil=0.410> ,COMMA you will after this function is done you eventually unwind all the way back up to the top and now you are ready to call the second sub problem of max array a comma 8 which is max array a plus 4 comma 4 and you do it similarly <sil=0.965> .PERIOD Now <sil=0.590> ,COMMA one thing you can notice here is that at any point the active path what what are active on the stack the functions which have not yet returned are the highlighted entries in the call tree <sil=0.900> .PERIOD So <sil=0.369> ,COMMA for example at the very end the call stack contains four functions before you eventually return and compute the last compute the maximum of the whole array the worst case depth of the stack is 4 and we had 8 elements <sil=0.979> .PERIOD So <sil=0.317> ,COMMA you would think that based on this experience that the depth of the stack is about n over 2 but if you think more carefully about it what happens is that at every sub problem at every level I am dividing the problem by 2 <sil=0.912> .PERIOD So <sil=0.541> ,COMMA the depth of the stack is the maximum length path in this tree and at every step of the tree I am dividing the problem by 2 <sil=0.995> .PERIOD How many times do I have to divide n by 2 in order to reach 1 that will be the depth of the tree equivalently you can think about how many times do I have to double in order to reach n if I start from 1 that is the bottom of way <sil=0.971> .PERIOD So <sil=0.368> ,COMMA if I start from 1 and I double every level how many times do I have to double in order to reach n that is the solution to the equation 2 to the x equal to n <sil=0.979> .PERIOD So <sil=0.306> ,COMMA what I have to find is how many times do I have to double <sil=0.905> .PERIOD So <sil=0.363> ,COMMA how many times do I have to multiply 2 which itself in order to reach n and you will see that the solution is log n to the base 2 <sil=0.922> .PERIOD So <sil=0.643> ,COMMA this is going to be the height of the call graph or the call tree <sil=0.971> .PERIOD So <sil=0.632> ,COMMA the stack depth here is about 1 plus log n that is approximately correct which is a huge improvement over n if you think of n as something like 1024 which is 2 to the 10 we are saying that the stack depth is about 10 <sil=0.954> .PERIOD Notice that in the linear case we would have a stack depth of about 1024 instead we are doing about 10 <sil=0.907> .PERIOD So <sil=0.511> ,COMMA this is a huge improvement in the case of stack depth <sil=0.963> .PERIOD So <sil=0.567> ,COMMA with a very simple idea which is instead of solving once a problem of size n minus 1 what if you split it into 2 halves roughly about size n by 2 you will see that you get a huge improvement in the stack depth <sil=0.909> .PERIOD This is one of the simple ideas that we repeatedly use in computer science <sil=0.901> .PERIOD Now <sil=0.445> ,COMMA there are standard arithmetic functions also which can be defined in terms of the 2 way recursion a very classic example is Paganaji numbers <sil=0.960> .PERIOD So <sil=0.597> ,COMMA for example <sil=0.394> ,COMMA they are defined as f 0 equal to 1 f 1 equal to 1 and for n greater than or equal to 2 they are defined as f n equal to f n minus 1 plus f n minus 2 <sil=0.925> .PERIOD So <sil=0.406> ,COMMA if we code this up it is a very simple function in 5 in 10 if n is 0 or n is 1 you return 1 otherwise you return Paganaji so <sil=0.353> ,COMMA 5 of n minus 2 plus 5 of n minus 1 <sil=0.938> .PERIOD So <sil=0.555> ,COMMA here is a very simple arithmetic sequence which is defined in terms of a 2 way recursion <sil=0.974> .PERIOD So <sil=0.549> ,COMMA this is a very simple way to write it <sil=0.456> ,COMMA but it is a very inefficient way to do it <sil=0.963> .PERIOD So <sil=0.519> ,COMMA we will see why it is inefficient in a moment <sil=0.911> .PERIOD If you just think of how you trace the function in the case of a letter of a concrete Fibranaji number let us say we want to calculate the fifth Fibranaji number <sil=0.963> .PERIOD Now <sil=0.643> ,COMMA that depends on 5 4 and 5 3 <sil=0.490> ,COMMA 5 4 depends on 5 3 and 5 2 <sil=0.358> ,COMMA 5 3 depends on 5 2 and 5 1 and so on <sil=0.918> .PERIOD So <sil=0.513> ,COMMA this is the call graph that you will have the call tree that you will have if you consider the calculation of Fibranaji 5 <sil=0.981> .PERIOD Now <sil=0.572> ,COMMA what is a problem here you will see that many computations are unnecessarily done multiple times <sil=0.923> .PERIOD So <sil=0.515> ,COMMA if you look at Fibranaji 2 in the call graph it is evaluated multiple times <sil=0.933> .PERIOD So <sil=0.514> ,COMMA Fibranaji 2 is evaluated when Fibranaji 3 is called it is also called when Fibranaji 4 is called and Fibranaji 3 is called in a different context when you want to calculate Fibranaji 5 even there Fibranaji 2 is called <sil=0.992> .PERIOD So <sil=0.601> ,COMMA you will see that Fibranaji 3 is called 2 times Fibranaji 2 is called 3 times and Fibranaji 5 1 is called 5 times and so on <sil=0.988> .PERIOD So <sil=0.619> ,COMMA we are necessarily repeating the work and there are tricks in computer science to alleviate to remove this kind of unnecessary work <sil=0.412> ,COMMA but that is strictly it is not an idea that strictly falls into the concept of recursion and it is slightly outside the scope of this course <sil=0.968> .PERIOD So <sil=0.635> ,COMMA we will not cover this in this course <sil=0.594> ,COMMA but I just want to point out that even though it is natural to consider this arithmetic sequence in terms of 2 way recursion it may not be the most efficient way to do it <sil=0.963> .PERIOD 