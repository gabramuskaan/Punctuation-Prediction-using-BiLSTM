So far we have seen comparison operators like less than equal to less than or equal to and so on <sil=0.969> .PERIOD We will see a bunch of few more operators in this session <sil=0.942> .PERIOD So let us consider the modulo operator which we have already seen when we discussed Euclidean Gcv <sil=0.944> .PERIOD So a percentage B gives the remainder when A is divided by B <sil=0.911> .PERIOD So suppose we have the following problem we get a number A and we want to check whether the given number is divisible by 6 <sil=1.000> .PERIOD If it is divisible by 6 <sil=0.404> ,COMMA A modulo 6 will be 0 <sil=0.418> ,COMMA the remainder will be 0 <sil=0.985> .PERIOD So we will write a simple code <sil=0.999> .PERIOD You have INTA <sil=0.563> ,COMMA ASF type int <sil=0.646> ,COMMA then scan the number using scanF percentage D and A and then you test whether A is divisible by 6 <sil=0.956> .PERIOD To test whether A is divisible by 6 <sil=0.524> ,COMMA you check whether A mod 6 is 0 <sil=0.918> .PERIOD If it is divisible <sil=0.485> ,COMMA you say that input is divisible by 6 <sil=0.431> ,COMMA plus NHD A <sil=0.931> .PERIOD Otherwise else print if the input is not divisible by 6 <sil=0.958> .PERIOD Very simple operation <sil=0.952> .PERIOD Now let us make it slightly more elaborate <sil=0.982> .PERIOD Suppose you have to test whether this is a slight variant <sil=0.416> ,COMMA suppose you have to test whether a given number is divisible by 6 and by 4 to numbers <sil=0.960> .PERIOD How do you do this <sil=0.983> ?QUESTIONMARK So you scanF the number and you test whether A is divisible by 6 <sil=0.910> .PERIOD So A modulo 6 is 0 <sil=0.902> .PERIOD If that is true <sil=0.539> ,COMMA then you also check whether A modulo 4 is 0 <sil=0.961> .PERIOD If both are true <sil=0.491> ,COMMA then you print that the given number is divisible by 6 and 4 <sil=0.942> .PERIOD So percentage D is divisible by 6 and 4 <sil=0.369> ,COMMA A <sil=0.959> .PERIOD So you can argue about this program and see that if it is divisible by 6 but not by 4 <sil=0.447> ,COMMA then it will enter the first if but not enter the second if <sil=0.951> .PERIOD Therefore it will not print that it is divisible by 6 and 4 <sil=0.966> .PERIOD Similarly <sil=0.649> ,COMMA if it is not even divisible by 6 <sil=0.494> ,COMMA it will not even enter the first if condition <sil=0.904> .PERIOD So you will in any case not print that it is divisible <sil=0.914> .PERIOD So convince yourself that this particular code will print a number is divisible by 6 and 4 <sil=0.613> ,COMMA if and only if the given number is divisible by both 6 and 4 <sil=0.993> .PERIOD Now that piece of code was slightly long <sil=0.358> ,COMMA is there any way to write the same code with a fewer number of lines <sil=0.945> .PERIOD And for this C provides what are known as logical operators <sil=0.976> .PERIOD Now there are 3 logical operators in Boolean or logic which are Boolean and Boolean or and Boolean not <sil=0.972> .PERIOD So there are 3 logical operations and or and not and C provides all of them <sil=0.986> .PERIOD So the same if condition that we wrote before <sil=0.370> ,COMMA you could have easily said if it is divisible by 6 and if it is divisible by 4 <sil=0.587> ,COMMA then print the output <sil=0.972> .PERIOD So for this C provides an operator which is the Boolean and operation <sil=0.982> .PERIOD So the Boolean and operation in C is given by 2 ANS <sil=0.911> .PERIOD So by now you should be familiar with the fact that certain operations in C have repeated characters <sil=0.936> .PERIOD For example <sil=0.482> ,COMMA we already have seen the equality operation which was equal equal <sil=0.901> .PERIOD Similarly the Boolean operation and it is actually the AND symbol on the keyboard but you have to have 2 of them that represents the logical AND <sil=0.931> .PERIOD So this expression says if a a modulo 6 is 0 <sil=0.428> ,COMMA so this expression is what test for a is a multiple of 6 and this is the expression which test whether a is a multiple of 4 <sil=0.957> .PERIOD So if both conditions are true then you say that the given number is divisible by 6 and by 4 <sil=0.924> .PERIOD So consecutive amperesent signs <sil=0.947> .PERIOD So consecutive amperesent signs that is the AND symbols without any blanks in between is the C operator corresponding to the mathematical and the logical AND function <sil=0.978> .PERIOD So it takes 2 values as input and returns as 0 if any of the values is 0 <sil=0.392> ,COMMA if both values are 1 then it returns a 1 <sil=0.924> .PERIOD So this is the same as the logical AND if either of them is 0 then the result is 0 if both of them are 1 then the result is 1 <sil=0.988> .PERIOD So the truth table for the operation and is as follows if a is a non-zero value and b is a non-zero value then C considers that the output value is of a and b is 1 <sil=0.907> .PERIOD If a is 0 and b is any value at all the output is 0 and b is not evaluated <sil=0.921> .PERIOD So this is the same as the logical AND the only thing to note is that if in evaluating a and b you already know that a is 0 then you know the result is 0 <sil=0.947> .PERIOD So C will not bother to evaluate b because it knows that the result is already 0 <sil=0.952> .PERIOD Every expression has a type A and B is of type int regardless of the value of <sil=0.445> ,COMMA regardless of the types of A and B <sil=0.924> .PERIOD This is because A and B is a logical assertion the type of a logical assertion is that it is either true or false <sil=0.910> .PERIOD It corresponds to a Boolean value therefore the type of an A and B regardless of what A and B are the result is always 0 or 1 so it is of type int <sil=0.903> .PERIOD Now you can print the result as an int you can say print of percentage D A and N B <sil=0.982> .PERIOD Now there are 3 logical operations as I mentioned so there is also OR in C it is denoted by 2 vertical bars which are there on your keyboard <sil=0.971> .PERIOD So A or B <sil=0.312> ,COMMA which is A bar bar B evaluates to non-zero if either A is non-zero or B is non-zero <sil=0.915> .PERIOD If both of them are 0 then the result is 0 <sil=0.978> .PERIOD So this is the meaning of a logical OR operation if both of them are false then A or B is false if at least one of them is true then A or B is true <sil=0.981> .PERIOD So you can write the truth table for that if N B are 0 then the output is 0 if A is non-zero and B is any value then you already know that the output of A or B is 1 so the output is 1 and B will not be evaluated <sil=0.939> .PERIOD This is similar to in the case of AND if A was 0 and B was any other value then you know that the output of AND is 0 therefore B will not be evaluated <sil=0.909> .PERIOD Similarly here if A is non-zero then you know the value is 1 so B will not be evaluated and as before A or B is of type int <sil=0.913> .PERIOD So the third logical operation is not <sil=0.912> .PERIOD Now not in C is denoted as the exclamation mark <sil=0.939> .PERIOD So let us see an example of that <sil=0.929> .PERIOD So not is the logical complement and it takes only one argument this is different from the previous two that we have seen A or B and A and B both took two arguments each not takes only one argument so it is called a unary operator <sil=0.967> .PERIOD So not of A is an expression of type integer and the value is the negation of A <sil=0.997> .PERIOD So if A is 0 not of A will be 1 and if A is not 0 then not of A will be 0 <sil=0.971> .PERIOD So for example if I want to say that A is not divisible by 3 I will just write not of A mod 3 equal to 0 <sil=0.929> .PERIOD You know that A mod 3 equal to 0 test for A being divisible by 3 so negation of that it will say that the given number is not divisible by 3 <sil=0.919> .PERIOD Let us finish this by slightly complicated example which is that of leap years <sil=0.984> .PERIOD So I am given a particular year number and I want to say whether the given number is a corresponds to a leap year or not <sil=0.924> .PERIOD Now what is a leap year it is that you add a few years will have February 29th in February all other years will have 28 days in February <sil=0.973> .PERIOD So what is the logic of a leap so roughly an average solar year is 365 <sil=0.960> .PERIOD 242375 rotations <sil=0.999> .PERIOD So in particular it is not an integer so we normally say that a year has 365 days that is not quite true it is a rounding <sil=0.968> .PERIOD So how much are we losing <sil=0.947> ?QUESTIONMARK So you can calculate it as follows the remaining number after the decimal point is roughly 0 <sil=0.989> .PERIOD 25 <sil=0.935> .PERIOD So at a rough cut let us say that every 4 years because of this 0 <sil=0.936> .PERIOD 25 you will lose 1 day <sil=0.926> .PERIOD So every year you are losing about a quarter of a day so every 4 years you will add a day <sil=0.969> .PERIOD Now when you do that you go back to so just a minute <sil=0.948> .PERIOD So you have 365 point let us say 2 <sil=0.981> .PERIOD 5 <sil=0.939> .PERIOD So every 4 years you would lose 4 years you lose about a day <sil=0.989> .PERIOD So you have to do this approximately 1 day <sil=0.966> .PERIOD So in order to compensate for that you add 1 day every 4 years <sil=0.978> .PERIOD So in 100 years you would have added 1 day <sil=0.958> .PERIOD So in 100 years you would have added 1 day 25 days <sil=0.921> .PERIOD But that is 1 day too much because remember that this number is only 365 <sil=0.910> .PERIOD 24 something <sil=0.913> .PERIOD So in 100 days you should have added only 24 days but now you added 25 days <sil=0.982> .PERIOD So to compensate for that every 100 years <sil=0.948> .PERIOD So every 100 years you would have to do this <sil=0.914> .PERIOD So in 100 years skip adding the extra day <sil=0.968> .PERIOD So every 4 years you add 1 extra day but every 100 years you do not add that extra day because you skip it because you would have added 1 more day <sil=0.924> .PERIOD And then again you can look at what remains <sil=0.952> .PERIOD What remains is also roughly 0 <sil=0.930> .PERIOD 24 which means that every 400 years if you do this adjustment you are losing about a day because every 100 years you are losing about quarter of a day from this 0 <sil=0.954> .PERIOD 2375 part <sil=0.935> .PERIOD So you do the same logic again every 400 years <sil=0.902> .PERIOD So every 400 years add an extra day <sil=0.959> .PERIOD So this is the logic of the leap year that we all know <sil=0.923> .PERIOD So how do we decide whether a year will be a leap year <sil=0.907> .PERIOD So the logic that I have outlined just now says that if a year is a multiple of 4 then it is a leap year but if a year is a multiple of 100 as well then it is not a leap year but if it is a multiple of 400 then it is a leap year <sil=0.993> .PERIOD So here is a pretty complicated expression <sil=0.904> .PERIOD So every 4th year is a leap year but skip every 100 year unless it is also a 400 year <sil=0.970> .PERIOD And you can write this expression in C <sil=0.960> .PERIOD It is slightly complicated as you can imagine <sil=0.951> .PERIOD So if the first line the first expression says that year is a multiple of 4 <sil=0.921> .PERIOD So if year is divisible by 4 also the following should be true <sil=0.948> .PERIOD It should not be a multiple of 100 unless it is a multiple of 400 <sil=0.945> .PERIOD So it should not be divisible by 100 that should be true or it should be true that it should be a multiple of 400 <sil=0.948> .PERIOD For example <sil=0.589> ,COMMA if you have 400 then it is a leap year <sil=0.912> .PERIOD So what will happen is that year model of 400 model of 400 is 0 then what happens is that you have 400 model of 100 that is 0 <sil=0.903> .PERIOD So this is equal to 0 that is 1 not of 1 is 0 <sil=0.906> .PERIOD So this part is entirely 0 but it is divisible by 400 <sil=0.991> .PERIOD 400 divided by 400 is 0 therefore this part is true this or 0 or 1 is true therefore the whole expression becomes 1 and 1 <sil=0.900> .PERIOD So it is true <sil=0.945> .PERIOD So this logical expression slightly complicated logical expression encodes the logic for saying that the given year is a leap year <sil=0.917> .PERIOD So try this out yourself this is a slightly tricky expression and convince yourself that this exactly encodes the logic of a leap year <sil=0.907> .PERIOD In this lecture <sil=0.586> ,COMMA let us look at one particular part of the CE compiler which is very important namely the pre processor <sil=0.976> .PERIOD Technically speaking <sil=0.607> ,COMMA the pre processor is the step before compilation <sil=0.994> .PERIOD So <sil=0.378> ,COMMA let us understand this in detail <sil=0.965> .PERIOD We have used statements such as hash include within angular brackets <sil=0.622> ,COMMA stda or dot h also hash include within codes list dot h and you may have seen C code which looks like this <sil=0.977> .PERIOD You say hash defined pi to be 3 <sil=0.992> .PERIOD 1416 hash defined max to be 9999 something like this <sil=0.998> .PERIOD So <sil=0.649> ,COMMA lines in a C program that start with a hash symbol are called macros and they are viewed and they are processed by the C pre processor <sil=0.952> .PERIOD Now <sil=0.482> ,COMMA the C pre processor implements what is known as a macro language part of C and it is used to transform C programs before they are compiled <sil=1.000> .PERIOD So <sil=0.312> ,COMMA C pre processor is the step just before compilation <sil=0.991> .PERIOD We do not explicitly call the C pre processor <sil=0.496> ,COMMA but when you write GCC some file name GCC the first step is the pre processor step <sil=0.983> .PERIOD So <sil=0.353> ,COMMA as part of the compilation first the C pre processor runs and then transforms the macros <sil=0.946> .PERIOD The resulting file including the transform macros is compiled by the C compiler <sil=0.901> .PERIOD So <sil=0.320> ,COMMA let us look at header files <sil=0.974> .PERIOD A header file is a file containing C declarations macro definitions etcetera to be shared between several source files <sil=0.993> .PERIOD Head of files are included in your program using C pre processor directives hash include <sil=0.979> .PERIOD For example <sil=0.584> ,COMMA we have seen include within angular brackets stda or dot h and within codes list dot h <sil=0.977> .PERIOD So <sil=0.439> ,COMMA header files serve two purposes that we have seen <sil=0.989> .PERIOD First is that it could be a system header files this declares interfaces to part of the operating system including system calls C libraries and so on or you could have your own header files which you have written to contain declarations of your code of the functions in your code <sil=0.974> .PERIOD Now <sil=0.600> ,COMMA what does what happens exactly when you include a header file in a C file including a header file produces the same results as copying the header file into each source file <sil=0.980> .PERIOD So <sil=0.307> ,COMMA when you say include stda or dot h it is essentially taking the contents of the stda or dot h file and copy pasting into your source code <sil=0.972> .PERIOD So <sil=0.457> ,COMMA this happens at exactly the place where the corresponding hash include command was written <sil=0.949> .PERIOD The advantages of having this header file and hash include is that related declarations appear only in one place and if you want to change the if you want to change a particular function on a declaration of a function you just have to change it in a single file and all files which include that header file will automatically see the change <sil=0.906> .PERIOD So <sil=0.363> ,COMMA here is something that we have mentioned in the previous video if the difference between angular bracket and the double codes <sil=0.905> .PERIOD So <sil=0.445> ,COMMA the angular bracket is usually used in system header files and it searches for the file named let us say stda or dot h in a standard list of system directories <sil=0.971> .PERIOD If you say within double codes on the other hand like list dot h it searches for this list dot h first in the current directory if it is not found in the current directory then it goes again into the standard list of directories <sil=0.971> .PERIOD Now <sil=0.305> ,COMMA the argument for hash include whether you include it in a angular bracket or in a double code behaves like a string constant and it is literally put there <sil=0.952> .PERIOD So <sil=0.551> ,COMMA if you have like commands the commands are not recognized as commands if you have a star symbol for example <sil=0.626> ,COMMA it will be just put exactly like a star symbol <sil=0.973> .PERIOD So <sil=0.382> ,COMMA it is just treated as a string constant and no interpretation is done there <sil=0.907> .PERIOD Now <sil=0.343> ,COMMA let us look at very special case that could happen in the header file typically you would not do this <sil=0.923> .PERIOD So <sil=0.530> ,COMMA suppose you have within header dot h you have a text character star error equal to overflow typically you do not initialize variables in a header file but let us say that in a particular header dot h we have this character star error equal to overflow <sil=1.000> .PERIOD Now <sil=0.374> ,COMMA in p dot c I write this very peculiar thing I write in x and then in the middle of the code I say hash include header dot h till now we have always used hash include headers in the beginning of the file <sil=0.938> .PERIOD But <sil=0.402> ,COMMA suppose what happens if I do it in the middle <sil=0.900> .PERIOD Now <sil=0.486> ,COMMA after the c pre-processor processes the file what happens is that in whatever text is there in header dot h is copy pasted at that position <sil=0.932> .PERIOD So <sil=0.428> ,COMMA for example <sil=0.575> ,COMMA this code will be transformed by the c pre-processor to look like this it will say in text and the header dot h contain the single line character star error equal to overflow <sil=1.000> .PERIOD So <sil=0.317> ,COMMA that text will come here <sil=1.000> .PERIOD Now <sil=0.594> ,COMMA this transform text is what the c pre c compiler sees and it will compile and produce the object code or the execute <sil=0.993> .PERIOD So <sil=0.434> ,COMMA included files are not limited to declarations and macro definitions these are merely the typical users you can put any text there and when you include that header file the text will be copy pasted into the position <sil=0.934> .PERIOD Typically though you would want to avoid this you would want only declarations in header file <sil=0.915> .PERIOD Now <sil=0.524> ,COMMA let us look at some other features that the c pre-processor gives we have seen in some code this use of hash define <sil=0.969> .PERIOD So <sil=0.400> ,COMMA hash define is used for what are known as object like macros <sil=0.909> .PERIOD Now <sil=0.371> ,COMMA an object like macro is basically an identifier and it will be replaced by some code text <sil=0.937> .PERIOD It is called object like because it looks like an object <sil=0.959> .PERIOD So <sil=0.610> ,COMMA it is most common use is to give symbolic names to numeric constants <sil=0.941> .PERIOD Suppose you want to write a program in which the maximum array size is let us say 1024 instead of putting 1024 in several places <sil=0.916> .PERIOD A typical usage in a program would be to say hash define buff size <sil=0.914> .PERIOD So <sil=0.359> ,COMMA buffer size to be 1024 <sil=0.947> .PERIOD So <sil=0.517> ,COMMA you have used hash define to define this identify buff size and buff size will have will be assigned the text 1024 <sil=0.977> .PERIOD So <sil=0.535> ,COMMA this says that I am defining a macro named be buff size and it is an abbreviation a short form for the token 1024 <sil=0.934> .PERIOD Now <sil=0.481> ,COMMA if somewhere in your code if you say hash define buff size 1024 in all places after that the suppose you say like character star string equal to malloc or calloc buff size size of character <sil=0.951> .PERIOD What the pre-processor will do will will be that it will look at this string constant <sil=0.991> .PERIOD It is the name of a macro and it will replace it with 1024 which is the value of the macro <sil=0.936> .PERIOD So <sil=0.582> ,COMMA the transform text will look like this character star string equal to malloc or calloc 1024 size of care <sil=0.944> .PERIOD Now <sil=0.332> ,COMMA by convention macro names are written in upper case <sil=0.938> .PERIOD So <sil=0.624> ,COMMA that somebody who reads the code will be aware that this could be a macro because if I write it in lower case there are chances that somebody might think that it is a variable name and look for the variable <sil=0.956> .PERIOD So <sil=0.327> ,COMMA writing it in capital letters is a way of indicating to the user that this is actually a macro <sil=0.947> .PERIOD So <sil=0.446> ,COMMA please look it in a header file for example <sil=0.945> .PERIOD So <sil=0.306> ,COMMA the C pre-processor can through a program sequentially this is an important thing to understand and macro definitions take effect at the place you write them <sil=0.904> .PERIOD So <sil=0.346> ,COMMA let us look at a very specific example to illustrate this point <sil=0.916> .PERIOD So <sil=0.453> ,COMMA suppose you write Foo equal to capital X after that you have a line saying hash define X 4 and then bar equal to X <sil=1.000> .PERIOD What will the C pre-processor do <sil=0.964> ?QUESTIONMARK It will look through the file and say Foo equal to X fine it does not know what X is it will not transform that line <sil=0.931> .PERIOD Then it sees the hash define X 4 now it knows that X is a macro and it has the value 4 and then it says bar equal to X but now X is a macro the pre-processor knows about this <sil=0.971> .PERIOD So <sil=0.636> ,COMMA it will replace X with 4 <sil=0.903> .PERIOD So <sil=0.583> ,COMMA the transform text will be Foo equal to X bar equal to 4 it is natural to imagine that I would have Foo equal to 4 but that is not what happens because the way the source code was written the hash defined happened after Foo equal to X <sil=0.969> .PERIOD So <sil=0.387> ,COMMA anything that happens before the macro was defined is not changed <sil=0.937> .PERIOD Now <sil=0.437> ,COMMA let us conclude this discussion of pre-processor with a very typical project management problem and we will see third macro that third operation that is done by the C pre-processor <sil=0.965> .PERIOD This is something called hash if and this is used typically when you have multiple projects multiple files in your project and you need to include multiple header files into a single source file <sil=0.955> .PERIOD So <sil=0.339> ,COMMA let us discuss what is the problem with a particular example <sil=0.949> .PERIOD Suppose we have a list <sil=0.937> .PERIOD h and a list <sil=0.990> .PERIOD c <sil=0.968> .PERIOD So <sil=0.303> ,COMMA I have this header file list <sil=0.998> .PERIOD h <sil=0.941> .PERIOD Now <sil=0.384> ,COMMA I have a program p 1 <sil=0.963> .PERIOD c that needs the list functions and also creates a bunch of new functions <sil=0.907> .PERIOD So <sil=0.560> ,COMMA its declarations will be included in p 1 <sil=0.961> .PERIOD h <sil=0.931> .PERIOD Now <sil=0.518> ,COMMA in p 1 <sil=0.948> .PERIOD h I would say include list noth <sil=0.960> .PERIOD So <sil=0.439> ,COMMA this is I will have a corresponding p 1 <sil=0.996> .PERIOD c which will just say include p 1 <sil=0.942> .PERIOD h <sil=0.952> .PERIOD Now <sil=0.495> ,COMMA suppose that I have another file p 2 <sil=0.958> .PERIOD c <sil=0.927> .PERIOD The p 2 <sil=0.902> .PERIOD c needs some functions in list noth and some functions in p 1 <sil=0.925> .PERIOD h <sil=0.997> .PERIOD So <sil=0.439> ,COMMA now there when I write p 2 <sil=0.918> .PERIOD h I will say include p 1 <sil=0.933> .PERIOD h and include list noth <sil=0.931> .PERIOD Now <sil=0.595> ,COMMA what happens is that when we compile p 2 <sil=0.920> .PERIOD c list noth gets included twice first because it directly includes list noth and second because it includes p 1 <sil=0.932> .PERIOD h which itself includes list noth <sil=0.976> .PERIOD So <sil=0.478> ,COMMA list noth code will be copy based at twice in p 2 <sil=0.948> .PERIOD h <sil=0.997> .PERIOD So <sil=0.519> ,COMMA for example <sil=0.522> ,COMMA this is a problem because if list noth contains a structure definition it will be included twice and the compiler will produce an error <sil=0.956> .PERIOD So <sil=0.359> ,COMMA this is a standard problem in large projects where you want to include a file <sil=0.379> ,COMMA but you do not want to include it multiple times <sil=0.924> .PERIOD So <sil=0.378> ,COMMA in this particular example I want to include list noth <sil=0.595> ,COMMA but I want to avoid the possibility that list noth is included multiple times leading to compiler errors <sil=0.905> .PERIOD So <sil=0.521> ,COMMA how do we solve this <sil=0.860> ?QUESTIONMARK So <sil=0.530> ,COMMA this is a facility provided by the C pre-processor <sil=0.955> .PERIOD You can say you can use this hash if n if <sil=0.948> .PERIOD So <sil=0.557> ,COMMA it is saying that if this macro is not defined then do something <sil=0.923> .PERIOD So <sil=0.354> ,COMMA in list noth I will write the following <sil=0.522> ,COMMA hash if and if this is a macro that I will define <sil=0.989> .PERIOD So <sil=0.649> ,COMMA usually if a file is list noth <sil=0.442> ,COMMA the macro will be named in capital letters list under storage <sil=0.924> .PERIOD If this macro is not defined then hash define list noth <sil=0.931> .PERIOD So <sil=0.495> ,COMMA this says define list noth for me and then all the remaining statements in list noth and then it will be enclosed in an n if <sil=0.984> .PERIOD So <sil=0.353> ,COMMA now what happens is that suppose list noth is included for the first time in p 1 noth then list noth is not defined <sil=0.915> .PERIOD So <sil=0.464> ,COMMA it will define list noth and then include list noth in p 1 noth <sil=0.962> .PERIOD Now p 2 noth includes p 1 noth and list noth <sil=0.910> .PERIOD So <sil=0.486> ,COMMA now when list noth is included for the second time the C pre-processor will look at this statement if and if list noth list under storage that has been defined because p 2 p 1 noth has already defined it <sil=0.400> ,COMMA cost it to be defined <sil=0.903> .PERIOD So <sil=0.591> ,COMMA it says that list noth is defined <sil=0.957> .PERIOD So <sil=0.558> ,COMMA I will skip the entire thing until n if <sil=0.921> .PERIOD So <sil=0.384> ,COMMA this is one way to say that <sil=0.924> .PERIOD So <sil=0.407> ,COMMA if list list underscore h macro is not defined as yet then define it and process all statements until the matching n if it is already defined this happens when you are trying to include it for the second time then all statements until the n if are skipped <sil=0.942> .PERIOD So <sil=0.423> ,COMMA you do not copy paste it for the second time <sil=0.999> .PERIOD So <sil=0.607> ,COMMA this is a standard way to avoid including one file multiple times <sil=0.905> .PERIOD So <sil=0.548> ,COMMA the high level picture of the stages in compilation you have retaken <sil=0.929> .PERIOD So <sil=0.636> ,COMMA the high level picture of the stages in compilation you have source files and then it is run through the pre-processor <sil=0.919> .PERIOD It produces the transform files and then after compilation using gcc minus c it produces object files and after the object files are done they are linked to produce the executable files <sil=0.988> .PERIOD So <sil=0.617> ,COMMA when you press gcc some source file internally it first runs the c pre-processor <sil=0.993> .PERIOD Then it runs the compiler and then it runs the linker and gcc provides facilities to stop the compilation at any stage <sil=0.974> .PERIOD So <sil=0.325> ,COMMA for example <sil=0.470> ,COMMA we have seen in the previous video that you can stop the compilation just after the compilation itself by using gcc minus c <sil=0.974> .PERIOD So <sil=0.380> ,COMMA it will produce dot o files and several dot o files can be later linked to produce the a dot o file <sil=0.913> .PERIOD In this lecture <sil=0.301> ,COMMA let us look at one particular part of the CE compiler which is very important namely the pre processor <sil=0.917> .PERIOD Technically speaking <sil=0.477> ,COMMA the pre processor is the step before compilation <sil=0.901> .PERIOD So <sil=0.353> ,COMMA let us understand this in detail <sil=0.956> .PERIOD We have used statements such as hash include within angular brackets <sil=0.628> ,COMMA stda or dot h also hash include within codes list dot h and you may have seen C code which looks like this <sil=0.906> .PERIOD You say hash defined pi to be 3 <sil=0.902> .PERIOD 1416 hash defined max to be 9999 something like this <sil=0.904> .PERIOD So <sil=0.513> ,COMMA lines in a C program that start with a hash symbol are called macros and they are viewed and they are processed by the C pre processor <sil=0.939> .PERIOD Now <sil=0.618> ,COMMA the C pre processor implements what is known as a macro language part of C and it is used to transform C programs before they are compiled <sil=0.936> .PERIOD So <sil=0.306> ,COMMA C pre processor is the step just before compilation <sil=0.911> .PERIOD We do not explicitly call the C pre processor <sil=0.457> ,COMMA but when you write GCC some file name GCC the first step is the pre processor step <sil=0.998> .PERIOD So <sil=0.425> ,COMMA as part of the compilation first the C pre processor runs and then transforms the macros <sil=0.941> .PERIOD The resulting file including the transform macros is compiled by the C compiler <sil=0.973> .PERIOD So <sil=0.604> ,COMMA let us look at header files <sil=0.926> .PERIOD A header file is a file containing C declarations macro definitions etcetera to be shared between several source files <sil=0.907> .PERIOD Head of files are included in your program using C pre processor directives hash include <sil=0.950> .PERIOD For example <sil=0.469> ,COMMA we have seen include within angular brackets stda or dot h and within codes list dot h <sil=0.962> .PERIOD So <sil=0.422> ,COMMA header files serve two purposes that we have seen <sil=0.964> .PERIOD First is that it could be a system header files this declares interfaces to part of the operating system including system calls C libraries and so on or you could have your own header files which you have written to contain declarations of your code of the functions in your code <sil=0.918> .PERIOD Now <sil=0.396> ,COMMA what does what happens exactly when you include a header file in a C file including a header file produces the same results as copying the header file into each source file <sil=0.972> .PERIOD So <sil=0.323> ,COMMA when you say include stda or dot h it is essentially taking the contents of the stda or dot h file and copy pasting into your source code <sil=0.906> .PERIOD So <sil=0.514> ,COMMA this happens at exactly the place where the corresponding hash include command was written <sil=0.962> .PERIOD The advantages of having this header file and hash include is that related declarations appear only in one place and if you want to change the if you want to change a particular function on a declaration of a function you just have to change it in a single file and all files which include that header file will automatically see the change <sil=0.982> .PERIOD So <sil=0.536> ,COMMA here is something that we have mentioned in the previous video if the difference between angular bracket and the double codes <sil=0.903> .PERIOD So <sil=0.607> ,COMMA the angular bracket is usually used in system header files and it searches for the file named let us say stda or dot h in a standard list of system directories <sil=0.975> .PERIOD If you say within double codes on the other hand like list dot h it searches for this list dot h first in the current directory if it is not found in the current directory then it goes again into the standard list of directories <sil=0.943> .PERIOD Now <sil=0.603> ,COMMA the argument for hash include whether you include it in a angular bracket or in a double code behaves like a string constant and it is literally put there <sil=0.941> .PERIOD So <sil=0.412> ,COMMA if you have like commands the commands are not recognized as commands if you have a star symbol for example <sil=0.411> ,COMMA it will be just put exactly like a star symbol <sil=0.931> .PERIOD So <sil=0.497> ,COMMA it is just treated as a string constant and no interpretation is done there <sil=0.906> .PERIOD Now <sil=0.490> ,COMMA let us look at very special case that could happen in the header file typically you would not do this <sil=0.918> .PERIOD So <sil=0.448> ,COMMA suppose you have within header dot h you have a text character star error equal to overflow typically you do not initialize variables in a header file but let us say that in a particular header dot h we have this character star error equal to overflow <sil=0.999> .PERIOD Now <sil=0.596> ,COMMA in p dot c I write this very peculiar thing I write in x and then in the middle of the code I say hash include header dot h till now we have always used hash include headers in the beginning of the file <sil=0.937> .PERIOD But <sil=0.518> ,COMMA suppose what happens if I do it in the middle <sil=0.913> .PERIOD Now <sil=0.480> ,COMMA after the c pre-processor processes the file what happens is that in whatever text is there in header dot h is copy pasted at that position <sil=0.989> .PERIOD So <sil=0.470> ,COMMA for example <sil=0.499> ,COMMA this code will be transformed by the c pre-processor to look like this it will say in text and the header dot h contain the single line character star error equal to overflow <sil=0.940> .PERIOD So <sil=0.371> ,COMMA that text will come here <sil=0.993> .PERIOD Now <sil=0.544> ,COMMA this transform text is what the c pre c compiler sees and it will compile and produce the object code or the execute <sil=0.912> .PERIOD So <sil=0.360> ,COMMA included files are not limited to declarations and macro definitions these are merely the typical users you can put any text there and when you include that header file the text will be copy pasted into the position <sil=0.902> .PERIOD Typically though you would want to avoid this you would want only declarations in header file <sil=0.911> .PERIOD Now <sil=0.408> ,COMMA let us look at some other features that the c pre-processor gives we have seen in some code this use of hash define <sil=0.938> .PERIOD So <sil=0.368> ,COMMA hash define is used for what are known as object like macros <sil=0.900> .PERIOD Now <sil=0.538> ,COMMA an object like macro is basically an identifier and it will be replaced by some code text <sil=0.953> .PERIOD It is called object like because it looks like an object <sil=0.956> .PERIOD So <sil=0.623> ,COMMA it is most common use is to give symbolic names to numeric constants <sil=0.961> .PERIOD Suppose you want to write a program in which the maximum array size is let us say 1024 instead of putting 1024 in several places <sil=0.991> .PERIOD A typical usage in a program would be to say hash define buff size <sil=0.982> .PERIOD So <sil=0.366> ,COMMA buffer size to be 1024 <sil=0.933> .PERIOD So <sil=0.364> ,COMMA you have used hash define to define this identify buff size and buff size will have will be assigned the text 1024 <sil=0.907> .PERIOD So <sil=0.400> ,COMMA this says that I am defining a macro named be buff size and it is an abbreviation a short form for the token 1024 <sil=0.910> .PERIOD Now <sil=0.548> ,COMMA if somewhere in your code if you say hash define buff size 1024 in all places after that the suppose you say like character star string equal to malloc or calloc buff size size of character <sil=0.924> .PERIOD What the pre-processor will do will will be that it will look at this string constant <sil=0.905> .PERIOD It is the name of a macro and it will replace it with 1024 which is the value of the macro <sil=0.913> .PERIOD So <sil=0.571> ,COMMA the transform text will look like this character star string equal to malloc or calloc 1024 size of care <sil=0.962> .PERIOD Now <sil=0.378> ,COMMA by convention macro names are written in upper case <sil=0.999> .PERIOD So <sil=0.566> ,COMMA that somebody who reads the code will be aware that this could be a macro because if I write it in lower case there are chances that somebody might think that it is a variable name and look for the variable <sil=1.000> .PERIOD So <sil=0.470> ,COMMA writing it in capital letters is a way of indicating to the user that this is actually a macro <sil=0.992> .PERIOD So <sil=0.442> ,COMMA please look it in a header file for example <sil=0.982> .PERIOD So <sil=0.520> ,COMMA the C pre-processor can through a program sequentially this is an important thing to understand and macro definitions take effect at the place you write them <sil=0.909> .PERIOD So <sil=0.594> ,COMMA let us look at a very specific example to illustrate this point <sil=0.913> .PERIOD So <sil=0.554> ,COMMA suppose you write Foo equal to capital X after that you have a line saying hash define X 4 and then bar equal to X <sil=0.946> .PERIOD What will the C pre-processor do <sil=0.984> ?QUESTIONMARK It will look through the file and say Foo equal to X fine it does not know what X is it will not transform that line <sil=0.931> .PERIOD Then it sees the hash define X 4 now it knows that X is a macro and it has the value 4 and then it says bar equal to X but now X is a macro the pre-processor knows about this <sil=0.937> .PERIOD So <sil=0.342> ,COMMA it will replace X with 4 <sil=0.908> .PERIOD So <sil=0.515> ,COMMA the transform text will be Foo equal to X bar equal to 4 it is natural to imagine that I would have Foo equal to 4 but that is not what happens because the way the source code was written the hash defined happened after Foo equal to X <sil=0.946> .PERIOD So <sil=0.564> ,COMMA anything that happens before the macro was defined is not changed <sil=0.982> .PERIOD Now <sil=0.504> ,COMMA let us conclude this discussion of pre-processor with a very typical project management problem and we will see third macro that third operation that is done by the C pre-processor <sil=0.990> .PERIOD This is something called hash if and this is used typically when you have multiple projects multiple files in your project and you need to include multiple header files into a single source file <sil=0.957> .PERIOD So <sil=0.623> ,COMMA let us discuss what is the problem with a particular example <sil=0.947> .PERIOD Suppose we have a list <sil=0.987> .PERIOD h and a list <sil=0.961> .PERIOD c <sil=0.984> .PERIOD So <sil=0.434> ,COMMA I have this header file list <sil=0.951> .PERIOD h <sil=0.940> .PERIOD Now <sil=0.626> ,COMMA I have a program p 1 <sil=0.966> .PERIOD c that needs the list functions and also creates a bunch of new functions <sil=0.947> .PERIOD So <sil=0.517> ,COMMA its declarations will be included in p 1 <sil=0.938> .PERIOD h <sil=0.977> .PERIOD Now <sil=0.637> ,COMMA in p 1 <sil=0.911> .PERIOD h I would say include list noth <sil=0.900> .PERIOD So <sil=0.341> ,COMMA this is I will have a corresponding p 1 <sil=0.953> .PERIOD c which will just say include p 1 <sil=0.926> .PERIOD h <sil=0.965> .PERIOD Now <sil=0.474> ,COMMA suppose that I have another file p 2 <sil=0.967> .PERIOD c <sil=0.961> .PERIOD The p 2 <sil=0.985> .PERIOD c needs some functions in list noth and some functions in p 1 <sil=0.993> .PERIOD h <sil=0.937> .PERIOD So <sil=0.307> ,COMMA now there when I write p 2 <sil=0.920> .PERIOD h I will say include p 1 <sil=0.929> .PERIOD h and include list noth <sil=0.964> .PERIOD Now <sil=0.418> ,COMMA what happens is that when we compile p 2 <sil=0.993> .PERIOD c list noth gets included twice first because it directly includes list noth and second because it includes p 1 <sil=0.976> .PERIOD h which itself includes list noth <sil=0.963> .PERIOD So <sil=0.376> ,COMMA list noth code will be copy based at twice in p 2 <sil=0.935> .PERIOD h <sil=0.940> .PERIOD So <sil=0.426> ,COMMA for example <sil=0.402> ,COMMA this is a problem because if list noth contains a structure definition it will be included twice and the compiler will produce an error <sil=0.975> .PERIOD So <sil=0.300> ,COMMA this is a standard problem in large projects where you want to include a file <sil=0.374> ,COMMA but you do not want to include it multiple times <sil=0.948> .PERIOD So <sil=0.594> ,COMMA in this particular example I want to include list noth <sil=0.321> ,COMMA but I want to avoid the possibility that list noth is included multiple times leading to compiler errors <sil=0.913> .PERIOD So <sil=0.377> ,COMMA how do we solve this <sil=0.990> ?QUESTIONMARK So <sil=0.475> ,COMMA this is a facility provided by the C pre-processor <sil=0.934> .PERIOD You can say you can use this hash if n if <sil=0.984> .PERIOD So <sil=0.507> ,COMMA it is saying that if this macro is not defined then do something <sil=0.902> .PERIOD So <sil=0.353> ,COMMA in list noth I will write the following <sil=0.545> ,COMMA hash if and if this is a macro that I will define <sil=0.902> .PERIOD So <sil=0.369> ,COMMA usually if a file is list noth <sil=0.428> ,COMMA the macro will be named in capital letters list under storage <sil=0.948> .PERIOD If this macro is not defined then hash define list noth <sil=0.935> .PERIOD So <sil=0.313> ,COMMA this says define list noth for me and then all the remaining statements in list noth and then it will be enclosed in an n if <sil=0.927> .PERIOD So <sil=0.423> ,COMMA now what happens is that suppose list noth is included for the first time in p 1 noth then list noth is not defined <sil=0.925> .PERIOD So <sil=0.346> ,COMMA it will define list noth and then include list noth in p 1 noth <sil=0.970> .PERIOD Now p 2 noth includes p 1 noth and list noth <sil=0.971> .PERIOD So <sil=0.622> ,COMMA now when list noth is included for the second time the C pre-processor will look at this statement if and if list noth list under storage that has been defined because p 2 p 1 noth has already defined it <sil=0.442> ,COMMA cost it to be defined <sil=0.965> .PERIOD So <sil=0.450> ,COMMA it says that list noth is defined <sil=0.933> .PERIOD So <sil=0.435> ,COMMA I will skip the entire thing until n if <sil=0.981> .PERIOD So <sil=0.448> ,COMMA this is one way to say that <sil=0.991> .PERIOD So <sil=0.422> ,COMMA if list list underscore h macro is not defined as yet then define it and process all statements until the matching n if it is already defined this happens when you are trying to include it for the second time then all statements until the n if are skipped <sil=0.989> .PERIOD So <sil=0.337> ,COMMA you do not copy paste it for the second time <sil=0.984> .PERIOD So <sil=0.461> ,COMMA this is a standard way to avoid including one file multiple times <sil=0.956> .PERIOD So <sil=0.558> ,COMMA the high level picture of the stages in compilation you have retaken <sil=0.917> .PERIOD So <sil=0.601> ,COMMA the high level picture of the stages in compilation you have source files and then it is run through the pre-processor <sil=0.936> .PERIOD It produces the transform files and then after compilation using gcc minus c it produces object files and after the object files are done they are linked to produce the executable files <sil=0.976> .PERIOD So <sil=0.450> ,COMMA when you press gcc some source file internally it first runs the c pre-processor <sil=0.967> .PERIOD Then it runs the compiler and then it runs the linker and gcc provides facilities to stop the compilation at any stage <sil=0.906> .PERIOD So <sil=0.377> ,COMMA for example <sil=0.390> ,COMMA we have seen in the previous video that you can stop the compilation just after the compilation itself by using gcc minus c <sil=0.995> .PERIOD So <sil=0.380> ,COMMA it will produce dot o files and several dot o files can be later linked to produce the a dot o file <sil=0.941> .PERIOD In this video we will look at multidimensional arrays <sil=0.925> .PERIOD In particular let us look at two dimensional arrays because that will give you an idea of how multidimensional arrays work <sil=0.913> .PERIOD Initially let us look at them as arrays and in a subsequent video we will look at the connection between multidimensional arrays and pointers <sil=0.989> .PERIOD So multidimensional arrays can be defined in the similar to the following <sil=0.948> .PERIOD You can say double mat 5 6 or int mat 5 6 or float mat 5 6 <sil=0.922> .PERIOD This is similar to the mathematical notation of multidimensional arrays or matrices <sil=0.987> .PERIOD So let us look at the first example <sil=0.967> .PERIOD We have that the definition states that mat is a 5 by 6 array of double entries <sil=0.966> .PERIOD So this means that mat has 5 rows each row contains 6 entries and all the entries are of type double <sil=0.966> .PERIOD Now double is what is known as double precision floating point numbers and if you are doing a lot of floating point computations then instead of float you could use double because you might need a lot of precision in your computation <sil=0.963> .PERIOD So the matrix 2 D array might look like this <sil=0.965> .PERIOD This looks like a mathematical matrix of size 5 by 6 <sil=0.997> .PERIOD So it has 5 rows <sil=0.615> ,COMMA rows 0 through row 4 and each row has 6 columns <sil=0.304> ,COMMA column 0 through column 5 <sil=0.981> .PERIOD Now the i jth member of matrix is access test mat i j <sil=0.908> .PERIOD This is slightly different from the mathematical notation <sil=0.946> .PERIOD In mathematical notation you will write matrix and then a square bracket and then you will write i comma j followed by close bracket <sil=0.993> .PERIOD So this is different in C you would write the indices separately in their own square brackets <sil=0.937> .PERIOD Now the row and the column numbering begin at 0 <sil=0.952> .PERIOD This is similar to one dimensional arrays <sil=0.978> .PERIOD We saw that one dimensional arrays start with index 0 <sil=0.965> .PERIOD Let us look at a function which prints the input matrix <sil=0.996> .PERIOD So I have a function it returns void so it does not return anything it just performs an action which is to print a matrix <sil=0.992> .PERIOD Now the function is called print matrix it takes a double matrix mat of size 5 by 6 <sil=0.402> ,COMMA 5 rows 6 columns each <sil=0.967> .PERIOD I first declare i and j <sil=0.433> ,COMMA i is supposed to iterate over the rows and j is supposed to iterate over the columns <sil=0.973> .PERIOD Now how do you iterate over the whole matrix <sil=0.931> ?QUESTIONMARK Well first you would take each row i so you need an outer loop for that based on the variable i <sil=0.935> .PERIOD I will go from 0 to 4 so the for loop goes from 0 until you hit 5 <sil=0.926> .PERIOD Now for each row what do we have to do <sil=0.914> ?QUESTIONMARK We have to take the elements in the column <sil=0.933> .PERIOD Now the columns are numbered 0 through 5 <sil=0.944> .PERIOD So for each ith row we have to take column 0 column 1 column 2 column 3 column 4 and column 5 <sil=0.981> .PERIOD So all these entries and then you have to print that entry <sil=0.925> .PERIOD Now we have just mentioned the i jth element in the matrix is access test mat i j i in square bracket and j in square bracket <sil=0.960> .PERIOD Therefore you will see print f percentage f followed by space mat i j <sil=0.915> .PERIOD So this will take the entry in the i th row j th column <sil=0.996> .PERIOD One more thing that is worth noting is that even though you had a double matrix you still print it as percentage f as though you were printing a float and the language will take care of printing the double precision <sil=0.979> .PERIOD So here is the loop to print the columns of a row <sil=0.920> .PERIOD Once you are finished with a row you would print a new line because then you can start at the beginning of the next line for the next row <sil=0.911> .PERIOD So here is the loop <sil=0.979> .PERIOD So what the loop does is prints the i th row row starting from 0 and ending in 4 and for each row print each of the 6 columns 0 through 5 <sil=0.980> .PERIOD Now at the end of each row you would print a new line <sil=0.909> .PERIOD So here is the code to print a matrix <sil=1.000> .PERIOD The lesson here is how to access the i jth element <sil=0.932> .PERIOD You would access it as matrix square bracket j <sil=0.928> .PERIOD Now the dual operation of printing is of course reading in the input from the user we have done it using scan f <sil=0.980> .PERIOD So let us try to use scan f to read in elements which are input by the user <sil=0.908> .PERIOD Now one of the things with scan f is that the argument to which variable we have to read it in <sil=0.908> .PERIOD We usually give and x if you have to read it into a particular variable x then we will say scan f whatever format it is and then say and x which says the address of x <sil=0.929> .PERIOD Similarly I could guess that in order to read to the i jth element of a matrix I would need and math i j and that is actually correct <sil=0.982> .PERIOD You do not need a parenthesis here to write <sil=0.920> .PERIOD So you do not need to write and of math i j with math i j in square bracket <sil=0.906> .PERIOD Because the address operator has lower precedence than the array indexing operator <sil=0.953> .PERIOD So when you see an expression like this the parenthesis will be in such a way that math i j is evaluated first and then the address is taken because it is a lower precedence operator <sil=0.986> .PERIOD So this is similar to one dimensional array that you have already seen <sil=1.000> .PERIOD You would have read it using and of a i <sil=0.962> .PERIOD So we have the two dimensional analog of that <sil=0.912> .PERIOD So let us look at the code and the code looks exactly as the print routine except that we are now scanning a number <sil=0.955> .PERIOD So you have an outer loop which will go through all the rows and then an inner loop which will go through the columns of the ith row and how do you scan <sil=0.976> ?QUESTIONMARK You say scan f percentage f and math i j <sil=0.974> .PERIOD So remember if it was just a double variable instead of an array you would have just said and of the variable name <sil=0.927> .PERIOD Similarly we have and of math i j <sil=0.961> .PERIOD Again note that even though we have a double array you read it in exactly as though it were a floater using percentage f format <sil=0.938> .PERIOD So read in the ith row and the ith row goes from 0 to 4 and for each row read the jth column <sil=0.971> .PERIOD Column goes from 0 to 5 <sil=0.908> .PERIOD Now the way the scan f works the scan f with percentage f option will skip over the white space and it will skip over any white space <sil=0.926> .PERIOD So in effect what it means is that if I had to enter a matrix of size 5 by 6 I can enter it in multiple ways <sil=0.921> .PERIOD I can enter it in the most natural way which is 0 <sil=0.378> ,COMMA 1 <sil=0.354> ,COMMA 2 <sil=0.446> ,COMMA 3 <sil=0.474> ,COMMA 4 <sil=0.576> ,COMMA 5 <sil=0.514> ,COMMA 6 <sil=0.466> ,COMMA 7 <sil=0.508> ,COMMA 8 <sil=0.340> ,COMMA 9 and so on <sil=0.980> .PERIOD So 5 rows each row has is entered in a line and each line has 6 entries <sil=0.984> .PERIOD So let us call this may be 10 and 11 <sil=0.956> .PERIOD So each row has 6 entries and there are 5 rows <sil=0.935> .PERIOD This is the most natural way to enter it but as far as scan f is concerned any white space will be skipped <sil=0.950> .PERIOD So instead I could just enter one number in one line <sil=0.945> .PERIOD So I could enter it line one number per line and it would be read exactly in the same manner <sil=0.949> .PERIOD That is the property of scan f <sil=0.953> .PERIOD So it really does not matter whether the entire input is given in 5 rows of 6 doubles or just 30 doubles each number in a single row by itself <sil=0.979> .PERIOD So that is both of them are fine <sil=0.939> .PERIOD We have seen how to print an array <sil=0.530> ,COMMA we have seen how to read elements into an array <sil=0.957> .PERIOD Now let us see how to initialize a multidimensional array <sil=0.978> .PERIOD So we want to initialize let us say 4 by 3 array in the following way it should be 1 2 3 4 5 6 7 8 9 and 0 1 2 <sil=0.925> .PERIOD Let us say this is the array that I want to enter <sil=0.945> .PERIOD Now we have seen initialization of one dimensional arrays <sil=0.905> .PERIOD If I had let us say int b 3 how did be initialize it we could initialize it as 0 1 2 <sil=0.989> .PERIOD So the summary of this is that if it is a list of numbers separated by commas and the list is enclosed in curly braces <sil=0.916> .PERIOD This is the case for a one dimensional array <sil=0.968> .PERIOD So it is natural to generalize the notation in the following way <sil=0.924> .PERIOD If I have to initialize a 4 by 3 array I can just say curly brace and so here is a list of elements and each element is basically a row <sil=0.975> .PERIOD So what is a number here will be a row <sil=0.972> .PERIOD So it will be a list of rows and each row being somewhat like an array each row will be given by a list <sil=0.975> .PERIOD So the list initialize the array initialization on the right hand side is exactly the array that is shown here <sil=0.966> .PERIOD So it will come out to 1 2 3 4 5 6 7 8 9 0 1 2 <sil=0.937> .PERIOD So the notation is consistent and it is a generalization of the one dimensional array notation <sil=0.974> .PERIOD So there are some initialization rules similar to what we have seen for one dimensional arrays <sil=0.977> .PERIOD Values are given row wise <sil=0.906> .PERIOD The first row this row number 0 is the first entry <sil=0.951> .PERIOD Number of columns needs to be specified we need to know how many columns there are <sil=0.987> .PERIOD Now value of each row is enclosed in double braces <sil=0.626> ,COMMA enclosed in braces curly braces and the number of values in a row may be less than the total number of columns <sil=0.901> .PERIOD This is allowed <sil=0.967> .PERIOD This was similar to how we saw that even though you had declared the size of an array you could give less one dimensional array you could give less than that number of values as the initial values <sil=0.964> .PERIOD The remaining values will just be 0 <sil=0.992> .PERIOD Same case occurs in the multi dimensional array <sil=0.991> .PERIOD So let us watch an example if I have an array a 3 a number of rows unspecified number of columns 3 but each row let us say I have 3 rows each row does not have exactly 3 elements <sil=0.970> .PERIOD One the row 0 has just one element row has only two elements and so on <sil=0.944> .PERIOD It will be initialized as 1 0 0 because in row 0 I have given only one element so that will be the first and the remaining will be 0 <sil=0.988> .PERIOD 2 3 so I am short of one element that will be 0 <sil=0.959> .PERIOD 3 4 5 I have 3 columns and I have given 3 values <sil=0.975> .PERIOD So it will be a initialized as 3 4 5 <sil=0.966> .PERIOD So the list the initialization on the left hand side results in the matrix on the right hand side <sil=0.968> .PERIOD Here is how initialization works <sil=0.935> .PERIOD Now let us look at axis mechanism in somewhat greater detail <sil=0.906> .PERIOD So let us ask the following question <sil=0.944> .PERIOD Instead of matrix 5 by 6 I have written a function to read a matrix of size 5 by 6 <sil=0.920> .PERIOD Can I give a 6 by 5 matrix <sil=0.928> ?QUESTIONMARK So this is a matrix of 5 rows 6 columns each <sil=0.912> .PERIOD Instead can I give a matrix of 6 rows 5 columns each <sil=0.945> .PERIOD The total number of elements is still 30 <sil=0.973> .PERIOD Would it be the same or would it be even a matrix of 10 by 3 10 rows 3 columns each <sil=0.934> .PERIOD All these have 30 elements <sil=0.914> .PERIOD Now as far as C is concerned are all these the same <sil=0.905> .PERIOD The answer is that no it is not correct neither it should be but we will say that the answer depends on the way the array elements are accessed <sil=0.949> .PERIOD So we will see this in greater detail <sil=0.933> .PERIOD So in order to motivate that let us introduce the problem of passing an array to a function and let us look at the issue in greater detail <sil=0.929> .PERIOD Suppose I want to take a true dimensional array of type double 5 by 6 and print the sum of entries in each row <sil=0.980> .PERIOD So this is similar to a matrix program that we have seen much much before <sil=0.919> .PERIOD Given a 2D matrix for each row you have to find the sum of elements in each row and just print it out <sil=0.911> .PERIOD So in mathematics this is often called marginals <sil=0.997> .PERIOD So let us just compute the marginals <sil=0.908> .PERIOD We have a function void marginals it takes a matrix 5 by 6 <sil=0.981> .PERIOD It has int ij i is over the rows j is over the columns and I also have a row some variable to keep track of the sum of a row <sil=0.942> .PERIOD So what do I do I have an outer loop which goes through all the rows <sil=0.904> .PERIOD For each row I initialize the sum to 0 <sil=0.953> .PERIOD Now for each row I have to sum all the elements in the i-th row <sil=0.948> .PERIOD So I have to sum all the elements in the columns j through 6 j 0 through 5 of matrix ij <sil=0.959> .PERIOD So I will go through the elements and add them to the row sum <sil=0.928> .PERIOD Once I am done with the last column of row i I have the row sum for row i and I will print that <sil=0.992> .PERIOD So this print up is happening in the loop for row i <sil=0.907> .PERIOD Now let us look at a slight modification <sil=0.929> .PERIOD We say that instead of printing phi rows I currently have only 3 rows of entries available <sil=0.945> .PERIOD So can you print me the row sum of the first 3 rows instead of all the phi rows <sil=0.931> .PERIOD Now this is very simple <sil=0.925> .PERIOD Let us just modify the function a little bit <sil=0.970> .PERIOD It takes an additional parameter saying how many of the initial rows do you want me to sum <sil=0.966> .PERIOD So that is an additional parameter <sil=0.981> .PERIOD Let us call it n rows <sil=0.901> .PERIOD So here are the number of rows for which I have to take the sum and that function is a very small modification of the sum that we have already seen <sil=0.924> .PERIOD The function that we have already seen the difference is that we now take n rows which is like how many rows do we have to add <sil=0.937> .PERIOD And then for i equal to 0 earlier I would go from i equal to 0 to 5 because the matrix had 5 rows <sil=0.940> .PERIOD But now I will just say I will go up to n rows <sil=0.961> .PERIOD And the logic is the same as before nothing else changes <sil=0.978> .PERIOD So here is the strange thing see completely ignore the number of columns <sil=0.941> .PERIOD As far as the C language is concerned if you have a 2 D array the number of columns is crucial it has to be specified <sil=0.910> .PERIOD But the number of rows is not really important <sil=0.962> .PERIOD So see completely ignore the phi part the number of rows <sil=0.953> .PERIOD Now this means that we could pass less than 5 rows into the same function since we are not checking for example that n rows is less than or equal to 5 <sil=0.982> .PERIOD So let us see an example here is the completely surprising example that this code is the same as before the only difference is highlighted in red that I have now omitted what is the number of rows <sil=0.970> .PERIOD Please relate this back to the codes that we used to write for arrays <sil=0.989> .PERIOD Earlier I said that for an array you do not need to specify the number of elements in the array <sil=0.959> .PERIOD When you write a function taking an array as parameter I could just say int a r r and then empty pair of square brackets with no size in between <sil=0.999> .PERIOD So we have a similar phenomenon for 2 D arrays except you are not allowed to omit both rows and columns <sil=0.912> .PERIOD You have to specify the number of columns but you have the flexibility that you are allowed to omit the number of rows <sil=0.938> .PERIOD So the number of rows is not important you could omit it and just give an empty pair of brackets and the code will work as before <sil=0.948> .PERIOD So this means that the above program actually works for any k cross 6 matrix where k could be the number of rows and this is because c does not care about the number of rows only about the number of columns and y is this asymmetry y is it that it cares about one element but not the number of rows but not the number of columns <sil=0.949> .PERIOD We will see this using the 2 dimensional array addressing <sil=0.981> .PERIOD Let us say that I have written a code for computing marginals and it takes these parameters double match empty pair <sil=0.967> .PERIOD So the number of rows is unspecified the number of columns is 6 and then it takes an additional parameter n rows which says how many rows should I add and then I am calling this function suppose I have defined the function elsewhere and I am calling this function from mean <sil=0.915> .PERIOD So I declare a matrix 9 by 6 and then I will call marginals on just the 8 first 8 rows not the 9th row <sil=0.977> .PERIOD So I pass a subset of the rows so I pass a subset of the rows this is fine because I have declared a matrix of size 9 by 8 but I am passing only 8 rows to marginals and that is fine I can pass a subset of the rows <sil=0.929> .PERIOD What is definitely not fine is suppose you declare a matrix of size 9 by 6 and see that I want to add I want you to find the marginals of the first 10 rows then this is unsafe because it is true that the marginals function does not really care about the number of rows <sil=0.999> .PERIOD So it will work for any k cross 6 matrix but you cannot hope to pass arbitrary junk values to that matrix for example you have just declared a 9 by 6 matrix <sil=0.938> .PERIOD Now the 10 row of the matrix is basically invalid so if you pass it you could expect your code to receive a segmentation violation when you run the code <sil=0.974> .PERIOD So when it processes the 10th row what it has basically cross the limits of the array so the code may have a segmentation violation <sil=0.918> .PERIOD So note the difference between saying that marginals could work with arbitrary k cross 6 matrices it is still true that if you pass junk values to the matrix your code will crash if your code is a valid matrix then you can pass an arbitrary number of rows inside the matrix <sil=0.924> .PERIOD So the summary is that as with one dimensional arrays you should allocate your array and stay within the limits allocated within those limits the number of rows does not matter but it does not mean that you can overshoot the limit and hope that your code will work it may not and it can crash <sil=0.982> .PERIOD Welcome to the introductory programming course on NPTEL MOOCs <sil=0.933> .PERIOD The goal of this is to learn how to code basic programs in the C programming language <sil=0.942> .PERIOD Basically the aim of this course is to teach you how to solve problems using a computer and by the end of this course we will hope that you can write medium sized programs <sil=0.443> ,COMMA may be running to a couple of hundred lines of code comfortably in the C programming language <sil=0.937> .PERIOD Programming nowadays is considered a basic skill similar to mathematics that is needed across all disciplines like engineering in the sciences and nowadays even in the arts <sil=0.903> .PERIOD So a little bit of programming skill is an enhancement to any other skill set that you might already have <sil=0.920> .PERIOD This course we will start from the ground up <sil=0.980> .PERIOD We do not assume any prior experience in programming whether in C or in any other language <sil=0.951> .PERIOD So the focus will be to start from the basics and to use C as a medium of programming <sil=0.908> .PERIOD A couple of words about the process of programming it involves two basic steps <sil=0.994> .PERIOD One is to define the problem often you get real world problems which are not precise enough to write a program for <sil=0.975> .PERIOD So the first step would be to define and model the problem and this is a very important step in large scale software development <sil=0.980> .PERIOD However we will not focus on this as part of this course <sil=0.992> .PERIOD During this course you will not write a large software system like the Indian Railways Reservation System <sil=0.905> .PERIOD Those are extremely complex problems involving multiple programmers <sil=0.992> .PERIOD In this course we will assume that the problem is well defined and already provided to you <sil=0.903> .PERIOD So they will be precise and they will be fairly short and simple <sil=0.930> .PERIOD So this is the first step of programming which is definition of the problem which you can assume will be given <sil=0.909> .PERIOD Now comes the second step which is to obtain a logical solution to your problem and what do we mean by a logical solution <sil=0.956> .PERIOD A logical solution is a finite sequence of steps <sil=0.997> .PERIOD Do this first <sil=0.557> ,COMMA do this next <sil=0.958> .PERIOD If a certain condition is true do this otherwise do something else <sil=0.989> .PERIOD This is called an algorithm so an algorithm is basically a finite step by step procedure to solve a problem <sil=0.948> .PERIOD One way to visualize an algorithm is using a flow chart <sil=0.934> .PERIOD If you are new to programming it is recommended that you draw flow charts to define the solution to your problem <sil=0.960> .PERIOD Experience programmers very rarely draw flow charts but that is not a reason for beginning programmers to avoid flow charts <sil=0.911> .PERIOD So defining a problem is there then the process of coming up with an algorithm <sil=0.934> .PERIOD This is a very important step in the programming process and followed by there is a third step which is to implement the algorithm in a usual programming language <sil=0.959> .PERIOD So is the concept of an algorithm a new concept I would claim that it is not <sil=0.988> .PERIOD An algorithm is a very familiar concept <sil=0.904> .PERIOD The most important example that you can think of are cooking recipes are written in a way that they are almost algorithms <sil=0.920> .PERIOD They are not quite precise enough for a computer but they come quite close <sil=0.910> .PERIOD For example let us take an unnamed dish at the dessert and let us look at how things are specified in a recipe and we will see that this analogy is quite deep <sil=0.935> .PERIOD There is a very strong similarity in the way that a recipe is written and a program is written <sil=0.992> .PERIOD So usually they will have a list of ingredients upfront <sil=0.924> .PERIOD For example you have ice cream <sil=0.392> ,COMMA crushed cereal and so on and then once you have all the ingredients in place then you have instructions to say how do you start and how do you end up with the dish <sil=0.935> .PERIOD Now those instructions will be fairly precise <sil=0.967> .PERIOD Of course you assume that the person preparing the dish is a fairly experienced cook so that certain instructions need not be given in very precise detail <sil=0.952> .PERIOD For example you can say do this heat oil and so on and it is assumed that a person knows how to heat oil <sil=0.928> .PERIOD Even so you will see that certain recipes are fairly vague and other recipes are fairly detailed and in any recipe you can see certain things which are vague and will cause confusion to most people <sil=0.945> .PERIOD For example here is a term which says try to make each scoop about as large as your fist <sil=0.997> .PERIOD Now that of course is a vague term because my fist could be a different size than yours and then you will see that in a formation that makes it easy to dip in order <sil=0.983> .PERIOD So this is fairly vague and it is not very helpful to a cook who is making this for the first time <sil=0.920> .PERIOD So think of algorithms as similar to recipes but mentioned in a more precise manner <sil=0.913> .PERIOD Another way you can be familiar with algorithms is when you buy a make it yourself kit for a furniture or something like that and you will be provided with a step by step instructions on how to assemble the kit <sil=0.949> .PERIOD Often when you buy a disassembled table or something like that it will come with a sheet telling you how to start with the components and build a table <sil=0.901> .PERIOD Those are also similar to an algorithm <sil=0.995> .PERIOD So let us look at a flow chart to depict a mathematical algorithm and we will use this flow chart to explain certain conventions about how algorithms can be described <sil=0.974> .PERIOD So every flow chart will have a start and an end and it will have a finite number of boxes <sil=0.943> .PERIOD So this is the finite number of instructions that I was talking about <sil=0.969> .PERIOD There are certain conventions in drawing flow charts <sil=0.943> .PERIOD The start and the end are often described in circles <sil=0.914> .PERIOD Then there are ordinary boxes and then there are diamonds <sil=0.911> .PERIOD We will shortly describe what they mean <sil=0.999> .PERIOD So suppose you want to write an algorithm for adding the first n numbers <sil=0.943> .PERIOD All of you know how to do it <sil=0.976> .PERIOD The point is how do you describe this step by step to somebody who does not know it already <sil=0.981> .PERIOD So first you have to take what is the upper limit n and then you have to sum them up <sil=0.957> .PERIOD So one way to sum them up is start with an initial sum of 0 and then add numbers 1 by 1 <sil=0.992> .PERIOD So increment a common counter from 1 all the way up to n <sil=0.920> .PERIOD So you start with i equal to 1 and then add the i th number to the sum and then increment i <sil=0.910> .PERIOD If i is already n then you are done <sil=0.983> .PERIOD If i is not n then you go back and do the sum all over again until you hit an i <sil=0.913> .PERIOD When you reach i equal to n you come out of the program print the sum and then the program <sil=0.924> .PERIOD So this is a very simple flow chart <sil=0.916> .PERIOD So initially if n is less than 1 you have nothing to do <sil=0.902> .PERIOD If n is greater than 1 you start a counter from i equal to 1 to n and add the numbers 1 by 1 until you hit the n th number <sil=0.941> .PERIOD If you wanted to compute a slightly different problem which is let us say the factorial of n which is just the product of the first n numbers <sil=0.914> .PERIOD The flow chart will look fairly similar <sil=0.924> .PERIOD The only difference is that instead of adding numbers you will multiply them <sil=0.995> .PERIOD So this flow chart is similar to the previous flow chart <sil=0.988> .PERIOD You will first input an n and then increment n until you hit n equal to m <sil=0.915> .PERIOD If so you will finally print the factorial otherwise you go back to the loop <sil=0.906> .PERIOD So here are the conventions used <sil=0.900> .PERIOD The start symbol is often depicted as a circle or a novel <sil=0.930> .PERIOD The input symbol and the output symbol are often represented as parallelograms and the normal operation boxes are represented as rectangles and the test box to see whether you have hit a limit to test some condition in general they are represented as diamonds <sil=0.945> .PERIOD In this video we will discuss a slightly advanced usage of pointers <sil=0.429> ,COMMA even though the title of the first slide is how to return pointers from a function that is just a motivation for introducing a slightly more advanced topic in pointers <sil=0.951> .PERIOD So let us just see what is the problem with returning a pointer from a function <sil=0.916> .PERIOD You know that any variable can be passed as argument to a function <sil=0.620> ,COMMA can be declared as a local variable within a function and can also be returned from a function <sil=0.902> .PERIOD So is there something and we have already seen that in the case of the swap function <sil=0.403> ,COMMA how we pass pointers to a function and what new kinds of functions does this enable us to write <sil=0.996> .PERIOD So in this slide in this lecture let us talk about what will happen when we return pointers from a function <sil=0.955> .PERIOD I have written a very silly function here <sil=0.424> ,COMMA you do not need a function to do this <sil=0.451> ,COMMA but this illustrates a point <sil=0.930> .PERIOD I have a main function in which I have an integer pointer p and I will make it point to the return value of increment 1 <sil=0.982> .PERIOD And the increment function what it does is it takes an argument <sil=0.372> ,COMMA it increments the value <sil=0.529> ,COMMA it makes a pointer and points to the incremented value and returns that pointer <sil=0.957> .PERIOD We will see a pictorial representation in a minute <sil=0.983> .PERIOD Now this leads to a very notorious error in C known as a dangling pointer <sil=0.968> .PERIOD Let us examine that in slightly greater detail <sil=0.983> .PERIOD What happens when we call the increment function <sil=0.867> ?QUESTIONMARK By the main function we have an int pointer p and when it is declared it is not pointing to anything and immediately you will call increment 1 <sil=0.972> .PERIOD So you call increment 1 <sil=0.494> ,COMMA n is a local variable in increment <sil=0.519> ,COMMA it is the argument so n is 1 and then you declare a temp and then you declare pointer to temp <sil=0.921> .PERIOD So there is a ptr <sil=0.534> ,COMMA let us say that temp is at address hexadecimal 1000 <sil=0.414> ,COMMA so ptr contains 1000 and it points to temp <sil=0.450> ,COMMA temp is at address 1000 <sil=0.924> .PERIOD Now in the next statement you increment temp <sil=0.536> ,COMMA you set temp to n plus 1 <sil=0.639> ,COMMA so n is 1 and temp is 2 <sil=0.914> .PERIOD Now ptr points to temp and now I will return ptr <sil=0.417> ,COMMA so the return value is 1000 which is the address of temp <sil=0.996> .PERIOD Now what happens when you return to mean <sil=0.968> ?QUESTIONMARK As soon as increment finishes and we have said this several times before <sil=0.479> ,COMMA as soon as any function finishes the memory that is allocated to the function is erased <sil=0.924> .PERIOD So when you return to the main function what happens is that you have p and p will contain the address 1000 <sil=0.318> ,COMMA so it is meant to point to temp but the space meant for temp has already been erased <sil=0.595> ,COMMA so p is pointing to a junk value in memory <sil=0.346> ,COMMA it is pointing to an arbitrary location memory <sil=0.614> ,COMMA so this is known as a dangling pointer <sil=0.498> ,COMMA hopefully the picture is representative of a dangling pointer <sil=0.400> ,COMMA the fact that it points to a location which is no longer meaningful <sil=0.980> .PERIOD Notice that what I am talking about is the ideal situation <sil=0.542> ,COMMA when you run the <sil=0.633> ,COMMA when you code it in c and try to run it may be p does point to the location with address 2 <sil=0.397> ,COMMA this is because c may not be aggressive in reclaiming the memory but you should always assume that the safe thing is to assume every location that was allocated to increment is erased immediately after increment returns <sil=0.975> .PERIOD In practice it may not be the case but you should never assume that you still have the temp variable <sil=0.308> ,COMMA in general what you will have is a dangling pointer because p points to a location which no longer contains any relevant information <sil=0.588> ,COMMA so when you print p you will have a danger <sil=0.596> ,COMMA so how do you return pointers from a function <sil=0.529> ,COMMA so we have seen what a dangling pointer means and here is a very silly function which will create a dangling pointer <sil=0.978> .PERIOD Now what is the problem with this function <sil=0.419> ,COMMA it returns the address of a local variable temp but temp is erased as soon as increment end returns <sil=0.316> ,COMMA so the return value is not a meaningful address to the calling function which is mean <sil=0.509> ,COMMA can we get around this <sil=0.501> ,COMMA so the main problem here is that anything that is allocated to the called function on the stack is erased as soon as it returns <sil=0.358> ,COMMA is there any way at all to meaningful erase <sil=0.371> ,COMMA so the return pointers to new variables <sil=0.480> ,COMMA we will use a new concept that of a globally accessible memory called heap <sil=0.365> ,COMMA we have already seen a stack <sil=0.649> ,COMMA now we will understand what a heap is <sil=0.901> .PERIOD So <sil=0.608> ,COMMA I will roughly the idea is that if we allocate value on the global memory it is not erased when the function returns <sil=0.920> .PERIOD I will explain this with a help of a slightly broad analogy <sil=0.486> ,COMMA hopefully this is indicative of what actually happens with a heap <sil=0.450> ,COMMA so think of executing a function as writing on a classroom blackboard when a lecture is going on <sil=0.365> ,COMMA once the function finishes execution this is like the class is over <sil=0.628> ,COMMA everything on the blackboard is erased <sil=0.587> ,COMMA suppose you want to retain a message after the class is over <sil=0.950> .PERIOD Now <sil=0.542> ,COMMA the solution could be that you can post things on a notice board which is global to all classrooms <sil=0.462> ,COMMA so it is common to all classrooms <sil=0.511> ,COMMA so things on the notice board are not removed as soon as a class is over <sil=0.423> ,COMMA if you write something on the blackboard which is similar to storing something on the stack <sil=0.466> ,COMMA as soon as the class is over it will be erased <sil=0.972> .PERIOD So <sil=0.448> ,COMMA if you have something to communicate back to another class may maybe you can post it on a notice board <sil=0.321> ,COMMA now the notice board is globally accessible to all classrooms <sil=0.528> ,COMMA the blackboard is like a stack and the global notice board is like a heap and contents on the heap is not erased when a function finishes <sil=0.426> ,COMMA so how do you allocate things on the heap <sil=0.893> ?QUESTIONMARK There is a standard library function called malloc in the file SDD lib dot h which can be used to allocate space on the heap <sil=0.372> ,COMMA roughly this is what it does <sil=0.373> ,COMMA if you ask for malloc n where n is a positive integer <sil=0.324> ,COMMA it will allocate n bytes of memory on the heap and it will return a pointer to that to the first location of the allocated space <sil=0.416> ,COMMA now that pointer can be converted to pointer of any type malloc just allocates n bytes <sil=0.522> ,COMMA now you may want to interpret those bytes as n divided by 4 integers <sil=0.624> ,COMMA in that case it will return a pointer <sil=0.622> ,COMMA so you convert that pointer to an int pointer <sil=0.514> ,COMMA let see an example I may have an int pointer ptr and now I want to allocate 10 integers on the heap <sil=0.547> ,COMMA how do I do that <sil=0.941> ?QUESTIONMARK I will allocate 10 star size of int <sil=0.620> ,COMMA so this will allocate on some particular machine let us say 40 bytes and it will return an address of the first location <sil=0.635> ,COMMA now that address I want to treat it as an integer address <sil=0.566> ,COMMA so I will convert it to an int as int star and then malloc 10 star size of int <sil=0.307> ,COMMA so this style of writing code makes the code portable <sil=0.453> ,COMMA because suppose you write the code and you on a machine where integer was 4 bytes and you take your code and go to a bigger machine which has 8 bytes as the size of an integer <sil=0.502> ,COMMA then you compile the code on that machine and your code will still allocate 10 integers <sil=0.497> ,COMMA why <sil=0.967> ?QUESTIONMARK Because on the new machine size of int will be used automatically 8 <sil=0.344> ,COMMA so it will allocate 8 bytes <sil=0.543> ,COMMA so in order to write portable code you can use size of int instead of assuming that integer is 4 bytes <sil=0.425> ,COMMA so I want to allocate malloc 10 star size of int <sil=0.640> ,COMMA this will allocate 10 integers no matter which machine you do it on <sil=0.308> ,COMMA so and it will return you the address of the first byte in that allocated space <sil=0.431> ,COMMA that address you convert to an integer at integer pointer <sil=0.604> ,COMMA here is how you allocate memory on the heap <sil=0.551> ,COMMA so when you think pictorially think of heap as a separate space in the memory <sil=0.565> ,COMMA in this case ptr will be allocated some space on the heap <sil=0.394> ,COMMA let us say 10 integers <sil=0.421> ,COMMA so it will on some particular machine it will say 40 bytes and it will ptr will return the address of the first byte <sil=0.506> ,COMMA now that first byte you treat it as a pointer to int that is done through the conversion in star <sil=0.551> ,COMMA now it is nice that you can allocate space on the heap <sil=0.356> ,COMMA but in order to be hygienic you should also remove the allocated space once you are done with it <sil=0.543> ,COMMA there should be a reverse operation to allocate and that is free <sil=0.476> ,COMMA it is in the same library stdlib dot h and if I just say free ptr and ptr was originally allocated using malloc then it will correctly remove however many bytes was originally were originally allocated <sil=0.330> ,COMMA so let us say that I have instar ptr and then ptr I allocate 10 integers on the heap and ptr is an is the address of the first allocated location <sil=0.447> ,COMMA now I may do a bunch of processing here and once I am done it is just nice of me to be allocate things on the heap <sil=0.424> ,COMMA this is like saying that things on the notice board once some condition occurs where you know that that notice is no longer needed <sil=0.406> ,COMMA you just remove that posting from the notice board <sil=0.580> ,COMMA for that you use free of ptr <sil=0.958> .PERIOD Now notice the asymmetry here malloc took the number of bytes to be allocated free just wanted to say which pointer is to be freed <sil=0.634> ,COMMA it does not ask for how many bytes to free <sil=0.395> ,COMMA so you can imagine that malloc does some kind of bookkeeping where it says that I allocated 40 bytes and that was returned to ptr <sil=0.524> ,COMMA so if I just say free ptr it automatically knows that 40 bytes are to be freed <sil=0.303> ,COMMA you do not have to give the extra argument saying how many bytes to free <sil=0.622> ,COMMA once you free the pointer you just set it back to null <sil=0.459> ,COMMA this is just a safe practice and it is not absolutely necessary but it is recommended <sil=0.968> .PERIOD So let us solve our earlier problem using malloc <sil=0.367> ,COMMA our earlier problem was that ptr was pointing to some location within the stack <sil=0.542> ,COMMA so as soon as the function returned the return address no longer meant any meaningful address <sil=0.493> ,COMMA so let us now solve this problem <sil=0.470> ,COMMA I have included STD lib dot h because I will allocate memory on the heap <sil=0.535> ,COMMA so the increment function is modified as follows <sil=0.627> ,COMMA strictly speaking I do not need attempt variable anymore <sil=0.420> ,COMMA I have an int pointer and I will use the pointer to allocate one integer on the heap <sil=0.371> ,COMMA this is a really wasteful practice but it just illustrates a point <sil=0.650> ,COMMA so it will allocate one integer on the heap and then return that address and treat that address as an in star <sil=0.602> ,COMMA now I will use star ptr equal to n plus 1 to dereference that location on the heap and increment the and set the value to n plus 1 <sil=0.568> ,COMMA once I am done I will return the ptr <sil=0.636> ,COMMA I will return the address on the heap <sil=0.306> ,COMMA the difference here is that the return address is on the heap and only the stack is erased <sil=0.596> ,COMMA so things on the heap are not erased unless you explicitly ask it to be erased wire free <sil=0.366> ,COMMA so returning a heap address and so p will point to a meaningful location on the heap <sil=0.614> ,COMMA when you print it you will get 2 and once you are done you can say free p <sil=0.543> ,COMMA so here is a strange use which you have not seen before <sil=0.367> ,COMMA something was done the malloc was done in the increment function and the free is being done in the main function <sil=0.301> ,COMMA now if you think back to the physical analogy it is not really surprising <sil=0.496> ,COMMA somebody can post something on the notice board and a different person can remove it <sil=0.447> ,COMMA what happens here is that the increment function ptr points to some location on the heap using malloc <sil=0.423> ,COMMA so one integer is allocated on the heap and when you start ptr equal to n plus once then the location in the heap will contain 2 and here is the catch <sil=0.308> ,COMMA earlier p was just a dangling it was just pointing to an arbitrary location in the memory <sil=0.368> ,COMMA but increment allocated something on the heap and return that address <sil=0.475> ,COMMA as soon as increment returns the stack is erased <sil=0.597> ,COMMA so everything that was allocated on the stack for increment is erased <sil=0.373> ,COMMA but things that are allocated on the heap remain <sil=0.357> ,COMMA so p points to a meaningful address on the heap <sil=0.350> ,COMMA then once you are done you can say free p and things will be erased <sil=0.454> ,COMMA when you print it the output will be 2 <sil=0.605> ,COMMA malloc and free are prone to a lot of errors and a lot of programming errors in C can be traced back to incorrect use of malloc and free <sil=0.583> ,COMMA so there are some categories of errors <sil=0.520> ,COMMA for example you may forget to malloc in the first place <sil=0.443> ,COMMA so you will need to dangling references or dangling pointers as we saw in the first example <sil=0.645> ,COMMA now you could allocate some space <sil=0.336> ,COMMA but you may not allocate enough space that is a very common error <sil=0.550> ,COMMA commonly you could allocate off by one errors <sil=0.332> ,COMMA I wanted to allocate really n plus 1 number of bytes <sil=0.648> ,COMMA but instead I allocated only n number of bytes <sil=0.605> ,COMMA another very common error is something known as a memory leak <sil=0.557> ,COMMA which is that you allocate things on the heap <sil=0.414> ,COMMA but you forget to free memory after use <sil=0.357> ,COMMA this is called a memory leak <sil=0.575> ,COMMA notice that if you allocate space on the stack it will always be cleaned up as soon as the function returns <sil=0.465> ,COMMA so memory leaks usually happen when you malloc space on the heap <sil=0.335> ,COMMA but you forget to free them once you are done and a lot of software ships with memory leaks and this is a major concern in the industry <sil=0.331> ,COMMA there is also an obscure error which is freeing the same memory more than once <sil=0.507> ,COMMA this is uncommon when a single programmer is working on a code <sil=0.307> ,COMMA but when multiple programmers are working on the same piece of code <sil=0.460> ,COMMA you may end up freeing the same memory twice <sil=0.302> ,COMMA this will lead to some runtime errors <sil=0.902> .PERIOD In this session <sil=0.551> ,COMMA we will discuss operators and expressions <sil=0.926> .PERIOD So <sil=0.525> ,COMMA we have already used C expressions in our programs before and expressions in C are similar to expressions in mathematics and they follow rules similar to what mathematical expressions also follow <sil=0.908> .PERIOD They are a basic unit of evaluation and each expression has a value <sil=0.946> .PERIOD We say that an expression returns a value of a particular type <sil=0.975> .PERIOD So <sil=0.575> ,COMMA let us consider a few example expressions <sil=0.974> .PERIOD For example <sil=0.644> ,COMMA I have the following A is 3 <sil=0.450> ,COMMA B is 4 and I have a variable C which is just declared to be a type int and then say that C equal to A times A plus B times B <sil=0.917> .PERIOD So <sil=0.352> ,COMMA the right hand side of the assignment operator <sil=0.313> ,COMMA so this is the assignment operator and the right hand side is an expression and that expression has sub expressions A star A and B star B within parent this is <sil=0.902> .PERIOD So <sil=0.533> ,COMMA an expression can be made up of variables <sil=0.352> ,COMMA it can be made up of constants <sil=0.917> .PERIOD These are the atoms of the basic components of an expression and sub expressions can be combined into bigger expressions using operators <sil=0.945> .PERIOD Now <sil=0.546> ,COMMA operators can be unary that is they take one argument operation <sil=0.905> .PERIOD For example <sil=0.649> ,COMMA unary operators the examples can be minus which is the unary minus for example <sil=0.455> ,COMMA minus 3 is a negative number <sil=0.943> .PERIOD Similarly <sil=0.559> ,COMMA not operator that we have seen in connection with logical operations <sil=0.935> .PERIOD So <sil=0.493> ,COMMA not of 0 for example <sil=0.609> ,COMMA so the logical negation operator both of these operations take one argument <sil=0.926> .PERIOD Now <sil=0.620> ,COMMA there is also the binary operations like plus minus star etcetera <sil=0.927> .PERIOD So <sil=0.621> ,COMMA plus takes two arguments for example <sil=0.645> ,COMMA an expression like 2 plus 3 and here is the binary minus <sil=0.989> .PERIOD So <sil=0.631> ,COMMA if I say 2 minus 3 this is actually a binary operator which takes two arguments which is which are 2 and 3 <sil=0.957> .PERIOD Similarly <sil=0.303> ,COMMA the binary multiplication so <sil=0.632> ,COMMA 2 star 3 would be the product of 2 and 3 <sil=0.952> .PERIOD So <sil=0.557> ,COMMA notice the difference between it is the same sign for the unary minus and the binary minus <sil=0.943> .PERIOD But <sil=0.537> ,COMMA the unary minus takes only one argument and the binary minus takes two arguments <sil=0.985> .PERIOD We have used the assignment operation many times and let us understand it in somewhat more detail <sil=0.975> .PERIOD For example <sil=0.516> ,COMMA if you consider the expression be equal to b plus 1 <sil=0.927> .PERIOD Now <sil=0.330> ,COMMA if you remove the semicolon at the end so <sil=0.616> ,COMMA the statement is b equal to b plus 1 semicolon and if you omit the semicolon what you get is an assignment expression b equal to b plus 1 without the semicolon <sil=0.940> .PERIOD So <sil=0.621> ,COMMA how does the assignment operation work <sil=0.953> ?QUESTIONMARK For example <sil=0.391> ,COMMA consider an expression like a equal to and then on the right hand side within parenthesis b equal to 10 what does this do <sil=0.994> .PERIOD So <sil=0.553> ,COMMA assume that a and b are integer variables <sil=0.984> .PERIOD Now <sil=0.628> ,COMMA assignment assigns to the left hand variable <sil=0.430> ,COMMA left hand operand the variable left hand operand the value of the expression on the right hand side <sil=0.949> .PERIOD For example <sil=0.507> ,COMMA in this assignment operation there are two assignment expressions one is the expression b equal to 10 and the second is the expression a equal to b equal to 10 <sil=0.953> .PERIOD So <sil=0.442> ,COMMA the first assignment expression is supposed to do the following assign 10 to b <sil=0.958> .PERIOD So <sil=0.631> ,COMMA what it does is it assigns the value of the right expression which is 10 in this case to the left hand side operand that is one thing it does and also it returns the value after the assignment <sil=0.993> .PERIOD So <sil=0.649> ,COMMA 10 has been assigned to b and the return value of this expression is 10 <sil=0.915> .PERIOD So <sil=0.557> ,COMMA we can now analyze a equal to b equal to 10 as follows <sil=0.974> .PERIOD So <sil=0.383> ,COMMA this is the first evaluate the expression in parenthesis <sil=0.991> .PERIOD The expression b equal to 10 has an assignment operator <sil=0.916> .PERIOD So <sil=0.536> ,COMMA evaluate the expression on the right hand side and then assign it to b <sil=0.941> .PERIOD Now <sil=0.420> ,COMMA that operation returns so that expression returns a particular value which is 10 <sil=0.993> .PERIOD Now <sil=0.476> ,COMMA the original expression can be thought of as just a equal to 10 right <sil=0.902> .PERIOD This is evaluated as usual <sil=0.977> .PERIOD So <sil=0.462> ,COMMA you take 10 and assign it to a and the return value of the whole expression becomes 10 <sil=0.956> .PERIOD So <sil=0.359> ,COMMA when executing this expression when evaluating this expression two variables are assigned their values <sil=0.951> .PERIOD One is b which is assigned the value 10 and the second is a which is also assigned the value 10 <sil=0.912> .PERIOD The assignment operation can be used to initialize a number of variables in one shot for example <sil=0.425> ,COMMA if I write a statement like a equal to b equal to c equal to d equal to e equal to 0 what does this mean <sil=0.989> .PERIOD Now <sil=0.338> ,COMMA here there is some big bit here because we do not know which order to evaluate this should be evaluate from left to right should be evaluate from right to left does it matter <sil=1.000> .PERIOD So <sil=0.577> ,COMMA should the assignment be treated as the following where a equal to b is done first then equal to c then equal to d and so on or should it be the opposite way right to left where equal to 0 is first done then d equal to that then c equal to that so on until a <sil=0.983> .PERIOD So <sil=0.563> ,COMMA the expression is evaluated from right to left in the case of the assignment operation assignment for example <sil=0.586> ,COMMA the above expression that we just saw will be done as a equal to so <sil=0.323> ,COMMA e equal to 0 first and then backward until a is assigned <sil=0.916> .PERIOD Now <sil=0.461> ,COMMA this is also the standard mathematical convention we are not introducing a new strange rule here why is this first we will evaluate the innermost expression which is e equal to 0 <sil=0.948> .PERIOD So <sil=0.625> ,COMMA e will be assigned 0 then the return value of this sub expression <sil=0.906> .PERIOD So <sil=0.492> ,COMMA this sub expression will return the value 0 <sil=0.952> .PERIOD So <sil=0.470> ,COMMA this becomes d equal to 0 d is assigned the value 0 and the return value of this sub expression becomes 0 <sil=0.950> .PERIOD So <sil=0.567> ,COMMA then we have c equal to 0 and so on <sil=0.974> .PERIOD Finally <sil=0.305> ,COMMA every variable here will be assigned the value 0 <sil=0.964> .PERIOD So <sil=0.328> ,COMMA the reason for doing this is that if you try to do it in the opposite way you will see that uninitialized variables are initialized to other uninitialized variables for example <sil=0.541> ,COMMA if you go from left to right in the previous this simply does not make any sense because you have just declared a <sil=0.407> ,COMMA b <sil=0.373> ,COMMA c and so on and when you say a equal to b a and b are not initialized yet <sil=0.914> .PERIOD So <sil=0.564> ,COMMA this assignment hardly makes any sense the basic rule of assignment is that a left hand side equal to right hand side <sil=0.904> .PERIOD So <sil=0.363> ,COMMA the left hand side is some value that can be assigned to for example <sil=0.566> ,COMMA this is a variable <sil=0.971> .PERIOD The right hand side can be anything variable constant or it can be an expression <sil=0.976> .PERIOD So <sil=0.506> ,COMMA all these are valid assignments <sil=0.993> .PERIOD So <sil=0.405> ,COMMA what is an invalid assignment <sil=0.963> ?QUESTIONMARK So <sil=0.642> ,COMMA a equal to 0 can be a valid assignment but 0 equal to a <sil=0.912> .PERIOD So <sil=0.467> ,COMMA the assignment operation is evaluated right to left <sil=0.901> .PERIOD Now <sil=0.497> ,COMMA we have the concept of associativity of operators <sil=0.964> .PERIOD So <sil=0.555> ,COMMA what does associativity mean <sil=0.863> ?QUESTIONMARK It is we have just argued that a equal to b equal to c equal to d equal to 0 and expression like that will be evaluated from right to left <sil=0.960> .PERIOD So <sil=0.540> ,COMMA it is as though we had parenthesis the expression as d equal to 0 in our most then c equal to that then b equal to that and so on <sil=0.938> .PERIOD So <sil=0.618> ,COMMA on the other hand if you take an operator on the other hand if you take an operator like binary plus the addition symbol then the usual custom is that you parenthesis from left to right <sil=0.942> .PERIOD So <sil=0.591> ,COMMA the evaluation is done a plus b first then that sum is added to c then that is added to t <sil=0.960> .PERIOD So <sil=0.530> ,COMMA the assignment operation goes right to left the addition symbol operates left to right <sil=0.922> .PERIOD So <sil=0.423> ,COMMA this concept of associativity of an operator tells us the order in which the evaluate the operations if there are multiple occurrences of the same operator <sil=0.948> .PERIOD So <sil=0.583> ,COMMA the first there are multiple occurrences of the equal to sign in the second there are multiple occurrences of the addition symbol <sil=0.901> .PERIOD So <sil=0.417> ,COMMA associativity rules tells you that if there are identical operators in an expression in which order do you evaluate them do you evaluate them from left to right <sil=0.906> .PERIOD If you do then it is called a left associative operator if you evaluate from right to left in the case of for example <sil=0.514> ,COMMA the assignment then it is called a right associative operator binary minus is also left associative for example <sil=0.533> ,COMMA a minus b minus c minus d is evaluated as a minus b then c then minus c then minus d <sil=0.909> .PERIOD So <sil=0.319> ,COMMA for example <sil=0.456> ,COMMA if you say 10 minus 5 minus 15 what will be done is 10 minus 5 and then minus 15 <sil=0.974> .PERIOD So <sil=0.592> ,COMMA this is 5 minus 15 which is minus 10 <sil=0.915> .PERIOD Whereas <sil=0.481> ,COMMA if the parenthesis had been in the opposite way it would be 10 minus 5 minus 15 which case it would be 10 minus this is minus 10 which is 20 <sil=0.947> .PERIOD Notice that this is not how you are supposed to do it even in mathematics <sil=0.991> .PERIOD So <sil=0.376> ,COMMA the way that c does handles the associativity of the binary operation is correct <sil=0.998> .PERIOD So <sil=0.495> ,COMMA the correct parenthesis is 10 minus 5 and then minus 10 minus 10 minus 15 <sil=0.953> .PERIOD In general for every operator c defines an associativity <sil=0.930> .PERIOD So <sil=0.620> ,COMMA let us see the part of the associativity operations of operations in c <sil=0.987> .PERIOD There are several operations that we have seen so far the parenthesis the Boolean naught the logical naught and the unary the binary multiplication division and so on addition symbol comparison less than or equal to and so on equality logical and logical or and then the assignment operator <sil=0.948> .PERIOD We have seen all these operations so far and of this the typical associativity is left to right there are couple of exceptions one we have already seen assignment operation is right to left <sil=0.903> .PERIOD The unary operations are also right to left most of the other operations are left to right <sil=0.911> .PERIOD So <sil=0.371> ,COMMA if you think for a little bit you can see that the associativity for unary operations is also easily seen to be right to left that makes more sense <sil=0.957> .PERIOD So <sil=0.568> ,COMMA the idea is not that you should memorize this table but you should understand given the table can you correctly calculate what the value of the expression will be <sil=0.978> .PERIOD This lecture will continue our discussion of structures <sil=0.965> .PERIOD So <sil=0.460> ,COMMA if you remember our earlier lecture we were saying that user defined structures are user defined types which will be treated by C in pretty much the same way as the basic data types <sil=0.912> .PERIOD So <sil=0.341> ,COMMA we will continue on that theme and look at a topic on pointers to structures <sil=0.988> .PERIOD You know that for a basic data type you can define a pointer to that type I can declare in star or character star and so on <sil=0.923> .PERIOD Similarly <sil=0.571> ,COMMA does it make sense to talk about struct point star for instance <sil=0.978> .PERIOD Let us look at an example where it makes sense <sil=0.935> .PERIOD So <sil=0.465> ,COMMA let us go back to the example of struct point and struct rectangle from the earlier lecture <sil=0.983> .PERIOD So <sil=0.465> ,COMMA let us say that struct rectangle has two points which are left bottom and right top and both of them are struct point <sil=0.917> .PERIOD Now <sil=0.482> ,COMMA we want to calculate the area of a rectangle <sil=0.995> .PERIOD So <sil=0.353> ,COMMA you have a rectangle R which is initialized to 0 0 1 1 <sil=0.994> .PERIOD So <sil=0.620> ,COMMA left bottom will be 0 0 and right top will be 1 1 and I want to compute its area <sil=0.967> .PERIOD Now <sil=0.359> ,COMMA the area function is defined as follows it is a function that returns an integer it takes as parameter a struct rectangle and it does the following it does R dot right top dot x minus left bottom dot x star right top dot y minus left bottom dot y <sil=0.913> .PERIOD So <sil=0.573> ,COMMA it does that particular function and it returns it <sil=0.994> .PERIOD So <sil=0.340> ,COMMA we know that we can pass structures as parameters and also return structures from functions <sil=0.917> .PERIOD But is it efficient to pass structures or to return structures and the answer is usually no because copying a structure involves copying all its sub fields <sil=0.967> .PERIOD So <sil=0.474> ,COMMA generally when you call a function the value has to be copied on to the functions local scope and we have seen this when discussing functions <sil=0.974> .PERIOD So <sil=0.309> ,COMMA when you pass a structure the entire structure has to be copied <sil=0.943> .PERIOD Similarly <sil=0.397> ,COMMA when you return a structure the entire structure that was created inside the function has to be copied back this is usually an expensive operation <sil=0.961> .PERIOD One way to get around it is to pass a pointer to the structure <sil=0.916> .PERIOD So <sil=0.551> ,COMMA what should be done to pass to pass structures as functions in an efficient manner <sil=0.996> .PERIOD Now <sil=0.549> ,COMMA one way to do it would be to define what is known as a pointer to a structure <sil=0.909> .PERIOD How do you define a pointer to a structure you define it pretty much the same way as pointer to any other data type <sil=0.957> .PERIOD At this pin an integer you would declare in star PR <sil=0.949> .PERIOD So <sil=0.358> ,COMMA if you want to declare a variable which is a pointer to a structure you would define struct rect star PR <sil=0.938> .PERIOD So <sil=0.392> ,COMMA PR is a pointer to struct rectangle <sil=0.987> .PERIOD So <sil=0.390> ,COMMA now how would you pass the argument you would say address of the rectangle R <sil=0.921> .PERIOD So <sil=0.545> ,COMMA you would say area and the parameter is address of R <sil=0.944> .PERIOD Now <sil=0.461> ,COMMA inside the function earlier you remember it was pr dot write top dot x <sil=0.900> .PERIOD Now <sil=0.642> ,COMMA PR in this case is just a pointer to rectangle <sil=0.969> .PERIOD So <sil=0.302> ,COMMA we have to access the variable in that address <sil=0.936> .PERIOD How do you do it using the star operator <sil=0.925> .PERIOD This is the same as addressing any basic data type <sil=0.961> .PERIOD You would say that star PR would be the address would be the variable in that location <sil=0.957> .PERIOD So <sil=0.459> ,COMMA in this case it would be star PR <sil=0.914> .PERIOD Star PR would be a struct rect and that struct rect dot write top dot x minus star PR dot left bound dot x and so on <sil=0.997> .PERIOD So <sil=0.564> ,COMMA the lesson here is that instead of passing structures you pass pointers to structures and now whatever be the size of the structure <sil=0.923> .PERIOD So <sil=0.483> ,COMMA you have a struct rectangle which inside has two points and so on <sil=0.961> .PERIOD So <sil=0.490> ,COMMA you may be copying a very large you may want to pass a very large structure and copying that will take a long time <sil=0.991> .PERIOD But instead what you do is you pass just a pointer <sil=0.948> .PERIOD Now <sil=0.408> ,COMMA regardless of the size of the structure only one pointer is copied <sil=0.983> .PERIOD So <sil=0.417> ,COMMA the same principle goes for returning structures as well <sil=0.947> .PERIOD When you are in a structure from a function what you would do is to return a pointer to that structure <sil=0.915> .PERIOD Of course <sil=0.368> ,COMMA now the structure has to be allocated on the heap rather than the stack <sil=0.974> .PERIOD Now <sil=0.474> ,COMMA let us see how the memory depiction of this looks like <sil=0.929> .PERIOD So <sil=0.645> ,COMMA PR when you define struct rect star PR PR is a pointer to a structure of type rectangle and then what is happening here is that if you want to access the y coordinate of the left bottom you would say star PR dot left dot y <sil=0.995> .PERIOD So <sil=0.382> ,COMMA it will come to the left bottom field of rectangle and pick its sub field y <sil=0.954> .PERIOD So <sil=0.384> ,COMMA star PR dot left dot y would refer to this location in the memory <sil=0.933> .PERIOD Similarly <sil=0.470> ,COMMA star PR dot right dot y would be this location in the memory and so on <sil=0.978> .PERIOD So <sil=0.526> ,COMMA you can address the sub fields of address the fields of a structure using pointer <sil=0.979> .PERIOD There is one syntactic convenience that C provides you because addressing structures is a fairly common occurrence and because in this case by associativity you cannot omit the parenthesis <sil=0.934> .PERIOD You cannot say star PR without parenthesis because it means PR dot left bottom and star of that <sil=0.960> .PERIOD So <sil=0.335> ,COMMA that is not what you want <sil=0.996> .PERIOD You want to say that take the structure in the location star PR and take its left bottom <sil=0.961> .PERIOD So <sil=0.345> ,COMMA in this case by its associativity and precedence rules you have to include these parenthesis you cannot omit them and this is inconvenient <sil=0.912> .PERIOD Therefore <sil=0.345> ,COMMA C provides a syntactic convenience which is PR arrow <sil=0.907> .PERIOD Arrow is actually two characters it is a dash and a left angle bracket <sil=0.962> .PERIOD So <sil=0.316> ,COMMA PR arrow left bottom is the same as within bracket star PR dot left bottom <sil=0.951> .PERIOD So <sil=0.633> ,COMMA there are two ways to address the fields of the location pointer to by PR <sil=0.995> .PERIOD So <sil=0.545> ,COMMA PR is a pointer to a struct rect you can access its left bottom by saying star PR dot left bottom or PR arrow dot left bottom <sil=0.993> .PERIOD Notice that these two characters dash and left angle is just a single operator and they have so dash left angle that is the arrow operator and dot have the same precedence and both are left associative <sil=0.966> .PERIOD So <sil=0.393> ,COMMA in this lecture we will talk about structures in C which is a syntactic feature that C provides in order to define new data types <sil=0.988> .PERIOD So <sil=0.591> ,COMMA let us look at the motivation till now we have used the data types that C language has already provided like int float character and also we have seen data types like arrays and we could define arrays of in arrays of character and so on <sil=0.927> .PERIOD We have also seen pointers which can hold address locations of other variables <sil=0.986> .PERIOD Now what if we want to define our own data types using the data types that are already available <sil=0.945> .PERIOD So <sil=0.549> ,COMMA if you want to define custom data types <sil=0.354> ,COMMA does the language provide any feature to do it <sil=0.908> .PERIOD Before we reach there <sil=0.392> ,COMMA we will just take a look at why you would want to define such a data type <sil=0.948> .PERIOD So <sil=0.640> ,COMMA let us say that we are designing a geometry package and we want to define a point on the plane as having an x coordinate and a y coordinate <sil=0.908> .PERIOD Now <sil=0.580> ,COMMA there is a easy way to do it if you have arrays you could hold a point inside an array of size 2 <sil=0.992> .PERIOD Now <sil=0.603> ,COMMA you would keep the first coordinate in the x coordinate as the 0th element in the array and the y coordinate as the first element in the array <sil=0.975> .PERIOD This is one way to do it <sil=0.995> .PERIOD Another way is to keep two variables point underscore x and point underscore y and these are the x coordinates and the y coordinate of a single point <sil=0.972> .PERIOD This is another way to do it <sil=0.629> ,COMMA but in both these solutions there is no way to indicate that these two are intended to be the x coordinate and the y coordinate of the same point <sil=0.917> .PERIOD The programmer has to impose considerable discipline in coding in order to maintain this meaning <sil=0.989> .PERIOD So <sil=0.398> ,COMMA is there a more natural way to do it in C <sil=0.916> .PERIOD So <sil=0.571> ,COMMA we want to define a point data type and a point data type internally has two integers <sil=0.523> ,COMMA one two floating point <sil=0.524> ,COMMA one in x coordinate and another a y coordinate <sil=0.942> .PERIOD So <sil=0.503> ,COMMA now we will define a structure as a collection of variables with a common name <sil=0.936> .PERIOD Now <sil=0.374> ,COMMA the variables can be of different types <sil=0.933> .PERIOD This is unlike arrays we know that in an array you can hold multiple values in a continuous sequence <sil=0.357> ,COMMA but all the values have to be of the same type <sil=0.949> .PERIOD So <sil=0.342> ,COMMA what is different here with structures is that you can hold multiple values in the same data type <sil=0.926> .PERIOD Also the same data type can hold multiple sub types within itself <sil=0.997> .PERIOD So <sil=0.482> ,COMMA structural variables are called fields <sil=0.952> .PERIOD So <sil=0.365> ,COMMA let us look at example structure <sil=0.989> .PERIOD We define something called a struct point and it has an int x and the int y coordinate and how do you this is the data type <sil=0.942> .PERIOD Notice that the data type declaration has a semicolon at the end <sil=0.928> .PERIOD Now <sil=0.449> ,COMMA how do you define a variable with this data type <sil=0.913> ?QUESTIONMARK You can say struct point p t <sil=0.907> .PERIOD So <sil=0.639> ,COMMA p t is one variable that is of data type <sil=0.944> .PERIOD So <sil=0.344> ,COMMA this is the struct point <sil=0.911> .PERIOD You cannot say point p t <sil=0.997> .PERIOD You have to say that it is a struct point <sil=0.953> .PERIOD Now <sil=0.396> ,COMMA how do I assign values to this data type <sil=0.866> ?QUESTIONMARK So <sil=0.567> ,COMMA structure is a composite data type that has two internal components <sil=1.000> .PERIOD One is x and the other is y <sil=0.945> .PERIOD So <sil=0.334> ,COMMA in order to say that the internal components will have certain values <sil=0.395> ,COMMA I need to say how do you get to these internal components <sil=0.871> ?QUESTIONMARK And this is done by the dot operator <sil=0.958> .PERIOD So <sil=0.547> ,COMMA you can say p t dot x equal to 1 that would assign the x field inside the p t structure to 1 <sil=0.928> .PERIOD Similarly <sil=0.303> ,COMMA p t dot y equal to 0 <sil=0.318> ,COMMA what it will do is it will take the y field of p t structure and assign it to 0 <sil=0.972> .PERIOD So <sil=0.500> ,COMMA the internal memory representation after executing these statements will be that p t is a structure it has two sub fields x and y and x will be assigned to 1 and y will be assigned to 0 <sil=0.909> .PERIOD Struct point is the name of the data type and p t is the name of the variable <sil=0.972> .PERIOD Now <sil=0.393> ,COMMA as far as c is concerned <sil=0.414> ,COMMA the structure data type that you define is just like a data type that it provides <sil=0.988> .PERIOD So <sil=0.512> ,COMMA user defined data types especially structures are treated more or less in the same way as an ordinary data type <sil=0.940> .PERIOD And we will see that with an ordinary data type <sil=0.598> ,COMMA there are multiple things that you can do with it <sil=0.988> .PERIOD You can initialize you can declare a variable to be of that data type <sil=0.940> .PERIOD We have seen already how to do it <sil=0.994> .PERIOD You can initialize a variable of a particular data type <sil=0.395> ,COMMA we will see how to do it <sil=0.996> .PERIOD Similarly <sil=0.481> ,COMMA you can pass a data of a particular type to a function and return a variable of that type from a function <sil=0.927> .PERIOD You will see that all these are possible with structures as well <sil=0.905> .PERIOD So <sil=0.396> ,COMMA we will see these with examples <sil=0.966> .PERIOD Now <sil=0.498> ,COMMA struct point is just a type and it can be used like any other standard c data type even though you as a programmer have defined it <sil=0.904> .PERIOD For now <sil=0.548> ,COMMA how do you define a structure <sil=0.952> ?QUESTIONMARK Usually <sil=0.618> ,COMMA you define all the structures that you need at the very top of the file just of the hashing rule <sil=0.945> .PERIOD Now <sil=0.542> ,COMMA you know that with a standard data type <sil=0.645> ,COMMA you can define an array of that data type <sil=0.927> .PERIOD If you have you can declare array of in array of characters and so on <sil=0.906> .PERIOD Similarly <sil=0.544> ,COMMA you can define a struct point array <sil=0.979> .PERIOD C says that user defined data types are treated in the same way as the standard data types that it provides <sil=0.924> .PERIOD So <sil=0.621> ,COMMA here let us look at this example <sil=0.977> .PERIOD So <sil=0.539> ,COMMA we have struct point p t 1 p t 2 <sil=0.983> .PERIOD So <sil=0.512> ,COMMA this says that p t 1 and p t 2 are two variables which are of type struct point <sil=0.933> .PERIOD What about p t s 6 <sil=0.878> ?QUESTIONMARK It is an array of size 6 where each element in the array is of type struct point <sil=0.916> .PERIOD So <sil=0.496> ,COMMA to visualize it <sil=0.523> ,COMMA you would imagine that it is like this <sil=0.991> .PERIOD There are six cells <sil=0.985> .PERIOD Each cell contains a struct point <sil=0.959> .PERIOD So <sil=0.383> ,COMMA each cell will have two fields x and y <sil=0.951> .PERIOD Now <sil=0.348> ,COMMA how do I assign values to these elements in the array <sil=0.997> ?QUESTIONMARK So <sil=0.545> ,COMMA you would write a loop for example of the following form <sil=0.952> .PERIOD So <sil=0.558> ,COMMA you would say for i equal to 0 i less than 6 i equal to i plus 1 and p t s i dot x equal to i <sil=0.962> .PERIOD So <sil=0.521> ,COMMA p t s i is the ith element in the array <sil=0.964> .PERIOD The elements in the array are of type struct point <sil=0.984> .PERIOD So <sil=0.609> ,COMMA p t s i will be a struct point variable and that variable has two fields x and y <sil=0.984> .PERIOD So <sil=0.632> ,COMMA I can say p t s i dot x equal to something i and p t s i dot y equal to i <sil=0.929> .PERIOD So <sil=0.610> ,COMMA at the end of execution of this loop <sil=0.564> ,COMMA the result will be of the following form p t s 0 is a structure and its x and y coordinate are 0 <sil=0.987> .PERIOD p t s 1 is another structure its x and y coordinates are 1 and so on <sil=0.951> .PERIOD So <sil=0.622> ,COMMA what is what are the characteristic features of an array that it contains cells which are continuously allocated <sil=0.900> .PERIOD So <sil=0.385> ,COMMA they will be allocated one after the other in memory and each cell is of the same type as the others in the same array <sil=0.915> .PERIOD So <sil=0.466> ,COMMA both those are maintained <sil=0.997> .PERIOD These structures will be stored one after the other in memory also everything in the array is a struct point <sil=0.909> .PERIOD So <sil=0.523> ,COMMA an array of structs is similar to an array of in except for the fact that within a cell you will have values that can have sub fields <sil=0.973> .PERIOD Now <sil=0.479> ,COMMA we will see what else can you do with structures <sil=0.910> ?QUESTIONMARK Just like a variable of a int data type <sil=0.630> ,COMMA you can return it from a function <sil=0.988> .PERIOD If you declare an int x <sil=0.625> ,COMMA you can say return x <sil=0.938> .PERIOD Now <sil=0.649> ,COMMA let us say can be write functions which can return struct point <sil=0.947> .PERIOD So <sil=0.345> ,COMMA the theme of this lecture is that user defined structures are treated by c pretty much the same way as the standard data types <sil=0.919> .PERIOD So <sil=0.332> ,COMMA the behavior should be consistent you should be able to return a value of a struct of type struct from a function <sil=0.921> .PERIOD Let us see an example <sil=0.932> .PERIOD So <sil=0.460> ,COMMA here the user defines a struct point and then when you run the program a user can give two integer values x and y and I want to create a point struct with sub fields x and y which the user has input <sil=0.974> .PERIOD So <sil=0.359> ,COMMA I have written a function called make point <sil=0.371> ,COMMA make point takes two arguments int x and int y and what it returns is a variable of type struct point <sil=0.901> .PERIOD So <sil=0.523> ,COMMA this is the return type of the this whole name is basically the return type of the function the name of the function is make point <sil=0.980> .PERIOD Now <sil=0.428> ,COMMA how do you define it <sil=0.991> ?QUESTIONMARK So <sil=0.602> ,COMMA for example <sil=0.573> ,COMMA you can define a variable temp of type struct point and then say temp dot x equal to x temp dot y equal to y and return temp <sil=0.938> .PERIOD Now <sil=0.481> ,COMMA if you forget about this code particular code if temp had been an int variable you would say return temp if the function was of return type int <sil=0.999> .PERIOD Here it is the function is returning struct point and you would do it exactly in the same way as a function returning int <sil=0.920> .PERIOD So <sil=0.427> ,COMMA what else can you do with a normal data type <sil=0.866> ?QUESTIONMARK You could for example <sil=0.545> ,COMMA pass it as a parameter to a function <sil=0.982> .PERIOD So <sil=0.586> ,COMMA if you have int variables you can pass functions taking int arguments <sil=0.927> .PERIOD Similarly <sil=0.546> ,COMMA can you write functions taking struct parameters and we will see that this can be done <sil=0.969> .PERIOD So <sil=0.488> ,COMMA we will take an example that is fairly easy to understand <sil=0.925> .PERIOD So <sil=0.431> ,COMMA you take a point p and calculate the norm of the point p <sil=0.961> .PERIOD So <sil=0.457> ,COMMA what is the norm of the point p <sil=0.861> ?QUESTIONMARK The norm of a point x y in the Euclidean plane is simply square root of x square plus y square <sil=0.907> .PERIOD So <sil=0.505> ,COMMA you just have to calculate a function which does this <sil=0.944> .PERIOD For this we will use the math library in c <sil=0.921> .PERIOD So <sil=0.570> ,COMMA I will say include math dot h and then I will define a function norm of struct point p <sil=0.982> .PERIOD So <sil=0.650> ,COMMA let us call this norm 2 and let us ignore y it is called norm 2 <sil=0.902> .PERIOD So <sil=0.361> ,COMMA it is just a function that takes a point p and calculates the norm of p <sil=0.914> .PERIOD So <sil=0.417> ,COMMA for this what do I do <sil=0.881> ?QUESTIONMARK I will say that return square root <sil=0.976> .PERIOD So <sil=0.559> ,COMMA sqrt is the square root function provided by math dot h <sil=0.979> .PERIOD So <sil=0.649> ,COMMA return square root of p dot x star p dot x plus p dot y star p dot y <sil=0.941> .PERIOD So <sil=0.583> ,COMMA the in the main what you would do is Euclidean gives an input x and an input y <sil=0.940> .PERIOD You make a point using the earlier function that we wrote make point x y <sil=0.938> .PERIOD So <sil=0.318> ,COMMA p t will be a point with x coordinate x and y coordinate y <sil=0.974> .PERIOD Now <sil=0.345> ,COMMA for that point p t you define norm 2 of p t <sil=0.933> .PERIOD So <sil=0.316> ,COMMA norm 2 of p t here you would pass a point a struct point as a parameter and the function would calculate the norm of the point and return the norm <sil=0.911> .PERIOD So <sil=0.351> ,COMMA the way you pass a structure is the same as the way you would pass an int or a character or something <sil=0.971> .PERIOD Now <sil=0.609> ,COMMA let us take the game a bit further <sil=0.964> .PERIOD You know that I can you know that you can define structures whose sub fields are standard c data types <sil=0.999> .PERIOD Now <sil=0.384> ,COMMA if Euclidean defined data types Euclidean defined structures are of the same category as standard data types <sil=0.586> ,COMMA then I should be able to define structures whose internal fields are themselves structures <sil=0.986> .PERIOD So <sil=0.611> ,COMMA we have seen structures whose internal fields can be basic data types <sil=0.984> .PERIOD Now <sil=0.414> ,COMMA we will see structures whose internal fields are structures themselves <sil=0.994> .PERIOD So <sil=0.318> ,COMMA let us look at a very reasonable use case in which this can be occurring <sil=0.910> .PERIOD So <sil=0.602> ,COMMA suppose you want to extend your geometry package and you want to define a rectangle <sil=0.988> .PERIOD Now <sil=0.519> ,COMMA a rectangle is defined by 2 points <sil=0.506> ,COMMA 2 diagonally opposite points <sil=0.966> .PERIOD Let us say the left bottom and the right top these 2 points define a rectangle <sil=0.951> .PERIOD So <sil=0.552> ,COMMA the bottom and the right top are themselves points <sil=0.974> .PERIOD So <sil=0.370> ,COMMA they have sub fields which are x coordinate and y coordinate <sil=0.985> .PERIOD So <sil=0.432> ,COMMA this is how you would imagine the picture R is a rectangle <sil=0.993> .PERIOD It has 2 points left bottom and right top and this left bottom and right top themselves have 2 sub fields x and y <sil=0.991> .PERIOD So <sil=0.332> ,COMMA this is the composite picture <sil=0.916> .PERIOD Now <sil=0.642> ,COMMA how do I manipulate this rectangle <sil=0.889> ?QUESTIONMARK How do I say that this rectangle is left bottom is the point 11 <sil=0.870> ?QUESTIONMARK Suppose <sil=0.581> ,COMMA I want to say something like this <sil=0.970> .PERIOD So <sil=0.513> ,COMMA again you would use the dot notation <sil=0.978> .PERIOD So <sil=0.592> ,COMMA it is a very consistent representation <sil=0.913> .PERIOD So <sil=0.632> ,COMMA I would say that in the inside the code mean I would say struct rect R and then I would say R dot left bottom dot x equal to 0 <sil=0.937> .PERIOD This says that the take the left bottom sub field of R <sil=0.976> .PERIOD Now <sil=0.597> ,COMMA since that is a structure R dot left bottom itself has sub fields which is x and y <sil=0.928> .PERIOD It is x coordinate is assigned to 0 <sil=0.977> .PERIOD Similarly <sil=0.536> ,COMMA R dot left bottom dot y equal to 0 and so on <sil=0.939> .PERIOD So <sil=0.331> ,COMMA I will say that this rectangle's left bottom is 0 and is 0 0 and its right top is 11 <sil=0.912> .PERIOD So <sil=0.620> ,COMMA after running this code this is the state of the memory <sil=0.957> .PERIOD So <sil=0.486> ,COMMA I will have a rectangle R and it is left bottom dot x is 0 <sil=0.981> .PERIOD It is left bottom dot y is 0 <sil=0.945> .PERIOD It is right top dot x is 1 and it is right top dot x dot y is 1 <sil=0.922> .PERIOD Now <sil=0.472> ,COMMA we will also see how to initialize structures <sil=0.969> .PERIOD So <sil=0.634> ,COMMA we know that normal basic data types like int <sil=0.442> ,COMMA care and all that when you declare a variable you can also initialize it <sil=0.912> .PERIOD Can you initialize a user defined structure in this way <sil=0.939> ?QUESTIONMARK So <sil=0.357> ,COMMA the way you define it is similar to the way you define you initialize arrays <sil=0.996> .PERIOD So <sil=0.326> ,COMMA initializing structures is very similar to initializing arrays and close all the values of the fields in braces <sil=0.950> .PERIOD And the values are given in the same order that you they are defined in the structure <sil=0.977> .PERIOD Suppose you have struck point int x and in y how would I initialize it <sil=0.973> ?QUESTIONMARK I would say struck point p equal to 0 0 <sil=0.904> .PERIOD So <sil=0.639> ,COMMA this means that the first field in point that is x is assigned 0 <sil=0.975> .PERIOD The second field that is y is assigned 0 as well <sil=0.991> .PERIOD Similarly <sil=0.396> ,COMMA if I say struck point q equal to 1 1 it says q dot x equal to 1 and q dot y equal to 1 <sil=0.933> .PERIOD Now <sil=0.527> ,COMMA you can do the same thing with nested structures <sil=0.984> .PERIOD So <sil=0.608> ,COMMA this is very nice <sil=0.917> .PERIOD So <sil=0.618> ,COMMA if I want to define a rectangle remember that a rectangle has two fields which are themselves structures their points <sil=0.956> .PERIOD So <sil=0.614> ,COMMA if I say r equal to 0 0 within braces comma 1 1 within braces <sil=0.925> .PERIOD What happens is that r first field which is the left bottom it will get the value 0 0 that means that it is the left bottom sub field x will get 0 and the left bottom are y will get 0 <sil=0.990> .PERIOD Similarly <sil=0.577> ,COMMA r second field is the right top it will get 1 1 <sil=0.904> .PERIOD So <sil=0.466> ,COMMA right top dot x will be 1 and right top dot y will be 1 as well <sil=0.996> .PERIOD So <sil=0.346> ,COMMA this is how you would initialize and initialize a structure as very similar to initializing an array <sil=0.995> .PERIOD The only thing to remember is that the values must be given in the same order that they are declared in the type declaration <sil=0.964> .PERIOD Now <sil=0.527> ,COMMA we know that variables can be assigned to other variables <sil=0.937> .PERIOD So <sil=0.421> ,COMMA a natural question is can struck variables be assigned to struck variables and the answer is yes <sil=0.905> .PERIOD Suppose you have a rectangle r whose left bottom is 0 0 you either initialize it or you assign the values and its right top is 1 1 <sil=0.937> .PERIOD So <sil=0.317> ,COMMA I define another variable s which is also a rectangle and if I say s equal to r let us see what happens <sil=0.906> .PERIOD So <sil=0.496> ,COMMA before the assignment r is as follows <sil=0.969> .PERIOD So <sil=0.314> ,COMMA you have x 0 0 x y 0 0 and x y 1 1 left bottom and the right top and s is uninitiated it has just been declared but no value has been assigned to it <sil=0.932> .PERIOD So <sil=0.633> ,COMMA this is the state before the assignment <sil=0.916> .PERIOD When you do s equal to r it is very nice what it does is s is left bottom dot x will be assigned 0 s is left bottom dot y will be assigned 0 s is right top dot x will be assigned 1 and dot y will be assigned 1 <sil=0.986> .PERIOD So <sil=0.503> ,COMMA what happens is it goes into the structure r and copies it entirely in its full depth into s <sil=0.906> .PERIOD So <sil=0.313> ,COMMA it is not just that left bottom right top or copied its internal fields are also copied into s <sil=0.913> .PERIOD s is left bottom dot x will be assigned 1 and dot y will be assigned 1 and dot y will be assigned 1 and dot y will be assigned 1 and dot y will be assigned 1 and dot y will be assigned <sil=0.993> .PERIOD Today's video we will talk about an important concept in computer science which is recursion <sil=0.955> .PERIOD And we will slowly approach this by looking at various kinds of recursion <sil=0.903> .PERIOD Now recursion is usually something that is completely new <sil=0.941> .PERIOD It is a new way of thinking about problems that might sound unfamiliar at first <sil=0.983> .PERIOD But eventually it is a more natural way of solving problems than other techniques <sil=0.986> .PERIOD So we will carefully examine what recursion means <sil=0.937> .PERIOD So this is the video of a media player having itself inside having a copy of itself inside the video and it goes on forever <sil=0.902> .PERIOD And we will see what dusters have to do with recursion <sil=0.954> .PERIOD So recursion in English means roughly say again and functions defined in terms of itself are called recursive functions <sil=0.994> .PERIOD Now this is not completely accurate <sil=0.970> .PERIOD We want to say that functions defined in terms of itself in a particular way <sil=0.962> .PERIOD These are valid recursions <sil=0.939> .PERIOD One is a powerful tool for program construction and for thinking about and reasoning about functions in general <sil=0.945> .PERIOD So it is a general purpose technique of programming and you can do any kind of program using only just recursion <sil=0.914> .PERIOD We will not see such general types of recursion in this course but we will see fairly common examples of recursions <sil=0.947> .PERIOD So for example let us consider a very simple function which will search for a key within a given array <sil=0.984> .PERIOD And we know how to write this <sil=0.948> .PERIOD What I will do is I will take an integer initialized it to 0 for i equal to 0 to n <sil=0.926> .PERIOD n is the size of the array <sil=0.955> .PERIOD I will increment i <sil=0.995> .PERIOD And if at any i I find the key I will return 1 indicating that I have found the key <sil=0.901> .PERIOD If I have not found the key and I have reached the end of the array I will return minus 1 <sil=0.942> .PERIOD This is a typical way to search for a key inside a given array <sil=0.996> .PERIOD Now we will approach the idea of recursion by looking at a recursive solution to this <sil=0.969> .PERIOD Hopefully while seeing this program we will get an idea of what recursion means <sil=0.986> .PERIOD So what do we mean by a recursive solution to this rather than defining it and describing abstract properties of recursion <sil=0.920> .PERIOD Why not let us write an actual program which is defined in a recursive manner and through these kind of examples we will eventually get the hang of recursion <sil=0.904> .PERIOD We have to write a function search <sil=0.960> .PERIOD It will return whether a key is found or not <sil=0.991> .PERIOD If the key is found it returns a 1 <sil=0.906> .PERIOD If the key is not found it returns a minus 1 <sil=0.962> .PERIOD And you have to search an array a of size n for the key <sil=0.964> .PERIOD Now we have written this function just now using loops <sil=0.987> .PERIOD Now let us write this using recursion <sil=0.981> .PERIOD Now what do we mean by solving it in recursive <sil=0.886> ?QUESTIONMARK We have to think of the function search in terms of the same function applied to a smaller instance of the problem <sil=0.967> .PERIOD So we have to solve the problem of searching for a key in an array of size n <sil=0.905> .PERIOD Can we think of this in terms of solving the sub problem for a smaller array <sil=0.938> ?QUESTIONMARK This is the basic question that you have to ask when you want to design a recursive function <sil=0.941> .PERIOD So let us try to in very abstract terms think of how to solve this in recursive manner <sil=0.902> .PERIOD So let us say that I will in some unspecified syntax <sil=0.924> .PERIOD This is not going to be valid C but this is just so that we see the idea in a very clear manner <sil=0.961> .PERIOD I have to search for an array of size a of size n for key <sil=0.946> .PERIOD Now if the array is empty that is n is equal to 0 <sil=0.912> .PERIOD You can have more conditions here n can be less than 0 as well <sil=0.907> .PERIOD But let us say that empty array is n is equal to 0 <sil=0.953> .PERIOD Then you say that I have not found the key because it is an empty array <sil=0.988> .PERIOD So you give back the value minus 1 <sil=0.978> .PERIOD So n equal to 0 implies the value to be returned is minus 1 <sil=0.953> .PERIOD That is what this notation is supposed to stand for <sil=0.965> .PERIOD Suppose n is not 0 <sil=1.000> .PERIOD So this means that the array is non empty <sil=0.910> .PERIOD Now how do we solve this recursively <sil=0.892> ?QUESTIONMARK So we look for the first element whether it is the key or not <sil=0.976> .PERIOD If the first element is the key we do not have to do anything further <sil=0.927> .PERIOD We know that the key is present in the array so you return 1 <sil=0.980> .PERIOD So the key has been found and you return 1 <sil=0.965> .PERIOD And now is the big step for recursion <sil=0.974> .PERIOD How can we search for the key in an array of size smaller than n <sil=0.881> ?QUESTIONMARK So if a 0 is not equal to key then this means that key can be somewhere in a 1 through a n minus 1 or it is not absent in the array <sil=0.907> .PERIOD In any case what we now have to do is search for the array starting at a 1 <sil=0.949> .PERIOD So by a 1 this is not strictly c notation <sil=0.946> .PERIOD What I mean is the sub array starting at a plus 1 <sil=0.954> .PERIOD So search in the sub array starting at a plus 1 <sil=0.948> .PERIOD Now the sub array has one element less because we already know if we are here that a 0 is not equal to key <sil=0.967> .PERIOD So there are only n minus 1 elements in the smaller sub problem <sil=0.903> .PERIOD And what do we have to search for <sil=0.904> ?QUESTIONMARK We have to search for the key <sil=0.913> .PERIOD So this says that either the key is present as the first element of the array or you have to solve the sub problem of searching in the sub array of size n minus 1 for the same key <sil=0.993> .PERIOD So here is the key to thinking about a problem in recursive terms <sil=0.947> .PERIOD What you first do is consider the case when you have the trivial array which is the empty array in this case <sil=0.903> .PERIOD So we have the base case and then these are the recursive case <sil=0.962> .PERIOD So the recursive case consists of doing something at size n <sil=0.996> .PERIOD So in this case it is search whether the first element is the key or not <sil=0.997> .PERIOD If it is true then we do not have to do anything further we have found the key <sil=0.980> .PERIOD Otherwise solve the sub problem <sil=0.960> .PERIOD Now the sub problem is a smaller copy of the old problem <sil=0.986> .PERIOD So this is what is known as the inductive case or the recursive case <sil=0.905> .PERIOD The reason I am calling it is inductive case is that recursion has very tight connections to the idea of mathematical induction <sil=0.903> .PERIOD If you know how to write a proof by mathematical induction what you normally do is you consider a base case <sil=0.971> .PERIOD So you have a theorem and you want to prove this by mathematical induction <sil=0.947> .PERIOD You consider the base case probably n equal to 1 or n equal to 0 <sil=0.991> .PERIOD These will be the base cases for an assertion about natural numbers <sil=0.940> .PERIOD And then if the base case is true then you say that I assume that the problem is true for size n and now I want to prove that the theorem is true for size n plus 1 <sil=0.955> .PERIOD This is how a mathematical induction proof looks like <sil=0.912> .PERIOD And in the case of a recursive program there is a very tight analogy <sil=0.907> .PERIOD The recursion in fact is just mathematical induction in the context of writing programs <sil=0.991> .PERIOD We have to solve a problem <sil=0.959> .PERIOD What we will see what is the problem in the base case <sil=0.912> ?QUESTIONMARK The base case is a very trivial case usually but it is important that you think about the base case <sil=0.902> .PERIOD You say that if the array is empty then I will return minus 1 because the key cannot be in the array <sil=0.960> .PERIOD Then you say that I will now define the problem of size n in terms of a sub problem of size n minus 1 for example <sil=0.990> .PERIOD So we will solve the bigger problem in terms of a smaller copy of itself and this is the key to thinking about recursive programs <sil=0.964> .PERIOD Let us code this in C <sil=0.937> .PERIOD So we code this in a very straightforward manner <sil=0.928> .PERIOD I will write in search int a which is the size of the array a int key which is the size the key we are searching for <sil=0.936> .PERIOD If n equal to 0 then return minus 1 because the key is not found this is the base case <sil=0.965> .PERIOD And if otherwise n is greater than 0 so you can search for a equal to a 0 is equal to key or not <sil=0.932> .PERIOD So you can search for whether the first element is the key <sil=0.920> .PERIOD If it is then you have found the key <sil=0.922> .PERIOD Otherwise what you do is you call search a plus 1 which is the sub array starting at size 1 <sil=0.994> .PERIOD The sub array has size n minus 1 and key <sil=0.920> .PERIOD So when you search when you write a recursive program there are a few things that you want to check <sil=0.902> .PERIOD The first is that the base case is properly handled <sil=0.920> .PERIOD The second is that when you define the sub problem you want to ensure that it really is a sub problem because if you solve the problem in terms of an equal size problem or even a bigger size problem your program may not terminate <sil=0.952> .PERIOD We will see this in a moment <sil=0.957> .PERIOD So this part which is highlighted in green which is calling search itself but on a smaller sub problem this is a plus 1 and minus 1 <sil=0.909> .PERIOD This is what is known as a recursive call to the same function <sil=0.932> .PERIOD So we have seen functions that can call other functions <sil=0.921> .PERIOD Now we are seeing functions which can call themselves and this is what is known as recursion <sil=0.935> .PERIOD Let us see how this function behaves <sil=0.960> .PERIOD Now before we go into the execution trace of this function I want to add a word of caution <sil=0.995> .PERIOD The actual way to understand recursion is not to think about the stack and how functions are calling other functions <sil=0.977> .PERIOD The real way to understand recursion is to think about this program as a problem defined in terms of sub instance <sil=0.929> .PERIOD But in any case we will just see the execution of this function through the stack trace just to get comfortable with what happens at the back of all of this <sil=0.994> .PERIOD So let us do a quick trace <sil=0.939> .PERIOD Suppose we have an array 31 <sil=0.420> ,COMMA 4 <sil=0.552> ,COMMA 10 <sil=0.467> ,COMMA 35 <sil=0.407> ,COMMA 59 <sil=0.948> .PERIOD It is an array of size 5 named A and we are searching for the key 3 <sil=0.987> .PERIOD Now we know that this key is not present in the array <sil=0.959> .PERIOD But let us see how the function executes <sil=0.948> .PERIOD So first we call search A53 <sil=0.966> .PERIOD A0 is 31 which is not the key <sil=0.950> .PERIOD So it calls search A plus 1 <sil=0.416> ,COMMA 4 because now we are searching in the sub array of size 4 for the same key <sil=0.944> .PERIOD So that is in effect the same as calling the same search function on this sub array highlighted in gray <sil=0.900> .PERIOD This is because the answer to search in the whole array is now the same as answer to the search in the sub array <sil=0.972> .PERIOD That is what the recursive statement is <sil=0.937> .PERIOD Now A plus 1 of 0 is 4 <sil=0.972> .PERIOD This is the first element of the sub array <sil=0.987> .PERIOD Now 4 is not 3 <sil=0.906> .PERIOD And at this point you call the sub sub problem which is search A plus 2 the sub array of size 3 for the key 3 <sil=0.959> .PERIOD Here is the sub array of size 3 and you are searching for 3 in this sub array <sil=0.964> .PERIOD Again the first element of the array is 10 which is not 3 <sil=0.993> .PERIOD So you call the sub problem of this which is A plus 3 <sil=0.944> .PERIOD Now the array is of size 2 and you will search for 3 <sil=0.993> .PERIOD And this goes on until you find that you have exhausted the array and finally the array is of size 0 <sil=0.977> .PERIOD You will finally say that since the array is of size 0 I have not found the key so you return minus 1 <sil=0.984> .PERIOD Now let us just look at this stack of function calls and see how it looks like <sil=0.900> .PERIOD Search A 5 3 is called by main and let us say that it has some return address <sil=0.948> .PERIOD We do not care about it right now <sil=0.932> .PERIOD But search A 5 3 calls search A plus 1 4 3 and the place to return is some line in search function <sil=0.962> .PERIOD This calls the sub sub problem A plus 2 3 that calls A plus 3 2 that calls A plus 4 1 and that calls A plus 5 0 at which point you realize that the sub problem now is empty <sil=0.936> .PERIOD And then you return a minus 1 <sil=0.921> .PERIOD So at this point you have reached the base case if n equal to 0 return minus 1 <sil=0.914> .PERIOD So that will return a minus 1 <sil=0.925> .PERIOD Where will it return to <sil=0.860> ?QUESTIONMARK It will return to the function which immediately called it which is search A plus 4 1 3 <sil=0.971> .PERIOD So this guy gets a minus 1 therefore and it just returns that minus 1 <sil=0.907> .PERIOD And the value of whatever is returned by the sub problem <sil=0.996> .PERIOD So it is minus 1 and that minus 1 gets returned <sil=0.910> .PERIOD So it gets bubbled up all the way back to main and main you can realize that the element is not present in the array because the return value of search A 5 3 was minus 1 <sil=0.907> .PERIOD And this point the call stack terminates <sil=0.965> .PERIOD So what was special about the recursion call stack <sil=0.869> ?QUESTIONMARK It was just that most of the stack was involved by a function calling itself over and over <sil=0.971> .PERIOD But each time the function called itself it was calling on a smaller version of the problem <sil=0.917> .PERIOD And here is how you think about a very simple program in terms of recursion <sil=0.920> .PERIOD Earlier we saw how to solve this using iteration which was using a loop and we have seen the problem how to be solved using recursion <sil=0.945> .PERIOD Now a word of caution we will see this in further examples <sil=0.947> .PERIOD It is very important that you handle the base case properly <sil=0.944> .PERIOD Now this is something that we are not used to in normal way of thinking <sil=0.998> .PERIOD When we think about solving a problem we are thinking about solving substantial sizes of the problems <sil=0.948> .PERIOD We are not concerned too much with what happens with an empty array what happens when n is minus 1 and things like that <sil=0.995> .PERIOD But even in this problem we know that when we call search A plus 5 0 3 we know that the function terminated because we had a base case which said that if n equal to 0 then return minus 1 <sil=0.962> .PERIOD If we did not have this case you could see that probably it will go on calling itself infinite number of times <sil=0.945> .PERIOD So just like when you are writing a for loop or a while loop you have the case of infinite loops <sil=0.992> .PERIOD In the case of recursion you can have an infinite recursion and you have to guard against that <sil=0.925> .PERIOD The only way to guard against that is to get the base case correct <sil=0.953> .PERIOD So here is something counter intuitive about programming recursive functions <sil=0.949> .PERIOD You know almost half of your intellectual effort is in handling the base case properly and only the remaining is in involved in solving the recursive case <sil=0.939> .PERIOD In this session we will write another algorithm to solve a mathematical problem <sil=0.940> .PERIOD If you do not know this algorithm already that is fine <sil=0.306> ,COMMA it is more for the purpose of demonstrating if you know a solution how do you come up with the algorithm to tell a computer how to solve it <sil=0.977> .PERIOD The algorithm is for finding the greatest common device or the highest common factor it is known under two names of two positive integers M and N <sil=0.901> .PERIOD So <sil=0.461> ,COMMA this is an algorithm you probably know <sil=0.916> .PERIOD How do you solve this <sil=0.986> ?QUESTIONMARK Let us first try naive solution and before writing an algorithm let us see what do I mean by the simple solution of GCD <sil=0.979> .PERIOD So <sil=0.306> ,COMMA you are asked to find the greatest common divisor of M and N <sil=0.523> ,COMMA take the smaller number N and now you start looking for each number K between 1 and N remember that N is the smaller number in descending order do the following <sil=0.937> .PERIOD What you do is if K divides M and N then K is the greatest common divisor of M and N and this is obvious by the definition of greatest common divisor <sil=0.986> .PERIOD If K divides M and N then it is obviously a divisor of M and N also we are coming in descending order we start from N and go down to N <sil=0.915> .PERIOD So <sil=0.410> ,COMMA the first divisor that you hit when you go down is going to be the greatest common divisor of M and N <sil=0.937> .PERIOD So <sil=0.580> ,COMMA this algorithm obviously works it will compute the GCD correctly but it is very slow and think about very large numbers M and N and you will see that it may go N steps before reaching the correct GCD <sil=0.942> .PERIOD So <sil=0.520> ,COMMA compute the GCD of two very large numbers which are relatively prime to each other that means that the GCD of M and N are 1 <sil=0.980> .PERIOD Now <sil=0.621> ,COMMA if you pick such a pair this algorithm will compute the GCD correctly but it will take N steps because you have to go down all the way from N to 1 before you will hit the GCD <sil=0.941> .PERIOD Can we do better <sil=0.894> ?QUESTIONMARK There is a faster way and it is a very old algorithm the algorithm is due to Euclid we will see a slightly modified version of that algorithm <sil=0.930> .PERIOD So <sil=0.640> ,COMMA before we go into Euclid's algorithm for GCD we will describe what it does and give you a slight intuition of why it works <sil=0.912> .PERIOD So <sil=0.346> ,COMMA consider the GCD of 8 and 6 <sil=0.998> .PERIOD Now <sil=0.443> ,COMMA you can consider two rods one of length 8 and another of length 6 <sil=0.941> .PERIOD Now <sil=0.546> ,COMMA obviously if a number divides 6 and 8 then I should be able to make a stick of that length so that I can measure 6 exactly with that shorter rod and I can measure 8 exactly with that shorter rod <sil=0.947> .PERIOD This is the meaning of a common divisor and we have to find the greatest common divisor <sil=0.964> .PERIOD So <sil=0.553> ,COMMA first what we will do is we will measure the shorter we will measure the longer rod using the shorter rod <sil=0.993> .PERIOD Now <sil=0.507> ,COMMA it may not measure the longer rod exactly for example in this case 6 does not measure 8 exactly there will be a small piece of length 2 left over <sil=0.940> .PERIOD So <sil=0.467> ,COMMA take that remainder and now repeat the process now 2 has become the shorter rod and 6 has become the longer rod <sil=0.927> .PERIOD Now <sil=0.570> ,COMMA see if 2 measures 6 exactly it does so you are done and then you can say that 2 is the GCD of 8 and 6 <sil=0.975> .PERIOD The reason why this works is by the nature of this algorithm it is clear that 2 divides 6 because that is why we stop the algorithm and also we know that 8 is basically 6 plus 2 <sil=0.936> .PERIOD So <sil=0.647> ,COMMA it is obviously a multiple of 2 <sil=0.901> .PERIOD So <sil=0.594> ,COMMA it is a common divisor and with a slightly more elaborate argument we can argue that it is the greatest common divisor <sil=0.939> .PERIOD So <sil=0.568> ,COMMA this is an algorithm which is essentially due to Uplit <sil=0.923> .PERIOD So <sil=0.348> ,COMMA it was known for at least 2000 years <sil=0.944> .PERIOD Let us pick a slightly more elaborate example <sil=0.904> .PERIOD Let us say we want to find the GCD of 102 and 21 <sil=0.962> .PERIOD The process of taking remainder is what is known as the modulo operator in mathematics <sil=0.978> .PERIOD So <sil=0.570> ,COMMA 102 modulo 21 is the remainder of integer division of 102 by 21 <sil=0.967> .PERIOD So <sil=0.502> ,COMMA the remainder of when you divide 102 by 21 is 18 <sil=0.988> .PERIOD So <sil=0.621> ,COMMA that is the shorter rod for the next stage <sil=0.904> .PERIOD Now <sil=0.453> ,COMMA 21 mod 18 is 3 and that becomes the rod for the next stage the shorter rod for the next stage and 18 mod 3 is 0 that is when you stop the algorithm <sil=0.950> .PERIOD So <sil=0.450> ,COMMA when the modulo operator gives you 0 result that means that the shorter number exactly divides the larger number that means that the shorter number is a divisor of the larger number and you stop the algorithm <sil=0.964> .PERIOD Now <sil=0.608> ,COMMA you say that GCD of 102 and 21 is 3 <sil=0.991> .PERIOD So <sil=0.539> ,COMMA this is a slight modification of the classical Uplits method for GCD and so it is based on the following simple fact which we have described and you can prove this mathematically as well <sil=0.909> .PERIOD So <sil=0.630> ,COMMA suppose you take two positive numbers A and B where A is the larger number <sil=0.970> .PERIOD Then GCD of A and B is the same as GCD of A <sil=0.548> ,COMMA GCD of B and the remainder when you divide A by B <sil=0.986> .PERIOD So <sil=0.332> ,COMMA it is written by the equation GCD of A B is GCD of B comma A modulo B <sil=0.981> .PERIOD The modulo operator is represented as the percentage sign because this is the convention that we will use in C and this equation can be seen by our previous slide A was the bigger rod <sil=0.505> ,COMMA B was the shorter rod <sil=0.913> .PERIOD This was the first stage the second stage was when B is the shorter rod and the shorter rod for the next stage is modulo is given by the modulo operator <sil=0.916> .PERIOD To prove this you can start by considering the division of A by B and writing A as B times Q plus R <sil=0.639> ,COMMA but we will not go into the proof <sil=0.996> .PERIOD From elementary properties of natural numbers it is possible to prove that Uplits method correctly computes the GCD <sil=0.902> .PERIOD Right now we will move into how do we write the GCD algorithm in the form of an input <sil=0.957> .PERIOD So <sil=0.598> ,COMMA here is a slightly abbreviated picture <sil=0.972> .PERIOD I have skipped the start state <sil=0.602> ,COMMA but the start state is there <sil=0.930> .PERIOD Let us focus on what happens during the algorithm <sil=0.990> .PERIOD You have two numbers A and B <sil=0.906> .PERIOD The first thing to ensure is that A is the larger number <sil=0.998> .PERIOD The reason we do that is that if A is the larger number then the modulo operator is properly defined <sil=0.939> .PERIOD So if A is the larger number then we are fine we can go into the GCD algorithm <sil=0.928> .PERIOD If A is not the larger number you merely swap A and B so that whatever is the larger number you call it A <sil=0.939> .PERIOD So exchange A and B means that you say that the value of A is stored in a temporary variable then the value of B is stored in A and then the value of B is stored in T <sil=0.393> ,COMMA the value of T is stored in B <sil=0.923> .PERIOD So here is a way to exchange the values of A and B <sil=0.970> .PERIOD So ensure at first that A is the larger number <sil=0.913> .PERIOD Once you do that you get into the code for the proper Euclidean GCD <sil=0.967> .PERIOD First you test whether B is 0 <sil=0.974> .PERIOD If B is 0 then there is nothing to do A is the GCD of A and B <sil=0.955> .PERIOD GCD of 4 <sil=0.343> ,COMMA 0 is 4 <sil=0.602> ,COMMA GCD of 8 <sil=0.535> ,COMMA 0 is 8 and so on <sil=0.968> .PERIOD So if the smaller number is 0 then there is nothing to do in the algorithm <sil=0.942> .PERIOD The algorithm is over and you say that print A <sil=0.976> .PERIOD If B is not 0 then we do the Euclidean equation <sil=0.981> .PERIOD You take A modulo B <sil=0.519> ,COMMA store it in a variable G then assign the value of B to A and assign the value of B to A and assign the value of G to B <sil=0.907> .PERIOD So this corresponds to the operation of taking B and A modulo B as the next step <sil=0.991> .PERIOD After you do that you again test the condition whether B has now become 0 <sil=0.902> .PERIOD If it is 0 then we are done and A is the GCD <sil=0.991> .PERIOD Otherwise we do another round of taking A modulo B and setting A equal to B and B equal to G <sil=0.952> .PERIOD So A B and G are what are known as variables and variables are used in programming to store exactly one value at a time <sil=0.992> .PERIOD So at any particular time it will have one value then after the execution of another instruction it will have a new value and so on <sil=0.915> .PERIOD Now for the purposes of describing an algorithm imagine that the variable is a box and it is the name of a box and the value is stored inside the box <sil=0.978> .PERIOD For example A <sil=0.339> ,COMMA B and G are the variables that we have used in the program and they are the names for these integer boxes <sil=0.990> .PERIOD So if you are computing let us say the GCD of 5 and 3 then you might start with A equal to 5 and B equal to 3 <sil=0.975> .PERIOD The second operation that we have used in the code is the assignment operation <sil=0.906> .PERIOD So this is what an example of the assignment operator and when we do an assignment what we mean is that you take the left variable which is G in this case and assign it the value of what is the expression on the right hand side which is A mod L O B <sil=0.987> .PERIOD So assignment A equal to B replaces whatever is stored in A by what is stored in B <sil=0.919> .PERIOD So take the right hand side <sil=0.404> ,COMMA take the value of that and put it into the variable that the left hand side represents <sil=0.940> .PERIOD For example if A was 5 and B is 3 then we have to say that after A equal to B you would take the value of B and put it in A <sil=0.958> .PERIOD So A will now become 3 and B will remain 3 <sil=0.933> .PERIOD Another small thing that we have used in the code is sequential assignment <sil=0.956> .PERIOD So if you write a bunch of statements one after the other let us say separated by semi-colons then this means that the instructions are to be executed one after the other in sequence <sil=0.928> .PERIOD So first you do G equal to A mod L O B then you do A equal to B and after that you do B equal to G <sil=0.948> .PERIOD So initially let us say that A is 10 and B is 6 G is undefined <sil=0.925> .PERIOD After you run the statement G equal to A mod L O B you take 10 mod L O 6 you will have 4 and then A equal to B the value of B will be stored in A so A becomes 6 and then B equal to G the value of G will be stored in B so B will become 4 <sil=0.915> .PERIOD Now let us just dry run the program on the algorithm and see how it computes the GCD of 2 numbers <sil=0.998> .PERIOD So I will denote the currently executing statement with an icon and I will call this the program counter so this is at any point it is the next step to be executed <sil=0.991> .PERIOD Initially it is at the beginning of the code where you take the input and we will have 3 variables which will represent the current state of a program <sil=0.970> .PERIOD So suppose you want to compute the GCD of 8 and 6 so you have A equal to 8 B equal to 6 you know that is greater than B so you proceed <sil=0.910> .PERIOD Now you test whether B is 0 <sil=0.948> .PERIOD So since B is non-zero you go into the main body of the loop <sil=0.941> .PERIOD So you do G equal to A mod L O B A equal to B equal to G this step once so you will end up with A is now 6 B is 2 and G is 2 <sil=0.987> .PERIOD You again come back to the decision and test whether B is 0 or not B is not 0 <sil=0.904> .PERIOD So you will get the go back into the body of the loop again <sil=0.937> .PERIOD So you have G to be A mod L O B so 6 mod L O 2 should be 0 and then you do A equal to B and B equal to G you will have A equal to 2 B equal to 0 and G equal to 0 <sil=0.968> .PERIOD At this point B is now 0 so you say that A is actually the GCD of the numbers of the of the numbers 8 and 6 <sil=0.950> .PERIOD So you can ensure that it computes the GCD correctly <sil=0.938> .PERIOD Let us see a few more examples of expression evaluation in C <sil=0.947> .PERIOD What kind of expressions are allowed <sil=0.645> ,COMMA what kind of errors do people usually make and so on <sil=0.962> .PERIOD Let us say that we have given an expression A equal to 1 B equal to 1 C equal to 2 and then we have an expression A less than B and then B greater than or equal to C <sil=0.909> .PERIOD So <sil=0.541> ,COMMA this is the expression that we want to see how it will be evaluated <sil=0.919> .PERIOD So <sil=0.612> ,COMMA let us just go through it systematically <sil=0.909> .PERIOD The operations on are less than or equal to then we have the logical and operation and the greater than or equal to simple <sil=0.975> .PERIOD Of these the relational comparison operations less than or equal to and greater than or equal to have greater precedence over the logical and <sil=0.945> .PERIOD So <sil=0.393> ,COMMA the precedence will be and and among operations of the same precedence level we have left to right <sil=0.963> .PERIOD So <sil=0.447> ,COMMA whatever happens first when looking from left to right will be evaluated first <sil=0.930> .PERIOD So <sil=0.352> ,COMMA these two operations have the same precedence <sil=0.941> .PERIOD So <sil=0.459> ,COMMA we will have A less than or equal to B within parenthesis then B greater than or equal to C within parenthesis <sil=0.999> .PERIOD These have to be done first and then and <sil=0.911> .PERIOD So <sil=0.370> ,COMMA this will be done first <sil=0.556> ,COMMA this will be done second and this is the third operation <sil=0.959> .PERIOD Conceptually using just precedence and associativity rules this is how the expression should be evaluated <sil=0.989> .PERIOD So <sil=0.590> ,COMMA when we evaluate it A less than or equal to B is one less than or equal to one <sil=0.951> .PERIOD So <sil=0.570> ,COMMA that is one B greater than or equal to C is one greater than or equal to two <sil=0.941> .PERIOD So <sil=0.312> ,COMMA that is 0 <sil=0.912> .PERIOD So <sil=0.500> ,COMMA this becomes 1 and 0 in which case it is 0 <sil=0.936> .PERIOD Now <sil=0.373> ,COMMA let us look at a few tricky examples <sil=0.999> .PERIOD So <sil=0.506> ,COMMA if you have an expression of the following form if A equal to B greater than 1 then C equal to 1 <sil=0.916> .PERIOD So <sil=0.364> ,COMMA let us see what happens here we will do the same thing operations sorted by precedence is there is greater than symbol which has a higher precedence over the equal to symbol <sil=0.972> .PERIOD So <sil=0.342> ,COMMA the expression A equal to B greater than 1 will be evaluated as B greater than 1 because that has higher precedence <sil=0.951> .PERIOD So <sil=0.480> ,COMMA this goes first and then A equal to B greater than 1 <sil=0.939> .PERIOD Now <sil=0.325> ,COMMA B is 2 <sil=0.950> .PERIOD So <sil=0.407> ,COMMA B greater than 1 is 1 <sil=0.904> .PERIOD So <sil=0.523> ,COMMA you have A equal to 1 and A equal to 1 is an assignment expression it assigns the value 1 to A and the return value is 1 because A is assigned to 1 <sil=0.932> .PERIOD So <sil=0.485> ,COMMA then this whole expression becomes if 1 C equal to 1 in which case we know that C equal to 1 that statement will be executed <sil=0.915> .PERIOD So <sil=0.437> ,COMMA this is the expression B is 1 C equal to 1 <sil=0.988> .PERIOD So <sil=0.547> ,COMMA this is the expression B <sil=0.918> .PERIOD Now <sil=0.381> ,COMMA typically what is expected the typical programming style is to say something like A is assigned to B and if that result is greater than 1 <sil=0.934> .PERIOD So <sil=0.390> ,COMMA we may want to deliberately violate the precedence <sil=0.904> .PERIOD How do you do that <sil=0.925> ?QUESTIONMARK So <sil=0.517> ,COMMA C does it in some way if you do not parenthesis it you can always change the order of evaluation in C by introducing parenthesis <sil=0.983> .PERIOD So <sil=0.537> ,COMMA that the meaning is very clear <sil=0.946> .PERIOD So <sil=0.313> ,COMMA if you do not parenthesis it then A equal to B greater than 1 is the same as A equal to B greater than 1 <sil=0.987> .PERIOD But what if you really want to do A equal to B and then that greater than 1 <sil=0.914> .PERIOD So <sil=0.346> ,COMMA in that case you parenthesis I said why because parenthesis has the highest precedence <sil=0.959> .PERIOD So <sil=0.423> ,COMMA whatever is within parenthesis will be evaluated first <sil=0.997> .PERIOD So <sil=0.351> ,COMMA A equal to B will be evaluated first and B is 2 <sil=0.932> .PERIOD So <sil=0.388> ,COMMA A will get the value 2 <sil=0.986> .PERIOD So <sil=0.352> ,COMMA A will get the value 2 <sil=0.987> .PERIOD So <sil=0.376> ,COMMA the assignment A equal to B will have a return the value 2 and 2 is greater than 1 <sil=0.916> .PERIOD So <sil=0.439> ,COMMA it will be executed <sil=0.962> .PERIOD One particular way in which such an expression can be seen we have already seen such an example is you read all integers from the terminal until a minus 1 is read <sil=0.955> .PERIOD So <sil=0.348> ,COMMA suppose the input is of the form 3 2 minus 1 and then let us say dot or something of that sort <sil=0.968> .PERIOD So <sil=0.479> ,COMMA what this expression does is <sil=0.515> ,COMMA scan if returns a value which is the number of tokens that number of inputs that was it was successfully able to read <sil=0.948> .PERIOD So <sil=0.518> ,COMMA if you try to read a character as an integer it may not succeed <sil=0.926> .PERIOD And so <sil=0.363> ,COMMA as long as you have correctly written integer and the integer is not minus 1 then you do a particular loop <sil=0.954> .PERIOD So <sil=0.445> ,COMMA this is the kind of expression that is often used where you assign some value to A using the assignment statement or maybe you want to check the return value of a function whether it is positive or not and based on that you want to write a condition <sil=0.905> .PERIOD So <sil=0.328> ,COMMA the logical and operation does operates in the following way it evaluates the first the left operand first <sil=0.948> .PERIOD If this is the first condition is false then you know that the whole expression is going to be false if at least one of the terms is false then you know that the whole thing is false <sil=0.964> .PERIOD So <sil=0.449> ,COMMA it will not even evaluate the second operand <sil=0.904> .PERIOD On the other hand if the operation is true then it will check whether the second operand is true <sil=0.963> .PERIOD If the second operand is also true then the whole expression is true if the second operand is false then it is also then it is also then the whole expression is false <sil=0.932> .PERIOD This method of evaluation is also called short circuting because it may not evaluate the whole expression in order to get the result <sil=0.917> .PERIOD So <sil=0.382> ,COMMA if I know that this expression is false then there is no need to evaluate this because I know that the whole expression is going to be false <sil=0.946> .PERIOD Here is a common mistake that people do in the because this is similar to mathematical notation <sil=0.922> .PERIOD When you want to check a condition that a is between 1 and 5 what happens if you write a 1 less than a less than 5 because this is the way we do it in mathematics <sil=0.900> .PERIOD Well C will apply the precedence and the associativity in this case it is the same operation <sil=0.984> .PERIOD So <sil=0.481> ,COMMA only associativity applies and according to associativity it is left to right <sil=0.915> .PERIOD So <sil=0.597> ,COMMA this will be evaluated as 1 less than a less than 5 <sil=0.989> .PERIOD Now <sil=0.649> ,COMMA a is 2 so 1 less than a is false <sil=0.911> .PERIOD So <sil=0.359> ,COMMA this becomes 0 so the whole thing is 0 less than 5 so it is true <sil=0.952> .PERIOD So <sil=0.444> ,COMMA if you execute this code it will eventually become an infinite loop because this is an expression that always evaluates to true <sil=0.967> .PERIOD Now <sil=0.469> ,COMMA what you probably mean is that I want to check that a is between 1 and 5 a is 2 <sil=0.904> .PERIOD So <sil=0.646> ,COMMA the correct way to write such an expression would be 1 less than a and a less than 5 that will check the between this condition <sil=0.957> .PERIOD So <sil=0.408> ,COMMA notice that this is different from the way we know that the whole expression is normally write in mathematics <sil=0.991> .PERIOD This is how we would write such a test in mathematics but that will cause an infinite loop <sil=0.915> .PERIOD This is because C will apply the precedence and the associativity rules and not what you think it should do <sil=0.996> .PERIOD So <sil=0.461> ,COMMA now let us look at can there be expressions which make no sense <sil=0.944> .PERIOD We have already or we have seen several examples where you can always make sense out of it <sil=0.932> .PERIOD So <sil=0.399> ,COMMA let us take this expression again list out the operations see you have equal to twice then you have the modelo operation which is highest precedence then you have minus then you again have an equal to and then you have a plus <sil=0.955> .PERIOD So <sil=0.369> ,COMMA these are the operations in the expression <sil=0.958> .PERIOD So <sil=0.418> ,COMMA what needs to be done first be modelo C and then you have minus a and then you have a plus 1 this is by following precedence and associativity rules <sil=0.940> .PERIOD Now <sil=0.619> ,COMMA now we come to the assignment statement <sil=0.951> .PERIOD Assignment statements are done right to left <sil=0.980> .PERIOD So <sil=0.597> ,COMMA the first thing that you try to do is the following <sil=0.990> .PERIOD So <sil=0.539> ,COMMA you try to do the so here is a sub expression here is a sub expression here is a sub expression and here is a sub expression <sil=0.907> .PERIOD So <sil=0.506> ,COMMA it is like assigning 4 terms and the innermost thing will be done first the right most thing will be done first <sil=0.940> .PERIOD So <sil=0.301> ,COMMA the right most assignment is B modelo C minus a is assigned to A plus 1 <sil=0.901> .PERIOD Now <sil=0.313> ,COMMA this is a syntax error <sil=0.990> .PERIOD So <sil=0.326> ,COMMA what happens is as we just discussed if you work out the whole assignment if you work out the whole expression it becomes something like this <sil=0.927> .PERIOD And somewhere when you work out the assignment from right to left you will see that it is trying to assign a number minus 3 to minus 7 that does not make any sense <sil=0.945> .PERIOD The left hand side of assignment statement should be an assignable value which is essentially a variable and in this case you are trying to assign a number to another number which does not make sense <sil=0.904> .PERIOD So <sil=0.547> ,COMMA here is a syntax error <sil=0.909> .PERIOD We will conclude the discussion on operations with one more operation which is quite common in C which is the comma operator <sil=0.956> .PERIOD Now <sil=0.403> ,COMMA this is not very common in mathematics <sil=0.308> ,COMMA but let us just discuss what does it mean in C <sil=0.969> .PERIOD So <sil=0.634> ,COMMA let us say that we have two expressions one expression one and expression two separated by a comma <sil=0.984> .PERIOD Now <sil=0.455> ,COMMA think of the comma as an operation just like any other operation like plus a minus <sil=0.939> .PERIOD So <sil=0.605> ,COMMA it must have a precedence it must have an associativity and so on <sil=0.982> .PERIOD So <sil=0.418> ,COMMA what will happen when we have an expression like i plus 2 comma sum equal to sum minus 1 <sil=0.907> .PERIOD So <sil=0.568> ,COMMA how does it follows first you evaluate the expression one <sil=0.999> .PERIOD So <sil=0.480> ,COMMA first in this case you evaluate i plus 2 then you evaluate sum equal to sum minus 1 and return the value of the last expression <sil=0.907> .PERIOD So <sil=0.584> ,COMMA the whole the comma operation is involved in an expression called the comma expression every expression has a value and the value of the comma expression will be expression two <sil=0.963> .PERIOD So <sil=0.518> ,COMMA what if you have multiple expressions you figure out what is the associativity of the comma expression the comma expression associates left to right <sil=0.906> .PERIOD So <sil=0.498> ,COMMA this expression will become scan F and so on sum equal to 0 i equal to 0 <sil=0.912> .PERIOD So <sil=0.489> ,COMMA this for the first comma this is expression one and this is expression two <sil=0.932> .PERIOD So <sil=0.483> ,COMMA this expression evaluates to the result of sum equal to 0 which is 0 as we know <sil=0.914> .PERIOD Now <sil=0.332> ,COMMA the second level is you have 0 comma i equal to 0 <sil=0.902> .PERIOD So <sil=0.305> ,COMMA the first comma expression is evaluated and its result is expression two of that expression which is sum equal value of sum equal to 0 which is 0 <sil=0.950> .PERIOD So <sil=0.513> ,COMMA the outer expression becomes 0 comma equal to 0 the value of that expression is the value of expression two in that bigger expression which is the value of i equal to 0 <sil=0.943> .PERIOD So <sil=0.559> ,COMMA here is how you will apply the rule that it is the value of the second expression for a more general expression involving multiple commas <sil=0.990> .PERIOD So <sil=0.318> ,COMMA what you do is first evaluate the first expression and it has some value for example <sil=0.531> ,COMMA in this case it is an assignment expression <sil=0.943> .PERIOD So <sil=0.352> ,COMMA it will have the value 0 and then the second expression is evaluated and the value of the comma expression is the value of the second expression <sil=0.952> .PERIOD Note that the you may at first sight you may see multiple commas in the same expression <sil=0.572> ,COMMA but the way you do it is that you group them using associativity rules into a sequence of comma expressions where each comma expression has exactly two terms <sil=0.904> .PERIOD This is what we did in the previous example <sil=0.967> .PERIOD Now <sil=0.644> ,COMMA comma expression is very convenient because you can do things like when you want to initialize multiple variables in a for loop for example <sil=0.331> ,COMMA you can just say sum equal to 0 comma equal to 0 it will initialize both values at the same time both variables at the same time <sil=0.934> .PERIOD So <sil=0.408> ,COMMA commas are evaluated left to right this is what I just worked out an example of the following form <sil=0.924> .PERIOD So <sil=0.427> ,COMMA if you have multiple sub expressions in a comma expression <sil=0.641> ,COMMA if you have multiple commas what you do is you associate them just like you did with plus and star you have multiple comma expressions and then group them two at a time <sil=0.948> .PERIOD So <sil=0.424> ,COMMA it becomes two comma expressions and then evaluate them <sil=0.949> .PERIOD Now <sil=0.630> ,COMMA the comma expression has the lowest precedence of any operator in C <sil=0.956> .PERIOD So <sil=0.365> ,COMMA if you have an operation like a equal to a plus 5 comma sum equal to sum plus a what will happen is you do this expression a equal to a plus 5 then do this expression sum equal to sum plus a and then evaluate the comma expression <sil=0.964> .PERIOD And therefore <sil=0.553> ,COMMA when you have a comma expression you do not need explicit parenthesis because the precedence takes care of it it has the lowest precedence <sil=0.975> .PERIOD So <sil=0.574> ,COMMA it will never get swallowed into a bit bigger expression which involves other operations <sil=0.963> .PERIOD So <sil=0.620> ,COMMA it will always be evaluated at the end <sil=0.940> .PERIOD So <sil=0.623> ,COMMA just to remind you here is the table once again and notice that as we discussed the comma operation is the lowest precedence and it associates left to right <sil=0.950> .PERIOD There is also a slightly different meaning of the comma in C we will just mention that in passing <sil=0.937> .PERIOD There is also the normal separator <sil=0.950> .PERIOD So <sil=0.575> ,COMMA the separator can be seen in multiple occasions in C when you initialize an expression when you say sum equal to 0 comma equal to 0 comma j equal to 0 this is not the comma expression it is just a separator as in English <sil=0.903> .PERIOD So <sil=0.303> ,COMMA similarly when you call a function you have comma to separate out the arguments that does not mean that the arguments are inside the comma expression <sil=0.988> .PERIOD Then here comma is just a separator as in English and it is always clear from the context whether a comma is a separator or an operator as an operator it has a particular value as a separator it does not do anything other than saying that this first and then this <sil=0.949> .PERIOD So <sil=0.359> ,COMMA we have seen several operators in C and discuss the concepts of precedence and associativity and what is important is given the precedence and associativity tables can you understand an expression see whether it is a valid expression and if it is a valid expression what will be its value <sil=0.904> .PERIOD In this session <sil=0.358> ,COMMA we will try to code up the C code for finding the length of the longest increasing continuous subsequence <sil=0.975> .PERIOD So let us first examine what we need to do <sil=0.904> .PERIOD We will write a code and from the previous discussion <sil=0.392> ,COMMA we saw that we need at least three variables <sil=0.632> ,COMMA one for storing the previous number <sil=0.474> ,COMMA one for storing the current number and the third for storing the length of the current decreasing subsequence <sil=0.914> .PERIOD So we start by declaring all those three variables and initializing length to 0 <sil=0.910> .PERIOD So here is a new construct that we are seeing for the first time <sil=0.628> ,COMMA which is that when you declare a variable <sil=0.519> ,COMMA you can also initialize it immediately by saying length equal to 0 <sil=0.985> .PERIOD So this is a very intuitive notation <sil=0.927> .PERIOD So this will declare a variable and immediately initialize it to 0 <sil=0.910> .PERIOD So once we declare these three variables <sil=0.415> ,COMMA let us say that we scan the first variable into previous <sil=0.964> .PERIOD Now let us focus on the main body of the program <sil=0.934> .PERIOD If the currently red number is not minus 1 <sil=0.643> ,COMMA then you say that you start with length 1 <sil=0.901> .PERIOD So the length of the current increasing subsequence is 1 and then you scan the next number into CURR <sil=0.929> .PERIOD So here is the current number <sil=0.937> .PERIOD So this part of the code is just to initialize <sil=0.933> .PERIOD So if the current <sil=0.473> ,COMMA if the first number is minus 1 <sil=0.329> ,COMMA then there is no point in getting into the program because it is equivalent to the empty input <sil=0.991> .PERIOD So there is no increasing subsequence to be found <sil=0.940> .PERIOD So we just exit out of the program <sil=0.951> .PERIOD So initially we just check to see whether the first number is minus 1 or not <sil=0.936> .PERIOD If the first number is not minus 1 <sil=0.414> ,COMMA you scan the next number <sil=0.947> .PERIOD So current will be the second number <sil=0.935> .PERIOD And if current is not minus 1 <sil=0.452> ,COMMA while the currently red number is not minus 1 <sil=0.318> ,COMMA what you do is exactly the logic that we were discussing before <sil=0.901> .PERIOD If the previous number is less than the current number <sil=0.377> ,COMMA then you extend the length by 1 <sil=0.993> .PERIOD So length equal to length plus 1 says that I am continuing the current increasing subsequence by increasing its length <sil=0.962> .PERIOD Otherwise that is current is less than or equal to previous <sil=0.966> .PERIOD You break the sequence and say length equal to 1 <sil=0.983> .PERIOD Then we have this step <sil=0.309> ,COMMA previous equal to current <sil=0.582> ,COMMA which is the advancing both variables by 1 <sil=0.926> .PERIOD So previous becomes the currently red number and current becomes the next number to be red <sil=0.931> .PERIOD So recall from the diagram that previous and current were at some position and we will advance both of them by 1 <sil=0.995> .PERIOD And when the loop condition is checked next time <sil=0.460> ,COMMA we will check whether the current is not getting seen number is minus 1 or not <sil=0.993> .PERIOD So far we have coded up part of the logic <sil=0.568> ,COMMA which is the part of the logic dealing with when the current <sil=0.542> ,COMMA when the next number is red <sil=0.468> ,COMMA do we extend the sequence or do we break the sequence and start a new sequence <sil=0.996> .PERIOD So this is just part of the work that we need to do to solve the problem <sil=0.902> .PERIOD So let us continue with the logic <sil=0.970> .PERIOD So let us start with a few boundary cases and let us see whether this works <sil=0.917> .PERIOD If it works <sil=0.416> ,COMMA we can try your logic on other cases <sil=0.962> .PERIOD So let us say that by boundary cases <sil=0.320> ,COMMA I mean maybe very long inputs or very short inputs <sil=0.991> .PERIOD So these are cases where your code normally breaks <sil=0.988> .PERIOD So when you test your code <sil=0.437> ,COMMA it is always a good idea to check boundary cases <sil=0.951> .PERIOD And one thing that makes programming difficult is that when we do things by hand <sil=0.444> ,COMMA we know how to handle the boundary cases elegantly <sil=0.955> .PERIOD But in a program <sil=0.521> ,COMMA unless you say how to handle the boundary cases <sil=0.585> ,COMMA the program might break <sil=0.970> .PERIOD And a lot of testing and a lot of errors come from incorrectly handling the boundary cases <sil=0.925> .PERIOD So it is always good to handle the boundary cases <sil=0.966> .PERIOD Test our code on very small inputs <sil=0.973> .PERIOD So let us say that I enter a sequence 5 minus 1 <sil=0.911> .PERIOD So previous becomes <sil=0.614> ,COMMA so length is 0 <sil=0.476> ,COMMA previous becomes 5 <sil=0.961> .PERIOD And then since previous is not minus 1 <sil=0.633> ,COMMA I have used an abbreviation here which is the not equal to operator <sil=0.908> .PERIOD This is the same as saying not of previous equal to equal to 1 <sil=0.969> .PERIOD So previous not equal to 1 is the same as saying not of previous equal to equal to 1 <sil=0.922> .PERIOD It is an operator in C <sil=0.931> .PERIOD This is equal to 1 <sil=0.919> .PERIOD Then you say that the length is 1 because you have seen 1 number and scan the next number <sil=0.952> .PERIOD The next number is minus 1 <sil=0.909> .PERIOD So you scan the next number and the next number is minus 1 <sil=0.945> .PERIOD So you break the sequence <sil=0.915> .PERIOD So you immediately exit out of the sequence and the length of the increasing sub sequence that we saw <sil=0.978> .PERIOD So 5 is the only increasing sub sequence and when we exit it <sil=0.322> ,COMMA the length was 1 <sil=0.954> .PERIOD So we handle the boundary case of an extremely small sequence <sil=0.422> ,COMMA a sequence with exactly one element correctly <sil=0.987> .PERIOD This gives us confidence that the code could be correct <sil=0.953> .PERIOD Of course we have handled only the boundary case <sil=0.951> .PERIOD Now we need to test it for other cases as well <sil=0.911> .PERIOD So far the program is not doing anything useful because we are just extending the sequence and breaking the sequence <sil=0.902> .PERIOD But recall that what we were supposed to do was to find the length of the longest increasing sub sequence <sil=0.963> .PERIOD So this is the main thing that we have to do in the logic <sil=0.936> .PERIOD So to do this <sil=0.594> ,COMMA what we do is something simple <sil=0.946> .PERIOD We keep track of the maximum length sequence that we have seen so far <sil=0.981> .PERIOD We keep track of the length of the longer sequence that we have seen so far <sil=0.969> .PERIOD So we have the current sequence <sil=0.909> .PERIOD Now all we need to do is whether to check whether the current sequence is longer than the previously known longest one <sil=0.925> .PERIOD So for this <sil=0.320> ,COMMA what we do is keep track of the maximum length that we have seen so far <sil=0.952> .PERIOD So this is a standard technique in programming and how do I do that <sil=0.973> ?QUESTIONMARK So let us modify the program a little bit <sil=0.950> .PERIOD So earlier we resend out that we need at least three variables <sil=0.923> .PERIOD Now in order to keep track of the length <sil=0.486> ,COMMA the maximum length that we have seen so far <sil=0.641> ,COMMA I need a new variable <sil=0.904> .PERIOD So this part we have already done before and here is the max length equal to 0 <sil=0.982> .PERIOD So that is the new variable which is the maximum length that we have seen so far <sil=0.941> .PERIOD When we start the program <sil=0.389> ,COMMA we have not seen any increasing subsequence and therefore the length of the longest increasing sequence <sil=0.324> ,COMMA the current increasing sequence is 0 that is length equal to 0 and the length of the maximum length that we have seen so far is also 0 <sil=0.961> .PERIOD Then you scan the new number <sil=0.901> .PERIOD If the new number is not minus 1 <sil=0.433> ,COMMA you continue <sil=0.993> .PERIOD So length equal to 1 <sil=0.904> .PERIOD Now max length equal to 1 because currently the longest sequence that we have seen so far is 1 <sil=0.328> ,COMMA 1 long <sil=0.920> .PERIOD You scan the next number <sil=0.947> .PERIOD So here is the main body of the loop and what we need to do is the following <sil=0.933> .PERIOD If the currently red number is greater than the previous number <sil=0.362> ,COMMA we extend the sequence <sil=0.953> .PERIOD So this logic is the same as before <sil=0.987> .PERIOD Otherwise which means that current number is less than or equal to previous <sil=0.933> .PERIOD So we are starting a new sequence <sil=0.965> .PERIOD So the situation is the following <sil=0.918> .PERIOD We have some max length sequence somewhere in the past <sil=0.932> .PERIOD So max length is the length of the sequence that we have seen somewhere in the past <sil=0.993> .PERIOD Now we are scanning the sequence <sil=0.903> .PERIOD We have a current sequence <sil=0.998> .PERIOD And we have decided to break the sequence <sil=0.904> .PERIOD So we are now starting a new sequence starting at current <sil=0.906> .PERIOD So we are at this part of the logic <sil=0.982> .PERIOD So we have decided to start a new sequence <sil=0.925> .PERIOD That is because the current sequence is last number is greater than or equal to the current number <sil=0.994> .PERIOD So here is previous and this is current <sil=0.985> .PERIOD So we are deciding to start a new sequence <sil=0.979> .PERIOD What we need to see is whether this sequence is longer than the previously known maximum length <sil=0.913> .PERIOD If the sequence that we just stopped is longer than the previously known maximum length sequence <sil=0.982> .PERIOD So if max length is less than length <sil=0.479> ,COMMA notice that length is the sequence that length of the sequence that we just stopped <sil=0.946> .PERIOD Then we say that max length equal to length <sil=0.922> .PERIOD So now <sil=0.404> ,COMMA if the current sequence is longer than the previously known max length <sil=0.539> ,COMMA what we do is that max length becomes the length of this sequence <sil=0.977> .PERIOD Otherwise if the current sequence was shorter than the previously known maximum length <sil=0.325> ,COMMA we do not do anything <sil=0.949> .PERIOD So maximum length is the same <sil=0.979> .PERIOD This one more concept that we have to understand before we really understand how C evaluates expressions that is the concept of precedence <sil=0.952> .PERIOD So <sil=0.315> ,COMMA what do we mean by precedence <sil=0.859> ?QUESTIONMARK Let us pick a expression which involves multiple operators like for example <sil=0.485> ,COMMA in this expression you have two operations the assignment operation and the addition operation <sil=0.988> .PERIOD Now <sil=0.538> ,COMMA how do we know how to evaluate this expression <sil=0.987> ?QUESTIONMARK So <sil=0.555> ,COMMA what are the two ways in which the above expression can be interpreted <sil=0.971> ?QUESTIONMARK The first way is you could say A equal to B and then say plus C or you can say A equal to B plus C <sil=0.959> .PERIOD To decide which of the following <sil=0.428> ,COMMA which of the above possibilities to really do <sil=0.947> ?QUESTIONMARK C also defines what is known as a precedence between operators <sil=0.952> .PERIOD So <sil=0.426> ,COMMA we have already seen the notion of associativity which is what happens when the many occurrences of the same operator occur in an expression <sil=0.980> .PERIOD So <sil=0.563> ,COMMA what is the difference on the other hand is to mediate between two different or multiple different operations in the same expression <sil=0.985> .PERIOD So <sil=0.380> ,COMMA let us see what is an example of using precedence <sil=0.944> .PERIOD So <sil=0.483> ,COMMA in C the plus operation is given more precedence than the equal to operation <sil=0.939> .PERIOD So <sil=0.322> ,COMMA I really want to interpret this expression as A equal to B plus C <sil=1.000> .PERIOD So <sil=0.628> ,COMMA this is how I want to interpret the operation and not as A equal to B plus C <sil=0.948> .PERIOD So <sil=0.624> ,COMMA I want to avoid this and I want to do it in this way <sil=0.908> .PERIOD So <sil=0.603> ,COMMA one way I will I can ensure that is by saying that please do B plus C first and then take that result and assign it to A <sil=0.968> .PERIOD So <sil=0.433> ,COMMA one way of doing that is to say whenever equal to and plus appear together give more importance to plus do that first <sil=0.938> .PERIOD So <sil=0.500> ,COMMA proceed means going first <sil=0.906> .PERIOD So <sil=0.611> ,COMMA plus has a greater precedence over assignment <sil=0.900> .PERIOD Plus and minus have the same precedence and both have the same associativity we have seen this addition and subtraction have the same precedence <sil=0.429> ,COMMA but multiplication and division have a higher precedence <sil=0.973> .PERIOD So <sil=0.372> ,COMMA if I want to evaluate a complicated expression let us say that A plus B minus C star D modulo E divided by F <sil=0.990> .PERIOD So <sil=0.510> ,COMMA suppose I have a fairly complicated expression then the what I can do is what are the operations here <sil=0.967> .PERIOD So <sil=0.509> ,COMMA the operations are plus minus star modulo and division <sil=0.963> .PERIOD Now <sil=0.526> ,COMMA according to the precedence I know that star modulo and division have equal precedence above plus and minus <sil=0.987> .PERIOD So <sil=0.379> ,COMMA I know that these operations have to be done before plus and minus <sil=0.909> .PERIOD So <sil=0.308> ,COMMA they have a lower precedence <sil=0.954> .PERIOD So <sil=0.594> ,COMMA these have to be done first <sil=0.524> ,COMMA but among them how do you know which to do first that for that we use the left to right associativity of these operations <sil=0.993> .PERIOD So <sil=0.348> ,COMMA as far as within the same precedence is concerned let us just simplify the situation a little bit and think of them as the same operation <sil=0.902> .PERIOD They have they are different operations of the same precedence <sil=0.558> ,COMMA but I will just fudge the thing a little bit to say that let us say that they are the same operation all of them have left to right associativity <sil=0.903> .PERIOD Therefore <sil=0.462> ,COMMA I will according to the associativity rule I will do C star D first then that modulo E and then that divide by F <sil=0.999> .PERIOD So <sil=0.631> ,COMMA I will that is what the left to right associativity is <sil=1.000> .PERIOD So <sil=0.327> ,COMMA precedence by precedence we will know that these three operations have to be done first <sil=0.965> .PERIOD Among them how do you do this star occurs first when you scan from left to right <sil=0.983> .PERIOD So <sil=0.349> ,COMMA C star D has to be done first and then the modulo operation and then the divide by operation <sil=0.954> .PERIOD So <sil=0.416> ,COMMA and once you are done there then you come to plus and minus <sil=0.983> .PERIOD So <sil=0.606> ,COMMA currently once we have finished with this you will have some situation like this C star D modulo E divided by F and then on the remaining side you have A plus B minus this and now you have to decide which way you will do the plus and minus <sil=0.930> .PERIOD Again we know that they have the same precedence <sil=0.916> .PERIOD So <sil=0.426> ,COMMA let us fudge a little bit and think of them as the same operator both of them have the left to right associativity <sil=0.974> .PERIOD So <sil=0.463> ,COMMA I will do A plus B first and then the minus <sil=0.953> .PERIOD So <sil=0.481> ,COMMA within the same precedence level you will decide which operation to do first purely based on the left to right associativity <sil=0.971> .PERIOD So <sil=0.464> ,COMMA let us take a look at the precedence or associativity table <sil=0.957> .PERIOD Again I want to emphasize it is not to memorize it is just that if you are given this table you should be able to understand how an expression is going to be evaluated <sil=0.994> .PERIOD So <sil=0.614> ,COMMA parenthesis is above all because once you parenthesis an expression then you are really saying this is the order that I want <sil=0.998> .PERIOD So <sil=0.525> ,COMMA it overrides any other precedence or associativity rule <sil=0.982> .PERIOD Then you have the unary operations whichever the second highest precedence <sil=0.993> .PERIOD Then the arithmetic operations then the comparison logical operators assignment and so on <sil=0.967> .PERIOD The comma is an operation we will see later <sil=0.991> .PERIOD So <sil=0.619> ,COMMA within the arithmetic operations multiply divide and modulo operator have higher precedence over plus and minus plus and minus have higher precedence over relational operations like less than or equal to and so on <sil=0.934> .PERIOD So <sil=0.399> ,COMMA we will see a few examples of how to use this table to understand what will happen with an expression <sil=0.907> .PERIOD So <sil=0.531> ,COMMA let us take 10 plus 5 star 4 modulo 2 and assign to A <sil=0.955> .PERIOD Let us examine what will happen here <sil=0.917> .PERIOD So <sil=0.500> ,COMMA what I will do is I will make a list of operations <sil=0.933> .PERIOD So <sil=0.631> ,COMMA they are equal to plus star modulo and then precedence I know that multiplication and modulo have very high precedence <sil=0.915> .PERIOD Then the next level is plus and then assignment has the least precedence <sil=0.924> .PERIOD Now <sil=0.434> ,COMMA both of these occur in this expression star and modulo how do we decide which goes first both of them have left to right associativity <sil=0.900> .PERIOD So <sil=0.515> ,COMMA whatever happens first in the looking from left to right we will do that first <sil=0.919> .PERIOD So <sil=0.346> ,COMMA among all these operations we know that 5 star 4 will happen first <sil=0.902> .PERIOD Then this will be followed by modulo 2 and then this will be followed by 10 plus and finally <sil=0.356> ,COMMA the last which is that you do all these operations get the value and assign it to A <sil=0.980> .PERIOD So <sil=0.316> ,COMMA this is the way in which the above expression will be evaluated <sil=0.959> .PERIOD So <sil=0.555> ,COMMA the above expression corresponds to giving the parenthesis in the way that we have done <sil=0.939> .PERIOD So <sil=0.478> ,COMMA this is the way that we have done <sil=0.902> .PERIOD So <sil=0.600> ,COMMA once you do that A will get the value 1 A will get the value 10 <sil=0.939> .PERIOD So <sil=0.481> ,COMMA we will see a few more examples because loops are really important <sil=0.967> .PERIOD Let us go back to the first problem that we discussed which was the problem of computing the greatest common divisor of two numbers <sil=0.518> ,COMMA two positive numbers <sil=0.953> .PERIOD So <sil=0.443> ,COMMA the problem is to read the two numbers <sil=0.389> ,COMMA find their GCD and compute the output <sil=0.902> .PERIOD Now <sil=0.319> ,COMMA we had a flow chart of the problem based on the fact that if A is greater than or equal to B <sil=0.633> ,COMMA then GCD of A comma 0 if B is 0 <sil=0.345> ,COMMA then GCD of A comma 0 is A <sil=0.952> .PERIOD Otherwise GCD of A comma B is the same as GCD of B comma A modulo B <sil=0.543> ,COMMA where A modulo B is A percent is B is the reminder of when A is divided by B <sil=0.938> .PERIOD So <sil=0.361> ,COMMA let us now try to write the program in C using a while loop <sil=0.933> .PERIOD So <sil=0.627> ,COMMA we have to do a few preliminary things <sil=0.962> .PERIOD So <sil=0.476> ,COMMA let us call it the first half of the program <sil=0.902> .PERIOD In the first half I declare three variables A <sil=0.552> ,COMMA B and there is another variable T whose need we will see right now <sil=0.938> .PERIOD But let us say that I need an extra variable for now let us just take it on faith <sil=0.942> .PERIOD So <sil=0.544> ,COMMA what I will do is scan two variables A and B <sil=0.915> .PERIOD Now <sil=0.405> ,COMMA recall in the GCD equation that if it is saw right now <sil=0.584> ,COMMA we assume that A is greater than or equal to B <sil=0.919> .PERIOD Now <sil=0.321> ,COMMA what if the user is unaware of this condition and entered the lesser number first <sil=0.967> .PERIOD So <sil=0.321> ,COMMA he just entered the numbers in such a way that A is less than B <sil=0.932> .PERIOD So <sil=0.642> ,COMMA we need to correct that we need to make sure that A is the greater number <sil=0.938> .PERIOD So <sil=0.484> ,COMMA we need to exchange the values of A and B if it is true that A is less than B <sil=0.941> .PERIOD Now <sil=0.466> ,COMMA how do we do this <sil=0.948> ?QUESTIONMARK So <sil=0.315> ,COMMA the first thing to note to try will be to say that for example <sil=0.559> ,COMMA if I say that let us say A was 3 and B was 4 <sil=0.987> .PERIOD And suppose I just said A equal to B I want to exchange the values of A and B I just said A equal to B and B equal to A <sil=0.979> .PERIOD What will be the effect of this <sil=0.882> ?QUESTIONMARK Note that this is the assignment statement <sil=0.923> .PERIOD So <sil=0.567> ,COMMA after I execute this line B is 4 <sil=0.992> .PERIOD So <sil=0.529> ,COMMA A will be 4 <sil=0.649> ,COMMA A equal to B results in A equal to 4 right <sil=0.975> .PERIOD After the execution of this line <sil=0.371> ,COMMA so what the situation that we will have is that B equal to 4 and A equal to 4 and we will have no memory of what was the original value of A that is lost right <sil=0.922> .PERIOD So <sil=0.401> ,COMMA it is just simply lost <sil=0.984> .PERIOD So <sil=0.331> ,COMMA this idea that we can exchange 2 values by just writing A equal to B equal to A does not work <sil=0.911> .PERIOD So <sil=0.467> ,COMMA what is the correct way to do it <sil=0.968> ?QUESTIONMARK So <sil=0.364> ,COMMA we have an idea known as the cyclic exchange and this is a really neat idea the idea is that <sil=0.916> .PERIOD So <sil=0.303> ,COMMA how can I motivate it <sil=0.957> ?QUESTIONMARK Let us say that you have 2 rooms and these 2 rooms are full of stuff and I want to change the contents of the first room to the second and the second room to the third <sil=0.947> .PERIOD One way I can do it is that I will move the contents of the first room to a different room <sil=0.904> .PERIOD So <sil=0.541> ,COMMA have a temporary room and then copy the contents of the second room to the first and copy the contents of the third room to the second <sil=0.992> .PERIOD So <sil=0.596> ,COMMA this is a very nice intuition and it almost is similar to what we need to do <sil=0.977> .PERIOD So <sil=0.436> ,COMMA we have 2 variables A and B that we need to swap <sil=0.974> .PERIOD So <sil=0.632> ,COMMA one thing we can do is I will keep a third variable T <sil=0.960> .PERIOD First what I will do is I will copy the value of A to T <sil=0.947> .PERIOD So <sil=0.300> ,COMMA now I have a backup copy <sil=0.976> .PERIOD Now <sil=0.538> ,COMMA then I will say B equal to A <sil=0.340> ,COMMA A equal to B <sil=0.907> .PERIOD So <sil=0.486> ,COMMA at this point the value of B will be copied to the A <sil=0.985> .PERIOD So <sil=0.594> ,COMMA now A is 6 <sil=0.357> ,COMMA B is 6 <sil=0.443> ,COMMA but still we have a memory of what was A before because the old value of A was stored in T <sil=0.999> .PERIOD So <sil=0.328> ,COMMA in order to complete the routine all you need to do is to copy the value of T to B and that can be accomplished by the equation by the assignment statement B equal to T <sil=0.919> .PERIOD So <sil=0.452> ,COMMA this idea is known as cyclic exchange <sil=0.906> .PERIOD So <sil=0.397> ,COMMA recall the physical intuition of swapping the contents of 2 rooms which are almost full <sil=0.936> .PERIOD You have a third room and you copy the you move the contents of the first room to the third room <sil=0.375> ,COMMA move the contents of the second to the first and move the contents of the third to the second <sil=0.970> .PERIOD So <sil=0.415> ,COMMA this is similar to what we did in the case of physical contents we cannot copy in the case of variables we can copy <sil=0.972> .PERIOD So <sil=0.569> ,COMMA now let us complete the GCD program <sil=0.907> .PERIOD We have just done the first part of the program which is to ensure that A is actually the greater number <sil=0.925> .PERIOD If it was not the greater number you swap or exchange <sil=0.985> .PERIOD Now <sil=0.461> ,COMMA so after exchange we have ensured that A is greater than or equal to B <sil=0.997> .PERIOD Now <sil=0.305> ,COMMA we have to write the main loop for the GCD function <sil=0.956> .PERIOD So <sil=0.451> ,COMMA just by translating that flow chart what we will do is while B is not 0 what you do is you say that store the value of A and T assign A to B <sil=0.411> ,COMMA A equal to B and B becomes T modulo B <sil=0.959> .PERIOD Recall the equation was written as follows that <sil=0.948> .PERIOD So <sil=0.315> ,COMMA recall that the equation was GCD of A B is the same as GCD of B A modulo B <sil=0.969> .PERIOD So <sil=0.641> ,COMMA when you assign A to B the old value of A is lost and we can no longer do A modulo B <sil=0.992> .PERIOD So <sil=0.437> ,COMMA the way to do that is you use the idea of a temporary variable store the old value of A and T before you do A equal to B <sil=0.924> .PERIOD So <sil=0.332> ,COMMA that finally A modulo B can be done by T modulo B <sil=0.936> .PERIOD I do not want the new value of A I want the old value of A <sil=0.900> .PERIOD So <sil=0.361> ,COMMA let us just trace the execution of this program <sil=0.979> .PERIOD Let us say that I scan 2 numbers A and B and the user was correct in entering it <sil=0.991> .PERIOD So <sil=0.559> ,COMMA he or she entered the greater number first <sil=0.998> .PERIOD So <sil=0.304> ,COMMA we have 16 and 9 A equal to 16 B equal to 9 and T is undefined <sil=0.974> .PERIOD So <sil=0.541> ,COMMA after you read the numbers you just say GCD of after this you enter a message which is print a message which is that GCD of A and B is <sil=0.915> .PERIOD So <sil=0.387> ,COMMA GCD of 16 and 9 is and then you enter the loop <sil=0.979> .PERIOD So <sil=0.640> ,COMMA in the initial execution of the loop you have T equal to A which will store T equal to 16 A equal to B which is A will become 9 and then but you want to compute the modulo 16 modulo 9 <sil=0.625> ,COMMA but 16 was lost in A because A is now 9 <sil=0.913> .PERIOD So <sil=0.592> ,COMMA you have to do T modulo B <sil=0.928> .PERIOD So <sil=0.554> ,COMMA 16 modulo 9 which is 7 <sil=0.999> .PERIOD So <sil=0.360> ,COMMA you go back to the while loop and then you see that B is not 0 B is 7 <sil=0.931> .PERIOD So <sil=0.322> ,COMMA you enter the loop again T is equal to A <sil=0.994> .PERIOD So <sil=0.539> ,COMMA T is 9 A equal to B <sil=0.957> .PERIOD So <sil=0.452> ,COMMA A becomes 7 B becomes 2 again B is not 0 <sil=0.995> .PERIOD So <sil=0.498> ,COMMA you enter the loop again <sil=0.914> .PERIOD So <sil=0.361> ,COMMA T is 7 A equal to 2 and B equal to 1 again you enter the loop B is not 0 T is 2 A becomes 1 and B becomes 0 <sil=0.951> .PERIOD At this point you exit the loop and at this point the A that we ended with is the GCD of these numbers <sil=0.991> .PERIOD So <sil=0.449> ,COMMA 16 and 9 are relatively prime therefore <sil=0.419> ,COMMA their GCD is 1 <sil=0.978> .PERIOD Now <sil=0.571> ,COMMA let us think of minute about what is the loop invariant in this program <sil=0.971> .PERIOD What is what is it that we have a central while loop which computes the GCD what was the invariant in that loop <sil=0.966> .PERIOD So <sil=0.482> ,COMMA for this I will just introduce a slight notation which makes it easier to discuss these invariant <sil=0.984> .PERIOD So <sil=0.328> ,COMMA let capital A and capital B be the original numbers that I input and little A and little B represent the numbers which are involved in the loop <sil=0.919> .PERIOD So <sil=0.614> ,COMMA capital A and capital B were the original input and the invariant that I have is that at every stage the GCD of the original inputs are the same as the GCD of little A and B <sil=0.967> .PERIOD Recall that little A and B are the variables involved in the loop <sil=0.998> .PERIOD So <sil=0.587> ,COMMA little A and B keep changing through the loop whereas <sil=0.343> ,COMMA capital A and B are fixed they are the input <sil=0.928> .PERIOD So <sil=0.308> ,COMMA the invariant that I have is that at every time you enter the loop the GCD of the input were the same as the GCD of the variable <sil=0.993> .PERIOD Now <sil=0.392> ,COMMA this guarantees the correctness because when you exit out of the loop the you will correctly compute you exit out of the loop because B equal to 0 and by the original equation you know that when B equal to 0 A is the GCD of A and B <sil=0.921> .PERIOD So <sil=0.378> ,COMMA this guarantees correctness <sil=0.931> .PERIOD Now <sil=0.431> ,COMMA you could also ask other questions like how many times has the loop run and this question is a bit complicated because you have to compute it based on the input numbers <sil=0.920> .PERIOD So <sil=0.339> ,COMMA such questions are of interest to computer science but we will not go into computing the efficiency or the performance of this code but it is also a very crucial question <sil=0.907> .PERIOD In this session <sil=0.358> ,COMMA let us look at a matrix problem and the problem is given as follows <sil=0.925> .PERIOD You have a bunch of lines of input <sil=0.935> .PERIOD The first line of the input consists of two numbers m and n <sil=0.944> .PERIOD This line is followed by m lines each containing n integers <sil=0.947> .PERIOD So <sil=0.401> ,COMMA this is supposed to represent the matrix of size m time m cross n <sil=0.902> .PERIOD We have to calculate the sum of the squares of the sum of numbers in each row <sil=0.970> .PERIOD That is quite a mouthful <sil=0.918> .PERIOD Let us look at the formula <sil=0.924> .PERIOD So <sil=0.516> ,COMMA what I want to do is summation j a i j <sil=0.913> .PERIOD So <sil=0.560> ,COMMA once you do the sum <sil=0.637> ,COMMA you square that and then do the summation i <sil=0.991> .PERIOD So <sil=0.476> ,COMMA i is an index which goes over the rows <sil=0.987> .PERIOD In C <sil=0.368> ,COMMA we adopt the convention that the first row is starting with 0 <sil=0.924> .PERIOD So <sil=0.621> ,COMMA it goes from 0 to m minus 1 <sil=0.951> .PERIOD Similarly <sil=0.371> ,COMMA the first column starts with index 0 <sil=0.984> .PERIOD So <sil=0.550> ,COMMA it goes on till n minus 1 <sil=0.915> .PERIOD So <sil=0.487> ,COMMA the input will be given as follows <sil=0.975> .PERIOD The first number m represents that there are three rows <sil=0.909> .PERIOD The second number represents the number of columns in each row <sil=0.985> .PERIOD Then <sil=0.566> ,COMMA this is followed by a matrix of size 3 cross 4 <sil=0.953> .PERIOD Now <sil=0.588> ,COMMA the numbering is as follows <sil=0.952> .PERIOD For example <sil=0.599> ,COMMA if you have a 2 0 <sil=0.366> ,COMMA this means second row 0 with column <sil=0.926> .PERIOD Note that second row means we start with row 0 <sil=0.342> ,COMMA then row 1 <sil=0.467> ,COMMA then row 2 and 0 with column is this <sil=0.329> ,COMMA the first column <sil=0.916> .PERIOD So <sil=0.357> ,COMMA a 2 0 is this number which is 2 <sil=0.992> .PERIOD Similarly <sil=0.525> ,COMMA a 1 2 is first row <sil=0.568> ,COMMA row number 1 <sil=0.348> ,COMMA column number 2 which is also 2 <sil=0.992> .PERIOD So <sil=0.504> ,COMMA the desired output that we have is 4 plus 7 plus 11 plus 2 whole square and so on <sil=0.969> .PERIOD So <sil=0.638> ,COMMA how do we do this by hand <sil=0.981> ?QUESTIONMARK Let us just look at the calculation <sil=0.989> .PERIOD So <sil=0.324> ,COMMA we have 4 <sil=0.507> ,COMMA 7 <sil=0.572> ,COMMA 11 <sil=0.357> ,COMMA 2 <sil=0.325> ,COMMA 1 <sil=0.432> ,COMMA 1 <sil=0.541> ,COMMA 2 <sil=0.572> ,COMMA 4 and 2 <sil=0.648> ,COMMA 9 <sil=0.306> ,COMMA 0 <sil=0.623> ,COMMA minus 1 <sil=0.941> .PERIOD Notice that the formula that we have to calculate is I going from 0 to 2 <sil=0.425> ,COMMA j going from 0 to 3 <sil=0.392> ,COMMA a i j squared <sil=0.942> .PERIOD So <sil=0.349> ,COMMA how do we do this <sil=0.946> ?QUESTIONMARK First <sil=0.437> ,COMMA we sum the numbers in each column <sil=0.926> .PERIOD So <sil=0.597> ,COMMA I will name that as j going from 0 to 3 <sil=0.491> ,COMMA a i j and then squared <sil=0.916> .PERIOD So <sil=0.511> ,COMMA if you sum all this <sil=0.572> ,COMMA you see 11 <sil=0.405> ,COMMA 22 <sil=0.559> ,COMMA 24 squared which is 576 and similarly <sil=0.326> ,COMMA this is 64 <sil=0.472> ,COMMA 8 squared and this is 10 squared which is 100 <sil=0.991> .PERIOD So <sil=0.520> ,COMMA what I have tallied on the right hand side is for each row <sil=0.436> ,COMMA you sum the numbers <sil=0.518> ,COMMA take that sum and square it <sil=0.916> .PERIOD And then finally <sil=0.373> ,COMMA in order to compute what we want which is I equal to 0 to 2 of summation j equal to 0 to 3 <sil=0.511> ,COMMA a i j squared <sil=0.955> .PERIOD In order to calculate this <sil=0.350> ,COMMA all we need to do is to sum this number up and this turns out to be 740 <sil=0.948> .PERIOD So <sil=0.605> ,COMMA notice when we did by hand <sil=0.495> ,COMMA we did the following <sil=0.953> .PERIOD We first calculated row wise <sil=0.620> ,COMMA you summed over all the numbers in that row <sil=0.641> ,COMMA take the sum square it <sil=0.566> ,COMMA then you repeated the same operation for the next row and then for the third row <sil=0.932> .PERIOD So <sil=0.314> ,COMMA we have three numbers and then we added them in sequence <sil=0.919> .PERIOD So <sil=0.561> ,COMMA we will see how we will code this up <sil=0.957> .PERIOD So <sil=0.525> ,COMMA what we need here is something called an inner loop or a double loop <sil=0.934> .PERIOD We need a loop inside a loop <sil=0.901> .PERIOD Now <sil=0.641> ,COMMA the inner loop is doing what we did first <sil=0.503> ,COMMA it is taking a row and adding all the numbers in that row <sil=0.503> ,COMMA then squaring it <sil=0.978> .PERIOD So <sil=0.394> ,COMMA we need one loop to do the row sum of each row <sil=0.911> .PERIOD Once a row is finished <sil=0.304> ,COMMA we squared the row sum <sil=0.929> .PERIOD Once that is done <sil=0.616> ,COMMA remember that once the we tallied numbers on the right hand side and squared them <sil=0.533> ,COMMA we had to add those numbers up <sil=0.949> .PERIOD So <sil=0.640> ,COMMA we need another loop <sil=0.476> ,COMMA an outer loop to add the squares of row sums <sil=0.930> .PERIOD So <sil=0.390> ,COMMA let us do this program in stages <sil=0.905> .PERIOD First <sil=0.300> ,COMMA let us write the inner loop <sil=0.946> .PERIOD This is the loop so that for a given row <sil=0.595> ,COMMA you sum up all the numbers in that row <sil=0.950> .PERIOD Now <sil=0.507> ,COMMA let us assume that we are at the beginning of a row and we have not read any numbers yet <sil=0.958> .PERIOD Now <sil=0.372> ,COMMA what we have to do is to start reading the numbers <sil=0.911> .PERIOD So <sil=0.489> ,COMMA we write a while loop <sil=0.498> ,COMMA we declare four variables a column index <sil=0.527> ,COMMA then we need something for the row sum and some integer variable for row sum squared <sil=1.000> .PERIOD Now <sil=0.618> ,COMMA what you do is you go along the row and add the numbers in each column <sil=0.965> .PERIOD So <sil=0.547> ,COMMA while the column index is less than n <sil=0.524> ,COMMA recall that the matrix size was m cross n <sil=0.919> .PERIOD You scan the next number <sil=0.973> ,COMMA the next number is added to the row sum and then increment the column index until you hit n minus until you hit n <sil=0.587> ,COMMA recall that the last column is n minus 1 because we start the column numbers from 0 <sil=0.968> .PERIOD Now <sil=0.564> ,COMMA once you are done <sil=0.339> ,COMMA you have the sum of the numbers in that row and what you need to do is to square that number <sil=0.918> .PERIOD So <sil=0.630> ,COMMA we have row sum times row sum will be row sum squared <sil=0.956> .PERIOD That completes the inner loop <sil=0.541> ,COMMA which is what we did when we added the numbers along a given row and then finally <sil=0.478> ,COMMA square the sum <sil=0.961> .PERIOD Now <sil=0.484> ,COMMA what we need is an outer loop structure over this <sil=0.927> .PERIOD So <sil=0.316> ,COMMA we have a code that reads the next and integers from the terminal and sums them <sil=0.903> .PERIOD Now <sil=0.602> ,COMMA what we need is some further code that takes the output of the previous code and then sums all those numbers up <sil=1.000> .PERIOD Remember <sil=0.495> ,COMMA when we did this by hand <sil=0.342> ,COMMA this was the second operation we did <sil=0.920> .PERIOD We went over the right most column and added all those numbers up and that was the result that we wanted <sil=0.971> .PERIOD So <sil=0.359> ,COMMA how do we modify the code <sil=0.960> ?QUESTIONMARK So <sil=0.426> ,COMMA let us what we need is something like this <sil=0.978> .PERIOD Assume that we have the output available from the previous code in some variable called row sum squared and we need a loop over that <sil=0.327> ,COMMA which is going from row index 0 to m minus 1 and tallying up all the numbers in row sum squared <sil=0.956> .PERIOD So <sil=0.326> ,COMMA for each row <sil=0.622> ,COMMA you will end up with a row sum squared and you have to add all those row sum squares together <sil=0.910> .PERIOD So <sil=0.360> ,COMMA in this the row sum squared comes from the previous code <sil=0.994> .PERIOD So <sil=0.577> ,COMMA this is how we will visualize the outer loop <sil=0.906> .PERIOD Now <sil=0.417> ,COMMA note that this is not completely specified code <sil=0.917> .PERIOD This is just a very intuitive picture that instead of row sum squared <sil=0.493> ,COMMA it should come from some inner loop <sil=0.520> ,COMMA which actually calculates it <sil=0.930> .PERIOD So <sil=0.646> ,COMMA we should plug in the output from the previous inner loop and this is the outer loop over it <sil=0.948> .PERIOD So <sil=0.609> ,COMMA here is how we put these two loops together <sil=0.915> .PERIOD We have a while loop inside a while loop <sil=0.971> .PERIOD Remember that this was the previous loop that we had written <sil=0.992> .PERIOD So <sil=0.530> ,COMMA this was the inner loop that we had written <sil=0.599> ,COMMA where at the end of the inner loop <sil=0.402> ,COMMA you have the row sum squared <sil=0.929> .PERIOD Now <sil=0.506> ,COMMA at the end of the code <sil=0.348> ,COMMA what you will end up is the exact row sum square of a particular column <sil=0.986> .PERIOD So <sil=0.339> ,COMMA you can imagine that after this inner loop finishes execution <sil=0.464> ,COMMA the row sum squared is the corrects <sil=0.599> ,COMMA row sum is the corrects square of the sum of the elements in that row <sil=0.936> .PERIOD Now <sil=0.309> ,COMMA the outer index does the following <sil=0.963> .PERIOD You start from row index 0 and sum the row sum square over all columns <sil=0.997> .PERIOD So <sil=0.412> ,COMMA this is the structure of the code <sil=0.982> .PERIOD Let us look at the code in slightly more detail <sil=0.963> .PERIOD We have a row index <sil=0.515> ,COMMA a column index <sil=0.339> ,COMMA a column sum <sil=0.630> ,COMMA a row sum and a row sum squared <sil=0.917> .PERIOD A is supposed to be the current number that we are reading <sil=0.937> .PERIOD Suppose we know that the size of the matrix is m cross n <sil=0.982> .PERIOD So <sil=0.517> ,COMMA row index can go from 0 to m minus 1 <sil=0.906> .PERIOD So <sil=0.600> ,COMMA the termination condition of this while loop is row index equal to m <sil=0.931> .PERIOD Now <sil=0.547> ,COMMA for all that <sil=0.343> ,COMMA you are currently at a particular row <sil=0.931> .PERIOD So <sil=0.409> ,COMMA you have to initialize the row sum to 0 and the column index to 0 <sil=0.339> ,COMMA because for a given row <sil=0.640> ,COMMA you have to start from row 0 <sil=0.976> .PERIOD For a given row <sil=0.380> ,COMMA you have to start from column 0 and you go on until column n minus 1 <sil=0.902> .PERIOD Also <sil=0.496> ,COMMA this previous row sum should not influence the next row <sil=0.995> .PERIOD So <sil=0.539> ,COMMA for every row <sil=0.426> ,COMMA you have to initialize the row sum variable <sil=0.928> .PERIOD Once that is done <sil=0.503> ,COMMA you go over the columns of that given row and you scan the numbers <sil=0.396> ,COMMA add the number to the row sum and increment the column index until you hit n columns <sil=0.336> ,COMMA columns 0 through n minus 1 <sil=0.954> .PERIOD When you have read all the columns in that row <sil=0.528> ,COMMA you have the correct row sum <sil=0.939> .PERIOD So <sil=0.438> ,COMMA that row sum squared can now be calculated <sil=0.967> .PERIOD Once row sum square is calculated <sil=0.526> ,COMMA you have the row sum squared for that particular row <sil=0.986> .PERIOD So <sil=0.554> ,COMMA add the row sum squared to the previously computed column sum <sil=0.949> .PERIOD So <sil=0.418> ,COMMA if you go back and think about how we did this by hand <sil=0.535> ,COMMA you can convince yourself that <sil=0.396> ,COMMA this is exactly the coding of the logic that we had earlier <sil=0.929> .PERIOD So <sil=0.562> ,COMMA let us try this on a small example to see exactly how the code works <sil=0.905> .PERIOD Suppose <sil=0.477> ,COMMA the input is 2 <sil=0.398> ,COMMA 3 followed by 2 rows of 3 numbers each <sil=0.966> .PERIOD So <sil=0.507> ,COMMA the input matrix sizes 2 cross 3 and the entries are 1 <sil=0.535> ,COMMA 0 minus 1 and 0 <sil=0.525> ,COMMA 1 <sil=0.344> ,COMMA 1 <sil=0.402> .PERIOD Let us see how the code executes on this <sil=0.971> .PERIOD So <sil=0.359> ,COMMA the output should be 4 if you do it by hand <sil=0.925> .PERIOD And let us see the variables are n <sil=0.480> ,COMMA n <sil=0.528> ,COMMA a row index <sil=0.496> ,COMMA column index <sil=0.525> ,COMMA row sum <sil=0.598> ,COMMA nth square sum <sil=0.926> .PERIOD Finally <sil=0.591> ,COMMA the result should be in square sum <sil=0.968> .PERIOD You start with row index equal to 0 <sil=0.559> ,COMMA column index equal to 0 and you scan m and n <sil=0.902> .PERIOD So <sil=0.561> ,COMMA you already know the size of the matrix when you scan m and n <sil=0.968> .PERIOD So <sil=0.614> ,COMMA m becomes 2 and n becomes 3 <sil=0.949> .PERIOD Now <sil=0.514> ,COMMA row index is 0 which is less than 2 <sil=0.945> .PERIOD So <sil=0.598> ,COMMA we start the loop which reads the row 0 <sil=0.970> .PERIOD So <sil=0.425> ,COMMA notice the arrow here <sil=0.405> ,COMMA you are starting to read this particular row <sil=0.540> ,COMMA the first row which is row 0 <sil=0.902> .PERIOD Now <sil=0.441> ,COMMA you initialize row sum equal to 0 <sil=0.615> ,COMMA column index equal to 0 and while column index is less than n <sil=0.590> ,COMMA you scan the next number which is 1 <sil=0.918> .PERIOD Add a to the row sum <sil=0.985> .PERIOD So <sil=0.519> ,COMMA row sum becomes 1 increment the column index <sil=0.968> .PERIOD So <sil=0.441> ,COMMA you reach column 1 row 0 <sil=0.567> ,COMMA read that number <sil=0.541> ,COMMA add it to the row sum <sil=0.463> ,COMMA go to the second column <sil=0.414> ,COMMA add read the number and add it to the row sum <sil=0.998> .PERIOD So <sil=0.308> ,COMMA once you are done <sil=0.538> ,COMMA now column index is 2 <sil=0.492> ,COMMA column index is 3 <sil=0.983> .PERIOD So <sil=0.617> ,COMMA this means that we have read all the entries in the row 0 <sil=0.965> .PERIOD So <sil=0.606> ,COMMA we have got the correct row sum <sil=0.356> ,COMMA what we will do is add the row sum squared to the square sum <sil=0.937> .PERIOD So <sil=0.459> ,COMMA row sum is 0 <sil=0.476> ,COMMA 0 square to square sum <sil=0.901> .PERIOD So <sil=0.552> ,COMMA square sum remains 0 <sil=0.991> .PERIOD Now <sil=0.625> ,COMMA you go to the second row <sil=0.966> .PERIOD So <sil=0.512> ,COMMA increment row index <sil=0.932> .PERIOD Now <sil=0.445> ,COMMA row index is less than 2 <sil=0.523> ,COMMA row index is 1 <sil=1.000> .PERIOD So <sil=0.622> ,COMMA it is less than 2 <sil=0.624> ,COMMA we are reading row 1 and you repeat the same execution <sil=0.906> .PERIOD We re-initialize row sum to 0 <sil=0.312> ,COMMA column index to 0 and then scan the next number which is 0 <sil=0.421> ,COMMA add it to the row sum increment the column index <sil=0.554> ,COMMA scan the next number which is 1 and so on until you finish reading the second row as well <sil=0.903> .PERIOD So <sil=0.434> ,COMMA once you read the second row <sil=0.454> ,COMMA you will find that the row the row sum is 2 and square sum would be square sum plus 2 squared which is 4 <sil=0.935> .PERIOD After you do that <sil=0.567> ,COMMA you increment row index and row index becomes 3 which is greater than the given row index <sil=0.916> .PERIOD So <sil=0.377> ,COMMA you exit the loop <sil=0.932> .PERIOD So <sil=0.430> ,COMMA we have correctly computed the sum that we wanted <sil=0.964> .PERIOD So <sil=0.639> ,COMMA we will see one more example for writing loops <sil=0.502> ,COMMA we will see a slightly trickier example and we will cover this over multiple sessions <sil=0.937> .PERIOD So <sil=0.491> ,COMMA the problem is the following <sil=0.572> ,COMMA we have to read a sequence of numbers until a minus 1 is read <sil=0.547> ,COMMA minus 1 indicates that <sil=0.385> ,COMMA then the sequence has ended <sil=0.986> .PERIOD And the question is <sil=0.386> ,COMMA we have to output the length of the longest contiguous increasing subsequence <sil=0.956> .PERIOD So <sil=0.518> ,COMMA that is a lot of words <sil=0.454> ,COMMA let us illustrate it with an example <sil=0.961> .PERIOD Let us say that the input is of the following numbers 9 <sil=0.517> ,COMMA 2 <sil=0.325> ,COMMA 4 <sil=0.430> ,COMMA 0 <sil=0.329> ,COMMA 3 <sil=0.629> ,COMMA 4 <sil=0.536> ,COMMA 6 <sil=0.449> ,COMMA 9 <sil=0.496> ,COMMA 2 and then finally <sil=0.406> ,COMMA a minus 1 <sil=0.927> .PERIOD And we have to output the length of the longest contiguous increasing subsequence <sil=0.973> .PERIOD So <sil=0.353> ,COMMA let us say <sil=0.384> ,COMMA what do I mean by a contiguous increasing subsequence <sil=0.995> ?QUESTIONMARK So <sil=0.377> ,COMMA I say that 9 is an increasing subsequence <sil=0.573> ,COMMA then the next number is 2 <sil=0.320> ,COMMA 2 is less than 9 <sil=0.948> .PERIOD So <sil=0.596> ,COMMA 9 and 2 cannot be part of a subsequence where the numbers keep on increasing <sil=0.923> .PERIOD So <sil=0.407> ,COMMA 2 is the start of a new sequence <sil=0.988> .PERIOD Again <sil=0.520> ,COMMA the next number is 4 <sil=0.348> ,COMMA so 2 and 4 form an increasing sequence <sil=0.973> .PERIOD So <sil=0.313> ,COMMA you can continue increasing the sequence <sil=0.939> .PERIOD The next number is 0 <sil=0.498> ,COMMA 0 is less than 4 <sil=0.540> ,COMMA so you break the sequence there <sil=0.915> .PERIOD And then when you look at the succeeding numbers <sil=0.388> ,COMMA 0 <sil=0.504> ,COMMA 3 <sil=0.602> ,COMMA 4 <sil=0.376> ,COMMA 6 <sil=0.306> ,COMMA 9 <sil=0.489> ,COMMA they form an increasing sequence <sil=0.973> .PERIOD And the last number is 2 <sil=0.322> ,COMMA which is lesser than 9 <sil=0.948> .PERIOD So <sil=0.332> ,COMMA the increasing sequence stops here <sil=0.930> .PERIOD So <sil=0.569> ,COMMA these are the increasing contiguous subsequences <sil=0.901> .PERIOD Contiguous means together occurring adjacent to each other <sil=0.940> .PERIOD So <sil=0.335> ,COMMA the largest or the longest contiguous subsequences obviously <sil=0.645> ,COMMA 0 <sil=0.406> ,COMMA 3 <sil=0.567> ,COMMA 4 <sil=0.622> ,COMMA 6 <sil=0.547> ,COMMA 9 <sil=0.380> .PERIOD And the length of that sequence is 5 <sil=0.932> .PERIOD Let us take another example <sil=0.314> ,COMMA 11 <sil=0.519> ,COMMA 9 <sil=0.313> ,COMMA 7 <sil=0.572> ,COMMA 8 <sil=0.332> ,COMMA 11 <sil=0.425> ,COMMA 12 <sil=0.604> ,COMMA 15 <sil=0.643> ,COMMA 15 <sil=0.426> ,COMMA and minus 1 <sil=0.955> .PERIOD So <sil=0.633> ,COMMA just to illustrate the point <sil=0.569> ,COMMA 11 is greater than 9 <sil=0.623> ,COMMA so that cannot be an increasing sequence <sil=0.955> .PERIOD 9 is greater than 7 <sil=0.594> ,COMMA so that is another increasing sequence is just 9 <sil=0.904> .PERIOD But then 7 <sil=0.367> ,COMMA 8 <sil=0.535> ,COMMA 11 <sil=0.621> ,COMMA 12 <sil=0.626> ,COMMA 15 <sil=0.504> ,COMMA these are increasing <sil=0.993> .PERIOD And I decided to stop here <sil=0.507> ,COMMA even though the next number was 15 <sil=0.598> ,COMMA because I am interested in an increasing subsequences <sil=0.992> .PERIOD So <sil=0.394> ,COMMA 15 and 15 are equal numbers <sil=0.397> ,COMMA so we break it <sil=0.964> .PERIOD So <sil=0.485> ,COMMA the longest increasing subsequences is 7 <sil=0.491> ,COMMA 8 <sil=0.372> ,COMMA 11 <sil=0.550> ,COMMA 12 <sil=0.619> ,COMMA 15 <sil=0.554> ,COMMA and its length is 5 <sil=0.921> .PERIOD So <sil=0.487> ,COMMA this is the longest contiguous increasing subsequences <sil=0.969> .PERIOD So <sil=0.475> ,COMMA here is a basic property given any sequence of numbers <sil=0.463> ,COMMA we can break it into a collection of increasing contiguous subsequences <sil=0.901> .PERIOD For example <sil=0.474> ,COMMA the numbers that the sequence that we have seen <sil=0.537> ,COMMA so 9 <sil=0.592> ,COMMA 2 <sil=0.516> ,COMMA 4 <sil=0.578> ,COMMA 0 <sil=0.491> ,COMMA 3 <sil=0.318> ,COMMA 4 <sil=0.561> ,COMMA 6 <sil=0.585> ,COMMA 9 <sil=0.546> ,COMMA 2 <sil=0.328> ,COMMA and that the length of the increasing <sil=0.486> ,COMMA the longest increasing contiguous subsequence is 5 <sil=0.904> .PERIOD So <sil=0.538> ,COMMA we have to write a program to do this <sil=0.323> ,COMMA given a sequence of numbers <sil=0.631> ,COMMA find the length of the longest increasing subsequences <sil=0.964> .PERIOD So <sil=0.540> ,COMMA how do we do it <sil=0.937> ?QUESTIONMARK We do it in the way that we have been writing loops so far <sil=0.451> ,COMMA like adding n numbers and finding their sum and so on <sil=0.927> .PERIOD The idea was that you start from the first number and keep on adding the numbers until you hit a minus 1 <sil=0.476> ,COMMA at which point you have the sum <sil=0.970> .PERIOD So <sil=0.412> ,COMMA the idea of this algorithm was that you start from the first and you keep reading until a certain condition happens <sil=0.978> .PERIOD We will adapt that idea to solve our current problem <sil=0.904> .PERIOD So <sil=0.487> ,COMMA what we need to do is to keep track of the current increasing subsequences <sil=0.966> .PERIOD Let us say that it is denoted by S <sil=0.988> .PERIOD So <sil=0.641> ,COMMA before we get into the code <sil=0.577> ,COMMA let us see how we will do it by hand <sil=0.998> .PERIOD So <sil=0.443> ,COMMA initially the increasing subsequences S and let us say that it is empty <sil=0.905> .PERIOD After you read 9 <sil=0.412> ,COMMA you have an increasing subsequence which consists of exactly one number <sil=0.958> .PERIOD So <sil=0.631> ,COMMA S is 9 <sil=0.971> .PERIOD Now <sil=0.533> ,COMMA the next number is 10 <sil=0.363> ,COMMA 10 is greater than 9 <sil=0.956> .PERIOD So <sil=0.505> ,COMMA you extend this <sil=0.997> .PERIOD Read the next number <sil=0.931> .PERIOD 4 is less than 10 <sil=0.902> .PERIOD So <sil=0.516> ,COMMA 9 <sil=0.638> ,COMMA 10 <sil=0.605> ,COMMA 4 cannot be an increasing subsequence <sil=0.967> .PERIOD Therefore <sil=0.559> ,COMMA you say that you break the subsequence there <sil=0.975> .PERIOD So <sil=0.623> ,COMMA 9 <sil=0.382> ,COMMA 10 is a different subsequence <sil=0.990> .PERIOD Now <sil=0.635> ,COMMA you start a new subsequence which is 4 <sil=0.970> .PERIOD So <sil=0.405> ,COMMA the current subsequence is just 4 <sil=0.945> .PERIOD So <sil=0.593> ,COMMA 0 is less than 4 <sil=0.310> .PERIOD So <sil=0.589> ,COMMA you break it there <sil=0.978> .PERIOD The current increasing subsequence becomes 0 <sil=0.968> .PERIOD Read the next number <sil=0.973> .PERIOD 3 <sil=0.974> .PERIOD 3 is greater than 0 <sil=0.902> .PERIOD So <sil=0.434> ,COMMA you extend the subsequence <sil=0.960> .PERIOD S is now 0 <sil=0.458> ,COMMA 3 <sil=0.339> .PERIOD 4 is greater than 3 <sil=0.912> .PERIOD So <sil=0.598> ,COMMA the sequence becomes 0 <sil=0.503> ,COMMA 3 <sil=0.492> ,COMMA 4 and so on <sil=0.995> .PERIOD So <sil=0.597> ,COMMA what are we doing here <sil=0.901> ?QUESTIONMARK We are reading the numbers integer by integer and we are keeping track of the current increasing subsequence <sil=0.901> .PERIOD So <sil=0.626> ,COMMA this is part of what we want to do <sil=0.938> .PERIOD Now <sil=0.376> ,COMMA in order to decide whether we should increase the subsequence <sil=0.464> ,COMMA extend it or break the subsequence and start a new sequence <sil=0.919> .PERIOD What we need to do is we should remember what was the previous number we saw and what is the current number that we are seeing <sil=0.931> .PERIOD So <sil=0.321> ,COMMA with two variables <sil=0.534> ,COMMA we can say whether the subsequence should be extended or should be broken at this point <sil=0.967> .PERIOD So <sil=0.315> ,COMMA if the previous number is less than the current number <sil=0.397> ,COMMA then we should increase the <sil=0.315> ,COMMA we should extend the subsequence <sil=0.979> .PERIOD If the previous number is greater than or equal to the current number <sil=0.367> ,COMMA then we should break the subsequence and start a new sequence <sil=0.928> .PERIOD So <sil=0.637> ,COMMA extend the sequence means add one to the length of the current decreasing subsequence and add that number to the subsequence <sil=0.967> .PERIOD Reset means you start a new sequence of length 1 <sil=0.958> .PERIOD So <sil=0.478> ,COMMA from the current from the description that we have seen so far <sil=0.547> ,COMMA we need the following variables <sil=0.513> ,COMMA we need C which is for the current red number <sil=0.521> ,COMMA P which is the previous number that we have seen and length which is the length of the current increasing sequence <sil=0.968> .PERIOD So <sil=0.417> ,COMMA we store the previous number into P <sil=0.414> ,COMMA store the current length of the increasing subsequence into length and read the next number into C <sil=0.909> .PERIOD So <sil=0.498> ,COMMA if the previous number is less than the current number <sil=0.574> ,COMMA so we take the true branch in which case we extend the sequence <sil=0.953> .PERIOD So <sil=0.346> ,COMMA the new number that we have read is part of the currently increasing subsequence <sil=0.947> .PERIOD So <sil=0.303> ,COMMA increase the length of the sequence by 1 and now we move log step <sil=0.960> .PERIOD So <sil=0.513> ,COMMA what we do is <sil=0.315> ,COMMA so we are at a stage where suppose we have numbers 1 <sil=0.572> ,COMMA 2 and 3 <sil=0.644> ,COMMA suppose P was pointing to 1 <sil=0.434> ,COMMA C was pointing to 2 <sil=0.927> .PERIOD So <sil=0.342> ,COMMA since 2 was greater than 1 <sil=0.576> ,COMMA we extend the sequence <sil=0.923> .PERIOD After extending the sequence <sil=0.427> ,COMMA we have to proceed and see what will happen with the next number <sil=0.938> .PERIOD So <sil=0.401> ,COMMA when you do that <sil=0.584> ,COMMA you can do the following <sil=0.565> ,COMMA I will extend the current sequence by doing the following <sil=0.986> .PERIOD I will now set P equal to 2 and C equal to 3 <sil=0.937> .PERIOD So <sil=0.350> ,COMMA this is the idea that we will advance both the variables by 1 number each <sil=0.946> .PERIOD So <sil=0.371> ,COMMA that it is always true that previous is 1 number behind current <sil=0.994> .PERIOD So <sil=0.396> ,COMMA I hope this idea is clear that in order to ensure that P is 1 number behind current <sil=0.444> ,COMMA you have to advance both P and C <sil=0.992> .PERIOD So <sil=0.461> ,COMMA assign P to C <sil=0.413> ,COMMA this will advance P and then read the next number <sil=0.348> ,COMMA so that will become C <sil=0.959> .PERIOD Now <sil=0.469> ,COMMA what happens if C is greater than or equal to P <sil=0.890> ?QUESTIONMARK Then the new number is not part of the current increasing sub sequence <sil=0.989> .PERIOD So <sil=0.526> ,COMMA you start a new sequence which is of length 1 and again do the same <sil=0.389> ,COMMA assign P to C which is advancing the pointer and read the next number <sil=0.966> .PERIOD So <sil=0.308> ,COMMA here is the method that we will follow in order to keep track of the current increasing sub sequence <sil=0.925> .PERIOD Now <sil=0.517> ,COMMA what is left is to find the longest of all the increasing sub sequences that we find <sil=0.940> .PERIOD So <sil=0.592> ,COMMA we have been talking about designing programs using functions and the general philosophies that you have a large task that you want to accomplish and you break it into sub task <sil=0.364> ,COMMA maybe each of those sub task are split into smaller sub task and so on <sil=0.961> .PERIOD So <sil=0.449> ,COMMA break them until some sub task can be easily solved by a single function and then you put all these functions together in order to solve the whole problem <sil=0.930> .PERIOD So <sil=0.634> ,COMMA design your program from top down <sil=0.328> ,COMMA big task decomposing into small task and so on and debug your program or make sure that they are free of errors from the bottom up <sil=0.958> .PERIOD So <sil=0.629> ,COMMA test each function thoroughly and then test the overall program <sil=0.931> .PERIOD In this we will discuss a few technical details about how C executes its functions <sil=0.990> .PERIOD In particular we will see how C passes arguments to its functions and also how does it return values <sil=0.966> .PERIOD When passing arguments we will talk about issues like evaluation order <sil=0.582> ,COMMA in what are order arguments evaluated if there are multiple arguments and we will discuss what are known as side effects <sil=0.909> .PERIOD So <sil=0.648> ,COMMA let us start by considering a very simple example <sil=0.933> .PERIOD I have very simple function called sum which just adds up to variables x and y which are integers therefore <sil=0.538> ,COMMA the return value is also an integer <sil=0.954> .PERIOD Now <sil=0.490> ,COMMA inside the main program I will call a equal to sum of a b <sil=0.351> ,COMMA a is 1 and b is 2 and then you will sum this up and the return value is assigned to a <sil=0.933> .PERIOD So <sil=0.645> ,COMMA this is supposed to do 1 plus 2 <sil=0.343> ,COMMA 3 and a is assigned the value 3 <sil=0.975> .PERIOD So <sil=0.453> ,COMMA after passing the parameters sum is called with x as a which is 1 and y as b which is 2 <sil=0.956> .PERIOD So <sil=0.495> ,COMMA sum returns a 3 <sil=0.974> .PERIOD So <sil=0.340> ,COMMA the return value is 3 and the 3 is assigned back to a <sil=0.993> .PERIOD So <sil=0.425> ,COMMA when you print it the output will be 3 followed by 2 <sil=0.904> .PERIOD So <sil=0.307> ,COMMA this is simple enough <sil=0.955> .PERIOD Now <sil=0.312> ,COMMA let us try a slightly more tricky example <sil=0.943> .PERIOD So <sil=0.505> ,COMMA here is the novelty in this example <sil=0.901> .PERIOD Sum instead of being declared with a instead of being declared with x and y are now being declared with 2 variables called a and b <sil=0.935> .PERIOD The main program also has 2 variables named a and b <sil=0.900> .PERIOD So <sil=0.628> ,COMMA what will happen here <sil=0.981> ?QUESTIONMARK The output is the same as before <sil=0.983> .PERIOD So <sil=0.392> ,COMMA 3 <sil=0.503> ,COMMA 2 if you compile the program and execute it it will be the same as before <sil=0.924> .PERIOD So <sil=0.355> ,COMMA what really happened here after passing the parameters sum is called with a as 1 and b as 2 and so <sil=0.400> ,COMMA it returns a value 3 assigned to the a of main <sil=0.910> .PERIOD Now <sil=0.620> ,COMMA these variables are called a and b in main and they are called a and b in sum as well <sil=0.972> .PERIOD Now <sil=0.560> ,COMMA the variables a and b inside sum are different from the variables a and b inside main <sil=0.941> .PERIOD So <sil=0.599> ,COMMA the scope of these variables is main and the scope of these variables a and b is the sum function <sil=0.941> .PERIOD So <sil=0.484> ,COMMA in other words the a and b inside sum has scope just this function they are not visible or addressable outside especially in main <sil=0.985> .PERIOD So <sil=0.574> ,COMMA if you want to think of it you can think of them as sum dot a and sum dot b <sil=0.955> .PERIOD So <sil=0.579> ,COMMA they are the a variable belonging to sum and the b variable belonging to sum <sil=0.902> .PERIOD So <sil=0.513> ,COMMA even though you would think that this a and this a might get confused they are actually different variables one is the a variable belonging to main and the other is the a variable inside sum and they are different even though they have a common name <sil=0.911> .PERIOD So <sil=0.621> ,COMMA now let us try a slightly more elaborate program what happens if you have sum of sum of a b and then sum of that with comma b <sil=0.954> .PERIOD So <sil=0.503> ,COMMA this is the program in this case what will happen <sil=0.922> .PERIOD So <sil=0.541> ,COMMA first evaluate the inner program inner function sum of a b <sil=0.944> .PERIOD So <sil=0.364> ,COMMA a is 1 and b is 2 <sil=0.925> .PERIOD So <sil=0.336> ,COMMA the that will return 3 then you add b again to it b is 2 <sil=0.978> .PERIOD So <sil=0.537> ,COMMA you have 5 as the total sum <sil=0.931> .PERIOD So <sil=0.484> ,COMMA the total the complete output is a will be assigned 5 and b is still 2 <sil=0.943> .PERIOD So <sil=0.412> ,COMMA this is similar to evaluating a normal mathematical expression one thing that we need to take care of is to handle expressions with side effects <sil=0.968> .PERIOD Now <sil=0.508> ,COMMA what are expressions with side effects <sil=0.978> .PERIOD So <sil=0.574> ,COMMA let us classify expressions into 2 kinds one is what are known as pure expressions <sil=0.944> .PERIOD So <sil=0.347> ,COMMA they are the normal mathematical expressions like a minus b star c slash d and so on similarly <sil=0.479> ,COMMA evaluating functions these normally do not have any effect other than returning you the value <sil=0.952> .PERIOD So <sil=0.622> ,COMMA they will they will be correctly evaluated and they will return some value other than that they have no effect <sil=0.902> .PERIOD Now <sil=0.531> ,COMMA expressions with side effects change the state of the program for example <sil=0.513> ,COMMA when I execute an expression a equal to a plus 1 <sil=0.918> .PERIOD Now <sil=0.610> ,COMMA this is an expression it has a value <sil=0.999> .PERIOD So <sil=0.371> ,COMMA let us say that a was 1 before a equal to a plus 1 a plus 1 has value 2 and a is assign the value 2 <sil=0.900> .PERIOD The state of the program is involves for example <sil=0.321> ,COMMA what values are stored in the variables <sil=0.914> .PERIOD When you execute the expression a equal to a plus 1 the value of the variable a changes contrast this with previous expressions like a minus b star slash d <sil=0.984> .PERIOD You can see that unless you assign it to something no variables value is changing <sil=0.961> .PERIOD It will just be evaluated and the value will be returned <sil=0.933> .PERIOD Here the value will be returned also the variable a is changing <sil=0.904> .PERIOD Here in the second function you have 2 arguments to function f <sil=0.928> .PERIOD The first is an expression a equal to b plus 1 the second is an expression b equal to a plus 1 <sil=0.971> .PERIOD This might sound like a very strange way to code <sil=0.578> ,COMMA but you know that any expression can be given as arguments <sil=0.970> .PERIOD So <sil=0.588> ,COMMA in particular assignment expressions can be given as arguments for example <sil=0.370> ,COMMA a equal to b plus 1 is an assignment expression which is given as an argument to the function <sil=0.972> .PERIOD Now <sil=0.371> ,COMMA such expressions are called expressions with side effects because they change the state of the program <sil=0.929> .PERIOD When you have side effects you should be careful for example <sil=0.630> ,COMMA what will happen in the following program you have a function int minus int a int b and it returns b minus a <sil=0.983> .PERIOD Now <sil=0.396> ,COMMA in this program main calls the minus function with 2 expressions as arguments a equal to b plus 1 and b equal to a plus 1 <sil=0.959> .PERIOD They are expressions with side effects because once you evaluate these arguments you know that the variable a will change in the first expression and the variable b will change in the second expression <sil=0.960> .PERIOD So <sil=0.595> ,COMMA what will happen in this program <sil=0.958> ?QUESTIONMARK So <sil=0.383> ,COMMA how should be evaluated <sil=0.917> ?QUESTIONMARK The general rule is that all arguments are evaluated before the function called as made <sil=0.992> .PERIOD So <sil=0.572> ,COMMA before the function is executing we know that a equal to b plus 1 and b equal to a plus 1 both will be executed <sil=0.928> .PERIOD But and here is the major problem we know that both have to be executed <sil=0.619> ,COMMA but c does not specify in which order they have to be executed <sil=0.963> .PERIOD So <sil=0.458> ,COMMA it is left to the compiler <sil=0.944> .PERIOD So <sil=0.390> ,COMMA let us evaluate it in first in left to right order <sil=0.993> .PERIOD So <sil=0.553> ,COMMA this expression first and then b equal to a plus 1 <sil=0.942> .PERIOD So <sil=0.355> ,COMMA what will happen then <sil=0.856> ?QUESTIONMARK a equal to b plus 1 b is 1 <sil=0.959> .PERIOD So <sil=0.313> ,COMMA a will get the value 2 b equal to a plus 1 will be executed after that a is now 2 <sil=0.957> .PERIOD So <sil=0.363> ,COMMA b will get the value 3 <sil=0.981> .PERIOD Now <sil=0.421> ,COMMA you execute minus <sil=0.981> .PERIOD So <sil=0.587> ,COMMA b will be <sil=0.572> ,COMMA you will return 3 minus 2 which is 1 and b has value 3 <sil=0.927> .PERIOD So <sil=0.548> ,COMMA this is the expected output <sil=0.329> ,COMMA but when you run it on some machines you may get the output minus 1 3 <sil=0.944> .PERIOD So <sil=0.622> ,COMMA what happened here <sil=0.992> ?QUESTIONMARK Now <sil=0.324> ,COMMA this happens for example <sil=0.402> ,COMMA when the compiler would evaluate it right to left <sil=0.995> .PERIOD So <sil=0.501> ,COMMA when you evaluate it right to left what will happen is that b equal to a plus 1 will be executed first <sil=0.916> .PERIOD So <sil=0.586> ,COMMA b equal to a plus 1 <sil=0.939> .PERIOD So <sil=0.528> ,COMMA b gets the value 2 plus 1 3 and then you will execute the argue you will execute a equal to b plus 1 b is now 3 <sil=0.966> .PERIOD So <sil=0.480> ,COMMA a gets the value 4 <sil=0.941> .PERIOD So <sil=0.437> ,COMMA when you call minus of 3 minus of 4 comma 3 minus will return 3 minus 4 which is minus 1 <sil=0.944> .PERIOD So <sil=0.419> ,COMMA in this case you know that b gets the value 3 a gets the value 4 and the result will be minus 1 <sil=0.926> .PERIOD So <sil=0.335> ,COMMA what was the mistake <sil=0.937> ?QUESTIONMARK The mistake was that we assume that both arguments will be evaluated before the function is called <sil=0.379> ,COMMA but we assume that it will be evaluated left to right and the first expression will be evaluated before the second expression <sil=0.985> .PERIOD That is a reasonable assumption to make <sil=0.473> ,COMMA but c does not guarantee you that <sil=0.991> .PERIOD See leaves these decisions to the compiler <sil=0.920> .PERIOD Now <sil=0.326> ,COMMA compilers may evaluate arguments in different orders for example <sil=0.541> ,COMMA a very common order is right to left <sil=0.962> .PERIOD So <sil=0.618> ,COMMA both answers like 1 and 3 and minus 1 and 3 are both consistent with the c specification <sil=0.997> .PERIOD Now <sil=0.558> ,COMMA this is a very troubling scenario what should we do <sil=0.879> ?QUESTIONMARK So <sil=0.562> ,COMMA we should write these functions in such a way that they do not depend on whether the arguments are evaluated left to right or whether they are evaluated right to left <sil=0.930> .PERIOD So <sil=0.428> ,COMMA write expressions in such a way that they are free of side effects when you pass them to functions <sil=0.992> .PERIOD So <sil=0.408> ,COMMA how do we do that <sil=0.897> ?QUESTIONMARK We can do the following for example <sil=0.548> ,COMMA if we really wanted the left to right order that is if you want a equal to b plus 1 to happen first and then b equal to a plus 1 <sil=0.919> .PERIOD Why not write them explicitly in that order in the main function <sil=0.990> ?QUESTIONMARK So <sil=0.618> ,COMMA first this will be executed then b equal to a plus 1 will be executed <sil=0.929> .PERIOD So <sil=0.388> ,COMMA a will get the value 2 and then b will get the value 3 <sil=0.997> .PERIOD So <sil=0.347> ,COMMA minus of a comma b will execute as 3 minus 2 in which case you will get 1 <sil=0.939> .PERIOD So <sil=0.593> ,COMMA the important thing to note is that in this particular function called the arguments do not have any side effects because we explicitly coded them up before to specify that this is the order in which I want <sil=0.917> .PERIOD If I put it here then it is up to the compiler the compiler can do whatever is best in for several criteria <sil=0.998> .PERIOD So <sil=0.462> ,COMMA now let us come back to what the functions were we have the function definition which is the entire function the logic of the function is what is known as the function body and the heading is what we call the declaration the type signature <sil=0.961> .PERIOD The type signature has for example <sil=0.336> ,COMMA two arguments a and b these are called the formal parameters <sil=0.967> .PERIOD Now <sil=0.487> ,COMMA we focus on the return expression <sil=0.967> .PERIOD So <sil=0.422> ,COMMA return followed by some expression is the only mechanism for returning the value from a function <sil=0.973> .PERIOD If the type of the return expression does not match the declared type of the return <sil=0.965> .PERIOD So <sil=0.334> ,COMMA if for example <sil=0.456> ,COMMA a is of a variable which is different from int in this case they are they are the same then it is fine <sil=0.911> .PERIOD But otherwise the return expression is converted to this type and then return <sil=0.934> .PERIOD So <sil=0.587> ,COMMA it might lead to some undesirable behavior <sil=0.927> .PERIOD Now <sil=0.312> ,COMMA we have discussed parameter passing in when passing parameters in c the values from the calling function are copied to formal parameters in the called function <sil=0.915> .PERIOD So <sil=0.606> ,COMMA the actual parameters are converted to the formal parameter type and a separate copies made <sil=0.931> .PERIOD So <sil=0.636> ,COMMA this is known as called by value <sil=0.921> .PERIOD So <sil=0.494> ,COMMA formal parameters and local variables of the function are accessible only within the function we have already seen this and memory for the formal parameters and the local variables of the called function will be erased as soon as the function returns <sil=0.914> .PERIOD So <sil=0.480> ,COMMA executing return anywhere inside the function will immediately return from the function and transfer control back to the calling function at the specified return address <sil=0.912> .PERIOD So <sil=0.346> ,COMMA when you execute there are few things to keep in mind whenever you execute any return expression it will cause the function to immediately return <sil=0.940> .PERIOD Now <sil=0.541> ,COMMA main is a function <sil=0.966> .PERIOD So <sil=0.417> ,COMMA we can use return statements inside main what that means is that main will immediately stop execution that is the whole program will stop execution <sil=0.990> .PERIOD Now <sil=0.422> ,COMMA when you return a particular value the calling function may choose to ignore the value for example <sil=0.335> ,COMMA let us say that I write some dummy function int f and it takes two arguments float a and int b and we have some code here <sil=0.950> .PERIOD And then I have the main function in which I have two variables int x and float y and then I have some code and here is the interesting thing I call f of y comma x y is a float x is an int <sil=0.974> .PERIOD So <sil=0.393> ,COMMA I am fine <sil=0.438> ,COMMA but this function returns an integer value <sil=0.404> ,COMMA but I am not assigning it to anything <sil=0.932> .PERIOD So <sil=0.344> ,COMMA I am not saying something like x equal to f of y comma x <sil=0.939> .PERIOD So <sil=0.582> ,COMMA this is not required <sil=0.993> .PERIOD So <sil=0.485> ,COMMA if this is the case then y call the function in the first place this is because the function also may have side effects <sil=0.975> .PERIOD So <sil=0.338> ,COMMA remember that side effects are something some expressions which change the state of the program <sil=0.920> .PERIOD So <sil=0.541> ,COMMA functions may have side effects you have already seen one such function which has a side effect for example <sil=0.307> ,COMMA scan f <sil=0.998> .PERIOD So <sil=0.576> ,COMMA the side effect of calling scan f is that the input from the keyboard is copied into some variable <sil=0.962> .PERIOD So <sil=0.321> ,COMMA functions may have side effects this is why you can call the function and choose to ignore the output of the return value <sil=0.981> .PERIOD Now <sil=0.507> ,COMMA just for curiosity sake executing return will cause the function to immediately return to the return address <sil=0.906> .PERIOD Now <sil=0.446> ,COMMA the return value if you omit it then the return value is unpredictable <sil=0.930> .PERIOD So <sil=0.431> ,COMMA here is a example you should in general avoid doing things like this <sil=0.611> ,COMMA but just for completeness I am supposed to return a float value instead if I just say return the program will compile <sil=0.498> ,COMMA but when you execute some unpredictable behavior may result <sil=0.912> .PERIOD So <sil=0.349> ,COMMA the printed value in this case can in general be not predicted <sil=0.991> .PERIOD With the concepts we have seen so far <sil=0.649> ,COMMA let us design a sample program <sil=0.934> .PERIOD So <sil=0.546> ,COMMA the problem that we want to solve is <sil=0.311> ,COMMA we want to write a program that reads the input line by line and counts how many lines has the user input <sil=0.917> .PERIOD Program should terminate when the end of file character is encountered <sil=0.931> .PERIOD So <sil=0.622> ,COMMA we will try to solve this problem <sil=0.904> .PERIOD By the way the end of file is a character which you can enter using control D if you are running Linux <sil=0.935> .PERIOD So <sil=0.380> ,COMMA the flow chart at the very top level can be envisioned as follows <sil=0.970> .PERIOD So <sil=0.465> ,COMMA we will just check as the end of file been reached <sil=0.949> .PERIOD If the end of file has not been reached <sil=0.428> ,COMMA you read the next line <sil=0.923> .PERIOD If it has been and check again <sil=0.521> ,COMMA if the end of file has been reached then you have halt otherwise you read another line <sil=0.949> .PERIOD So <sil=0.363> ,COMMA here is the very top level picture of what we want to do <sil=0.915> .PERIOD So <sil=0.367> ,COMMA this design is just meant to read the input line by line <sil=0.963> .PERIOD So <sil=0.326> ,COMMA it is a very vague flow chart <sil=0.524> ,COMMA but at the top level this is what we want to do <sil=0.963> .PERIOD So <sil=0.629> ,COMMA let us say more details about how we are going to accomplish this <sil=0.943> .PERIOD In particular we want to see how we can read and put line by line <sil=0.969> .PERIOD So <sil=0.617> ,COMMA here is the top level design and now we are going to essentially expand this box <sil=0.998> .PERIOD We want to say how do we read the next line <sil=0.931> .PERIOD So <sil=0.317> ,COMMA let us design the read next line box <sil=0.962> .PERIOD So <sil=0.389> ,COMMA the read next line box first you read a character and then you check whether the character read is new line character <sil=0.969> .PERIOD That means that the user has pressed and entered <sil=0.912> .PERIOD So <sil=0.469> ,COMMA the line is entered at that point or the user can enter a bunch of characters and instead of pressing enter press control D <sil=0.985> .PERIOD So <sil=0.417> ,COMMA the user can enter end of file <sil=0.978> .PERIOD If either of these are true then the line has ended <sil=0.969> .PERIOD So <sil=0.617> ,COMMA you hold <sil=0.982> .PERIOD Otherwise if the character is neither new line nor end of file then you read the next character <sil=0.946> .PERIOD So <sil=0.389> ,COMMA here is the design for the function to read the next character <sil=0.512> ,COMMA the next line <sil=0.976> .PERIOD So <sil=0.530> ,COMMA you read character by character after every character you check whether a new line or an end of file has been encountered <sil=0.996> .PERIOD If either of them happen then the line has ended otherwise you go back and read another character <sil=1.000> .PERIOD So <sil=0.332> ,COMMA let us start by writing the top level function <sil=0.965> .PERIOD So <sil=0.399> ,COMMA let us translate the top level function into code <sil=0.931> .PERIOD So <sil=0.600> ,COMMA here we will introduce a new concept called what is known as a forward declaration <sil=0.924> .PERIOD So <sil=0.604> ,COMMA when you define a function you can either give the logic the full function body when you define the function or you can just say that here is what the function will look like <sil=0.939> .PERIOD Here is the type signature basically it is taking no arguments and it will return an integer value <sil=0.990> .PERIOD And I will terminate that statement by using a semicolon which says that this function I will currently just say the type of the function I will define the function later <sil=0.966> .PERIOD This is done so that we can write a function which uses this particular function <sil=0.920> .PERIOD So <sil=0.340> ,COMMA when we write a function which uses that function the type of the function should be known for that we can just declare the type of the function this is what is known as a declaration of a function <sil=0.993> .PERIOD Unless you define the function you cannot use it but in order for another function to just see what the function looks like the declaration is sufficient <sil=0.907> .PERIOD So <sil=0.367> ,COMMA let us design the top level function <sil=0.968> .PERIOD So <sil=0.606> ,COMMA we declare this function that we will use in this function that we are about to write <sil=0.917> .PERIOD So <sil=0.542> ,COMMA this user function will be called read all lines <sil=0.916> .PERIOD Now <sil=0.514> ,COMMA in that we will keep a line count initialized to 0 and then I will keep a flag called ease line <sil=0.979> .PERIOD Now <sil=0.623> ,COMMA what this will do is we have to check for whether an end of file has been reached or not for that I will use the function F e o f S T d I n we will see that in a minute <sil=0.991> .PERIOD While the end of file has not been encountered you say that read next line <sil=0.918> .PERIOD Read next line will return a 1 if a line has been encountered otherwise it will return a 0 <sil=0.919> .PERIOD So <sil=0.332> ,COMMA line count will be incremented by 1 if I read another line otherwise it will remain as it is <sil=0.944> .PERIOD Finally <sil=0.619> ,COMMA you return the number of lines read <sil=0.963> .PERIOD So <sil=0.338> ,COMMA this is a realization of the flow chart on the left <sil=0.960> .PERIOD Now <sil=0.506> ,COMMA there are a couple of things that require explanation <sil=0.972> .PERIOD This is that even though the read next line function has not yet been defined just based on the declaration I can say that it is going to return an integer and I can use the integer here <sil=0.909> .PERIOD The other thing is what do we mean by F e o f S T d I n <sil=0.983> .PERIOD So <sil=0.349> ,COMMA what do we mean by the function so what do we mean by the function F e o f <sil=0.962> .PERIOD So <sil=0.428> ,COMMA F e o f S T d I n is a function that is part of the S T d I a a a a a a a a a a a a a a a a a a a a a a a a a a already used other functions from that a a a a a a a b for example <sil=0.387> ,COMMA print a f and scan a <sil=0.921> .PERIOD Now <sil=0.587> ,COMMA the F e o f function what it does is it returns a function it returns a value 1 if If the end of file has been encountered in the input argument <sil=0.936> .PERIOD So <sil=0.643> ,COMMA STDIN means that I am using the standard input which is the keyboard input <sil=0.942> .PERIOD So if an end of file has been entered via the keyboard then FeoF STDIN will return 1 <sil=0.935> .PERIOD So STDIN is usually the keyboard input and if usually if the user enters the control D character then FeoF will say 1 because end of file has been entered <sil=0.955> .PERIOD Now let us design the function to read a line <sil=0.927> .PERIOD The earlier wrote a function which assume that there is a function which will read the next line and based on that I will keep on reading lines until the end of file is encountered <sil=0.943> .PERIOD So we are now about to write the bottom function <sil=0.928> .PERIOD So we want to read a line <sil=0.964> .PERIOD So we have already drawn the flow chart for that <sil=0.908> .PERIOD Now let us try to make it into code <sil=0.992> .PERIOD So we have to define a few variables <sil=0.918> .PERIOD We will have int CH for reading a character <sil=0.923> .PERIOD We will come to that in a minute <sil=0.909> .PERIOD Then we will keep account of how many characters have been read <sil=0.996> .PERIOD And let us write the basic loop <sil=0.919> .PERIOD So we will just write the loop corresponding to the flow chart <sil=0.980> .PERIOD CH will be get chart <sil=0.937> .PERIOD So get the next character and while CH is <sil=0.399> ,COMMA while the red character is neither end of file nor new line you should keep reading characters <sil=0.921> .PERIOD So if neither of these is true then you should read the next character which is what the flow chart says <sil=0.943> .PERIOD A small point here is that get chart returns an integer <sil=0.983> .PERIOD This is a technicality because end of file is negative 1 <sil=0.969> .PERIOD So if you remember go from 0 until 127 or something like that whereas end of file is defined to be minus 1 <sil=0.954> .PERIOD So because of this minus 1 you cannot keep the return value of get chart as a character <sil=0.999> .PERIOD It technically has to be an integer <sil=0.916> .PERIOD This is a technicality <sil=0.988> .PERIOD So keep that in mind <sil=0.940> .PERIOD Now we need to do something further in the loop <sil=0.920> .PERIOD So we will complete this in a minute <sil=0.935> .PERIOD So what should we do inside the loop <sil=0.916> ?QUESTIONMARK This should be character <sil=0.901> .PERIOD So what is this function supposed to do overall <sil=0.885> ?QUESTIONMARK We have to return a 1 if the number of characters in the current line that we have read is at least 1 <sil=0.923> .PERIOD So if the current line contains at least a character then we have to return 1 <sil=0.985> .PERIOD For example if the user just entered a new line which is just press the enter key then it is a blank line <sil=0.937> .PERIOD In that case we will not say that we have read a line because it was a blank line <sil=0.929> .PERIOD So if there is at least one character which is neither new line nor end of file in that line we have to return a 1 <sil=0.928> .PERIOD Otherwise let us say we return a 0 <sil=0.996> .PERIOD So one way to do that is to keep account of the number of characters we have read <sil=0.980> .PERIOD So for every character read we will keep account of every character which is neither end of file nor a new line we will keep account of characters <sil=0.988> .PERIOD So notice the way that the loop has been written <sil=0.915> .PERIOD So if the first character is a new line it will not enter the loop hence count remains 0 <sil=0.943> .PERIOD At the same time the way the loop is written count will count exactly those characters which are neither new line nor end of file <sil=0.934> .PERIOD So now let us decide what should be the return value <sil=0.933> .PERIOD We have to return a 1 if the number of characters in the current line including new line is at least 1 <sil=0.988> .PERIOD So if count is greater than 0 we can return a 1 <sil=0.986> .PERIOD If exactly 1 if the last character was end of file without having any other characters then we return a 0 <sil=0.903> .PERIOD So how do we do that <sil=0.885> ?QUESTIONMARK We can check whether at least a character has been read by just checking the value of count <sil=0.919> .PERIOD So if count is greater than 0 then at least one character has been entered <sil=0.955> .PERIOD Otherwise for example we can also say that if the user has just entered a blank line then also we can say that one more line has been entered <sil=0.902> .PERIOD So that is up to the way you want to do it <sil=0.945> .PERIOD You can also take the stands that may be a blank line does not count as a line <sil=0.913> .PERIOD If that is the case then you do not have to do it <sil=0.973> .PERIOD But in this case let us just assume that if at least a character has been entered which is either a normal character on a new line we will say that return 1 <sil=0.910> .PERIOD If the only character entered in that line is end of file we will say that there is no more new line <sil=0.957> .PERIOD So what we have to do is return count greater than 0 this tells you how many non-new line non-end of file characters have been entered <sil=0.960> .PERIOD So this should be at least at least 1 or there is exactly one character entered which is a new line <sil=0.991> .PERIOD So in either these characters cases we will return a 1 otherwise we will return a 0 <sil=0.968> .PERIOD So we can put these program together by concatenating all the code that we have written <sil=0.978> .PERIOD Notice one thing that declare the function first we use the function here <sil=0.921> .PERIOD So here is a top level function which will use a read next line <sil=0.989> .PERIOD And read all lines uses read next line <sil=0.991> .PERIOD Read next line has not been defined yet <sil=0.938> .PERIOD So you can go here after read all lines has been defined you can define read next line <sil=0.947> .PERIOD So here is the function here <sil=0.955> .PERIOD So this is function 1 this is function 2 and finally you have made <sil=0.969> .PERIOD Read all lines does not need any forward declaration because when main uses read all lines it has already been defined <sil=0.957> .PERIOD That was not the case here when read all lines used read next line read next line was not defined yet that is why we needed a forward declaration <sil=0.967> .PERIOD In this program you can reorder the code such that read next line code can be written before in which case you do not need the forward declaration but the concept of forward declaration is useful for later discussions <sil=0.983> .PERIOD So I am just introduce that <sil=0.942> .PERIOD In this lecture <sil=0.367> ,COMMA we will just talk about how to initialize arrays <sil=0.951> .PERIOD So <sil=0.360> ,COMMA recall that we have defined arrays as follows <sil=0.922> .PERIOD If we declare an array float W 100 <sil=0.641> ,COMMA it will declare an array of floats of 100 floats consecutively allocated in memory <sil=0.958> .PERIOD And we have also mentioned the fact that there is a separate box W which will point to the first location in the array <sil=0.950> .PERIOD So <sil=0.547> ,COMMA it contains the address of the first location <sil=0.937> .PERIOD In num 10 <sil=0.541> ,COMMA we will declare an integer array of 10 integers plus one box which will hold the address of the first location and so on <sil=0.948> .PERIOD So <sil=0.410> ,COMMA the arrays names the cells of the array or the elements of the array are indexed from sub W 0 through W 99 <sil=0.924> .PERIOD The indices start from 0 <sil=0.956> .PERIOD We have also mentioned that conceptually there is a separate variable called W the name of the array which stores the address of W 0 <sil=0.983> .PERIOD Now it is not important that we use numbers as the size of the arrays <sil=0.938> .PERIOD We can also use constant expressions <sil=0.928> .PERIOD For example <sil=0.339> ,COMMA we can say float W 10 star 10 <sil=0.977> .PERIOD So <sil=0.576> ,COMMA instead of saying 100 <sil=0.311> ,COMMA we can give an arithmetic expression which evaluates to 100 <sil=0.958> .PERIOD And this has the same effect <sil=0.341> ,COMMA it will allocate an array of 100 elements starting from W 0 through W 99 <sil=0.950> .PERIOD And there is a separate box called W which will see address of the first location <sil=0.927> .PERIOD But what about using variables or variable size arrays <sil=0.922> ?QUESTIONMARK This is a feature that we often wish we had <sil=0.973> .PERIOD So <sil=0.596> ,COMMA what do I mean by that <sil=0.878> ?QUESTIONMARK I could declare the following code int size and then float W size <sil=0.919> .PERIOD And I could say scan F percentage D and size <sil=0.918> .PERIOD So <sil=0.322> ,COMMA a user enters the size of the array and then I can enter 10 elements into the array for example <sil=0.924> .PERIOD But here the size of the array itself is a variable which depends on the user input <sil=0.940> .PERIOD And we often wish that we would be able to allocate variable size arrays <sil=0.966> .PERIOD But this is not allowed in an CC <sil=0.957> .PERIOD It is allowed in the latest versions of CC 99 <sil=0.614> ,COMMA C 11 and so on <sil=0.958> .PERIOD We will avoid this feature for the purposes of this course <sil=0.943> .PERIOD Let us assume that array means they are declared to be of constant size <sil=0.935> .PERIOD By constant size you can give the size as a particular number or you can give it as a constant expression <sil=0.995> .PERIOD That is an arithmetic expression involving constants <sil=0.621> ,COMMA but not general expressions <sil=0.989> .PERIOD Now let us just look at how can we create an integer array in num and also initialize it to particular values <sil=0.998> .PERIOD For example <sil=0.450> ,COMMA I want the num array to look like the following <sil=0.921> .PERIOD It contains 7 cells having the values minus 2 <sil=0.517> ,COMMA 3 <sil=0.425> ,COMMA 5 <sil=0.357> ,COMMA minus 7 and so on <sil=0.956> .PERIOD Now I know that if C did not allow me to initialize arrays when I declared it <sil=0.473> ,COMMA I could declare the array as int num 7 <sil=0.964> .PERIOD And then I will just write num 0 equal to minus 2 num 1 equal to 3 and so on until num 6 equal to 11 <sil=0.981> .PERIOD So <sil=0.534> ,COMMA here is a way that I can create an array and ensure that this state is reached <sil=0.975> .PERIOD But is there a more convenient way of doing it <sil=0.866> ?QUESTIONMARK Can I start off the array with these contents <sil=0.881> ?QUESTIONMARK So C allows you two ways to do it <sil=0.991> .PERIOD The first is I declare an int num and then specify what are the initial values <sil=0.947> .PERIOD So <sil=0.559> ,COMMA minus 2 <sil=0.388> ,COMMA so on up to minus 11 within curly braces <sil=0.941> .PERIOD So <sil=0.545> ,COMMA this is one way that C allows you to do this <sil=0.955> .PERIOD The initial values are placed within curly braces and separated by commas <sil=0.955> .PERIOD The size of the array need not be specified <sil=0.948> .PERIOD So <sil=0.432> ,COMMA I did not say that num has size 7 <sil=0.955> .PERIOD It will allocate an array with enough space to hold 7 integers <sil=0.935> .PERIOD Array elements are assigned in the order that you specified <sil=0.976> .PERIOD So <sil=0.459> ,COMMA num 0 will be minus 2 <sil=0.488> ,COMMA num 1 will be 3 and so on <sil=0.933> .PERIOD So <sil=0.592> ,COMMA it is done in a reasonable manner <sil=0.910> .PERIOD There is also another way to do it which is slightly different from the way above <sil=0.973> .PERIOD I can declare the size of an array <sil=0.946> .PERIOD So <sil=0.617> ,COMMA I declare an array of size 10 and then give these initial values <sil=0.980> .PERIOD What will happen in this case is that it will make sure that the size of the array is at least equal to the size of the list that I have given <sil=0.906> .PERIOD So <sil=0.341> ,COMMA I have given 7 elements and I have declared an array of size 10 <sil=0.961> .PERIOD 7 is less than 10 <sil=0.902> .PERIOD So <sil=0.317> ,COMMA it is fine <sil=0.969> .PERIOD So <sil=0.517> ,COMMA I can declare an array of size 10 <sil=0.991> .PERIOD I should give a value <sil=0.479> ,COMMA I should give values at most 10 in number <sil=0.923> .PERIOD So <sil=0.455> ,COMMA I can give 10 or below <sil=0.902> .PERIOD In this case I give 7 numbers <sil=0.965> .PERIOD So <sil=0.562> ,COMMA what happens is that array is initialized in the order of elements given <sil=0.905> .PERIOD NUM 0 will be minus 2 <sil=0.383> ,COMMA num 1 will be 3 and so on until num 6 will be 11 <sil=0.972> .PERIOD 7 elements are filled <sil=0.966> .PERIOD The remaining 7 elements are unspecified <sil=0.947> .PERIOD So <sil=0.525> ,COMMA they will be initialized to 0 <sil=0.931> .PERIOD Now <sil=0.635> ,COMMA let me just remind you that if I had just declared an array in num 10 and then put a semicolon <sil=0.986> .PERIOD So <sil=0.477> ,COMMA I have just declared an array without saying any initialization at all <sil=0.989> .PERIOD Then you should assume that the array contains arbitrary values <sil=0.992> .PERIOD You should assume that the array contains junk values <sil=0.973> .PERIOD But if you initialize an array of size 10 and give only 7 initialization values <sil=0.512> ,COMMA then the C standard gives you the guarantee that the remaining elements are initialized to 0 <sil=0.950> .PERIOD So <sil=0.438> ,COMMA they are not junk <sil=0.998> .PERIOD The recommended method to initialize an array is to give the list of initial values and let the compiler decide what the size of the array should be <sil=0.987> .PERIOD So <sil=0.479> ,COMMA if you give 7 initial values <sil=0.413> ,COMMA it will decide that the array is of size 7 <sil=0.904> .PERIOD Now <sil=0.457> ,COMMA is the following code correct if I declare an array of size 100 num and give 4 initial values <sil=0.960> .PERIOD So <sil=0.340> ,COMMA this is correct <sil=0.970> .PERIOD It creates num as an array of size 100 <sil=0.911> .PERIOD The first 4 entries will be initialized as given <sil=0.917> .PERIOD So <sil=0.340> ,COMMA num 0 will be 0 <sil=0.996> .PERIOD num 1 will be minus 1 <sil=0.990> .PERIOD num 2 will be 1 <sil=0.926> .PERIOD num 3 will be minus 1 <sil=0.934> .PERIOD And then num 4 until num 99 <sil=0.340> ,COMMA they are all set to 0 <sil=0.996> .PERIOD So <sil=0.537> ,COMMA after the initialization <sil=0.643> ,COMMA the array will look as follows <sil=0.961> .PERIOD The first 4 values are what we give and the remaining values are 0 <sil=0.945> .PERIOD Now <sil=0.519> ,COMMA is the following code correct num 6 equal to and then you give a list of 7 values to initialize <sil=0.995> .PERIOD Is this correct <sil=0.912> ?QUESTIONMARK The answer is no <sil=0.928> .PERIOD It will not compile <sil=0.957> .PERIOD So <sil=0.581> ,COMMA if you write this code and compile it using gcc <sil=0.436> ,COMMA you will get a compilation error <sil=0.982> .PERIOD Why is that <sil=0.891> ?QUESTIONMARK We have declared an array of size 6 <sil=0.301> ,COMMA but we have given 7 initial values <sil=0.942> .PERIOD So <sil=0.445> ,COMMA there is no way to do this <sil=0.957> .PERIOD So <sil=0.444> ,COMMA the rule of thumb is that either give no size for the array and let the compiler figure out <sil=0.944> .PERIOD Or if you do give a size <sil=0.339> ,COMMA it has to be at least 7 <sil=0.619> ,COMMA which is the number of values that you gave <sil=0.907> .PERIOD It can be 10 <sil=0.375> ,COMMA it can be 100 <sil=0.470> ,COMMA but it cannot be less than 7 <sil=0.964> .PERIOD Now <sil=0.394> ,COMMA just like size can be not just numbers <sil=0.429> ,COMMA it can also be constant expressions <sil=0.956> .PERIOD We can also have constant expressions as initialization values <sil=0.988> .PERIOD So <sil=0.444> ,COMMA for example <sil=0.319> ,COMMA I can give num equal to 109 <sil=0.920> .PERIOD Then the character value a <sil=0.574> ,COMMA character value a means it will take the ASCII value of a <sil=0.576> ,COMMA 65 or whatever it is <sil=0.934> .PERIOD So <sil=0.581> ,COMMA the first number will be 109 <sil=0.545> ,COMMA the second number will be 65 <sil=0.424> ,COMMA let us say <sil=0.339> ,COMMA if the ASCII value of a is 65 <sil=0.927> .PERIOD And the third value will be 7 star <sil=0.446> ,COMMA 25 star <sil=0.608> ,COMMA 1023 plus the character constant 1 <sil=0.957> .PERIOD So <sil=0.435> ,COMMA whatever the ASCII value of the character 1 is <sil=0.602> ,COMMA let us say 90 or something <sil=0.927> .PERIOD So <sil=0.524> ,COMMA it will be added to this constant expression and it will be initialized to that value <sil=0.901> .PERIOD Num 2 will be the result of evaluating this expression <sil=0.926> .PERIOD So <sil=0.574> ,COMMA the type of each initialization constant should be promotable or demotable to the array element type <sil=0.910> .PERIOD So <sil=0.378> ,COMMA each value in the initialization list should be compatible with <sil=0.399> ,COMMA let us say <sil=0.390> ,COMMA integer <sil=0.521> ,COMMA because we have declared the array of type integer <sil=0.943> .PERIOD So <sil=0.344> ,COMMA what do I mean by that <sil=0.887> ?QUESTIONMARK For example <sil=0.420> ,COMMA I can initialize an array num with the initialization list 1 <sil=0.970> .PERIOD 09 <sil=0.640> ,COMMA then comma a <sil=0.613> ,COMMA comma 25 <sil=0.983> .PERIOD 05 <sil=0.901> .PERIOD So <sil=0.317> ,COMMA this is okay <sil=0.495> ,COMMA because the floating point values can be downgraded to integers <sil=0.986> .PERIOD So <sil=0.464> ,COMMA maybe this will be initialized to 1 <sil=0.590> ,COMMA then whatever the ASCII value of a is <sil=0.391> ,COMMA let us say <sil=0.371> ,COMMA 65 and then 25 <sil=0.962> .PERIOD Now <sil=0.534> ,COMMA these are about constant expressions <sil=0.911> .PERIOD What about expressions involving variables when we initialize an array <sil=0.929> ?QUESTIONMARK So <sil=0.438> ,COMMA can we do something like this <sil=0.918> ?QUESTIONMARK Int CURR equal to 5 and then the num array is initialized with 2 <sil=0.573> ,COMMA current star current plus 5 <sil=0.995> .PERIOD Will this work <sil=0.945> ?QUESTIONMARK The answer surprisingly is that it will work on most compilers <sil=0.982> .PERIOD So <sil=0.439> ,COMMA the MCC allows constants expressions and simple expressions for initialization values <sil=0.904> .PERIOD Now <sil=0.332> ,COMMA simple is of course <sil=0.638> ,COMMA dependent on which compiler you are using <sil=0.986> .PERIOD So <sil=0.301> ,COMMA if you write your code and compile using GCC with such an initialization <sil=0.329> ,COMMA maybe your code will compile <sil=0.971> .PERIOD And the moment you compile your code with a different compiler <sil=0.432> ,COMMA it may not compile <sil=0.937> .PERIOD So <sil=0.565> ,COMMA earlier I had said that the size of the array cannot be initialized using variable expressions <sil=0.944> .PERIOD In MCC that is forbidden <sil=0.906> .PERIOD But the initialization value <sil=0.330> ,COMMA so the value that goes into the array can involve variable expressions <sil=0.904> .PERIOD This may or may not be supported <sil=0.956> .PERIOD So <sil=0.341> ,COMMA it is safe to assume that both the size of the array and the initialization value can be done only using constant expressions <sil=0.946> .PERIOD Even though some compilers allow simple initialization values using variable expressions <sil=0.974> .PERIOD Now <sil=0.409> ,COMMA how do we initialize character arrays <sil=0.996> ?QUESTIONMARK Character arrays can be initialized like arrays of any other type <sil=0.913> .PERIOD Suppose <sil=0.478> ,COMMA we want the following array s equal to i space a space m space etcetera <sil=0.955> .PERIOD So <sil=0.595> ,COMMA I can initialize it just like I initialize the other array <sil=0.922> .PERIOD I will not specify the size of s and then give these characters i am done <sil=0.968> .PERIOD So <sil=0.643> ,COMMA this is another way to specify it and the last character is a null character <sil=0.982> .PERIOD But <sil=0.406> ,COMMA c also allows you to define what are known as string constants <sil=0.910> .PERIOD So <sil=0.443> ,COMMA we can also write s equal to i am done <sil=0.336> ,COMMA but now within double codes <sil=0.955> .PERIOD So <sil=0.570> ,COMMA this is known as a string constant <sil=0.911> .PERIOD The null character is an implicit ending character inside a string constant <sil=0.949> .PERIOD So <sil=0.636> ,COMMA it is automatically added to the end <sil=0.954> .PERIOD Now <sil=0.387> ,COMMA the string constants in c are specified by enclosing it in double codes <sil=0.925> .PERIOD In this video we will look at the last possibility with respect to multi dimensional arrays and pointers <sil=0.956> .PERIOD This is known as an array of arrays <sil=0.935> .PERIOD In order to understand this <sil=0.479> ,COMMA let us just look at something we are comfortable with <sil=0.965> .PERIOD If I had just a float array of 10 elements <sil=0.423> ,COMMA then how would I read this <sil=0.883> ?QUESTIONMARK I will say that array is aarrr is an array of 10 floats <sil=0.929> .PERIOD So <sil=0.500> ,COMMA this is how I would read it <sil=0.973> .PERIOD If I have more complicated declaration like aarrr star <sil=0.640> ,COMMA a strings <sil=0.921> .PERIOD So <sil=0.341> ,COMMA notice that the precedence for the square blackheads is higher than that of the precedence for star <sil=0.941> .PERIOD So <sil=0.610> ,COMMA this would actually be read as strings is an array of 7 characters stars <sil=0.971> .PERIOD So <sil=0.492> ,COMMA that is how it would be read because 7 would bind closer to strings <sil=0.964> .PERIOD So <sil=0.626> ,COMMA strings will become an array of size 7 and what type is it <sil=0.901> ?QUESTIONMARK It is character star <sil=0.908> .PERIOD So <sil=0.448> ,COMMA you replace float with character star and it is roughly the same phenomenon <sil=0.923> .PERIOD So <sil=0.422> ,COMMA the pictorially you can think of it like this <sil=0.988> .PERIOD So <sil=0.467> ,COMMA you have 7 cells in strings and each entry is a character star <sil=0.974> .PERIOD So <sil=0.381> ,COMMA each entry is a character pointer <sil=0.944> .PERIOD You can think of it as a string <sil=0.988> .PERIOD You can think of it as a character array whatever <sil=0.964> .PERIOD Here is the pictorial representation <sil=0.961> .PERIOD Let us look at why we would need such a structure and what is the advantage of it <sil=0.865> ?QUESTIONMARK This is a very popular structure almost as popular as two dimensional arrays themselves <sil=0.907> .PERIOD So <sil=0.551> ,COMMA let us look at what it means for when we allocate character star an array of arrays <sil=0.950> .PERIOD So <sil=0.336> ,COMMA we may want to let us say store the names of several movies and one of the things is that there is no maximum limit to the name of a movie <sil=0.970> .PERIOD I mean it can be as long as you want it can be as short as you want and suppose you want to store all of this in a data <sil=0.927> .PERIOD So <sil=0.300> ,COMMA let us say that we have character star movies and I declare it as an array of arrays and it contains the first array is done to the second is raven and so on <sil=0.913> .PERIOD Now <sil=0.482> ,COMMA how will we do this <sil=0.923> ?QUESTIONMARK So <sil=0.486> ,COMMA one way to do this is you say that movies is pointing to an array of arrays <sil=0.986> .PERIOD So <sil=0.629> ,COMMA movies plus one is pointing to another character array movies plus two is pointing to another character array and so on <sil=0.950> .PERIOD So <sil=0.626> ,COMMA this is how you pictorially represent it <sil=0.968> .PERIOD There are three entries and each entry is a character pointer <sil=0.924> .PERIOD So <sil=0.637> ,COMMA it can point to any character array whatsoever and here is the here you see the distinct advantage of this kind of representation over 2 D matrices <sil=0.978> .PERIOD Why <sil=0.931> ?QUESTIONMARK Because in 2 D matrices the whole point was the number of columns was fixed that is how the pointer arithmetic worked <sil=0.919> .PERIOD Here the number of columns in one row can be different from the number of columns in another row <sil=0.971> .PERIOD So <sil=0.337> ,COMMA this representation is actually more useful when you have what are known as a ragged arrays that is one row and the next row may have very different lengths and here is a natural situation of storing strings when you need such a facility <sil=0.998> .PERIOD So <sil=0.356> ,COMMA let us see what this means type of the variable movies is a pointer to a pointer to character or character star star <sil=0.955> .PERIOD Now <sil=0.562> ,COMMA type of star movies is character star because you dereference one level and type of star star movies is character <sil=0.905> .PERIOD So <sil=0.444> ,COMMA let us look at it once more <sil=0.955> .PERIOD So <sil=0.633> ,COMMA star movies has type character star <sil=0.965> .PERIOD So <sil=0.380> ,COMMA in particular star movies will be this array it is pointing to this array <sil=0.976> .PERIOD So <sil=0.586> ,COMMA star star movies will be what is it according to the general formula this will be star of star of movies plus 0 plus 0 <sil=0.981> .PERIOD So <sil=0.487> ,COMMA this will be the pointer arithmetic version of accessing this cell which contains D <sil=0.981> .PERIOD But instead you could also write movies 0 0 <sil=0.975> .PERIOD Similarly <sil=0.349> ,COMMA in order to get to the last cell here you could say star of star movies plus 5 <sil=0.985> .PERIOD It is the particular application of the general formula <sil=0.943> .PERIOD The second row will be star of movies plus 1 again try to think in whichever notion you are comfortable with because you can also write this as movies 1 <sil=0.964> .PERIOD It will you will get the same result <sil=0.987> .PERIOD So <sil=0.301> ,COMMA star of movies plus 1 will come to the second row and you have star of star movies plus 1 that would come to the first element in the second row and so on <sil=0.969> .PERIOD So <sil=0.309> ,COMMA star of movies plus 2 would be the third array in the in this structure and here is how you access different elements in the third array <sil=0.989> .PERIOD So <sil=0.579> ,COMMA notice the picture is slightly different here even the representation suggests that these rows need not be continuous in memory <sil=0.965> .PERIOD So <sil=0.399> ,COMMA then location after this row ends need not be this row <sil=0.981> .PERIOD So <sil=0.558> ,COMMA the second row can be located arbitrarily far away in memory <sil=0.972> .PERIOD The advantage due to that is that these rows can be of different length they are not packed as in the 2D array <sil=0.932> .PERIOD So <sil=0.591> ,COMMA let us look at this particular thing in detail so that you get comfortable with it <sil=0.904> .PERIOD So <sil=0.505> ,COMMA suppose you have that array and I consider what is printf percentages movies 2 <sil=0.908> .PERIOD Movies 2 will be the third character array that is present in the structure <sil=0.928> .PERIOD So <sil=0.517> ,COMMA it will print Chris 3 <sil=0.979> .PERIOD Similarly <sil=0.437> ,COMMA movie 0 will print the first string and if you say printf percentage as star of movies plus 1 by pointer notation this is the same as the subscript notation movies square bracket 1 <sil=0.916> .PERIOD So <sil=0.417> ,COMMA that will print array dot 1 <sil=0.963> .PERIOD Now <sil=0.649> ,COMMA what happens if you have put character put car star of movies star movies plus 1 plus 1 <sil=0.989> .PERIOD So <sil=0.579> ,COMMA again if you are more comfortable with the subscript notation you can translate back into the subscript notation this will become movies of square bracket 1 square bracket 1 <sil=0.921> .PERIOD So <sil=0.529> ,COMMA what it will print is this letter which is small a similarly for the last one <sil=0.940> .PERIOD So <sil=0.628> ,COMMA it will print yeah whatever it will print the i <sil=0.946> .PERIOD So <sil=0.399> ,COMMA here is a error <sil=0.960> .PERIOD Ariefer is now allows us to have a two dimensional structure with different number of elements per row and this is the advantage that it has <sil=0.956> .PERIOD Now <sil=0.622> ,COMMA let us say that we want to write a very natural program which is it takes a number between 1 and 12 and it prints out what is the month name corresponding to that member <sil=0.967> .PERIOD So <sil=0.580> ,COMMA I want to store the months and here is the problem different months have different lengths <sil=0.939> .PERIOD We right now saw a solution to this problem which is to store arbitrary length strings in one structure we would make an array of arrays <sil=0.926> .PERIOD So <sil=0.420> ,COMMA you can say that character star month names <sil=0.918> .PERIOD So <sil=0.450> ,COMMA this is an array of arrays of character and then you can just initialize it to the month names you do this and then I will write the code so <sil=0.513> ,COMMA you can write the code in any way <sil=0.959> .PERIOD So <sil=0.416> ,COMMA you can say that 0 is January and so on up to 11 is December <sil=0.579> ,COMMA but maybe it is more natural to say that 1 is January and so on up to 12 is December <sil=0.997> .PERIOD So <sil=0.338> ,COMMA I will check if the given month index is between 1 and 12 then I will print the month name month minus 1 <sil=0.941> .PERIOD So <sil=0.306> ,COMMA if you give the month as 1 you will print month names 0 which is January <sil=0.939> .PERIOD If you give month names if you give the month as 2 you will print month names 1 which is February and so on <sil=0.966> .PERIOD Now <sil=0.308> ,COMMA if the month is not in this range it is an invalid month <sil=0.931> .PERIOD So <sil=0.629> ,COMMA you just print that and so on <sil=0.947> .PERIOD So <sil=0.352> ,COMMA here is a very simple program which illustrates what advantage you get out of this kind of array of array structure <sil=0.945> .PERIOD You can store within the same data structure different strings of completely different lengths <sil=0.982> .PERIOD This is not possible in a 2 D array because all you have to calculate something like the maximum column length of the so <sil=0.376> ,COMMA the maximum width month name for example <sil=0.411> ,COMMA it could be September and then all the other names have to have exactly that width <sil=0.967> .PERIOD So <sil=0.618> ,COMMA let us look at this the array of arrays picture is like you have an array of character stars <sil=0.958> .PERIOD Now <sil=0.440> ,COMMA each of those character stars may be pointing to different months <sil=0.909> .PERIOD In this every month is exactly 3 characters long but you get the picture basically in this these rows can be of different lengths <sil=0.962> .PERIOD So <sil=0.451> ,COMMA contrast this with two dimensional arrays where the chief feature of a two dimensional array is the following you have to specify the number of columns <sil=0.996> .PERIOD So <sil=0.356> ,COMMA the number of columns have to be specified and no matter what the exact string is it will occupy 7 characters long <sil=0.990> .PERIOD So <sil=0.549> ,COMMA the remaining will be null filled or something <sil=0.951> .PERIOD So <sil=0.524> ,COMMA also notice that pictorially I have tried to represent it the very next memory cell after the first row will be the beginning of the second row <sil=0.966> .PERIOD So <sil=0.324> ,COMMA after row 0 it will immediately start with row 1 whereas <sil=0.422> ,COMMA in the case of array of arrays row 0 and row 1 may be located arbitrarily far apart in memory <sil=0.990> .PERIOD The only connection is that the pointers to these rows are consecutively located in the array in the pointer array that is not the case here it is actually located together in memory and it is represented in row major fashion where each row will take exactly 7 letters <sil=0.995> .PERIOD So <sil=0.500> ,COMMA I hope the limitation of the two dimensional arrays in this case is clear <sil=0.928> .PERIOD So <sil=0.558> ,COMMA you can try a few exercises in order to understand this notation a little bit this concept of array of arrays a little bit better <sil=0.980> .PERIOD So <sil=0.351> ,COMMA let us look at the types of various concepts <sil=0.993> .PERIOD So <sil=0.498> ,COMMA if I have month <sil=0.632> ,COMMA month is actually a character star star it is an address <sil=0.947> .PERIOD So <sil=0.334> ,COMMA if you want to print out month I mean it is very rare that you need to print out month you would use something like percentage LU which is long unsigned for printing the unsigned long end <sil=0.901> .PERIOD What happens if you access star month now you are dereferencing one level below <sil=0.962> .PERIOD So <sil=0.469> ,COMMA it will be a character star <sil=0.970> .PERIOD So <sil=0.307> ,COMMA now if you print percentage's star month it will print January <sil=0.967> .PERIOD If you print star star month you have dereference two levels and you will get the first letter of the first array which is j and you can try out a few other things you can say star of month plus 1 <sil=0.912> .PERIOD So <sil=0.471> ,COMMA one way you can do it is you translate it to subscript notation and try to see what it will print and there are <sil=0.902> .PERIOD So <sil=0.362> ,COMMA I would encourage you to try out these examples in order to get the translation between arrays and pointers correct <sil=0.951> .PERIOD So <sil=0.561> ,COMMA in comparison between array of arrays two dimensional arrays on the one hand individual array sizes can be different in the case of array of arrays <sil=0.992> .PERIOD In the case of two dimensional arrays all the rows must have exactly the same number of columns <sil=0.902> .PERIOD So <sil=0.505> ,COMMA array of arrays is useful in a lot of string processing routines in representing graphs and things like that <sil=0.941> .PERIOD But two dimensional arrays are more advantages when you deal with matrices because mathematical matrices typically have a fixed number of columns <sil=0.961> .PERIOD So <sil=0.321> ,COMMA here is a wrong picture but it sort of gives you an idea of how to look at these structures <sil=0.961> .PERIOD So <sil=0.561> ,COMMA if I have int array two three you can think of it as the number of rows is fixed and the number of columns is fixed <sil=0.997> .PERIOD This is not actually what happens in C <sil=0.908> .PERIOD In C actually the number of rows does not matter the number of columns matters <sil=0.902> .PERIOD But you can for the moment to make it easier to think about think that if you declare it in this way this is when the number of rows is fixed and the number of columns are fixed <sil=0.952> .PERIOD So <sil=0.417> ,COMMA in particular if you know beforehand that your data structure has a fixed number of rows and a fixed number of columns then it is probably better to use a two D array <sil=0.977> .PERIOD Now <sil=0.370> ,COMMA if you have in star a r r three then now this means that a r r is a pointer to an array of size three <sil=0.974> .PERIOD So <sil=0.645> ,COMMA here the number of columns is fixed but the number of rows is variable it you can have any number of rows <sil=0.970> .PERIOD On the other hand the third case in star array three <sil=0.999> .PERIOD So <sil=0.355> ,COMMA it is an array of three elements each of type in star <sil=0.919> .PERIOD So <sil=0.574> ,COMMA you can see that this is one situation where you have three pointers but each of them can point to arrays of arbitrary length <sil=0.970> .PERIOD So <sil=0.638> ,COMMA this is a situation where the number of rows can be seen as fixed and the number of columns is variable <sil=0.908> .PERIOD And the general case can be in star star which is where the number of rows and the number of columns are both variable <sil=0.978> .PERIOD So <sil=0.627> ,COMMA you can think of it in this way this is not a correct picture but when you want to model data this is probably and you know that you are in a situation where the number of columns is variable but the number of rows you know beforehand probably you should go for array of arrays <sil=0.901> .PERIOD If you are in a situation where you know that the number of columns is fixed but you do not know how many data there are then you can go for in star array of size three <sil=0.942> .PERIOD So <sil=0.574> ,COMMA you can go for the second alternative and so on <sil=0.962> .PERIOD So <sil=0.440> ,COMMA this picture is not quite accurate but it is indicative of the usage <sil=0.923> .PERIOD In this video <sil=0.604> ,COMMA we will start with a topic that is considered one of the trickiest concepts in C <sil=0.924> .PERIOD These are what are known as pointers <sil=0.908> .PERIOD We will just recap what we know about arrays because arrays and pointers are very closely related in C <sil=0.961> .PERIOD Now <sil=0.614> ,COMMA the memory allocated to any array has two components <sil=0.942> .PERIOD First is there are a bunch of consecutively allocated boxes of the same type and the second component is there is a box with the same name as the array and this box contains the address of the first element of the array <sil=0.911> .PERIOD So <sil=0.454> ,COMMA that let us be clear with the help of a concrete example <sil=0.911> .PERIOD So <sil=0.438> ,COMMA let us consider a particular array of size 10 declared as int num 10 <sil=0.910> .PERIOD Conceptually <sil=0.424> ,COMMA there are 10 boxes from num 0 through num 9 <sil=0.911> .PERIOD These are all containing integers plus there is an additional 11th box num <sil=0.929> .PERIOD So <sil=0.346> ,COMMA it has the same name as the name of the array and it contains the address of the first location of the array <sil=0.945> .PERIOD So <sil=0.398> ,COMMA it contains the address of num 0 <sil=0.998> .PERIOD So <sil=0.521> ,COMMA these are num 0 through num 9 are located somewhere in memory <sil=0.995> .PERIOD So <sil=0.365> ,COMMA maybe this is memory location 1000 <sil=0.945> .PERIOD So <sil=0.373> ,COMMA num contains the number 1000 which is supposed to indicate that the address of the first location in the array is 1000 or the ad num points to the memory location 1000 <sil=0.921> .PERIOD So <sil=0.595> ,COMMA conceptually this gives 11 boxes which are 10 integer boxes plus 1 box which holds the address of the first box <sil=0.999> .PERIOD Now <sil=0.397> ,COMMA we represent the address of a box x by an arrow to the box x <sil=0.977> .PERIOD So <sil=0.392> ,COMMA addresses are referred to as pointers and this is all there is to see pointers <sil=0.927> .PERIOD Pointers in some sense are variables which hold the addresses of other variables <sil=0.955> .PERIOD That is an exact description of the concept of pointers <sil=0.956> .PERIOD Now <sil=0.318> ,COMMA we will see what that means and what can we do with pointers <sil=0.962> .PERIOD Let us just step back a minute and say what can we do with a particular box or particular variable in memory which is an integer <sil=0.965> .PERIOD So <sil=0.382> ,COMMA that is very simple for example <sil=0.643> ,COMMA you can scan in scan up into that box <sil=0.975> .PERIOD You can print the value in that box <sil=0.962> .PERIOD You can do arithmetic operations on that box like plus division <sil=0.416> ,COMMA model row and so on <sil=0.973> .PERIOD And you can do this for each of the boxes from num 0 through num 9 because each of them by itself is an integer <sil=0.908> .PERIOD But we will also see a new operation which is that you can take the address of a box <sil=0.960> .PERIOD So <sil=0.399> ,COMMA we have already done this when we did scan up <sil=0.955> .PERIOD So <sil=0.601> ,COMMA we mentioned and of a variable <sil=0.971> .PERIOD So <sil=0.329> ,COMMA we will see this and operator in somewhat more detail <sil=0.943> .PERIOD So <sil=0.632> ,COMMA suppose I want to take the address of num 1 and store it in an address variable ptr <sil=0.999> .PERIOD So <sil=0.507> ,COMMA what I am essentially saying is that you can say ptr equal to and of num 1 <sil=0.932> .PERIOD So <sil=0.586> ,COMMA num 1 is an integer box <sil=0.404> ,COMMA it is an integer variable and of num 1 is the address of that integer in memory <sil=0.959> .PERIOD So <sil=0.410> ,COMMA you assign it to the variable ptr <sil=0.996> .PERIOD But every variable in c needs to have a type <sil=0.972> .PERIOD What is the type of ptr and how do you declare or define such a type such a variable <sil=0.914> .PERIOD Now <sil=0.626> ,COMMA ptr holds the address of an integer in c <sil=0.962> .PERIOD You denote that by saying that the type of ptr is int star <sil=0.922> .PERIOD So <sil=0.336> ,COMMA here is a new type that we are seeing for the first time <sil=0.939> .PERIOD We are saying ptr is of type int star <sil=0.916> .PERIOD Just like you can say that if I have int a <sil=0.614> ,COMMA you can say that a is of type int <sil=0.927> .PERIOD In this case <sil=0.603> ,COMMA we can say ptr equal to and of num 1 <sil=0.952> .PERIOD We have discussed right now <sil=0.911> .PERIOD We have int num 10 <sil=0.592> ,COMMA int star ptr and ptr equal to and of num 1 <sil=0.947> .PERIOD So <sil=0.449> ,COMMA ptr is the point of to an integer <sil=0.953> .PERIOD But what does ptr equal to and num 1 really mean <sil=0.930> .PERIOD So <sil=0.534> ,COMMA let us look at the memory status once we declare this size or once we declare this array <sil=0.914> .PERIOD So <sil=0.483> ,COMMA we have num which is the address of the first location and then we have somewhere in memory <sil=0.913> .PERIOD We have 10 consecutive locations corresponding to the array num 0 through num 9 <sil=0.938> .PERIOD Now <sil=0.340> ,COMMA I declare int star ptr <sil=0.923> .PERIOD So <sil=0.468> ,COMMA I create a box <sil=0.991> .PERIOD Now <sil=0.460> ,COMMA this box is supposed to hold the address of some integer variable <sil=0.908> .PERIOD So <sil=0.524> ,COMMA ptr is of type address of an integer box or more commonly referred to as pointer to integer <sil=0.961> .PERIOD The statement ptr equal to and of num 1 says that now points to num 1 or ptr continues the address of num 1 <sil=0.942> .PERIOD And pictorially we denote an arrow from ptr to num 1 <sil=0.946> .PERIOD Just like I denoted an arrow going from num to num 0 because the name of the array is a pointer to the first location of the array <sil=0.929> .PERIOD The name of the array is a box which holds the address of the first location of the array <sil=0.913> .PERIOD Similarly <sil=0.491> ,COMMA ptr is a box which holds the address of num 1 <sil=0.902> .PERIOD So <sil=0.335> ,COMMA we say that ptr points to num 1 and we denote it pictorally an arrow <sil=0.991> .PERIOD The program status is like this <sil=0.597> ,COMMA state is like this <sil=0.922> .PERIOD Now <sil=0.372> ,COMMA suppose I add one more statement after all these three statements <sil=0.958> .PERIOD I say scanf percentage d ptr <sil=0.964> .PERIOD Now <sil=0.613> ,COMMA earlier when we declared an array and we read into an array directly <sil=0.443> ,COMMA I said that you can do the following <sil=0.966> .PERIOD I can write scanf percentage d and num 1 <sil=0.933> .PERIOD So <sil=0.560> ,COMMA this will value whatever the user input into the first array using the and operator <sil=0.981> .PERIOD Now <sil=0.498> ,COMMA ptr equal to and num 1 <sil=0.967> .PERIOD So <sil=0.390> ,COMMA it is a reasonable thing to ask scanf percentage d ptr <sil=0.990> .PERIOD There is no and operator here because ptr is and num 1 <sil=0.941> .PERIOD This was our original statement and this is our new state <sil=0.913> .PERIOD And the answer is yes <sil=0.419> ,COMMA you can do it <sil=0.994> .PERIOD Suppose the input is 5 <sil=0.522> ,COMMA does num 1 become 5 <sil=0.979> .PERIOD So <sil=0.328> ,COMMA scanf percentage d ptr really does work like scanf percentage d and num 1 <sil=0.948> .PERIOD So <sil=0.459> ,COMMA it reads the value input by the user and it looks up ptr <sil=0.937> .PERIOD So <sil=0.490> ,COMMA it is an address <sil=0.925> .PERIOD So <sil=0.576> ,COMMA it goes to that address and stores it there <sil=0.947> .PERIOD So <sil=0.553> ,COMMA now we can clarify a long standing mystery which is the and operator in the case of scanf <sil=0.968> .PERIOD So <sil=0.414> ,COMMA we can see that scanf's second argument is a pointer which says where should I put the input input by the user <sil=0.915> .PERIOD For example <sil=0.424> ,COMMA if I have float variable and scanf as percentage f and then some address of a float variable <sil=0.590> ,COMMA it is done similar to reading an integer into an integer variable <sil=0.989> .PERIOD What scanf takes is an address of int variable or float variable as it may be <sil=0.912> .PERIOD If you have a percentage d <sil=0.432> ,COMMA then it takes an integer <sil=0.300> ,COMMA it takes a pointer to an integer variable and takes the input value by the user and puts it into that address <sil=0.974> .PERIOD So <sil=0.313> ,COMMA as far as scanf is concerned <sil=0.500> ,COMMA it doesn't matter whether you give it as an num 1 or whether you initialize ptr to an num 1 and then give ptr <sil=0.956> .PERIOD It is an address and it will put the integer input by the user into that location <sil=0.983> .PERIOD So <sil=0.434> ,COMMA num 1 indeed does become 5 <sil=0.910> .PERIOD So <sil=0.490> ,COMMA the location of the num 1 is now containing the value 5 <sil=0.996> .PERIOD Now <sil=0.318> ,COMMA what else can you do with a pointer <sil=0.992> ?QUESTIONMARK Num is an array <sil=0.965> .PERIOD It is of type int square brackets <sil=0.518> ,COMMA pair of square brackets and in C <sil=0.637> ,COMMA the box num contains the address of the first location of the array <sil=0.529> ,COMMA which is num 0 <sil=0.990> .PERIOD So <sil=0.566> ,COMMA internally as far as C is concerned <sil=0.496> ,COMMA the address of num 0 is just like address of any other integer location <sil=0.951> .PERIOD So <sil=0.423> ,COMMA the type int star can be interchange with int square bracket <sil=0.932> .PERIOD So <sil=0.443> ,COMMA you can think of num itself as just a pointer to an integer or you can say that it is a pointer to an array <sil=0.917> .PERIOD So <sil=0.483> ,COMMA which gives you the additional information that the next 10 values are also integers <sil=0.994> .PERIOD If you just say pointer to an integer <sil=0.594> ,COMMA the next location may be something else <sil=0.999> .PERIOD But <sil=0.608> ,COMMA internally as far as C is concerned <sil=0.394> ,COMMA an array name num can also be treated as pointer to an integer <sil=0.961> .PERIOD Now <sil=0.544> ,COMMA here are some other interesting things that you can do with pointers <sil=0.908> .PERIOD Whenever you declare a data type <sil=0.488> ,COMMA you also define what all operations can you do with a data type <sil=0.954> .PERIOD So <sil=0.510> ,COMMA 2 and 3 are fairly simple <sil=0.903> .PERIOD We have already seen it with integers <sil=0.400> ,COMMA floating points and so on <sil=0.958> .PERIOD You can do simple arithmetic plus and minus with pointers <sil=0.945> .PERIOD You cannot do star and divide <sil=0.393> ,COMMA you cannot do that <sil=0.401> ,COMMA but you can do plus and minus <sil=0.954> .PERIOD Similarly <sil=0.642> ,COMMA if you have two pointers <sil=0.639> ,COMMA you can test for equality <sil=0.371> ,COMMA you can test for less than <sil=0.483> ,COMMA you can test for greater than and so on as though you were comparing ordinary integers <sil=0.958> .PERIOD So <sil=0.525> ,COMMA 2 and 3 are what we have seen before except that in 2 <sil=0.601> ,COMMA you cannot do multiply and divide and model you <sil=0.983> .PERIOD All these things are not done with pointers <sil=0.466> ,COMMA but addition and subtraction can be done <sil=0.948> .PERIOD But there is a new operation which is de-referencing a pointer <sil=0.909> .PERIOD We have not seen this operation before with earlier data types <sil=0.990> .PERIOD What is de-referencing <sil=0.891> ?QUESTIONMARK Let me pictorially represent what it does <sil=0.958> .PERIOD Suppose you have instar ptr and int <sil=0.924> .PERIOD So <sil=0.625> ,COMMA a is an integer variable and ptr is a pointer point <sil=1.000> .PERIOD If I want to store the address of a in ptr <sil=0.628> ,COMMA I do it as follows <sil=0.921> .PERIOD ptr equal to and d <sil=0.914> .PERIOD So <sil=0.612> ,COMMA this means that take the address of a and store it in ptr <sil=0.995> .PERIOD So <sil=0.508> ,COMMA now you can say that ptr points to a <sil=0.910> .PERIOD Now <sil=0.537> ,COMMA I can also think of a reverse operation which is ptr contains a reverse operation which is ptr contains some address <sil=0.902> .PERIOD Go look up that address <sil=0.977> .PERIOD So <sil=0.518> ,COMMA that will be an int and store that value in a <sil=0.994> .PERIOD So <sil=0.325> ,COMMA that is what is known as the star operator a equal to star ptr <sil=0.993> .PERIOD This means that ptr is an integer pointer <sil=0.983> .PERIOD So <sil=0.567> ,COMMA ptr will point to a location which contains an integer <sil=0.971> .PERIOD Star ptr will take the contents of that location and store it in a <sil=0.947> .PERIOD So <sil=0.488> ,COMMA this is known as the de-referencing operator <sil=0.957> .PERIOD So <sil=0.423> ,COMMA the address operator takes an integer variable and stores the address in a pointer <sil=0.953> .PERIOD The de-referencing operation takes a pointer <sil=0.548> ,COMMA looks up that address and stores the value in a <sil=0.913> .PERIOD So <sil=0.385> ,COMMA you can visualize the and operator and the star operator as sort of reverse operations of each other and takes an integer and takes the address of that star takes a pointer and takes the value of the address pointed to that <sil=0.934> .PERIOD De-referencing a pointer therefore <sil=0.338> ,COMMA gives you the value of contained in the box pointed to by the pointer <sil=0.941> .PERIOD The de-referencing operator is star <sil=0.991> .PERIOD So <sil=0.439> ,COMMA if I say print if percentage d star pointer what it will do is look up the location pointed to by ptr <sil=0.973> .PERIOD In this case it is this integer box <sil=0.916> .PERIOD The contents of that box is 5 and it will be printed <sil=0.905> .PERIOD So <sil=0.422> ,COMMA the output will be 5 not for example <sil=0.491> ,COMMA the content of ptr <sil=0.922> .PERIOD So <sil=0.392> ,COMMA the content of ptr may be like 1000 and 4 <sil=0.903> .PERIOD It will not print 1000 and 4 but what it supposed to do is look up the location 1000 and 4 <sil=0.943> .PERIOD It contains a value 5 print that value <sil=0.928> .PERIOD So <sil=0.556> ,COMMA star ptr is the box number and printing it gives you the output 5 <sil=0.942> .PERIOD Now <sil=0.440> ,COMMA can I consider a statement like star ptr equal to star ptr plus 5 <sil=0.928> .PERIOD This is perfectly legal <sil=0.985> .PERIOD What this will do is star ptr is an integer value <sil=0.925> .PERIOD It is equal to 5 because look up this location ptr that is an integer take that value which will be 5 <sil=0.995> .PERIOD So <sil=0.412> ,COMMA this will be 5 plus 5 10 and where do you store it <sil=0.996> ?QUESTIONMARK You store it in the integer variable corresponding to star ptr <sil=0.952> .PERIOD The integer variable corresponding to star ptr is number 1 <sil=0.918> .PERIOD So <sil=0.316> ,COMMA I would have normally said number 1 equal to star ptr plus 5 but number is the same as star ptr <sil=0.970> .PERIOD I can say star ptr equal to star ptr plus 5 <sil=0.931> .PERIOD So <sil=0.369> ,COMMA this will look up that location add 5 to its contents and store it in that location <sil=0.926> .PERIOD So <sil=0.420> ,COMMA number 1 will now become 10 <sil=0.993> .PERIOD Similarly <sil=0.511> ,COMMA you can consider other examples <sil=0.925> .PERIOD For example <sil=0.519> ,COMMA I can consider a statement like number 2 equal to star number star ptr <sil=0.982> .PERIOD The novelty here is that <sil=0.596> ,COMMA if you have a number <sil=0.962> .PERIOD In this session <sil=0.574> ,COMMA let us see another simple program and try to study what is going on in there <sil=0.927> .PERIOD So here I have a slightly more complicated program than what we just saw <sil=0.959> .PERIOD This has two print-up statements <sil=0.936> .PERIOD One says welcome to and the second says see programming <sil=0.903> .PERIOD So it is slightly more sophisticated than the code that we have seen <sil=0.987> .PERIOD So to recap <sil=0.342> ,COMMA the first line hash include stda of dot h tells the compiler to include the standard output library <sil=0.919> .PERIOD Then we have the main function <sil=0.980> .PERIOD The open and close brackets immediately after main show that main is a function <sil=0.912> .PERIOD Then always begins at the first line of the main statement <sil=0.938> .PERIOD Then the body of the function <sil=0.539> ,COMMA the logic of the function is enclosed within two curly braces <sil=0.904> .PERIOD The first curly brace signals the beginning of the function and the last curly brace says that the function is over here <sil=0.965> .PERIOD This particular main function has two statements earlier we had just one statement <sil=0.912> .PERIOD The each statement as I said before is terminated with a semicolon <sil=0.985> .PERIOD So this is the first semicolon and this is the second semicolon <sil=0.923> .PERIOD The first semicolon says that the statement print-up welcome to ends at that point and then followed by the second statement and the second statement is also terminated by a semicolon <sil=0.916> .PERIOD Every statement in C is terminated with a semicolon <sil=0.971> .PERIOD Curly braces enclose a set of statements and each statement in a sequence is executed in the exact sequence that we wrote in the code <sil=0.907> .PERIOD Now once we edit this in an editor <sil=0.619> ,COMMA save the file <sil=0.989> .PERIOD Now compile and run the file <sil=0.941> .PERIOD So let us call it sample <sil=0.974> .PERIOD c or you may rename it any file you want <sil=0.959> .PERIOD Then once the compilation is successful <sil=0.488> ,COMMA you can run it using <sil=0.916> .PERIOD forward slash a <sil=0.932> .PERIOD out and then it will print welcome to C programming which was essentially the same message as we seen before <sil=0.972> .PERIOD Let us trace what happens when we execute the program <sil=0.936> .PERIOD By tracing we mean step by step looking at each statement and see what happens when the program executes <sil=0.993> .PERIOD We have what is known as a program counter which says here is the currently executing line of program <sil=0.935> .PERIOD The program counter starts executing at the first statement of main <sil=0.900> .PERIOD For ease of reference <sil=0.400> ,COMMA I have given line numbers in the code <sil=0.925> .PERIOD Now this is given just for clarity <sil=0.904> .PERIOD Now let us just see what happens when we run the program line by line <sil=0.981> .PERIOD So first we execute the first line of the code <sil=0.966> .PERIOD After we are done executing the line 4 <sil=0.903> .PERIOD So after we are done executing lines 3 and 4 <sil=0.644> ,COMMA the message welcome 2 will be printed on the terminal <sil=0.995> .PERIOD This will be followed by the next line <sil=0.913> .PERIOD The next line says C programming <sil=0.976> .PERIOD So after the next line executes <sil=0.460> ,COMMA it will print C programming percentage <sil=0.990> .PERIOD I have given this in two different colors to highlight that one was printed by the first line and the other was printed by the second line <sil=0.920> .PERIOD Otherwise the colors have no sense <sil=0.941> .PERIOD No special meaning <sil=0.960> .PERIOD The program terminates when the main finishes execution and this is what is typically known as returning from the function <sil=0.957> .PERIOD We will see this terminology later in the course <sil=0.982> .PERIOD Now when you code in addition to the statements which are actually executed <sil=0.345> ,COMMA you may also give a few additional remarks <sil=0.935> .PERIOD These are what are known as program commons <sil=0.968> .PERIOD For example <sil=0.600> ,COMMA the lines as simple C program <sil=0.493> ,COMMA first print and second print <sil=0.584> ,COMMA these are the comments in the code <sil=0.947> .PERIOD So whatever is highlighted in red in the code is what are known as commons <sil=0.977> .PERIOD Any text between forward slash star and then later followed by a star forward slash <sil=0.954> .PERIOD So any text between successive slash star and star slash is a comment and it will be ignored by the compiler <sil=0.946> .PERIOD So as far as the compiler is concerned <sil=0.620> ,COMMA a code with commons is the same as a code without commons <sil=0.920> .PERIOD Effect the logic of the code <sil=0.916> .PERIOD So commons are not part of the program <sil=0.948> .PERIOD However <sil=0.622> ,COMMA it is highly recommended that any program you write <sil=0.316> ,COMMA you should come in the code <sil=0.958> .PERIOD This is so that other people can understand your code <sil=0.913> .PERIOD Also you yourself looking at the code four months later or five months later <sil=0.995> .PERIOD It may be difficult to understand what you wrote much before and commons help you understand the logic of the program <sil=0.955> .PERIOD Now it is a very good idea to comment your programs and for larger programs it is a must to comment the programs <sil=0.987> .PERIOD This is standard industry practice and even if you are participating in large programming projects like free software projects <sil=0.576> ,COMMA commons are highly encouraged because it will understand other developers <sil=0.309> ,COMMA other programmers to understand your code <sil=0.992> .PERIOD So we will try to follow our own advice <sil=0.934> .PERIOD Most of the programs that we will see in this code <sil=0.627> ,COMMA we will comment it so that it is easy to follow the logic of the code <sil=0.923> .PERIOD Now a few notes just as main is a function <sil=0.982> .PERIOD PrintF is also a function <sil=0.982> .PERIOD PrintF is a library function which means that it is given by the C programming language <sil=0.915> .PERIOD We wanted to tell the compiler to include this library function <sil=0.931> .PERIOD The statement which said that is this hash include stdio <sil=0.985> .PERIOD json <sil=0.909> .PERIOD So hash include stdio <sil=0.937> .PERIOD json is a line telling that I want the standard input output library because that is the library from which I will get the function printF <sil=0.998> .PERIOD Now what does printF do <sil=0.986> ?QUESTIONMARK If takes two arguments just like arguments to mathematical functions <sil=0.941> .PERIOD So it takes an input argument which in our first case was welcome to <sil=0.951> .PERIOD So this was the printF <sil=0.322> ,COMMA first printF statement in the program that we just saw <sil=0.954> .PERIOD Now this was enclosed in double codes <sil=0.977> .PERIOD So it was enclosed in an open double code and then ended with a closed double code <sil=0.913> .PERIOD The sequence of characters in double codes is what is known as a string constant <sil=0.938> .PERIOD Now we can call the functions that we define or we can call the functions that the libraries provide <sil=0.992> .PERIOD This is how once you define a function you can call a function <sil=0.990> .PERIOD Now we will see an additional concept <sil=0.976> .PERIOD The printF statements that we have seen so far we will print a message and it will print there and then the terminal prompt will come immediately after the print <sil=0.921> .PERIOD Now typically what we want to do is we will print a message then tell the prompt to appear on the next line <sil=0.945> .PERIOD So for this we need what is known as the new line character <sil=0.965> .PERIOD For letters digits comma punctuation symbols these are all called characters in the C programming language <sil=0.985> .PERIOD There are a total of 256 characters in C <sil=0.410> ,COMMA 256 is 2 to the 8 <sil=0.921> .PERIOD So for example the small letters 8 to z <sil=0.563> ,COMMA capital letters 8 to z <sil=0.399> ,COMMA 0 to 9 the at symbol <sil=0.425> ,COMMA other punctuation symbols like dot comma exclamation mark and so on are all characters in C <sil=0.999> .PERIOD Now in addition to this there are certain things called special characters <sil=0.966> .PERIOD So there is a special character called new line in the C programming language it is denoted as backslash M <sil=0.960> .PERIOD So there are notice that there are two kinds of slashes forward slash and backward slash on your keyboard and the new line character is denoted as backslash M <sil=0.966> .PERIOD So even though it is a single character it is denoted by two letters <sil=0.916> .PERIOD When used in print if it causes the current output line to end and then printing will start from the new line <sil=0.954> .PERIOD So it is something which says the current line has ended <sil=0.907> .PERIOD Now whatever you have to print print it on the next line <sil=0.949> .PERIOD The new line character backslash M is like any other letter and can be used multiple times in any particular line <sil=0.903> .PERIOD For example if you have something to print followed by backslash M followed by C followed by something to print <sil=0.953> .PERIOD Now this will be treated as so many characters and then a new line followed by C <sil=0.989> .PERIOD So let us see a particular example <sil=0.963> .PERIOD If you have the old program that we just wrote but we end each message with a backslash M <sil=0.925> .PERIOD So we have printf welcome to backslash M printf C programming backslash M <sil=0.966> .PERIOD When we compile and execute we will see something new <sil=0.922> .PERIOD So when we run this as dot slash a dot out it will print welcome to and then the next thing to print is a backslash M which is a new line <sil=0.932> .PERIOD So printing will start from the next line and then it will print the next message which is C programming <sil=0.965> .PERIOD So it will print that followed by a new line <sil=0.955> .PERIOD So the prompt will appear on the line afterwards <sil=0.990> .PERIOD So a new line character is something that is used to make your output messages a little more prettier <sil=0.952> .PERIOD So let us just conclude by saying one more thing about new lines <sil=0.937> .PERIOD The new line character backslash M is like any other character and you can use it multiple times even within a single message <sil=0.913> .PERIOD For example if I do the same program but let us say I have welcome to backslash M <sil=0.508> ,COMMA backslash M and C backslash M <sil=0.937> .PERIOD So I have repeated occurrences of backslash M in the same message <sil=0.950> .PERIOD What it will do is if we will print the message welcome to then it will print a new line and then it will print another line and then it will print C followed by a new line <sil=0.985> .PERIOD So when you run the program you will have welcome to new line then the blank line then C and then another line <sil=0.972> .PERIOD So new lines are just like any other characters <sil=0.913> .PERIOD The difference is that because it is a special character it is represented by two letters <sil=0.901> .PERIOD So it is not represented by a single letter it is represented by backslash M <sil=0.974> .PERIOD So they are together one character in C called the new line <sil=0.938> .PERIOD In this video we will see some more common file operations <sil=0.957> .PERIOD These are by no means the only file facilities that C provides you <sil=0.541> ,COMMA but in common programming practice these are the functions that people often use <sil=0.902> .PERIOD So we have seen this in the code that we wrote <sil=0.917> .PERIOD The first function is FeoF and then it takes a file pointer <sil=0.904> .PERIOD What it does is it checks whether you have encountered end of file while operating on FB <sil=0.932> .PERIOD So maybe you are trying to read the file and you have already reached the end of file <sil=0.942> .PERIOD So if you have already reached the end of file that is if EoF is set then FeoF returns a non-zero value <sil=0.921> .PERIOD If FeoF is not set that is you have not completed the file yet by seeing end of file then FeoF returns 0 <sil=0.950> .PERIOD So in order to check whether a file still has some data you can just say not of FeoF FB <sil=0.970> .PERIOD So that will check for the fact that the file still has some data <sil=0.905> .PERIOD Now another useful file function is F error <sil=0.959> .PERIOD So the F error function what it does is it takes the input file pointer <sil=0.606> ,COMMA it takes the file pointer FB and checks whether you have encountered some error while reading the file <sil=0.919> .PERIOD So error may be of many kinds <sil=0.983> .PERIOD For example you are trying to write to a read only medium like CD or maybe you are trying to write to a file system and the file system is full <sil=0.986> .PERIOD You are trying to write to a hard drive and the hard drive is full <sil=0.926> .PERIOD So then you might encounter an error <sil=0.934> .PERIOD So there are various errors that you encounter in file operations and F error checks for some of these errors <sil=0.913> .PERIOD So if the error indicator has been set for FB then F error returns a non-zero value <sil=0.984> .PERIOD Otherwise it says 0 <sil=0.945> .PERIOD Now here are some couple more interesting functions who are very useful and quite commonly used whenever we deal with files <sil=0.979> .PERIOD For example we can have something called Fseq <sil=0.933> .PERIOD Now Fseq is a function which allows you to start reading from or start writing to arbitrary locations in the file <sil=0.998> .PERIOD So often we may want to read into the 10 <sil=0.405> ,COMMA 000 byte directly and we do not want to be bothered with reading the first 999 characters discarding them and then coming to the 10 <sil=0.618> ,COMMA 000th character <sil=0.907> .PERIOD And then coming to the 10 <sil=0.413> ,COMMA 000th character this may be a lot of wasted time <sil=0.948> .PERIOD It would be more convenient if I can directly jump to the 10 <sil=0.595> ,COMMA 000th location in the file <sil=0.959> .PERIOD So is there a function that allows you to do that <sil=0.922> ?QUESTIONMARK Yes there is this thing called Fseq <sil=0.973> .PERIOD Now what it takes is the file pointer and it takes two arguments <sil=0.931> .PERIOD One is known as an offset and the other is known as the origin <sil=0.906> .PERIOD So let us look at the offset and the origin in greater detail <sil=0.923> .PERIOD So suppose I want to read from the 10th byte of the file <sil=0.956> .PERIOD So I could say Fseq and suppose my file pointer is Fp <sil=0.914> .PERIOD I will just say let us say I want to read from the 10th point from the beginning of the file <sil=0.992> .PERIOD What I can say is Seq set <sil=0.927> .PERIOD So if I do this what will happen is that it will start from the beginning <sil=0.990> .PERIOD Seat set is the beginning of the file <sil=0.934> .PERIOD So it will add 10 bytes from the beginning of the file and it will start from there <sil=0.996> .PERIOD So if I know that I want to read from the 10th byte then I can say that start from the beginning of the file <sil=0.907> .PERIOD Seat set says origin of the beginning of the file plus 10 bytes <sil=0.904> .PERIOD So this is 10 bytes from beginning <sil=0.998> .PERIOD Now there are other situations <sil=0.943> .PERIOD For example you might want to say that I want to start from the 10th byte from the current location <sil=0.991> .PERIOD I have already read many bytes <sil=0.910> .PERIOD Now I want to skip the next 10 bytes <sil=0.976> .PERIOD So is there a way to do that <sil=0.995> ?QUESTIONMARK Then what you can do is if you say Fseq and let us say 10 itself but Seq current <sil=0.956> .PERIOD So there is a typo here <sil=0.911> .PERIOD This is just CuR <sil=0.954> .PERIOD So if I say this then what I need to do is what it will be perform is it will say 10 bytes from the current position <sil=0.979> .PERIOD So I have already read 100 bytes from the file and then I say Fseq 10 bytes from the current location <sil=0.987> .PERIOD What it will do is jump to 110th location <sil=0.931> .PERIOD Now I could also say something like here is a very common situation <sil=0.951> .PERIOD I want to start reading from the 10th byte from the end <sil=0.950> .PERIOD So I want to regardless of the size of the file I want to jump to the end and then rewind 10 bytes and start from there <sil=0.938> .PERIOD So in that case I can say the origin is Seq end <sil=0.919> .PERIOD That is the end of the file and where do I start from <sil=0.910> ?QUESTIONMARK Seq end plus something does not make any sense because it will refer to something that does not exist in the file <sil=0.905> .PERIOD So you could say Seq end minus 10 <sil=0.933> .PERIOD So this is 10 bytes before the end of the file <sil=0.939> .PERIOD So you can use Seq in several ways and it is a very convenient function because it allows you to jump to arbitrary locations in the file and it will work as long as the target location origin plus offset is a valid location in the file <sil=1.000> .PERIOD Now there is also something called Ftell which will tell you the current position in the file <sil=0.964> .PERIOD So if it will take a file pointer as the argument Fp and it will return you where in the file you are currently at <sil=0.904> .PERIOD So with this let us take a look at a few more modes in file operations <sil=0.954> .PERIOD So when you open the files we saw that you could open it in mode RWA <sil=0.912> .PERIOD Now there are also some other special modes that Seq gives you <sil=0.976> .PERIOD For example there is something called R plus <sil=0.979> .PERIOD This says you can open a file for reading and writing <sil=0.932> .PERIOD So this is essentially an update mode <sil=0.999> .PERIOD W plus will be write and update <sil=0.903> .PERIOD So create an empty file and update that file <sil=0.911> .PERIOD And there is something called A plus which is append an update <sil=0.979> .PERIOD This is somewhat strange <sil=0.967> .PERIOD If you do any Fseq after you open the file in A plus mode then the read will be affected <sil=0.923> .PERIOD So suppose I am at the 100th location I have read 99 bytes <sil=0.929> .PERIOD I am at the 100th byte <sil=0.940> .PERIOD If I read now do an Fseq to 10 bytes ahead <sil=0.952> .PERIOD So now I will be at the 100th and 10th byte <sil=0.946> .PERIOD Now there are two possibilities now <sil=0.963> .PERIOD I can read from here or I can do an Fprintf <sil=0.991> .PERIOD Fscanif will start from the 100th and 10th byte <sil=0.915> .PERIOD It will obey the Fseq <sil=0.943> .PERIOD Fprintf will always print at the end of the file <sil=0.926> .PERIOD So that is the append part of it <sil=0.913> .PERIOD So Fprintf is always <sil=0.445> ,COMMA output is always at the end of the file and reading will be dependent on any Fseq that you do <sil=0.904> .PERIOD So Fseq will never affect the where you print <sil=0.984> .PERIOD It will always be at the end of the file <sil=0.977> .PERIOD So A plus is a very special mode <sil=0.994> .PERIOD These are some additional file operations that you might find useful while coding in C <sil=0.929> .PERIOD In this session <sil=0.506> ,COMMA we will look at loops in the C programming language and we will start with a very basic kind of loop which is known as the wild statement <sil=0.964> .PERIOD So <sil=0.347> ,COMMA the general form of a wild statement is similar to that of an if which is that there is an expression and you say while that expression then do the statement <sil=0.990> .PERIOD So <sil=0.369> ,COMMA the flow chart corresponding to the expression will be the wild expression will be you test whether the expression is true or false <sil=0.970> .PERIOD If it is true <sil=0.509> ,COMMA you do the statement <sil=0.906> .PERIOD If it is false <sil=0.558> ,COMMA you exit out of the loop and execute the next statement outside the loop <sil=0.902> .PERIOD So <sil=0.591> ,COMMA if the expression is true in C that is the expression is non-zero <sil=0.432> ,COMMA then execute the statement and go to the step outside the loop <sil=0.913> .PERIOD If it is false <sil=0.322> ,COMMA then directly go outside the next statement after the wild loop <sil=0.903> .PERIOD This is similar if you recall to the if block without the else <sil=0.981> .PERIOD So <sil=0.580> ,COMMA loops are a new thing that explicitly there was no loop construct in a flow chart <sil=0.935> .PERIOD We just had this way of going back to the expression <sil=0.910> .PERIOD But in programming languages <sil=0.621> ,COMMA loops are such a basic programming need that in addition to the if block <sil=0.579> ,COMMA you have a loop construct as well <sil=0.908> .PERIOD So <sil=0.427> ,COMMA a slightly different variant of the wild expression will be that wild expression statement 1 and then statement 2 <sil=0.902> .PERIOD So <sil=0.571> ,COMMA the flow chart here is easy to follow <sil=0.985> .PERIOD If the first test whether the expression is true <sil=0.612> ,COMMA if the expression is true <sil=0.539> ,COMMA then you execute statement 1 and then after you execute statement 1 <sil=0.630> ,COMMA then go to go back to the expression <sil=0.973> .PERIOD If the statement is false <sil=0.628> ,COMMA if the expression is false <sil=0.452> ,COMMA then you go to statement 2 <sil=0.974> .PERIOD So <sil=0.352> ,COMMA while the expression is true <sil=0.548> ,COMMA execute statement 1 and if the expression is false <sil=0.576> ,COMMA then execute statement 2 <sil=0.969> .PERIOD So <sil=0.357> ,COMMA the difference in the if condition will be that if this was an if block <sil=0.620> ,COMMA then if the expression is true <sil=0.305> ,COMMA you do statement 1 and you exit out of the <sil=0.648> ,COMMA exit out of the wild loop and that is not done in the case of a normal wild loop <sil=0.942> .PERIOD After you execute the statement <sil=0.538> ,COMMA you go back to the expression <sil=0.921> .PERIOD So <sil=0.598> ,COMMA as long as the expression is true <sil=0.383> ,COMMA you keep executing statement 1 and if the expression becomes false <sil=0.363> ,COMMA then you execute statement 2 <sil=0.920> .PERIOD So <sil=0.588> ,COMMA let us illustrate the use of a wild loop with the help of a <sil=0.467> ,COMMA a <sil=0.350> ,COMMA a <sil=0.364> ,COMMA a <sil=0.516> ,COMMA program <sil=0.941> .PERIOD So <sil=0.591> ,COMMA we will introduce a very simple problem <sil=0.492> ,COMMA which is read a sequence of integers from the terminal until a minus 1 is encountered <sil=0.974> .PERIOD So <sil=0.417> ,COMMA minus 1 signals that the input is at an end <sil=0.944> .PERIOD Now <sil=0.373> ,COMMA what I want to do is that sum up all the numbers until the minus 1 and output the sum <sil=0.958> .PERIOD So <sil=0.553> ,COMMA it is a very simple program <sil=0.930> .PERIOD What you have to do is to read a sequence of numbers until you hit the first minus 1 and then add these numbers and output their sum <sil=0.942> .PERIOD So <sil=0.321> ,COMMA let us first introduce a very simple loop <sil=0.641> ,COMMA which will do only the basic thing of reading the numbers until a minus 1 is encountered <sil=0.999> .PERIOD So <sil=0.549> ,COMMA how do you write the loop <sil=0.965> ?QUESTIONMARK You have a stdiot <sil=0.944> .PERIOD h and then you declare an integer variable and read the variable <sil=0.976> .PERIOD So <sil=0.344> ,COMMA this is supposed to be the first number <sil=0.901> .PERIOD If that number is minus 1 <sil=0.648> ,COMMA then you do not have to read any more numbers <sil=0.953> .PERIOD So <sil=0.475> ,COMMA if the number is not minus 1 <sil=0.914> .PERIOD So <sil=0.370> ,COMMA if a equal to minus 1 is false <sil=0.319> ,COMMA then you read one more number <sil=0.995> .PERIOD After you read one more number <sil=0.645> ,COMMA you do not finish the loop <sil=0.340> ,COMMA you go back and test whether the loop condition is still true <sil=0.965> .PERIOD So <sil=0.436> ,COMMA you go back and check whether the second number you read was minus 1 or not <sil=0.947> .PERIOD And then you keep on reading it until you hit a minus 1 <sil=0.977> .PERIOD At some point when you hit a minus 1 <sil=0.386> ,COMMA you go back to the loop and the condition that a equal to minus 1 will be true <sil=0.935> .PERIOD So <sil=0.540> ,COMMA not of that will be false and you will exit the loop <sil=0.931> .PERIOD So <sil=0.581> ,COMMA read the first number if it is minus 1 <sil=0.538> ,COMMA don't enter the loop <sil=0.901> .PERIOD Otherwise <sil=0.642> ,COMMA keep on reading numbers until you hit a minus 1 <sil=0.930> .PERIOD That is the meaning of the while loop <sil=0.946> .PERIOD So <sil=0.394> ,COMMA let us just trace the execution of the loop on a sample input to understand how it works <sil=0.948> .PERIOD So <sil=0.632> ,COMMA in a box <sil=0.332> ,COMMA I will represent the memory location a and its current content <sil=0.925> .PERIOD So <sil=0.549> ,COMMA I run the program after compiling a dot out and let us say that I enter the number 4 <sil=0.973> .PERIOD Now <sil=0.438> ,COMMA you scan the number 4 <sil=0.997> .PERIOD So <sil=0.522> ,COMMA memory location a becomes 4 <sil=0.921> .PERIOD Now <sil=0.390> ,COMMA 4 is not minus 1 <sil=0.932> .PERIOD So <sil=0.329> ,COMMA you enter the loop <sil=0.902> .PERIOD So <sil=0.439> ,COMMA then and let us say that the next number is 15 <sil=0.990> .PERIOD You read the number into a <sil=0.956> .PERIOD So <sil=0.409> ,COMMA memory location a is now 15 <sil=0.987> .PERIOD 15 is not minus 1 <sil=0.902> .PERIOD So <sil=0.464> ,COMMA you again enter the loop <sil=0.958> .PERIOD You enter minus 5 <sil=0.956> .PERIOD Minus 5 is not minus 1 <sil=0.980> .PERIOD So <sil=0.573> ,COMMA you enter the loop again <sil=0.917> .PERIOD At this point <sil=0.403> ,COMMA you scan the number into a and a becomes minus 1 <sil=0.991> .PERIOD So <sil=0.501> ,COMMA you go back to the loop again and now the test that so a equal to minus 1 <sil=0.974> .PERIOD So <sil=0.328> ,COMMA not of that is false <sil=0.984> .PERIOD So <sil=0.413> ,COMMA the while condition becomes false <sil=0.977> .PERIOD At this point <sil=0.542> ,COMMA you exit the program <sil=0.976> .PERIOD So <sil=0.334> ,COMMA this is a very simple part of the program that we want to write <sil=0.951> .PERIOD Recall that we want to read a bunch of numbers and sum them <sil=0.931> .PERIOD And the end of the numbers is represented by a minus 1 <sil=0.923> .PERIOD Until now <sil=0.377> ,COMMA we have just read those numbers <sil=0.986> .PERIOD In this video we will look at the relation between multi dimensional erase and pointers and this is by far one of the trickiest topics in the entire course and you can code multi dimensional erase without actually understanding the exact relation between multi dimensional erase and pointers <sil=0.995> .PERIOD But understanding this gives you a better grasp of how C treats multi dimensional erase <sil=0.940> .PERIOD So <sil=0.393> ,COMMA we will now discuss how pointer arithmetic works with two dimensional matrices because as soon as we had discussed one dimensional matrices the next thing we did was we discussed two dimensional matrices <sil=0.959> .PERIOD We discussed the relation between pointers and one D arrays <sil=0.949> .PERIOD So <sil=0.517> ,COMMA let us try to see what is the relation between pointers and 2 D arrays <sil=0.995> .PERIOD Now <sil=0.349> ,COMMA this is more complicated than it looks at first sight and you can do a lot of matrix computations by not understanding this except that understanding this gives you a better grasp of what is happening <sil=0.919> .PERIOD We have seen that when you declare a 2 D array as a parameter to a function then you should specify the number of columns but not the number of rows <sil=0.969> .PERIOD So <sil=0.627> ,COMMA let us look at a function which makes an identity matrix <sil=0.996> .PERIOD An identity matrix is a matrix that has one along its diagonal and zero everywhere else <sil=0.991> .PERIOD So <sil=0.623> ,COMMA we have void make identity 10 and it takes a matrix of size double the number of columns is 10 <sil=0.911> .PERIOD Since identity matrices are square matrices this essentially says that the code will work for a 10 by 10 matrix <sil=0.964> .PERIOD Then I have a for loop going from i equal to 0 to 10 for loop going from for the columns going from j equal to 0 to 10 and the code just says that if I am at a diagonal element that is i equal to j then m i j is 1 for all other elements it m i j is 0 <sil=0.940> .PERIOD So <sil=0.509> ,COMMA this creates a matrix of size 10 by 10 <sil=0.982> .PERIOD Now <sil=0.594> ,COMMA this is a very strange code because it is a function that essentially makes exactly one matrix <sil=0.953> .PERIOD It would have been nice if I would have a function that can create arbitrary size identity matrices <sil=0.929> .PERIOD For example <sil=0.527> ,COMMA if I wanted a 20 by 20 matrix it looks like I have to write another function make identity 20 double m 20 <sil=0.986> .PERIOD The rows are unspecified the number of columns is 20 <sil=0.971> .PERIOD This is the standard way to do it <sil=0.404> ,COMMA but there is a slightly more complicated way to actually accomplish a function which can take an arbitrary size <sil=0.924> .PERIOD So <sil=0.501> ,COMMA let us see how these things can be done by understanding how pointer arithmetic works with 2 d arrays <sil=0.941> .PERIOD So <sil=0.615> ,COMMA let us go back to how do I address the i j th element in a 2 d array <sil=0.966> .PERIOD Now <sil=0.571> ,COMMA we can view it as a 3 by 5 matrix of integers something like this here <sil=0.945> .PERIOD So <sil=0.327> ,COMMA it may be an array is 0 1 2 3 4 that is row 0 and 5 6 7 8 9 that is row 1 10 11 12 13 14 that is row 2 <sil=0.958> .PERIOD So <sil=0.588> ,COMMA this is the matrix view which is 3 rows each with 5 columns this is the standard view <sil=0.513> ,COMMA but internally see views this as a long linear array of size 15 in what is known as the row major form <sil=0.962> .PERIOD So <sil=0.314> ,COMMA let us just look at what what it is internally see looks as looks at the array in the following form it is basically 0 0 through 14 laid out in a single row <sil=0.963> .PERIOD So <sil=0.639> ,COMMA this is the row major view it is called row major because first all elements of row 0 will be laid out then all elements of row 1 will be laid out and finally <sil=0.647> ,COMMA all elements of the last row will be laid out <sil=0.602> ,COMMA but it is laid out as a linear way <sil=0.929> .PERIOD Now <sil=0.426> ,COMMA the natural question to ask is in that case is a 2 d array really at the heart of it just a 1 d array <sil=0.939> .PERIOD So <sil=0.358> ,COMMA the difference between a 2 d array seen in the row major view point and an actual 1 dimensional array will come in the pointer array of it magic <sil=0.972> .PERIOD So <sil=0.484> ,COMMA as I just mentioned there are 2 views the matrix view and the row major view and both views are correct <sil=0.990> .PERIOD So <sil=0.405> ,COMMA if I have the matrix view mat is a pointer to the first row <sil=0.927> .PERIOD So <sil=0.348> ,COMMA mat plus 1 will be a pointer to the second row and mat plus pointer to the second row and mat plus 2 will be a pointer to the third row <sil=0.950> .PERIOD So <sil=0.330> ,COMMA row number 3 or row indexed with 2 in the row major view point here is the difference mat points to the first row and mat plus 1 should point to the second row <sil=0.921> .PERIOD So <sil=0.406> ,COMMA we cannot say that mat is pointing to the first element here and mat plus 1 should point to therefore <sil=0.331> ,COMMA 1 <sil=0.305> .PERIOD Now <sil=0.432> ,COMMA that is not what happens it has to be consistent with the matrix view <sil=0.973> .PERIOD So <sil=0.318> ,COMMA the pointer arithmetic mat plus 1 should point to the same element regardless of whether you are looking at it using the matrix view point or whether you are looking at it using the row major view point <sil=0.981> .PERIOD So <sil=0.539> ,COMMA mat plus 1 will still point to 5 and mat plus 2 will still point to 10 <sil=0.905> .PERIOD So <sil=0.438> ,COMMA these 2 view points are consistent <sil=0.912> .PERIOD Now <sil=0.618> ,COMMA here is the difference with one dimensional arrays <sil=0.903> .PERIOD So <sil=0.362> ,COMMA we have just repeated the view points here the matrix view point and the row major view point <sil=0.929> .PERIOD Now <sil=0.371> ,COMMA had mat actually been a one dimensional array mat would point to the first element in the array therefore <sil=0.508> ,COMMA mat plus 1 should point to the second element in the array that is not what happens it is actually the row major representation of a 2 D array and mat plus 1 should skip exactly 5 elements because that is the size of the column <sil=0.996> .PERIOD So <sil=0.363> ,COMMA mat plus 1 should skip 5 elements and go to the element mat 1 0 <sil=0.904> .PERIOD So <sil=0.484> ,COMMA here is the mat 1 0 <sil=0.953> .PERIOD So <sil=0.471> ,COMMA here is the gist of why you need to know the number of columns because in the row major view point I have to implement mat plus 1 <sil=0.994> .PERIOD So <sil=0.371> ,COMMA I have to say how many elements should I skip in order to get to the first element of the second row <sil=0.949> .PERIOD So <sil=0.506> ,COMMA how and that number is exactly the number of columns in the array <sil=0.904> .PERIOD So <sil=0.540> ,COMMA the number of columns in the array is 5 <sil=0.918> .PERIOD So <sil=0.644> ,COMMA to get to mat plus from mat I have to skip 5 elements <sil=0.909> .PERIOD Similarly <sil=0.546> ,COMMA to get to mat plus 2 from mat plus 1 I have to skip exactly 5 elements <sil=0.985> .PERIOD So <sil=0.375> ,COMMA this is the reason why the number of columns is an important information because that tells me how many in the row in the row major representation how many elements do I have to skip in order to get to the correct entry in the second row of the third row <sil=0.937> .PERIOD So <sil=0.403> ,COMMA here is the pointer arithmetic for the row major representation and notice that this is considerably different from the pointer arithmetic for a 1 D array <sil=0.916> .PERIOD In a 1 D array array plus 1 will go here the first element of the array <sil=0.927> .PERIOD Now <sil=0.394> ,COMMA can you try to guess what will be the type of mat <sil=0.901> .PERIOD So <sil=0.328> ,COMMA here are 4 candidates and let us go through them to see what is the most likely candidate and we will see this in greater detail <sil=0.984> .PERIOD In-stare mat mat is a pointer to int <sil=0.932> .PERIOD Now <sil=0.540> ,COMMA we have seen that that is approximately an array of integers and that is definitely incorrect because this is supposed to be a 2 D array not an array of integers <sil=0.956> .PERIOD Pointer to pointer to mat we have not seen that so far and that looks like a likely candidate <sil=0.966> .PERIOD So <sil=0.310> ,COMMA what about the third and the fourth <sil=0.886> ?QUESTIONMARK So <sil=0.523> ,COMMA the third and the fourth looks confusingly similar what do they mean <sil=0.966> .PERIOD So <sil=0.539> ,COMMA here is a hint the array indexing operator square black edge has higher precedence than star the dereferencing operator <sil=0.939> .PERIOD So <sil=0.476> ,COMMA in this case the first says that so what does this mean <sil=0.873> ?QUESTIONMARK The first declaration is actually int star mat 5 <sil=0.921> .PERIOD And the second declaration is int star mat 5 <sil=0.906> .PERIOD So <sil=0.481> ,COMMA what does this say <sil=0.889> ?QUESTIONMARK So <sil=0.446> ,COMMA let us compare with the standard declaration like float array 5 <sil=0.926> .PERIOD This means that array is a r r is an array of size 5 each entry of type float <sil=0.980> .PERIOD Similarly <sil=0.625> ,COMMA this means that matrix mat is a standard is an array of size 5 each entry being a pointer to integer <sil=0.900> .PERIOD So <sil=0.524> ,COMMA it will be some matrix like this it has 5 elements and each of them is a pointer <sil=0.956> .PERIOD So <sil=0.566> ,COMMA here is the view point for declaration 3 <sil=0.946> .PERIOD Now <sil=0.412> ,COMMA what about declaration 4 <sil=0.990> ?QUESTIONMARK So <sil=0.399> ,COMMA there is a point of the definition let us see this <sil=0.961> .PERIOD So <sil=0.369> ,COMMA let us compare it with a standard declaration like let us take a standard declaration like int a r r 5 <sil=0.981> .PERIOD Again this says that a r r is an integer array of size 5 <sil=0.904> .PERIOD So <sil=0.365> ,COMMA it contains 5 elements each of type int correspondingly what this means is that star mat is an integer array <sil=0.939> .PERIOD So <sil=0.469> ,COMMA here is an integer array containing 5 elements <sil=0.954> .PERIOD These are integers <sil=0.930> .PERIOD Now <sil=0.613> ,COMMA this means that if you dereference mat so <sil=0.568> ,COMMA mat is a pointer to an array of size 5 and this is exactly the actual representation of a 2 dimension array <sil=0.971> .PERIOD So <sil=0.385> ,COMMA notice the difference between these 2 representations the first says that mat 5 mat is an array of 5 entries and each entry is a pointer to an int <sil=0.965> .PERIOD So <sil=0.453> ,COMMA it looks like this <sil=0.917> .PERIOD So <sil=0.544> ,COMMA it is an array of 5 pointers to int <sil=0.907> .PERIOD The last declaration says that star is an array of int of size 5 <sil=0.982> .PERIOD So <sil=0.336> ,COMMA mat is a pointer to an array of integers of size 5 <sil=0.937> .PERIOD So <sil=0.595> ,COMMA here is the difference and we will argue that the fourth definition is essentially what we want and we will see this in greater detail <sil=0.997> .PERIOD So <sil=0.370> ,COMMA let us understand these type expressions in greater detail and we will see this in the further video also <sil=0.912> .PERIOD We will particularly pick on one representation here <sil=0.961> .PERIOD So <sil=0.547> ,COMMA we have argued that a 2 d array is similar to the last declaration here <sil=0.969> .PERIOD I have eliminated the most obviously wrong declaration which is int star mat that is basically a 1 dimensional array <sil=0.967> .PERIOD So <sil=0.626> ,COMMA I have just eliminated that we will examine all the others <sil=0.990> .PERIOD What I have just said is that a 2 d array is similar to the last declaration <sil=0.306> ,COMMA but even the previous 2 declarations do make sense and there may be situations where you need to use such variables <sil=0.909> .PERIOD Let us examine them in greater detail <sil=0.993> .PERIOD So <sil=0.515> ,COMMA let us look at the first one which is in star star mat and it means all of the following equivalent ways <sil=0.906> .PERIOD So <sil=0.425> ,COMMA all of these are equivalent ways of looking at the same thing <sil=0.967> .PERIOD You could say that a mat is of type in star star or you could say that mat is a pointer to a pointer to an int <sil=0.983> .PERIOD Since arrays are pointers approximately you could also say that mat is an array of pointers to int and this is also commonly called array of arrays <sil=0.907> .PERIOD So <sil=0.327> ,COMMA you have mat in star star <sil=0.920> .PERIOD Now <sil=0.443> ,COMMA this is a pointer to an array of integers <sil=0.991> .PERIOD Now <sil=0.622> ,COMMA every pointer to an int is essentially a pointer to an array you can look at it like that <sil=0.913> .PERIOD So <sil=0.344> ,COMMA you can say that mat will point to an array of pointers and this array of pointers each of them may point to a different array <sil=0.960> .PERIOD So <sil=0.556> ,COMMA you de-reference mat once you will get a pointer to an integer and again you de-reference once more you will get the actual array <sil=0.951> .PERIOD So <sil=0.384> ,COMMA what happens when I do mat plus 1 it will go to the second entry in the array of integers <sil=0.919> .PERIOD Now <sil=0.614> ,COMMA that may be a different array altogether <sil=0.909> .PERIOD So <sil=0.409> ,COMMA mat 00 is similar to star star mat this is just the way address arithmetic works and both of them are addresses both of them are pointing to this location both of them mean the content of this location <sil=0.980> .PERIOD Similarly <sil=0.552> ,COMMA star star of star mat plus 1 is mat of 0 plus mat of 0 1 <sil=0.901> .PERIOD So <sil=0.608> ,COMMA in the case of one dimensional arrays we have just mentioned the equation that array of I is the same as star of a r r plus I and what we are saying here essentially is that mat i j is the same rule applied twice <sil=0.951> .PERIOD So <sil=0.428> ,COMMA I could say mat i is star of mat plus I so that will give me an array and then I need the jth element of that <sil=0.959> .PERIOD So <sil=0.610> ,COMMA we can again do star of star mat plus I plus j <sil=0.926> .PERIOD So <sil=0.420> ,COMMA this is these are two ways of looking at this array <sil=0.934> .PERIOD So <sil=0.468> ,COMMA mat plus 1 will be the next element in the pointer to integers and it is the same as and when you dereference it you will get another array <sil=0.905> .PERIOD So <sil=0.463> ,COMMA in order to get the first element of this array I could say mat 1 0 or using the pointer notation I have star of star mat plus 1 <sil=0.975> .PERIOD So <sil=0.486> ,COMMA these are the same and similarly for other elements of the array <sil=0.939> .PERIOD One of the advantages of this kind of in star star mat is that I have freedom in both dimensions <sil=0.922> .PERIOD You can see these as the rows of a matrix and these as the columns of a matrix <sil=0.933> .PERIOD If you see that then you can see that I have a lot of freedom here <sil=0.929> .PERIOD First of all the number of rows is not limited because it is just in star star mat I could have any number of rows here <sil=0.962> .PERIOD Now <sil=0.482> ,COMMA another main advantage and the reason why this is somewhat popular is that the length of row 0 need not be the same as the length of row 1 <sil=0.912> .PERIOD These are just pointers to integers <sil=0.903> .PERIOD So <sil=0.598> ,COMMA the first pointer to integer may be pointing to a row of size 2 <sil=0.971> .PERIOD The second pointer may be pointing to a row of size 3 and so on <sil=0.907> .PERIOD So <sil=0.327> ,COMMA the row lengths need not be the same <sil=0.946> .PERIOD So <sil=0.374> ,COMMA think of an array where row 0 is two elements long and row 1 is has three elements in the row and so on <sil=0.932> .PERIOD So <sil=0.482> ,COMMA if you have extremely ragged arrays then in star star mat is a nice representation to pick <sil=0.915> .PERIOD In this lecture <sil=0.634> ,COMMA we will see some more pointer arithmetic operators and we will introduce those by talking about them through a problem <sil=0.985> .PERIOD So <sil=0.354> ,COMMA the problem that I have is that of reversing an array <sil=0.910> .PERIOD So <sil=0.477> ,COMMA we have to write a function to reverse an array and let us say that the declaration of the function is void reverse array int a int n <sil=0.995> .PERIOD Now <sil=0.349> ,COMMA if you have to reverse an array <sil=0.636> ,COMMA what is one way to do it <sil=0.990> ?QUESTIONMARK You take the array <sil=0.539> ,COMMA copy it into another array and then copy back in the reverse fashion <sil=0.937> .PERIOD So <sil=0.327> ,COMMA you have an array a <sil=0.437> ,COMMA copy all the values into p and now you copy those values back to a in the following way that the b's last value will go to a of 0 <sil=0.429> ,COMMA b's second last value will go to a of 1 and so on <sil=0.936> .PERIOD Now <sil=0.631> ,COMMA let us try to do it slightly more cleverly <sil=0.961> .PERIOD We want to take an integer array and reverse the array in place that means that essentially using no extra space <sil=0.944> .PERIOD So <sil=0.309> ,COMMA do not use an extra array in order to reverse it <sil=0.641> ,COMMA reverse it within a itself <sil=0.923> .PERIOD So <sil=0.425> ,COMMA the array before calling reverse array will look like a 0 up to a and minus 1 in this way and after calling reverse array it should look like a and minus 1 a and minus 2 etcetera up to a 0 and in doing that we should not use an extra array <sil=0.948> .PERIOD So <sil=0.555> ,COMMA how do we do this <sil=0.906> ?QUESTIONMARK Let us look at bunch of con couple of concrete examples to see how do how do we do it by hand and then we will try to code that algorithm <sil=0.912> .PERIOD So <sil=0.315> ,COMMA in this there are two cases <sil=0.963> .PERIOD So <sil=0.567> ,COMMA for example what happens when you have an even length array when you have let us say 6 elements <sil=0.326> ,COMMA then a 0 and a 5 have to be exchange a 5 goes to a 0 a 5 goes to the 0th location a 0 goes to the 6th location or the 5th location and then a 1 and a 4 have to be exchanged a 2 and a 3 have to be exchanged after this you should stop right that will correctly reverse the array <sil=0.907> .PERIOD Now <sil=0.478> ,COMMA what happens if the case of in the case of an odd length array <sil=0.982> .PERIOD So <sil=0.504> ,COMMA suppose you have an array b which has only 5 elements in that case to reverse the array you have to exchange b 0 and b 4 b 1 and b 3 and you can stop there because there is no need to exchange b 2 with itself right <sil=0.933> .PERIOD So <sil=0.500> ,COMMA the case of an odd length array you will end up with an element which does not need to be touched in the case of an even length array you have to exchange until you reach the middle of the array <sil=0.919> .PERIOD Let us try to code this up <sil=0.924> .PERIOD So <sil=0.374> ,COMMA how is the reverse array written first I need so remember how we did this by hand we exchange the 0th location with the last location then we exchange the first location with the second last location and so on <sil=0.909> .PERIOD So <sil=0.382> ,COMMA it is easy to code if you have 2 pointers initially 1 pointer starts to at the beginning of the array the second pointer is to the last of the array exchange those values then the first pointer goes to the next location and the second pointer goes to the previous location that is how we did it by hand <sil=0.937> .PERIOD So <sil=0.386> ,COMMA let us try to code that up I will have a pointer b which points to the last element of the array a plus n minus 1 <sil=0.942> .PERIOD Now <sil=0.541> ,COMMA the loop is as follows I will discuss this in a minute while b is greater than a <sil=0.943> .PERIOD So <sil=0.516> ,COMMA remember in the example by hand we had to exchange till we reach the middle of the array <sil=0.954> .PERIOD Now <sil=0.532> ,COMMA how do we find the middle of the array I will just write it as b greater than a and I will explain it in a minute <sil=0.969> .PERIOD So <sil=0.307> ,COMMA while this is true that you have not yet reached the middle of the array you exchange swap a and b here we use the swap function which we have seen in the previous lecture <sil=0.913> .PERIOD So <sil=0.379> ,COMMA for example <sil=0.487> ,COMMA it will swap the 0th element with the n minus first element after that is done you increment a and you decrement b <sil=0.953> .PERIOD So <sil=0.574> ,COMMA the design logic is that a initially points to the first element of the array the left end of the array and b points to the right end of the array <sil=0.931> .PERIOD In general while the algorithm happens then a is moving forward and b is moving backward <sil=0.934> .PERIOD Inside the loop you exchange star a with star b that is what is accomplished by calling swap of a and b because swap a and b will dereference those locations and exchange the values there <sil=0.953> .PERIOD So <sil=0.348> ,COMMA do this repeatedly until a and b cross over because when a is moving forward and b is moving backward then the middle of the array is the point where a and b cross over or the point where a and b mean <sil=0.947> .PERIOD So <sil=0.504> ,COMMA this is the very simple logic for reversing an array <sil=0.992> .PERIOD Now <sil=0.386> ,COMMA I have left one thing unexplained what do I mean by b greater than a b and a are pointers <sil=0.905> .PERIOD So <sil=0.539> ,COMMA what do I mean by pointer b is greater than pointer a we need to explain that we are introducing an operation an operator on two pointers what does it mean <sil=0.999> .PERIOD So <sil=0.391> ,COMMA we are seeing a new concept which is relational comparison between two pointers <sil=0.937> .PERIOD If a and b are pointers to variables of the same type like in star a and in star b we can compare them compare these pointers using equal to and not equal to this can be done for arbitrary locations a and b as long as those locations are of the same type <sil=0.948> .PERIOD So <sil=0.583> ,COMMA a equal to b is true if and only if a and b are pointing to the same location that is natural to expect otherwise if they are pointing to different locations a not equal to b is true <sil=0.978> .PERIOD Now <sil=0.526> ,COMMA there is another case if a is pointing to an integer let us say and b is pointing to a float then equal to and not equal to are undefined <sil=0.957> .PERIOD So <sil=0.591> ,COMMA notice that even though this behavior looks natural it is natural only if they are pointing to the same type <sil=0.920> .PERIOD So <sil=0.301> ,COMMA here are operations equal to and not equal to what about less than or equal to greater than greater than or equal to and so on and this is surprising because here is something that you do not expect you cannot compare less than or equal to on arbitrary locations in the memory <sil=0.956> .PERIOD We can compare a and b using less than for this they must be pointing to the same locations in the array <sil=0.955> .PERIOD Earlier when we discussed plus and minus we were saying that plus and minus are well behaved only when you are navigating within an array <sil=0.916> .PERIOD Similarly <sil=0.373> ,COMMA when we are comparing two pointers using greater than or equal to less than or equal to then they should all be point then a and b should be pointing to the same array different locations in the same <sil=0.918> .PERIOD If that is true then a is less than b if the value is pointing to a location which is before b in the same array <sil=0.901> .PERIOD Similarly <sil=0.418> ,COMMA a less than or equal to b is true if a is pointing to a location which is b or before b and so on <sil=0.902> .PERIOD So <sil=0.306> ,COMMA for example we can see that if we have an array in a 10 then a plus 1 is less than plus 2 that is clearly true because a plus 1 is pointing to the location 1 in the array and a plus 2 is pointing to location 2 in the array <sil=0.998> .PERIOD So <sil=0.554> ,COMMA if you have an array for example <sil=0.324> ,COMMA let us say a 0 through a 9 and p t r a is pointing to location 1 and p t r b is pointing to location 3 then p t r a is less than p t r b here the comparison is well defined and it is true <sil=0.941> .PERIOD But on the other hand let us say that p t r a is pointing to a of 1 and p t r b is pointing to b of 1 in this case p t r a less than p t r b is undefined because they are pointing to two different arrays <sil=0.935> .PERIOD So <sil=0.445> ,COMMA maybe memory a is laid out before b and so on but that is not what the less than or equal to operation is supposed to do it is supposed to compare pointers only within the same array <sil=0.997> .PERIOD So <sil=0.417> ,COMMA with this understanding let us understand how the reverse array works <sil=0.984> .PERIOD So <sil=0.536> ,COMMA in the first iteration you have an array a let us say that the array is 101 21 and so on it has 6 locations and we will run through the trace of the execution for an even length array and I would encourage you to create an odd length array and trace through the executions to ensure that the code works for odd length arrays as well <sil=0.975> .PERIOD So <sil=0.307> ,COMMA in this lecture we will do it for even length array <sil=0.903> .PERIOD So <sil=0.353> ,COMMA a is initially pointing to the beginning of the array b is pointing to the end of the array a plus n minus 1 will go to the end of the array <sil=0.911> .PERIOD Now <sil=0.584> ,COMMA b is greater than a that is true <sil=0.965> .PERIOD So <sil=0.513> ,COMMA we will enter the loop and in the first iteration we will swap a and b <sil=0.970> .PERIOD So <sil=0.413> ,COMMA it will go to the swap function and this is the swap function that actually works from the previous video <sil=0.900> .PERIOD So <sil=0.434> ,COMMA you can assume that a 0 will be swapped with a 1 a is so they were initially 101 and 0 and after swap they will be 0 and 101 <sil=0.959> .PERIOD Now <sil=0.490> ,COMMA once that happens a advances by 1 integer location b goes back by 1 integer location <sil=0.920> .PERIOD So <sil=0.533> ,COMMA this is the state after the first iteration <sil=0.943> .PERIOD In the second iteration you start with a at 21 and b at minus 101 again b is greater than a so is swap <sil=0.983> .PERIOD So <sil=0.532> ,COMMA 21 minus 101 becomes minus 101 and 21 <sil=0.960> .PERIOD So <sil=0.481> ,COMMA they are swapped and you advance a by 1 and you take back b by 1 again b is greater than a so you go to the third iteration <sil=0.907> .PERIOD In the third iteration this is the state at the beginning of the iteration and you swap these contents <sil=0.987> .PERIOD So <sil=0.613> ,COMMA you swap minus 1 and 1 21 it becomes this becomes the state of the array and once that is done b overshoots so b goes before a and a goes after b <sil=0.928> .PERIOD So <sil=0.495> ,COMMA I denoted that with two colored arrows <sil=0.952> .PERIOD So <sil=0.573> ,COMMA here is the b arrow it goes to location 121 and the a arrow goes to location minus 1 <sil=0.965> .PERIOD When this happens b is now less than a so this means that you have crossed the middle of the array therefore <sil=0.398> ,COMMA you should stop now <sil=0.954> .PERIOD So <sil=0.534> ,COMMA now b is less than a and the loop terminates and we have seen that this correctly reverse the array <sil=0.902> .PERIOD So <sil=0.333> ,COMMA here is how the reverse array works we have seen the concept of relational comparison operators using pointers how they make sense when they are pointing to locations within the same array and how that can be used to write code using arrays <sil=0.928> .PERIOD In this session <sil=0.546> ,COMMA we will use the for loop to code up a matrix problem <sil=0.904> .PERIOD So remember that we have seen a while loop and we have seen a do while loop inside while loops we have written nested loops or double loops <sil=0.975> .PERIOD So let us look at a for loop which problem where the solution involves a nested loop <sil=0.958> .PERIOD So the for loops are a good choice when the number of iterations is known in advance <sil=0.934> .PERIOD So a good example of such a condition is when you program for matrices because the dimensions of the matrices are known in advance <sil=0.986> .PERIOD So let us consider a sample problem <sil=0.968> .PERIOD So the first line of the input has a number n <sil=0.927> .PERIOD Now the matrix size is n cross n and there are n floating point numbers in the matrix given row by row <sil=0.940> .PERIOD Each line contains a distinct row <sil=0.938> .PERIOD Now the problem is to compute the trace of the matrix <sil=0.991> .PERIOD The trace of the matrix is the sum of the diagonal elements <sil=0.980> .PERIOD So it is defined as summation from i equal to 0 to n minus 1 of a sub i i <sil=0.914> .PERIOD Notice that the matrix row indexing starts from 0 <sil=0.965> .PERIOD Similarly <sil=0.381> ,COMMA the matrix column indexing also starts from 0 <sil=0.925> .PERIOD So let us write a c program to solve this problem <sil=0.910> .PERIOD Now you should be familiar with how we compute the trace of a matrix <sil=0.992> .PERIOD So for example <sil=0.325> ,COMMA if the matrix is given as let us say 1 <sil=0.495> ,COMMA 2 <sil=0.645> ,COMMA 3 <sil=0.460> ,COMMA 4 <sil=0.393> ,COMMA 5 <sil=0.482> ,COMMA 6 <sil=0.616> ,COMMA 7 <sil=0.601> ,COMMA 8 <sil=0.437> ,COMMA 9 <sil=0.606> .PERIOD So the way we do it by hand is look at the first row only this element goes into the trace <sil=0.999> .PERIOD So it is trace is 1 plus no other element of the row goes into the trace <sil=0.916> .PERIOD In the second row the second element goes into the trace <sil=0.950> .PERIOD So it is 5 plus and then no other remaining element goes into the trace <sil=0.991> .PERIOD So you go to the third row and the third element goes into the trace <sil=0.926> .PERIOD So 1 plus 5 plus 9 <sil=0.904> .PERIOD This is how we do it by hand <sil=0.974> .PERIOD You go row by row and then pick out for each row pick some element which goes into the trace <sil=0.930> .PERIOD Only the diagonal element will go into the trace <sil=0.932> .PERIOD Let us try to code this up <sil=0.995> .PERIOD So in this we have two variables i and j which I will use to iterate over the row indices and the column indices <sil=0.998> .PERIOD n is the designator for the size of the matrix <sil=0.919> .PERIOD For example the dimension of the matrix is n cross n <sil=0.984> .PERIOD Now a is the variable into which I will read the current entry and then trace is the sum of the diagonal elements seen so far <sil=0.999> .PERIOD I will assume that it is an integer matrix <sil=0.959> .PERIOD It is not general enough <sil=0.984> .PERIOD You can use a float variable as well <sil=0.998> .PERIOD I will first can have the size of the matrix n <sil=0.924> .PERIOD The matrix is of dimension n cross n <sil=0.958> .PERIOD Once I have done that here is what I was talking about in the previous slide <sil=0.978> .PERIOD Once you scan the number n you know that the matrix is n cross n <sil=0.964> .PERIOD So the number of times that you are going to iterate is known in advance <sil=0.931> .PERIOD So the number of times that you have to iterate is known before you enter the for loop <sil=0.941> .PERIOD In such cases the for loop is more convenient to write than the while loop <sil=0.983> .PERIOD So the outer loop is for each row from i equal to 0 to i equal to n excluding i equal to n you increment the row <sil=0.908> .PERIOD Similarly for j equal to 0 to n you increment the column index <sil=0.900> .PERIOD So j is supposed to be the column index <sil=0.937> .PERIOD Now you scan the number a <sil=0.953> .PERIOD Now if i equal to j remember that we wanted to add the only the diagonal elements <sil=0.935> .PERIOD So the diagonal elements will be when the row index is the same as the column index <sil=0.945> .PERIOD So when the row index is the same as the column index you should add the corresponding number to the trace <sil=0.931> .PERIOD So once j becomes n minus 1 you will fail the test j is less than n <sil=0.960> .PERIOD So we will exit out of the inner for loop and you will go to the outer for loop <sil=0.904> .PERIOD In the outer for loop you have i iterating over the row indices <sil=0.958> .PERIOD So you will go to the next row and do the same processing for the next row until you hit row index n at which point you will exit out of the outer for loop <sil=0.901> .PERIOD So let us look at a sample input <sil=0.927> .PERIOD Let us say that you have 1 <sil=0.600> ,COMMA 2 <sil=0.464> ,COMMA 3 <sil=0.379> ,COMMA 1 <sil=0.639> ,COMMA 3 <sil=0.343> ,COMMA 3 and minus 1 <sil=0.385> ,COMMA 0 <sil=0.472> ,COMMA minus 1 <sil=0.959> .PERIOD Here is a particular convenience that c gives you which I have used in this code <sil=0.948> .PERIOD So notice that this if block I did not put the braces <sil=0.925> .PERIOD So it would have been necessary to put the braces according to the syntax that we have discussed so far <sil=0.946> .PERIOD But if there is only a single statement in the if block then we do not need to put the braces and it is syntactically correct to do so <sil=0.922> .PERIOD So let us just run the program on a sample input <sil=0.978> .PERIOD So we have some sample array 2 <sil=0.540> ,COMMA 0 <sil=0.311> ,COMMA minus 1 <sil=0.967> ,COMMA 1 <sil=0.320> ,COMMA 3 <sil=0.433> ,COMMA 4 <sil=0.499> ,COMMA minus 1 <sil=0.944> ,COMMA 0 <sil=0.587> ,COMMA 1 <sil=0.455> .PERIOD So initially there is this number 3 <sil=0.979> .PERIOD So you know that it is a 3 cross 3 matrix <sil=0.928> .PERIOD So once you do that you know that n is 3 <sil=0.953> .PERIOD So representing that it is a 3 cross 3 matrix <sil=0.901> .PERIOD So then you start with i equal to 0 and go on until i less than n incrementing i by 1 each time <sil=0.932> .PERIOD i is 0 <sil=0.429> ,COMMA i is less than n because n is 3 <sil=0.937> .PERIOD So you enter the outer loop <sil=0.901> .PERIOD The first statement of the outer loop is itself a for loop <sil=0.964> .PERIOD You start with j equal to 0 <sil=0.949> .PERIOD j is less than 3 <sil=0.934> .PERIOD So you enter the inner loop <sil=0.929> .PERIOD You scan a number A which is a floating point number and if i equal to j <sil=0.977> .PERIOD So remember that we are looking for diagonal elements <sil=0.988> .PERIOD So we are currently at this point and i equal to 0 and j equal to 0 <sil=0.905> .PERIOD So we are entering we are scanning the 0th element of the 0th column of the 0th row <sil=0.976> .PERIOD So that element has to go into the trace <sil=0.930> .PERIOD So i equal to j is true and then you say that trace equal to trace plus A <sil=0.948> .PERIOD Trace was initialized to 0 <sil=0.976> .PERIOD So trace becomes now 2 <sil=0.933> .PERIOD Once you do that you iterate the inner for loop <sil=0.932> .PERIOD So you go to the update statement in the inner for loop <sil=0.959> .PERIOD j becomes j plus 1 <sil=0.914> .PERIOD So you go to the next column and j is less than 3 <sil=0.945> .PERIOD So you scan the next number 0 <sil=0.988> .PERIOD If i equal to j that is false now because i is 0 and j is 1 <sil=0.977> .PERIOD So you do not execute the if statement and go to the update statement <sil=0.990> .PERIOD So j becomes 2 <sil=0.994> .PERIOD 2 is less than 3 <sil=0.953> .PERIOD So you scan one more number which is minus 1 <sil=0.961> .PERIOD i is not j <sil=0.917> .PERIOD So you update again <sil=0.969> .PERIOD j becomes 3 <sil=0.970> .PERIOD Now 3 is not less than 3 <sil=0.912> .PERIOD So you exit out of the inner loop <sil=0.901> .PERIOD When you exit out of the inner loop there are no more statements to execute <sil=0.951> .PERIOD So you go directly to the update statement in the outer loop which becomes i equal to i plus 1 <sil=0.919> .PERIOD So you are reading the first row <sil=0.937> .PERIOD row number 1 <sil=0.905> .PERIOD You have finished reading row number 0 <sil=0.958> .PERIOD Again you scan the numbers <sil=0.988> .PERIOD When j equal to 1 that is the second number in the second row you will see that i equal to j because i is 1 and j is 1 <sil=0.970> .PERIOD So you will add it to the trace <sil=0.907> .PERIOD So that is 2 plus 3 which is 5 <sil=0.982> .PERIOD So trace gets updated <sil=0.997> .PERIOD And after you do that you scan the remaining entry in the same row but it does not go to the trace and then you are done with the row <sil=0.926> .PERIOD After that again you go to the outer loop <sil=0.912> .PERIOD You update the row index <sil=0.999> .PERIOD Now the row index is less is 2 which is less than 3 <sil=0.909> .PERIOD So you exit <sil=0.950> .PERIOD So you enter the if condition and you execute the inner loop <sil=0.940> .PERIOD When i equal to 2 and j equal to 2 you will find an element which is minus 1 which will go into the trace <sil=0.947> .PERIOD So the elements that will be added to the trace are when 2 <sil=0.549> ,COMMA 3 and minus 1 <sil=0.540> .PERIOD Once you are done you get out of the inner loop and then you go into the outer loop and update it <sil=0.954> .PERIOD But then i becomes 3 <sil=0.929> .PERIOD It is no longer true that 3 is less than 3 <sil=0.927> .PERIOD So you are done reading all the rows <sil=0.942> .PERIOD So you exit the program <sil=0.965> .PERIOD When you exit the program you have the correct trace which is 4 <sil=0.943> .PERIOD Since <sil=0.396> ,COMMA pointer arithmetic is a tricky concept <sil=0.483> ,COMMA let us solve one more problem to try to get comfortable with that notion <sil=0.919> .PERIOD So <sil=0.448> ,COMMA the problem here is copying a sub array into another array <sil=0.902> .PERIOD Now <sil=0.568> ,COMMA let us explain what that means <sil=0.977> .PERIOD Suppose <sil=0.420> ,COMMA I have written a function copy array <sil=0.583> ,COMMA which has three arguments <sil=0.624> ,COMMA an array <sil=0.463> ,COMMA an integer array a <sil=0.593> ,COMMA an integer array b <sil=0.469> ,COMMA and n <sil=0.442> ,COMMA which is the size <sil=0.589> ,COMMA I want to copy n successive index elements from a and put it into b <sil=0.996> .PERIOD So <sil=0.397> ,COMMA a 0 through a n minus 1 have to be copied to b <sil=0.917> .PERIOD I can easily write it in the following function as int copy array int a int b int n <sil=0.998> .PERIOD And then <sil=0.311> ,COMMA I have one variable to keep track of the index and that variable goes from 0 to n i for i equal to 0 i less than n i equal to i plus 1 <sil=0.901> .PERIOD And then <sil=0.322> ,COMMA I simply say b i equal to a i within the loop <sil=0.941> .PERIOD So <sil=0.430> ,COMMA this would copy whatever a i is into the location b i <sil=0.919> .PERIOD So <sil=0.413> ,COMMA once the loop executes <sil=0.360> ,COMMA I would have copied n elements from the array a to the array b <sil=0.917> .PERIOD But <sil=0.515> ,COMMA this is not general and I want to solve the following problem <sil=0.986> .PERIOD So <sil=0.504> ,COMMA I have two arrays <sil=0.637> ,COMMA let us name them from and two <sil=0.939> .PERIOD And I want to copy n numbers from the array from 2 to 2 <sil=0.978> .PERIOD But <sil=0.371> ,COMMA I have an additional requirement <sil=0.626> ,COMMA I want to copy n elements from index i <sil=0.972> .PERIOD So <sil=0.349> ,COMMA the earlier code solve the problem from index 0 <sil=0.933> .PERIOD In general <sil=0.381> ,COMMA I want to copy from index i of from n elements into the location starting at index j into <sil=0.927> .PERIOD So <sil=0.447> ,COMMA the earlier function assume that i and j were both 0 <sil=0.987> .PERIOD In the general function <sil=0.551> ,COMMA I want arbitrary i and arbitrary j <sil=0.989> .PERIOD So <sil=0.368> ,COMMA I need a declaration like the following <sil=0.641> ,COMMA I have int copy array 2 <sil=0.996> .PERIOD So <sil=0.517> ,COMMA this is the second function I am writing <sil=0.940> .PERIOD And I have from i to j and then n is the number of elements to copy <sil=0.919> .PERIOD So <sil=0.451> ,COMMA what I have to do is from i from i plus 1 <sil=0.330> ,COMMA so on up to from i plus n minus 1 <sil=0.641> ,COMMA have to be copied to 2 of j <sil=0.350> ,COMMA 2 of j plus 1 <sil=0.325> ,COMMA so on up to 2 of j plus n minus 1 <sil=0.925> .PERIOD So <sil=0.614> ,COMMA the for the purposes of this lecture <sil=0.424> ,COMMA let us just assume that from and 2 are big enough <sil=0.923> .PERIOD So <sil=0.403> ,COMMA that you will never overshoot the arrays by taking i plus n minus 1 and j plus n minus 1 <sil=0.978> .PERIOD Can you write this function <sil=0.996> ?QUESTIONMARK Now <sil=0.379> ,COMMA obviously <sil=0.613> ,COMMA you can write a separate function to solve this <sil=0.964> .PERIOD Now <sil=0.635> ,COMMA the trick is can you use the copy array function <sil=0.321> ,COMMA the copy array functions copied n elements starting from index 0 of a to index n minus 1 to the array b starting at index b of 0 to b of n minus 1 <sil=0.998> .PERIOD So <sil=0.424> ,COMMA that is what it did <sil=0.982> .PERIOD And this should be strange because if you think about it in a mathematical way <sil=0.379> ,COMMA you are saying that a general function is being solved in terms of a particular function <sil=0.902> .PERIOD So <sil=0.558> ,COMMA you are reducing a general case to a special case that sounds a bit strange <sil=0.537> ,COMMA but we can do this with pointer arithmetic <sil=0.947> .PERIOD So <sil=0.410> ,COMMA let us try to solve it using our own function <sil=0.944> .PERIOD And here is the guess that I am making and then I will justify that this works <sil=0.943> .PERIOD So <sil=0.639> ,COMMA I will just say here is my function from i to j n that will be defined as copy array from plus i 2 plus j comma m <sil=0.972> .PERIOD So <sil=0.644> ,COMMA copy array will start from a of 0 and copy n elements afterwards to b of 0 <sil=0.904> .PERIOD So <sil=0.403> ,COMMA on a point <sil=0.384> ,COMMA we will have to b of n minus 1 and that function I am calling using the address from plus i 2 plus j and n <sil=0.362> ,COMMA n is the number of elements I want to copy <sil=0.943> .PERIOD Now <sil=0.537> ,COMMA I will justify that this works <sil=0.938> .PERIOD So <sil=0.336> ,COMMA here is the problem that I have and I want t of j equal to f of i <sil=0.517> ,COMMA t of j equal to f of i <sil=0.644> ,COMMA t of j plus 1 equal to f of i plus 1 <sil=0.531> ,COMMA so on up to t of j plus n minus 1 equal to f of i plus n minus 1 <sil=0.979> .PERIOD So <sil=0.643> ,COMMA let us try to see what happens in this function <sil=0.954> .PERIOD Suppose <sil=0.563> ,COMMA I call copy array 2 from main using the arrays f t i j n n and that function merely calls the old copy array function using f plus i t plus j n n <sil=0.919> .PERIOD So <sil=0.429> ,COMMA the state of execution at the start of copy array 2 <sil=0.398> ,COMMA let us say that f is an array with say 10 elements and t is an array with say 10 elements arbitrary <sil=0.953> .PERIOD And what I want is <sil=0.372> ,COMMA this is the function of the array <sil=0.932> .PERIOD I also assume that i is 2 and j is 4 <sil=0.992> .PERIOD So <sil=0.625> ,COMMA I want to copy 5 elements starting from the second location or the third location in f of 2 onwards to the fifth location in t onwards <sil=0.900> .PERIOD So <sil=0.504> ,COMMA here is what I want to <sil=0.370> ,COMMA so I want to copy this minus 1 minus 1 minus 1 to t of 4 onwards <sil=0.995> .PERIOD So <sil=0.445> ,COMMA I will copy them here <sil=0.377> ,COMMA so 5 elements are to be copied <sil=0.996> .PERIOD Let see how function is able to do this <sil=0.998> .PERIOD So <sil=0.452> ,COMMA t plus 4 is this location f plus 2 is this 4 is this location f plus 2 is this location <sil=0.921> .PERIOD So <sil=0.581> ,COMMA what I am calling is the old copy array function with f plus i <sil=0.920> .PERIOD So <sil=0.490> ,COMMA f is the address of the first location of the array <sil=0.995> .PERIOD Therefore <sil=0.522> ,COMMA f plus 2 using pointer arithmetic is the second integer box after that <sil=0.929> .PERIOD So <sil=0.491> ,COMMA it is pointing to f of 2 <sil=0.936> .PERIOD Similarly <sil=0.445> ,COMMA t plus 4 t plus j in this case is pointing to the fourth location after the location pointed to by t <sil=0.925> .PERIOD t is an array <sil=0.955> .PERIOD So <sil=0.624> ,COMMA t points to the first location in the array <sil=0.925> .PERIOD Therefore <sil=0.625> ,COMMA t plus 4 will point to the fifth location in the array <sil=0.960> .PERIOD So <sil=0.575> ,COMMA when I say f plus 2 f plus 2 is a pointer to here and t plus 4 is a pointer to here <sil=0.922> .PERIOD And I am calling copy array function with these as the arguments and n is the number of elements I want to copy <sil=0.984> .PERIOD So <sil=0.642> ,COMMA here is the state just before I call copy array function <sil=0.940> .PERIOD Now <sil=0.482> ,COMMA for example <sil=0.388> ,COMMA this particular box has several names <sil=0.970> .PERIOD The most common name for it will be f of 3 <sil=0.961> .PERIOD But I can also write it as star of f plus 3 <sil=0.916> .PERIOD This says jump 3 integer boxes after f and then dereference that address <sil=0.988> .PERIOD Now <sil=0.469> ,COMMA if you are comfortable with the notion that let us say f of i is the same as star of f plus i <sil=0.975> .PERIOD If you are comfortable with that notion then it should be easy to see that f plus 2 of 1 is just star of f plus 2 plus 1 <sil=0.930> .PERIOD It is the same formula that I am using and this happens to be f plus 3 which happens to be f of 3 <sil=0.929> .PERIOD So <sil=0.411> ,COMMA star of f plus 3 would be f of 3 and so on <sil=0.950> .PERIOD So <sil=0.631> ,COMMA this formula that f of i is the same as dereferencing the address f plus i <sil=0.991> .PERIOD f of i is star of f plus i is applicable even for more strange looking expressions <sil=0.929> .PERIOD Now <sil=0.509> ,COMMA if you are comfortable with here is a trivia about C that because of the way it is defined <sil=0.957> .PERIOD So <sil=0.514> ,COMMA if you say that f of i is the same as star of f plus i then you could think that this is the same as star of i plus f <sil=0.941> .PERIOD So <sil=0.469> ,COMMA I can write this as i of f <sil=0.984> .PERIOD So <sil=0.407> ,COMMA this is the same formula that I have written <sil=0.962> .PERIOD Never do this but it will actually work <sil=0.941> .PERIOD So <sil=0.374> ,COMMA f of i you can also write it as i of f for example <sil=0.322> ,COMMA 3 of f and it will also work because internally C translates into star of f plus i and we know that star of f plus i is the same as star of i plus f <sil=0.923> .PERIOD So <sil=0.605> ,COMMA never do this but this helps you to understand that f of i is being translated into this format <sil=0.997> .PERIOD So <sil=0.487> ,COMMA now that we know this similarly you can argue about star of t plus 4 and t plus 4 of 0 and so on all of them refer to the same box <sil=0.941> .PERIOD Now <sil=0.643> ,COMMA let us see what happens when we call copy array <sil=0.995> .PERIOD So <sil=0.626> ,COMMA we have the stack space for copy array 2 and copy array 2 calls copy array <sil=0.983> .PERIOD The formal parameters are A and B <sil=0.638> ,COMMA A copies the address that it was past 2 <sil=0.991> .PERIOD It was past the address f plus i <sil=0.916> .PERIOD So <sil=0.408> ,COMMA A points to f plus 2 <sil=0.975> .PERIOD Similarly <sil=0.368> ,COMMA B points to t plus 4 <sil=0.989> .PERIOD So <sil=0.400> ,COMMA t B points to this <sil=0.967> .PERIOD Now <sil=0.601> ,COMMA as far as copy array is concerned it is not too bothered by the fact that it was not past the absolute first address of the array <sil=0.942> .PERIOD It will think that whatever address it has been past is the start of an array and it will work from there <sil=0.982> .PERIOD So <sil=0.470> ,COMMA copy array does not bother the fact that I was given the second element of the array rather than the first element of the array and so on <sil=0.979> .PERIOD It will work as though the array started from there and here is where we are exploiting that fact <sil=0.992> .PERIOD So <sil=0.314> ,COMMA now copy n elements from this location to this location <sil=0.425> ,COMMA this array <sil=0.951> .PERIOD So <sil=0.390> ,COMMA n is 5 <sil=0.984> .PERIOD Now <sil=0.476> ,COMMA when you execute that you will have copy array 2 should copy 5 elements starting from here to 5 locations here <sil=0.901> .PERIOD So <sil=0.588> ,COMMA that is what it will actually do and when you execute the loop it will start from this location copy to t plus j then f plus i plus 1 will be copied to t plus j plus 1 and so on <sil=0.952> .PERIOD So <sil=0.357> ,COMMA it will copy these 5 locations to here in the t array <sil=0.954> .PERIOD And after you do this copy array returns and every variable that was allocated to copy array is erased but then because of pointers it was actually working with the arrays in copy array 2 <sil=0.908> .PERIOD So <sil=0.620> ,COMMA even when you erase all the memory allocated to copy array once you return these arrays would have been changed <sil=0.981> .PERIOD These 5 locations starting from f plus 2 have been copied to these 5 locations starting from t plus 4 <sil=0.901> .PERIOD So <sil=0.394> ,COMMA changes made to be by copy array is still maintained after you return to the calling function copy array 2 <sil=0.935> .PERIOD Okay <sil=0.365> ,COMMA once we have understood what algorithms are <sil=0.350> ,COMMA we will start writing a few simple programs in the C programming language <sil=0.914> .PERIOD Before we begin <sil=0.538> ,COMMA we will give a brief introduction to the process of programming <sil=0.986> .PERIOD When you are programming <sil=0.561> ,COMMA you follow typically what is known as the programming cycle and this contains three parts <sil=0.959> .PERIOD One is the process where you write the program or edit the program and after you are done editing the program <sil=0.343> ,COMMA you save it and then you compile your program <sil=0.976> .PERIOD If your compilation succeeds <sil=0.593> ,COMMA you are ready to run the program <sil=0.907> .PERIOD If your compilation fails <sil=0.492> ,COMMA then you return to the editing step and correct the errors <sil=0.952> .PERIOD And compile again <sil=0.956> .PERIOD Once compilation process succeeds <sil=0.392> ,COMMA then you can run the program and check whether the output is correct <sil=0.940> .PERIOD If the output is correct <sil=0.328> ,COMMA you are done <sil=0.930> .PERIOD If not <sil=0.638> ,COMMA you go back to the edit process <sil=0.921> .PERIOD So this is why it is known as the edit compile run cycle <sil=0.970> .PERIOD So you edit the program first <sil=0.497> ,COMMA then compile it <sil=0.915> .PERIOD If there are compilation errors <sil=0.415> ,COMMA you go back and edit it again <sil=0.934> .PERIOD Otherwise you run the program <sil=0.977> .PERIOD If the logic is correct <sil=0.563> ,COMMA then you are done <sil=0.973> .PERIOD If your logic is incorrect <sil=0.339> ,COMMA then you go back and make changes to the program <sil=0.978> .PERIOD Compile it and run it again <sil=0.922> .PERIOD So this is the process that we have to follow in the when we are program <sil=0.945> .PERIOD We look at each of these steps one by one <sil=0.982> .PERIOD In editing <sil=0.612> ,COMMA it is typically done in what is known as an editor <sil=0.968> .PERIOD Now editor is a program that lets you create a text file <sil=0.609> ,COMMA make changes to the text file and update the text file and later save it <sil=0.953> .PERIOD So in order to create a program <sil=0.441> ,COMMA pick a particular editor of your choice <sil=0.981> .PERIOD If you are on Linux <sil=0.490> ,COMMA I would recommend a simple editor like G-Edit <sil=0.968> .PERIOD If you are on Windows <sil=0.398> ,COMMA there is a free editor called nodepad++ <sil=0.982> .PERIOD Be careful that this is not the usual nodepad that comes along with the system <sil=0.972> .PERIOD Write your code in an editor of your choice and save it into a file <sil=0.981> .PERIOD Let us call it sample <sil=1.000> .PERIOD c <sil=0.923> .PERIOD Once your code is saved <sil=0.368> ,COMMA you have to compile a program <sil=0.965> .PERIOD Now why do we have to compile a program <sil=0.944> ?QUESTIONMARK Why is this step necessary <sil=0.969> ?QUESTIONMARK The computer does not understand C per C <sil=0.934> .PERIOD It cannot execute a C program or the individual statements in a C language correctly <sil=0.948> .PERIOD For example <sil=0.469> ,COMMA let us say that in C you can write G equal to A percentage B <sil=0.981> .PERIOD The percentage operation stands for modelo <sil=0.918> .PERIOD So this statement says that you take A modelo B and assign it to the variable G <sil=0.967> .PERIOD The microprocessor or the processor in the computer cannot execute this statement because it does not understand this C programming language <sil=0.931> .PERIOD So it translates into an equivalent piece of code consisting of even more basic statements <sil=0.910> .PERIOD For example <sil=0.312> ,COMMA this is just for the purpose of illustration and it is not important that you understand exactly what is going on <sil=0.927> .PERIOD But a statement like G equal to A percentage B can be translated into a bunch of statements saying load data from a particular memory location into a particular register <sil=0.958> .PERIOD Load the second piece of data from another memory location to the second register <sil=0.961> .PERIOD Load the contents of these two registers <sil=0.326> ,COMMA store the remainder in a third register and then finally take the result and store it into a third memory location <sil=0.961> .PERIOD So the simple statement that we wrote G equal to A percentage B or G equal to A modelo B becomes a bunch of basic statements that the microprocessor can understand and then it executes these statements <sil=0.969> .PERIOD So why not a program in the microprocessor language or an assembly language <sil=0.943> ?QUESTIONMARK Writing programs in machine language is very tedious <sil=0.950> .PERIOD One line in a higher programming language like C translates into multiple lines of machine language <sil=0.948> .PERIOD So writing machine language code is very long <sil=0.478> ,COMMA it is very tedious and is particularly prone to errors <sil=0.911> .PERIOD Also they are not portable <sil=0.984> .PERIOD If you write machine code for a particular processor <sil=0.523> ,COMMA let us say you are writing the code for an Intel processor and you translate it into an AMD machine <sil=0.532> ,COMMA it might not work <sil=0.921> .PERIOD Whereas if you take your C code and compile it in another machine <sil=0.637> ,COMMA it will run on that machine <sil=0.976> .PERIOD So compilers work as a bridge <sil=0.921> .PERIOD What they do is take a high level C programming language and translate it into the equivalent machine code <sil=0.997> .PERIOD So think of them as a translator <sil=0.949> .PERIOD So the input is a C program and then you give it to a compiler <sil=0.991> .PERIOD The output of the compiler will be the equivalent machine program for whichever machine you want to run it on <sil=0.967> .PERIOD So compiler is a translator which translates from C to machine code <sil=0.936> .PERIOD How do you compile <sil=0.864> ?QUESTIONMARK We have just seen why we bother with compilation <sil=0.970> .PERIOD And on unique systems or Linux systems <sil=0.499> ,COMMA you can compile the program using the GCC compiler <sil=0.979> .PERIOD So GCC stands for GNUC compiler <sil=0.934> .PERIOD So for example <sil=0.477> ,COMMA if you have edited and saved your file as sample <sil=0.991> .PERIOD c <sil=0.939> ,COMMA you can just type on the command prompt <sil=0.507> ,COMMA on the terminal GCC sample <sil=0.908> .PERIOD c <sil=0.995> .PERIOD If your code does not have any errors <sil=0.312> ,COMMA then the system will silently say that the compilation is done and it will show you the prompt <sil=0.936> .PERIOD If there are errors <sil=0.338> ,COMMA the system will list the errors and so you can go back to the editor <sil=0.529> ,COMMA edit your code to correct the errors and come back and compile again <sil=0.964> .PERIOD As long as there are compilation errors <sil=0.404> ,COMMA there will be no executable file created <sil=0.994> .PERIOD So the executable file is the code <sil=0.337> ,COMMA the file that you can finally run <sil=0.924> .PERIOD And if there are compilation errors <sil=0.351> ,COMMA the compiler will not produce executable code <sil=0.933> .PERIOD So name your file as whatever you want <sil=0.972> .PERIOD Let us call it your file name <sil=0.902> .PERIOD c <sil=0.941> .PERIOD And then GCC your file name <sil=0.938> .PERIOD c <sil=0.966> ,COMMA it will produce the executable file <sil=0.949> .PERIOD If you are on Linux <sil=0.551> ,COMMA the executable file that it creates is something called a <sil=0.909> .PERIOD out <sil=0.980> .PERIOD If there are no errors and you look at your directory <sil=0.540> ,COMMA there will be a new file called a <sil=0.911> .PERIOD out in your directory <sil=0.906> .PERIOD We will explain the directory structures in another session <sil=0.991> .PERIOD Let us look at a very simple c program <sil=0.992> .PERIOD Open your editor <sil=0.612> ,COMMA depending on which system you are in <sil=0.977> .PERIOD So let us write a very simple program <sil=0.958> .PERIOD It is very short <sil=0.931> .PERIOD What it has is are three lines of code and some punctuation <sil=0.931> .PERIOD This is known as the c syntax <sil=0.991> .PERIOD Let us examine this code <sil=0.961> .PERIOD What this code does is it prints a particular message <sil=0.392> ,COMMA which is welcome to c <sil=0.990> .PERIOD It has various components <sil=0.904> .PERIOD You type it into an editor as it is <sil=0.958> .PERIOD Make no punctuation mistakes syntax errors <sil=0.939> .PERIOD Now if you compile the program and you have typed the program correctly <sil=0.440> ,COMMA then a new file called a <sil=0.931> .PERIOD out <sil=0.969> .PERIOD out will be created <sil=0.980> .PERIOD So if you type gcc sample <sil=0.982> .PERIOD c and if there are no errors <sil=0.493> ,COMMA it will just say nothing <sil=0.907> .PERIOD If it says something <sil=0.580> ,COMMA then there is a compilation error <sil=0.972> .PERIOD Compilation creates an executable a <sil=0.912> .PERIOD out <sil=0.910> .PERIOD And now you can run the program by typing and this is important <sil=0.992> .PERIOD forwardslash a <sil=0.985> .PERIOD out <sil=0.955> .PERIOD So the syntax is important <sil=0.963> .PERIOD What you type is <sil=0.915> .PERIOD forwardslash a <sil=0.919> .PERIOD out <sil=0.995> .PERIOD And then when you run the program <sil=0.318> ,COMMA it will say welcome to c <sil=0.990> .PERIOD Because that is what the program is supposed to do <sil=0.977> .PERIOD Let us look at the program a little more carefully <sil=0.982> .PERIOD What are its components <sil=0.887> ?QUESTIONMARK It had three lines <sil=0.905> .PERIOD The first line said hash include stdi <sil=0.923> .PERIOD au <sil=0.960> .PERIOD So it has multiple components <sil=0.931> .PERIOD One is the first symbol which is hash <sil=0.917> .PERIOD The first symbol which is a hash <sil=0.449> ,COMMA please do not forget to include that <sil=0.910> .PERIOD And actually there is no space between the hash and the first i <sil=0.984> .PERIOD So there is no space here <sil=0.965> .PERIOD So hash include stdi <sil=0.996> .PERIOD au <sil=0.981> .PERIOD That is this line is supposed to tell c that please include the standard input output library <sil=0.966> .PERIOD The standard input output library is what has the print routines which will print output messages on to the terminal <sil=0.937> .PERIOD So if you want to have any input output component of your program <sil=0.545> ,COMMA then you should include stdi <sil=0.905> .PERIOD au <sil=0.941> .PERIOD  <sil=0.987> .PERIOD Include this line routinely in the first line of your c file <sil=0.975> .PERIOD Because in the course of this class <sil=0.342> ,COMMA we will often need scan of and print of statements <sil=0.953> .PERIOD So we will often need input statements and output statements <sil=0.943> .PERIOD So include this by default <sil=0.928> .PERIOD Now if you look at the second line <sil=0.481> ,COMMA we will have a function called main and again note the parenthesis here that is also part of this syntax <sil=0.923> .PERIOD So main is supposed to be a function <sil=0.900> .PERIOD All c programs start by executing the main function and it starts from the first statement of the main function <sil=0.958> .PERIOD Now what does the main function have <sil=0.994> ?QUESTIONMARK It has a single line which says printf welcome to c <sil=0.919> .PERIOD So printf is the function called to output from a c program <sil=0.955> .PERIOD So to print a particular message <sil=0.376> ,COMMA you enclose it in double codes <sil=0.978> .PERIOD So whatever is enclosed in the double codes will be printed <sil=0.904> .PERIOD So to repeat again <sil=0.389> ,COMMA please note the extra punctuation symbols which tell you that these are valid c statements <sil=0.995> .PERIOD So all the underlying statements are <sil=0.331> ,COMMA all the underlying symbols are important <sil=0.905> .PERIOD So in the line printf welcome to c <sil=0.572> ,COMMA this is what is known as a statement in c and statements in c and in a semicolon <sil=0.944> .PERIOD So this semicolon is also important because it tells you that this is where the statement ends <sil=0.993> .PERIOD So typical errors do we have when we code in c <sil=0.903> .PERIOD Let's systematically enumerate a few common errors that could happen in even a simple program like what we have seen <sil=0.995> .PERIOD For example <sil=0.379> ,COMMA you could forget to include a stda of dot h <sil=0.968> .PERIOD If you do not include the standard input library <sil=0.477> ,COMMA then the compiler will give you an error message <sil=0.926> .PERIOD You may forget to include the main function <sil=0.578> ,COMMA then also you will get some error message <sil=0.937> .PERIOD You could forget to include the semicolon in the statement <sil=0.999> .PERIOD You could forget to include the braces <sil=0.565> ,COMMA the curly braces in main or forget to close the double code <sil=0.557> ,COMMA open or close the double code in the printf statement <sil=0.972> .PERIOD So these are a few errors that you could make even in a simple code like what we have seen <sil=0.910> .PERIOD We have only three lines but they could also have errors <sil=0.972> .PERIOD I would advise you to try deliberately making these mistakes in your code <sil=0.530> ,COMMA try compiling them and study the error messages <sil=0.989> .PERIOD Once you are familiar with the error messages <sil=0.390> ,COMMA this will help you later in your coding because when you see the error messages <sil=0.437> ,COMMA you can guess what errors did you possibly make in your code <sil=0.939> .PERIOD So go back to the code and correct it <sil=0.965> .PERIOD So <sil=0.439> ,COMMA in this session we will continue the program that we were writing <sil=0.520> ,COMMA recall that we were writing a while loop which will read a bunch of numbers and is supposed to sum them up until you hit a minus 1 <sil=0.955> .PERIOD In the loop that we have seen so far we just read the numbers until a minus 1 was encountered <sil=0.928> .PERIOD So <sil=0.559> ,COMMA let us now complete the program and compute their sum as well <sil=0.957> .PERIOD So <sil=0.432> ,COMMA for computing their sum how do we normally do it we will add numbers 2 at a time <sil=0.944> .PERIOD So <sil=0.314> ,COMMA the first two numbers will be added then that sum will be added to the third number and so on until you hit a minus 1 <sil=0.940> .PERIOD So <sil=0.517> ,COMMA let us try to do that in the course of a while loop what I will declare is I will declare a new variable s <sil=0.973> .PERIOD So <sil=0.390> ,COMMA here is the new variable s that I have declared s is supposed to hold the sum of the variables that I have read so far <sil=0.916> .PERIOD Now <sil=0.587> ,COMMA it is very important that when you declare a variable you should initialize them properly <sil=0.907> .PERIOD In the case of a we did not initialize it because we were reading the first number as soon as a was declared <sil=0.934> .PERIOD But in the case of a sum you would start to you would use s to maintain the sum as you read numbers <sil=0.947> .PERIOD So <sil=0.643> ,COMMA it is important that you start with s equal to 0 <sil=0.913> .PERIOD So <sil=0.519> ,COMMA the initialization step marked by this arrow is quite important <sil=0.918> .PERIOD If you do not initialize it properly then the sum may not be correct as we will see so <sil=0.991> .PERIOD So <sil=0.452> ,COMMA you keep a variable s which is supposed to hold the sum of n numbers sum of these numbers and initialize the sum to 0 <sil=0.911> .PERIOD Then the difference from the loop that we have seen so far is highlighted in red <sil=0.959> .PERIOD So <sil=0.324> ,COMMA earlier recall that we were reading the number and just testing whether the number is minus 1 <sil=0.910> .PERIOD If it was not minus 1 you read one more number <sil=0.944> .PERIOD So <sil=0.508> ,COMMA that was the loop <sil=0.964> .PERIOD Now <sil=0.638> ,COMMA inside the loop what we will do is we will keep a running sum of the numbers that we have seen so far <sil=0.990> .PERIOD So <sil=0.521> ,COMMA initially s sum is initialize to 0 <sil=0.979> .PERIOD Then if the first number is not minus 1 you add the first number to s <sil=0.979> .PERIOD So <sil=0.425> ,COMMA s will now be the first number <sil=0.905> .PERIOD Now <sil=0.517> ,COMMA read the second number <sil=0.921> .PERIOD If the second number is not minus 1 you will enter the loop again <sil=0.998> .PERIOD So <sil=0.434> ,COMMA you will add the second number to s <sil=0.945> .PERIOD So <sil=0.562> ,COMMA s is now first number plus second number and this keeps on going until you hit a minus 1 in the input <sil=0.905> .PERIOD So <sil=0.535> ,COMMA let us continue with this <sil=0.984> .PERIOD Let us try to trace the execution of this program on a sample input and try to understand how it works <sil=0.963> .PERIOD Let us see that I compile the program successfully and run the program <sil=0.922> .PERIOD So <sil=0.410> ,COMMA I run a dot out and let us as before let us the first number be 4 <sil=0.987> .PERIOD So <sil=0.359> ,COMMA after initialization a when you declare the variable a is undefined and s is also undefined after the initial statement s equal to 0 s is now 0 and then you scan the variable a <sil=0.942> .PERIOD So <sil=0.378> ,COMMA a becomes 4 because 4 was the input and some is still 0 <sil=0.956> .PERIOD You enter the loop and you say s equal to s plus a <sil=0.982> .PERIOD So <sil=0.596> ,COMMA some become 0 plus 4 which is 4 and you read the next number <sil=0.922> .PERIOD Let us say the next number was 15 <sil=0.927> .PERIOD So <sil=0.344> ,COMMA a becomes 15 a is not minus 1 <sil=0.905> .PERIOD Therefore <sil=0.603> ,COMMA you enter the loop again and some is now 4 plus 15 which is 19 <sil=0.979> .PERIOD So <sil=0.473> ,COMMA some at any point of time is some of the numbers that we have read so far <sil=0.921> .PERIOD So <sil=0.589> ,COMMA we have read 4 and 15 <sil=0.907> .PERIOD So <sil=0.344> ,COMMA the sum is 19 <sil=0.998> .PERIOD Now <sil=0.462> ,COMMA you read the next number <sil=0.968> .PERIOD Let us say the next number was minus 5 minus 5 is not minus 1 <sil=0.976> .PERIOD Therefore <sil=0.605> ,COMMA you enter the loop again s equal to s plus minus 5 <sil=0.916> .PERIOD So <sil=0.597> ,COMMA s becomes 14 then you read the next number and let us say the next number was minus 1 <sil=0.947> .PERIOD So <sil=0.381> ,COMMA since the number red is minus 1 you go back to the loop and this condition becomes falls <sil=0.989> .PERIOD So <sil=0.488> ,COMMA you exit out of the loop and then print that the sum is minus 1 <sil=0.951> .PERIOD So <sil=0.456> ,COMMA you have 1 is let us say 14 <sil=0.982> .PERIOD So <sil=0.496> ,COMMA and when you verify it by hand you would see that 4 plus 15 plus minus 5 is 14 <sil=0.985> .PERIOD So <sil=0.324> ,COMMA you have the program has executed correctly <sil=0.969> .PERIOD The important thing to note is that the final minus 1 is not summed up <sil=0.961> .PERIOD So <sil=0.540> ,COMMA that is it is used as the end of the input and you should not compute the sum of the numbers including minus 1 minus 1 is excluded and the program executed correctly <sil=0.994> .PERIOD We will introduce a few terminology associated with the notion of a loop <sil=0.933> .PERIOD Each execution of a loop is known as an iteration <sil=0.917> .PERIOD So <sil=0.350> ,COMMA in the above loop when the input was 4 15 minus 5 minus 1 the loop runs for 3 iterations corresponding to the inputs 4 15 and minus 5 <sil=0.946> .PERIOD So <sil=0.350> ,COMMA for input minus 1 the loop is broken <sil=0.936> .PERIOD So <sil=0.498> ,COMMA you do not enter the loop <sil=0.947> .PERIOD So <sil=0.410> ,COMMA you do not count an iteration corresponding to minus 1 <sil=0.997> .PERIOD So <sil=0.608> ,COMMA you entered 4 numbers including the minus 1 and the loop executed 3 times <sil=0.986> .PERIOD So <sil=0.583> ,COMMA you say that the loop had 3 iterations <sil=0.994> .PERIOD So <sil=0.326> ,COMMA this is a technical term associated with loops and here is a concept that I will introduce to help you argue about the correctness of a loop <sil=0.936> .PERIOD So <sil=0.552> ,COMMA there is a notion known as a loop invariant <sil=0.915> .PERIOD Now <sil=0.303> ,COMMA a loop invariant is a property relating values of the variables that hold at the beginning of each loop <sil=0.991> .PERIOD So <sil=0.612> ,COMMA that is a bit abstract <sil=0.910> .PERIOD Let me just illustrate with the example that we just saw <sil=0.914> .PERIOD So <sil=0.389> ,COMMA loop invariants are a good way of thinking about the correctness of the loops that you have written <sil=0.920> .PERIOD So <sil=0.308> ,COMMA in our program what will be the loop invariant <sil=0.884> ?QUESTIONMARK Let us look at the property of that we are interested in <sil=0.913> .PERIOD There are two variables in the program S and A and both of those variables are involved in the loop <sil=0.991> .PERIOD But the interesting property that we have relates to S <sil=0.944> .PERIOD What is the property that S holds with respect to the loop <sil=0.891> ?QUESTIONMARK So <sil=0.622> ,COMMA we can see that S holds the sum of all values red so far except the last value is that true the first time that we enter the loop <sil=0.948> .PERIOD Remember the loop yes because S was initialized to 0 and you had actually read the number <sil=0.938> .PERIOD So <sil=0.317> ,COMMA it is true that S holds the sum of all values except the first one <sil=0.966> .PERIOD So <sil=0.375> ,COMMA that is true when you first enter the loop and at any point when you enter the loop you sum the last value that was red and read one more number <sil=0.915> .PERIOD So <sil=0.450> ,COMMA you will see that S still holds the sum of all values red so far except the last one <sil=0.901> .PERIOD So <sil=0.341> ,COMMA this is the loop invariant in the program and loop invariants help you argue about the correctness of the loops <sil=0.967> .PERIOD So <sil=0.539> ,COMMA if the loop invariant is correct and the program maintains the loop invariant then the value of S when the program stops will be correct <sil=0.998> .PERIOD Why is that <sil=0.974> ?QUESTIONMARK Because the loop terminates because the last value red was a minus 1 and the invariant says that S holds the sum of all values except the last value <sil=0.937> .PERIOD So <sil=0.533> ,COMMA this means that S holds the sum of all numbers except the minus 1 <sil=0.939> .PERIOD Therefore <sil=0.303> ,COMMA when the program ends that is you exit out of the loop S holds the sum of all numbers that you were supposed to add <sil=0.926> .PERIOD So <sil=0.308> ,COMMA here is how arguing about a loop invariant and seeing whether loop invariant holds in the loop that you have written helps you argue that the program is correct <sil=0.909> .PERIOD So far we have been using wild loops in C <sil=0.947> .PERIOD Now <sil=0.649> ,COMMA C programming language also provides you other kinds of loops <sil=0.986> .PERIOD Let us look at some of them <sil=0.998> .PERIOD The first alternative loop mechanism in C that we will look at is what is known as a do wild loop <sil=0.991> .PERIOD So <sil=0.328> ,COMMA it is a variant of a wild loop and the general form is what you see here <sil=0.943> .PERIOD You have do statement followed by wild expression and here is an important syntactic difference which causes some syntax errors when you code <sil=0.924> .PERIOD The do wild terminates within semicolon whereas <sil=0.486> ,COMMA the wild loop does so the wild loop has the following form which is wild expression and then statement <sil=0.924> .PERIOD The difference is that here the statement is occurring before the wild test expression <sil=0.915> .PERIOD So <sil=0.378> ,COMMA the way it executes is the following <sil=0.977> .PERIOD You first execute the statement then evaluate the expression <sil=0.960> .PERIOD If the expression is true you go back to step one that is execute the statement <sil=0.904> .PERIOD If the expression is false then you get out <sil=0.956> .PERIOD So <sil=0.310> ,COMMA you execute the statement then test whether the expression is true or not <sil=0.915> .PERIOD If it is true you go back and execute the statement again <sil=0.969> .PERIOD So <sil=0.330> ,COMMA you loop if the statement is false you get out of the loop <sil=0.919> .PERIOD The difference from a wild loop and a do wild loop is the following <sil=0.911> .PERIOD You have a statement that will be executed without testing the expression even once <sil=0.908> .PERIOD So <sil=0.322> ,COMMA when you start executing the loop you will first execute the statement without testing the expression and after testing the expression you will go back and test the loop expression if it is true and you start executing the loop again <sil=0.942> .PERIOD So <sil=0.589> ,COMMA the first execution of the statement there is no test done for that <sil=0.937> .PERIOD So <sil=0.631> ,COMMA let us see the comparison between a wild loop and a do wild loop <sil=0.921> .PERIOD So <sil=0.503> ,COMMA we will look at the following problem you have to read numbers and output integer until a minus 1 is seen <sil=0.933> .PERIOD Now <sil=0.621> ,COMMA the difference is that in this problem you have to include the minus 1 <sil=0.952> .PERIOD So <sil=0.311> ,COMMA read all the numbers up to and including minus 1 and print all the numbers <sil=0.974> .PERIOD So <sil=0.496> ,COMMA we will have the following programs using wild loop and do wild loop <sil=0.950> .PERIOD Now <sil=0.632> ,COMMA the important thing to notice is that the wild construct and the do wild construct are equally expressive <sil=0.958> .PERIOD So <sil=0.624> ,COMMA you cannot write any more new programs using the do wild construct than you could using the wild construct <sil=0.921> .PERIOD But <sil=0.442> ,COMMA certain kinds of programs are easier using a shorter using the do wild construct <sil=0.917> .PERIOD For example <sil=0.596> ,COMMA let us solve this problem using the wild construct <sil=0.927> .PERIOD So <sil=0.623> ,COMMA what you do initially is you declare a variable then scan the variable <sil=0.967> .PERIOD If the variable is minus 1 you immediately exit out of the loop and print minus 1 and finish the program <sil=0.965> .PERIOD If the number is not minus 1 you print the value and scan the next number <sil=0.921> .PERIOD If the number you scan this not minus 1 you just print it and repeat the loop <sil=0.968> .PERIOD If it is minus 1 you exit out of the loop and print the minus 1 that you saw <sil=0.968> .PERIOD So <sil=0.567> ,COMMA here is the logic using the do wild loop using the wild loop and notice that when we exit it out of the loop we needed a print up statement and before you enter the loop you needed a scan up statement <sil=0.930> .PERIOD So <sil=0.341> ,COMMA this was the structure of the program <sil=0.919> .PERIOD This problem can be elegantly solved using the do wild loop <sil=0.922> .PERIOD What you initially need to do is you declare a variable then scan the variable and print it anyway <sil=0.991> .PERIOD Either the number is minus 1 or it is not in any case we need to print it <sil=0.972> .PERIOD So <sil=0.370> ,COMMA go ahead and print it then test whether the number was minus 1 <sil=0.910> .PERIOD If it is minus 1 you are done and you exit out of the program <sil=0.909> .PERIOD If it is not minus 1 you go back and scan the next number and print it <sil=0.989> .PERIOD So <sil=0.604> ,COMMA this is a program that we have seen where you could do the same thing with the wild loop <sil=0.943> .PERIOD The only difference is that the do wild program is shorter and please be careful about the syntactic difference between the wild loop and the do wild loop <sil=0.957> .PERIOD Notice the semicolon at the end <sil=0.932> .PERIOD This causes a lot of confusion when you compile the program it is easy to miss this <sil=0.917> .PERIOD If you are new to see programming you can stick to one particular loop as I said before you cannot write any new programs that you can do using the do wild loop then you could previously do using the wild loop <sil=0.986> .PERIOD So <sil=0.458> ,COMMA you can write the same logic you can write the same number of programs using the wild loop and the do wild loop it gives you no further power <sil=0.970> .PERIOD So <sil=0.462> ,COMMA it is recommended that you stick to one loop pick wild or pick do wild whatever you do but stick to that loop in when you write the program <sil=0.949> .PERIOD When you are comfortable with one of the loops programming using the other loop becomes easy <sil=0.954> .PERIOD So <sil=0.499> ,COMMA let us try to solve a problem that we have already seen which is to find the length of the longest continuous increasing subsequence ending in minus 1 <sil=0.969> .PERIOD The difference that we have is that earlier we did not include minus 1 in the sequence when you computed the length of the sequence <sil=0.927> .PERIOD Now we will include minus 1 <sil=0.950> .PERIOD So <sil=0.311> ,COMMA here is the program to do that and the logic the core logic <sil=0.960> .PERIOD So <sil=0.513> ,COMMA here is the initialization and here is the loop logic <sil=0.919> .PERIOD So <sil=0.496> ,COMMA this is the loop logic and the final check <sil=0.928> .PERIOD So <sil=0.484> ,COMMA if you recall from the lecture which covered the problem solving the longest increasing subsequence then you will see that the main structures in the code the main lines of logic in the code are pretty much the same <sil=0.994> .PERIOD All I have done is to change the wild logic to the do wild logic and let us see what that has accomplished for us <sil=0.938> .PERIOD So <sil=0.307> ,COMMA what this does is that you will scan a particular number if the particular number is bigger than the previous number then you extend the sequence <sil=0.938> .PERIOD If it is less than or equal to the previous number then you stop the sequence and start a new sequence this was the logic and when you start a new sequence the length is you start with 1 <sil=0.995> .PERIOD Then you say current equal to the next number and previous equal to the number that was just read <sil=0.973> .PERIOD So <sil=0.510> ,COMMA the logic here is that the testing for whether the currently read number is minus 1 is done at the end of the loop <sil=0.947> .PERIOD So <sil=0.631> ,COMMA if the first number is minus 1 you just do all this and then say that the length of the increasing subsequence is 1 and then you test if the currently read number is minus 1 or not <sil=0.962> .PERIOD If the currently read number is minus 1 then you are already done and you exit out of the loop then you check whether max length is less than length as before <sil=0.921> .PERIOD The difference between this logic and the logic that we have seen before is that we do this execution without testing whether the currently read number is minus 1 <sil=0.990> .PERIOD So <sil=0.483> ,COMMA automatically what happens is that if the number is minus 1 all these steps will be performed before we test that the sequence has ended <sil=0.954> .PERIOD So <sil=0.480> ,COMMA automatically we ensure that minus 1 is also included when we calculate the increasing subsequence <sil=0.908> .PERIOD Let us do a sample program using continuous statements <sil=0.915> .PERIOD I will introduce the problem initially <sil=0.954> .PERIOD The problem is that of finding Pythagorean triples <sil=0.917> .PERIOD By the way Pythagorean triples are numbers like a triplets of numbers like 3 <sil=0.563> ,COMMA 4 and 5 because you know that 3 square plus 4 square equal to 5 square <sil=0.933> .PERIOD So <sil=0.409> ,COMMA they are Pythagorean triples because there can be a right triangle where let us say the base is 3 <sil=0.619> ,COMMA the altitude is 4 and the hypotenuse is 5 <sil=0.909> .PERIOD So <sil=0.518> ,COMMA 3 <sil=0.581> ,COMMA 4 and 5 could be the sides of a right triangle because they satisfy the Pythagorean identity <sil=0.935> .PERIOD So <sil=0.492> ,COMMA here is our problem <sil=0.943> .PERIOD We are given a stream of numbers and let us say there are n numbers <sil=0.967> .PERIOD So <sil=0.624> ,COMMA the initial number says how many other numbers there are <sil=0.952> .PERIOD So <sil=0.409> ,COMMA 8 says that there are 8 numbers to process <sil=0.979> .PERIOD After you read n <sil=0.361> ,COMMA n is greater than or equal to 2 <sil=0.524> ,COMMA you have to read n integers and then you have to identify Pythagorean triplets occurring consecutively <sil=0.921> .PERIOD By consecutively we will say that consecutive positive integers because in the middle there could be negative numbers <sil=0.944> .PERIOD You have to just ignore them <sil=0.973> .PERIOD For example <sil=0.603> ,COMMA you have that 3 <sil=0.627> ,COMMA 4 and 5 are consecutive positive entries in this data because minus 3 <sil=0.307> ,COMMA minus 4 and minus 5 are negative numbers <sil=0.984> .PERIOD So <sil=0.368> ,COMMA consecutive in this context need not mean that they occur together <sil=0.949> .PERIOD It just means that if you ignore the negative numbers in between then they are together <sil=0.963> .PERIOD So <sil=0.522> ,COMMA we have to identify all such Pythagorean triplets <sil=0.902> .PERIOD So <sil=0.365> ,COMMA in this case the Pythagorean triple in the input sequence is 3 <sil=0.506> ,COMMA 4 and 5 <sil=0.909> .PERIOD So <sil=0.600> ,COMMA let us try to code it up <sil=0.923> .PERIOD I hope you see how it can be done <sil=0.904> .PERIOD So <sil=0.449> ,COMMA let us try to do it by hand <sil=0.938> .PERIOD So <sil=0.649> ,COMMA let us say that I have and then some negative numbers in between and so on <sil=0.910> .PERIOD So <sil=0.432> ,COMMA some positive numbers <sil=0.495> ,COMMA some negative numbers in between <sil=0.955> .PERIOD Let us say that I have and then some negative numbers in between and so on <sil=0.945> .PERIOD So <sil=0.522> ,COMMA some positive numbers <sil=0.587> ,COMMA some negative numbers in between <sil=0.908> .PERIOD Till I find so I have let us say 4 <sil=0.488> ,COMMA 6 numbers <sil=0.968> .PERIOD So <sil=0.408> ,COMMA the input is of the following form <sil=0.990> .PERIOD What I need to do is at any point I may have to remember some triple <sil=0.929> .PERIOD So <sil=0.526> ,COMMA for example <sil=0.437> ,COMMA the first triple that I will find is the following <sil=0.937> .PERIOD So <sil=0.459> ,COMMA this is the first number <sil=0.470> ,COMMA this is the second number and this is the third number <sil=0.921> .PERIOD And this is the third number and what I have to do is to check with the first square plus second square equal to third square <sil=0.967> .PERIOD So <sil=0.578> ,COMMA this is what I have to check <sil=0.948> .PERIOD Now suppose that 1 <sil=0.402> ,COMMA 3 and 4 are not it Pythagorean triple <sil=0.995> .PERIOD They are not because 1 square plus 3 square is not 4 square <sil=0.953> .PERIOD Then what do you have to do <sil=0.952> ?QUESTIONMARK You have to advance all these first second and third variables <sil=0.901> .PERIOD So <sil=0.537> ,COMMA let us try to advance the third variable <sil=0.918> .PERIOD The next interesting number is 5 because that is the next positive number <sil=0.989> .PERIOD So <sil=0.337> ,COMMA the next iteration should check for the following <sil=0.985> .PERIOD This should be the third number <sil=0.976> .PERIOD 4 should be the second number <sil=0.938> .PERIOD And 3 should be the first number <sil=0.992> .PERIOD If you do that then you know that 3 square plus 4 square equal to 5 square and you will identify a Pythagorean triple <sil=0.993> .PERIOD So <sil=0.440> ,COMMA what we do is that we have to shift all these variables first <sil=0.563> ,COMMA second and third by 1 positive entry <sil=0.935> .PERIOD So <sil=0.567> ,COMMA this is what we have to do <sil=0.982> .PERIOD We have to remember 3 numbers <sil=0.947> .PERIOD The current number that we have seen the previous number <sil=0.379> ,COMMA previous positive number that we have seen and the previous to previous positive number that we have seen <sil=0.995> .PERIOD So <sil=0.626> ,COMMA this is one situation where you need to remember 3 variables <sil=0.982> .PERIOD And once you check whether the current triplet satisfies it <sil=0.533> ,COMMA if you satisfy it fine <sil=0.615> ,COMMA if you do not satisfy it you have to advance the variables by 1 <sil=0.971> .PERIOD So <sil=0.408> ,COMMA first we will take over second <sil=0.415> ,COMMA second we will take over third and third we will go to the next positive number <sil=0.954> .PERIOD So <sil=0.303> ,COMMA this is the method of programming this <sil=0.991> .PERIOD Let us try to code this up <sil=0.909> .PERIOD So <sil=0.388> ,COMMA we will write the code as follows <sil=0.913> .PERIOD We need 3 variables <sil=0.605> ,COMMA the current number <sil=0.479> ,COMMA the code as follows <sil=0.925> .PERIOD We need 3 variables <sil=0.646> ,COMMA the current number <sil=0.517> ,COMMA the previous number and the previous to previous number <sil=0.976> .PERIOD Currently we will leave all of them undefined <sil=0.904> .PERIOD N is the number of integers to read <sil=0.912> .PERIOD I is we will eventually write a loop <sil=0.939> .PERIOD So <sil=0.571> ,COMMA for the for loop we need to count it <sil=0.917> .PERIOD So <sil=0.330> ,COMMA I will basically count from 1 to n to ensure that n numbers have been read <sil=0.931> .PERIOD I will also have an extra variable called count <sil=0.916> .PERIOD I is supposed to count the number of numbers seen so far and count will count the positive numbers seen so far <sil=0.954> .PERIOD So <sil=0.472> ,COMMA I need 2 of them in this code <sil=0.999> .PERIOD I may need them <sil=0.975> .PERIOD Now <sil=0.639> ,COMMA after you do that you scan the n which tells you how many numbers are there in the input <sil=0.928> .PERIOD Now <sil=0.346> ,COMMA a for loop has to go here which will do most of the work in the code <sil=0.962> .PERIOD So <sil=0.329> ,COMMA let us see what that loop looks like <sil=0.919> .PERIOD So <sil=0.602> ,COMMA recall what we did by hand you will look at a you will look at the current number which is the next number to read <sil=0.945> .PERIOD If the next number is 0 or less than 0 you say continue <sil=0.988> .PERIOD So <sil=0.640> ,COMMA this is the application of the continuous statement here <sil=0.909> .PERIOD So <sil=0.532> ,COMMA if says if the current number is not positive you just go on to the next iteration of the loop <sil=0.945> .PERIOD Now <sil=0.583> ,COMMA here is some logic which is not easy to read but we can motivate it the following <sil=0.983> .PERIOD If the current number that I have seen is the first positive number then obviously that cannot they then this was the first number that I read <sil=0.914> .PERIOD Therefore <sil=0.494> ,COMMA there was no previous number and there was no previous to previous number <sil=0.967> .PERIOD So <sil=0.518> ,COMMA I will because this is the first positive number that I am reading then I will just said that the previous to previous number is the current number <sil=0.901> .PERIOD Also I have seen one positive number <sil=0.941> .PERIOD So <sil=0.371> ,COMMA I will say increment count equal to 1 <sil=0.903> .PERIOD So <sil=0.494> ,COMMA if I have seen if the current number that I have seen is positive and it is not the first positive number that means if count equal to 1 I have already seen at least I have already seen one positive number <sil=0.943> .PERIOD Then what you do is you know that there is a previous to previous number you set the previous number to the current number and you continue the loop setting that count equal to 2 which says that I have seen two positive numbers <sil=0.933> .PERIOD So <sil=0.519> ,COMMA I have a previous to previous number and I have a previous number now I will read the next number <sil=0.965> .PERIOD This is because in order to identify a triple you need at least three numbers <sil=0.973> .PERIOD So <sil=0.600> ,COMMA previous to previous and previous should already be to some positive values in the input <sil=0.913> .PERIOD This is why we initially said that we need at least two inputs <sil=0.964> .PERIOD So <sil=0.336> ,COMMA we will go back to the loop if count equal to 1 otherwise let us say that count is at least two <sil=0.939> .PERIOD So <sil=0.371> ,COMMA it is two or more <sil=0.905> .PERIOD So <sil=0.576> ,COMMA in this case we will just say that as far as count is concerned I do not need to keep track of how many positive numbers are needed <sil=0.951> .PERIOD It was used only to see that I have at least two positive numbers to begin with <sil=0.924> .PERIOD So <sil=0.446> ,COMMA I can add the next number as the possible third number in the triple <sil=0.993> .PERIOD So <sil=0.540> ,COMMA I will not update count from now on you can also do that but counts afterwards serves no purpose <sil=0.930> .PERIOD So <sil=0.343> ,COMMA I will say that count is two and I will just adopt the convention that it will remain two <sil=0.967> .PERIOD So <sil=0.610> ,COMMA I have seen at least two positive numbers <sil=0.995> .PERIOD Now <sil=0.480> ,COMMA I have also a third number in the current so you have previous to previous and you have current <sil=0.909> .PERIOD So <sil=0.539> ,COMMA these are the three numbers that you have <sil=0.908> .PERIOD So <sil=0.382> ,COMMA what you have to check is whether previous to previous squared plus previous squared equal to current squared <sil=0.901> .PERIOD So <sil=0.622> ,COMMA that is what we will say <sil=0.986> .PERIOD So <sil=0.415> ,COMMA this is the check <sil=0.951> .PERIOD We will check whether previous to previous squared plus previous squared is equal to current squared <sil=0.993> .PERIOD If that is true then you have found the Pythagorean triple <sil=0.977> .PERIOD So <sil=0.337> ,COMMA you will just say that I will print f that I have found the Pythagorean triple which is formed by previous to previous previous previous and current <sil=0.911> .PERIOD Now <sil=0.359> ,COMMA what I will do if the Pythagorean triple is found is that I will advance previous to previous by one <sil=0.995> .PERIOD So <sil=0.578> ,COMMA previous to previous will become previous previous will become current <sil=0.903> .PERIOD So <sil=0.645> ,COMMA recall the figure that I first true and then we will go back to the loop <sil=0.904> .PERIOD So <sil=0.572> ,COMMA this is the code for identifying the Pythagorean triple and it encodes exactly the logic that we did by hand <sil=0.952> .PERIOD So <sil=0.323> ,COMMA here is the stuff that we have seen about pointers <sil=0.959> .PERIOD First we have defined what is a pointer <sil=0.461> ,COMMA a pointer is just a variable that holds the address of another variable <sil=0.952> .PERIOD We say that pointer points to another variable and depending on what variable it points to the type of that target <sil=0.375> ,COMMA we say it is an in pointer or a character pointer or a float pointer and so on <sil=0.908> .PERIOD So <sil=0.534> ,COMMA this is the first thing what is a pointer and then we have seen what all can you do with a pointer <sil=0.351> ,COMMA what are the operations that you can do in a pointer <sil=0.915> .PERIOD So <sil=0.338> ,COMMA if you have a normal variable you can take the address of that variable using the and operator <sil=0.958> .PERIOD If you have a pointer then you can de-reference the pointer by using star of ptr that will go to the location pointer to by ptr and take the value of that target <sil=0.982> .PERIOD Further we have seen pointer arithmetic involving plus and minus and I have introduced you with the caution that they are meant to navigate within arrays <sil=0.918> .PERIOD They are not meant to navigate to arbitrary locations in the memory <sil=0.971> .PERIOD If you do that it may or may not work <sil=0.966> .PERIOD And further we have touched upon the intimate relationship between arrays and pointers in C as captured by the formula array of i is star of array plus i <sil=0.977> .PERIOD A special case of this is to say that the name of the array is an address of the first entry in the array <sil=0.901> .PERIOD For example array of 0 is the same as star of array plus 0 <sil=0.929> .PERIOD We have seen this and think about them once more to get comfortable with the notion <sil=0.952> .PERIOD In this video we will talk about how pointers interact with functions <sil=0.964> .PERIOD When we introduced arrays we first said here are arrays here is how you write programs with arrays and then we introduced here is how you pass arrays into functions <sil=0.934> .PERIOD Let us do that the same thing with pointers <sil=0.959> .PERIOD So <sil=0.555> ,COMMA here are pointers and how do you pass them to pointers <sil=0.995> .PERIOD Before coming into how do you pass them to pointers we will go into why should you pass pointers to functions <sil=0.956> .PERIOD So <sil=0.423> ,COMMA let me introduce this with a very standard example this is a classic example in C how do you exchange two variables <sil=0.953> .PERIOD We have seen the three way exchange where I said that if you have B rooms A B I have two full rooms A and B and then I want to exchange the contents of these rooms then I can use a third room first move the contents of A to T that is your first move then move the contents of B to A that is your second move and then afterwards A now contains the contents of B and B is empty T is containing the contents of A <sil=0.936> .PERIOD So <sil=0.582> ,COMMA the third move is move T to B <sil=0.928> .PERIOD So <sil=0.621> ,COMMA the net effect will be that B contains the old contents of A contains the old contents of A and T is empty <sil=0.969> .PERIOD So <sil=0.482> ,COMMA this was the three way exchange which we did within main function this is long back when we discussed GCD algorithm <sil=0.954> .PERIOD Now <sil=0.572> ,COMMA let us try to do that using a function <sil=0.933> .PERIOD So <sil=0.333> ,COMMA I have a swap routine which takes two integer arguments A and B and it is meant to exchange the values of A and B <sil=0.934> .PERIOD So <sil=0.632> ,COMMA inside main I have A equal to 1 B equal to 2 and I call A and swap A and B and swap A and B what it does is this three way exchange that we have just discussed <sil=0.964> .PERIOD Now <sil=0.471> ,COMMA just to test whether things are working I have bunch of print of statements which says what is the value of swap what is the value of A and B after swap has executed <sil=0.941> .PERIOD Similarly <sil=0.402> ,COMMA when I come back I will just print the values of A and B to see what has happened after swap <sil=0.933> .PERIOD So <sil=0.309> ,COMMA when you call swap and you output it within swap it is very clear that A equal to 2 B equal to 1 <sil=0.989> .PERIOD So <sil=0.396> ,COMMA this the three way exchange would work as you expect and you have whatever was passed which is swap 1 to <sil=0.999> .PERIOD So <sil=0.613> ,COMMA it will exchange those variables and it will print A equal to 2 and B equal to 1 <sil=0.994> .PERIOD Now <sil=0.369> ,COMMA within main A was 1 and B is 2 <sil=0.953> .PERIOD Now <sil=0.307> ,COMMA when you print these statements inside main surprisingly you will find that A equal to 1 and B equal to 2 <sil=0.907> .PERIOD So <sil=0.355> ,COMMA the effect of swap has is completely absent when you come back to main swap within swap they were exchanged but when you come back to main they were not exchanged <sil=0.969> .PERIOD Now <sil=0.303> ,COMMA why does this happen this is because remember that some space is allocated to a function and whatever space is allocated to the swap function all the variables there is erased are erased once you return from the swap function <sil=0.954> .PERIOD So <sil=0.515> ,COMMA within swap function A and B are exchanged but all that is gone when you return to main <sil=0.903> .PERIOD So <sil=0.531> ,COMMA passing integer float character variables as parameters does not allow passing back to the calling function <sil=0.951> .PERIOD You have only the return value to return back any changes made within the called function are lost once this function returns <sil=0.975> .PERIOD So <sil=0.585> ,COMMA the question is can we now make a new function such that work done within that function will be reflected back in main <sil=0.934> .PERIOD Now <sil=0.375> ,COMMA here is an intermediate solution we know that if we pass a erase then work done in the called function will be reflected back in the calling function <sil=0.956> .PERIOD So <sil=0.646> ,COMMA you could think of the following intermediate function <sil=0.930> .PERIOD So <sil=0.441> ,COMMA if I have int num 2 and then I say that num 0 is 1 num 1 is 2 <sil=0.944> .PERIOD So <sil=0.423> ,COMMA this is the function of num 2 <sil=0.949> .PERIOD This is in the main function and then I call swap of num or we will call it swap 1 of num I have a new function <sil=0.960> .PERIOD Now <sil=0.383> ,COMMA what swap 1 does is so int swap 1 int error is 1 <sil=0.938> .PERIOD So <sil=0.481> ,COMMA suppose I have this function inside that I will just say that I will have an intermediate variable t and then have t equal to num or error 0 then error 0 equal to t error 0 equal to 1 and error 1 equal to t <sil=0.936> .PERIOD Suppose I have this function and now you can sort of argue that this will also swap the two cells in the num array <sil=0.996> .PERIOD So <sil=0.342> ,COMMA the dirty trick that I am doing is that I want to swap two variables instead I will say that instead of these two variables I will insert them into a array of size 2 and then call swap 1 on that array <sil=0.990> .PERIOD Now <sil=0.488> ,COMMA what I will do is I will do this <sil=0.913> .PERIOD So <sil=0.320> ,COMMA I will do this in the name of the array and then I will do this in the name of the array <sil=0.909> .PERIOD So <sil=0.569> ,COMMA I will do this in the name of the array and then call swap 1 on that array <sil=0.988> .PERIOD Now <sil=0.443> ,COMMA what swap 1 does is it will it will exchange it will do the 3 way exchange on the array <sil=0.908> .PERIOD Now <sil=0.330> ,COMMA I know that because of the way arrays are passed in C any change that happens to the array error inside swap 1 will be reflected back in main <sil=0.955> .PERIOD So <sil=0.625> ,COMMA when I print this num array back in main I would see that num 0 is now 2 and num 1 is 1 <sil=0.944> .PERIOD So <sil=0.523> ,COMMA this is a intermediate trick in order to write the correct swap function <sil=0.312> ,COMMA but you will agree that this is a kind of a dirty trick because in order to swap two variables I created an array and then dependent on the fact that swap will change array in such a way that the change will be reflected back in main <sil=0.971> .PERIOD So <sil=0.564> ,COMMA is there a nicer way to do it that is what we are interested in and the answer is let us just think about that array trick what we did was when we passed an array we were passing the address of the array <sil=0.920> .PERIOD This is how arrays are passed to functions <sil=0.918> .PERIOD So <sil=0.359> ,COMMA now let us just take that idea that we are passing the address <sil=0.958> .PERIOD So <sil=0.637> ,COMMA let us try to write a swap function where you are passing address of variables instead of the variables themselves <sil=0.900> .PERIOD So <sil=0.471> ,COMMA here is the correct swap function and what I write is void swap <sil=0.970> .PERIOD So <sil=0.390> ,COMMA void is a new keyword that you will see <sil=0.311> ,COMMA but it is not a big deal is just a function that does not return a value it just performs an action without returning a value <sil=0.997> .PERIOD So <sil=0.301> ,COMMA such functions you can write it as void swap in star p <sil=0.529> ,COMMA t array in star p <sil=0.459> ,COMMA t array so p <sil=0.332> ,COMMA t array and p <sil=0.565> ,COMMA t array are pointers <sil=0.924> .PERIOD Now <sil=0.570> ,COMMA inside the code you have something that looks like a 3 way exchange it is very carefully written because the obvious way to code the function is not right <sil=0.949> .PERIOD So <sil=0.634> ,COMMA you have to be slightly careful you have to declare an integer variable <sil=0.915> .PERIOD Now <sil=0.473> ,COMMA t contains star p <sil=0.571> ,COMMA t array star p <sil=0.528> ,COMMA t array equal to star p <sil=0.331> ,COMMA t array and star p <sil=0.593> ,COMMA t array be equal to t <sil=0.974> .PERIOD The obvious way to write it seems to be you declare an integer star p <sil=0.407> ,COMMA t array and then do this it is not quite right we will come to that later <sil=0.945> .PERIOD So <sil=0.382> ,COMMA here is the swap function and how do you call the function you declare two integer variables in main a equal to 1 and b equal to 2 and then pass the addresses using and a and and b <sil=0.980> .PERIOD So <sil=0.448> ,COMMA let us just trace the function you have two variables in main a equal to 1 <sil=0.574> ,COMMA b equal to 2 and call swap of address a and address b <sil=0.981> .PERIOD Now <sil=0.577> ,COMMA just to denote that these are addresses I will say that these are a is situated at location 1024 in hexadecimal <sil=0.933> .PERIOD So <sil=0.475> ,COMMA this is some location in memory hexadecimal 1024 and this is some other location in memory b is say at hexadecimal location 2000 <sil=0.999> .PERIOD Now <sil=0.485> ,COMMA do not be distracted by the hexadecimal notation if you are uncomfortable with it just write 1024 in equal equivalent in a in an equal and decimal notation and you can say that it is at that location <sil=0.922> .PERIOD So <sil=0.569> ,COMMA it is at that location and I am representing the location in hexadecimal because it leads to shorter addresses and this is also an address <sil=0.987> .PERIOD So <sil=0.382> ,COMMA when I take address of a I will get 1024 hex in when I take the address of b I will get 2000 hex <sil=0.939> .PERIOD So <sil=0.451> ,COMMA this is the address of a and it is located at memory location 1024 when represented in the hexadecimal notation <sil=0.955> .PERIOD What happens when you call the swap function <sil=0.996> ?QUESTIONMARK So <sil=0.557> ,COMMA here is the state of mean and when you call the swap function a new bunch of memory a new block of memory is allocated on the stack <sil=0.938> .PERIOD So <sil=0.569> ,COMMA first the formal parameters are copied their values from the actual parameters <sil=0.920> .PERIOD So <sil=0.535> ,COMMA PTRA will get AND A which is 1024 PTRB will get AND B which is 2000 <sil=0.953> .PERIOD Now <sil=0.370> ,COMMA I declare a new variable T T equal to star PTRA <sil=0.980> .PERIOD So <sil=0.584> ,COMMA what does that mean <sil=0.908> ?QUESTIONMARK PTRA is an address D reference address which means go look up that address <sil=0.922> .PERIOD So <sil=0.446> ,COMMA it will go to this location and get that value <sil=0.979> .PERIOD So <sil=0.431> ,COMMA T will now become 1 and the next statement is somewhat mysterious <sil=0.948> .PERIOD Please understand it very slowly <sil=0.920> .PERIOD So <sil=0.629> ,COMMA on the right hand side you have star PTRB this means D reference PTRB <sil=0.940> .PERIOD So <sil=0.381> ,COMMA we are saying PTRB is address 2000 when you D reference it you will get the value 2 <sil=0.922> .PERIOD Now <sil=0.517> ,COMMA where do I have to store that value 2 for that D reference PTRA <sil=0.867> ?QUESTIONMARK So <sil=0.441> ,COMMA 1024 D reference it you will go to this box that is where you have to store 2 <sil=0.969> .PERIOD So <sil=0.410> ,COMMA 2 will go to that location <sil=0.951> .PERIOD So <sil=0.418> ,COMMA what has happened due to that is that A in main has now changed <sil=0.996> .PERIOD Why <sil=0.913> ?QUESTIONMARK Because within the swap function we were dealing with pointers <sil=0.949> .PERIOD So <sil=0.359> ,COMMA as a result of the statement star PTRA equal to star PTRB it has taken 2 from the main functions B and put it back into the main functions A and that was accomplished through variables inside swap <sil=0.993> .PERIOD So <sil=0.501> ,COMMA think about it for a while <sil=0.989> .PERIOD And the last statement of course <sil=0.406> ,COMMA is star PTRB equal to T <sil=0.979> .PERIOD So <sil=0.524> ,COMMA D reference PTRB and put the value 1 there <sil=0.964> .PERIOD So <sil=0.413> ,COMMA here is a 3 way exchange that works through variables in only in swap <sil=0.956> .PERIOD But since they were pointer variables you ended up changing the locations in the main as well <sil=0.924> .PERIOD And once you return all the memory will all the memory corresponding to swap will be erased <sil=0.905> .PERIOD But then when you return the main A and B will have changed A and B were 1 and 2 before <sil=0.919> .PERIOD Now <sil=0.333> ,COMMA A is 2 and B is 1 <sil=0.946> .PERIOD So <sil=0.558> ,COMMA it has correctly swapped <sil=0.976> .PERIOD Now <sil=0.528> ,COMMA as an exercise I said that the obvious way to write the swap function is as follows <sil=0.989> .PERIOD Voids swap A in star PTRB's PTRA and in star PTRB <sil=0.900> .PERIOD And then I declare in star PTRT and then I write these statements <sil=0.930> .PERIOD This is a very obvious way to code swap <sil=0.927> .PERIOD This does not work <sil=0.909> .PERIOD So <sil=0.335> ,COMMA try to draw these pictures as we have done with a swap function that actually worked <sil=0.910> .PERIOD Try to draw the picture of what happens in main and what happens in the swap function and understand why this particular swap function does not work <sil=0.921> .PERIOD One final word about passing pointers to <sil=0.325> ,COMMA passing pointers to functions <sil=0.918> .PERIOD C has something called a call by value mechanism <sil=0.978> .PERIOD What is meant by call by value is that when you call a function remember the original picture that your friend came with his notebook and copied down the numbers in your page <sil=0.924> .PERIOD So <sil=0.304> ,COMMA your friend created a separate copy of your arguments then computed what had to be computed and returned you a value <sil=0.961> .PERIOD That picture is essentially still correct <sil=0.938> .PERIOD Even though you are now dealing with functions which can manipulate memory inside main <sil=0.571> ,COMMA the passing mechanism is still called by value <sil=0.903> .PERIOD It is just the fact that what is being copied are the addresses <sil=0.920> .PERIOD So <sil=0.305> ,COMMA when you manipulate the addresses through dereferencing you end up changing the location inside main <sil=0.966> .PERIOD So <sil=0.386> ,COMMA even with pointers in C what happens is call by value <sil=0.918> .PERIOD In this lecture <sil=0.647> ,COMMA we will see a slightly more advanced data type than a sinkley link list <sil=0.917> .PERIOD We will briefly go over one or two functions to manipulate the data structure <sil=0.943> .PERIOD The principle of manipulating the data structure for the other operations is similar <sil=1.000> .PERIOD So <sil=0.506> ,COMMA in the case of a sinkley link list <sil=0.443> ,COMMA we have seen that every node has one link to its next neighbor and we have seen this problem in a sinkley link list that if you are at a current node in a link list <sil=0.482> ,COMMA you can always go forward <sil=0.391> ,COMMA but there is no way to go back <sil=0.952> .PERIOD There is one the only way to get to its previous node is to start all over again from the beginning of the list and traverse until you reach a list <sil=0.530> ,COMMA traverse until you reach the previous node <sil=0.922> .PERIOD So <sil=0.592> ,COMMA we can easily remedy this by thinking of a data structure <sil=0.350> ,COMMA a slightly more involved data structure where every node has two links <sil=0.927> .PERIOD So <sil=0.384> ,COMMA look at this node 2 <sil=0.967> .PERIOD So <sil=0.417> ,COMMA it has two links <sil=0.388> ,COMMA one is to its neighbor <sil=0.628> ,COMMA success in neighbor <sil=0.992> .PERIOD So <sil=0.565> ,COMMA it is its next node <sil=0.910> .PERIOD There is another link which goes back to its previous neighbor <sil=0.936> .PERIOD So <sil=0.440> ,COMMA in this data structure <sil=0.432> ,COMMA there are two links per node <sil=0.945> .PERIOD Therefore <sil=0.340> ,COMMA it is known as a doubley link list and this list <sil=0.304> ,COMMA obviously <sil=0.576> ,COMMA you can go from a current node <sil=0.549> ,COMMA you can go forward or backward <sil=0.969> .PERIOD So <sil=0.449> ,COMMA easily <sil=0.990> .PERIOD So <sil=0.581> ,COMMA now the variation is this <sil=0.351> ,COMMA if each node has three fields <sil=0.305> ,COMMA one is a pointer to the previous node <sil=0.314> ,COMMA the second is the data in the node and the third is the pointer to the next node <sil=0.950> .PERIOD So <sil=0.630> ,COMMA how will the definition look like <sil=0.968> ?QUESTIONMARK It will say something like struct DLL node <sil=0.568> ,COMMA doubley link list node <sil=0.945> .PERIOD It will have one field which is data in data <sil=0.387> ,COMMA let us say and then two nodes struct DLL node next and struct DLL node previous <sil=0.956> .PERIOD So <sil=0.648> ,COMMA one to go to the next node and another to go to the previous node <sil=0.996> .PERIOD Now <sil=0.647> ,COMMA we will need two pointers typically for a doubley link list <sil=0.927> .PERIOD One is the pointer to the beginning of the list <sil=0.446> ,COMMA which is usually called the head and another to the end of the list <sil=0.589> ,COMMA which is usually called the tail <sil=0.981> .PERIOD So <sil=0.325> ,COMMA I will use a type def in order to shorten the name <sil=0.633> ,COMMA I will just say type def struct DLL node star node pointer <sil=0.934> .PERIOD And then I will say that the list has two node pointers <sil=0.363> ,COMMA node pointer head and node pointer last <sil=0.949> .PERIOD So <sil=0.582> ,COMMA doubley link list <sil=0.312> ,COMMA each node in the doubley link list has two list <sil=0.447> ,COMMA one to its previous node and another to its next node <sil=0.958> .PERIOD And the list itself has two pointers <sil=0.423> ,COMMA one to the beginning of the list called the head and another to the end of the list called the tail <sil=0.976> .PERIOD So <sil=0.534> ,COMMA now doubley link list is another data structure <sil=0.444> ,COMMA notice that we have seen two or three data structures so far <sil=0.636> ,COMMA arrays are one which see already provides <sil=0.944> .PERIOD We have already seen single link list <sil=0.584> ,COMMA now we have seen a third link list <sil=0.455> ,COMMA third data structure which is a doubley link list <sil=0.903> .PERIOD Now <sil=0.526> ,COMMA a data structure has data and a bunch of operations defined on it <sil=0.984> .PERIOD So <sil=0.499> ,COMMA let us look at typical operations that can be defined on a doubley link list and we will go over the implementation of two or three of them <sil=0.969> .PERIOD So <sil=0.386> ,COMMA node pointer head <sil=0.473> ,COMMA so this is a function that should return the head of the list <sil=0.932> .PERIOD Similarly <sil=0.581> ,COMMA node pointer tail <sil=0.335> ,COMMA this should return the tail of the list <sil=0.449> ,COMMA insert before <sil=0.940> .PERIOD So <sil=0.447> ,COMMA this is like the insert before node in the case of a single link list <sil=0.946> .PERIOD So <sil=0.534> ,COMMA here we are given a current node and we have to insert before a current node in the doubley link list <sil=0.929> .PERIOD Notice this was difficult in a single link list because there was no way to go from a current node to a previous node <sil=0.902> .PERIOD We could always go to the next node <sil=0.997> .PERIOD So <sil=0.504> ,COMMA if I say that here is a node and insert before that node in a single link list <sil=0.577> ,COMMA it is difficult <sil=0.944> .PERIOD You need some extra information <sil=0.552> ,COMMA but in a doubley link list you have the current node and you can use the previous link in order to go before that <sil=0.902> .PERIOD Insert after node also can be done <sil=0.973> .PERIOD This could also be done in a single link list <sil=0.937> .PERIOD So <sil=0.465> ,COMMA and then you can think of several other common like you can think of a make node <sil=0.630> ,COMMA you can think of a make list with a single with a single node pointer to by p new <sil=0.907> .PERIOD You can make an empty list <sil=0.503> ,COMMA you can check whether a given list empty <sil=0.570> ,COMMA you can write functions to copy a doubley link list to a new doubley link list <sil=0.960> .PERIOD You can concatenate two doubley link list <sil=0.403> ,COMMA you can do a deep concaten <sil=0.477> ,COMMA we will see this in a future slide <sil=0.520> ,COMMA you can append two link list and so on <sil=0.970> .PERIOD Similarly <sil=0.457> ,COMMA we can have insert <sil=0.395> ,COMMA since we have insert functions <sil=0.327> ,COMMA we can also have delete functions <sil=0.560> ,COMMA you can delete a particular node <sil=0.547> ,COMMA you can extract a node in the sense that <sil=0.542> ,COMMA so delete would take out a node and free the memory allocated to the node <sil=0.346> ,COMMA extract would just take out the node from the link list <sil=0.596> ,COMMA but you retain the node <sil=0.391> ,COMMA you can delete an entire list and so on <sil=0.952> .PERIOD So <sil=0.533> ,COMMA let us look at a couple of these functions <sil=0.418> ,COMMA other functions can be written in similar manner <sil=0.961> .PERIOD So <sil=0.421> ,COMMA suppose let us take insert before node <sil=0.484> ,COMMA this was a function that was not easy with the single link list <sil=0.931> .PERIOD So <sil=0.476> ,COMMA I am given a link list L <sil=0.450> ,COMMA I am given a current node p <sil=0.431> ,COMMA c urr and a new node to insert before the current node <sil=0.943> .PERIOD So <sil=0.422> ,COMMA what are the things to check <sil=0.622> ,COMMA if the list is empty <sil=0.632> ,COMMA then insert before the current node just means that <sil=0.435> ,COMMA you create a new node and return the new list <sil=0.923> .PERIOD Now <sil=0.349> ,COMMA if the head of the list is null <sil=0.512> ,COMMA then you just say that <sil=0.432> ,COMMA now the new list contains only one node <sil=0.625> ,COMMA L head will point to new <sil=0.433> ,COMMA L tail will point to new <sil=0.914> .PERIOD So <sil=0.346> ,COMMA if the list itself was null <sil=0.562> ,COMMA then what you do is you create a new node <sil=0.558> ,COMMA now the new list contains only one element <sil=0.925> .PERIOD So <sil=0.548> ,COMMA the head will point to that and the tail will also point to that and you return that <sil=0.931> .PERIOD Now <sil=0.631> ,COMMA you come to the non trivial case <sil=0.609> ,COMMA suppose the reason list and the list has some elements <sil=0.581> ,COMMA then so if p current is not equal to null <sil=0.392> ,COMMA then what you do is <sil=0.313> ,COMMA sorry if p current equal to null <sil=0.469> ,COMMA then you return the L <sil=0.579> ,COMMA this is an error <sil=0.434> ,COMMA if p current is not equal to null <sil=0.360> ,COMMA then what you do is the following <sil=0.995> .PERIOD So <sil=0.582> ,COMMA now you have to insert p new into the list <sil=0.483> ,COMMA so how do you do this <sil=0.867> ?QUESTIONMARK So <sil=0.576> ,COMMA we say that the new nodes next will be <sil=0.444> ,COMMA so we are trying to insert p new before p current <sil=0.970> .PERIOD So <sil=0.538> ,COMMA the new nodes next will be p current <sil=0.490> ,COMMA p current previous will go to p new and so the p new next will go to p current and p current previous will go to p new <sil=0.960> .PERIOD Similarly <sil=0.507> ,COMMA we have to say that the previous node <sil=0.572> ,COMMA the node before p current <sil=0.406> ,COMMA it has to point to p new <sil=0.992> .PERIOD So <sil=0.598> ,COMMA p current previous that nodes next will go point to p new and then you return the new list <sil=0.936> .PERIOD So <sil=0.616> ,COMMA this can be done by looking at pointers and handling pointers carefully <sil=0.914> .PERIOD So <sil=0.623> ,COMMA now let us see how to delete a particular node in a list <sil=0.921> .PERIOD So <sil=0.646> ,COMMA if you have to delete the header of the list <sil=0.438> ,COMMA then if there is a list <sil=0.505> ,COMMA you just delete the header and you just free the entire list <sil=0.911> .PERIOD Now <sil=0.550> ,COMMA if you have to delete a particular node in the middle of a list <sil=0.388> ,COMMA what do you do <sil=0.889> ?QUESTIONMARK So <sil=0.632> ,COMMA let us look at the various cases <sil=0.923> .PERIOD So <sil=0.585> ,COMMA in case 1 <sil=0.340> ,COMMA the node that you want to delete is the head of the list <sil=0.905> .PERIOD So <sil=0.589> ,COMMA in this case <sil=0.509> ,COMMA suppose you want to delete p <sil=0.458> ,COMMA what would you do <sil=0.920> ?QUESTIONMARK You would make head point to the next element and free p <sil=0.998> .PERIOD So <sil=0.385> ,COMMA head will be made to point to p next <sil=0.995> .PERIOD So <sil=0.422> ,COMMA this is the next <sil=0.943> .PERIOD So <sil=0.424> ,COMMA this line here <sil=0.315> ,COMMA L head will go to p next <sil=0.978> .PERIOD Now <sil=0.607> ,COMMA this guy's previous will be set to null because we are going to delete this node <sil=0.983> .PERIOD So <sil=0.322> ,COMMA this guy's previous will be set to null <sil=0.997> .PERIOD So <sil=0.526> ,COMMA now it does not point to anything and then you will free p <sil=0.986> .PERIOD So <sil=0.461> ,COMMA this is the first case where p <sil=0.542> ,COMMA the node to be deleted was the head of the list <sil=0.923> .PERIOD Now <sil=0.376> ,COMMA similarly <sil=0.501> ,COMMA if you want to delete the tail of the list <sil=0.952> .PERIOD So <sil=0.362> ,COMMA now what should you do here <sil=0.953> ?QUESTIONMARK The tail should go to p previous <sil=0.903> .PERIOD So <sil=0.473> ,COMMA in case 2 <sil=0.493> ,COMMA when p is the end of the list that we want to delete <sil=0.628> ,COMMA then tail should go into p previous <sil=0.924> .PERIOD Now <sil=0.490> ,COMMA this guy's next will now point to null because we are going to delete this node and finally <sil=0.441> ,COMMA we will free p <sil=0.933> .PERIOD So <sil=0.388> ,COMMA L tail will go to p previous L tail next will be null and then finally <sil=0.517> ,COMMA you will free p <sil=0.902> .PERIOD So <sil=0.322> ,COMMA we have seen 2 easy cases <sil=0.941> .PERIOD One is delete the head and the other is delete the tail and now we will see the difficult case where p is an intermediate node <sil=0.900> .PERIOD So <sil=0.641> ,COMMA in this case what we will do <sil=0.913> ?QUESTIONMARK So <sil=0.337> ,COMMA we will we have to remove this node <sil=0.982> .PERIOD So <sil=0.433> ,COMMA p previous's next node should be the next node of p <sil=0.908> .PERIOD So <sil=0.518> ,COMMA this link should point to the node after p <sil=0.907> .PERIOD So <sil=0.476> ,COMMA that is the first thing <sil=0.967> .PERIOD So <sil=0.484> ,COMMA we will make this node point to the node after p and this node's previous should point to the node before p <sil=0.952> .PERIOD So <sil=0.407> ,COMMA we will reset the links <sil=0.993> .PERIOD Now <sil=0.563> ,COMMA if you look at the link <sil=0.341> ,COMMA this guy's next is the one after p <sil=0.993> .PERIOD This guy's previous is the one before p <sil=0.952> .PERIOD So <sil=0.543> ,COMMA now p can be safely removed <sil=0.969> .PERIOD So <sil=0.618> ,COMMA this is how you would delete a node in the intermediate list <sil=0.917> .PERIOD So <sil=0.324> ,COMMA if there is a next node <sil=0.477> ,COMMA then p next previous will be p previous that is this backward link and if there is a previous node <sil=0.555> ,COMMA then p previous's next will be p next that is this forward node <sil=0.937> .PERIOD And finally <sil=0.382> ,COMMA after that you will free p <sil=0.981> .PERIOD So <sil=0.590> ,COMMA this is how you would delete a node from a link list <sil=0.497> ,COMMA from a doubly linked list and other operations can be done in a similar manner <sil=0.919> .PERIOD And some of these operations will be asked in the exercise problem that you will be assigned <sil=0.904> .PERIOD Similarly <sil=0.398> ,COMMA you can think of an extract node <sil=0.933> .PERIOD The code will be exactly identical to before <sil=0.357> ,COMMA except at the end <sil=0.595> ,COMMA you will instead of freeing p <sil=0.569> ,COMMA you will return p <sil=0.930> .PERIOD You do not free the p node <sil=0.451> ,COMMA you will just return the p node <sil=0.944> .PERIOD Now <sil=0.568> ,COMMA let us look at one more example <sil=0.946> .PERIOD How do you attend append one node to the end of a list <sil=0.877> ?QUESTIONMARK So <sil=0.433> ,COMMA first we will check that the node is pointing to a non-null node <sil=0.949> .PERIOD If it is pointing to a null node <sil=0.424> ,COMMA there is nothing to be done <sil=0.928> .PERIOD So <sil=0.628> ,COMMA there is nothing to be appended <sil=0.999> .PERIOD So <sil=0.390> ,COMMA you return <sil=0.996> .PERIOD Now <sil=0.393> ,COMMA if the if the reason list <sil=0.443> ,COMMA then what you do is <sil=0.575> ,COMMA if there is no list <sil=0.424> ,COMMA what you do is <sil=0.468> ,COMMA you make a list with only one node which is p <sil=0.911> .PERIOD Now <sil=0.359> ,COMMA if the reason list <sil=0.417> ,COMMA you can in order to append a node at the end <sil=0.436> ,COMMA what you could do is call insert after node L L last p <sil=0.968> .PERIOD So <sil=0.641> ,COMMA append will be the same as insert the node p at the end of the list <sil=0.936> .PERIOD So <sil=0.362> ,COMMA you will say insert after L last <sil=0.581> ,COMMA what is the node to be inserted p <sil=0.956> .PERIOD So <sil=0.556> ,COMMA if you have an insert after node or an insert before node <sil=0.526> ,COMMA you can do this to implement other functions <sil=0.997> .PERIOD So <sil=0.529> ,COMMA this is a brief introduction to doubly linked list which are similar to sinkley linked list <sil=0.523> ,COMMA but facilitate forward as well as backward traveling from a current node <sil=0.920> .PERIOD Using that <sil=0.559> ,COMMA you can implement more functions easier than a sinkley linked list <sil=0.920> .PERIOD At the same time <sil=0.367> ,COMMA it has all the advantages of a sinkley linked list in the sense that <sil=0.629> ,COMMA if you want to insert a node <sil=0.483> ,COMMA it can be done using a constant number of operations <sil=0.924> .PERIOD If you want to delete a node <sil=0.320> ,COMMA it can be done in a constant number of operations <sil=0.985> .PERIOD So <sil=0.593> ,COMMA those advantages are similar to a sinkley linked list <sil=0.948> .PERIOD At the same time <sil=0.551> ,COMMA the disadvantages are also similar to a sinkley linked list in the sense that <sil=0.446> ,COMMA if you want to search through even a sorted doubly linked list <sil=0.457> ,COMMA you have to search through all the elements <sil=1.000> .PERIOD In this session <sil=0.516> ,COMMA we will see slightly more sophisticated programs <sil=0.973> .PERIOD Recall that in our discussion about flow charts <sil=0.356> ,COMMA we talked about variables <sil=0.332> ,COMMA which were conceptually seen as little boxes in which you can hold values <sil=0.924> .PERIOD So <sil=0.377> ,COMMA let us see how to write simple C programs in which we make use of variables <sil=0.916> .PERIOD So <sil=0.557> ,COMMA we will illustrate with the help of a sample program <sil=0.927> .PERIOD So <sil=0.519> ,COMMA we have this following program <sil=0.556> ,COMMA which is very simple <sil=0.383> ,COMMA read a Celsius temperature and convert it into the equivalent Fahrenheit temperature <sil=0.966> .PERIOD This is something that all of you must know <sil=0.941> .PERIOD So the flow chart is very simple <sil=0.317> ,COMMA you have an input C <sil=0.504> ,COMMA which is the current Celsius that you want to convert <sil=0.901> .PERIOD Then you apply the formula F <sil=0.389> ,COMMA which is 9 C upon 5 plus 32 <sil=0.955> .PERIOD In this session <sil=0.506> ,COMMA we will see how to write simple C programs <sil=0.415> ,COMMA which make use of variables <sil=0.905> .PERIOD Recall that in our discussion about flow charts <sil=0.546> ,COMMA we talked about variables <sil=0.454> ,COMMA which were conceptually seen as little boxes in which you can hold values <sil=0.955> .PERIOD So <sil=0.499> ,COMMA let us illustrate a simple C program making use of variables with the help of a program <sil=0.916> .PERIOD So <sil=0.625> ,COMMA we have a small problem <sil=0.644> ,COMMA which is convert a Celsius temperature into the equivalent Fahrenheit temperature <sil=0.955> .PERIOD This is a formula that all of you must know <sil=0.924> .PERIOD So <sil=0.339> ,COMMA let us write a C program for it <sil=0.975> .PERIOD So <sil=0.475> ,COMMA we will draw the simple flow chart for doing the program <sil=0.577> ,COMMA you input the temperature in C in Celsius <sil=0.628> ,COMMA convert it into Fahrenheit according to the formula 9 by 5 times Celsius plus 32 <sil=0.901> .PERIOD Once you have done that <sil=0.392> ,COMMA the variable F holds the Fahrenheit value <sil=0.304> ,COMMA so you output the F <sil=0.972> .PERIOD So <sil=0.621> ,COMMA here is the simple flow chart that we want to implement <sil=0.954> .PERIOD Now <sil=0.329> ,COMMA how do we write the equivalent C code <sil=0.991> ?QUESTIONMARK So <sil=0.530> ,COMMA in the flow chart <sil=0.473> ,COMMA we have seen that we have two variables C and F <sil=0.990> .PERIOD These are the variables that we would want to implement in the C code <sil=0.993> .PERIOD So <sil=0.522> ,COMMA let us see how to do it <sil=0.980> .PERIOD So <sil=0.345> ,COMMA we write the following C program <sil=0.303> ,COMMA in which now we have two more components <sil=0.926> .PERIOD One is the variable declaration float centigrade and then the second is another variable float Fahrenheit <sil=0.935> .PERIOD So <sil=0.430> ,COMMA centigrade correspond to C in the flow chart and Fahrenheit corresponds to F in the flow chart <sil=0.904> .PERIOD So <sil=0.354> ,COMMA I write the following code <sil=0.530> ,COMMA which is supposed to implement the flow chart on the left <sil=0.911> .PERIOD So <sil=0.476> ,COMMA let us say that the input is 50 degree Celsius and then you can in the Fahrenheit the formula is exactly the same as what we have in the flow chart <sil=0.962> .PERIOD We have 9 times centigrade divided by 5 plus 32 <sil=0.980> .PERIOD Notice here that these are arithmetic operators <sil=0.980> .PERIOD So <sil=0.574> ,COMMA the star arithmetic operator is stands for multiplication <sil=0.540> ,COMMA forward slash stands for division and plus stands for addition <sil=0.933> .PERIOD So <sil=0.376> ,COMMA this is exactly as in the flow chart except that here in the flow chart multiplication symbol has been swallowed <sil=0.458> ,COMMA but in C you have to specify it using a star operator <sil=0.903> .PERIOD So <sil=0.528> ,COMMA Fahrenheit equal to 9 times centigrade divided by 5 plus 32 is exactly similar to the analogous line in the flow chart <sil=0.990> .PERIOD And finally <sil=0.411> ,COMMA for outputting we will use the print up statement <sil=0.992> .PERIOD So <sil=0.301> ,COMMA here is something new in the print up statement <sil=0.961> .PERIOD We use what are known as format specifiers <sil=0.976> .PERIOD These percentage F symbols are new and we will describe them shortly <sil=0.972> .PERIOD So <sil=0.581> ,COMMA let us look at the program in a little more detail <sil=0.974> .PERIOD So <sil=0.639> ,COMMA we have two statements which are of interest in the beginning of the code which are what are known as the definition of the two variables <sil=0.962> .PERIOD Recall from our discussion on flow charts that variables are boxes and each box has a name associated with it <sil=0.987> .PERIOD So <sil=0.549> ,COMMA you have two concepts associated with a variable as far as flow charts were concerned <sil=0.984> .PERIOD One was the box and the second was the name of the box <sil=0.987> .PERIOD Now <sil=0.307> ,COMMA when we come to see we will associate the third concept with a variable which is the type of the box <sil=0.983> .PERIOD So <sil=0.489> ,COMMA if you look at the first statement it says float centigrade semicolon <sil=0.944> .PERIOD Now <sil=0.549> ,COMMA this defines a variable centigrade <sil=0.926> .PERIOD It creates a box capable of storing a real number and names the box as centigrade <sil=0.929> .PERIOD So <sil=0.509> ,COMMA the box is of type float that type float means that that box can hold a real number <sil=0.908> .PERIOD Similarly <sil=0.448> ,COMMA Fahrenheit is also a box which can hold a real number <sil=0.942> .PERIOD So <sil=0.547> ,COMMA you declare that the type of that variable is float <sil=0.932> .PERIOD So <sil=0.375> ,COMMA these are supposed to be the first two lines of the code <sil=0.944> .PERIOD Now <sil=0.431> ,COMMA centigrade is equal to 50 that is the line which assigns the value 50 to the variable centigrade <sil=0.942> .PERIOD So <sil=0.354> ,COMMA once you execute that code the box associated with the name centigrade will hold the value 50 followed by the line which computes the value of the Fahrenheit <sil=0.979> .PERIOD So <sil=0.425> ,COMMA Fahrenheit equal to 9 times centigrade divided by 5 plus 32 <sil=0.989> .PERIOD It is an arithmetic expression <sil=0.986> .PERIOD So <sil=0.617> ,COMMA it evaluates an arithmetic expression takes its value and stores it in the box associated with Fahrenheit <sil=0.992> .PERIOD And as we just saw before start is the multiplication operator <sil=0.912> .PERIOD Forward slash is the division operator and plus is the addition operator <sil=0.957> .PERIOD Now <sil=0.607> ,COMMA the brackets in an arithmetic expression are just like brackets in mathematics <sil=0.975> .PERIOD So <sil=0.530> ,COMMA the group together a particular things <sil=0.977> .PERIOD Now <sil=0.523> ,COMMA let us just trace through the program <sil=0.959> .PERIOD Let us see what happens step by step when we run the program <sil=0.954> .PERIOD Let us say that we save the file in sample 2 <sil=0.952> .PERIOD c and then run it as dot slash a dot out <sil=0.924> .PERIOD So <sil=0.506> ,COMMA this is the function of the program <sil=0.918> .PERIOD So <sil=0.385> ,COMMA first we will have 2 boxes created one for centigrade and one for Fahrenheit <sil=0.961> .PERIOD These can store float numbers <sil=0.998> .PERIOD Now <sil=0.471> ,COMMA what are float numbers <sil=0.972> ?QUESTIONMARK Basically they are real numbers which are saved by the microprocessor <sil=0.917> .PERIOD Now <sil=0.451> ,COMMA the microprocessor has can store variable real numbers only using finite precision <sil=0.910> .PERIOD So <sil=0.380> ,COMMA this is different from the actual real numbers that we encounter in mathematics <sil=0.967> .PERIOD So <sil=0.638> ,COMMA we have only a limited number of digits after the decimal point <sil=0.964> .PERIOD But other than that you can think of them as real numbers <sil=0.929> .PERIOD We will see floating point numbers later in the course in greater detail <sil=0.968> .PERIOD For now <sil=0.632> ,COMMA think of them as the machine representation of a real number <sil=0.958> .PERIOD So <sil=0.351> ,COMMA once you finish the declaration statements what you have are 2 boxes one for centigrade <sil=0.401> ,COMMA one for Fahrenheit and because you declare their types to be float it is understood that those boxes will hold real numbers <sil=0.914> .PERIOD So <sil=0.382> ,COMMA let us execute the first executable assignment here <sil=0.940> .PERIOD Sintegrate is equal to 50 and you will see that the box contains 50 <sil=0.937> .PERIOD 000 something even though we specified it as an integer it will convert it into a real number of floating point number and store it <sil=0.905> .PERIOD Then this is followed by the calculation of the Fahrenheit value and let us say that you compute 9 times 50 divided by 5 plus 32 it comes out as 122 <sil=0.954> .PERIOD After that line is executed the box associated with Fahrenheit will contain 122 <sil=0.985> .PERIOD Then the next line says print print f the temperature there is no new line <sil=0.946> .PERIOD So <sil=0.367> ,COMMA the next print f will start from where this print f ended and here you see something new which is the percentage f symbol <sil=0.993> .PERIOD So <sil=0.509> ,COMMA these are what are known as format specifiers <sil=0.937> .PERIOD So <sil=0.540> ,COMMA the percentage f symbol says that take the corresponding variable which is given centigrade here and print it as a float print it as a real number <sil=0.993> .PERIOD So <sil=0.593> ,COMMA notice the difference between the first print f and the second print f <sil=0.906> .PERIOD The first print f just had a string between double codes <sil=0.988> .PERIOD The second print f has two arguments one is a string between double codes and the string is percentage f and then the second argument is centigrade <sil=0.919> .PERIOD So <sil=0.353> ,COMMA it says take the value of centigrade and print it as a floating point number <sil=0.984> .PERIOD So <sil=0.333> ,COMMA it does that and you see 50 <sil=0.984> .PERIOD 000 in the output there is no new line <sil=0.950> .PERIOD So <sil=0.617> ,COMMA the next print f starts from the previous line where the previous print f left off 50 Celsius equals <sil=0.990> .PERIOD So <sil=0.509> ,COMMA it prints that and now you have another format specifier it says print f percentage f fan night <sil=0.957> .PERIOD Fan night is 122 and it will print it as a floating point number or as a real number <sil=0.993> .PERIOD So <sil=0.354> ,COMMA it will print it as 122 <sil=0.926> .PERIOD 000 <sil=0.976> .PERIOD So <sil=0.630> ,COMMA print f fan night <sil=0.951> .PERIOD So <sil=0.607> ,COMMA the final message that will be printed will be the temperature 50 centigrade 50 Celsius equals 122 fan night <sil=0.903> .PERIOD So <sil=0.392> ,COMMA the new thing that we have seen in this program include variable definitions <sil=0.407> ,COMMA how they have an associated type and similarly how do we print these variables <sil=0.966> .PERIOD So <sil=0.368> ,COMMA we do not want to print the names of the variables we want to print the content of the variables <sil=1.000> .PERIOD We want to print what is stored in the box for that we use these format specifiers like this percentage f <sil=0.917> .PERIOD So <sil=0.620> ,COMMA let us briefly introduce what are types in C <sil=0.972> .PERIOD So <sil=0.306> ,COMMA variables are the names of the boxes in which to store the values <sil=0.946> .PERIOD But these boxes are special certain boxes can hold only certain kinds of values <sil=0.919> .PERIOD So <sil=0.592> ,COMMA all boxes are not the same there are different kinds of boxes <sil=0.924> .PERIOD Now <sil=0.304> ,COMMA types are basically saying that a particular box can hold a particular kind of data <sil=0.904> .PERIOD So <sil=0.302> ,COMMA variables are defined with associated type and we will use some basic types during the course of this programming language to to it <sil=0.984> .PERIOD One of the two common type two of the common types that we see in this program are int which stands for an integer and float which stands for a floating point number <sil=0.975> .PERIOD So <sil=0.623> ,COMMA it stands for a real number notice that machines can hold only a fixed number of bits <sil=0.942> .PERIOD So <sil=0.477> ,COMMA int does not mean that the integers can go from minus infinity to infinity <sil=0.958> .PERIOD It goes from a certain very very small negative number to a very large positive number <sil=0.941> .PERIOD Similarly <sil=0.479> ,COMMA floating point also is limited by a particular range <sil=0.991> .PERIOD This is because machines cannot represent arbitrary values <sil=0.911> .PERIOD The type of integer can store all numbers from minus m plus 1 through 0 to plus m <sil=0.954> .PERIOD So <sil=0.317> ,COMMA there will be some large m for which defines the upper limits and the lower limits of the particular machine <sil=0.980> .PERIOD Now <sil=0.409> ,COMMA that limit may depend on which particular machine that you use <sil=0.920> .PERIOD On a on a 32 bit machine it will be 2 to the power of 32 <sil=0.393> ,COMMA 2 m will be 2 to the power of 32 <sil=0.978> .PERIOD A few final words about variables just like in a cooking recipe you will never mention a step which involves an ingredient without mentioning that ingredient is needed in the first place <sil=0.983> .PERIOD So <sil=0.567> ,COMMA you will never say that you salt and if you look at the list of ingredients you will see that there is no salt in the list of ingredients <sil=0.945> .PERIOD Such recipes are considered bad <sil=0.967> .PERIOD So <sil=0.375> ,COMMA when you write a typical recipe you list out all the ingredients first and then write the steps for the cooking <sil=0.973> .PERIOD Similarly <sil=0.602> ,COMMA in a program you define whatever variables that you need before those variables are used by any statement in the program <sil=0.903> .PERIOD Always define a variable before use <sil=0.966> .PERIOD Now <sil=0.448> ,COMMA a word about names of variables in the C programming language the names are consisting of numbers <sil=0.321> ,COMMA letters and an underlying symbol and underscore symbol <sil=0.929> .PERIOD And there is a particular convention that a variable cannot start with a number <sil=0.997> .PERIOD So <sil=0.421> ,COMMA the initial letter has to be a letter or an underscore it cannot be a number <sil=0.634> ,COMMA but further letters can be either capital letters small letter or numbers or an underscore <sil=0.949> .PERIOD So <sil=0.516> ,COMMA there are valid names like C underscore S q <sil=0.372> ,COMMA C S q 1 <sil=0.514> ,COMMA C underscore S q underscore one <sil=0.986> .PERIOD So <sil=0.582> ,COMMA all these are valid <sil=0.932> .PERIOD One thing to note is that the names are sensitive to upper and lower case <sil=0.905> .PERIOD So <sil=0.399> ,COMMA for example capital C centigrade is different from a centigrade with a small C <sil=0.920> .PERIOD So <sil=0.520> ,COMMA these are two distinct variables that is a common source of errors when you start programming <sil=0.969> .PERIOD Another thing to note to watch out for is that the assignment operation which is equal to is not the same as the mathematical equal <sil=0.971> .PERIOD So <sil=0.442> ,COMMA when mathematically we say a equal to b it means that a and b are the same quantity <sil=0.952> .PERIOD So <sil=0.538> ,COMMA a equal to b is the same as saying b equal to a this is not true in C <sil=0.918> .PERIOD For example <sil=0.327> ,COMMA let us say that you have the statements b equal to 3 semicolon and then later you have a equal to 2 semicolon and further you have the statement a equal to b semicolon <sil=0.990> .PERIOD So <sil=0.625> ,COMMA the statement a equal to b will set a to b's value <sil=0.950> .PERIOD So <sil=0.344> ,COMMA b's value is 3 and that value will be copied to a <sil=0.922> .PERIOD So <sil=0.574> ,COMMA it will set a to 3 and b will be unchanged <sil=0.920> .PERIOD So <sil=0.582> ,COMMA watch out for this if the statement if you are expecting the mathematical operator after the operation a equal to b a and b will have the same value <sil=0.485> ,COMMA but that is not the case <sil=0.978> .PERIOD The meaning of the symbol equal to is that take the value on the right hand side of the expression and copy that into the box specified by the left side <sil=0.969> .PERIOD So <sil=0.338> ,COMMA copy the value on the right hand side to the variable on the left <sil=0.962> .PERIOD In this video <sil=0.405> ,COMMA let me show some cool stuff which is pointer arithmetic which helps you to understand the relationship between pointers and arrays in C <sil=0.964> .PERIOD So <sil=0.629> ,COMMA let us consider an array declared as follows int num and then it has 5 numbers in the initialization list <sil=0.972> .PERIOD So <sil=0.645> ,COMMA the array will be initialized as follows <sil=0.912> .PERIOD There are 5 consecutive integer locations in memory with the given elements plus there is a 6th cell which points to the first location in the array <sil=0.925> .PERIOD So <sil=0.422> ,COMMA num points to the first location in the array <sil=0.910> .PERIOD If num points to the first location <sil=0.554> ,COMMA then you can do the following operator num plus 1 <sil=0.975> .PERIOD So <sil=0.638> ,COMMA num plus 1 would point to the integer box right next to the integer box pointed to by num and we also know that arrays are consecutively located <sil=0.917> .PERIOD So <sil=0.347> ,COMMA the integer box next to num is exactly num 1 <sil=0.917> .PERIOD So <sil=0.353> ,COMMA num plus 1 points to num of 1 similarly num plus 2 points to num of 2 and so on until num plus 4 equal to num of 4 <sil=0.929> .PERIOD So <sil=0.503> ,COMMA this particular box for example <sil=0.424> ,COMMA num of 4 can be accessed in two ways <sil=0.939> .PERIOD You can write num of 4 or you can write star of num plus 4 <sil=0.943> .PERIOD So <sil=0.582> ,COMMA can you tell me the output of the following print of statement <sil=0.994> .PERIOD So <sil=0.342> ,COMMA think about this for a minute you have 3 integers to print using percentage d percentage d percentage d and what are to be printed are star of num plus 1 star of num plus 2 and star of num plus 3 <sil=0.992> .PERIOD So <sil=0.529> ,COMMA think about it for a minute <sil=0.985> .PERIOD Num plus 1 is the address which is the second integer box in the array num points to the first location <sil=0.973> .PERIOD Therefore <sil=0.507> ,COMMA num plus 1 points to the second location star is the dereference operator on a pointer <sil=0.961> .PERIOD So <sil=0.362> ,COMMA star of this pointer means go to that location which is this location and get the value in that location which is 22 <sil=0.996> .PERIOD Similarly <sil=0.450> ,COMMA num plus 2 is the box 2 boxes away from the first box in the array <sil=0.967> .PERIOD So <sil=0.644> ,COMMA 2 boxes away from num <sil=0.913> .PERIOD So <sil=0.432> ,COMMA that happens to be num plus 2 which is the and then get the value there which is 16 <sil=0.993> .PERIOD Similarly <sil=0.346> ,COMMA star of num plus 3 will give you minus 1 <sil=0.901> .PERIOD So <sil=0.507> ,COMMA the output would be 22 16 minus 1 <sil=0.969> .PERIOD So <sil=0.518> ,COMMA in this print of statement we have used two concepts <sil=0.932> .PERIOD One is getting to a different pointer from a given pointer using pointer arithmetic operator plus <sil=0.998> .PERIOD So <sil=0.615> ,COMMA we have used plus here the second operator that we have used is star on a given on a given pointer <sil=0.928> .PERIOD So <sil=0.509> ,COMMA plus will tell you go to the next integer location and star will tell you for a given integer pointer give me the value in that location <sil=0.920> .PERIOD Now <sil=0.458> ,COMMA let us look at a slightly different array what happens if you have a character array <sil=0.911> .PERIOD So <sil=0.315> ,COMMA I have car STR array which is initialized to let us say given string 1 t is a nice girl and then I have a character pointer <sil=0.993> .PERIOD So <sil=0.582> ,COMMA car star ptr and it is assigned STR plus 6 it is initialized to STR plus 6 what will happen here <sil=0.951> .PERIOD What is different about this example is that earlier I said that in an integer array plus 1 for example <sil=0.304> ,COMMA would go to the next integer location in memory <sil=0.954> .PERIOD So <sil=0.514> ,COMMA wherever num was num plus 1 would go to the next integer location here STR is a character array <sil=0.972> .PERIOD So <sil=0.305> ,COMMA it has to go to the next character location and that is exactly what it does <sil=0.993> .PERIOD So <sil=0.527> ,COMMA what is printed let us first consider the state of the memory <sil=0.901> .PERIOD So <sil=0.311> ,COMMA you have an array which is a character array it starts from STR 0 and goes on up to STR 20 <sil=0.900> .PERIOD So <sil=0.444> ,COMMA there are 19 characters followed by the null character <sil=0.946> .PERIOD Why is the null character there because I initialized it to a string constant every string constant has a null character implicitly at the end <sil=0.983> .PERIOD So <sil=0.578> ,COMMA this is the state of the STR array <sil=0.924> .PERIOD Now <sil=0.538> ,COMMA I say that I declare a pointer the pointer is pointing to a car <sil=0.945> .PERIOD So <sil=0.508> ,COMMA it is a car star pointer and what is the location it points to it points to STR plus 6 <sil=0.995> .PERIOD STR is a pointer to the first location of the character array and this is the first location plus 6 would jump 6 character locations away from STR 0 <sil=0.917> .PERIOD So <sil=0.445> ,COMMA you would reach this character the important difference between this example and the previous example is that if you declared an integer array plus 1 would jump 1 integer location plus 6 would jump 6 integer locations <sil=0.957> .PERIOD Here since it is a character array STR plus 6 would jump 6 character locations <sil=0.975> .PERIOD So <sil=0.475> ,COMMA how the plus operator is interpreted in the case of a pointer depends on what array am I pointing to right now <sil=0.974> .PERIOD Now <sil=0.593> ,COMMA what will happen with the print up statement <sil=0.967> ?QUESTIONMARK So <sil=0.548> ,COMMA if I say print up percentage as PTR what will happen <sil=0.995> ?QUESTIONMARK So <sil=0.302> ,COMMA PTR points to STR 6 <sil=0.925> .PERIOD So <sil=0.432> ,COMMA print up will print whatever string is starting from that location until the first null character <sil=0.938> .PERIOD So <sil=0.361> ,COMMA it will start printing from this I and then go on printing till it reaches the null character <sil=0.990> .PERIOD So <sil=0.621> ,COMMA the output will be just is a nice goal <sil=0.949> .PERIOD So <sil=0.327> ,COMMA when you want to print up it is not important that you start from the absolute beginning of the array <sil=0.934> .PERIOD You can start from an arbitrary location in the character array and if you say print up percentage is it will start from there and go on and print until the first null character <sil=0.949> .PERIOD So <sil=0.401> ,COMMA let us look at it once more <sil=0.995> .PERIOD So <sil=0.444> ,COMMA here is the code that we had and let us say that the one dimensional array for the sake of convenience I will just show it like this it is actually a row <sil=0.484> ,COMMA but here is the first part here is the second part and so on <sil=0.909> .PERIOD So <sil=0.491> ,COMMA when I see STR <sil=0.333> ,COMMA STR is a character array and PTR plus 6 would go 6 locations away from the first location <sil=0.976> .PERIOD So <sil=0.529> ,COMMA STR is pointing to the first location in the array it will go to the sixth location in the array PTR and PTR is pointing to the sixth location <sil=0.988> .PERIOD So <sil=0.561> ,COMMA you can ask the first more expressions do they make sense can I say STR plus 5 is this location similarly can I say STR plus 10 is this location and so on <sil=0.934> .PERIOD So <sil=0.431> ,COMMA these are all correct expressions <sil=0.987> .PERIOD Now <sil=0.602> ,COMMA can you tell the output of print up percentage PTR minus 5 we have talked about plus operator on pointers <sil=0.952> .PERIOD So <sil=0.530> ,COMMA it will whatever the nature of the array that the pointer is pointing to it will jump n locations away from it <sil=0.901> .PERIOD So <sil=0.416> ,COMMA if I say PTR plus n it will jump n locations of that type away from it <sil=0.915> .PERIOD So <sil=0.402> ,COMMA by the same logic can I argue that if I do minus 5 PTR minus 5 can I say that it will go 5 locations previous to what PTR is pointing to right now and the answer is yes <sil=0.927> .PERIOD So <sil=0.571> ,COMMA it will behave exactly as you expect <sil=0.978> .PERIOD So <sil=0.574> ,COMMA PTR is pointing to this location here is the previous location <sil=0.911> .PERIOD So <sil=0.513> ,COMMA it will jump to 5 locations before the location pointed to by PTR and happens to be A <sil=0.960> .PERIOD So <sil=0.466> ,COMMA the location which is STR 1 that is equal to PTR minus 5 <sil=0.988> .PERIOD So <sil=0.519> ,COMMA if you print up on that location it will say anti is a nice curve <sil=0.987> .PERIOD So <sil=0.356> ,COMMA that is the output <sil=0.944> .PERIOD Before I proceed this 1 <sil=0.545> ,COMMA this is the output of the thing that I want to emphasize and it is often not emphasized when you see online material on pointer arithmetic <sil=0.902> .PERIOD See pointer arithmetic is not supposed to be meant for navigating the array you meant for navigating arbitrary locations in the memory <sil=0.984> .PERIOD So <sil=0.368> ,COMMA you cannot take a pointer let us say character pointer and just say pointer plus 1000 <sil=0.950> .PERIOD It will give you some location in the memory <sil=0.368> ,COMMA but the behavior of the program will be undefined <sil=0.957> .PERIOD So <sil=0.508> ,COMMA the C pointers are well defined pointer arithmetic using C pointers are well defined only when the pointers are pointing to locations within an array <sil=0.984> .PERIOD So <sil=0.639> ,COMMA within an array plus n will take you n locations away from the given pointer minus n will give you minus n away from the given behind the given pointer and so on of whatever type the character whatever type the given pointer is pointing to <sil=0.958> .PERIOD For example <sil=0.352> ,COMMA if you have int num 10 and then you have num plus 11 you know that num plus 11 is not a valid location in the array <sil=0.931> .PERIOD Similarly num minus 1 the num array starts at num of 0 which is equal into num plus 0 <sil=0.912> .PERIOD So <sil=0.320> ,COMMA num minus 1 is also out of the given array therefore <sil=0.473> ,COMMA these two locations are actually undefined because C does not guarantee you that if you try to dereference these pointers you will get any meaningful information <sil=0.997> .PERIOD So <sil=0.364> ,COMMA plus and minus on pointers are well defined their behavior is easy to predict exactly when you are navigating within the bounds of an array <sil=0.960> .PERIOD So <sil=0.485> ,COMMA the main point of the lecture was that if you have let us say for example <sil=0.333> ,COMMA an integer array int num 10 then num of i which is the array notation is exactly equivalent to star of num plus i and I am not saying this that you can think of num of i as num plus i <sil=0.930> .PERIOD It is not an analogy this is exactly what C actually does <sil=0.964> .PERIOD So <sil=0.305> ,COMMA num of i is translated to star of num plus i <sil=0.901> .PERIOD So <sil=0.639> ,COMMA arrays and pointers in C are very intimately related <sil=0.905> .PERIOD When it comes to C functions <sil=0.505> ,COMMA we have seen the following concepts <sil=0.924> .PERIOD One is the declaration and the definition of a function by which I mean the declaration is what type is the function <sil=0.522> ,COMMA what are the input arguments <sil=0.350> ,COMMA what types are the input arguments and what is the result return type <sil=0.915> .PERIOD So <sil=0.315> ,COMMA these form the declaration definition is the logic of the function <sil=0.989> .PERIOD So <sil=0.540> ,COMMA this is what is known as the declaration and the definition of the function and we do it only once <sil=0.905> .PERIOD So <sil=0.387> ,COMMA a function is defined only once <sil=0.982> .PERIOD Once we define a function <sil=0.594> ,COMMA we can of course <sil=0.413> ,COMMA call the function multiple times <sil=0.997> .PERIOD So <sil=0.631> ,COMMA definition is done only once and calling can be done any number of times <sil=0.980> .PERIOD Now <sil=0.539> ,COMMA we refer to a stack which is what is the central concept in executing a function <sil=0.937> .PERIOD The stack is just a part of the memory that grows only in one direction <sil=0.928> .PERIOD So <sil=0.530> ,COMMA that is what it is supposed to mean <sil=0.913> .PERIOD Basically <sil=0.463> ,COMMA you can think of it as a stack of boxes or a stack of paper on your table or a stack of plates <sil=0.967> .PERIOD So <sil=0.516> ,COMMA it grows in one direction <sil=0.909> .PERIOD So <sil=0.594> ,COMMA the stack is grows as the main calls a particular function <sil=0.475> ,COMMA that function calls as the different function and so on <sil=0.920> .PERIOD And you can imagine the stack is growing upwards or growing downwards <sil=0.943> .PERIOD It does not matter as functions get called it either keeps growing upwards or keeps going downwards <sil=0.978> .PERIOD We will usually represent it as keeping growing downward <sil=0.965> .PERIOD So <sil=0.564> ,COMMA let us look at this function that we were talking about earlier <sil=0.982> .PERIOD So <sil=0.499> ,COMMA n choose k is n factorial upon k factorial times n minus k factorial and let us try to code this up <sil=0.922> .PERIOD We know that factorial is something that we will need over and over in this program <sil=0.995> .PERIOD So <sil=0.516> ,COMMA let us say that I will write factorial as a function <sil=0.938> .PERIOD So <sil=0.551> ,COMMA factorial takes an integer and returns an integer <sil=0.992> .PERIOD So <sil=0.595> ,COMMA the declaration is int fact int r is the input argument and the return type is int <sil=0.966> .PERIOD Now <sil=0.638> ,COMMA inside that we will write the code for factorial <sil=0.949> .PERIOD All variables declared inside the factorial are local or private to the factorial function <sil=0.957> .PERIOD They cannot be seen outside <sil=0.969> .PERIOD So <sil=0.357> ,COMMA the input argument as well as any variables declared inside factorial are private or local to the factorial function <sil=0.959> .PERIOD So <sil=0.621> ,COMMA I have i and this encodes the logic of factorial that we have seen earlier <sil=0.935> .PERIOD So <sil=0.425> ,COMMA you start with the product equal to 1 and keep on multiplying the numbers till you reach r factorial <sil=0.932> .PERIOD So <sil=0.318> ,COMMA once you reach r <sil=0.448> ,COMMA you return the r factorial <sil=0.992> .PERIOD This logic is something that we have seen before <sil=0.932> .PERIOD Now <sil=0.629> ,COMMA we will see how do we put this together in order to produce the function <sil=0.936> .PERIOD So <sil=0.320> ,COMMA what we need to do is we will just encode up the solution that we have <sil=0.953> .PERIOD So <sil=0.446> ,COMMA it is factorial n divided by factorial k divided by factorial n minus k <sil=0.928> .PERIOD So <sil=0.588> ,COMMA here I have encoded just the logic <sil=0.913> .PERIOD So <sil=0.592> ,COMMA even though division is involved <sil=0.641> ,COMMA I know that when I do n c k <sil=0.439> ,COMMA the result is always going to be an integer <sil=0.993> .PERIOD So <sil=0.468> ,COMMA I can declare it as int r s <sil=0.946> .PERIOD So <sil=0.621> ,COMMA this part is known as the definition of the factorial function <sil=0.921> .PERIOD So <sil=0.567> ,COMMA this part is what is known as definition and each of these are what are known as calls <sil=0.935> .PERIOD Now <sil=0.410> ,COMMA we have a function called as n c k <sil=0.398> ,COMMA now let us try to see what happens when we execute this program <sil=0.906> .PERIOD So <sil=0.617> ,COMMA regardless of how many functions have been defined <sil=0.474> ,COMMA whenever you start executing a program <sil=0.611> ,COMMA it always executes the first line of main <sil=0.913> .PERIOD So <sil=0.432> ,COMMA let us try to add some temporary variables because we call this function 3 times in this main <sil=0.968> .PERIOD Let us try to separate them out into 3 separate calls just for the sake of clarity <sil=0.956> .PERIOD So <sil=0.488> ,COMMA I will add a slightly larger code <sil=0.400> ,COMMA this is not proper c code <sil=0.921> .PERIOD Let us say that I have 3 extra variables which I have declared up int t 1 <sil=0.510> ,COMMA t 2 and t 3 <sil=0.984> .PERIOD Now <sil=0.442> ,COMMA t 1 will be factorial of n <sil=0.451> ,COMMA t 2 will be factorial of k and t 3 will be factorial of n minus k <sil=0.901> .PERIOD I have separated these out so that I can clearly explain what happens when the code executes <sil=0.951> .PERIOD Let us say that I want to calculate 4 c 2 <sil=0.999> .PERIOD Now <sil=0.631> ,COMMA first when the program starts executing <sil=0.587> ,COMMA you start with the main on the first line of the <sil=0.641> ,COMMA with the code on the first line of the main <sil=0.909> .PERIOD So <sil=0.515> ,COMMA you scan of n and k <sil=0.363> ,COMMA so n is 4 and k is 2 <sil=0.915> .PERIOD Now <sil=0.407> ,COMMA you do t 1 equal to factorial of n <sil=0.965> .PERIOD So <sil=0.401> ,COMMA when t 1 equal to factorial of n is called <sil=0.537> ,COMMA what you do is you set up the return value and return address <sil=0.936> .PERIOD So <sil=0.554> ,COMMA return value is not yet decided <sil=0.511> ,COMMA return address is 5 because you have to go back to line 5 of the code <sil=0.906> .PERIOD So <sil=0.556> ,COMMA that is why the return value is 5 <sil=0.954> .PERIOD Also <sil=0.340> ,COMMA what do you need to do <sil=0.877> ?QUESTIONMARK You need to copy the parameter value which is 4 <sil=0.911> .PERIOD So <sil=0.575> ,COMMA this is the actual parameter 4 and you have to copy it to the input argument r <sil=0.981> .PERIOD So <sil=0.576> ,COMMA r is the input argument r should be assigned to the value n here n is 4 <sil=0.950> .PERIOD So <sil=0.461> ,COMMA that is known as passing the argument <sil=0.957> .PERIOD Now <sil=0.601> ,COMMA once that is done <sil=0.525> ,COMMA the code can be seen as jumping to factorial <sil=0.954> .PERIOD So <sil=0.362> ,COMMA as soon as the function is called <sil=0.314> ,COMMA you actually pass the execution to the factorial function <sil=0.909> .PERIOD Now <sil=0.310> ,COMMA inside the factorial function <sil=0.552> ,COMMA you have 2 local variables i and a n s which is answered and we start executing the factorial function <sil=0.912> .PERIOD So <sil=0.453> ,COMMA let us see what happens when we execute the factorial function <sil=0.960> .PERIOD So <sil=0.315> ,COMMA far we have passed the arguments and so on <sil=0.910> .PERIOD Now <sil=0.551> ,COMMA I have just hidden the part of the stack that was used for main and let us focus just on the factorial function <sil=0.930> .PERIOD This computes the factorial function that we are familiar with <sil=0.921> .PERIOD There is nothing new here <sil=0.936> .PERIOD So <sil=0.627> ,COMMA it has a variable i which keeps track of how many times it has the loop has executed and r is notice 4 <sil=0.954> .PERIOD So <sil=0.505> ,COMMA you compute the factorial of 4 <sil=0.928> .PERIOD Finally <sil=0.530> ,COMMA when r equal to 4 answer equal to 24 <sil=0.979> .PERIOD Now <sil=0.640> ,COMMA this 24 value <sil=0.468> ,COMMA we say return the answer value <sil=0.923> .PERIOD So <sil=0.567> ,COMMA answer value is 24 <sil=0.977> .PERIOD So <sil=0.395> ,COMMA this will be copied to the return value location <sil=0.953> .PERIOD Return value location <sil=0.997> .PERIOD So <sil=0.528> ,COMMA the return value will get the value 24 and now jump back to return address <sil=0.923> .PERIOD So <sil=0.482> ,COMMA return address is line 5 <sil=0.940> .PERIOD So <sil=0.419> ,COMMA we will jump back to line 5 and there we will say that t 1 equal to 24 <sil=0.969> .PERIOD Only the return value is equal to 24 <sil=0.941> .PERIOD So <sil=0.479> ,COMMA this is the return value is copied back to the main program <sil=0.929> .PERIOD All other things are irrelevant <sil=0.971> .PERIOD So <sil=0.554> ,COMMA the correct way to imagine what happens when a function has returned is that the stack that was allocated to main to the execution of fact is completely erased <sil=0.940> .PERIOD So <sil=0.469> ,COMMA once you go back to main as soon as the function returns back to the main <sil=0.585> ,COMMA you should imagine that the entire stack is deleted and only the memory that was originally allocated to main remains <sil=0.946> .PERIOD So <sil=0.446> ,COMMA the correct way to think about a function executing <sil=0.384> ,COMMA you can imagine that you are main and you have a friend who can calculate factorial for you <sil=0.956> .PERIOD Now <sil=0.559> ,COMMA you can ask your friend to calculate factorial for you and things are done in a very hygienic manner <sil=0.997> .PERIOD So <sil=0.381> ,COMMA what you do is you write on a piece of paper the number 4 and give it to your friend <sil=0.916> .PERIOD Now <sil=0.578> ,COMMA your friend is another room <sil=0.985> .PERIOD So <sil=0.417> ,COMMA he has at his disposal some blackboard <sil=0.986> .PERIOD So <sil=0.505> ,COMMA he looks at the number 4 and using the private local variables that he has which is I and result or answer <sil=0.589> ,COMMA he calculates the factorial of these numbers <sil=0.955> .PERIOD Once he does that <sil=0.455> ,COMMA he copies the result back onto a piece of paper <sil=0.974> .PERIOD So <sil=0.346> ,COMMA 4 factorial is 24 and brings it back to you <sil=0.901> .PERIOD Before he does that <sil=0.640> ,COMMA he raises his blackboard and he will bring back the number 24 on a piece of paper <sil=0.966> .PERIOD Now <sil=0.428> ,COMMA you can imagine that the space that your friend used to compute 24 has now been wiped clean and all that remains is the value 24 which you can copy back into onto your notebook <sil=0.993> .PERIOD So <sil=0.556> ,COMMA this allegory tells you exactly what happens in the case of a function execution <sil=0.986> .PERIOD You write down what you want the factorial of on a piece of paper <sil=0.584> ,COMMA pass it to your friend <sil=0.387> ,COMMA he will go to a separate room and he will calculate whatever he wants <sil=0.980> .PERIOD Once he does that <sil=0.519> ,COMMA he will clean his blackboard <sil=0.399> ,COMMA write down the result on a piece of paper and bring that paper back to you <sil=0.922> .PERIOD So <sil=0.319> ,COMMA as far as you are concerned <sil=0.535> ,COMMA you are least bothered with how he is computing the factorial function <sil=0.385> ,COMMA all you want is the result and this is the basic way to think about functions <sil=0.986> .PERIOD You should be able to reason out a bigger program by saying what does a smaller program <sil=0.427> ,COMMA what does a smaller function do regardless of how that function does it <sil=0.989> .PERIOD Now <sil=0.380> ,COMMA let us get on with the remaining execution <sil=0.987> .PERIOD We have just computed factorial of 4 <sil=0.946> .PERIOD Now <sil=0.358> ,COMMA we need to calculate factorial of 2 and factorial of 4 minus 2 <sil=0.991> .PERIOD So <sil=0.377> ,COMMA we go to the next line <sil=0.631> ,COMMA the next line also involves a call to factorial of k <sil=0.956> .PERIOD So <sil=0.533> ,COMMA we do the same things again <sil=0.461> ,COMMA we save the return address <sil=0.998> .PERIOD Now <sil=0.633> ,COMMA the return address is 6 because we are executing line 6 <sil=0.617> ,COMMA then we create a box for the return value and pass the parameters and finally <sil=0.353> ,COMMA jump to the called function <sil=0.997> .PERIOD So <sil=0.554> ,COMMA we do all that <sil=0.432> ,COMMA we have some memory for the main <sil=0.518> ,COMMA but we allocate a new stack <sil=0.413> ,COMMA new space in the stack for executing factorial <sil=0.975> .PERIOD At this point <sil=0.363> ,COMMA return address is 6 because it is a second factorial that is being called R is 2 because k is 2 and you execute the factorial function <sil=0.994> .PERIOD So <sil=0.475> ,COMMA you again go to the factorial function and calculate 2 factorial <sil=0.610> ,COMMA 2 factorial is 2 <sil=0.943> .PERIOD So <sil=0.637> ,COMMA that will be transferred back to the return value and now <sil=0.560> ,COMMA you can imagine that you will get back to the address 6 where t 2 will have the value 2 <sil=0.934> .PERIOD So <sil=0.308> ,COMMA once you do that <sil=0.537> ,COMMA again the thing to imagine is that this slit is wiped clean and all the memory that you allocated to the stack is now free <sil=0.952> .PERIOD So <sil=0.462> ,COMMA once you are back in main <sil=0.550> ,COMMA all you have is the memory for me <sil=0.997> .PERIOD Now <sil=0.611> ,COMMA there is a third call to factorial <sil=0.346> ,COMMA factorial of n minus k and it is done in exactly the same manner <sil=0.959> .PERIOD So <sil=0.645> ,COMMA without much elaboration <sil=0.616> ,COMMA so it will create n minus k is 4 minus 2 which is also 2 and the return address is 7 <sil=0.938> .PERIOD Here is an n and once you do that <sil=0.500> ,COMMA it will execute the factorial code again and calculate the factorial of 2 which is again 2 <sil=0.906> .PERIOD So <sil=0.365> ,COMMA this is the return and return to line 7 <sil=0.904> .PERIOD So <sil=0.594> ,COMMA 2 will be copied as the return value and once the execution finishes <sil=0.573> ,COMMA you return to line 7 of the main program <sil=0.987> .PERIOD At this point <sil=0.419> ,COMMA you say that t 3 equal to 2 and you can imagine that the stack allocated to factorial is now erased <sil=0.976> .PERIOD So <sil=0.327> ,COMMA at this point <sil=0.561> ,COMMA main has t 1 equal to 24 <sil=0.587> ,COMMA t 2 equal to 2 and t 3 equal to 2 <sil=0.996> .PERIOD You have all the information that you need in order to calculate your result <sil=0.952> .PERIOD So <sil=0.545> ,COMMA you calculate 24 divided by 2 divided by 2 and the answer is 6 which is 4 choose 2 <sil=0.999> .PERIOD So <sil=0.519> ,COMMA this illustrates how do you write a function <sil=0.636> ,COMMA how do you define a function and how do you call it and what actually happens when you execute a function <sil=0.949> .PERIOD So <sil=0.360> ,COMMA the execution of a function can be visualized as a stack <sil=0.904> .PERIOD A stack is a part of memory that is allocated as private to a new function that is being called <sil=0.950> .PERIOD Once that function finishes execution <sil=0.468> ,COMMA the stack is erased and you go back to the previous function and you go back to the calling function <sil=0.967> .PERIOD So <sil=0.445> ,COMMA when we extend the sequence we do not have to do anything special <sil=0.308> ,COMMA when we break a sequence and we start a new sequence then all we have to do is you check whether the currently say the sequence that you just saw was longer than the previously known longest sequence <sil=0.917> .PERIOD If that is the case then the sequence that just ended is becoming the longer sequence that you long a sequence we have seen so far otherwise you maintain the max length just forget about the currently stop sequence <sil=0.904> .PERIOD Now <sil=0.574> ,COMMA there is a so that is this loop and at the end we have to do a slight tricky logic it could so happen that the sequence ends with the longest increasing sub sequence in that case we will never reset the max length <sil=0.998> .PERIOD So <sil=0.302> ,COMMA if the last sequence is the longest you also have to handle the case separately <sil=0.978> .PERIOD So <sil=0.608> ,COMMA we will see an example where if you exit out of the loop that is you have already seen a minus 1 you just have to check whether the last increasing sequence that you saw was in fact the longest <sil=0.949> .PERIOD So <sil=0.622> ,COMMA there is a small if block at the end to do that in this part we will just see a small tracing of this program on a sample input <sil=0.906> .PERIOD So <sil=0.648> ,COMMA that the logic of the program becomes slightly more clear <sil=0.914> .PERIOD So <sil=0.438> ,COMMA I have picked a particular input 3 2 1 3 5 minus 1 and you will see that the longest increasing sequences are 3 <sil=0.972> .PERIOD So <sil=0.390> ,COMMA the increasing sequences are 3 then 2 then 1 3 5 <sil=0.985> .PERIOD So <sil=0.363> ,COMMA 1 3 5 is going to be the longest increasing sub sequence and let us see how our program will find that out <sil=0.967> .PERIOD So <sil=0.612> ,COMMA initially you have a bunch of variables which you declare <sil=0.960> .PERIOD So <sil=0.638> ,COMMA length is 0 max length is 0 and previous and current are undefined then you first read previous <sil=0.947> .PERIOD So <sil=0.482> ,COMMA previous becomes 3 it is not minus 1 <sil=0.902> .PERIOD So <sil=0.643> ,COMMA you enter the if condition at which point you set length and max length to 1 <sil=0.984> .PERIOD Now <sil=0.614> ,COMMA you scan the current number <sil=0.988> .PERIOD So <sil=0.331> ,COMMA current becomes 2 <sil=0.961> .PERIOD So <sil=0.441> ,COMMA remember that previous is now 3 and current is 2 <sil=0.954> .PERIOD So <sil=0.397> ,COMMA current is not minus 1 therefore <sil=0.515> ,COMMA you enter the while loop previous is less than current is false because previous is 3 and current is 2 <sil=0.953> .PERIOD Therefore <sil=0.624> ,COMMA you enter the L spot max length less than length is false both are 1 <sil=0.961> .PERIOD Therefore <sil=0.488> ,COMMA you start a new sequence with length equal to 1 <sil=0.936> .PERIOD Now <sil=0.496> ,COMMA you continue the loop with previous becoming current <sil=0.961> .PERIOD So <sil=0.436> ,COMMA previous is now the now 2 and current you read the next number which is 1 <sil=0.993> .PERIOD So <sil=0.631> ,COMMA previous and current have both moved one step <sil=0.950> .PERIOD So <sil=0.340> ,COMMA current is not minus 1 previous less than current is again false because 2 is greater than 1 <sil=0.956> .PERIOD So <sil=0.340> ,COMMA you enter the L spot max length and length there is no change <sil=0.913> .PERIOD So <sil=0.360> ,COMMA you reset the length to 1 previous is current <sil=0.971> .PERIOD So <sil=0.366> ,COMMA current previous becomes 1 and you scan the next number which is 3 <sil=0.913> .PERIOD Now <sil=0.536> ,COMMA at this point previous is 1 and current is 3 <sil=0.913> .PERIOD So <sil=0.483> ,COMMA the if condition is true <sil=0.983> .PERIOD So <sil=0.516> ,COMMA you extend the length length increases by 1 <sil=0.997> .PERIOD Again your advance previous and current <sil=0.933> .PERIOD So <sil=0.563> ,COMMA previous becomes 3 current becomes 5 again 3 is less than 5 <sil=0.939> .PERIOD So <sil=0.457> ,COMMA increase the length we are extending the sequence <sil=0.939> .PERIOD So <sil=0.456> ,COMMA the length becomes 3 advance <sil=0.932> .PERIOD So <sil=0.567> ,COMMA previous becomes 5 and current becomes minus 1 at this point you exit the loop <sil=0.990> .PERIOD And now <sil=0.590> ,COMMA you encounter the situation that max length which is the length that we have seen so far recall that it is 1 <sil=0.970> .PERIOD But the length of the sequence that we just stop the input with is 3 <sil=0.903> .PERIOD That is that happened because the longest increasing continuous subsequence the was at the end of the input <sil=0.965> .PERIOD So <sil=0.615> ,COMMA it happened right at the end <sil=0.949> .PERIOD So <sil=0.533> ,COMMA when we exit the loop we have to do one additional check <sil=0.911> .PERIOD We cannot simply say that the maximum length that we have seen in the sequences 1 because max length is the length of the longest sequence we have seen before the current one <sil=0.978> .PERIOD The current one was the one that we just stopped with it had a length of 3 <sil=0.954> .PERIOD So <sil=0.319> ,COMMA we just check if max length equal to length is less than the length then you set max length to be the length <sil=0.961> .PERIOD So <sil=0.629> ,COMMA once you do that max length becomes 3 <sil=0.936> .PERIOD This is just to handle the case when the longest increasing subsequence is the last <sil=0.992> .PERIOD Now <sil=0.500> ,COMMA you can exit out of the if condition and then print that the maximum length that you have seen is 3 <sil=0.976> .PERIOD In this session <sil=0.587> ,COMMA we will see a very popular loop construct in C <sil=0.995> .PERIOD We have already seen while loops and do while loops <sil=0.916> .PERIOD We will see that do while loops are not all that common in C code when C program is code <sil=0.992> .PERIOD Among the most popular loop constructs in C is this for loop <sil=0.925> .PERIOD So <sil=0.326> ,COMMA let us see what it stands for <sil=0.955> .PERIOD The expression for the general form of the false statement is slightly more complex than that of a while loop <sil=0.940> .PERIOD While loop was very simple <sil=0.527> ,COMMA while a certain expression was true <sil=0.357> ,COMMA you execute the statement and when the statement <sil=0.329> ,COMMA when the expression becomes false <sil=0.625> ,COMMA you exit out of the loop <sil=0.946> .PERIOD For loop is slightly more complex <sil=0.933> .PERIOD So <sil=0.443> ,COMMA it has the following components <sil=0.307> ,COMMA it has an initialization expression <sil=0.588> ,COMMA then the test expression <sil=0.508> ,COMMA this is the expression corresponding to the expression inside the while loop and then there is an update expression followed by the loop statement <sil=0.963> .PERIOD This looks complex at first <sil=0.626> ,COMMA but it is quite intuitive once you start using it <sil=0.919> .PERIOD The execution is as follows <sil=0.504> ,COMMA first you execute the initialization expression <sil=0.300> ,COMMA then you test whether the test expression is true or not <sil=0.947> .PERIOD If the test expression is true <sil=0.388> ,COMMA you execute the statement and then come back and execute the update expression <sil=0.979> .PERIOD After you execute the update expression <sil=0.555> ,COMMA go back to step 2 <sil=0.388> ,COMMA which is go to the test expression <sil=0.918> .PERIOD So <sil=0.490> ,COMMA any expression is the initialization expression <sil=0.327> ,COMMA update expression is the update expression and test expression is the expression that is evaluates to either true or false <sil=0.949> .PERIOD So <sil=0.390> ,COMMA if you look at the flow of how the code goes <sil=0.593> ,COMMA then it is first you start from the initialization expression <sil=0.383> ,COMMA then you go to this <sil=0.366> ,COMMA first you start with the initialization expression <sil=0.592> ,COMMA then you go to the test expression <sil=0.982> .PERIOD If the test expression is true <sil=0.397> ,COMMA you go to the statement <sil=0.429> ,COMMA then you go to the update expression and you go to the test expression again <sil=0.934> .PERIOD So <sil=0.502> ,COMMA the loop is here <sil=0.429> ,COMMA you test the expression <sil=0.310> ,COMMA execute the statement <sil=0.357> ,COMMA update and test again <sil=0.980> .PERIOD Initialization is done only once <sil=0.936> .PERIOD So <sil=0.518> ,COMMA this is the first step and here is the loop <sil=0.962> .PERIOD So <sil=0.514> ,COMMA this sounds a bit complex at first <sil=0.484> ,COMMA but it is quite simple to use once you get the hang of it <sil=0.975> .PERIOD So <sil=0.553> ,COMMA the execution of the for loop can be understood in terms of the while loop <sil=0.974> .PERIOD The execution of the for loop is almost equivalent to the following while loop <sil=0.925> .PERIOD You have the initialization expression before the while loop <sil=0.634> ,COMMA then the test expression <sil=0.540> ,COMMA while test expression <sil=0.417> ,COMMA then you have statement and then you have the update expression <sil=0.938> .PERIOD So <sil=0.456> ,COMMA if you have a for loop <sil=0.336> ,COMMA you can write the equivalent code using while loop <sil=0.945> .PERIOD So <sil=0.371> ,COMMA if you say that I do not want to use for loops <sil=0.348> ,COMMA here is how you have a for loop and you can write the equivalent while loop in the following way or if you have a while loop <sil=0.598> ,COMMA you can write a equivalent for loop by looking at this form and how it is translated to corresponding for loop <sil=0.925> .PERIOD Now <sil=0.451> ,COMMA there why did I say execution is almost equivalent <sil=0.986> .PERIOD We will see this later in the course <sil=0.416> ,COMMA whenever there is a continuous statement or a break statement <sil=0.627> ,COMMA you will see that we need to modify this equivalence between the for loop and the while loop <sil=0.977> .PERIOD But for now <sil=0.630> ,COMMA with the features of c that we have seen so far <sil=0.515> ,COMMA the for loop is equivalent to the while loop and we will have to modify this slightly later <sil=0.995> .PERIOD So <sil=0.341> ,COMMA the any expression maps to the first part of the while loop of the for loop <sil=0.451> ,COMMA the test expression maps to the second part and the update expression maps to the third part <sil=0.909> .PERIOD One important thing to notice is that the update expression is after the statement <sil=0.904> .PERIOD So <sil=0.372> ,COMMA we have the following <sil=0.317> ,COMMA first <sil=0.427> ,COMMA we execute the initialization expression <sil=0.435> ,COMMA then we test whether the state expression is true <sil=0.948> .PERIOD If it is true you execute the statement <sil=0.427> ,COMMA update expression and then again go to the test expression <sil=0.974> .PERIOD If it is true <sil=0.306> ,COMMA you execute statement update and then test again <sil=0.958> .PERIOD So <sil=0.525> ,COMMA you initialize the expression <sil=0.479> ,COMMA then when the test the test expression <sil=0.529> ,COMMA if it is true <sil=0.414> ,COMMA you execute the statement after the statement is true <sil=0.481> ,COMMA after the statement is executed you update the expression and go back to the test expression because that is how you execute it in the while loop <sil=0.948> .PERIOD You first initialize then test whether it is true execute the statement update and then go back to the test expression <sil=0.901> .PERIOD So <sil=0.497> ,COMMA this is how a while loop can be translated to a fault loop and vice versa <sil=0.940> .PERIOD So <sil=0.400> ,COMMA let us do some examples a very simple thing let us say that print the sum of reciprocals of the first 100 natural numbers <sil=0.970> .PERIOD So <sil=0.470> ,COMMA what do I want to do I want to do the following I want to do 1 plus 1 over 2 plus 1 over 3 plus etcetera up to 1 over 100 <sil=0.996> .PERIOD So <sil=0.456> ,COMMA how would I do it I would initialize a variable called sum sum will be initialize to 1 and then to sum I will add 1 over 2 then I to that I will add 1 over 3 and keep on going until 1 over 100 <sil=0.985> .PERIOD So <sil=0.610> ,COMMA let us see how to code this in C using the for loop <sil=0.911> .PERIOD So <sil=0.501> ,COMMA I have a variable called reciprocal sum and even though I am summing over integers you know that the reciprocal numbers will be real numbers <sil=0.939> .PERIOD So <sil=0.494> ,COMMA in order to keep the reciprocal sum I need a floating point number floating point variable and then I have an integer variable which goes from 1 to 100 <sil=0.965> .PERIOD So <sil=0.331> ,COMMA here is how I will do the loop first initialize I to 1 if I is less than or equal to 100 you enter the loop and do reciprocal sum equal to the current reciprocal sum plus 1 over I <sil=0.945> .PERIOD After doing that you update by saying I equal to I plus 1 <sil=0.965> .PERIOD So <sil=0.421> ,COMMA increment I once the increment is done you test whether the new number is less than or equal to 100 <sil=0.971> .PERIOD If it is less than or equal to 100 you do the reciprocal sum come back update until you reach 101 <sil=0.940> .PERIOD At the point where you reach 101 you test whether I is less than or equal to 100 that becomes false and you exit <sil=0.932> .PERIOD So <sil=0.603> ,COMMA you will see that when you exit out of the loop the reciprocal sum will be the sum of reciprocals of numbers from 1 to 100 <sil=0.931> .PERIOD So <sil=0.304> ,COMMA here is how the for loop functions <sil=0.916> .PERIOD So <sil=0.544> ,COMMA instead of 100 let us try to execute it on a particularly very small number to see how this for loop executes <sil=0.977> .PERIOD So <sil=0.563> ,COMMA let us instead of summing from 1 to 100 let us sum from 1 to 4 <sil=0.919> .PERIOD So <sil=0.446> ,COMMA first you have the initialization expression <sil=0.921> .PERIOD So <sil=0.602> ,COMMA I is undefined before you enter the while loop reciprocal sum is of course <sil=0.636> ,COMMA initialized to 0 <sil=0.973> .PERIOD So <sil=0.610> ,COMMA I can after initialization I will be 1 as soon as it is initialized we will test whether it is less than or equal to 4 <sil=0.910> .PERIOD One is less than or equal to 4 that is true <sil=0.911> .PERIOD So <sil=0.570> ,COMMA you will enter the while loop you will enter the for loop <sil=0.913> .PERIOD Then you add to the reciprocal sum 1 over I <sil=0.372> ,COMMA I is 1 <sil=0.914> .PERIOD So <sil=0.324> ,COMMA 1 over 1 is 1 <sil=0.985> .PERIOD So <sil=0.379> ,COMMA reciprocal sum will be updated to reciprocal sum plus 1 <sil=0.962> .PERIOD So <sil=0.560> ,COMMA reciprocal sum would be 1 <sil=0.994> .PERIOD Then you go to the update expression <sil=0.943> .PERIOD At this point you have I equal to I plus 1 <sil=0.978> .PERIOD So <sil=0.511> ,COMMA I becomes 2 <sil=0.984> .PERIOD Now <sil=0.495> ,COMMA test whether I is less than or equal to 4 yes it is and enter the loop <sil=0.946> .PERIOD So <sil=0.548> ,COMMA 1 plus 0 <sil=0.916> .PERIOD 5 then go back to the update expression I becomes 3 now and test whether 3 is less than or equal to 4 it is <sil=0.902> .PERIOD So <sil=0.418> ,COMMA enter the loop <sil=0.997> .PERIOD So <sil=0.517> ,COMMA you add 1 <sil=0.962> .PERIOD 5 plus 1 over 3 1 <sil=0.926> .PERIOD 833 and so on <sil=0.903> .PERIOD Update again you have 4 <sil=0.631> ,COMMA 4 is less than or equal to 4 that is true <sil=0.933> .PERIOD So <sil=0.411> ,COMMA you enter the loop 1 more time and add 1 over 4 <sil=0.922> .PERIOD 25 to the current number <sil=0.906> .PERIOD So <sil=0.343> ,COMMA you get 2 <sil=0.946> .PERIOD 0833 and so on <sil=0.965> .PERIOD Update again I becomes 5 <sil=0.946> .PERIOD At this point 5 is not less than or equal to 4 <sil=0.970> .PERIOD So <sil=0.602> ,COMMA you exit out of the for loop <sil=0.909> .PERIOD Now <sil=0.415> ,COMMA you say that print that the sum of reciprocals from 1 to 4 is reciprocal sum which is 2 <sil=0.990> .PERIOD 0833 <sil=0.903> .PERIOD So <sil=0.342> ,COMMA even though the for loop looks complicated once you start using it it is very nice to write you have an initialization expression you have a test expression and then you have the update expression that you should do after every execution of the loop <sil=0.936> .PERIOD After every iteration you should have the update expression <sil=0.975> .PERIOD As soon as the update is over you test whether I can execute the loop one more time <sil=0.953> .PERIOD If I can enter the loop update and test again and so on until the loop condition is false <sil=0.901> .PERIOD Let us take another example <sil=0.542> .PERIOD You have 2 lines the first line contains a single number m which specifies how many numbers are there in the second line <sil=0.975> .PERIOD The second line contains m integers and we have to just output the sum of the m numbers <sil=0.991> .PERIOD Now <sil=0.586> ,COMMA we know how to do this we have already done this using a void loop <sil=0.913> .PERIOD Let us try to do it using a for loop <sil=0.972> .PERIOD So <sil=0.497> ,COMMA the sample input is let us say the first line is 5 and then I have 5 integers on the second line <sil=0.960> .PERIOD The strategy is very simple you read the number on the first line into m and then have a variable called sum which is which will start with the first number and keep on adding the subsequent numbers until you have read m numbers <sil=0.931> .PERIOD Initialize sum to 0 <sil=0.916> .PERIOD So <sil=0.349> ,COMMA run a for loop from the first number to the mth number and keep adding the numbers to sum <sil=0.928> .PERIOD So <sil=0.548> ,COMMA this loop will run for m times <sil=0.994> .PERIOD So <sil=0.490> ,COMMA let us code this up you have m i sum and numbers which are all integers <sil=0.988> .PERIOD First you scan the number m initialize sum to 0 this is important because if sum is not properly initialized it is some garbage value and you keep adding numbers to it you will get garbage value as the output <sil=0.913> .PERIOD So <sil=0.468> ,COMMA initialize the number sum to properly to 0 and then here is the for loop what the for loop does is you start with i equal to 0 and go on until i less than m <sil=0.987> .PERIOD Now <sil=0.455> ,COMMA you could also do the following you could start with i equal to 1 and go on until exactly m <sil=0.968> .PERIOD So <sil=0.465> ,COMMA if you start with i equal to 1 you will say i less than or equal to m you can adopt either convention in c it is more popular to start from 0 and go on until m minus 1 <sil=0.901> .PERIOD So <sil=0.448> ,COMMA you break the loop when i is equal to m <sil=0.903> .PERIOD So <sil=0.320> ,COMMA here is the test condition for the loop and then you have the loop body which is you read the number and add the number to sum and after you have done that you have the update expression which is i equal to i plus 1 <sil=0.969> .PERIOD So <sil=0.482> ,COMMA here is how the for loop looks you start from 0 and go on until i becomes m you add the number and just increment i which is i is the number of integers we have seen so far <sil=0.965> .PERIOD Let us do a trace of this execution you start you have this integer variables and you first read m which is 5 the number on the first line and then we do things in order you have initialized sum to 0 you start with i equal to 0 you once you do the initialization expression i become 0 i is less than m 0 is less than 5 that is fine <sil=0.948> .PERIOD So <sil=0.437> ,COMMA you execute the loop scan the next number which is 2 add it to the sum <sil=0.910> .PERIOD So <sil=0.313> ,COMMA sum becomes 2 now update update is increment i so i becomes 1 and test whether 1 is less than 5 it is so you read the next number add it to the sum so the sum becomes 1 update again and keep repeating this <sil=0.986> .PERIOD Until you have read all 5 numbers so when you read the fifth number i will be 4 after that you add the fifth number to the summation once you are done i will be incremented to 5 5 is not less than 5 5 is equal to 5 so you will exit out of the loop <sil=0.927> .PERIOD At this point you will you will have the correct sum so the correct sum will be 25 and you exit out <sil=0.963> .PERIOD So <sil=0.535> ,COMMA the printf will come out on one line it will say that the sum of given fine numbers is 25 <sil=0.954> .PERIOD So <sil=0.490> ,COMMA what I will recommend is write the same program using a while loop and a for loop and see how you can easily go from while to for and for to while <sil=0.903> .PERIOD The advantage of the for loop and the reason why for loop becomes so popular among programmers is that in comparison to the while loop it is first of all it is easier to read because you have all the initialization expression the update expression and the test expression all on one line <sil=0.991> .PERIOD So <sil=0.541> ,COMMA you see what the loop is about the second is that it involves fewer lines of code than the corresponding while loop <sil=0.939> .PERIOD So <sil=0.626> ,COMMA it is a very popular loop among programmers <sil=0.935> .PERIOD Now <sil=0.601> ,COMMA here is a syntactic convenience that see provides us and let me make this remark as the final thing in this session <sil=0.925> .PERIOD So <sil=0.535> ,COMMA notice that we had to initialize two variables here <sil=0.959> .PERIOD So <sil=0.407> ,COMMA the first is sum was initialized to 0 and the second was that I was initialized to 0 <sil=0.964> .PERIOD Now <sil=0.599> ,COMMA would it be convenient if I could do this together and that is what see provides us <sil=0.913> .PERIOD So <sil=0.563> ,COMMA I have something known as the comma operator <sil=0.976> .PERIOD So <sil=0.510> ,COMMA the the normal comma that we have seen <sil=0.938> .PERIOD So <sil=0.455> ,COMMA in order to initialize multiple variables at the same time I can say sum equal to 0 comma I equal to 0 <sil=0.989> .PERIOD So <sil=0.406> ,COMMA C will initialize the variables in the order that it was given <sil=0.995> .PERIOD First it will initialize sum to 0 and then it will initialize the I equal to 0 <sil=0.950> .PERIOD So <sil=0.422> ,COMMA here is a very syntactically convenient notation that see provides for us <sil=0.959> .PERIOD The advantage again is that you end up with fewer lines of code <sil=0.993> .PERIOD So <sil=0.353> ,COMMA here is a very simple example <sil=0.987> .PERIOD So <sil=0.591> ,COMMA here is a very simple example <sil=0.995> .PERIOD So <sil=0.384> ,COMMA here is a very simple example <sil=0.993> .PERIOD So <sil=0.545> ,COMMA here is a very simple example <sil=0.992> .PERIOD So <sil=0.585> ,COMMA here is a very simple example <sil=0.986> .PERIOD So <sil=0.410> ,COMMA here is a very simple example <sil=0.976> .PERIOD So <sil=0.324> ,COMMA here is a very simple example <sil=0.999> .PERIOD So <sil=0.370> ,COMMA here is a very simple example <sil=0.990> .PERIOD So <sil=0.508> ,COMMA in this video we will talk about how pre increment <sil=0.648> ,COMMA post increment and operators like that work in C <sil=0.980> .PERIOD So <sil=0.348> ,COMMA we will first introduce the notion of side effects <sil=0.999> .PERIOD Now <sil=0.447> ,COMMA we have earlier seen that any expression in C yields a certain value <sil=0.923> .PERIOD So <sil=0.330> ,COMMA let us look at a particular example <sil=0.506> ,COMMA if you have integer variables i and j i is assigned to 1 and then you say that j is assigned to i plus 1 <sil=0.940> .PERIOD What happens is that you take the value of i add 1 to it and then resulting value is the result of the expression i plus 1 <sil=0.990> .PERIOD So <sil=0.585> ,COMMA the result of the expression will be 2 which is assigned to j <sil=0.978> .PERIOD The value of i itself is unchanged due to an expression like i plus 1 <sil=0.967> .PERIOD It is just that you read the value of a <sil=0.577> ,COMMA use it and then return the value of i plus 1 <sil=0.972> .PERIOD Now <sil=0.509> ,COMMA some expressions in C also change the variables involved in them <sil=0.917> .PERIOD For example <sil=0.484> ,COMMA if you have a code like int i <sil=0.550> ,COMMA let us say i is initialized to 1 in j and then you say j equal to plus plus i <sil=0.966> .PERIOD In this case <sil=0.576> ,COMMA what happens is that you take the value of i <sil=0.320> ,COMMA increment it <sil=0.936> .PERIOD So <sil=0.624> ,COMMA you will get i equal to 2 and then that incremented value is then assigned to j <sil=0.919> .PERIOD So <sil=0.426> ,COMMA evaluating the expression plus plus i has the side effect that i becomes 2 <sil=0.920> .PERIOD So <sil=0.436> ,COMMA it not only takes the value of i increments it by 1 and gives it to j <sil=0.977> .PERIOD It also has the additional effect that i's value is incremented <sil=0.904> .PERIOD So <sil=0.423> ,COMMA contrast the first example and the second example <sil=0.954> .PERIOD In the first example <sil=0.389> ,COMMA when you said i plus 1 <sil=0.339> ,COMMA the value of i was unchanged and in the second when you said plus plus i <sil=0.519> ,COMMA the value of i is changed <sil=0.966> .PERIOD So <sil=0.447> ,COMMA this is known as a side effect because in addition to returning the value <sil=0.615> ,COMMA it also changes the variable involved in plus plus i <sil=0.944> .PERIOD So <sil=0.593> ,COMMA now <sil=0.596> ,COMMA let us look at this operation in slightly more detail <sil=0.982> .PERIOD So <sil=0.647> ,COMMA when you say in i equal to 1 in j and then j equal to plus plus i <sil=0.334> ,COMMA the effect of this plus plus i can be understood in terms of an equivalent code <sil=0.982> .PERIOD So <sil=0.562> ,COMMA what you do is consider a code where you have i equal to i plus 1 and then assign j equal to i <sil=0.934> .PERIOD So <sil=0.589> ,COMMA in this case i will become 2 after i equal to i plus 1 and then j will be assigned the value 2 <sil=0.973> .PERIOD So <sil=0.454> ,COMMA this is the effect of the pre-increment operation <sil=0.995> .PERIOD So <sil=0.324> ,COMMA pre-increment operation is calls <sil=0.929> .PERIOD So <sil=0.495> ,COMMA because before you use the value of i <sil=0.424> ,COMMA you would increment the value of i <sil=0.953> .PERIOD So <sil=0.383> ,COMMA that is one way of understanding this and these two codes are equivalent in effect <sil=0.928> .PERIOD There is a slightly different way of writing this <sil=0.540> ,COMMA which is a short form for writing i equal to i plus 1 <sil=0.910> .PERIOD So <sil=0.650> ,COMMA instead of doing this <sil=0.529> ,COMMA you can say i plus equal to 1 <sil=0.984> .PERIOD So <sil=0.480> ,COMMA plus equal to 1 says that says the effect i equal to i plus 1 <sil=0.962> .PERIOD So <sil=0.448> ,COMMA it is a short form of writing it <sil=0.996> .PERIOD So <sil=0.509> ,COMMA all these codes are have equivalent effect <sil=0.902> .PERIOD So <sil=0.451> ,COMMA it is called plus plus i is called a pre-increment operator because before you use the value of i <sil=0.642> ,COMMA it is values incremented <sil=0.987> .PERIOD Now <sil=0.584> ,COMMA there is also the post increment operator <sil=0.929> .PERIOD So <sil=0.355> ,COMMA plus plus i is an example of an X minus expression with the pre-increment operation and you can also use i plus plus <sil=0.496> ,COMMA which is known as the post increment operation <sil=0.994> .PERIOD And the confusing thing is how do we interpret fairly complicated expressions like the following <sil=0.978> .PERIOD So <sil=0.529> ,COMMA suppose you have int i equal to 1 in j and then j equal to i plus plus plus plus plus i <sil=0.901> .PERIOD So <sil=0.466> ,COMMA what should we expect in this case is this allowed behavior <sil=0.632> ,COMMA what does it mean <sil=0.944> ?QUESTIONMARK What will be the result <sil=0.546> ,COMMA which is stored in j <sil=0.999> .PERIOD So <sil=0.622> ,COMMA let us look at these things in slightly greater detail <sil=0.971> .PERIOD So <sil=0.540> ,COMMA first let us look at some simple examples and try to understand the behavior <sil=0.926> .PERIOD So <sil=0.389> ,COMMA suppose you have i equal to 1 and then 2 variables j and k and first you say int i in j equal to i plus plus <sil=0.976> .PERIOD So <sil=0.349> ,COMMA this is the post increment operator <sil=0.965> .PERIOD So <sil=0.515> ,COMMA what happens here is that you take the value of i <sil=0.302> ,COMMA assign it to j <sil=0.913> .PERIOD So <sil=0.442> ,COMMA that is i equal to 1 <sil=0.450> ,COMMA the current value of i will be assigned to j and after the expression is over i will be incremented <sil=0.998> .PERIOD So <sil=0.304> ,COMMA then i will become 2 <sil=0.521> ,COMMA the old value of i is assigned to j and then the value of i will be incremented <sil=0.981> .PERIOD So <sil=0.586> ,COMMA it is the post increment operator <sil=0.996> .PERIOD So <sil=0.587> ,COMMA when you print f i and j here i will be 2 and j will be 1 because the old value of j <sil=0.493> ,COMMA old value of i was what was stored in j <sil=0.970> .PERIOD Now <sil=0.619> ,COMMA let us look at plus plus i <sil=0.905> .PERIOD So <sil=0.563> ,COMMA if you say k equal to plus plus i <sil=0.463> ,COMMA i is now 2 when it starts and you pre-increpan i <sil=0.988> .PERIOD So <sil=0.552> ,COMMA you increment i <sil=0.645> ,COMMA i becomes 3 and that value is stored in k <sil=0.969> .PERIOD So <sil=0.344> ,COMMA it is the pre-increpan operator <sil=0.969> .PERIOD So <sil=0.346> ,COMMA the value will be incremented before the assignment will take place <sil=0.952> .PERIOD So <sil=0.543> ,COMMA when you print i and k <sil=0.578> ,COMMA i will be 3 and k will also be 3 <sil=0.926> .PERIOD So <sil=0.424> ,COMMA notice the difference between the first case and the second case <sil=0.497> ,COMMA the pre-increpan versus the post increment <sil=0.928> .PERIOD Now <sil=0.623> ,COMMA let us look at slightly more complicated example <sil=0.965> .PERIOD So <sil=0.421> ,COMMA at this point what do we have <sil=0.884> ?QUESTIONMARK We have i equal to 3 and j equal to 1 at this point and then you say k equal to plus plus i plus j plus plus <sil=0.939> .PERIOD So <sil=0.495> ,COMMA take a minute and think about what will happen here <sil=0.912> .PERIOD You pre-increment i <sil=0.944> .PERIOD So <sil=0.325> ,COMMA the value of this expression that is used to add will be 4 because the value of i will be incremented before it is used in the plus expression <sil=0.928> .PERIOD Whereas <sil=0.416> ,COMMA this is the post increment expression <sil=0.994> .PERIOD So <sil=0.574> ,COMMA the value of j <sil=0.343> ,COMMA the old value of j will be used and then j will be incremented <sil=0.993> .PERIOD So <sil=0.362> ,COMMA here the value that will be used will be 4 and here the value that will be used will be the old value of j which is 1 <sil=0.908> .PERIOD So <sil=0.528> ,COMMA k will be 4 plus 1 which is 5 <sil=0.925> .PERIOD I will be incremented <sil=0.958> .PERIOD So <sil=0.522> ,COMMA i becomes 4 and after this expression is over <sil=0.460> ,COMMA j will be incremented <sil=0.913> .PERIOD So <sil=0.365> ,COMMA j becomes 2 <sil=0.963> .PERIOD So <sil=0.567> ,COMMA when you print this <sil=0.473> ,COMMA you will say that i is 4 <sil=0.552> ,COMMA j is 2 and k is 5 <sil=0.936> .PERIOD So <sil=0.330> ,COMMA understand why k is 5 because it is 4 plus 1 rather than 4 plus 2 <sil=0.970> .PERIOD So <sil=0.634> ,COMMA this is fairly simple can be understood in terms of the pre-increment and the post increment operator <sil=0.943> .PERIOD So <sil=0.510> ,COMMA let us look at some code that is equivalent to the post increment operation <sil=0.949> .PERIOD So <sil=0.344> ,COMMA suppose you have j equal to i plus plus <sil=0.434> ,COMMA you can think of it like the following <sil=0.948> .PERIOD You can say that j is assigned to i <sil=0.911> .PERIOD So <sil=0.550> ,COMMA the old value of i is assigned to j and then the value of i is incremented i equal to i plus 1 <sil=0.900> .PERIOD If you want to use the assignment compound assignment operation <sil=0.336> ,COMMA then what you can do is j equal to i and i equal to i plus 1 <sil=0.954> .PERIOD So <sil=0.629> ,COMMA this is equivalent to i plus equal to 1 is equivalent to i equal to i plus 1 <sil=0.974> .PERIOD So <sil=0.575> ,COMMA contrast with the pre-increment operation <sil=0.567> ,COMMA there i equal to i plus 1 will be done before j equal to i <sil=0.957> .PERIOD Here <sil=0.476> ,COMMA j equal to i will be done before i equal to i plus 1 <sil=0.908> .PERIOD So <sil=0.492> ,COMMA can we see that this is exactly how post increment works and the answer is yes <sil=0.408> ,COMMA in this particular case this is exactly how it works <sil=0.943> .PERIOD But <sil=0.352> ,COMMA if you want to understand the general case <sil=0.479> ,COMMA we have to understand a slightly more advanced concept in C and note that this is not something that strictly falls into an introductory course <sil=0.913> .PERIOD But <sil=0.348> ,COMMA in case you want to understand exactly how it works <sil=0.327> ,COMMA then we will look at the general case <sil=0.942> .PERIOD So <sil=0.452> ,COMMA the to understand the general case <sil=0.633> ,COMMA instead of writing a few examples and compiling it and seeing <sil=0.491> ,COMMA one way to do it would be to go to the C standard and say <sil=0.421> ,COMMA what is the standard value <sil=0.880> ?QUESTIONMARK And here <sil=0.522> ,COMMA it is slightly surprising <sil=0.954> .PERIOD So <sil=0.416> ,COMMA the result of the post fixed operator is the value of the operand <sil=0.945> .PERIOD So <sil=0.322> ,COMMA this is the old value of the operand will be written <sil=0.943> .PERIOD After the result is obtained <sil=0.447> ,COMMA the value of the operand is incremented <sil=0.911> .PERIOD This is what we saw in the last slide <sil=0.919> .PERIOD Now <sil=0.588> ,COMMA when is the operand incremented <sil=0.851> ?QUESTIONMARK We loosely said last time that after the expression is over <sil=0.329> ,COMMA then the value of i will be incremented <sil=0.999> .PERIOD But <sil=0.469> ,COMMA what is the precise point at which the value of i will be incremented <sil=0.936> ?QUESTIONMARK This is slightly surprising <sil=0.939> .PERIOD So <sil=0.452> ,COMMA the side effect of updating the stored value of the operand shall occur between the previous and the next sequence point <sil=0.926> .PERIOD So <sil=0.599> ,COMMA the when you have an i plus plus operation <sil=0.398> ,COMMA it will not be immediately updated <sil=0.986> .PERIOD It will be updated only after a place known as the sequence point <sil=0.923> .PERIOD So <sil=0.478> ,COMMA let us just understand briefly what is meant by a sequence point <sil=0.962> .PERIOD So <sil=0.501> ,COMMA before we get into it <sil=0.573> ,COMMA let me emphasize <sil=0.988> .PERIOD We are trying to understand <sil=0.991> .PERIOD So <sil=0.580> ,COMMA the post increment operation will say that the old value of i will be used and the value of i will be incremented after the expression <sil=0.906> .PERIOD We are trying to precisely understand after what point can be say that i's value will have been incremented <sil=0.971> .PERIOD So <sil=0.307> ,COMMA a sequence point as defined in the standard is a point in the code by which all pending side effects are assured to be over <sil=0.907> .PERIOD So <sil=0.571> ,COMMA this is a very technical definition and it is to be understood by compiler writers <sil=0.955> .PERIOD But <sil=0.431> ,COMMA the we will briefly understand what does it mean <sil=0.905> .PERIOD So <sil=0.421> ,COMMA some prominent sequence points include end of a full declarator <sil=0.925> .PERIOD So <sil=0.372> ,COMMA for example <sil=0.638> ,COMMA if I have a declaration in i equal to 0 comma j equal to 0 <sil=0.338> ,COMMA then a full declarator gets over after i equal to 0 <sil=0.925> .PERIOD So <sil=0.589> ,COMMA after i equal to 0 <sil=0.350> ,COMMA there is a sequence point here <sil=0.946> .PERIOD So <sil=0.432> ,COMMA if there are any pending side effects <sil=0.414> ,COMMA then it will be incremented at this point <sil=0.902> .PERIOD This is another full declarator <sil=0.975> .PERIOD So <sil=0.568> ,COMMA it will after that again any pending side effects will be assured to be done <sil=0.992> .PERIOD Then the surprising thing is suppose you have full expressions <sil=0.908> .PERIOD So <sil=0.320> ,COMMA suppose you have like i plus plus plus 3 <sil=0.912> .PERIOD So <sil=0.609> ,COMMA the major thing to understand will be when is this i plus plus plus suppose to happen <sil=0.977> .PERIOD Will it happen immediately after i plus plus and the thing is that the c standard does not say that that has to happen <sil=0.964> .PERIOD The c standard says that the next sequence point is the semicolon <sil=0.930> .PERIOD So <sil=0.521> ,COMMA when you see the semicolon operation <sil=0.511> ,COMMA you will know that this whole thing is what is known as a full expression j equal to i plus plus 3 <sil=0.966> .PERIOD So <sil=0.490> ,COMMA that is known as a full expression <sil=0.969> .PERIOD So <sil=0.450> ,COMMA after you encounter a full expression <sil=0.539> ,COMMA any pending side effects <sil=0.939> .PERIOD So <sil=0.645> ,COMMA this is a pending side effect that will be updated <sil=0.956> .PERIOD So <sil=0.422> ,COMMA only at that point c standard says that <sil=0.475> ,COMMA now by now you should have updated the i plus plus operation <sil=0.920> .PERIOD Before that the compiler is free to do what it wants <sil=0.934> .PERIOD It may or may not update so <sil=0.621> ,COMMA this is actually slightly confusing and contrary to the popular understanding of what should i plus plus when should i plus plus happen <sil=0.943> .PERIOD So <sil=0.370> ,COMMA again the general case is slightly confusing <sil=0.954> .PERIOD It is not what you would expect <sil=0.906> .PERIOD It just says that by the next sequence point in the code <sil=0.560> ,COMMA all pending side effects should be taking place <sil=0.941> .PERIOD Now <sil=0.494> ,COMMA it does not say that exactly at the end of the sequence point <sil=0.506> ,COMMA you will update all side effects <sil=0.940> .PERIOD Compilers are free to do what it wants <sil=0.954> .PERIOD All it says is that by the time you meet the next sequence point <sil=0.427> ,COMMA pending side effects should take place in whatever order <sil=0.906> .PERIOD So <sil=0.359> ,COMMA this is slightly technical <sil=0.947> .PERIOD Now <sil=0.496> ,COMMA for a full list of course <sil=0.382> ,COMMA you have to refer to the c standard which is not really recommended <sil=0.981> .PERIOD But <sil=0.533> ,COMMA it is just that if you want to understand it <sil=0.481> ,COMMA then you can look at the standard <sil=0.988> .PERIOD So <sil=0.565> ,COMMA let us try to understand the post increment operation <sil=0.951> .PERIOD So <sil=0.575> ,COMMA again slightly greater detail <sil=0.969> .PERIOD So <sil=0.516> ,COMMA if you say that k equal to i plus plus plus j plus plus <sil=0.916> .PERIOD Now <sil=0.399> ,COMMA there are two ways to do it <sil=0.955> .PERIOD Of course <sil=0.409> ,COMMA k equal to i plus j <sil=0.401> ,COMMA the old values of i and j are increment are used and then you calculate k <sil=0.391> ,COMMA as I need to k <sil=0.987> .PERIOD And then you can do i equal to i plus 1 <sil=0.588> ,COMMA j equal to j plus 1 <sil=0.918> .PERIOD Because <sil=0.493> ,COMMA the standard says that by the time you see the full expression pending updates must be happening <sil=0.941> .PERIOD So <sil=0.436> ,COMMA you can say that by the time you see the semicolon operation <sil=0.500> ,COMMA I will do i equal to i plus 1 and j equal to j plus 1 <sil=0.912> .PERIOD Now <sil=0.496> ,COMMA if you think a minute <sil=0.434> ,COMMA you could also do update j first and then i <sil=0.993> .PERIOD So <sil=0.600> ,COMMA I know that by the time you see the semicolon pending update should happen <sil=0.982> .PERIOD But <sil=0.564> ,COMMA in what order should it happen <sil=0.974> ?QUESTIONMARK Is it i equal to i plus 1 first and j equal to j plus 1 next or is it the other way around <sil=0.936> ?QUESTIONMARK And the answer is that the c standard does not say <sil=0.923> .PERIOD So <sil=0.565> ,COMMA it leaves it deliberately unspecified <sil=0.973> .PERIOD So <sil=0.454> ,COMMA that the compiler can do what it wants <sil=0.998> .PERIOD So <sil=0.412> ,COMMA here is the second subtlety in this whole business <sil=0.971> .PERIOD So <sil=0.547> ,COMMA if you say what is the order of side effects <sil=0.899> ?QUESTIONMARK There are certain operations where the sequence is specified <sil=0.949> .PERIOD For example <sil=0.535> ,COMMA the function called the and the logical and operator <sil=0.438> ,COMMA the logical or operator <sil=0.445> ,COMMA the conditional operator and the comma operator <sil=0.952> .PERIOD So <sil=0.300> ,COMMA for very specific operators <sil=0.469> ,COMMA the sequence is specified <sil=0.929> .PERIOD But <sil=0.419> ,COMMA in all other operations <sil=0.587> ,COMMA the order of evaluation of sub expressions is unspecified <sil=0.983> .PERIOD And similarly <sil=0.356> ,COMMA the order of side effects is also unspecified <sil=0.960> .PERIOD So <sil=0.445> ,COMMA in the previous slide <sil=0.465> ,COMMA doing i equal to i plus 1 before j equal to j plus 1 is valid as also j equal to j plus 1 and i equal to i plus 1 <sil=0.928> .PERIOD So <sil=0.397> ,COMMA these both these orders are valid and the c standard does not say that what should really happen <sil=0.935> .PERIOD So <sil=0.641> ,COMMA what in practice you will notice is that in one compiler <sil=0.488> ,COMMA a certain order may happen in another compiler <sil=0.379> ,COMMA certain other order may happen <sil=0.987> .PERIOD So <sil=0.325> ,COMMA it is left to the compiler and you cannot assume anything about what really happens <sil=0.649> ,COMMA which order it happens <sil=0.928> .PERIOD Further and here is the most important thing as far as these sequence points are concerned <sil=0.928> .PERIOD The c standard says that an object or a variable can have its stored value modified at most ones by the evaluation of an expression between two sequence points <sil=0.928> .PERIOD This is very important <sil=0.991> .PERIOD So <sil=0.549> ,COMMA between two sequence points <sil=0.517> ,COMMA if a variable is to be updated by a side effect <sil=0.439> ,COMMA then there should it should be updated at most ones <sil=0.979> .PERIOD Beyond that <sil=0.500> ,COMMA if it is updated multiple times <sil=0.338> ,COMMA the c standard says that the result is actually unspecified <sil=1.000> .PERIOD So <sil=0.638> ,COMMA let us look at a few specific examples to see what is actually happening here <sil=0.951> .PERIOD So <sil=0.499> ,COMMA let us say that let us take the first expression j equal to i plus plus plus i plus plus <sil=0.935> .PERIOD So <sil=0.306> ,COMMA we know that here is a sequence point and we know that here is a sequence point <sil=0.999> .PERIOD These are full expressions <sil=0.988> .PERIOD Between these two sequence points <sil=0.352> ,COMMA the value of i is updated more than once <sil=0.930> .PERIOD Here is i plus plus i plus i plus plus and the c standard says that the behavior is unspecified <sil=0.946> .PERIOD This is somewhat surprising because you may try it out multiple times and you will see that consistently some behavior is happening <sil=0.945> .PERIOD But what the c standard says is that if you take the code and compile it with a different compiler <sil=0.544> ,COMMA the result may be different <sil=0.906> .PERIOD So <sil=0.358> ,COMMA the result of this expression is actually unspecified <sil=0.939> .PERIOD Similarly <sil=0.367> ,COMMA let us look at the next example <sil=0.997> .PERIOD So <sil=0.313> ,COMMA here the sequence point is the full expression <sil=0.951> .PERIOD Let us look at the next expression <sil=0.942> .PERIOD So <sil=0.341> ,COMMA i plus plus i plus plus i <sil=0.999> .PERIOD So <sil=0.648> ,COMMA post increment and then pre increment <sil=0.982> .PERIOD Again <sil=0.581> ,COMMA even in this case the result is unspecified because these two are the sequence points here <sil=0.935> .PERIOD Between this full expression and between these full expression <sil=0.968> .PERIOD So <sil=0.634> ,COMMA you have two sequence points and between these two sequence points <sil=0.560> ,COMMA the value of i is updated more than once <sil=0.962> .PERIOD So <sil=0.427> ,COMMA the result is unspecified according to the c standard <sil=0.997> .PERIOD Let us look at this interesting example j equal to j plus plus <sil=0.966> .PERIOD Again <sil=0.622> ,COMMA result is unspecified because you can have these two sequence points and between these the value of j is updated twice <sil=0.989> .PERIOD First <sil=0.451> ,COMMA by the post increment operator and then by the assignment operator <sil=0.948> .PERIOD So <sil=0.481> ,COMMA the value of j is updated more than once the result is unspecified <sil=0.929> .PERIOD The last expression is interesting <sil=0.938> .PERIOD So <sil=0.331> ,COMMA if you look at the two sequence points here <sil=0.569> ,COMMA you have one full expression here another full expression here <sil=0.938> .PERIOD Between these the value of i is updated only once here and the value of j is updated only once here <sil=0.952> .PERIOD So <sil=0.557> ,COMMA it is not that the value of i is updated more than once or the value of j is updated more than once <sil=0.960> .PERIOD But here <sil=0.618> ,COMMA it is a which of these sub expressions happen first <sil=0.969> .PERIOD Is it i plus plus that happens first or i plus 1 that happens first <sil=0.910> .PERIOD So <sil=0.407> ,COMMA according to the c standard that is actually unspecified <sil=0.965> .PERIOD So <sil=0.336> ,COMMA the order of evaluation of the sub expressions is unspecified according to the c standard <sil=0.948> .PERIOD So <sil=0.510> ,COMMA let us just go back to that and this is what it says the order of evaluation of sub expressions is also unspecified <sil=0.903> .PERIOD So <sil=0.647> ,COMMA if you look at this expression j equal to i plus plus plus i plus 1 it is not clear which happens first i plus plus or is it i plus 1 that is also unspecified <sil=0.992> .PERIOD So <sil=0.611> ,COMMA here are the sequence points which ended full expression and the specific case of the last example it is not that values of variables are updated more than once it is just that the sub expressions may be evaluated in whatever order it may happen <sil=0.996> .PERIOD So <sil=0.550> ,COMMA all this is slightly confusing <sil=0.967> .PERIOD So <sil=0.421> ,COMMA let us just summarize something that you can take away for as far as programming is concerned <sil=0.920> .PERIOD So <sil=0.396> ,COMMA list out a few operations operators with side effects <sil=0.998> .PERIOD So <sil=0.354> ,COMMA let us say pre increment <sil=0.596> ,COMMA post increment <sil=0.531> ,COMMA pre decrement <sil=0.506> ,COMMA post decrement all of these have side effects in addition to returning the value it also updates the variable <sil=0.934> .PERIOD The assignment operator clearly has side effects <sil=0.951> .PERIOD So <sil=0.629> ,COMMA if you say j equal to i obviously the value of i will be assigned to j and we have earlier seen that as an operation it returns the value that was assigned <sil=0.968> .PERIOD So <sil=0.596> ,COMMA that has a side effect because it updates j and also returns a value which is the value of j <sil=0.980> .PERIOD We have also seen this compound assignments <sil=0.922> .PERIOD So <sil=0.552> ,COMMA you can say i plus equal to 1 which is the same as i equal to i plus 1 and j minus equal to 2 which is the same as j equal to j minus 2 <sil=0.957> .PERIOD So <sil=0.327> ,COMMA all these operators have side effects and the general advice is that use operators with side effects with extreme caution <sil=0.928> .PERIOD In general if you use them make sure that a single full expression does not contain more than one sub expression with side effects <sil=0.911> .PERIOD So <sil=0.600> ,COMMA make sure that even if you want to use these expressions with side effects make sure that one full expression contains at most one side effect <sil=0.905> .PERIOD So <sil=0.565> ,COMMA avoid expressions like i equal to i plus plus as we have seen before this has two updates on i <sil=0.901> .PERIOD So <sil=0.522> ,COMMA the result is unspecified i equal to j equal to 1 well here is a full expression that is two side effects <sil=0.965> .PERIOD Technically the result is you can predict what the result is but as a programming practice please avoid these kind of expressions because this is an expression that involves multiple updates and it is not really that the result is unspecified because the updates are on different variables but still as a good coding practice avoid such expressions <sil=0.923> .PERIOD So <sil=0.596> ,COMMA let us look at the third example you have x equal to y equal to 12 divided by y equal to 4 <sil=0.972> .PERIOD Again it is not clear which of the sub expressions y equal to 12 or y equal to 4 which will happen first <sil=0.925> .PERIOD So <sil=0.351> ,COMMA the result of this expression is very difficult to interpret <sil=0.912> .PERIOD So <sil=0.421> ,COMMA in general do not use full expressions that have more than one side effects even if they are on the single variable <sil=0.963> .PERIOD If it is if it is multiple updates on a single variable then the c standard clearly says that the result is unspecified but even if they are on multiple variables try to avoid writing such expressions you can write always write slightly longer code where the meaning of the code will be perfectly clear and the result will be completely specified <sil=0.943> .PERIOD Thank you <sil=0.956> .PERIOD In this session <sil=0.575> ,COMMA we are going to introduce a new concept of programming in C called functions <sil=0.907> .PERIOD So <sil=0.452> ,COMMA initially let us just try to motivate why we need functions and then we will try to see whether programming becomes easier if we have functions <sil=0.992> .PERIOD So <sil=0.469> ,COMMA let us say that why do we need functions <sil=0.953> ?QUESTIONMARK There are essentially two different reasons for it and I will mention these reasons one after the other <sil=0.944> .PERIOD The first reason is to break up a complex problem into simple sub problems <sil=0.955> .PERIOD All of us for example <sil=0.321> ,COMMA like to draw a drop into two do lists saying that these are the things I wish to accomplish today <sil=0.939> .PERIOD So <sil=0.574> ,COMMA step one you know get to college <sil=0.637> ,COMMA we are step two at an classes step three finish homework or something like that <sil=0.960> .PERIOD And then each of those main tasks will have several sub tasks in order to get to college <sil=0.561> ,COMMA maybe you need to renew the ticket subscription <sil=0.590> ,COMMA get on the bus <sil=0.459> ,COMMA get to college and so on <sil=0.982> .PERIOD So <sil=0.410> ,COMMA each of those higher level task involves several such smaller sub tasks and conceptually it is cleaner to say that these are the big level things that I want to do <sil=0.978> .PERIOD Each of those big level task have several sub tasks so that I can think of it what I want to accomplish in a layer wise manner <sil=0.966> .PERIOD So <sil=0.453> ,COMMA this is something that we do intuitively we always break up a complex problem into simpler sub problems <sil=0.976> .PERIOD So <sil=0.341> ,COMMA that we can analyze the simplest sub problem and perform it completely and then come back to the bigger problem <sil=0.908> .PERIOD So <sil=0.372> ,COMMA we need to solve it each separately and the main tool for this programming in C which allows you to accomplish breaking up a complex sub problem into simplest sub problems is what is known as functions <sil=0.911> .PERIOD So <sil=0.600> ,COMMA this enables you to do what is known as modular programming in C and functions are not new we have already seen three functions in particular main was a function that we always wrote and then we have sprinter and scan up which we use for outputting and inputting respectively <sil=0.905> .PERIOD So <sil=0.347> ,COMMA let us just motivate the notion of functions by using the second motivation that I was talking about <sil=0.907> .PERIOD So <sil=0.383> ,COMMA suppose you have you want to say I want to compute n C k which is n factorial upon k factorial n minus k factorial <sil=0.909> .PERIOD So <sil=0.358> ,COMMA this is the definition of n choose k or n C k as it is known <sil=0.936> .PERIOD Now <sil=0.406> ,COMMA suppose I want to write this and code this into a C program <sil=0.966> .PERIOD So <sil=0.513> ,COMMA I will have let us say a main function and then inside the main function I will have let us say three variables a <sil=0.406> ,COMMA b <sil=0.483> ,COMMA c and then float a result because the result of a division will be a float <sil=0.905> .PERIOD So <sil=0.328> ,COMMA I will have what should I do intuitively one way to do it is I will have a block of code which says it will calculate n factorial which is the numerator then I will say that a equal to n factorial at the end of this let us say that a stores n factorial <sil=0.945> .PERIOD Then I will have another block of code which says that I will calculate k factorial and then this will say let us say b equal to k factorial <sil=0.958> .PERIOD And a third block of code will calculate n minus k factorial <sil=0.940> .PERIOD Let us say I will store this in C and then I will say a result equal to a by b times c some code that looks like this <sil=0.997> .PERIOD And you would notice what is inconvenient about it all these three blocks of code once we completed we look very similar they are all calculating the factorial of a particular number <sil=0.442> ,COMMA but there is nothing in C which will that using the feature will actually calculating the factorial of a particular number <sil=0.638> ,COMMA but there is nothing in C which will that using the features we have seen so far which will tell us that this code and this code are essentially the same and I need to write that similar code only once <sil=0.941> .PERIOD So <sil=0.532> ,COMMA what there is no simple way to use loops to accomplish this <sil=0.984> .PERIOD So <sil=0.603> ,COMMA it seems like this redundant business of writing similar code again and again can be avoided <sil=0.923> .PERIOD So <sil=0.598> ,COMMA this is the second motivation for introducing the notion of functions which is basically to avoid duplication of code <sil=0.955> .PERIOD So <sil=0.432> ,COMMA here is a side benefit of functions avoid code replication <sil=0.906> .PERIOD We have already seen loops to some extent avoid code replication <sil=0.438> ,COMMA but here is a newer method to avoid code replication in a greater degree <sil=0.954> .PERIOD So <sil=0.605> ,COMMA the second reason why we write functions is to avoid writing similar code again and again <sil=0.944> .PERIOD So <sil=0.390> ,COMMA let us try to write functions by motivating it with the help of an example <sil=1.000> .PERIOD This example will show the benefit of how we can avoid code duplication using functions and also how we can break up a complex problem into simpler sub problems <sil=0.989> .PERIOD So <sil=0.312> ,COMMA in this I will introduce the problem similar to what we have seen before <sil=0.954> .PERIOD We have a sequence of numbers the first number tells you how many inputs there are and then what we need to do is to pick out the numbers which are relatively prime in this sequence <sil=0.995> .PERIOD So <sil=0.364> ,COMMA two numbers are relatively prime if their GCD is 1 <sil=0.937> .PERIOD So <sil=0.484> ,COMMA 16 and 7 are relatively prime 4 and 6 are not because they have a common factor of 2 6 and 16 are not they have a common factor of 2 16 and 7 do not have a common factor other than 1 7 and 8 are similarly relatively prime 8 and 9 are relatively prime 9 and 10 are relatively prime and 10 and 11 are relatively prime <sil=0.991> .PERIOD So <sil=0.522> ,COMMA these are the relatively prime pairs and we need to write a function which given a sequence of these numbers count how many pairs how many successively occurring numbers are relatively prime to each other in this case there are 5 such pairs <sil=0.905> .PERIOD So <sil=0.342> ,COMMA in this problem we can clearly see that there is a sub problem which is given 2 numbers are they relatively prime that is one sub problem and if we have the solution to that sub problem then we can compose the solution to the whole problem as follows given 2 numbers I check whether they are relatively prime if they are relatively prime I will increment the count of the relatively prime pairs I have seen so far otherwise I will skip to the next pair and see whether they are relatively prime <sil=0.935> .PERIOD So <sil=0.483> ,COMMA for each new pair of numbers I am seeing that is the subtask of checking whether they are relatively prime <sil=0.997> .PERIOD So <sil=0.393> ,COMMA let us say that suppose we have a function a function is something that we will see in a minute suppose we have a small component which will perform the task of testing is co prime a b <sil=0.987> .PERIOD So <sil=0.395> ,COMMA is co prime a b that function will take 2 numbers a and b and check whether they are relatively prime or not if a and b are relatively prime it evaluates to 1 it is we say that it returns 1 if they are relatively prime and if they are not co prime to each other if they are not relatively prime then it has to return as 0 <sil=0.957> .PERIOD So <sil=0.579> ,COMMA it has to evaluate to 0 now associated with every function there are 3 concepts we will see them 1 by 1 there is this declaration of a function which says what does the function look like what is the type of the function <sil=0.973> .PERIOD So <sil=0.353> ,COMMA the declaration of the function will be written in the following way it will be written as int e scope prime int a int b this means that e scope prime is the function name and then it takes 2 arguments a and b which are of type int <sil=0.927> .PERIOD So <sil=0.601> ,COMMA int a and int b if we had written another function which takes a float a and int b we would say function int float a int b <sil=0.961> .PERIOD So <sil=0.503> ,COMMA in this case we are taking 2 integers as arguments so you have to say int a int b a small syntactic point that you have to notice that you cannot abbreviate this as int a comma b <sil=0.921> .PERIOD So <sil=0.433> ,COMMA that is not allowed each variable needs to have a separate type signature <sil=0.990> .PERIOD So <sil=0.619> ,COMMA these are called the input arguments <sil=0.957> .PERIOD So <sil=0.504> ,COMMA that is the second part of the declaration the first part of the declaration the first which says that it is an int is actually the type of the return value <sil=0.965> .PERIOD So <sil=0.389> ,COMMA the return value is 1 if the pairs is co prime and it is 0 if the pair is not co prime <sil=0.996> .PERIOD So <sil=0.641> ,COMMA the return values and int is 0 <sil=0.920> .PERIOD So <sil=0.388> ,COMMA we need a function name we need a declaration of the input arguments the arguments need to be named and the return value of the output <sil=0.960> .PERIOD So <sil=0.525> ,COMMA let us say how do we design the higher level function <sil=0.907> .PERIOD So <sil=0.352> ,COMMA here is how you use functions menu program you assume that the function is already available to you and it does what it is supposed to do using that how do I build the solution to the whole program <sil=0.934> .PERIOD So <sil=0.514> ,COMMA in this case let us just assume that we have written int a is co prime we have written that function and we are interested in how do we build the solution to the entire problem using that <sil=0.981> .PERIOD So <sil=0.445> ,COMMA how do you do that use have a flow chart which reads numbers 1 by 1 and count is the number of co prime pairs that you have seen so far <sil=0.936> .PERIOD So <sil=0.529> ,COMMA you check whether you have seen n numbers if you have not seen n numbers then you will read the next number and check whether the previous number and the current number form a co prime pair <sil=0.972> .PERIOD So <sil=0.643> ,COMMA you give is co prime pre current it will return 1 if they are co prime <sil=0.917> .PERIOD So <sil=0.312> ,COMMA that will get added to the count if they are not co prime they will it will return a 0 <sil=0.991> .PERIOD So <sil=0.303> ,COMMA count will remain as it is once you do that you say previous equal to current and indicate that you are going to read the next number <sil=0.908> .PERIOD This is similar to other problems where we scanned this bunch of numbers and did some function based on that <sil=0.989> .PERIOD The new thing here is the is co prime function which we just assume that it is correctly written and it does what it is supposed to do <sil=0.926> .PERIOD So <sil=0.411> ,COMMA this is the function declaration <sil=0.967> .PERIOD Now <sil=0.308> ,COMMA how do you code this up you basically code this up in C just as you did it with other program other functions like scan F you just say count plus is co prime previous current <sil=0.906> .PERIOD So <sil=0.571> ,COMMA this is how you can encode the flow chart including the function called as a C program <sil=1.000> .PERIOD Now <sil=0.479> ,COMMA let us come to the interesting part which is how do we design the int is co prime function <sil=0.922> .PERIOD So <sil=0.430> ,COMMA the top is the declaration part of the function where I say that what is its type <sil=0.957> .PERIOD So <sil=0.506> ,COMMA the function name is is co prime it takes two variables a and b a is of type int b is of type int and it is supposed to return an integer value <sil=0.946> .PERIOD So <sil=0.519> ,COMMA that much is clear from the type signature so called of is co prime <sil=0.978> .PERIOD Now <sil=0.605> ,COMMA what do you do with it <sil=0.969> ?QUESTIONMARK You say that so this is the classic GCD code you declare a t variable if a is less than b is swap a and b and this part of the code is just calculating the GCD <sil=0.990> .PERIOD This is code that we have seen before and at the end of that a will become the GCD if a and b are co prime then a will be 1 if a is any number greater than 1 then they are not co prime <sil=0.989> .PERIOD So <sil=0.529> ,COMMA if a is equal to 1 you return 1 and for returning you use the code return <sil=0.940> .PERIOD So <sil=0.637> ,COMMA you return the value 1 otherwise you return the value 0 <sil=0.906> .PERIOD So <sil=0.467> ,COMMA this is how you write the function is co prime <sil=0.946> .PERIOD So <sil=0.376> ,COMMA now we have to put both these code together so I will say include a stdao dot h this is the first line of the code then I will have closed code for is co prime <sil=0.920> .PERIOD So <sil=0.443> ,COMMA I will write that and afterwards write main function <sil=0.942> .PERIOD So <sil=0.605> ,COMMA that when main calls is co prime function then we already have the code for is co prime available first this line then the is co prime function and then the main function <sil=0.946> .PERIOD So <sil=0.438> ,COMMA let us look at the function in somewhat greater detail a and b are what are called the formal parameters of the function they are viewed as variables <sil=0.968> .PERIOD Now <sil=0.457> ,COMMA the formal parameters are visible only within the function <sil=0.968> .PERIOD So <sil=0.572> ,COMMA we say that their scope is inside the function now there is this is what is known as the definition of the function every function can be called the notice that we have already called the functions like printf and scanf <sil=0.979> .PERIOD So <sil=0.541> ,COMMA once you define a function you can call a function calling a function will be evaluating that function with particular arguments you can do that <sil=0.949> .PERIOD So <sil=0.538> ,COMMA when you call a function you execute the function with the given arguments <sil=0.985> .PERIOD So <sil=0.567> ,COMMA phi becomes a and 6 becomes b <sil=0.924> .PERIOD Once a function call is encountered what happens is that formal parameters are mapped to actual parameters <sil=0.951> .PERIOD So <sil=0.319> ,COMMA a becomes so the value phi is copied to a and the value 6 is copied to b this process of copying values is known as parameter passing <sil=0.955> .PERIOD Then what you do is you store the return address of the call the return address is the line of the main function where the function was called <sil=0.950> .PERIOD So <sil=0.351> ,COMMA let us say that it was called in the second line of main <sil=0.988> .PERIOD Once the function finishes it has to come back to this point <sil=0.967> .PERIOD Now <sil=0.339> ,COMMA in addition we also create a box for storing the return value at the end of the function either 1 or 0 will be returned <sil=0.911> .PERIOD So <sil=0.368> ,COMMA we also need some space in memory to store that return value <sil=0.957> .PERIOD So <sil=0.358> ,COMMA to the function look at it in slightly greater detail <sil=0.993> .PERIOD So <sil=0.645> ,COMMA let us say that is co prime 9 4 is called in step 20 A <sil=0.968> .PERIOD So <sil=0.452> ,COMMA this is the address 20 A by which I mean it is line 20 and some location A <sil=0.999> .PERIOD So <sil=0.568> ,COMMA now you have to allocate the space for the return value store the return address and pass the parameters <sil=0.925> .PERIOD Now <sil=0.358> ,COMMA at when you pass the inputs 9 and 4 the space is allocated for A equal to 9 and B equal to 4 this is the process of parameter passing <sil=0.912> .PERIOD So <sil=0.370> ,COMMA we visualize the memory SS stack <sil=0.950> .PERIOD So <sil=0.323> ,COMMA when you start the program you start executing from line 1 of main <sil=0.948> .PERIOD So <sil=0.513> ,COMMA access initialize to minus 1 and then you come to the function called is co prime 9 4 <sil=0.949> .PERIOD So <sil=0.336> ,COMMA when you execute this you do the following you allocate the space for the return value you pass the parameters and then execute the function and finally <sil=0.334> ,COMMA pass back the return value <sil=0.999> .PERIOD So <sil=0.595> ,COMMA when you execute the function you imagine that the stack is now divided into a separate space <sil=0.917> .PERIOD So <sil=0.308> ,COMMA here is a clean separation between the memory that is required for main <sil=0.998> .PERIOD So <sil=0.310> ,COMMA above here is main and below here is the memory required for is co prime <sil=0.914> .PERIOD So <sil=0.377> ,COMMA in that I have stored a box for return value I have stored the return address which is 20 A and then I have A equal to 9 and B equal to 4 <sil=0.991> .PERIOD Now <sil=0.397> ,COMMA I will execute the function as though memory is limited to here <sil=0.956> .PERIOD So <sil=0.323> ,COMMA I will declare t and then execute the GCD algorithm <sil=0.965> .PERIOD So <sil=0.372> ,COMMA this is stuff that we have seen before and finally <sil=0.591> ,COMMA A is the GCD which is 1 <sil=0.936> .PERIOD If A is 1 we have to return 1 <sil=0.992> .PERIOD So <sil=0.367> ,COMMA the value 1 will be copied to the return value and that is the value that will be the value of the value <sil=0.980> .PERIOD So <sil=0.510> ,COMMA the return value will be copied back to the main function <sil=0.966> .PERIOD In this session we will learn about arrays in C <sil=0.953> .PERIOD Now <sil=0.482> ,COMMA what does the word array mean <sil=0.957> ?QUESTIONMARK It means grouping or a collection of objects <sil=0.919> .PERIOD So <sil=0.517> ,COMMA for example <sil=0.605> ,COMMA you could say that he could not dismiss the array of facts <sil=0.930> .PERIOD So <sil=0.462> ,COMMA that means a collection of facts and it also implies regular order or arrangement that is in the case of a series <sil=0.944> .PERIOD So <sil=0.410> ,COMMA what do we mean by an array and why do we need it <sil=0.965> ?QUESTIONMARK So <sil=0.545> ,COMMA let us consider that I have a bunch of numbers say 1 <sil=0.471> ,COMMA 2 <sil=0.623> ,COMMA 3 <sil=0.505> ,COMMA 4 and I want to consider them as being part of a sequence <sil=0.946> .PERIOD Let us say 1 <sil=0.348> ,COMMA 2 <sil=0.309> ,COMMA 3 <sil=0.474> ,COMMA 4 <sil=0.592> .PERIOD So <sil=0.338> ,COMMA the first element is 1 and so on <sil=0.954> .PERIOD Now <sil=0.396> ,COMMA I want them to be stored and one way I can do it is that I can store them into separate variables <sil=0.961> .PERIOD For example <sil=0.557> ,COMMA I can say that a is 1 <sil=0.465> ,COMMA b is 2 and c is 3 and d is 4 <sil=0.971> .PERIOD But when I do it in that way <sil=0.608> ,COMMA they are separate variables and the relationship between those variables <sil=0.435> ,COMMA the fact that b comes after a and things like that is something that the programmer knows <sil=0.440> ,COMMA but it is hard for somebody else looking at the code to figure out <sil=0.972> .PERIOD Often we need to store a sequence as a sequence itself <sil=0.970> .PERIOD So <sil=0.458> ,COMMA an array has the following properties <sil=0.997> .PERIOD One <sil=0.501> ,COMMA it is a collection of objects of the same type <sil=0.985> .PERIOD Second is that it has some size <sil=0.341> ,COMMA some finite size say n <sil=0.937> .PERIOD There are n elements in the array and the third is that I should be able to selectively update <sil=0.302> ,COMMA update only a single element in the array by which I mean suppose I have four elements in the array <sil=0.917> .PERIOD I should be able to say that I want to replace the third element by 5 <sil=0.926> .PERIOD So <sil=0.623> ,COMMA 3 will be replaced by 5 without touching the other elements <sil=0.995> .PERIOD That is what the third thing is about <sil=0.984> .PERIOD The first thing says that I want a collection such that it is a collection of objects of all of type integer and not of any other type <sil=0.942> .PERIOD The second says that it has some finite size <sil=0.913> .PERIOD So <sil=0.538> ,COMMA it is not an infinite collection <sil=0.972> .PERIOD So <sil=0.414> ,COMMA that is what an array is supposed to do <sil=0.960> .PERIOD Now <sil=0.540> ,COMMA let us see how we can define arrays <sil=0.944> .PERIOD We will try to motivate why arrays are needed by introducing certain problems and I will try to convince you that it is easy to do using arrays and whereas it was difficult to do without using arrays using only the facilities in C that we have seen so far <sil=0.933> .PERIOD So <sil=0.449> ,COMMA an array is defined in C similar to how we define a variable <sil=0.976> .PERIOD If we had an integer variable we would say int a semicolon instead of that when we declare an array we have int a 5 <sil=0.932> .PERIOD So <sil=0.501> ,COMMA this would declare that it is an array containing 5 integers <sil=0.973> .PERIOD Now <sil=0.630> ,COMMA one thing that is certain about arrays in C is that the 5 integers which make up the array will be allocated consecutively in memory <sil=0.980> .PERIOD So <sil=0.344> ,COMMA they will happen one after the other <sil=0.985> .PERIOD Also one thing to note is that arrays in C start with index 0 <sil=0.971> .PERIOD So <sil=0.334> ,COMMA the first element is a 0 <sil=0.968> .PERIOD So <sil=0.599> ,COMMA if we have an array of 5 elements it will go from a 0 to a 4 <sil=0.986> .PERIOD So <sil=0.580> ,COMMA have we seen arrays in mathematics for example <sil=0.302> ,COMMA you can think of vectors similarly matrices these are all arrays and C arrays will have similarities to mathematical vectors and mathematical arrays <sil=0.906> .PERIOD But note that in mathematics it is customary to start from index 1 here it is from index 0 <sil=0.990> .PERIOD So <sil=0.360> ,COMMA the boxes are addressed as a 0 up to a 4 <sil=0.986> .PERIOD So <sil=0.465> ,COMMA the boxes are addressed as a 0 up to a 4 <sil=0.901> .PERIOD These are called the elements of the array <sil=0.973> .PERIOD The array is the whole collection of boxes and each box in it will be called an element of the array <sil=0.963> .PERIOD Now <sil=0.498> ,COMMA let us consider a simple program using an array <sil=0.917> .PERIOD So <sil=0.302> ,COMMA I mentioned that the third requirement that I want for an array is that the so <sil=0.558> ,COMMA the first requirement was that all elements of the array are of the same type <sil=0.988> .PERIOD The second requirement is that it has a finite size and the third requirement is that I should be able to selectively update only one element of the array without touching the other elements <sil=0.960> .PERIOD So <sil=0.499> ,COMMA let us see a program where we can do all that <sil=0.911> .PERIOD So <sil=0.306> ,COMMA here is a simple program it declares an integer I an integer array a 5 and then a for loop <sil=0.904> .PERIOD So <sil=0.386> ,COMMA let us see what the for loop is suppose to do <sil=0.917> .PERIOD So <sil=0.527> ,COMMA the for loop starts from I equal to 0 and then goes from I equal to 0 to 5 <sil=0.924> .PERIOD So <sil=0.456> ,COMMA filling in the elements by using the statement a I equal to I <sil=0.936> .PERIOD So <sil=0.440> ,COMMA let us see what that is suppose to do <sil=0.920> .PERIOD So <sil=0.352> ,COMMA this is the notation a I is the notation used to address the elements of the array <sil=0.909> .PERIOD So <sil=0.637> ,COMMA notice the similarity here a 5 when you declare it it says that it is an array of size 5 a of I is saying that I want the I th element in the array <sil=0.973> .PERIOD So <sil=0.602> ,COMMA when I equal to 0 it will refer to the 0 th element in the array until I equal to 4 it will go on until the fourth element of the array <sil=0.934> .PERIOD So <sil=0.500> ,COMMA a of I similar to a of 5 the way we wrote declared the array says I want the I th element of the array <sil=0.983> .PERIOD So <sil=0.598> ,COMMA the variable I is being used as an index for a that means if I say a of I I will pick the I th cell in the I th element in the array <sil=0.988> .PERIOD Now <sil=0.472> ,COMMA this is similar to the mathematical notation a is subscript I which is what we normally use for vectors and matrices <sil=0.964> .PERIOD So <sil=0.571> ,COMMA let us run through the program once to see what is doing <sil=0.913> .PERIOD So <sil=0.535> ,COMMA first we declare a 5 which is 5 consecutively allocated integers in the memory and we have also have a variable I <sil=0.962> .PERIOD I starts with 0 and for the 0th iteration a of I is allocated let us say I plus 1 <sil=0.978> .PERIOD So <sil=0.403> ,COMMA a 0 will be 1 then we update I <sil=0.978> .PERIOD So <sil=0.305> ,COMMA this statement becomes a of 1 equal to 1 plus 1 which is 2 <sil=0.949> .PERIOD So <sil=0.377> ,COMMA and then we execute it a 2 becomes 3 a 3 becomes 4 and a 4 becomes 5 <sil=0.989> .PERIOD So <sil=0.365> ,COMMA notice that because we have indices and indices can be numbers they can also be replaced by integer expressions <sil=0.938> .PERIOD This is the trick that we have used here <sil=0.938> .PERIOD So <sil=0.499> ,COMMA a of I goes from a 0 all the way up to a 4 <sil=0.995> .PERIOD Now <sil=0.397> ,COMMA it is only required that a single array can be objects of the same type <sil=0.928> .PERIOD So <sil=0.504> ,COMMA we have dealt with integer arrays so far <sil=0.960> .PERIOD Now <sil=0.560> ,COMMA we can also deal with floating arrays and float arrays and character arrays and things like that <sil=0.966> .PERIOD So <sil=0.557> ,COMMA in general you can declare an array of any data type in C <sil=0.967> .PERIOD For example <sil=0.401> ,COMMA you can say float num 100 <sil=0.995> .PERIOD So <sil=0.306> ,COMMA that will declare array of 100 floating point numbers <sil=0.906> .PERIOD Similarly <sil=0.355> ,COMMA car S 256 will declare a character array of size 256 <sil=0.963> .PERIOD So <sil=0.311> ,COMMA you can declare a floating point array and you can visualize it as 100 floating point boxes allocated consecutively that is the important part <sil=0.910> .PERIOD The consecutive locations in the memory 1 after the other will be allocated for the same array <sil=0.979> .PERIOD Now <sil=0.518> ,COMMA for character array similarly 100 boxes are allocated 1 after the other <sil=0.927> .PERIOD Now <sil=0.304> ,COMMA depending on the size of the data type involved <sil=0.485> ,COMMA obviously the size of the array will be different <sil=0.902> .PERIOD So <sil=0.636> ,COMMA the float array will be of size 100 times the size of a single float and the character array will be of size 256 times the size of a single character and so on <sil=0.905> .PERIOD So <sil=0.397> ,COMMA one thing is we have to take care of the size of the array <sil=0.960> .PERIOD For example <sil=0.641> ,COMMA if we have an integer array of size 5 x <sil=0.924> .PERIOD This means that 5 integer variables named x 0 to x 4 are allocated <sil=0.950> .PERIOD So <sil=0.480> ,COMMA this is the size of the array <sil=0.915> .PERIOD Now <sil=0.343> ,COMMA so the variables x 0 to x 4 are integers and they can be assigned and also they can be operated on they can be part of other expressions and so on <sil=0.982> .PERIOD Now <sil=0.475> ,COMMA what about arbitrary integers <sil=0.967> ?QUESTIONMARK Can we know that 0 to 4 are valid indices <sil=0.904> .PERIOD What about 5 and so on <sil=0.969> ?QUESTIONMARK What happens to x 5 x 66 something like that <sil=0.922> ?QUESTIONMARK Similarly <sil=0.391> ,COMMA what will do <sil=0.955> ?QUESTIONMARK What will happen if I write x of minus 1 <sil=0.925> ?QUESTIONMARK What are these valid <sil=0.923> ?QUESTIONMARK So <sil=0.309> ,COMMA the answer is no <sil=0.568> ,COMMA you cannot in general assume that indices other than 0 to 4 make any sense <sil=0.942> .PERIOD Your program may crash and this is the most important thing in C programming when you use arrays <sil=0.927> .PERIOD It is the may part of it because it is not even guaranteed that your program will crash <sil=0.975> .PERIOD So <sil=0.358> ,COMMA you may run the program once with x of 5 <sil=0.914> .PERIOD Let us say and the program will work fine <sil=0.943> .PERIOD And you will be under the false impression that everything is correct in your program <sil=0.973> .PERIOD But the next time you run it may be your program will crash <sil=0.970> .PERIOD So <sil=0.543> ,COMMA it is not even guaranteed that it will crash <sil=0.997> .PERIOD If it is guaranteed that it will crash then of course <sil=0.386> ,COMMA you can know that there is an error and you can go back to the code <sil=0.949> .PERIOD In this case you just have to be careful when you write the code <sil=0.947> .PERIOD So <sil=0.482> ,COMMA x 5 x 6 and so on are undefined <sil=0.917> .PERIOD These are names but there are no storage locations that they correspond to <sil=0.996> .PERIOD So <sil=0.316> ,COMMA you should not access them <sil=0.923> .PERIOD So <sil=0.534> ,COMMA if you ask a very specific question should not I access them or can't I access them <sil=0.998> .PERIOD So <sil=0.626> ,COMMA what will happen if I write a code like this where I declare an integer array of size 5 then I know that x 0 to x 4 are valid locations <sil=0.919> .PERIOD They are the first 5 locations <sil=0.900> .PERIOD But the problem comes with statements like x of 5 equal to 5 or x of 6 equal to 6 <sil=0.902> .PERIOD 5 and 6 do not refer to valid locations in the array <sil=0.928> .PERIOD So <sil=0.644> ,COMMA what will happen <sil=0.985> ?QUESTIONMARK So <sil=0.469> ,COMMA the initial statements up to x of 4 are all fine <sil=0.912> .PERIOD But the last two statements x of 5 equal to 5 x of 6 equal to 6 lead to errors <sil=0.946> .PERIOD Will it compile yes if you just give the source code with these erroneous locations it will compile <sil=0.925> .PERIOD But the because the C compiler does not check that the indices are within the proper range <sil=0.915> .PERIOD So <sil=0.472> ,COMMA it will compile and the compiler will not tell you that there is anything wrong with it <sil=0.917> .PERIOD But when you run a program the program will give something called a segmentation fault <sil=0.930> .PERIOD It may or may not give that <sil=0.976> .PERIOD So <sil=0.356> ,COMMA this is one of the most notorious errors when you program in C <sil=0.915> .PERIOD So <sil=0.621> ,COMMA we will see this error greater detail when we understand something called pointers <sil=0.988> .PERIOD But in general when you exceed the bounds of the array when you go beyond the location locations permissible in the array your code may crash and the code will crash usually with the error segmentation fault <sil=0.957> .PERIOD So <sil=0.579> ,COMMA if you run the program and if you see a segmentation fault this is a good indication that may be you are referring to locations in your array that do not exist <sil=0.916> .PERIOD So <sil=0.461> ,COMMA you should go back and rectify the code <sil=0.964> .PERIOD But the danger is that it may not always crash <sil=0.924> .PERIOD So <sil=0.546> ,COMMA the only way to be really sure is to go through your source code and examine it your program may crash <sil=0.964> .PERIOD So <sil=0.649> ,COMMA we have seen certain aspects of a race in C so far <sil=0.963> .PERIOD So <sil=0.552> ,COMMA for example <sil=0.343> ,COMMA let us say that I declare a character array STR of size 5 <sil=0.994> .PERIOD So <sil=0.318> ,COMMA it has 5 characters inside it and let us say that I use the variable i as an index into the array <sil=0.983> .PERIOD So <sil=0.550> ,COMMA STR of 0 to 4 can be addressed using the index i <sil=0.903> .PERIOD So <sil=0.426> ,COMMA if I have the index I know that I can set particular values as STR of i equal to a since i is 0 this will set the 0th element in the array to character a <sil=0.912> .PERIOD Similarly <sil=0.610> ,COMMA if I say CH equal to STR i plus 1 it will take whatever is in the first cell in STR of 1 and assign it to the variable CH <sil=0.993> .PERIOD So <sil=0.301> ,COMMA we can set a particular element in an array like this <sil=0.935> .PERIOD Similarly <sil=0.413> ,COMMA we can also read the value in an element and then assign it to something else <sil=0.996> .PERIOD So <sil=0.599> ,COMMA these are possible with help of an array <sil=0.943> .PERIOD Now <sil=0.478> ,COMMA let us consider a particular example which is the problem is as follows <sil=0.998> .PERIOD We want a character array let us say of size 100 and then we have to read input which is from the keyboard and store them in the array <sil=0.922> .PERIOD After we store it we should stop once at least 100 characters have been read because that is our array size or when the user pressed end of file <sil=0.937> .PERIOD Remember that you can press control D to enter the end of file <sil=0.905> .PERIOD Now <sil=0.344> ,COMMA what we have to do is take the array and print it in the reverse order <sil=0.960> .PERIOD Now <sil=0.350> ,COMMA if you think for a little bit you can see that it is difficult to do this without an array <sil=0.916> .PERIOD Instead of an array if you were storing it in a single character there is no way to store 100 characters in one variable and then print them in the reverse order <sil=0.993> .PERIOD Because the first character has to be printed at the end the last character entered has to be printed first <sil=0.941> .PERIOD So <sil=0.407> ,COMMA you need to remember all the characters this is an intuitive reason why arrays are important for this problem <sil=0.956> .PERIOD So <sil=0.561> ,COMMA what is an example problem let us say that we have M e O R then new line and then M O O followed by control D <sil=0.933> .PERIOD So <sil=0.362> ,COMMA when you reverse it you will have O O M then the new line then O R E M and so on <sil=0.974> .PERIOD So <sil=0.348> ,COMMA you have to reverse everything input <sil=0.967> .PERIOD Similarly <sil=0.391> ,COMMA if you have a string what you have to output is the exact reverse of the string including the spaces <sil=0.913> .PERIOD So <sil=0.646> ,COMMA let us design the program we will just try to write the program using main <sil=0.942> .PERIOD Now <sil=0.340> ,COMMA there are two parts in this program the first is just to read what has been input into the array and the second part is to print the array in reverse <sil=0.983> .PERIOD So <sil=0.620> ,COMMA the read into array that part of the program will read the input character by character until one of two events happen <sil=0.925> .PERIOD The first is 100 characters have been input because you have declared the array of size only 100 <sil=0.934> .PERIOD So <sil=0.476> ,COMMA you can read only 100 characters <sil=0.982> .PERIOD So <sil=0.587> ,COMMA once you reach that you should stop otherwise before you reached 100 characters may be the user pressed a control D to say that I am done with the input <sil=0.960> .PERIOD In that also you have to say that I have done by reading the input <sil=0.902> .PERIOD Now <sil=0.571> ,COMMA print reverse will print the characters in reverse <sil=0.922> .PERIOD So <sil=0.326> ,COMMA let us design the program for reading into the array <sil=0.906> .PERIOD So <sil=0.322> ,COMMA keep the following variables one is to keep the count of how many characters I have read so far and then I will keep a variable to store the currently read character <sil=0.964> .PERIOD Now <sil=0.533> ,COMMA we have touched upon this topic once I am going to declare it in CH instead of care CH <sil=0.960> .PERIOD So <sil=0.639> ,COMMA I am not going to do this this is because get CHAR will give you whatever character has been read just now from the input <sil=1.000> .PERIOD So <sil=0.306> ,COMMA in particular the characters that can be entered can be an ASCII value which is from 0 to 255 or something and then it can also enter the E OF character <sil=0.942> .PERIOD The end of file character which is actually minus 1 <sil=0.987> .PERIOD So <sil=0.556> ,COMMA minus 1 does not correspond to an ASCII character <sil=0.978> .PERIOD So <sil=0.390> ,COMMA get CHAR can also read an end of file character this is the reason why if you are reading characters through get get care and we are doing this because the user can also enter a minus 1 <sil=0.944> .PERIOD Then in order to hold that value you need an int CH rather than a character CH <sil=0.946> .PERIOD So <sil=0.637> ,COMMA this is what we just mentioned the end of file character is usually minus 1 <sil=0.902> .PERIOD So <sil=0.412> ,COMMA it is not a valid ASCII value <sil=0.993> .PERIOD So <sil=0.469> ,COMMA the code at the top level looks like this we have the logic to read a next character into the CH using get CHAR <sil=0.969> .PERIOD And then we have a let us say a while loop which says that while the character is not end of file and the number of characters read count is less than 100 you store the character into the array increment count and then read the next character <sil=0.993> .PERIOD So <sil=0.473> ,COMMA please look at the structure of the loop very carefully the S is a character array <sil=0.977> .PERIOD So <sil=0.441> ,COMMA technically it cannot hold an end of file <sil=0.376> ,COMMA but then if you think about it a little bit you will see that we will never encounter a situation where you will store end of file into the S array because suppose the first character is end of file then we will not even enter the loop <sil=0.986> .PERIOD Now <sil=0.467> ,COMMA at any point when we enter end of file it will be at this point we will read the character only here before storing it into the array we will actually check whether it is end of file <sil=0.976> .PERIOD So <sil=0.489> ,COMMA we will not accidentally set the array to minus 1 at any point <sil=0.961> .PERIOD So <sil=0.552> ,COMMA the array to minus 1 at any point so character array suffices <sil=0.987> .PERIOD So <sil=0.405> ,COMMA think carefully about the way this loop has been written in particular if I had just done this as the last line before the loop ended then you would run into problems because you could store the end of file character into the S array by mistake <sil=0.961> .PERIOD So <sil=0.596> ,COMMA just think about that issue <sil=0.991> .PERIOD Now <sil=0.491> ,COMMA here is a initial design and so the overall design is that first you have to read into the array and then you have to print in reverse <sil=0.931> .PERIOD So <sil=0.615> ,COMMA let us make the read into array a little bit more precise <sil=0.989> .PERIOD So <sil=0.355> ,COMMA we have CH equal to get char and because you are using the get char function we have int CH because it could also be an end of file <sil=0.911> .PERIOD Now <sil=0.388> ,COMMA the while loop says that while the CH is not end of file and the number of characters read is strictly less than 100 you increment <sil=0.917> .PERIOD So <sil=0.401> ,COMMA if first set S count equal to the character read increment count and then get the next character <sil=0.934> .PERIOD So <sil=0.446> ,COMMA this loop keeps on filling characters into the character array until you see either end of file or you have entered 100 characters <sil=0.958> .PERIOD Now <sil=0.348> ,COMMA let us design the remaining thing which is print in reverse <sil=0.969> .PERIOD So <sil=0.403> ,COMMA suppose the input is let us say to be concrete H a L p and then control D the end of file character <sil=0.992> .PERIOD So <sil=0.456> ,COMMA once you run the read into array part it will lead to the array looking like this S 0 will be the character H S 1 will be E S 2 will be L S 3 will be p <sil=0.968> .PERIOD At this point you will read end of file and you will not store the end of file in the array <sil=0.910> .PERIOD So <sil=0.305> ,COMMA S 0 to S 3 are valid characters and at this point if you go back to the code count always keeps track of how many characters have been read <sil=0.959> .PERIOD So <sil=0.476> ,COMMA in particular count will be 4 when you exit the array <sil=0.927> .PERIOD Now <sil=0.379> ,COMMA to print in reverse all you have to do is to start printing from S 3 then S 2 then S 1 and then S 0 <sil=0.909> .PERIOD So <sil=0.623> ,COMMA you read in this direction and you print in the reverse direction <sil=0.933> .PERIOD So <sil=0.493> ,COMMA we should be somewhat careful at this point <sil=0.935> .PERIOD Suppose you have read the array before you enter this part then you declare I which is the array index that we are going to use <sil=0.957> .PERIOD Now <sil=0.428> ,COMMA I should be set to the index of the last character read <sil=0.920> .PERIOD So <sil=0.358> ,COMMA here is the tracky part notice that count is 4 <sil=0.939> .PERIOD So <sil=0.370> ,COMMA 4 characters have been read therefore <sil=0.334> ,COMMA the last character read is at index count minus 1 <sil=0.961> .PERIOD So <sil=0.637> ,COMMA it is not a count index if you say S of 4 that is an invalid index whereas <sil=0.500> ,COMMA S of 3 is where we should start from <sil=0.913> .PERIOD So <sil=0.361> ,COMMA start from I equal to count minus 1 that way we will start at this character <sil=0.924> .PERIOD Now <sil=0.594> ,COMMA while I is greater than or equal to 0 <sil=0.952> .PERIOD So <sil=0.552> ,COMMA we will start from S of 3 then print S of I <sil=0.986> .PERIOD So <sil=0.494> ,COMMA we will print S 3 then decrement I because you have to go back to the next to the previous character <sil=0.907> .PERIOD So <sil=0.511> ,COMMA I becomes 2 I is still greater than or equal to 0 <sil=0.926> .PERIOD So <sil=0.548> ,COMMA you will print S 2 decrement I <sil=0.972> .PERIOD So <sil=0.368> ,COMMA I becomes 1 <sil=0.998> .PERIOD So <sil=0.323> ,COMMA you will print E then decrement I you will come to I becomes 0 and you will print H you decrement once again I becomes minus 1 <sil=0.955> .PERIOD So <sil=0.486> ,COMMA you will exit the while loop <sil=0.981> .PERIOD So <sil=0.441> ,COMMA this is the array that we were doing and so <sil=0.447> ,COMMA here is the code for printing the characters and reverse <sil=0.926> .PERIOD So <sil=0.362> ,COMMA here is the pseudo code where we said print S of I instead of that in C we have a particular function which will print the character which is put care <sil=0.948> .PERIOD So <sil=0.569> ,COMMA this is the dual function of get share <sil=0.955> .PERIOD So <sil=0.581> ,COMMA put share takes a character as an argument and prints it on to the standard output <sil=0.922> .PERIOD So <sil=0.491> ,COMMA you have int I I is said to count minus 1 because that way we will get the last index of the character in the array and then you start counting down until you print the first character and until the end of the array <sil=0.912> .PERIOD So <sil=0.618> ,COMMA putting these 2 together you have the read into array part and then you have the reverse part print in reverse part <sil=0.938> .PERIOD So <sil=0.415> ,COMMA when you put these 2 together the first thing you do is bring all the declarations together <sil=0.964> .PERIOD So <sil=0.385> ,COMMA this is the declarations for read into array as well as print to put together <sil=0.952> .PERIOD Similarly <sil=0.381> ,COMMA first you have to print you have to put the code for the read into array part and then the code for the print in reverse part <sil=0.993> .PERIOD So <sil=0.647> ,COMMA let us trace the execution for a small sample input <sil=0.936> .PERIOD So <sil=0.311> ,COMMA when we have the input is hello and then the user presses control D for end of file <sil=0.992> .PERIOD Let us see what will happen <sil=0.991> .PERIOD So <sil=0.318> ,COMMA you start reading into the array <sil=0.949> .PERIOD So <sil=0.412> ,COMMA S count with count equal to 0 starts setting the array <sil=0.960> .PERIOD So <sil=0.337> ,COMMA S 0 will be H and then H S 1 will be E and so on <sil=0.970> .PERIOD So <sil=0.444> ,COMMA once CH becomes control D the end of file character you will exit the loop <sil=0.981> .PERIOD So <sil=0.306> ,COMMA the character array is hello <sil=0.991> .PERIOD So <sil=0.436> ,COMMA once CH becomes control D the end of file character you will exit the loop <sil=0.926> .PERIOD So <sil=0.303> ,COMMA the character array is hello <sil=0.925> .PERIOD So <sil=0.416> ,COMMA the first thing you have to do is <sil=0.554> ,COMMA you have to do this <sil=0.934> .PERIOD In this lecture <sil=0.568> ,COMMA let us look at one particular part of the CE compiler which is very important namely the pre processor <sil=0.940> .PERIOD Technically speaking <sil=0.561> ,COMMA the pre processor is the step before compilation <sil=0.911> .PERIOD So <sil=0.433> ,COMMA let us understand this in detail <sil=0.938> .PERIOD We have used statement such as hash include within angular brackets STDA or dot H <sil=0.615> ,COMMA also hash include within codes list dot H <sil=0.973> .PERIOD And you may have seen CE code which looks like this <sil=0.909> .PERIOD You say hash defined pi to be 3 <sil=0.986> .PERIOD 1416 hash defined max to be 9999 something like this <sil=0.956> .PERIOD So <sil=0.529> ,COMMA lines in a CE program that start with a hash symbol are called macros and they are viewed and they are processed by the CE pre processor <sil=0.991> .PERIOD Now <sil=0.362> ,COMMA the CE pre processor implements what is known as a macro language part of CE and it is used to transform CE programs before they are compiled <sil=0.987> .PERIOD So <sil=0.581> ,COMMA CE pre processor is the step just before compilation <sil=0.912> .PERIOD We do not explicitly call the CE pre processor <sil=0.591> ,COMMA but when you write GCC some file name GCC the first step is the pre processor step <sil=0.942> .PERIOD So <sil=0.341> ,COMMA as part of the compilation first the CE pre processor runs and then transforms the macros <sil=0.923> .PERIOD The resulting file including the transform macros is compiled by the CE compiler <sil=0.957> .PERIOD So <sil=0.633> ,COMMA let us look at header files <sil=0.957> .PERIOD The header file is a file containing CE declarations macro definitions etcetera to be shared between several source files <sil=0.908> .PERIOD Header files are included in your program using CE pre processor directives hash include <sil=0.939> .PERIOD For example <sil=0.593> ,COMMA we have seen include within angular brackets STDA dot H and within codes list dot H <sil=0.928> .PERIOD So <sil=0.450> ,COMMA header files serve two purposes that we have seen <sil=0.902> .PERIOD First is that it could be a system header files this declares interfaces to part of the operating system including system calls CE libraries and so on or you could have your own header files which you have written to contain declarations of your code of the functions in your code <sil=0.945> .PERIOD Now <sil=0.357> ,COMMA what does what happens exactly when you include a header file in a CE file <sil=0.934> ?QUESTIONMARK Including a header file produces the same results as copying the header file into each source file <sil=0.917> .PERIOD So <sil=0.305> ,COMMA when you say include STDA or dot H it is essentially taking the contents of the STDA dot H file and copy pasting into your source code <sil=0.925> .PERIOD So <sil=0.395> ,COMMA this happens at exactly the place where the corresponding hash include command was written <sil=0.904> .PERIOD The advantages of having this header file and hash include is that related declarations appear only in one place and if you want to change the if you want to change a particular function on a declaration of a function you just have to change it in a single file and all files which include that header file will automatically see the change <sil=0.921> .PERIOD So <sil=0.642> ,COMMA here is something that we have mentioned in the previous video if the difference between angular bracket and the double codes <sil=0.948> .PERIOD So <sil=0.364> ,COMMA the angular bracket is usually used in system header files and it searches for the file named let us say STDA dot H in a standard list of system directories <sil=0.945> .PERIOD If you say within double codes on the other hand like list dot H it searches for this list dot H first in the current directory if it is not found in the current directly then it goes again into the standard list of directories <sil=0.951> .PERIOD Now <sil=0.460> ,COMMA the argument for hash include whether you include it in a angular bracket or in a double code behaves like a string constant and it is literally put there <sil=0.966> .PERIOD So <sil=0.640> ,COMMA if you have like comments the comments are not recognized as comments if you have a star symbol for example <sil=0.348> ,COMMA it will be just put exactly like a star symbol <sil=0.921> .PERIOD So <sil=0.433> ,COMMA it is just treated as a string constant and no interpretation is done there <sil=0.905> .PERIOD Now <sil=0.439> ,COMMA let us look at very special case that could happen in the header file typically you would not do this <sil=0.941> .PERIOD So <sil=0.431> ,COMMA suppose you have within header dot H you have a you have a text character star error equal to overflow typically you do not initialize variables in a header file <sil=0.417> ,COMMA but let us say that in a particular header dot H we have this character star error equal to overflow <sil=0.981> .PERIOD Now <sil=0.516> ,COMMA in p dot C I write this very peculiar thing I write int x and then in the middle of the code I say hash include header dot H till now we have always used hash include headers in the beginning of the file <sil=0.356> ,COMMA but suppose what happens if I do it in the middle <sil=0.907> .PERIOD Now <sil=0.325> ,COMMA after the C pre-process process is the file what happens is that whatever text is there in header dot H is copy pasted at that position <sil=0.944> .PERIOD So <sil=0.520> ,COMMA for example <sil=0.638> ,COMMA this code will be transformed by the C pre-processor to look like this it will say int x and the header dot H contain the single line character star error equal to overflow <sil=0.945> .PERIOD So <sil=0.574> ,COMMA that text will come here <sil=0.903> .PERIOD Now <sil=0.446> ,COMMA this transform text is what the C pre-C compiler sees and it will compile in produce the object code or the execute <sil=0.901> .PERIOD So <sil=0.342> ,COMMA included files are not limited to declarations and macro definitions these are merely the typical users you can put any text there and when you include that header file the text will be copy pasted into the position <sil=0.971> .PERIOD Typically <sil=0.467> ,COMMA though you would want to avoid this you would want only declarations in a header file <sil=0.995> .PERIOD Now <sil=0.527> ,COMMA let us look at some other features that the C pre-processor gives we have seen in some code this use of hash define <sil=0.975> .PERIOD So <sil=0.649> ,COMMA hash define is used for what are known as object like macros <sil=0.981> .PERIOD Now <sil=0.341> ,COMMA an object like macro is basically an identifier and it will be replaced by some code text it is called object like because it looks like an object <sil=0.953> .PERIOD So <sil=0.425> ,COMMA it is most common use is to give symbolic names to numeric constants <sil=0.951> .PERIOD Suppose you want to write a program in which the maximum array size is let us say 1024 <sil=0.976> .PERIOD Instead of putting 1024 in several places <sil=0.449> ,COMMA a typical usage in a program would be to say hash define buff size <sil=0.971> .PERIOD So <sil=0.556> ,COMMA buffer size to be 1024 <sil=0.975> .PERIOD So <sil=0.555> ,COMMA you have used hash define to define as identify buff size and buff size will will be assigned the text 1024 <sil=0.959> .PERIOD So <sil=0.449> ,COMMA this says that I am defining a macro named be above size and it is an abbreviation a short form for the token 1024 <sil=0.942> .PERIOD Now <sil=0.581> ,COMMA if somewhere in your code if you say hash define buff size 1024 in all places after that the suppose you say like character star string equal to malocharcaloch buff size size of character what the preprocessor will do will will be that it will look at this string constant <sil=0.945> .PERIOD It is the name of a macro and it will replace it with 1024 which is the value of the macro <sil=0.930> .PERIOD So <sil=0.605> ,COMMA the transform text will look like this character star string equal to malocharcaloch 1024 size of character <sil=0.907> .PERIOD Now <sil=0.502> ,COMMA by convention macro names are written in upper case <sil=0.944> .PERIOD So <sil=0.508> ,COMMA that somebody who reads the code will be aware that this could be a macro because if I write it in lower case there are chances that somebody might think that it is a variable name and look for the variable <sil=0.981> .PERIOD So <sil=0.590> ,COMMA writing it in capital letters is a way of indicating to the user that this is actually a macro <sil=0.917> .PERIOD So <sil=0.327> ,COMMA please look at in a header file for example <sil=0.960> .PERIOD So <sil=0.315> ,COMMA the C preprocessor can through a program sequentially this is an important thing to understand and macro definitions take effect at the place you write them <sil=0.953> .PERIOD So <sil=0.474> ,COMMA let us look at a very specific example to illustrate this point <sil=0.988> .PERIOD So <sil=0.326> ,COMMA suppose you write Foo equal to capital X after that you have a line saying hash define X4 and then bar equal to X <sil=0.918> .PERIOD What will the C preprocessor do <sil=0.901> ?QUESTIONMARK It will look through the file and say Foo equal to X fine it does not know what X is it will not transform that line then it sees the hash define X4 <sil=0.912> .PERIOD Now <sil=0.567> ,COMMA it knows that X is a macro and it has the value 4 and then it says bar equal to X but now X is a macro the preprocessor knows about this <sil=0.965> .PERIOD So <sil=0.432> ,COMMA it will replace X with 4 <sil=0.941> .PERIOD So <sil=0.314> ,COMMA the transform text will be Foo equal to X bar equal to 4 <sil=0.978> .PERIOD It is natural to imagine that I would have Foo equal to 4 <sil=0.990> .PERIOD But that is not what happens because the way the source code was written the hash defined happened after Foo equal to X <sil=0.935> .PERIOD So <sil=0.537> ,COMMA anything that happens before the macro was defined is not changed <sil=0.962> .PERIOD Now <sil=0.505> ,COMMA let us conclude this discussion of preprocessor with a very typical project management problem and we will see third macro that third operation that is done by the C preprocessor <sil=0.995> .PERIOD This is something called hash if and this is used typically when you have multiple projects multiple files in your project and you need to include multiple header files into a single source file <sil=0.901> .PERIOD So <sil=0.418> ,COMMA let us discuss what is the problem with a particular example <sil=0.904> .PERIOD Suppose we have a list <sil=0.999> .PERIOD h and a list <sil=0.995> .PERIOD c <sil=0.975> .PERIOD So <sil=0.377> ,COMMA I have this header file list <sil=0.959> .PERIOD h <sil=0.955> .PERIOD Now <sil=0.429> ,COMMA I have a program p1 <sil=0.978> .PERIOD c that needs the list functions and also creates a bunch of new functions <sil=0.950> .PERIOD So <sil=0.624> ,COMMA its declarations will be included in p1 <sil=0.988> .PERIOD h <sil=0.955> .PERIOD Now <sil=0.643> ,COMMA in p1 <sil=0.964> .PERIOD h I would say include list <sil=0.961> .PERIOD h <sil=0.975> .PERIOD So <sil=0.599> ,COMMA this is I will have a corresponding p1 <sil=0.926> .PERIOD c which will just say include p1 <sil=0.934> .PERIOD h <sil=0.905> .PERIOD Now <sil=0.514> ,COMMA suppose that I have another file p2 <sil=0.972> .PERIOD c <sil=1.000> .PERIOD Now <sil=0.384> ,COMMA p2 <sil=0.907> .PERIOD c needs some functions in list <sil=0.901> .PERIOD h and some functions in p1 <sil=0.915> .PERIOD h <sil=0.991> .PERIOD So <sil=0.333> ,COMMA now there when I write p2 <sil=0.906> .PERIOD h I will say include p1 <sil=0.953> .PERIOD h and include list <sil=0.930> .PERIOD h <sil=0.958> .PERIOD Now <sil=0.319> ,COMMA what happens is that when we compile p2 <sil=0.907> .PERIOD c list <sil=0.981> .PERIOD h gets included twice <sil=0.930> .PERIOD First because it directly includes list <sil=0.925> .PERIOD h and second because it includes p1 <sil=0.975> .PERIOD h which itself includes list <sil=0.909> .PERIOD h <sil=0.944> .PERIOD So <sil=0.447> ,COMMA list <sil=0.944> .PERIOD h code will be copy-pasted twice in p2 <sil=0.946> .PERIOD h <sil=0.962> .PERIOD So <sil=0.602> ,COMMA for example <sil=0.482> ,COMMA this is a problem because if list <sil=0.987> .PERIOD h contains a structure definition <sil=0.425> ,COMMA it will be included twice and the compiler will produce an error <sil=0.901> .PERIOD So <sil=0.598> ,COMMA this is a standard problem in large projects where you want to include a file <sil=0.372> ,COMMA but you do not want to include it multiple times <sil=0.902> .PERIOD So <sil=0.392> ,COMMA in this particular example <sil=0.470> ,COMMA I want to include list <sil=0.977> .PERIOD h <sil=0.949> ,COMMA but I want to avoid the possibility that list <sil=0.968> .PERIOD h is included multiple times leading to compiler errors <sil=0.920> .PERIOD So <sil=0.340> ,COMMA how do we solve this <sil=0.912> ?QUESTIONMARK So <sil=0.499> ,COMMA this is a facility provided by the C pre-processor <sil=0.912> .PERIOD You can say you can use this hash if n if <sil=0.934> .PERIOD So <sil=0.430> ,COMMA it is saying that if this macro is not defined <sil=0.315> ,COMMA then do something <sil=0.902> .PERIOD So <sil=0.492> ,COMMA in list <sil=0.926> .PERIOD h <sil=0.922> ,COMMA I will write the following <sil=0.924> .PERIOD hash if and if this is a macro that I will define <sil=0.943> .PERIOD So <sil=0.373> ,COMMA usually if a file is list <sil=0.989> .PERIOD h <sil=0.948> ,COMMA the macro will be named in capital letters list underscore <sil=0.917> .PERIOD h <sil=0.960> .PERIOD If this macro is not defined <sil=0.571> ,COMMA then hash define list <sil=0.929> .PERIOD h <sil=0.972> .PERIOD So <sil=0.409> ,COMMA this says define list <sil=0.959> .PERIOD h for me and then all the remaining statements in list <sil=0.904> .PERIOD h <sil=0.976> .PERIOD And then it will be enclosed in an n if <sil=0.959> .PERIOD So <sil=0.470> ,COMMA now what happens is that <sil=0.590> ,COMMA suppose list <sil=0.947> .PERIOD h is included for the first time in p1 <sil=0.957> .PERIOD h <sil=0.919> ,COMMA then list <sil=0.948> .PERIOD h is not defined <sil=0.952> .PERIOD So <sil=0.588> ,COMMA it will define list <sil=0.911> .PERIOD h and then include list <sil=0.935> .PERIOD h in p1 <sil=0.993> .PERIOD h <sil=0.977> .PERIOD Now p2 <sil=0.960> .PERIOD h includes p1 <sil=0.918> .PERIOD h and list <sil=0.944> .PERIOD h <sil=0.933> .PERIOD So <sil=0.377> ,COMMA now when list <sil=0.964> .PERIOD h is included for the second time <sil=0.383> ,COMMA the C pre-processor will look at this statement if and if list <sil=0.991> .PERIOD h <sil=0.992> ,COMMA list underscore <sil=0.980> .PERIOD h <sil=0.976> .PERIOD That has been defined because p1 <sil=0.946> .PERIOD h has already defined it <sil=0.953> .PERIOD Cost it to be defined <sil=0.994> .PERIOD So <sil=0.511> ,COMMA it says that list <sil=0.956> .PERIOD h <sil=0.965> .PERIOD is defined <sil=0.938> .PERIOD So <sil=0.313> ,COMMA I will skip the entire thing until n if <sil=0.975> .PERIOD So <sil=0.628> ,COMMA this is one way to say that <sil=0.933> .PERIOD So <sil=0.584> ,COMMA if list <sil=0.971> .PERIOD h list underscore <sil=0.901> .PERIOD h macro is not defined as yet <sil=0.610> ,COMMA then define it and process all statements until the matching end if it is already defined <sil=0.965> .PERIOD This happens when you are trying to include it for the second time <sil=0.358> ,COMMA then all statements until the n if are skipped <sil=0.907> .PERIOD So <sil=0.609> ,COMMA you do not copy paste it for the second time <sil=0.962> .PERIOD So <sil=0.399> ,COMMA this is a standard way to avoid including one file multiple times <sil=0.954> .PERIOD So <sil=0.526> ,COMMA the high level picture of the stages in compilation <sil=0.622> ,COMMA you have retaken <sil=0.938> .PERIOD So <sil=0.311> ,COMMA the high level picture of the stages in compilation <sil=0.419> ,COMMA you have source files and then it is run through the pre-processor <sil=0.453> ,COMMA it produces the transformed files <sil=0.983> .PERIOD And then after compilation using gcc minus c <sil=0.433> ,COMMA it produces object files and after the object files are done <sil=0.449> ,COMMA they are linked to produce the executable files <sil=0.953> .PERIOD So <sil=0.581> ,COMMA when you press gcc some source file internally <sil=0.423> ,COMMA it first runs the c pre-processor <sil=0.338> ,COMMA then it runs the compiler and then it runs the linker <sil=0.902> .PERIOD And gcc provides facilities to stop the compilation at any stage <sil=0.902> .PERIOD So <sil=0.487> ,COMMA for example <sil=0.647> ,COMMA we have seen in the previous video that you can stop the compilation just after the compilation itself by using gcc minus c <sil=0.905> .PERIOD So <sil=0.629> ,COMMA it will produce dot o files and several dot o files can be later linked to produce the a dot o file <sil=0.953> .PERIOD In this video we will look at a slightly more general way of defining problems through recursion <sil=0.996> .PERIOD For the lack of a better name I will call it just two way recursion <sil=0.956> .PERIOD These are problems which are solved by calling two subinstances <sil=0.935> .PERIOD So <sil=0.422> ,COMMA this is the picture of a family tree and we will see that the call stack for a two way recursive functions looks somewhat similar to a family tree <sil=0.940> .PERIOD Let us revisit a problem that we have seen which is to find the maximum value in an integer array <sil=0.912> .PERIOD We saw that the stack depth in our earlier solution was order n because each problem of size n called one sub problem of size n minus 1 <sil=0.922> .PERIOD Now can we reduce the depth of the stack from something close to n to something smaller than n <sil=0.963> .PERIOD So <sil=0.422> ,COMMA here is an alternate way to look at the problem which can be described in a very simple way <sil=0.989> .PERIOD Instead of looking at the maximum of the first element and then the tail what I can do is take an array of size n and split it roughly into half <sil=0.905> .PERIOD So <sil=0.476> ,COMMA there is a left half and a right half each of size n over 2 <sil=0.920> .PERIOD Now imagine that you have the solution for the greatest element in the first half <sil=0.964> .PERIOD Let us call that x and imagine that you have the greatest element of the right half let us call that y <sil=0.935> .PERIOD Now whichever is greater m x and y is going to be the greatest in the whole array and this is the idea that we are going to implement right now <sil=0.905> .PERIOD So <sil=0.597> ,COMMA divide the array into about 2 equal half the first half is 0 to a n by 2 minus 1 this contains n by 2 elements and the second half is a n by 2 so on up to n minus 1 this the right half <sil=0.993> .PERIOD Now recursively find the maximum element of each half and let us say that you have x which is the maximum in the left half and y which is the maximum in the right half then you just return the larger of x and y that should be the largest element of the array <sil=0.915> .PERIOD While doing this we have to take care of the base cases this is as before for the linear case when n is 1 then the only element in the array is the maximum element <sil=0.911> .PERIOD So <sil=0.510> ,COMMA return a of 0 if n is 0 that is the array is empty you return minus infinity <sil=0.969> .PERIOD So <sil=0.512> ,COMMA let us consider a concrete array a is an integer array with these elements just to remind you the linear version was done as follows if n is 0 you return something like minus infinity a very large negative value <sil=0.980> .PERIOD Now if n is 1 you return a of 0 which is the only element in the array otherwise you have at least 2 elements and earlier what we did was you call the sub problem a plus 1 <sil=0.937> .PERIOD So <sil=0.535> ,COMMA the array which starts with the second element in the array and now the sub problem has n minus 1 elements because you are considering a 0 the first element as a separate thing <sil=0.981> .PERIOD Now what you wanted to return was maximum of whatever was return in the sub problem <sil=0.918> .PERIOD So <sil=0.346> ,COMMA let that be some max well and whichever is greater a 0 and max well that is going to be the greatest element in the array <sil=0.963> .PERIOD Now we saw that the stack depth for this problem was n because a size n problem is being reduced to a size n minus 1 problem <sil=0.979> .PERIOD So <sil=0.621> ,COMMA in each step we are reducing the size of the problem by 1 and increasing the stack depth by 1 <sil=0.945> .PERIOD So <sil=0.589> ,COMMA in total that stack depth would be n because there will be about n calls or n minus 1 calls however you want to count <sil=0.965> .PERIOD Now let us look at the 2 way recursive version <sil=0.917> .PERIOD So <sil=0.500> ,COMMA here is the algorithm that we discussed and let us just code this up <sil=0.906> .PERIOD So <sil=0.533> ,COMMA we will have int max array and then int a which is the array containing n elements and let us say that we have some constant minus infinity we have defined elsewhere in the program <sil=0.944> .PERIOD Later we will see how to do this <sil=0.989> .PERIOD Let us say that if n is equal to 0 you return minus infinity some large number some large negative value and if n is equal to 1 you return the only value in the array <sil=0.957> .PERIOD So <sil=0.362> ,COMMA these are the case cases as before <sil=0.920> .PERIOD The changes here if you have at least 2 elements then you return maximum of the values return by the 2 sub problems what are the 2 sub problems <sil=0.966> .PERIOD The first is the left half of the array which starts from a that is the first location in the array and contains n upon 2 elements <sil=0.968> .PERIOD Then we need to compute the maximum of the right half how do we find the right half <sil=0.997> .PERIOD So <sil=0.476> ,COMMA we need to skip n upon 2 elements which went to the left half to get to the first index in the right half <sil=0.980> .PERIOD So <sil=0.539> ,COMMA we do that by saying a plus n upon 2 if a is the address of the first location of the whole array then a plus n upon 2 is going to be the first address of the first location of the right half and how many elements does the right half contain n upon 2 elements went to the left <sil=0.986> .PERIOD Therefore <sil=0.476> ,COMMA what we are left with is n minus n upon 2 <sil=0.995> .PERIOD So <sil=0.629> ,COMMA notice how we call the left half starting from a and containing n upon 2 elements and the right half which is starting from a plus n upon 2 and containing n minus n upon 2 elements <sil=0.997> .PERIOD Now <sil=0.458> ,COMMA let us examine whether this is better than the previous recursive call where we reduced a problem of size n to a problem of size n upon 2 <sil=0.961> .PERIOD It was called linear recursion because we called one sub problem in order to solve the whole problem <sil=0.953> .PERIOD Here we have we are roughly dividing it into halves and then calling 2 sub problems each of size about n upon 2 <sil=0.982> .PERIOD Now <sil=0.333> ,COMMA surprisingly we will see that there is a huge improvement if you do this and this is one of the most elementary tricks in computer science it is called divide and conquer and here is a very simple example of that <sil=0.930> .PERIOD So <sil=0.612> ,COMMA if you look at the concrete array that we had and we call max array a comma 8 because this contains 8 elements <sil=0.927> .PERIOD Now <sil=0.611> ,COMMA we say that it will recursively call 2 sub problems which is maximum max array a comma 4 <sil=0.983> .PERIOD So <sil=0.637> ,COMMA that will be the first four elements starting from a 0 and then max array a plus 4 comma 4 which are the four elements starting from a 4 which is the fifth element in the array <sil=0.965> .PERIOD Now <sil=0.632> ,COMMA let us just look at the stack <sil=0.932> .PERIOD Now <sil=0.617> ,COMMA notice what I have repeatedly mentioned which is that in order to think about a recursive problem you just think about the formulation of the problem and then what you have to convince yourself is if I solve the sub problems correctly then I will get the correct solution to the problem <sil=0.977> .PERIOD So <sil=0.460> ,COMMA I will divide my work into two sub problems <sil=0.961> .PERIOD So <sil=0.315> ,COMMA both of them will report their results back to me and now what I have to do is to figure out how do I put these two solutions together in order to solve the whole sub problem <sil=0.932> .PERIOD So <sil=0.542> ,COMMA think about it in terms of the design of the algorithm and not about the execution stack <sil=0.487> ,COMMA but we will show why this is a major improvement over the linear recursion version of the same solution by looking at the stack <sil=0.970> .PERIOD So <sil=0.449> ,COMMA let us just look at the stack max array a comma 8 calls max array a comma 4 <sil=0.954> .PERIOD Now <sil=0.585> ,COMMA the way function calls in C works you will go to the second half of this problem which is a plus 4 comma 4 only after max array a comma 4 is completely done <sil=0.941> .PERIOD So <sil=0.562> ,COMMA let us now see how max a comma 4 will execute <sil=0.937> .PERIOD It has two sub problems again and let us look at the first sub problem which is max array a comma 2 that itself has a sub problem max array a comma 1 in order to abbreviate I will just put a dot there <sil=0.614> ,COMMA but that dot is supposed to signify max array <sil=0.994> .PERIOD Now <sil=0.476> ,COMMA once you have solved this suppose this is a base case now it contains only one element <sil=0.914> .PERIOD So <sil=0.361> ,COMMA the only element is the maximum <sil=0.992> .PERIOD So <sil=0.507> ,COMMA it returns that value to max array a comma 2 that is one of the sub problems for max array a comma 2 <sil=0.916> .PERIOD So <sil=0.620> ,COMMA now this max array a comma 2 calls the second sub problem that it has which is max array a plus 1 comma 1 again it is a base case it contains only one element that single element is the greatest element in that <sil=0.959> .PERIOD So <sil=0.469> ,COMMA you have two values now one coming from the left and one coming from the right and you just compare these two values and that will be the greatest value in the first two elements of the array <sil=0.977> .PERIOD So <sil=0.459> ,COMMA once you do this you return and when you return you get the value max array a comma 2 <sil=0.987> .PERIOD So <sil=0.358> ,COMMA suppose all of that happens and then you return to max array a comma 4 at this point this function will call it second component which is max array a plus 2 comma 2 and the recursion continues so as soon as a function returns its stack will be erased I am showing that by dimming out that particular function call and this proceeds <sil=0.994> .PERIOD So <sil=0.308> ,COMMA once this values obtained you can return to max array a plus 2 comma 2 now this function is finished because it has called both its sub problems <sil=0.963> .PERIOD So <sil=0.373> ,COMMA this will return and this problem has return has finished with both its sub problems <sil=0.999> .PERIOD So <sil=0.430> ,COMMA you will after this function is done you eventually unwind all the way back up to the top and now you are ready to call the second sub problem of max array a comma 8 which is max array a plus 4 comma 4 and you do it similarly <sil=0.975> .PERIOD Now <sil=0.433> ,COMMA one thing you can notice here is that at any point the active path what what are active on the stack the functions which have not yet returned are the highlighted entries in the call tree <sil=0.970> .PERIOD So <sil=0.617> ,COMMA for example at the very end the call stack contains four functions before you eventually return and compute the last compute the maximum of the whole array the worst case depth of the stack is 4 and we had 8 elements <sil=0.954> .PERIOD So <sil=0.565> ,COMMA you would think that based on this experience that the depth of the stack is about n over 2 but if you think more carefully about it what happens is that at every sub problem at every level I am dividing the problem by 2 <sil=0.947> .PERIOD So <sil=0.514> ,COMMA the depth of the stack is the maximum length path in this tree and at every step of the tree I am dividing the problem by 2 <sil=0.926> .PERIOD How many times do I have to divide n by 2 in order to reach 1 that will be the depth of the tree equivalently you can think about how many times do I have to double in order to reach n if I start from 1 that is the bottom of way <sil=0.920> .PERIOD So <sil=0.575> ,COMMA if I start from 1 and I double every level how many times do I have to double in order to reach n that is the solution to the equation 2 to the x equal to n <sil=0.938> .PERIOD So <sil=0.420> ,COMMA what I have to find is how many times do I have to double <sil=0.955> .PERIOD So <sil=0.397> ,COMMA how many times do I have to multiply 2 which itself in order to reach n and you will see that the solution is log n to the base 2 <sil=0.954> .PERIOD So <sil=0.610> ,COMMA this is going to be the height of the call graph or the call tree <sil=0.921> .PERIOD So <sil=0.329> ,COMMA the stack depth here is about 1 plus log n that is approximately correct which is a huge improvement over n if you think of n as something like 1024 which is 2 to the 10 we are saying that the stack depth is about 10 <sil=0.931> .PERIOD Notice that in the linear case we would have a stack depth of about 1024 instead we are doing about 10 <sil=0.994> .PERIOD So <sil=0.350> ,COMMA this is a huge improvement in the case of stack depth <sil=0.976> .PERIOD So <sil=0.572> ,COMMA with a very simple idea which is instead of solving once a problem of size n minus 1 what if you split it into 2 halves roughly about size n by 2 you will see that you get a huge improvement in the stack depth <sil=0.919> .PERIOD This is one of the simple ideas that we repeatedly use in computer science <sil=0.934> .PERIOD Now <sil=0.311> ,COMMA there are standard arithmetic functions also which can be defined in terms of the 2 way recursion a very classic example is Paganaji numbers <sil=0.970> .PERIOD So <sil=0.370> ,COMMA for example <sil=0.511> ,COMMA they are defined as f 0 equal to 1 f 1 equal to 1 and for n greater than or equal to 2 they are defined as f n equal to f n minus 1 plus f n minus 2 <sil=0.952> .PERIOD So <sil=0.396> ,COMMA if we code this up it is a very simple function in 5 in 10 if n is 0 or n is 1 you return 1 otherwise you return Paganaji so <sil=0.582> ,COMMA 5 of n minus 2 plus 5 of n minus 1 <sil=0.993> .PERIOD So <sil=0.566> ,COMMA here is a very simple arithmetic sequence which is defined in terms of a 2 way recursion <sil=0.907> .PERIOD So <sil=0.489> ,COMMA this is a very simple way to write it <sil=0.422> ,COMMA but it is a very inefficient way to do it <sil=0.958> .PERIOD So <sil=0.381> ,COMMA we will see why it is inefficient in a moment <sil=0.988> .PERIOD If you just think of how you trace the function in the case of a letter of a concrete Fibranaji number let us say we want to calculate the fifth Fibranaji number <sil=0.915> .PERIOD Now <sil=0.319> ,COMMA that depends on 5 4 and 5 3 <sil=0.620> ,COMMA 5 4 depends on 5 3 and 5 2 <sil=0.613> ,COMMA 5 3 depends on 5 2 and 5 1 and so on <sil=0.957> .PERIOD So <sil=0.445> ,COMMA this is the call graph that you will have the call tree that you will have if you consider the calculation of Fibranaji 5 <sil=0.915> .PERIOD Now <sil=0.416> ,COMMA what is a problem here you will see that many computations are unnecessarily done multiple times <sil=0.956> .PERIOD So <sil=0.341> ,COMMA if you look at Fibranaji 2 in the call graph it is evaluated multiple times <sil=0.978> .PERIOD So <sil=0.308> ,COMMA Fibranaji 2 is evaluated when Fibranaji 3 is called it is also called when Fibranaji 4 is called and Fibranaji 3 is called in a different context when you want to calculate Fibranaji 5 even there Fibranaji 2 is called <sil=0.998> .PERIOD So <sil=0.508> ,COMMA you will see that Fibranaji 3 is called 2 times Fibranaji 2 is called 3 times and Fibranaji 5 1 is called 5 times and so on <sil=0.918> .PERIOD So <sil=0.464> ,COMMA we are necessarily repeating the work and there are tricks in computer science to alleviate to remove this kind of unnecessary work <sil=0.329> ,COMMA but that is strictly it is not an idea that strictly falls into the concept of recursion and it is slightly outside the scope of this course <sil=0.945> .PERIOD So <sil=0.629> ,COMMA we will not cover this in this course <sil=0.420> ,COMMA but I just want to point out that even though it is natural to consider this arithmetic sequence in terms of 2 way recursion it may not be the most efficient way to do it <sil=0.985> .PERIOD In this video we will look at one of the other expressions in particular we will look at the third one which is in star mat 5 <sil=0.994> .PERIOD So <sil=0.629> ,COMMA if I had written int array 5 this means that array is an integer array of size 5 <sil=0.907> .PERIOD So <sil=0.419> ,COMMA similarly I can read this as star mat is an integer array of size 5 <sil=0.997> .PERIOD So <sil=0.566> ,COMMA in other words mat is a pointer to an array of size 5 array of int of size 5 <sil=0.909> .PERIOD We can look at it in this way and let us see what this really means <sil=0.905> .PERIOD So <sil=0.319> ,COMMA we can pictureize in this way if you de-reference mat that is if you take star mat you will get some array of size 5 of integers <sil=0.987> .PERIOD Now <sil=0.304> ,COMMA let us look at the picture <sil=0.940> .PERIOD So <sil=0.340> ,COMMA mat may be pointing to some array of size 5 which means that the next subsequent location will be another array of size 5 if it is valid address <sil=0.924> .PERIOD Now <sil=0.452> ,COMMA for the first location we can refer to it as mat 0 0 or it is the same as star mat of 0 or it is the same as star star mat <sil=0.980> .PERIOD So <sil=0.522> ,COMMA remember the general formula that we had was if I have the notation mat i j I can look it up as star mat <sil=0.922> .PERIOD So <sil=0.637> ,COMMA first let me translate mat i <sil=0.924> .PERIOD So <sil=0.587> ,COMMA that we have seen that this is simply de-referencing mat plus i that address <sil=0.932> .PERIOD So <sil=0.451> ,COMMA now we have one more subscript <sil=0.968> .PERIOD So <sil=0.394> ,COMMA in order to decode that I will do the formula for a second time <sil=0.952> .PERIOD So <sil=0.352> ,COMMA this plus j <sil=0.946> .PERIOD So <sil=0.352> ,COMMA remember that this is the general form <sil=0.980> .PERIOD So <sil=0.371> ,COMMA similarly if we have mat 0 0 I can write it as star mat of 0 or I can write it as star star mat because i and j are both 0 <sil=0.905> .PERIOD So <sil=0.340> ,COMMA this is just a special case of the general formula <sil=0.918> .PERIOD Mat plus 1 points to the second row of 5 integers <sil=0.977> .PERIOD So <sil=0.463> ,COMMA remember that the type of mat is it is a pointer to an array of size 5 of integers <sil=0.937> .PERIOD So <sil=0.391> ,COMMA the next pointer location when you do mat plus 1 goes to the next array of size 5 <sil=0.940> .PERIOD So <sil=0.317> ,COMMA mat plus 1 is another array of size 5 in particular it may be the second row of a two dimensional array where you have 5 columns <sil=0.921> .PERIOD Mat plus 2 will be similarly the third row and so on <sil=0.936> .PERIOD So <sil=0.512> ,COMMA mat 2 3 for example <sil=0.385> ,COMMA if you apply the formula it will come out to be star of star of mat plus 2 plus 3 <sil=0.938> .PERIOD Notice that all boxes are allocated in this example <sil=0.913> .PERIOD Now <sil=0.535> ,COMMA mat plus i points to the ith row of 5 integers and star mat is an array of size 5 <sil=0.925> .PERIOD This is what we have seen <sil=0.986> .PERIOD Now <sil=0.611> ,COMMA you can in order to get comfortable with the notation you can look at these formulas and try to decode like for example <sil=0.472> ,COMMA you could try what is the pointer way arithmetic way of representing the location mat 1 1 <sil=0.981> .PERIOD So <sil=0.625> ,COMMA you can see that it is definitely the first case where it is star of star mat plus 1 <sil=0.999> .PERIOD So <sil=0.613> ,COMMA that is definitely true because this is just the formula that we just now discussed <sil=0.925> .PERIOD But if I do not decode both the subscripts I decode only one subscript using pointer arithmetic and leave the other subscript as it is then I know that it is also the equivalent to 3 <sil=0.919> .PERIOD So <sil=0.316> ,COMMA 3 is also another representative and try to convince yourself by the second is not correct <sil=0.934> .PERIOD Now <sil=0.362> ,COMMA let us understand this in somewhat more detail by considering a tricky question <sil=0.988> .PERIOD We have a function int search <sil=0.906> .PERIOD So <sil=0.524> ,COMMA here is a function int search int a int and int key <sil=0.954> .PERIOD So <sil=0.419> ,COMMA what does this function do <sil=0.947> ?QUESTIONMARK It will search for key inside array a of size n a is an array with n elements and you have to search for it search inside for it for the element key <sil=0.987> .PERIOD If it is found then you return the index where it is found if it is not found you return minus 1 because minus 1 can never be a valid index in an array <sil=0.914> .PERIOD So <sil=0.386> ,COMMA when you return minus 1 you know that it is not present in the array <sil=0.902> .PERIOD Now <sil=0.649> ,COMMA can we use this function to search inside a 2 d array <sil=0.999> .PERIOD So <sil=0.526> ,COMMA we are using a 1 dimensional function in order to search inside a 2 d array <sil=0.922> .PERIOD Now <sil=0.406> ,COMMA the basic idea is that we can search rho by rho <sil=0.979> .PERIOD Each rho of a 2 dimensional array is somewhat like a 1 dimensional array <sil=0.968> .PERIOD So <sil=0.415> ,COMMA we will call search multiple times once for each row in the array until we either find it or we are done with all rows <sil=0.931> .PERIOD The algorithm is search it rho by rho <sil=0.982> .PERIOD Now <sil=0.470> ,COMMA the question is which of the following is actually doing that <sil=0.908> .PERIOD So <sil=0.643> ,COMMA we have three expressions search mat plus 1 5 key search star of mat plus 1 5 key and search mat of 1 5 key which of these will do it <sil=0.946> .PERIOD So <sil=0.578> ,COMMA this is the function of mat <sil=0.993> .PERIOD Now <sil=0.523> ,COMMA let us look at second mat is pointing to an array of size 5 <sil=0.980> .PERIOD Therefore <sil=0.595> ,COMMA mat plus 1 is also a pointer to an array of size 5 when we dereference that we get an array of size 5 <sil=0.903> .PERIOD So <sil=0.452> ,COMMA that is the right type <sil=0.946> .PERIOD So <sil=0.303> ,COMMA the first argument to search the second statement will be an array of size 5 <sil=0.968> .PERIOD So <sil=0.548> ,COMMA therefore <sil=0.387> ,COMMA the second call is valid <sil=0.921> .PERIOD What about the third call again mat of 1 is simply star of mat plus 1 if you translate into pointer arithmetic <sil=0.990> .PERIOD So <sil=0.636> ,COMMA the third line is just the second line in disguise instead of using pointer arithmetic notation we are using subscript notation <sil=0.938> .PERIOD So <sil=0.384> ,COMMA 2 and 3 in fact are equivalent <sil=0.985> .PERIOD So <sil=0.566> ,COMMA 2 is correct therefore <sil=0.466> ,COMMA 3 is also correct <sil=0.928> .PERIOD Now <sil=0.574> ,COMMA think about why statement 1 does not make sense <sil=0.952> .PERIOD So <sil=0.410> ,COMMA mat plus 1 is actually a pointer to an array of size in size 5 <sil=0.918> .PERIOD Therefore <sil=0.586> ,COMMA it is not the right type it is not an array of size 5 it is a pointer to an array of size 5 <sil=0.991> .PERIOD So <sil=0.332> ,COMMA it is not the correct type and therefore <sil=0.643> ,COMMA the first call is not valid <sil=0.991> .PERIOD The first option is a bit delicate <sil=0.976> .PERIOD So <sil=0.489> ,COMMA I would encourage you to stop here and think about why it is not correct <sil=0.956> .PERIOD Now <sil=0.539> ,COMMA let us utilize the function in order to write our routine to search inside a 2 D array <sil=0.907> .PERIOD So <sil=0.559> ,COMMA once again we are utilizing a 1 dimensional search routine in order to search inside a 2 dimensional array <sil=0.920> .PERIOD So <sil=0.472> ,COMMA let us say that we are given this int search function which can search inside a 1 dimensional array for a key <sil=0.916> .PERIOD Now <sil=0.412> ,COMMA I will write a 2 D function which can search inside a 2 D array <sil=0.935> .PERIOD Now <sil=0.435> ,COMMA the correct declaration of the function would be in star mat 5 <sil=0.968> .PERIOD And <sil=0.323> ,COMMA N rows and a key N rows is going to be the number of key rows in the array key is the key we are searching for and in star row and in star column <sil=0.946> .PERIOD So <sil=0.477> ,COMMA I want to focus on the first argument and the last two arguments <sil=0.935> .PERIOD The first argument says that I will pass you a pointer to an array of size 5 <sil=0.975> .PERIOD This is exactly what we should find out in the array of size 2 <sil=0.935> .PERIOD So <sil=0.569> ,COMMA we will have to do because then a 2 dimensional array can be just traversed by using mat plus 1 <sil=0.479> ,COMMA mat plus 2 and so on <sil=0.903> .PERIOD So <sil=0.362> ,COMMA here is the correct type declaration that should accompany the 2 D search routine <sil=0.951> .PERIOD N rows is just the number of rows key is the key <sil=0.962> .PERIOD Why are we saying in star row and in star column <sil=0.978> ?QUESTIONMARK We want to return two things <sil=0.918> .PERIOD If key is found <sil=0.380> ,COMMA we want to return its row index and its column index <sil=0.923> .PERIOD Now <sil=0.466> ,COMMA unfortunately a function can return only one value <sil=0.988> .PERIOD So <sil=0.350> ,COMMA how will you return two values <sil=0.931> ?QUESTIONMARK So <sil=0.512> ,COMMA we will say that we will not return two values <sil=0.902> .PERIOD What we will do is give me a pointer and I will write you and I will write in that address the correct row and the correct column if it is found <sil=0.944> .PERIOD Here is a standard way in C where you might encounter a situation where you need to return two values and instead what you pass are the pointers <sil=0.974> .PERIOD The algorithm is what we have discussed before <sil=0.923> .PERIOD You check each row of mat using the function search <sil=0.958> .PERIOD If search returns success <sil=0.365> ,COMMA then that will be the column index in that row because search is searching inside a 1 D array <sil=0.987> .PERIOD So <sil=0.630> ,COMMA wherever it returns that will be the column index in the I th row <sil=0.957> .PERIOD So <sil=0.576> ,COMMA now you say that the column index is that and the row index is the I that I had <sil=0.942> .PERIOD If it is not found in any of the rows <sil=0.470> ,COMMA you return minus 1 <sil=0.981> .PERIOD So <sil=0.509> ,COMMA let us write the function <sil=0.941> .PERIOD We have an I to go traverse through the rows <sil=0.922> .PERIOD We have found equal to 0 <sil=0.911> .PERIOD This will be the flag indicating whether the key is found or not and initially you just set star row equal to minus 1 and star column equal to minus 1 to indicate that I have not yet found it <sil=0.956> .PERIOD Found the key <sil=0.936> .PERIOD Now <sil=0.345> ,COMMA you write the main loop which is going through the rows 1 by 1 <sil=0.923> .PERIOD You start with rows 0 and you go on until both these conditions are true that is you have not seen all the rows I is less than n rows and you have not found the key <sil=0.932> .PERIOD So <sil=0.324> ,COMMA not found <sil=0.983> .PERIOD What should you do for to the I th row <sil=0.987> ?QUESTIONMARK I should say that search the I th row <sil=0.944> .PERIOD So <sil=0.416> ,COMMA the way I say it is search star of mat plus I is the same as saying search mat of square black at I comma 5 which is the number of columns and key which is the key that I want to search for <sil=0.974> .PERIOD The return value is stored in star column <sil=0.915> .PERIOD So <sil=0.641> ,COMMA it is you dereference call and store the return value there <sil=0.941> .PERIOD Now <sil=0.504> ,COMMA search can return either if the key is found it will return the correct column index or it will return minus 1 <sil=0.958> .PERIOD So <sil=0.631> ,COMMA you just check for that if column if star column is a non negative number then you say that it has been found <sil=0.933> .PERIOD So <sil=0.463> ,COMMA you say that the row is I <sil=0.959> .PERIOD So <sil=0.347> ,COMMA star row is I and found is now 1 <sil=0.986> .PERIOD So <sil=0.562> ,COMMA at the next iteration you will exit out of the loop because you have found the key and then the last statement in the loop will be just to increment the I variable <sil=0.921> .PERIOD Finally <sil=0.397> ,COMMA if you have done with all the rows and if you have exit out of the while loop you check whether you exit out of the while loop because you exhausted all the rows <sil=0.949> .PERIOD So <sil=0.312> ,COMMA there are two conditions to exit the while loop <sil=0.948> .PERIOD One is I is greater than or equal to n rows that is one condition <sil=0.983> .PERIOD The second is that found equal to 1 <sil=0.959> .PERIOD If you exit it because found equal to 1 then you can return the correct value without any problem <sil=0.919> .PERIOD If you exit it before you if all the rows were exhausted and you still did not find the key then you have to say that column is minus 1 <sil=0.971> .PERIOD So <sil=0.408> ,COMMA here is a brief code which will do this <sil=0.979> .PERIOD So <sil=0.512> ,COMMA this code utilizes our understanding of two dimensional arrays as basically an array of point as a pointer to an array of size 5 <sil=0.951> .PERIOD And here is why the number of columns is important because in order to do math plus 1 correctly we need to know how many bytes to skip <sil=0.963> .PERIOD And this is crucially dependent on the number of columns <sil=0.904> .PERIOD The number of rows actually does not matter because you can keep on incrementing the rows as long as the array is valid <sil=0.971> .PERIOD The number of columns is important because that is how you get to the next row <sil=0.927> .PERIOD In this video we will talk about initializing character arrays <sil=0.633> ,COMMA which are a special kind of arrays and has more features than when it comes to initialization as compared to arrays of other type <sil=0.934> .PERIOD So <sil=0.532> ,COMMA they may be initialized just like any other array and suppose I want to initialize an array to the following values <sil=0.987> .PERIOD The first is I <sil=0.310> ,COMMA the second is a space character <sil=0.646> ,COMMA then a <sil=0.589> ,COMMA then m and so on and the final character is a null character <sil=0.644> ,COMMA which will be given as backslash 0 within single codes <sil=0.959> .PERIOD Now <sil=0.617> ,COMMA we can write s <sil=0.589> ,COMMA so character s equal to and without with just the empty pair of square brackets without specifying a size and then followed by the list of characters <sil=0.961> .PERIOD Notice that each character is enclosed in single codes <sil=0.397> ,COMMA so the space character is a space enclosed in a single code and so on until the last <sil=0.336> ,COMMA which is a null character <sil=0.378> ,COMMA which is backslash 0 enclosed in a pair of single codes <sil=0.980> .PERIOD But <sil=0.609> ,COMMA c also allows us to define what are known as string constants <sil=0.943> .PERIOD So <sil=0.628> ,COMMA in order to initialize an array <sil=0.641> ,COMMA a character array <sil=0.351> ,COMMA I can also write character s square brackets is equal to I am done <sil=0.410> ,COMMA but this time within a pair of double codes <sil=0.922> .PERIOD So <sil=0.570> ,COMMA I am done is a string constant in a <sil=0.386> ,COMMA every string constant that is a string enclosed in double codes <sil=0.561> ,COMMA the null character is automatically added to the end <sil=0.980> .PERIOD So <sil=0.526> ,COMMA I want you to note this difference that here we explicitly gave a null character at the end <sil=0.314> ,COMMA here you do not have to give that <sil=0.975> .PERIOD Now <sil=0.430> ,COMMA c string constants are specified by enclosing some text within double codes <sil=0.437> ,COMMA for example <sil=0.647> ,COMMA I am a string within double codes <sil=0.984> .PERIOD Now <sil=0.488> ,COMMA we will talk about how do we print strings <sil=0.627> ,COMMA we have used string constants many times <sil=0.902> .PERIOD So <sil=0.300> ,COMMA just take a moment to think back to see whether you can figure out where we have used string constants <sil=0.916> .PERIOD So <sil=0.550> ,COMMA we have used for them for example <sil=0.383> ,COMMA in printf and scanf <sil=0.979> .PERIOD The first argument of a printer for a scanf was always a string constant <sil=0.336> ,COMMA because if you recall we had some text <sil=0.583> ,COMMA which involved special characters like new line <sil=0.346> ,COMMA it involves format specifiers like percentage D <sil=0.603> ,COMMA but whatever it was it was a bunch of characters <sil=0.986> .PERIOD So <sil=0.459> ,COMMA it was a text inside a pair of double codes <sil=0.561> ,COMMA that is a string constant <sil=0.908> .PERIOD So <sil=0.510> ,COMMA the first argument is a string constant followed by what all arguments we want to print <sil=0.960> .PERIOD Similarly <sil=0.438> ,COMMA even for scanf we had some say format specifier enclosed in double codes <sil=0.938> .PERIOD So <sil=0.532> ,COMMA that is a string constant and then you say and value <sil=0.960> .PERIOD So <sil=0.505> ,COMMA strings are printed using the percentage S option <sil=0.921> .PERIOD So <sil=0.385> ,COMMA any of the basic data types in c can be easily printed using the printf statement if you give the correct format specifier <sil=1.000> .PERIOD So <sil=0.531> ,COMMA if you have a string constant you can print it using the percentage S option <sil=0.926> .PERIOD For example <sil=0.317> ,COMMA if I want to print the string I am done within double codes <sil=0.540> ,COMMA then what I can do is I can say printf percentages I am done and this will print I space I am space done <sil=0.484> ,COMMA which is exactly what I wanted to print <sil=0.954> .PERIOD Now <sil=0.470> ,COMMA what if I initialize a character array character SDR open close square bracket <sil=0.547> ,COMMA without specifying the size <sil=0.988> .PERIOD I initialize it using a string constant I am great done within double codes <sil=0.958> .PERIOD Then I print it using printf percentages SDR <sil=0.914> .PERIOD Will this work <sil=0.868> ?QUESTIONMARK And the answer is yes it will work because c will consider this as a string constant and it will print it using percentages and you will get the correct output <sil=0.934> .PERIOD So <sil=0.611> ,COMMA state of memory after definition of this string in example 2 is that it has a list of all these characters I space A M space and so on and node the implicit null at the end <sil=0.957> .PERIOD So <sil=0.574> ,COMMA even though the double codes ended just after N when you stored it in an array there is an implicit null that is inserted at the end of the array <sil=0.911> .PERIOD So <sil=0.568> ,COMMA when you print it it will print until the null character <sil=0.946> .PERIOD So <sil=0.539> ,COMMA the null character itself at the end of a string is not printed when you print it using percentages <sil=0.971> .PERIOD Now <sil=0.611> ,COMMA let us look at the following fragment to understand slightly in a deeper way what percentage S does when you print it using printf <sil=0.958> .PERIOD So <sil=0.491> ,COMMA suppose I declare a character array using character SDR square bracket equal to I am great done within double codes <sil=0.920> .PERIOD So <sil=0.529> ,COMMA this is initialized using a string constant which means that after the last N there will be a null character in the array <sil=0.908> .PERIOD Now <sil=0.443> ,COMMA I initialize I set SDR 4 equal to null <sil=0.967> .PERIOD Note that there are 11 non null characters in the string constant <sil=0.927> .PERIOD So <sil=0.398> ,COMMA this goes from SDR 0 to SDR 10 followed by SDR 11 which is a null character <sil=0.986> .PERIOD So <sil=0.364> ,COMMA now I set SDR 4 equal to null <sil=0.964> .PERIOD So <sil=0.556> ,COMMA somewhere in the middle of the string I put a null character <sil=0.923> .PERIOD What will happen if I print it using printf percentages <sil=0.925> .PERIOD So <sil=0.367> ,COMMA let us see what happens here I declare the array and initialize it using a string constant <sil=0.953> .PERIOD So <sil=0.497> ,COMMA it has all these letters followed by a null at the end <sil=0.944> .PERIOD Then when I set SDR 4 equal to null what it does is it goes to the fourth location in the array and changes that to null <sil=0.996> .PERIOD So <sil=0.648> ,COMMA what that does is there was a space there before but now you insert a null character there <sil=0.951> .PERIOD After the null character there are other non null characters and then there is a second null <sil=0.998> .PERIOD So <sil=0.553> ,COMMA what will happen when you print <sil=0.880> ?QUESTIONMARK It will just print I am and stop there <sil=0.955> .PERIOD It will not print the remaining characters and why does that happen <sil=0.919> .PERIOD So <sil=0.367> ,COMMA a string of as far as C is concerned is a sequence of characters terminated by a null <sil=0.990> .PERIOD This null is not part of the string <sil=0.901> .PERIOD So <sil=0.611> ,COMMA there may be non null characters after the first occurrence of null in SDR but they are not considered part of the string SDR <sil=0.990> .PERIOD They are part of the character array but when you look at SDR as a string it is just the first null character <sil=0.937> .PERIOD So <sil=0.424> ,COMMA when you print it using percentage S only the part until the first null is printed <sil=0.929> .PERIOD So <sil=0.498> ,COMMA that is considered the string the character array is bigger <sil=0.907> .PERIOD So <sil=0.508> ,COMMA it will just print I am and stop there <sil=0.947> .PERIOD So <sil=0.376> ,COMMA do I lose the characters after the first null and where do they go <sil=0.921> ?QUESTIONMARK Well of course <sil=0.642> ,COMMA they do not go anywhere they remain where they are <sil=0.916> .PERIOD So <sil=0.429> ,COMMA what is the new state of the array <sil=0.980> ?QUESTIONMARK The new state of the array is I space M and then there is a null and then there are some other characters <sil=0.983> .PERIOD So <sil=0.560> ,COMMA if I print it using percentage S it will only come up to I am and then stop there <sil=0.905> .PERIOD So <sil=0.524> ,COMMA is there any way to print the remaining characters <sil=0.966> ?QUESTIONMARK Of course <sil=0.303> ,COMMA there is a way <sil=0.963> .PERIOD So <sil=0.425> ,COMMA if I print it using percentage S I will get I am but I could easily write a loop like this <sil=0.923> .PERIOD I will say int I and then for I equal to 0 until 11 I plus plus and then put car SDR I <sil=0.961> .PERIOD So <sil=0.612> ,COMMA this will print the character SDR 0 <sil=0.302> ,COMMA SDR 1 and so on up to SDR 11 regardless of whether that character is null or not <sil=0.929> .PERIOD If it is null it will do something but it will still go on to the next character <sil=0.929> .PERIOD If you run this what you will see is it will print the first character which is I then it will print the second character which is space then it will print the third character which is A <sil=0.976> .PERIOD So <sil=0.400> ,COMMA these three are printed as they are and then M and the fifth is a null character <sil=0.903> .PERIOD What do you mean by printing a null character <sil=0.903> ?QUESTIONMARK It may not print anything <sil=0.948> .PERIOD So <sil=0.575> ,COMMA it may be just skipped but then it goes on to the next character GR8 DON and there it stops because it does not print the 11th character <sil=0.935> .PERIOD So <sil=0.470> ,COMMA the null character in this example is not printed <sil=0.907> .PERIOD Now <sil=0.504> ,COMMA the way the null character is treated on different terminals may be different <sil=0.985> .PERIOD So <sil=0.640> ,COMMA on some Linux terminals if you ask to print null character it will just not print anything but other character terminals may print them in different ways <sil=0.916> .PERIOD In this video we will look at a few basic things about file handling and see <sil=0.913> .PERIOD This is a vast topic in itself and we will see just the basics of this <sil=0.943> .PERIOD So <sil=0.341> ,COMMA let us begin by describing what are files <sil=0.928> .PERIOD Now <sil=0.318> ,COMMA you would think that the most natural way to define what a file is <sil=0.390> ,COMMA it is a set of bytes <sil=0.446> ,COMMA a collection of bytes sitting in secondary storage like maybe your hard drive <sil=0.406> ,COMMA maybe your CD room drive or DVD drive or something <sil=0.950> .PERIOD I mean it is on a secondary storage device <sil=0.952> .PERIOD But the actual description is that any addressable part of the file system in an operating system is a file <sil=0.906> .PERIOD Now <sil=0.471> ,COMMA this includes extremely bizarre strange things <sil=0.918> .PERIOD For example <sil=0.506> ,COMMA slash dev slash null in Linux <sil=0.600> ,COMMA this stands for nothing <sil=0.954> .PERIOD So <sil=0.623> ,COMMA if you write to slash dev slash null <sil=0.401> ,COMMA it is like discarding the data <sil=0.933> .PERIOD Similarly <sil=0.346> ,COMMA slash dev slash u rant <sil=0.536> ,COMMA this is the random data device <sil=0.999> .PERIOD If you read from here <sil=0.469> ,COMMA you will get random data <sil=0.902> .PERIOD Slash dev slash audio is speakers <sil=0.951> .PERIOD So <sil=0.466> ,COMMA if you write some data into that <sil=0.454> ,COMMA it will be heard on the speakers <sil=0.904> .PERIOD And of course <sil=0.517> ,COMMA plain old data files <sil=0.930> .PERIOD For example <sil=0.454> ,COMMA in your home directly <sil=0.625> ,COMMA you may have slash home slash down to slash input dot text <sil=0.914> .PERIOD So <sil=0.332> ,COMMA input dot text is just a collection of bytes <sil=0.913> .PERIOD So <sil=0.545> ,COMMA we will not bother with defining what a file says <sil=0.938> .PERIOD But it is something that can be manipulated using the file system interface <sil=0.946> .PERIOD So <sil=0.335> ,COMMA you can open a file system interface to that file <sil=0.905> .PERIOD You can read from that file <sil=0.910> .PERIOD You can write into that file <sil=0.995> .PERIOD You can close that file and so on <sil=0.953> .PERIOD Now recall that in one of our earlier lectures <sil=0.506> ,COMMA I said that there are three files which are available by default to all C programs <sil=0.909> .PERIOD So <sil=0.351> ,COMMA these are standard input <sil=0.356> ,COMMA STDIN <sil=0.922> .PERIOD This is associated usually with the keyboard <sil=0.906> .PERIOD And this is where scanf <sil=0.587> ,COMMA get char <sil=0.585> ,COMMA get us <sil=0.339> ,COMMA these kind of functions get their input from <sil=0.971> .PERIOD It has file descriptors 0 <sil=0.927> .PERIOD Similarly <sil=0.358> ,COMMA standard output STD out is where printf <sil=0.501> ,COMMA put car <sil=0.397> ,COMMA put s <sil=0.526> ,COMMA all these functions output their data to <sil=0.904> .PERIOD This is usually visible on the terminal <sil=0.498> ,COMMA on the screen <sil=0.979> .PERIOD This has file descriptor 1 <sil=0.995> .PERIOD We also have a third file which is known as standard error <sil=0.979> .PERIOD This is the standard error console and it has file descriptor 2 <sil=0.993> .PERIOD Usually <sil=0.398> ,COMMA you can print error messages to STDERR <sil=0.985> .PERIOD We haven't seen how to print error messages to STDERR so far <sil=0.906> .PERIOD We will see that in this video <sil=1.000> .PERIOD Now <sil=0.620> ,COMMA how do you read input using standard file descriptors <sil=0.478> ,COMMA but from sources other than keyboard and so on <sil=0.954> .PERIOD So <sil=0.397> ,COMMA for example <sil=0.447> ,COMMA if you are running A dot out and you want to take the input not from the keyboard <sil=0.480> ,COMMA but from an input file <sil=0.364> ,COMMA you can say slash A dot out less than input file <sil=0.973> .PERIOD This says that the input is coming from the file input file <sil=0.946> .PERIOD So <sil=0.543> ,COMMA this is the input file as the source instead of the keyboard <sil=0.970> .PERIOD Similarly <sil=0.536> ,COMMA if you want to redirect <sil=0.517> ,COMMA so if you want to redirect the output to a particular output file instead of the screen <sil=0.361> ,COMMA you can say slash A dot out greater than out file <sil=0.903> .PERIOD So <sil=0.620> ,COMMA this will use the out file as the output instead of the terminal <sil=0.955> .PERIOD If you want to output something <sil=0.337> ,COMMA the error messages to error file <sil=0.558> ,COMMA you can say slash A dot out to greater than error file <sil=0.968> .PERIOD Two stands for the standard error console <sil=0.959> .PERIOD So <sil=0.316> ,COMMA if you say redirect this to this file <sil=0.337> ,COMMA you will say the standard output should get the standard output messages and the standard error messages should go to error file <sil=0.993> .PERIOD So <sil=0.634> ,COMMA Linux gives you some facilities to take input from other files using the standard input and the output <sil=0.919> .PERIOD So <sil=0.428> ,COMMA what you say is that instead of the standard input <sil=0.546> ,COMMA you can use this less than greater than arrows in order to redirect input from some file or output to another file or error to another file <sil=0.946> .PERIOD So <sil=0.305> ,COMMA this is the facility Linux gives you <sil=0.626> ,COMMA but consider the general situation when you have a program <sil=0.347> ,COMMA you want to read the input from multiple files and maybe output to multiple files <sil=0.900> .PERIOD So <sil=0.595> ,COMMA this is the general situation <sil=0.603> ,COMMA we just saw how to take input from one particular input file <sil=0.519> ,COMMA how to output to another input output file using the redirection operator the less than and the greater than operation on Linux <sil=0.994> .PERIOD So <sil=0.309> ,COMMA the redirection mechanism is provided by the Linux shell and is not part of the C programming language <sil=0.989> .PERIOD So <sil=0.521> ,COMMA is there a way to do it in C itself rather than using the facilities of Linux <sil=0.948> .PERIOD So <sil=0.521> ,COMMA can we read from other files other than the standard input <sil=0.576> ,COMMA can we write into other files other than writing on to the screen standard output and so on <sil=0.931> .PERIOD So <sil=0.516> ,COMMA we look at the general scheme of file handling in C <sil=0.540> ,COMMA all these functions that I am going to talk about are in STDIO dot itself <sil=0.992> .PERIOD So <sil=0.347> ,COMMA you do not need to include any more files <sil=0.903> .PERIOD So <sil=0.383> ,COMMA if you want to open the file for reading or writing etcetera <sil=0.585> ,COMMA we need to first open the file <sil=0.935> .PERIOD The three standard files <sil=0.310> ,COMMA STDIO <sil=0.510> ,COMMA STDIN and STDIER are available to the program <sil=0.470> ,COMMA any other file you have to open the file and the function to do that is F open takes two arguments name and mode and we will see what these are soon and it returns something called a file pointer <sil=0.953> .PERIOD Now <sil=0.340> ,COMMA file pointer is a pointer to a structure and that structure contains a lot of information about the file <sil=0.951> .PERIOD For example <sil=0.634> ,COMMA where is it situated <sil=0.901> ?QUESTIONMARK The current position being in the being read in the file <sil=0.929> .PERIOD So <sil=0.528> ,COMMA maybe you have read 1000 bytes and you are about to read the 1000 and first byte <sil=0.961> .PERIOD So <sil=0.485> ,COMMA it has that information and various maintenance information about the file <sil=0.903> .PERIOD Now <sil=0.358> ,COMMA in order to read or write into the file <sil=0.407> ,COMMA you can use F scan F or F print F <sil=0.972> .PERIOD These are the analogs of scan F and print F <sil=0.622> ,COMMA which allow you to write to arbitrary files <sil=0.925> .PERIOD It takes three arguments <sil=0.512> ,COMMA at least two arguments <sil=0.426> ,COMMA the first is the file pointer where you want to write the file <sil=0.420> ,COMMA where you want to read from the file and so on <sil=0.977> .PERIOD Then <sil=0.542> ,COMMA there is a format specifier just as a normal scan F or normal print F and then further arguments <sil=0.974> .PERIOD So <sil=0.460> ,COMMA the difference here is that <sil=0.415> ,COMMA whereas scan F and print F started with the format specifiers <sil=0.594> ,COMMA we have an additional file pointer in the beginning <sil=0.976> .PERIOD So <sil=0.478> ,COMMA compare with the scan F and the print F <sil=0.494> ,COMMA the first argument F P is missing <sil=0.960> .PERIOD This is because scan F just assumes that the file it has to read from is the standard input and print F assumes that it has to print to the standard output and to close the file you say F close F P <sil=0.915> .PERIOD Notice the way the F scan F <sil=0.508> ,COMMA print F and F close work <sil=0.492> ,COMMA they do not take the file name as input <sil=0.359> ,COMMA only F open takes the name of the file as input <sil=0.968> .PERIOD Whatever F open returns the file pointer <sil=0.578> ,COMMA those are the arguments to F scan F <sil=0.460> ,COMMA print F and F close <sil=0.937> .PERIOD This is because once it is once a file has been opened <sil=0.524> ,COMMA all the information that scan F scan F <sil=0.363> ,COMMA print F and F close need are already in the structure pointed to by F P <sil=0.974> .PERIOD Now <sil=0.380> ,COMMA let us write a very simple program <sil=0.559> ,COMMA this takes two files <sil=0.338> ,COMMA it takes the names of two files and what it does is <sil=0.394> ,COMMA it first prints the contents of the first file and then prints the contents of the second file and these will be output to the standard output <sil=0.941> .PERIOD What is the algorithm <sil=0.973> ?QUESTIONMARK It is very simple <sil=0.606> ,COMMA you have to first read the file names <sil=0.439> ,COMMA then open file 1 <sil=0.424> ,COMMA if open fails we exit <sil=0.929> .PERIOD Now <sil=0.505> ,COMMA if print the contents of file 1 to STD out <sil=0.382> ,COMMA after you are done you close file 1 <sil=0.626> ,COMMA then you open file 2 <sil=0.648> ,COMMA check whether open has succeeded if it has fail we exit <sil=0.490> ,COMMA then print the contents of file 2 to STD out <sil=0.430> ,COMMA close file 2 and that is it <sil=0.945> .PERIOD So <sil=0.642> ,COMMA let us see what each of these steps in slightly more detail <sil=0.611> ,COMMA how do you open the file <sil=0.378> ,COMMA we open it using a standard called F open <sil=0.393> ,COMMA F open takes two arguments the name and the mode as character pointers and returns a file point <sil=0.913> .PERIOD The first argument name is the name of the file and the name of the file can be given in short form <sil=0.387> ,COMMA suppose you are already in a directory where that file is situated <sil=0.536> ,COMMA then you can just give the name of the file for example <sil=0.349> ,COMMA input file or you can give the full path name of that file in the operating system <sil=0.962> .PERIOD So <sil=0.422> ,COMMA for example <sil=0.412> ,COMMA input file may be in the directory slash home slash dawn <sil=0.935> .PERIOD So <sil=0.533> ,COMMA in that case you can give the name as slash home slash dawn slash input file <sil=0.967> .PERIOD So <sil=0.329> ,COMMA this will be the full path name either of this is accepted <sil=0.916> .PERIOD Now <sil=0.622> ,COMMA the second argument is the mode <sil=0.567> ,COMMA this is the way in which you want to open the file <sil=0.970> .PERIOD So <sil=0.458> ,COMMA what are the common modes for example <sil=0.620> ,COMMA if you give R this will open the file in read only mode <sil=0.577> ,COMMA this is if you want to just read a file and not write to that file <sil=0.379> ,COMMA there are also other situations where the medium itself may not support writing <sil=0.982> .PERIOD For example <sil=0.420> ,COMMA if you have a CD roam disk <sil=0.612> ,COMMA then you cannot write to that <sil=0.991> .PERIOD So <sil=0.517> ,COMMA it can only be opened in a read only mode <sil=0.924> .PERIOD If you give W this is the write mode <sil=0.939> .PERIOD Now <sil=0.516> ,COMMA the first write happens at the beginning of the file <sil=0.946> .PERIOD So <sil=0.392> ,COMMA if the file already exists it will be overwritten <sil=0.968> .PERIOD If a file does not exist <sil=0.601> ,COMMA so this is the name of a new file that we support commonly is known as the append mode you specify that by saying the mode is A <sil=0.998> .PERIOD So <sil=0.435> ,COMMA if you open the file for append mode <sil=0.408> ,COMMA then instead of the name writing at the first location of the file <sil=0.439> ,COMMA it will write at the end of the current file <sil=0.987> .PERIOD So <sil=0.406> ,COMMA if the file does not exist <sil=0.419> ,COMMA then it will start from the first location <sil=0.917> .PERIOD If the file exists <sil=0.600> ,COMMA it will go to the end of the file and start writing from there <sil=0.909> .PERIOD So <sil=0.384> ,COMMA append does not overwrite the file <sil=0.955> .PERIOD We have seen the arguments of F open <sil=0.925> .PERIOD Now <sil=0.614> ,COMMA let us look at what it returns <sil=0.982> .PERIOD If successful F open returns what is known as a file pointer <sil=0.573> ,COMMA this is later used for F print F scan F close as I just mentioned <sil=0.969> .PERIOD If unsuccessful the file may be you try to open a non-existent file for reading and or you try to write to a file which cannot be return to for example <sil=0.415> ,COMMA it is a file sitting inside a CD-ROM drive and you are not allowed to write to it <sil=0.918> .PERIOD So <sil=0.581> ,COMMA if you try to open the file in write mode <sil=0.458> ,COMMA then you have a problem <sil=0.989> .PERIOD So <sil=0.319> ,COMMA for whatever reason <sil=0.384> ,COMMA if the file open does not succeed <sil=0.642> ,COMMA then the F open returns in null and it is always a good idea to check for these errors <sil=0.916> .PERIOD So <sil=0.490> ,COMMA just try opening a file and always check whether it has returned a null <sil=0.959> .PERIOD So <sil=0.608> ,COMMA let us write the program that we were discussing which will take two input files and print one file and then print the other file <sil=0.916> .PERIOD So <sil=0.624> ,COMMA the program is fairly simple <sil=0.959> .PERIOD We have a main function <sil=0.929> .PERIOD You have two file pointers F P 1 and F P 2 and then two file names <sil=0.323> ,COMMA file name 1 and file name 2 <sil=0.941> .PERIOD You get the input you get the file name 1 from the input <sil=0.305> ,COMMA you get file name 2 from input using getters functions <sil=0.979> .PERIOD Now <sil=0.307> ,COMMA what we have to first do is write the contents of the first file <sil=0.990> .PERIOD So <sil=0.638> ,COMMA try opening the file <sil=0.940> .PERIOD So <sil=0.303> ,COMMA if F P 1 equal to F open file name 1 R because we just need to read from the file <sil=0.620> ,COMMA we do not need to write into it <sil=0.943> .PERIOD So <sil=0.561> ,COMMA open it in R mode <sil=0.943> .PERIOD If it is successful that is if it is or rather if it has failed <sil=0.998> .PERIOD So <sil=0.413> ,COMMA if it has returned a null <sil=0.569> ,COMMA then you just say print if that it has failed <sil=0.998> .PERIOD And here is for the first time we are seeing how to print to the standard error <sil=0.965> .PERIOD So <sil=0.522> ,COMMA in STD E R R is any other file <sil=0.401> ,COMMA you can is similar to any other file <sil=0.552> ,COMMA you can just say F print of STD E R R and then opening file failed <sil=0.539> ,COMMA file name 1 <sil=0.967> .PERIOD So <sil=0.615> ,COMMA we try to open file name with file name 1 as the name <sil=0.333> ,COMMA but there was some error <sil=0.964> .PERIOD So <sil=0.382> ,COMMA try to the error terminal which is STD E R R <sil=0.912> .PERIOD Now <sil=0.550> ,COMMA once you do that <sil=0.498> ,COMMA we will call the function copy file F P 1 to STD out <sil=0.976> .PERIOD So <sil=0.364> ,COMMA here is a function that we will write <sil=0.581> ,COMMA which will copy from a source file to a destination file <sil=0.978> .PERIOD And what it takes is what it takes are pointers to those files <sil=0.913> .PERIOD Once you are done <sil=0.507> ,COMMA you close the file 1 and then you repeat the whole process <sil=0.459> ,COMMA exactly the same process for file 2 <sil=0.910> .PERIOD So <sil=0.421> ,COMMA try to open it <sil=0.338> ,COMMA if there is an error <sil=0.644> ,COMMA you print the error message to STD E R R <sil=0.434> ,COMMA then copy the file from F P 2 to STD out and finally <sil=0.518> ,COMMA close the file <sil=0.922> .PERIOD Once you are done <sil=0.397> ,COMMA you can return from name <sil=0.979> .PERIOD So <sil=0.519> ,COMMA now what is left is what is this copy file function <sil=0.941> .PERIOD So <sil=0.368> ,COMMA let us look at the copy file function <sil=0.916> .PERIOD Now <sil=0.633> ,COMMA there are two ways to start writing any function which takes files as arguments <sil=0.976> .PERIOD One is you can take the file name as the argument itself and within the function try to open the file <sil=0.976> .PERIOD So <sil=0.648> ,COMMA you will get a file pointer and you can start reading from the file using F scan F and writing to the file using F print F <sil=0.971> .PERIOD This is possible <sil=0.923> .PERIOD It is somewhat more convenient to say that I assume that the files are already open and I am getting the file names as the pointer using file pointers <sil=0.994> .PERIOD This avoids duplication of work <sil=0.994> .PERIOD The main doesn't have to open the file and then a brief function has to open the file again and again <sil=0.959> .PERIOD Instead <sil=0.371> ,COMMA what you can just say that I assume that the caller function has already the file open and I will just take the file pointer as the argument <sil=0.960> .PERIOD So <sil=0.497> ,COMMA let us look at this function <sil=0.977> .PERIOD It is a void function <sil=0.983> .PERIOD So <sil=0.610> ,COMMA it does not return anything <sil=0.367> ,COMMA it just performs an action <sil=0.976> .PERIOD So <sil=0.381> ,COMMA name is copy file takes two arguments from F P which is a file pointer after to the source file and two F P which is file pointer to the destination file <sil=0.964> .PERIOD And what does the function do <sil=0.939> ?QUESTIONMARK We have a character C and here is a function we will see in a later video <sil=0.996> .PERIOD But right now it just checks whether from F P has encountered enter file <sil=0.993> .PERIOD So <sil=0.626> ,COMMA F E O F just tells you whether you are done with the from file <sil=0.918> .PERIOD So <sil=0.567> ,COMMA if you are not done with the from file <sil=0.398> ,COMMA what you do is you scan one character from the from file <sil=0.992> .PERIOD So <sil=0.597> ,COMMA F scan F from F P percentage C and C <sil=0.966> .PERIOD So <sil=0.398> ,COMMA this will read one character from the source file from F P and read it into the variable C <sil=0.984> .PERIOD Now <sil=0.362> ,COMMA what we have to do is to print that to two F P <sil=0.903> .PERIOD So <sil=0.363> ,COMMA you say F print F two F P percentage C comma C <sil=0.986> .PERIOD So <sil=0.628> ,COMMA this is exactly like scan F and print F <sil=0.474> ,COMMA but taking one extra argument <sil=0.986> .PERIOD So <sil=0.495> ,COMMA in the case of scan F it just says what is the source file that is the file pointer argument <sil=0.964> .PERIOD In the case of F print F you have to take the destination file which is two F P that is the extra argument and that is the function <sil=0.990> .PERIOD In this lecture <sil=0.389> ,COMMA we will see a slightly more advanced data type than a sinkley linked list <sil=0.960> .PERIOD We will briefly go over one or two functions to manipulate the data structure <sil=0.903> .PERIOD The principle of manipulating the data structure for the other operations is similar <sil=0.928> .PERIOD So <sil=0.387> ,COMMA in the case of a sinkley linked list <sil=0.318> ,COMMA we have seen that every node has one link to its next neighbor <sil=0.994> .PERIOD And we have seen this problem in a sinkley linked list that if you are at a current node in a linked list <sil=0.345> ,COMMA you can always go forward <sil=0.392> ,COMMA but there is no way to go back <sil=0.922> .PERIOD There is one <sil=0.415> ,COMMA the only way to get to its previous node is to start all over again from the beginning of the list and traverse until you reach a list <sil=0.498> ,COMMA traverse until you reach the previous node <sil=0.900> .PERIOD So <sil=0.359> ,COMMA we can easily remedy this by thinking of a data structure <sil=0.540> ,COMMA a slightly more involved data structure <sil=0.615> ,COMMA where every node has two links <sil=0.976> .PERIOD So <sil=0.645> ,COMMA look at this node 2 <sil=0.958> .PERIOD So <sil=0.348> ,COMMA it has two links <sil=0.526> ,COMMA one is to its neighbor <sil=0.489> ,COMMA successive neighbor <sil=0.918> .PERIOD So <sil=0.605> ,COMMA it is its next node <sil=0.958> .PERIOD There is another link which goes back to its previous neighbor <sil=0.943> .PERIOD So <sil=0.432> ,COMMA in this data structure <sil=0.313> ,COMMA there are two links per node <sil=0.913> .PERIOD Therefore <sil=0.626> ,COMMA it is known as a doubley linked list <sil=0.910> .PERIOD And this list obviously <sil=0.440> ,COMMA you can go from a current node <sil=0.446> ,COMMA you can go forward or backward <sil=0.905> .PERIOD So <sil=0.574> ,COMMA easily <sil=0.907> .PERIOD So <sil=0.302> ,COMMA now the variation is this <sil=0.600> ,COMMA if each node has three fields <sil=0.517> ,COMMA one is a pointer to the previous node <sil=0.380> ,COMMA the second is the data in the node and the third is the pointer to the next node <sil=0.957> .PERIOD So <sil=0.399> ,COMMA how will the definition look like <sil=0.948> ?QUESTIONMARK It will say something like struct DLL node <sil=0.369> ,COMMA doubley linked list node <sil=0.519> ,COMMA it will have one field which is data in data <sil=0.466> ,COMMA let us say <sil=0.313> .PERIOD And then two nodes struct DLL node next and struct DLL node previous <sil=0.958> .PERIOD So <sil=0.540> ,COMMA one to go to the next node and another to go to the previous node <sil=0.977> .PERIOD Now <sil=0.518> ,COMMA we will need two pointers typically for a doubley linked list <sil=0.999> .PERIOD One is the pointer to the beginning of the list which is usually called the head and then another to the end of the list which is usually called the tail <sil=0.945> .PERIOD So <sil=0.368> ,COMMA I will use a type def in order to shorten the name <sil=0.319> ,COMMA I will just say type def struct DLL node star node pointer <sil=0.929> .PERIOD And then I will say that the list has two node pointers node pointer head and node pointer last <sil=0.929> .PERIOD So <sil=0.408> ,COMMA doubley linked list <sil=0.567> ,COMMA each node in the doubley linked list has two list <sil=0.411> ,COMMA one to its previous node and another to its next node <sil=0.905> .PERIOD And the list itself has two pointers <sil=0.317> ,COMMA one to the beginning of the list called the tail and another to the end of the list called the tail <sil=0.901> .PERIOD So <sil=0.413> ,COMMA now doubley linked list is another data structure <sil=0.545> ,COMMA notice that we have seen two or three data structure so far arrays and one which see already provides <sil=0.987> .PERIOD We have already seen simply linked list <sil=0.566> ,COMMA now we have seen a third linked list <sil=0.491> ,COMMA third data structure which is a doubley linked list <sil=0.901> .PERIOD Now <sil=0.632> ,COMMA a data structure has data and a bunch of operations defined on it <sil=0.937> .PERIOD So <sil=0.402> ,COMMA let us look at typical operations that can be defined on a doubley linked list and we will go over the implementation of two or three of them <sil=0.997> .PERIOD So <sil=0.575> ,COMMA node pointer head so this is a function that should return the head of the list <sil=0.996> .PERIOD Similarly <sil=0.331> ,COMMA node pointer tail this should return the tail of the list insert before <sil=0.964> .PERIOD So <sil=0.485> ,COMMA this is like the insert before node in the case of a singly linked list <sil=0.972> .PERIOD So <sil=0.437> ,COMMA here we are given a current node and we have to insert before a current node in the doubley linked list <sil=0.945> .PERIOD Notice this was difficult in a singly linked list because there was no way to go from a current node to a previous node <sil=0.946> .PERIOD We could always go to the next node <sil=0.995> .PERIOD So <sil=0.468> ,COMMA if I say that here is a node and insert before that node in a singly linked list it is difficult <sil=0.961> .PERIOD You need some extra information but in a doubley linked list you have the current node and you can use the previous link in order to go before that <sil=0.956> .PERIOD Insert after node also can be done this could also be done in a singly linked list <sil=0.936> .PERIOD So <sil=0.539> ,COMMA and then you can think of several other common like you can think of a make node you can think of a make list with a single with a single node pointer to by p new <sil=0.904> .PERIOD You can make an empty list you can check whether a given list is empty <sil=0.949> .PERIOD You can write functions to copy a doubley linked list to a new doubley linked list <sil=0.964> .PERIOD You can concatenate two doubley linked list <sil=0.944> .PERIOD You can do a deep concatenate we will see this in a future slide <sil=0.938> .PERIOD You can append two linked list and so on <sil=0.906> .PERIOD Similarly <sil=0.488> ,COMMA we can have insert since we have insert functions we can also have delete functions you can delete a particular node <sil=0.974> .PERIOD You can extract a node in the sense that so delete would take out a node and free the memory allocated to the node extract would just take out the node from the linked list but you retain the node <sil=0.943> .PERIOD You can delete an entire list and so on <sil=0.972> .PERIOD So <sil=0.536> ,COMMA let us look at a couple of these functions other functions can be written in similar manner <sil=0.991> .PERIOD So <sil=0.647> ,COMMA suppose let us take insert before node this was a function that was not easy with the singly linked list <sil=0.979> .PERIOD So <sil=0.405> ,COMMA I am given a linked list L I am given a current node p C U R R and a new node to insert before the current node <sil=0.997> .PERIOD So <sil=0.322> ,COMMA what are the things to check if the list is empty then insert before the current node just means that you create a new node and return the new list <sil=0.955> .PERIOD Now <sil=0.455> ,COMMA if the head of the list is null then you just say that the now the new list contains only one node L head will point to new L tail will point to new <sil=0.928> .PERIOD So <sil=0.491> ,COMMA if the list itself was null then what you do is you create a new node now the new list contains only one element <sil=0.934> .PERIOD So <sil=0.498> ,COMMA the head will point to that and the tail will also point to that and you return that now you come to the non trivial case <sil=0.915> .PERIOD Suppose there is a list and the list has some elements then so if p current is not equal to null then what you do is sorry if p current equal to null then you return the L this is an error if p current is not equal to null then what you do is the following <sil=0.908> .PERIOD So <sil=0.647> ,COMMA now you have to insert p new into the list so how do you do this <sil=0.930> .PERIOD So <sil=0.412> ,COMMA we say that the new nodes next will be so we are trying to insert p new will be so we are trying to insert p new before p current <sil=0.971> .PERIOD So <sil=0.403> ,COMMA the new nodes next will so the new nodes next will be p current p current previous will go to p new and so the p new next will go to p current and p current previous will go to p new <sil=0.940> .PERIOD Similarly <sil=0.643> ,COMMA we have to say that the previous node the node before p current it has to point to p new so p current previous that nodes next will go point to p new and then you return the new list <sil=0.956> .PERIOD So <sil=0.602> ,COMMA this can be done by looking at pointers and handling pointers carefully <sil=0.913> .PERIOD So <sil=0.374> ,COMMA now let us see how to delete a particular node in a list <sil=0.908> .PERIOD So <sil=0.357> ,COMMA if you have to delete the header of the list then if there is a list you just delete the header and you just free the entire list <sil=0.980> .PERIOD Now <sil=0.588> ,COMMA if you have to delete a particular node in the middle of a list what do you do <sil=0.983> ?QUESTIONMARK So <sil=0.498> ,COMMA let us look at the various cases <sil=0.954> .PERIOD So <sil=0.552> ,COMMA in case one the node that you want to delete is the head of the list <sil=0.978> .PERIOD So <sil=0.422> ,COMMA in this case suppose you want to delete p what would you do you would make head point to the next element and free p <sil=0.989> .PERIOD So <sil=0.598> ,COMMA head will be made to point to p next <sil=0.978> .PERIOD So <sil=0.384> ,COMMA this is the line here L head will go to p next <sil=0.993> .PERIOD Now <sil=0.577> ,COMMA this guy previous will be set to null because we are going to delete this node <sil=0.979> .PERIOD So <sil=0.399> ,COMMA this guy previous will be set to null <sil=0.981> .PERIOD So <sil=0.593> ,COMMA now it does not point to anything and then you will free p <sil=0.977> .PERIOD So <sil=0.397> ,COMMA this is the first case where p the node to be deleted was the head of the list <sil=0.939> .PERIOD Now <sil=0.333> ,COMMA similarly if you want to delete the tail of the list <sil=0.955> .PERIOD So <sil=0.382> ,COMMA now what should you do here the tail should go to p previous <sil=0.996> .PERIOD So <sil=0.554> ,COMMA in case two when p is the end of the list that we want to delete then tail should go into p previous <sil=0.968> .PERIOD Now <sil=0.639> ,COMMA this guy next will now point to null because we are going to delete this node and finally <sil=0.643> ,COMMA we will free p <sil=0.959> .PERIOD So <sil=0.598> ,COMMA L tail will go to p previous L tail next will be null and then finally <sil=0.340> ,COMMA you will free p <sil=0.980> .PERIOD So <sil=0.384> ,COMMA we have seen two easy cases one is delete the head and the other is delete the tail and now we will see the difficult case where p is an intermediate node <sil=0.967> .PERIOD So <sil=0.563> ,COMMA in this case what we will do <sil=0.890> .PERIOD So <sil=0.486> ,COMMA we will we have to remove this node <sil=0.969> .PERIOD So <sil=0.353> ,COMMA p is the previous next node should be the next node of p previous <sil=0.944> .PERIOD So <sil=0.448> ,COMMA this link should point to the node after p <sil=0.948> .PERIOD So <sil=0.310> ,COMMA that is the first thing <sil=0.988> .PERIOD So <sil=0.363> ,COMMA we will make this node point to the node after p and this node previous should point to the node before p <sil=0.942> .PERIOD So <sil=0.514> ,COMMA we will reset the links <sil=0.975> .PERIOD Now <sil=0.580> ,COMMA if you look at the link this guy is next is the one after p this guy is previous is the one before p <sil=0.969> .PERIOD So <sil=0.338> ,COMMA now p can be safely removed <sil=0.904> .PERIOD So <sil=0.393> ,COMMA this is how you would delete a node in the intermediate list <sil=0.992> .PERIOD So <sil=0.331> ,COMMA if there is a next node then p next previous will be p previous that is this backward link and if there is a previous node then p previous next will be p next that is this forward node <sil=0.953> .PERIOD And finally <sil=0.544> ,COMMA after that you will free p <sil=0.934> .PERIOD So <sil=0.384> ,COMMA this is how you would delete a node from a link list from a doubly link list and other operations can be done in a similar manner and some of these operations will be asked in the exercise problem that you will be assigned <sil=0.915> .PERIOD Similarly <sil=0.302> ,COMMA you can think of an extract node the code will be exactly identical to before except at the end you will instead of freeing p you will return p you do not free the p node you will just return the p node <sil=0.961> .PERIOD Now <sil=0.594> ,COMMA let us look at one more example how do you attend append one node to the end of a list <sil=0.939> .PERIOD So <sil=0.597> ,COMMA first we will check that the node is pointing to a non-none node if it is pointing to a non-none there is nothing to be done <sil=0.941> .PERIOD So <sil=0.390> ,COMMA there is nothing to be appended so you return <sil=0.957> .PERIOD Now <sil=0.607> ,COMMA if the if the reason list then what you do is if there is no need list what you do is you make a list with only one node which is p <sil=0.989> .PERIOD Now <sil=0.471> ,COMMA if the reason you can in order to append a node at the end what you could do is call insert after node L L last p <sil=0.963> .PERIOD So <sil=0.338> ,COMMA append will be the same as insert the node p at the end of the list <sil=0.953> .PERIOD So <sil=0.443> ,COMMA you will say insert after L last what is the node to be inserted p <sil=0.909> .PERIOD So <sil=0.380> ,COMMA if you have an insert after node or an insert before node you can do this to implement other functions <sil=0.960> .PERIOD So <sil=0.547> ,COMMA this is a brief introduction to W linked list which are similar to sinkley linked list but facilitate forward as well as backward traveling from a current node using that you can implement more functions easier than a sinkley linked list <sil=0.957> .PERIOD At the same time it has all the advantages of a sinkley linked list in the sense that if you want to insert a node it can be done using a constant number of operations if you want to delete a node it can be done in a constant number of operations <sil=0.954> .PERIOD So <sil=0.595> ,COMMA those advantages are similar to a sinkley linked list <sil=0.917> .PERIOD At the same time the disadvantages are also similar to a sinkley linked list in the sense that if you want to search through even a sorted W linked list you have to search through all the elements <sil=0.929> .PERIOD So <sil=0.461> ,COMMA in this video we will talk about how pre increment <sil=0.554> ,COMMA post increment and operators like that work in C <sil=0.932> .PERIOD So <sil=0.312> ,COMMA we will first introduce the notion of side effects <sil=0.936> .PERIOD Now <sil=0.402> ,COMMA we have earlier seen that any expression in C yields a certain value <sil=0.913> .PERIOD So <sil=0.564> ,COMMA let us look at a particular example <sil=0.558> ,COMMA if you have integer variables i and j i is assigned to 1 and then you say that j is assigned to i plus 1 <sil=0.970> .PERIOD What happens is that you take the value of i add 1 to it and then resulting value is the result of the expression i plus 1 <sil=0.918> .PERIOD So <sil=0.518> ,COMMA the result of the expression will be 2 which is assigned to j <sil=0.933> .PERIOD The value of i itself is unchanged due to an expression like i plus 1 <sil=0.932> .PERIOD It is just that you read the value of a <sil=0.303> ,COMMA use it and then return the value of i plus 1 <sil=0.904> .PERIOD Now <sil=0.491> ,COMMA some expressions in C also change the variables involved in them <sil=0.928> .PERIOD For example <sil=0.341> ,COMMA if you have a code like int i <sil=0.564> ,COMMA let us say i is initialized to 1 in j and then you say j equal to plus plus i <sil=0.995> .PERIOD In this case <sil=0.348> ,COMMA what happens is that you take the value of i <sil=0.578> ,COMMA increment it <sil=0.947> .PERIOD So <sil=0.489> ,COMMA you will get i equal to 2 and then that incremented value is then assigned to j <sil=0.924> .PERIOD So <sil=0.592> ,COMMA evaluating the expression plus plus i has the side effect that i becomes 2 <sil=0.947> .PERIOD So <sil=0.628> ,COMMA it not only takes the value of i increments it by 1 and gives it to j <sil=0.937> .PERIOD It also has the additional effect that i's value is incremented <sil=0.944> .PERIOD So <sil=0.462> ,COMMA contrast the first example and the second example <sil=0.926> .PERIOD In the first example <sil=0.574> ,COMMA when you said i plus 1 <sil=0.636> ,COMMA the value of i was unchanged and in the second when you said plus plus i <sil=0.495> ,COMMA the value of i is changed <sil=0.994> .PERIOD So <sil=0.365> ,COMMA this is known as a side effect because in addition to returning the value <sil=0.603> ,COMMA it also changes the variable involved in plus plus i <sil=0.947> .PERIOD So <sil=0.324> ,COMMA now <sil=0.390> ,COMMA let us look at this operation in slightly more detail <sil=0.932> .PERIOD So <sil=0.301> ,COMMA when you say in i equal to 1 in j and then j equal to plus plus i <sil=0.556> ,COMMA the effect of this plus plus i can be understood in terms of an equivalent code <sil=1.000> .PERIOD So <sil=0.486> ,COMMA what you do is consider a code where you have i equal to i plus 1 and then assign j equal to i <sil=0.993> .PERIOD So <sil=0.389> ,COMMA in this case i will become 2 after i equal to i plus 1 and then j will be assigned the value 2 <sil=0.936> .PERIOD So <sil=0.388> ,COMMA this is the effect of the pre-increment operation <sil=0.918> .PERIOD So <sil=0.595> ,COMMA pre-increment operation is calls <sil=0.991> .PERIOD So <sil=0.366> ,COMMA because before you use the value of i <sil=0.607> ,COMMA you would increment the value of i <sil=0.924> .PERIOD So <sil=0.308> ,COMMA that is one way of understanding this and these two codes are equivalent in effect <sil=0.927> .PERIOD There is a slightly different way of writing this <sil=0.425> ,COMMA which is a short form for writing i equal to i plus 1 <sil=0.929> .PERIOD So <sil=0.368> ,COMMA instead of doing this <sil=0.639> ,COMMA you can say i plus equal to 1 <sil=0.956> .PERIOD So <sil=0.558> ,COMMA plus equal to 1 says that says the effect i equal to i plus 1 <sil=0.919> .PERIOD So <sil=0.377> ,COMMA it is a short form of writing it <sil=0.910> .PERIOD So <sil=0.304> ,COMMA all these codes are have equivalent effect <sil=0.982> .PERIOD So <sil=0.630> ,COMMA it is called plus plus i is called a pre-increment operator because before you use the value of i <sil=0.441> ,COMMA its value is incremented <sil=0.913> .PERIOD Now <sil=0.586> ,COMMA there is also the post increment operator <sil=0.964> .PERIOD So <sil=0.431> ,COMMA plus plus i is an example of an expression with the pre-increment operation and you can also use i plus plus <sil=0.473> ,COMMA which is known as the post increment operation <sil=0.936> .PERIOD And the confusing thing is how do we interpret fairly complicated expressions like the following <sil=0.998> .PERIOD So <sil=0.319> ,COMMA suppose you have int i equal to 1 in j and then j equal to i plus plus plus plus plus i <sil=0.954> .PERIOD So <sil=0.567> ,COMMA what should we expect in this case <sil=0.925> ?QUESTIONMARK Is this allowed behavior <sil=0.995> ?QUESTIONMARK What does it mean <sil=0.932> ?QUESTIONMARK What will be the result <sil=0.545> ,COMMA which is stored in j <sil=0.951> ?QUESTIONMARK So <sil=0.397> ,COMMA let us look at these things in slightly greater detail <sil=0.964> .PERIOD So <sil=0.594> ,COMMA first let us look at some simple examples and try to understand the behavior <sil=0.924> .PERIOD So <sil=0.472> ,COMMA suppose you have i equal to 1 and then 2 variables j and k <sil=0.906> .PERIOD And first you say int j equal to i plus plus <sil=0.946> .PERIOD So <sil=0.546> ,COMMA this is the post increment operator <sil=0.944> .PERIOD So <sil=0.457> ,COMMA what happens here is that you take the value of i <sil=0.316> ,COMMA assign it to j <sil=0.940> .PERIOD So <sil=0.411> ,COMMA that is i equal to 1 <sil=0.368> .PERIOD The current value of i will be assigned to j and after the expression is over <sil=0.566> ,COMMA i will be incremented <sil=0.922> .PERIOD So <sil=0.413> ,COMMA then i will become 2 <sil=0.351> .PERIOD The old value of i is assigned to j and then the value of i will be incremented <sil=0.993> .PERIOD So <sil=0.307> ,COMMA it is the post increment operator <sil=0.909> .PERIOD So <sil=0.324> ,COMMA when you print if i and j here i will be 2 and j will be 1 <sil=0.490> ,COMMA because the old value of j <sil=0.348> ,COMMA old value of i was what was stored in j <sil=0.935> .PERIOD Now <sil=0.390> ,COMMA let us look at plus plus i <sil=0.925> .PERIOD So <sil=0.335> ,COMMA if you say k equal to plus plus i <sil=0.339> ,COMMA i is now 2 when it starts and you pre increment i <sil=0.919> .PERIOD So <sil=0.534> ,COMMA you increment i <sil=0.467> ,COMMA i becomes 3 and that value is stored in k <sil=0.973> .PERIOD So <sil=0.399> ,COMMA it is the pre increment operator <sil=0.982> .PERIOD So <sil=0.423> ,COMMA the value will be incremented before the assignment will take place <sil=0.987> .PERIOD So <sil=0.468> ,COMMA when you print i and k <sil=0.648> ,COMMA i will be 3 and k will also be 3 <sil=0.903> .PERIOD So <sil=0.332> ,COMMA notice the difference between the first case and the second case <sil=0.606> ,COMMA the pre increment versus the posting increment <sil=0.915> .PERIOD Now <sil=0.586> ,COMMA let us look at slightly more complicated examples <sil=0.910> .PERIOD So <sil=0.585> ,COMMA at this point what do we have <sil=0.970> ?QUESTIONMARK We have i equal to 3 and j equal to 1 at this point and then you say k equal to plus plus i plus j plus plus <sil=0.984> .PERIOD So <sil=0.489> ,COMMA this is the take a minute and think about what will happen here <sil=0.952> .PERIOD You pre increment i <sil=0.955> .PERIOD So <sil=0.624> ,COMMA the value of this expression that is used to add will be 4 <sil=0.598> ,COMMA because the value of i will be incremented before it is used in the plus expression <sil=0.957> .PERIOD Whereas <sil=0.322> ,COMMA this is the post increment expression <sil=0.951> .PERIOD So <sil=0.573> ,COMMA the value of j <sil=0.385> ,COMMA the old value of j will be used and then j will be incremented <sil=0.966> .PERIOD So <sil=0.517> ,COMMA here the value that will be used will be 4 and here the value that will be used will be the old value of j <sil=0.607> ,COMMA which is 1 <sil=0.921> .PERIOD So <sil=0.513> ,COMMA k will be 4 plus 1 <sil=0.497> ,COMMA which is 5 <sil=0.964> .PERIOD I will be incremented so i becomes 4 and after this expression is over <sil=0.599> ,COMMA j will be incremented <sil=0.916> .PERIOD So <sil=0.628> ,COMMA j becomes 2 <sil=0.913> .PERIOD So <sil=0.342> ,COMMA when you print this <sil=0.488> ,COMMA you will say that i is 4 <sil=0.434> ,COMMA j is 2 and k is 5 <sil=0.904> .PERIOD So <sil=0.642> ,COMMA understand y k is 5 <sil=0.643> ,COMMA because it is 4 plus 1 rather than 4 plus 2 <sil=0.950> .PERIOD So <sil=0.572> ,COMMA this is fairly simple can be understood in terms of the pre increment and the post increment operator <sil=0.992> .PERIOD So <sil=0.606> ,COMMA let us look at some code that is equivalent to the post increment operation <sil=0.945> .PERIOD So <sil=0.515> ,COMMA suppose you have j equal to i plus plus <sil=0.368> ,COMMA you can think of it like the following <sil=0.908> .PERIOD You can say that j is assigned to i <sil=0.906> .PERIOD So <sil=0.616> ,COMMA the old value of i is assigned to j and then the value of i is incremented <sil=0.494> ,COMMA i equal to i plus 1 <sil=0.902> .PERIOD If you want to use the assignment compound assignment operation <sil=0.319> ,COMMA then what you can do is j equal to i and i equal to i plus 1 <sil=0.980> .PERIOD So <sil=0.518> ,COMMA this is equal into i plus equal to 1 is equal into i equal to i plus 1 <sil=0.986> .PERIOD So <sil=0.550> ,COMMA contrast with the pre increment operation <sil=0.455> ,COMMA there i equal to i plus 1 will be done before j equal to i <sil=0.971> .PERIOD Here j equal to i will be done before i equal to i plus 1 <sil=0.910> .PERIOD So <sil=0.372> ,COMMA can we see that this is exactly how post increment works and the answer is yes <sil=0.451> ,COMMA in this particular case this is exactly how it works <sil=0.924> .PERIOD But <sil=0.359> ,COMMA if you want to understand the general case <sil=0.493> ,COMMA we have to understand a slightly more advanced concept in C and note that this is not something that strictly falls into an introductory course <sil=0.984> .PERIOD But <sil=0.431> ,COMMA in case you want to understand exactly how it works <sil=0.422> ,COMMA then we will look at the general case <sil=0.951> .PERIOD So <sil=0.600> ,COMMA to understand the general case <sil=0.360> ,COMMA instead of writing a few examples and compiling it and seeing <sil=0.605> ,COMMA one way to do it would be to go to the C standard and say <sil=0.312> ,COMMA what is the standard C <sil=0.977> ?QUESTIONMARK And here it is slightly surprising <sil=0.965> .PERIOD So <sil=0.555> ,COMMA the result of the post fixed operator is the value of the operand <sil=0.956> .PERIOD So <sil=0.375> ,COMMA this is the old value of the operand will be written <sil=0.995> .PERIOD After the result is obtained <sil=0.316> ,COMMA the value of the operand is incremented <sil=0.947> .PERIOD This is what we saw in the last slide <sil=0.917> .PERIOD Now <sil=0.588> ,COMMA when is the operand incremented <sil=0.926> ?QUESTIONMARK We loosely said last time that after the expression is over <sil=0.331> ,COMMA then the value of i will be incremented <sil=0.900> .PERIOD But <sil=0.331> ,COMMA what is the precise point at which the value of i will be incremented <sil=0.921> ?QUESTIONMARK This is slightly surprising <sil=0.943> .PERIOD So <sil=0.517> ,COMMA the side effect of updating the stored value of the operand shall occur between the previous and the next sequence point <sil=0.977> .PERIOD So <sil=0.530> ,COMMA when you have an i plus plus operation <sil=0.602> ,COMMA it will not be immediately updated <sil=0.948> .PERIOD It will be updated only after a place known as the sequence point <sil=0.981> .PERIOD So <sil=0.397> ,COMMA let us just understand briefly what is meant by a sequence point <sil=0.995> .PERIOD So <sil=0.308> ,COMMA before we get into it <sil=0.436> ,COMMA let me emphasize <sil=0.936> .PERIOD We are trying to understand <sil=0.969> .PERIOD So <sil=0.463> ,COMMA the post increment operation will say that the old value of i will be used and the value of i will be incremented after the expression <sil=0.958> .PERIOD We are trying to precisely understand after what point can be say that i's value will have been incremented <sil=0.978> .PERIOD So <sil=0.597> ,COMMA a sequence point as defined in the standard is a point in the code by which all pending side effects are assured to be over <sil=0.949> .PERIOD So <sil=0.609> ,COMMA this is a very technical definition and it is to be understood by compiler writers <sil=0.908> .PERIOD But <sil=0.417> ,COMMA we will briefly understand what does it mean <sil=0.873> ?QUESTIONMARK So <sil=0.350> ,COMMA some prominent sequence points include end of a full declarator <sil=0.908> .PERIOD So <sil=0.506> ,COMMA for example <sil=0.464> ,COMMA if I have a declaration in i equal to 0 comma j equal to 0 <sil=0.594> ,COMMA then a full declarator gets over after i equal to 0 <sil=0.936> .PERIOD So <sil=0.311> ,COMMA after i equal to 0 <sil=0.489> ,COMMA there is a sequence point here <sil=0.933> .PERIOD So <sil=0.414> ,COMMA if there are any pending side effects <sil=0.565> ,COMMA then it will be incremented at this point <sil=0.978> .PERIOD This is another full declarator <sil=0.945> .PERIOD So <sil=0.462> ,COMMA it will after that again any pending side effects will be assured to be done <sil=1.000> .PERIOD Then the surprising thing is suppose you have full expressions <sil=0.986> .PERIOD So <sil=0.448> ,COMMA suppose you have like i plus plus plus 3 <sil=0.903> .PERIOD So <sil=0.524> ,COMMA the major thing to understand will be when is this i plus plus suppose to happen <sil=0.917> ?QUESTIONMARK Will it happen immediately after i plus plus and the thing is that the c standard does not say that that has to happen <sil=0.950> .PERIOD The c standard says that the next sequence point is the semicolon <sil=0.997> .PERIOD So <sil=0.477> ,COMMA when you see the semicolon operation <sil=0.318> ,COMMA you will know that this whole thing is what is known as a full expression j equal to i plus plus plus 3 <sil=0.914> .PERIOD So <sil=0.537> ,COMMA that is known as a full expression <sil=0.908> .PERIOD So <sil=0.614> ,COMMA after you encounter a full expression <sil=0.559> ,COMMA any pending side effects <sil=0.982> .PERIOD So <sil=0.351> ,COMMA this is a pending side effect that will be updated <sil=0.908> .PERIOD So <sil=0.545> ,COMMA only at that point c standard says that <sil=0.487> ,COMMA now by now you should have updated the i plus plus operation <sil=0.972> .PERIOD Before that the compiler is free to do what it wants <sil=0.935> ?QUESTIONMARK It may or may not update it <sil=0.978> .PERIOD So <sil=0.365> ,COMMA this is actually slightly confusing and contrary to the popular understanding of when should i plus plus happen <sil=0.908> .PERIOD So <sil=0.429> ,COMMA again the general case is slightly confusing <sil=0.938> .PERIOD It is not what you would expect <sil=0.923> .PERIOD It just says that by the next sequence point in the code <sil=0.615> ,COMMA all pending side effects should be taking place <sil=0.903> .PERIOD Now <sil=0.555> ,COMMA it does not say that exactly at the end of the sequence point <sil=0.513> ,COMMA you will update all side effects <sil=0.990> .PERIOD Compilers are free to do what it wants <sil=0.923> .PERIOD All it says is that by the time you meet the next sequence point <sil=0.300> ,COMMA pending side effects should take place in whatever order <sil=0.911> .PERIOD So <sil=0.496> ,COMMA this is slightly technical <sil=0.943> .PERIOD Now <sil=0.341> ,COMMA for a full stand list <sil=0.474> ,COMMA of course <sil=0.329> ,COMMA you have to refer to the c standard <sil=0.522> ,COMMA which is not really recommended <sil=0.941> .PERIOD But <sil=0.386> ,COMMA it is just that if you want to understand it <sil=0.507> ,COMMA then you can look at the standard <sil=0.977> .PERIOD So <sil=0.399> ,COMMA let us try to understand the post increment operation <sil=0.988> .PERIOD So <sil=0.319> ,COMMA it is again slightly greater detail <sil=0.937> .PERIOD So <sil=0.366> ,COMMA if you say that k equal to i plus plus plus j plus plus <sil=0.939> .PERIOD Now <sil=0.613> ,COMMA there are two ways to do it <sil=0.955> .PERIOD Of course <sil=0.381> ,COMMA k equal to i plus j <sil=0.502> ,COMMA the old values of i and j are increment are used and then you calculate k <sil=0.336> ,COMMA assign it to k <sil=0.927> .PERIOD And then you can do i equal to i plus 1 <sil=0.481> ,COMMA j equal to j plus 1 <sil=0.944> .PERIOD Because <sil=0.403> ,COMMA the standard says that by the time you see the full expression <sil=0.304> ,COMMA pending updates must be happening <sil=0.940> .PERIOD So <sil=0.425> ,COMMA you can say that by the time you see the semicolon operation <sil=0.511> ,COMMA I will do i equal to i plus 1 and j equal to j plus 1 <sil=0.985> .PERIOD Now <sil=0.526> ,COMMA if you think a minute <sil=0.452> ,COMMA you could also do update j first and then i <sil=0.990> .PERIOD So <sil=0.616> ,COMMA I know that by the time you see the semicolon <sil=0.410> ,COMMA pending update should happen <sil=0.961> .PERIOD But <sil=0.419> ,COMMA in what order should it happen <sil=0.882> ?QUESTIONMARK Is it i equal to i plus 1 first and j equal to j plus 1 next or is it the other way round <sil=0.864> ?QUESTIONMARK And the answer is that the c standard does not say <sil=0.990> .PERIOD So <sil=0.521> ,COMMA it leaves it deliberately unspecified <sil=0.969> .PERIOD So <sil=0.523> ,COMMA that the compiler can do what it wants <sil=0.932> .PERIOD So <sil=0.597> ,COMMA here is the second subtlety in this whole business <sil=0.979> .PERIOD So <sil=0.487> ,COMMA if you say what is the order of side effects <sil=0.856> ?QUESTIONMARK There are certain operations where the sequence is specified <sil=0.950> .PERIOD For example <sil=0.431> ,COMMA the function called the and the logical and operator <sil=0.579> ,COMMA the logical or operator <sil=0.330> ,COMMA the conditional operator and the comma operator <sil=0.986> .PERIOD So <sil=0.452> ,COMMA for very specific operators <sil=0.317> ,COMMA the sequence is specified <sil=0.970> .PERIOD But <sil=0.507> ,COMMA in all other operations <sil=0.463> ,COMMA the order of evaluation of sub expressions is unspecified <sil=0.945> .PERIOD And similarly <sil=0.591> ,COMMA the order of side effects is also unspecified <sil=0.916> .PERIOD So <sil=0.637> ,COMMA in the previous slide <sil=0.360> ,COMMA doing i equal to i plus 1 before j equal to j plus 1 is valid as also j equal to j plus 1 and i equal to i plus 1 <sil=0.988> .PERIOD So <sil=0.348> ,COMMA these both these orders are valid and the c standard does not say that what should really happen <sil=0.978> .PERIOD So <sil=0.307> ,COMMA what in practice you will notice is that in one compiler <sil=0.593> ,COMMA a certain order may happen in another compiler <sil=0.553> ,COMMA certain other order may happen <sil=0.989> .PERIOD So <sil=0.457> ,COMMA it is left to the compiler and you cannot assume anything about what really happens <sil=0.534> ,COMMA which order it happens <sil=0.989> .PERIOD Further and here is the most important thing as far as the sequence points are concerned <sil=0.984> .PERIOD The c standard says that an object or a variable can have its stored value modified at most once by the evaluation of an expression between two sequence points <sil=0.933> .PERIOD This is very important <sil=0.921> .PERIOD So <sil=0.451> ,COMMA between two sequence points <sil=0.591> ,COMMA if a variable is to be updated by a side effect <sil=0.571> ,COMMA then there should it should be updated at most once beyond that if it is updated multiple times <sil=0.581> ,COMMA the c standard says that the result is actually unspecified <sil=0.941> .PERIOD So <sil=0.342> ,COMMA let us look at a few specific examples to see what is actually happening here <sil=0.904> .PERIOD So <sil=0.391> ,COMMA let us take the first expression j equal to i plus plus plus i plus plus <sil=0.904> .PERIOD So <sil=0.513> ,COMMA we know that here is a sequence point and we know that here is a sequence point <sil=0.952> .PERIOD These are full expressions <sil=0.938> .PERIOD Between these two sequence points <sil=0.447> ,COMMA the value of i is updated more than once <sil=0.927> .PERIOD Here is i plus plus i plus i plus plus <sil=0.968> .PERIOD And the c standard says that the behavior is unspecified <sil=0.969> .PERIOD This is somewhat surprising because you may try it out multiple times and you will see that consistently some behavior is happening <sil=0.931> .PERIOD But what the c standard says is that if you take the code and compile it with a different compiler <sil=0.354> ,COMMA the result may be different <sil=0.971> .PERIOD So <sil=0.345> ,COMMA the result of this expression is actually unspecified <sil=0.986> .PERIOD Similarly <sil=0.393> ,COMMA let us look at the next example <sil=0.965> .PERIOD So <sil=0.314> ,COMMA here the sequence point is a full expression <sil=0.937> .PERIOD Let us look at the next expression <sil=0.992> .PERIOD So <sil=0.394> ,COMMA i plus plus plus i plus plus i <sil=0.989> .PERIOD So <sil=0.343> ,COMMA post increment and then pre increment <sil=0.950> .PERIOD Again <sil=0.627> ,COMMA even in this case <sil=0.410> ,COMMA the result is unspecified because these two are the sequence points here <sil=0.931> .PERIOD Between this full expression and between these full expression <sil=0.925> .PERIOD So <sil=0.483> ,COMMA you have two sequence points and between these two sequence points <sil=0.629> ,COMMA the value of i is updated more than once <sil=0.964> .PERIOD So <sil=0.583> ,COMMA the result is unspecified according to the c standard <sil=0.968> .PERIOD Let us look at this interesting example j equal to j plus plus <sil=0.937> .PERIOD Again <sil=0.604> ,COMMA result is unspecified because you can have these two sequence points and between these <sil=0.481> ,COMMA the value of j is updated twice <sil=0.985> .PERIOD First <sil=0.467> ,COMMA by the post increment operator and then by the assignment operator <sil=0.913> .PERIOD So <sil=0.579> ,COMMA the value of j is updated more than once <sil=0.929> .PERIOD The result is unspecified <sil=0.947> .PERIOD The last expression is interesting <sil=0.944> .PERIOD So <sil=0.460> ,COMMA if you look at the two sequence points here <sil=0.420> ,COMMA you have one full expression here and the full expression here <sil=0.909> .PERIOD Between these <sil=0.521> ,COMMA the value of i is updated only once here and the value of j is updated only once here <sil=0.939> .PERIOD So <sil=0.439> ,COMMA it is not that the value of i is updated more than once or the value of j is updated more than once <sil=0.987> .PERIOD But here <sil=0.634> ,COMMA it is a which of these sub expressions happen first <sil=0.996> ?QUESTIONMARK Is it i plus plus that happens first or i plus 1 that happens first <sil=0.962> ?QUESTIONMARK So <sil=0.471> ,COMMA according to the c standard that is actually unspecified <sil=0.952> .PERIOD So <sil=0.460> ,COMMA the order of evaluation of the sub expressions is unspecified according to the c standard <sil=0.971> .PERIOD So <sil=0.475> ,COMMA let us just go back to that and this is what it says <sil=0.980> .PERIOD The order of evaluation of sub expressions is also unspecified <sil=0.959> .PERIOD So <sil=0.505> ,COMMA if you look at this expression j equal to i plus plus plus i plus 1 <sil=0.368> ,COMMA it is not clear which happens first <sil=0.996> ?QUESTIONMARK i plus plus or is it i plus 1 <sil=0.854> ?QUESTIONMARK That is also unspecified <sil=0.989> .PERIOD So <sil=0.507> ,COMMA here are the sequence points which ended full expression and the specific case of the last example <sil=0.908> .PERIOD It is not that values of variables are updated more than once <sil=0.997> .PERIOD It is just that the sub expressions may be evaluated in whatever order it may happen <sil=0.916> .PERIOD So <sil=0.412> ,COMMA all this is slightly confusing <sil=1.000> .PERIOD So <sil=0.545> ,COMMA let us just summarize something that you can take away for as far as programming is concerned <sil=0.948> .PERIOD So <sil=0.547> ,COMMA let us list out a few operations operators with side effects <sil=0.938> .PERIOD So <sil=0.387> ,COMMA let us say pre increment <sil=0.546> ,COMMA post increment <sil=0.593> ,COMMA pre decrement <sil=0.453> ,COMMA post decrement <sil=0.530> ,COMMA all of these have side effects <sil=0.944> .PERIOD In addition to returning a value <sil=0.451> ,COMMA it also updates the variable <sil=0.966> .PERIOD The assignment operator clearly has side effects <sil=0.997> .PERIOD So <sil=0.399> ,COMMA if you say j equal to i <sil=0.416> ,COMMA obviously the value of i will be assigned to j and we have earlier seen that as an operation <sil=0.342> ,COMMA it returns the value that was assigned <sil=0.917> .PERIOD So <sil=0.394> ,COMMA that has a side effect because it updates j and also returns a value which is the value of j <sil=0.968> .PERIOD We have also seen this compound assignments <sil=0.904> .PERIOD So <sil=0.530> ,COMMA you can say i plus equal to 1 which is the same as i equal to i plus 1 and j minus equal to 2 which is the same as j equal to j minus 2 <sil=0.924> .PERIOD So <sil=0.645> ,COMMA all these operators have side effects <sil=0.991> .PERIOD And the general advice is that use operators with side effects with extreme caution <sil=0.916> .PERIOD In general <sil=0.503> ,COMMA if you use them <sil=0.423> ,COMMA make sure that a single full expression does not contain more than one sub expression with side effects <sil=0.931> .PERIOD So <sil=0.472> ,COMMA make sure that even if you want to use these expressions with side effects <sil=0.568> ,COMMA make sure that one full expression contains at most one side effect <sil=0.905> .PERIOD So <sil=0.463> ,COMMA avoid expressions like i equal to i plus plus as we have seen before <sil=0.354> ,COMMA this has two updates on i <sil=0.927> .PERIOD So <sil=0.562> ,COMMA the result is unspecified <sil=0.927> .PERIOD i equal to j equal to 1 <sil=0.424> ,COMMA well here is a full expression that has two side effects <sil=0.998> .PERIOD Technically <sil=0.341> ,COMMA the result is you can predict what the result is <sil=0.528> ,COMMA but as a programming practice <sil=0.529> ,COMMA please avoid these kind of expressions because this is an expression that involves multiple updates and it is not really that the result is unspecified because the updates are on different variables <sil=0.511> ,COMMA but still as a good coding practice avoid such expressions <sil=0.909> .PERIOD So <sil=0.553> ,COMMA let us look at the third example <sil=0.986> .PERIOD You have x equal to y equal to 12 divided by y equal to 4 <sil=0.989> .PERIOD Again <sil=0.605> ,COMMA it is not clear which of the sub expressions y equal to 12 or y equal to 4 <sil=0.454> ,COMMA which will happen first <sil=0.941> .PERIOD So <sil=0.386> ,COMMA the result of this expression is very difficult to interpret <sil=1.000> .PERIOD So <sil=0.577> ,COMMA in general <sil=0.488> ,COMMA do not use full expressions that have more than one side effects <sil=0.498> ,COMMA even if they are on the single variable <sil=0.970> .PERIOD If it is multiple updates on a single variable <sil=0.420> ,COMMA then the c standard clearly says that the result is unspecified <sil=0.475> ,COMMA but even if they are on multiple variables <sil=0.581> ,COMMA try to avoid writing such expressions <sil=0.974> .PERIOD You can write always write slightly longer code <sil=0.451> ,COMMA where the meaning of the code will be perfectly clear and the result will be completely specified <sil=0.977> .PERIOD Thank you <sil=0.940> .PERIOD In this lecture <sil=0.461> ,COMMA we will see some practices for lighting larger programs using C <sil=0.949> .PERIOD As far as we have seen so far <sil=0.310> ,COMMA we always wrote our code in a single file and this is not practical for very large programs running into say thousands of lines or millions of lines <sil=0.920> .PERIOD So <sil=0.537> ,COMMA we will see what is the usual practice for organizing your code when we have larger programs <sil=0.947> .PERIOD So <sil=0.399> ,COMMA one of the basic principles is to separate the function prototype declarations from the function definitions <sil=0.977> .PERIOD We have seen that when we have a function <sil=0.399> ,COMMA we have two things to do <sil=0.980> .PERIOD One is to declare a function which is just the types involved in the function and then the definition of the function which is actually the code of the function <sil=0.956> .PERIOD So <sil=0.622> ,COMMA one way to structure it <sil=0.629> ,COMMA one principle in structuring is that we will separate out the function prototype from the function definition <sil=0.910> .PERIOD Now <sil=0.369> ,COMMA place all prototype definitions <sil=0.635> ,COMMA structure definitions <sil=0.324> ,COMMA type <sil=0.409> ,COMMA depth <sil=0.930> .PERIOD So <sil=0.355> ,COMMA just the declarations <sil=0.389> ,COMMA you will place it in a file with suffix dot h <sil=0.955> .PERIOD So <sil=0.332> ,COMMA right now we have been coding in a file called dot c <sil=0.913> .PERIOD So <sil=0.473> ,COMMA right now what we are proposing is that the declarations alone will place it in a separate file with suffix dot h <sil=0.976> .PERIOD You have already seen such an example which is a studio dot h <sil=0.507> ,COMMA we never bothered about what is inside a studio dot h <sil=0.927> .PERIOD Now <sil=0.460> ,COMMA we are talking about how to write these header files <sil=0.968> .PERIOD Now <sil=0.527> ,COMMA declarations are only half the function <sil=0.457> ,COMMA I mean we have to write the definition of the function <sil=0.550> ,COMMA the code of the function <sil=0.451> ,COMMA the actual code of the function <sil=0.456> ,COMMA you place it in a dot c file separately <sil=0.925> .PERIOD So <sil=0.303> ,COMMA for example <sil=0.556> ,COMMA list dot h contains the definitions of the struct d l n load for doubly linked list and so on and list dot c would contain the bodies of the functions <sil=0.991> .PERIOD Now <sil=0.405> ,COMMA we will see why separate dot h and dot c <sil=0.994> .PERIOD Programs that use the doubly linked list need to know only the declarations actually <sil=0.427> ,COMMA where these are know <sil=0.630> ,COMMA think of these programs as the consumers of this code <sil=0.957> .PERIOD Now <sil=0.598> ,COMMA it does not need to know how the code is implemented <sil=0.488> ,COMMA just what to call and what is the declaration of the function <sil=0.902> .PERIOD Now <sil=0.457> ,COMMA if you do this then list dot c can be compiled separately into object code <sil=0.922> .PERIOD So <sil=0.373> ,COMMA we can say gcc minus c list dot c <sil=0.560> ,COMMA this will produce just file called list dot o <sil=0.343> ,COMMA list dot o is not executable <sil=0.528> ,COMMA but it can be used in other programs to create executables <sil=0.982> .PERIOD So <sil=0.348> ,COMMA how can we do this <sil=0.903> ?QUESTIONMARK This is the procedure known as linking <sil=0.961> .PERIOD So <sil=0.554> ,COMMA we can link the list dot o <sil=0.901> .PERIOD So <sil=0.583> ,COMMA notice the difference here <sil=0.348> ,COMMA when we see gcc minus c list dot c <sil=0.446> ,COMMA what it would produce is a dot o function dot dot dot o file and this dot o file can be included to produce output <sil=0.938> .PERIOD So <sil=0.427> ,COMMA this says that we are combining probe dot c file with list dot o object file and the output will produce is called prompt <sil=0.980> .PERIOD So <sil=0.376> ,COMMA gcc minus o prompt means the output file will produce will be called prompt <sil=0.910> .PERIOD So <sil=0.500> ,COMMA if we omit minus o prompt and we simply say gcc <sil=0.570> ,COMMA prompt dot c list dot o <sil=0.498> ,COMMA then the file that will get is a dot out <sil=0.919> .PERIOD If we specify an output file <sil=0.359> ,COMMA we will get that out file name <sil=0.946> .PERIOD Now <sil=0.416> ,COMMA inside prompt dot c <sil=0.608> ,COMMA let us say that we need to use list functions <sil=0.915> .PERIOD So <sil=0.508> ,COMMA prompt dot c will include list dot h <sil=0.410> ,COMMA this is the important thing <sil=0.339> ,COMMA it will not say include list dot c <sil=0.435> ,COMMA it will just say include list dot h <sil=0.935> .PERIOD This is similar to what we have seen with stdio <sil=0.502> ,COMMA we did not bother about whether there was an stdio dot c file <sil=0.543> ,COMMA we said we will include stdio dot h <sil=0.952> .PERIOD Also <sil=0.533> ,COMMA notice the difference that we are using double codes instead of angular brackets <sil=0.938> .PERIOD So <sil=0.320> ,COMMA when we wrote stdio dot h <sil=0.586> ,COMMA what we had was when we wrote stdio dot h <sil=0.637> ,COMMA what we had was angular brackets <sil=0.384> ,COMMA open angular bracket and close angular bracket <sil=0.951> .PERIOD Here <sil=0.366> ,COMMA we have codes <sil=0.647> ,COMMA why is that <sil=0.870> ?QUESTIONMARK We will see this <sil=0.995> .PERIOD So <sil=0.569> ,COMMA what is the advantage of separating list dot c from prog dot c <sil=0.392> ,COMMA why break it up into multiple files <sil=0.966> ?QUESTIONMARK One advantage is that it is it saves repeated compilation of list dot c functions when compiling prog dot c <sil=0.947> .PERIOD So <sil=0.484> ,COMMA the double codes around list dot h specifies to the c pre-processor <sil=0.383> ,COMMA we will see this in a subsequent lecture that the current working directory will be search for list dot h file <sil=0.995> .PERIOD So <sil=0.392> ,COMMA since we are saying that include list dot h within double codes <sil=0.360> ,COMMA what it means is that where is list dot h found <sil=0.576> ,COMMA it will be found in the current directory <sil=0.959> .PERIOD If it is not found in the correct directory <sil=0.353> ,COMMA it will search for some standard library parts <sil=0.644> ,COMMA some standard header file parts <sil=0.980> .PERIOD So <sil=0.457> ,COMMA in the case of stdio dot h <sil=0.635> ,COMMA we put angular brackets around stdio dot h <sil=0.940> .PERIOD That means that stdio dot h will be found not in the current directory <sil=0.416> ,COMMA but in some standard library directory and standard header directories <sil=0.901> .PERIOD So <sil=0.633> ,COMMA when you use double codes <sil=0.495> ,COMMA you can also use some full path name <sil=0.933> .PERIOD Suppose your full path name in a Linux system is slash user slash btech 2115 slash 1t slash prog slash list dot h <sil=0.444> ,COMMA you can specify the whole path as well <sil=0.987> .PERIOD This is a more general notation <sil=0.927> .PERIOD So <sil=0.527> ,COMMA currently the structure is as follows <sil=0.631> ,COMMA you have a list dot h file <sil=0.374> ,COMMA it has just the prototype declarations <sil=0.982> .PERIOD List dot c will define those functions <sil=0.998> .PERIOD So <sil=0.416> ,COMMA first inside list dot c <sil=0.531> ,COMMA you would say include within codes list dot h and then have all the function definitions <sil=0.962> .PERIOD Prog dot c needs list dot c functions <sil=0.606> ,COMMA but instead of saying include list dot c <sil=0.484> ,COMMA it will say include list dot h within quotations <sil=0.954> .PERIOD Now <sil=0.635> ,COMMA we will see how to compile such a setup <sil=0.960> .PERIOD So <sil=0.559> ,COMMA what is the division of work <sil=0.993> ?QUESTIONMARK What is the separation between the dot c and the dot h files <sil=0.983> ?QUESTIONMARK Dot h file is the public interface that if anybody else any other program wants to use the list functions <sil=0.465> ,COMMA what you would do is include the list dot h functions <sil=0.504> ,COMMA include the list dot h file <sil=0.918> .PERIOD Now <sil=0.611> ,COMMA list dot c implements defines all the functions that list dot h has declared <sil=0.986> .PERIOD In addition <sil=0.522> ,COMMA it can also define other functions <sil=0.515> ,COMMA but these functions will not be available to other programs that are using the list dot h file <sil=0.997> .PERIOD So <sil=0.436> ,COMMA files using list dot h will not be able to use these extra functions or even know about these functions <sil=0.976> .PERIOD These are taught of as private functions <sil=0.968> .PERIOD So <sil=0.444> ,COMMA this can be used to implement certain details of your code that other users of this program need not know about <sil=0.947> .PERIOD So <sil=0.322> ,COMMA the general principle is what is known as information hiding or localization <sil=0.935> .PERIOD So <sil=0.495> ,COMMA the break your programs into modules <sil=0.339> ,COMMA we have already seen one way to break a program into modules <sil=0.614> ,COMMA which is by writing functions <sil=0.944> .PERIOD Now <sil=0.424> ,COMMA this is another way to this is another level of modularization <sil=0.535> ,COMMA where you say that take a collection of functions and put them in a file and have multiple files <sil=0.975> .PERIOD Now <sil=0.610> ,COMMA each module implementing some aspect <sil=0.440> ,COMMA for example <sil=0.541> ,COMMA a data structure like a linked list <sil=0.996> .PERIOD Now <sil=0.487> ,COMMA if a module B does not need to know the details of how another module A works <sil=0.301> ,COMMA then we do not need to tell B about how it is done <sil=0.559> ,COMMA but module B should use module is dot h file <sil=0.643> ,COMMA not the dot c file <sil=0.914> .PERIOD Now <sil=0.626> ,COMMA why do we separate definitions into dot h and dot c <sil=0.963> ?QUESTIONMARK There are some reasons <sil=0.596> ,COMMA programs that use the list functions <sil=0.560> ,COMMA for example <sil=0.495> ,COMMA are typically consumers and they do not need to know the exact details behind how these functions work <sil=0.928> .PERIOD And we have already done this in other <sil=0.633> ,COMMA we do not know about how scan of for print of work <sil=0.980> .PERIOD We just know that scan of needs these two arguments <sil=0.571> ,COMMA for example <sil=0.636> ,COMMA it needs a format string and it needs the variable to be printed <sil=0.954> .PERIOD The print of needs the format string and the variable to be printed <sil=0.923> .PERIOD Similarly <sil=0.373> ,COMMA scan of needs a format string and the variable to be assigned <sil=0.961> .PERIOD So <sil=0.425> ,COMMA we just knew that we do not know anything about how scan of for print of is actually defined or implemented <sil=0.985> .PERIOD We just know that it needs these arguments and therefore <sil=0.434> ,COMMA we can call them <sil=0.995> .PERIOD So <sil=0.321> ,COMMA this is the kind of separation of detail that we are hoping to achieve <sil=0.913> .PERIOD Now <sil=0.317> ,COMMA so if some program wants to use the list functions <sil=0.604> ,COMMA such programs can use the prototypes using the include command <sil=0.566> ,COMMA hash include within code list dot h <sil=0.939> .PERIOD So <sil=0.454> ,COMMA again to remind the double code specify that it is the current working directly that list dot h is present in you can also give full pass <sil=0.937> .PERIOD List dot c program will contain all the actual function definitions <sil=0.913> .PERIOD Now <sil=0.358> ,COMMA usually header files are much smaller than the c files <sil=0.945> .PERIOD If list dot h and list dot c are separated <sil=0.541> ,COMMA then list dot c can be compiled ahead of time and you can generate the object file <sil=0.992> .PERIOD Notice that list dot o in this case will be not executable <sil=0.936> .PERIOD It is just an object file that can be used to build executables <sil=0.939> .PERIOD Now <sil=0.396> ,COMMA list dot c program is complete except for main function <sil=0.940> .PERIOD So <sil=0.437> ,COMMA it has a lot of functions <sil=0.925> .PERIOD It defines all the functions that list dot h has declared plus optionally some more functions <sil=0.973> .PERIOD And it can be compiled to produce an object code <sil=0.593> ,COMMA but it cannot be done <sil=0.375> ,COMMA it cannot be compiled into an executable code because it does not have a main function <sil=0.979> .PERIOD Now <sil=0.389> ,COMMA suppose we have written a function called probe dot c that uses many of the list functions that uses list dot h <sil=0.937> .PERIOD We can compile probe dot c to generate an object code gcc when the c probe dot o probe dot c <sil=0.999> .PERIOD So <sil=0.448> ,COMMA now we have two object files list dot o and probe dot o <sil=0.983> .PERIOD And then we can use these two object files to create the executable file <sil=0.979> .PERIOD Let us look at a diagram which will hopefully be helpful <sil=0.946> .PERIOD So <sil=0.305> ,COMMA list dot h includes prototype declarations <sil=0.457> ,COMMA but not the function definitions <sil=0.921> .PERIOD List dot c defines these functions <sil=0.919> .PERIOD So <sil=0.638> ,COMMA in order to define these functions first it says include list dot h <sil=0.919> .PERIOD Therefore <sil=0.490> ,COMMA it will get all the declarations and then it has this code which implements the list function definitions <sil=0.900> .PERIOD Prog dot c is a consumer which needs these functions <sil=0.957> .PERIOD So <sil=0.517> ,COMMA how does it do it <sil=0.894> ?QUESTIONMARK It does not say list dot c <sil=0.310> ,COMMA it says include list dot h <sil=0.998> .PERIOD So <sil=0.394> ,COMMA the declarations of all the functions are available to probe dot c <sil=0.957> .PERIOD Now <sil=0.345> ,COMMA I separately compile list dot c into list dot o using gccc minus c and probe dot c into probe dot o using gccc minus c <sil=0.972> .PERIOD So <sil=0.351> ,COMMA now I have two object files list dot o and probe dot o <sil=0.944> .PERIOD And these will be combined using gccc minus o <sil=0.989> .PERIOD So <sil=0.500> ,COMMA this says that the output file will be called a dot out <sil=0.977> .PERIOD The compilation units that I need are probe dot o and list dot o <sil=0.975> .PERIOD And so <sil=0.383> ,COMMA use these two files in order to create the output file a dot out <sil=0.935> .PERIOD And what is the big advantage here <sil=0.907> ?QUESTIONMARK Let us consider a scene where the probe dot c file changes <sil=0.964> .PERIOD I need some changes to be made into probe dot c <sil=0.915> .PERIOD Maybe I add some more functions <sil=0.302> ,COMMA modify some functions and all <sil=0.995> .PERIOD So <sil=0.435> ,COMMA now I need to recompile and produce the output file <sil=0.994> .PERIOD I have changed probe dot c but not list dot c <sil=0.938> .PERIOD So <sil=0.600> ,COMMA let us say probe dot c has changed <sil=0.974> .PERIOD What should I do now <sil=0.894> ?QUESTIONMARK I should compile only the probe dot c <sil=0.901> .PERIOD I can say gccc minus c probe dot c <sil=0.918> .PERIOD Now <sil=0.427> ,COMMA I will produce a new probe dot o file <sil=0.968> .PERIOD Notice list dot c has not changed <sil=0.987> .PERIOD So <sil=0.469> ,COMMA we do not need to recompile list dot c <sil=0.997> .PERIOD So <sil=0.341> ,COMMA we can just say gccc minus c probe dot c list dot o is the same as before <sil=0.976> .PERIOD And then I can use the new probe dot o the old list dot o in order to produce the new a dot out <sil=0.979> .PERIOD So <sil=0.422> ,COMMA notice the a dot out depends on probe dot o and probe dot c has changed <sil=0.948> .PERIOD So <sil=0.428> ,COMMA only this path gets recompiled which is saving a lot of effort <sil=0.981> .PERIOD And in large programs <sil=0.513> ,COMMA then one particular file changes and you recompile the project only the necessary files get recompiled <sil=0.960> .PERIOD It does not recompile the whole project which will take a lot of time <sil=0.936> .PERIOD Instead it will compile only those files which are necessary <sil=0.963> .PERIOD So <sil=0.486> ,COMMA this is a huge advantage <sil=0.954> .PERIOD So <sil=0.349> ,COMMA this just repeats what was said in the last slide <sil=0.910> .PERIOD Now <sil=0.303> ,COMMA a couple of thoughts about writing data structure libraries <sil=0.908> .PERIOD There is no one design which is best for a data structure library <sil=0.902> .PERIOD Choose your structure function <sil=0.550> ,COMMA structure functions to be as complete as possible for your programs <sil=0.941> .PERIOD Now <sil=0.373> ,COMMA programs can be based only on the function prototype <sil=0.959> .PERIOD Suppose I write a program which needs a list function <sil=0.916> .PERIOD I can just look at the function prototypes in the dot edge file and then write by program <sil=0.930> .PERIOD Consumers do not need to know how the program is implemented <sil=0.956> .PERIOD Just what the functions are <sil=0.327> ,COMMA what are its arguments <sil=0.324> ,COMMA not the details about how it is implemented <sil=0.947> .PERIOD Now <sil=0.310> ,COMMA implementation of libraries should be very sound <sil=0.926> .PERIOD All boundary cases should be completely defined and the implementation should thoroughly match the specifications <sil=0.934> .PERIOD So <sil=0.426> ,COMMA libraries need to be tested and debug thoroughly before other users can use it <sil=0.973> .PERIOD Also <sil=0.350> ,COMMA one more thing <sil=0.435> ,COMMA allocation and release of storage <sil=0.986> .PERIOD If the library is allocating storage <sil=0.359> ,COMMA it is only sensible to provide routines in the library itself which can free those storage <sil=0.957> .PERIOD So <sil=0.436> ,COMMA it cannot be that libraries allocating a storage and the freeing of the storage has to be done outside the library <sil=0.912> .PERIOD That is not a sensible design <sil=0.937> .PERIOD So <sil=0.319> ,COMMA if the library itself is allocating storage <sil=0.332> ,COMMA you give library functions to free the storage as well <sil=0.911> .PERIOD For example <sil=0.366> ,COMMA in list dot edge <sil=0.458> ,COMMA memory allocation is done only in two places <sil=0.507> ,COMMA make empty list and make load <sil=0.941> .PERIOD So <sil=0.472> ,COMMA to deallocate that <sil=0.318> ,COMMA you should provide a free functions for these functions <sil=0.471> ,COMMA corresponding to these functions <sil=1.000> .PERIOD Thanks <sil=0.940> .PERIOD In this video <sil=0.453> ,COMMA we will see the size of operator <sil=0.594> ,COMMA which is a slightly advanced topic in relation to pointer arithmetic <sil=0.972> .PERIOD This is explaining how pointer arithmetic really works and it is also important to understand one topic that we will see later on called malloc <sil=0.984> .PERIOD So <sil=0.412> ,COMMA the size of operator and note that it is an operator and I have highlighted that in red <sil=0.932> .PERIOD It looks like a function call <sil=0.429> ,COMMA but it is not <sil=0.977> .PERIOD The operator gives the number of bytes that any value with the given type occupies <sil=0.984> .PERIOD So <sil=0.537> ,COMMA size of is an operator which takes the name of a type as an argument <sil=0.917> .PERIOD It can also take other kinds of arguments <sil=0.527> ,COMMA we will see that <sil=0.983> .PERIOD So <sil=0.558> ,COMMA you could ask what is the size of an int <sil=0.314> ,COMMA what is the size of a float <sil=0.528> ,COMMA what is the size of a character and the answer <sil=0.587> ,COMMA the value that it will come out to be will depend on some particular machine <sil=0.928> .PERIOD So <sil=0.591> ,COMMA the reason why you use the size of operator is that it helps you to write the code that is general enough for any machine <sil=0.964> .PERIOD We will see what that means <sil=0.925> .PERIOD So <sil=0.432> ,COMMA right now it just returns you the size of any given data type <sil=0.969> .PERIOD So <sil=0.424> ,COMMA the size size of operator has an effect on the way data is allocated and the way data is allocated depends on the machine <sil=0.987> .PERIOD We will see that <sil=0.993> .PERIOD So <sil=0.460> ,COMMA for example <sil=0.388> ,COMMA if we have a character array <sil=0.526> ,COMMA the cells are one byte apart <sil=0.988> .PERIOD So <sil=0.316> ,COMMA size of operator returns you the number of bytes that a data type occupies <sil=0.935> .PERIOD So <sil=0.584> ,COMMA in the case of a character <sil=0.305> ,COMMA a character occupies one byte <sil=0.987> .PERIOD So <sil=0.646> ,COMMA if you have a character array declared as car S 8 <sil=0.471> ,COMMA what you have are 8 cells and each of those cells occupy a width of one byte <sil=0.911> .PERIOD So <sil=0.469> ,COMMA let us see that the character array starts at hexadecimal address 1000 <sil=0.900> .PERIOD So <sil=0.588> ,COMMA the next cell will be at the next byte which is byte address hexadecimal 1000 and 1 and this goes on until the last cell which is hexadecimal 1000 and 7 <sil=0.941> .PERIOD So <sil=0.514> ,COMMA this contains a null terminated character array with the latest SUCCES and then followed by another <sil=0.984> .PERIOD What happens with an integer array <sil=0.962> ?QUESTIONMARK So <sil=0.600> ,COMMA in an integer array size of an int is 4 bytes <sil=0.983> .PERIOD So <sil=0.539> ,COMMA the successive elements of an integer array are 4 bytes apart <sil=0.982> .PERIOD So <sil=0.370> ,COMMA let us say that I have declared an integer array as int a 4 <sil=0.906> .PERIOD This means that a 0 let us say start set hexadecimal address 2000 <sil=0.916> .PERIOD Then a 1 will start 4 bytes away because the size of an int is 4 bytes <sil=0.933> .PERIOD So <sil=0.491> ,COMMA it should start at address hexadecimal 2004 and I have seen that the initials sort of indicated it pictorially <sil=0.986> .PERIOD I want to say that a character is a narrower data type than an integer <sil=0.986> .PERIOD An integer occupies 4 bytes <sil=0.961> .PERIOD So <sil=0.471> ,COMMA the next integer cell <sil=0.531> ,COMMA the next integer element in the array will start at hexadecimal address 2004 <sil=0.971> .PERIOD The third element will start at hexadecimal address 2008 and the last at hexadecimal address 2000 and C <sil=0.969> .PERIOD So <sil=0.325> ,COMMA no one will notice that I should have started it at 2012 <sil=0.932> .PERIOD But <sil=0.474> ,COMMA 12 in hexadecimal address addressing scheme is C <sil=0.902> .PERIOD So <sil=0.388> ,COMMA in base 16 <sil=0.457> ,COMMA C is the same as decimal 12 <sil=0.906> .PERIOD So <sil=0.643> ,COMMA that is why I have written it as hexadecimal 200C <sil=0.963> .PERIOD Now <sil=0.650> ,COMMA let us look at pointer arithmetic in greater detail <sil=0.969> .PERIOD With our current understanding of the size of operator <sil=0.995> .PERIOD So <sil=0.486> ,COMMA suppose you have an instar pointer <sil=0.902> .PERIOD If you have an instar pointer and then you want to say that PTR plus I is equal to what it should <sil=0.932> .PERIOD So <sil=0.617> ,COMMA notice that plus makes sense when you are navigating within an array <sil=0.994> .PERIOD So <sil=0.388> ,COMMA PTR is let us say pointing to some cell within the array and PTR plus I should go to the Ith cell after PTR <sil=0.981> .PERIOD That is what it should do <sil=0.941> .PERIOD Now <sil=0.362> ,COMMA the Ith cell after PTR means the Ith integer after PTR <sil=0.921> .PERIOD So <sil=0.509> ,COMMA we should skip 4 I bytes in order to reach the Ith integer cell after PTR <sil=0.920> .PERIOD So <sil=0.417> ,COMMA this is what we have written here <sil=0.981> .PERIOD PTR plus I is the byte numbered PTR plus I star size of end <sil=0.956> .PERIOD The machine addressing goes in terms of bytes <sil=0.925> .PERIOD So <sil=0.395> ,COMMA in order to jump to the Ith integer cell <sil=0.545> ,COMMA we have to know how many bytes to skip and the size of an integer is 4 bytes <sil=0.921> .PERIOD So <sil=0.454> ,COMMA this means we have to skip ahead 4 I bytes in order to reach PTR plus I <sil=0.972> .PERIOD Now <sil=0.386> ,COMMA if had you declared character star PTR <sil=0.572> ,COMMA then PTR plus I is supposed to jump to the Ith character after PTR <sil=0.935> .PERIOD Size of a character is 1 byte <sil=0.976> .PERIOD So <sil=0.372> ,COMMA PTR plus I star size of character would be PTR plus I star 1 <sil=0.970> .PERIOD It is the same as PTR plus I <sil=0.900> .PERIOD So <sil=0.446> ,COMMA notice that let us say the machine understands only byte addresses <sil=0.990> .PERIOD So <sil=0.349> ,COMMA in order to execute PTR plus I correctly <sil=0.460> ,COMMA we have to tell which byte should I go to <sil=0.922> ?QUESTIONMARK Should the machine go to <sil=0.952> ?QUESTIONMARK And in order to do that <sil=0.454> ,COMMA you utilize the size of operator <sil=0.962> .PERIOD So <sil=0.628> ,COMMA since you had declared character star PTR <sil=0.490> ,COMMA you know that it is size of character <sil=0.991> .PERIOD I star size of character <sil=0.901> .PERIOD Those many bytes I have to skip <sil=0.948> .PERIOD In the previous case <sil=0.376> ,COMMA I had declared in star PTR <sil=0.937> .PERIOD So <sil=0.606> ,COMMA in that case <sil=0.357> ,COMMA I had to skip I star size of end in order to reach the correct cell <sil=0.964> .PERIOD So <sil=0.328> ,COMMA here is the actual reason why PTR plus I would magically work correctly <sil=0.450> ,COMMA whether it was an integer array or it was a character array <sil=0.922> .PERIOD This is because at the back of it all <sil=0.488> ,COMMA you translate everything to byte addresses using star size of whatever type <sil=0.972> .PERIOD So <sil=0.462> ,COMMA in general if you have type star PTR <sil=0.532> ,COMMA then PTR plus I is the byte numbered PTR plus I star size of type <sil=0.971> .PERIOD So <sil=0.566> ,COMMA this type is the same as the declared type of pointer <sil=0.905> .PERIOD PTR is a pointer to that type <sil=0.960> .PERIOD Therefore <sil=0.642> ,COMMA you multiply it with size of type and this is the general formula for pointer array <sil=0.915> .PERIOD Now <sil=0.478> ,COMMA one of the side effects of that or one of the consequences of this kind of addressing is that array plus I is star of array plus I and it will correctly jump to the I th location in that array <sil=0.953> .PERIOD Regardless of whatever type the array was <sil=0.373> ,COMMA why is that <sil=0.866> ?QUESTIONMARK Because array plus I is then translated to array plus I star size of whatever type the array has been declared to be <sil=0.921> .PERIOD So <sil=0.373> ,COMMA you will correctly jump to the byte address corresponding to the I th element in the array <sil=0.940> .PERIOD So <sil=0.309> ,COMMA here is how array arithmetic in C works in full <sil=0.929> .PERIOD What do we mean by this <sil=0.907> ?QUESTIONMARK Let us see that with the help of an example <sil=0.989> .PERIOD Suppose you have an integer array declared as int a 10 and it starts at the address 2000 and I want to know how is it that you get this third element of the array a of 2 <sil=0.973> .PERIOD So <sil=0.647> ,COMMA a of 2 we know is star of a plus 2 a is a pointer to the first element of the array and we have to now understand how plus 2 is executed <sil=0.964> .PERIOD So <sil=0.396> ,COMMA plus 2 should be the content located at byte address a plus 2 star size of it <sil=0.996> .PERIOD Why is this <sil=0.898> ?QUESTIONMARK A is been declared as integer array and in C integer array has the same type as in star <sil=0.934> .PERIOD So <sil=0.627> ,COMMA is a is a pointer to int <sil=0.910> .PERIOD Therefore <sil=0.546> ,COMMA we know that we have to do a plus 2 star size of int <sil=0.980> .PERIOD Whatever the argument is <sil=0.555> ,COMMA it will do 2 star size of the type pointer to by that pointer <sil=0.944> .PERIOD So <sil=0.567> ,COMMA we will do a plus 2 star 4 which is hexadecimal address 2008 <sil=0.429> ,COMMA A was 2000 <sil=0.955> .PERIOD So <sil=0.443> ,COMMA if you have an array int a 4 let us say and it started at address 2000 then you will jump to array address 2008 and this is the reason why C arrays started index 0 because it is a very easy formula <sil=0.920> .PERIOD A of 0 would be star of A plus 0 which is simply star of A <sil=0.945> .PERIOD In that case you have the consistent explanation that the name of the array is a pointer to the first address of the array <sil=0.935> .PERIOD First element of the array you do not need a special rule to do that <sil=0.939> .PERIOD Think of what would have happened if arrays started at 1 then A of 2 would be A plus 1 star size of int <sil=0.978> .PERIOD So <sil=0.517> ,COMMA A of n would be A plus n minus 1 times size of whatever and that is an earlier formula then what we have here <sil=0.921> .PERIOD So <sil=0.598> ,COMMA it is better for arrays to start at location 0 because it makes the pointer arithmetic easier <sil=0.993> .PERIOD So <sil=0.615> ,COMMA in summary the size of operator is used in pointer arithmetic and we will see one more common use of the size of operator very soon <sil=0.964> .PERIOD So <sil=0.412> ,COMMA the general usage is you can give size of an expression what will do what will it do is it will take the type of the type of expression <sil=0.943> .PERIOD So <sil=0.483> ,COMMA if I say size of 10 then 10 is an int <sil=0.947> .PERIOD So <sil=0.400> ,COMMA it will execute size of int and let us say that on a particular machine it is 4 bytes <sil=0.902> .PERIOD Similarly <sil=0.569> ,COMMA you could also say size of type name <sil=0.977> .PERIOD So <sil=0.481> ,COMMA for example <sil=0.396> ,COMMA I could say size of int rather than giving an integer as an argument I could also say size of int where int is the name of the type and it will return me 4 on some particular machine <sil=0.961> .PERIOD A less common usage is you could give size of array where array is some particular array and it will return you the size of the array in bytes and this is important it will not return you exactly the number of elements in the array it will return the total size of the array in bytes <sil=0.995> .PERIOD What do I mean by that <sil=0.970> ?QUESTIONMARK If I say int num 10 and then I say size of num it will return me 40 because there are 10 integers each integer occupying 4 bytes <sil=0.915> .PERIOD So <sil=0.302> ,COMMA in order to calculate the number of elements in the array for example <sil=0.566> ,COMMA you could do the following you could say size of num 0 divided by size of num 0 <sil=0.906> .PERIOD So <sil=0.371> ,COMMA this would evaluate to 40 divided by 4 which is 10 <sil=0.985> .PERIOD So <sil=0.497> ,COMMA size of the operator on the array does not exactly give you the number of elements in the array will give you the total number of bytes in the array <sil=0.977> .PERIOD But if you also know how much how many bytes a particular element in the array occupies then you can easily figure out the size of the array in terms of the number of elements <sil=0.979> .PERIOD So <sil=0.431> ,COMMA also note that C does not say that an integer is 4 bytes or float is 4 bytes and so on <sil=0.948> .PERIOD What it specifies is the relationship between the sizes of various types and we will not get into it right now <sil=0.931> .PERIOD But just keep in mind that the size of a particular type is dependent on which machine you are running the code on <sil=0.991> .PERIOD In the previous session <sil=0.581> ,COMMA we were talking about ASCII character set and I said that we do not need to remember the ASCII table <sil=0.637> ,COMMA but we need to remember some general properties of the ASCII table <sil=0.951> .PERIOD So what are those general properties <sil=0.994> ?QUESTIONMARK First we know that the initial 32 characters of the ASCII table are non printable characters <sil=0.520> ,COMMA then the remaining or rather from ASCII value 32 to ASCII value 126 are printable values <sil=0.956> .PERIOD Among them you know that the integers <sil=0.430> ,COMMA the digits are occurring together <sil=0.926> .PERIOD Similarly <sil=0.396> ,COMMA the capital letters occur consecutively one after the other and the small letters occur consecutively one after the other <sil=0.934> .PERIOD So this is some abstract property of the ASCII code chart that helps us in writing some useful code <sil=0.910> .PERIOD We will see in a minute what kind of use we can obtain using these general properties rather than knowing the specific thing like the character value of A is hex value 41 or decimal value 65 <sil=0.955> .PERIOD This kind of information we need not remember this <sil=0.929> .PERIOD For example <sil=0.351> ,COMMA let us write a small program that prints <sil=0.914> .PERIOD In our previous session <sil=0.612> ,COMMA we had said that we do not need to remember the exact ASCII code of certain characters <sil=1.000> .PERIOD We just need to remember some abstract properties of the ASCII table <sil=0.999> .PERIOD For example <sil=0.366> ,COMMA abstract properties like all the digits occur together from 0 to 9 <sil=0.969> .PERIOD All the capital letters from A to Z occur together in the table in the alphabetical order <sil=0.906> .PERIOD Similarly <sil=0.635> ,COMMA all the small letters occur together in consecutive locations in the ASCII table <sil=0.982> .PERIOD Also another property that you can observe is that the small letters occur after all the capital letters <sil=0.967> .PERIOD Let us see how we can write some interesting code using these properties and not by remembering the exact ASCII code of certain letters <sil=0.907> .PERIOD So let us write a simple program to print the alphabet <sil=0.927> .PERIOD The ASCII codes of the uppercase letters are consecutive and the ASCII codes of the lower case letters are consecutive <sil=0.918> .PERIOD This is the property that we will exploit in order to print the alphabet <sil=0.955> .PERIOD So for example <sil=0.535> ,COMMA let us say that we are going to print the letters of the alphabet in capital letters <sil=0.904> .PERIOD So for that we can use the following program using a for loop <sil=0.983> .PERIOD So what you have to do is to initialize a particular character variable to capital letter A <sil=0.966> .PERIOD So the ASCII character A <sil=0.903> .PERIOD So note that A within single codes stands for the character constant A <sil=0.900> .PERIOD If you look at the integer value then it is the ASCII code for A <sil=0.950> .PERIOD We are not particularly interested to know what exactly the number is <sil=0.975> .PERIOD Now we can write the for loop in an interesting way <sil=0.901> .PERIOD We can say that start from capital A and then print the characters until you hit capital Z <sil=0.906> .PERIOD And the update statement is after printing go to the next ASCII letter <sil=0.937> .PERIOD So what this is doing is starting from A and then it will go to A plus 1 which is the ASCII code for B <sil=0.929> .PERIOD Then it will go to B plus 1 which is the ASCII code for C <sil=0.954> .PERIOD So on up till Z <sil=0.928> .PERIOD So once you reach Z it will print that character <sil=0.958> .PERIOD It will update once more where it is the ASCII character one more than <sil=0.999> .PERIOD So the ASCII character next to Z in the ASCII table we do not really need to know what it is <sil=0.920> .PERIOD Certainly it will be greater than the ASCII value of Z and at that point we will exit the code <sil=0.934> .PERIOD So the output of it will be consecutively A to Z <sil=0.957> .PERIOD Let us look at what is happening here in greater detail <sil=0.913> .PERIOD All the characters are stored as 8 bit integers <sil=0.963> .PERIOD Now they can be assigned as integers <sil=0.637> ,COMMA incremented <sil=0.451> ,COMMA decremented etc <sil=0.968> .PERIOD Because essentially they behave like integers <sil=0.918> .PERIOD So suppose A has ASCII code 65 <sil=0.909> .PERIOD A has ASCII code 65 but we are not concerned about that <sil=0.931> .PERIOD Now so CH equal to character constant A sets CH equal to 65 <sil=0.959> .PERIOD Now CH plus 1 is the number 66 which corresponds to the ASCII code of B <sil=0.905> .PERIOD So addition <sil=0.581> ,COMMA subtraction all these can be performed on character values because internally they are represented as 8 bit integers <sil=0.939> .PERIOD Similarly relational operations like less than or equal to greater than or equal to all of these also make sense <sil=0.989> .PERIOD So for example if we use the relational expression capital letter A ASCII constant A less than character constant B then notice that A is the ASCII value 65 and B is ASCII value 66 <sil=0.966> .PERIOD So A less than B is correct <sil=0.968> .PERIOD Now for realizing that A is A less than B is correct <sil=0.993> .PERIOD We do not need to know that A is 65 and B is 66 <sil=0.956> .PERIOD All we know is that the abstractly in the ASCII table the character code for A is less than the character code for 6 because B occurs after A <sil=0.988> .PERIOD So if it is 65 and 66 or it is 0 and 1 the answer is still the same <sil=0.942> .PERIOD Now let us write a few more interesting programs where the spirit is that we do not need to understand what the exact ASCII code of a letter is but just we want to remember the layout of the ASCII table <sil=0.988> .PERIOD For example suppose I want to write a conditional expression and if condition which says that if the given character is capital letter then print that it is an uppercase <sil=0.944> .PERIOD So all I need to do is if the character value is greater than or equal to the character constant A and less than or equal to the character constant Z then you print that the given letter is an uppercase <sil=0.931> .PERIOD Again please remember that we did not need to know that this was 65 and this was whatever it is 90 <sil=0.967> .PERIOD And could as well have been 0 and 25 it would still have worked because all we need to remember in the ASCII table is that A through Z occurs in consecutive locations in the standard alphabetical order <sil=0.926> .PERIOD From that we can understand that if I write this if expression it will print the message uppercase only if the given character CH is an uppercase letter <sil=0.959> .PERIOD Similarly let us say that if you want to check whether a character is in lower case you can analogously write character is greater than or equal to A little A in single codes and it is less than or equal to little Z in single codes <sil=0.952> .PERIOD If that is true then you print that it is in lower case <sil=0.954> .PERIOD Now if you want to check whether a given character is a digit similarly you can say that it is greater than or equal to the character 0 and this is less than or equal to the character 9 <sil=0.990> .PERIOD Now here is a subtle point which I hope you notice the character 0 is the ASCII constant ASCII character constant 0 <sil=0.960> .PERIOD So it corresponds to some particular ASCII value it is different from the number 0 <sil=0.939> .PERIOD So this is something that so we are looking for the ASCII value corresponding to 0 it is greater than or equal to that and less than or equal to the character value corresponding to the character 9 <sil=0.952> .PERIOD So if that is true then the given character is a digit <sil=0.904> .PERIOD Now here is a snippet that I would advise you to take a look at it and tell me what it actually it is <sil=0.928> .PERIOD So take a moment yourself and try to figure it out <sil=0.948> .PERIOD So what it does is the given character CH if it is a lower case letter remember this is the example that we just saw this condition checks whether the given character is a lower case letter a small letter between A and Z little A and little Z <sil=0.962> .PERIOD If it is true then what you do is add capital A minus small A to the character <sil=0.940> .PERIOD So what does it accomplish <sil=0.983> ?QUESTIONMARK So let us say that we actually had CH equal to little A <sil=0.970> .PERIOD Now for the purpose of illustration let us say that little A was ASCII value 100 <sil=0.994> .PERIOD I do not know whether that is true but it is not important that is what I want to illustrate <sil=0.989> .PERIOD Now what does capital A represent <sil=0.858> ?QUESTIONMARK It represents some ASCII value let us say 65 <sil=0.906> .PERIOD So if the given character was little A what I would do is I would say character equal to CH minus 100 plus 65 <sil=0.976> .PERIOD Similarly if CH was character constant B I would still add CH equal to CH minus 100 plus 65 <sil=0.929> .PERIOD So it is adding a constant difference to the given character regardless of whether it was A or B the additive constant that we are adding is still the same <sil=0.928> .PERIOD If you think about what is happening it is adding exactly the difference between little A and capital A <sil=0.970> .PERIOD Notice that the difference between little B and capital B is the same as little A and capital A <sil=0.925> .PERIOD Why <sil=0.963> ?QUESTIONMARK Because all the capital letters occur consecutively and all the small letters occur consecutively <sil=0.947> .PERIOD So suppose A minus Z little A minus capital A is let us say 35 then little B minus capital B will also be 35 because you advance one in each case <sil=0.929> .PERIOD So if you think for a minute you will see that what this code does is take the ASCII code corresponding to the small letter and add a constant difference <sil=0.948> .PERIOD What is that difference <sil=0.945> ?QUESTIONMARK That difference is what will take you to the capital letter corresponding capital letter <sil=0.976> .PERIOD So in short what this does is to convert the given character in lower case letter to an upper case letter <sil=0.969> .PERIOD So if it is a lower case letter it will convert it to an upper case letter otherwise it does nothing <sil=0.963> .PERIOD Now let us think about what we mean by scanning a character versus scanning an integer <sil=0.999> .PERIOD So let us say that I have two variables in number and character letter <sil=0.934> .PERIOD So let us say that I am scanning now n which is a number and the input was 12 <sil=0.943> .PERIOD So when I say scan of percentage D and n I am trying to read 12 into an integer variable <sil=0.915> .PERIOD Now on a typical machine an integer variable may occur may occupy 32 bits or 4 bytes <sil=0.985> .PERIOD So it has 32 bits in it and if you know the binary notation you will see that 110 in binary is the number 12 <sil=0.983> .PERIOD So this is 8 plus 4 which is 12 <sil=0.938> .PERIOD So when you see that the input is 12 and then I ask the C program <sil=0.517> ,COMMA in the C program I am doing scan of percentage D and n <sil=0.988> .PERIOD What will happen is that n is an integer with 32 bits wide and it will have the following pattern encoded into it <sil=0.928> .PERIOD This is what it means by scanning an integers and if you try to print it out it will try to interpret n as a decimal number and it will print the digit 12 <sil=0.342> ,COMMA the number 12 <sil=0.904> .PERIOD On the other hand for the same input and here is the difference I want to emphasize <sil=0.973> .PERIOD If the code was saying percentage C and letter <sil=0.993> .PERIOD So scan the input 12 using the scan of statement scan of percentage C and letter <sil=0.941> .PERIOD What will happen is that the C program is looking at the first character which is the digit 1 and scanning it in <sil=0.952> .PERIOD Now character 1 is ASCII 49 <sil=0.306> ,COMMA it is not important you remember that but it has some ASCII value and that ASCII value 49 is 31 in hexadecimal because it is 3 times 16 plus 1 which is 48 plus 1 49 <sil=0.990> .PERIOD So the character 1 is 31 in hexadecimal and hence what will be stored <sil=0.878> ?QUESTIONMARK Remember that a character ASCII character is 8 bits wide so it will store 31 in hexadecimal so it will be 3 this is the number 3 and this is the number 1 <sil=0.924> .PERIOD So when you scan the input into a character variable called letter what will happen is that letter will have the number hexadecimal 31 or ASCII value 49 which corresponds to the number which corresponds to the character constant 1 <sil=0.953> .PERIOD So this is the difference between scanning a given input as a number and scanning a given input using a character <sil=0.929> .PERIOD So when you scan it using a number this entire thing will be scanned it will be converted into binary and you will store it in an integer variable <sil=0.935> .PERIOD When you scan it as a letter it will scan the first digit only because that is the character and then store the ASCII value inside the letter variable inside the character variable <sil=0.988> .PERIOD So this corresponds to the letter variable 1 within single codes the character constant 1 <sil=0.961> .PERIOD Once we know structures and pointers to structures <sil=0.630> ,COMMA we can introduce some very important data structure called a linked list <sil=0.990> .PERIOD So <sil=0.349> ,COMMA we will first see what linked lists are <sil=0.636> ,COMMA how to operate on them and then argue why linked lists are useful <sil=0.986> .PERIOD So <sil=0.526> ,COMMA let us just introduce this notion called self referential structures <sil=0.995> .PERIOD So <sil=0.520> ,COMMA we are defining a struct node that has two fields <sil=0.524> ,COMMA one is an int data and the next field is the surprising one <sil=0.565> ,COMMA it is a pointer to type struct node <sil=0.957> .PERIOD So <sil=0.507> ,COMMA this data structure <sil=0.526> ,COMMA this C structure is called a self referential structure because internally there is a pointer to an object of the same type <sil=0.990> .PERIOD So <sil=0.580> ,COMMA in that sense it refers to some other object of the same type <sil=0.982> .PERIOD So <sil=0.384> ,COMMA it is called self referential <sil=0.905> .PERIOD So <sil=0.645> ,COMMA an example would be like this where the data field has 10 and the next field points to something else which should be a struct node <sil=0.993> .PERIOD So <sil=0.327> ,COMMA then field next is of type struct node <sil=0.909> .PERIOD Now <sil=0.622> ,COMMA there is a subtle point to be emphasized <sil=0.573> ,COMMA instead of struct node star had I written struct node next <sil=0.399> ,COMMA then this is not allowed because the definition of struct node has an internal struct node inside it <sil=0.949> .PERIOD So <sil=0.577> ,COMMA it essentially has infinite size <sil=0.965> .PERIOD So <sil=0.548> ,COMMA we are cleverly avoiding that by including just a pointer to the next node <sil=0.968> .PERIOD So <sil=0.429> ,COMMA using this structure we can define what is known as a sinkley linked list <sil=0.966> .PERIOD So <sil=0.610> ,COMMA an example of a sinkley linked list structure would be where we have a pointer which we will call the head of the list <sil=0.945> .PERIOD Head points to the first struct which is 4 <sil=0.375> ,COMMA which has data 4 and it is linked to another struct which has data 2 <sil=0.564> ,COMMA that is linked to another struct which has data 1 and so on <sil=0.921> .PERIOD The last struct in the list will be linked to null <sil=0.969> .PERIOD So <sil=0.542> ,COMMA there is only one link from each node hence the name sinkley linked list <sil=0.969> .PERIOD So <sil=0.488> ,COMMA the fact that the next field is null indicates that that is the last node in a linked list and a linked list is always identified by its head which is the pointer to the first node in the linked list <sil=0.971> .PERIOD Once we reach the first node we can travel the list by using just the next links <sil=0.966> .PERIOD So <sil=0.498> ,COMMA once we have a link to 4 we can always say 4 <sil=0.426> ,COMMA 2 <sil=0.520> ,COMMA 1 <sil=0.446> ,COMMA minus 2 and so on <sil=0.982> .PERIOD So <sil=0.485> ,COMMA the list is made modeled by a variable called the head that points to the first node in the list and if the head is null then that means the list is empty and then you have a bunch of nodes and once we reach a node with the next field null then that is the last node in the linked list <sil=0.969> .PERIOD Now <sil=0.466> ,COMMA let us look at certain simple operations on sinkley linked list <sil=0.942> .PERIOD Suppose you want to insert a node at the front of the list <sil=0.946> .PERIOD So <sil=0.636> ,COMMA we have a list 4 to 1 minus 2 and we want to insert something else in the beginning <sil=0.957> .PERIOD So <sil=0.503> ,COMMA what you do is you create a new node of type struct node and set its data field to whatever number that you want to store <sil=0.923> .PERIOD Now <sil=0.447> ,COMMA add it to the front of the list and we will see how this can be done <sil=0.958> .PERIOD So <sil=0.614> ,COMMA suppose that the head is now pointing to 4 and the list is 4 to 1 minus 2 and you want to add a new node <sil=0.944> .PERIOD So <sil=0.631> ,COMMA 2 is the node the data field is 2 <sil=1.000> .PERIOD Now <sil=0.649> ,COMMA how do you add <sil=0.885> ?QUESTIONMARK You do 2 operations <sil=0.959> .PERIOD First you say that 2 is next is the first node in the old list <sil=0.958> .PERIOD So <sil=0.605> ,COMMA that would insert 2 here and then now the list has changed <sil=0.906> .PERIOD The list has changed because the first element is now 2 <sil=0.980> .PERIOD So <sil=0.428> ,COMMA head moves to 2 <sil=0.944> .PERIOD Head was previously 4 and head now moves to 2 <sil=0.915> .PERIOD So <sil=0.323> ,COMMA this is abstractly how you would insert a node at the beginning of a list <sil=0.972> .PERIOD So <sil=0.381> ,COMMA now let us try to code it and see <sil=0.958> .PERIOD So <sil=0.581> ,COMMA first we need a code small function to make a node with the given data <sil=0.907> .PERIOD So <sil=0.635> ,COMMA we will say struct node star make node in 12 <sil=0.972> .PERIOD Now <sil=0.550> ,COMMA we will create a pointer struct node star temp then use one of the malloc function called call log <sil=0.923> .PERIOD So <sil=0.302> ,COMMA one size of struct node <sil=0.923> .PERIOD So <sil=0.608> ,COMMA this will allocate memory enough to create one node <sil=0.941> .PERIOD Now <sil=0.461> ,COMMA this that memory its data field will be set to val which is what we are given as argument to the function and then you return the node <sil=0.992> .PERIOD So <sil=0.562> ,COMMA we have created a node and how do you insert in the front <sil=0.888> ?QUESTIONMARK Once you have once you receive an value to be inserted at the beginning of a list <sil=0.929> .PERIOD So <sil=0.302> ,COMMA the list is identified by the head <sil=0.967> .PERIOD So <sil=0.301> ,COMMA we have to create a node which contains the value and insert it at the beginning of this list <sil=0.953> .PERIOD So <sil=0.616> ,COMMA what we do is we first create a node with the value using make node function <sil=0.946> .PERIOD Now <sil=0.463> ,COMMA temp next is set to head <sil=0.942> .PERIOD So <sil=0.342> ,COMMA this link is activated <sil=0.919> .PERIOD So <sil=0.618> ,COMMA 2's next will be 4 <sil=0.955> .PERIOD So <sil=0.546> ,COMMA that is the first step <sil=0.960> .PERIOD The second step is that the head now has to move to 2 because the first element in the new list is 2 not 4 <sil=0.925> .PERIOD So <sil=0.555> ,COMMA I will just say head equal to temp and return head which is the head of the new list <sil=0.933> .PERIOD Now <sil=0.431> ,COMMA you can call this function multiple times <sil=0.957> .PERIOD Suppose <sil=0.323> ,COMMA you want to start with an empty list and insert minus 2 then insert minus 1 then insert 2 then insert 4 then insert 2 <sil=0.963> .PERIOD You can call these functions one after the other <sil=0.953> .PERIOD So <sil=0.384> ,COMMA I can just say struck node head equal to insert front 2 of insert front 4 of insert front 2 of 1 of minus 2 <sil=0.944> .PERIOD So <sil=0.328> ,COMMA this is the function this is the sequence of functions and this is the list that you will end up with <sil=0.966> .PERIOD So <sil=0.515> ,COMMA once you have the function to insert at the beginning of a list you can use that function multiple times to build up the list <sil=0.951> .PERIOD Now <sil=0.485> ,COMMA let us look at some useful functions to be done on linked list <sil=0.935> .PERIOD So <sil=0.417> ,COMMA once you have a linked list it will be good if you can search the linked list to see whether an element is present or not <sil=0.903> .PERIOD So <sil=0.455> ,COMMA we will look at a very simple algorithm <sil=0.995> .PERIOD So <sil=0.465> ,COMMA we want to search for a particular key that is an element in a singly linked list <sil=0.987> .PERIOD So <sil=0.378> ,COMMA how do you do it <sil=0.938> ?QUESTIONMARK abstractly what you do is you start with the head see whether the data field in the head node is the key that you want <sil=0.937> .PERIOD If it is then you are done and you say that I have found it if it is not what you do is you go to the next node through the next link and then search is it the data field of the next node if it is you are done if it is not you search and follow the next node <sil=0.958> .PERIOD You follow this procedure until you reach the last node suppose you have not found the key even in the last node and you follow the next link and it is null <sil=0.925> .PERIOD So <sil=0.495> ,COMMA once you reach null then you know that you have reached the end of the list <sil=0.911> .PERIOD So <sil=0.351> ,COMMA you cannot take null next that will cause your code to crash <sil=0.967> .PERIOD So <sil=0.628> ,COMMA once you know that your node is null you can search you can end the search and then say that the key is not present in the list <sil=0.967> .PERIOD Here is a flow chart corresponding to that you start with current equal to head <sil=0.905> .PERIOD Now <sil=0.615> ,COMMA is current null if the current is null then that means you have reached the end of the list and you have not found the key <sil=0.917> .PERIOD So <sil=0.446> ,COMMA if the current is not null then there is data still to be searched <sil=0.956> .PERIOD So <sil=0.551> ,COMMA you see whether current data is equal to key if it is yes then you have found the key otherwise you follow the next node link to go to the next node in the linked list and again repeat the procedure <sil=0.921> .PERIOD And you can code this in a straightforward manner <sil=0.924> .PERIOD So <sil=0.389> ,COMMA I will write slot node star search <sil=0.938> .PERIOD I need the head of the list and I need the key you start with current equal to head if current is not equal to null and current data is not equal to key you follow the next link current equal to current next and you repeat the procedure <sil=0.997> .PERIOD So <sil=0.548> ,COMMA when you exit the list either current will be null or current data will be key <sil=0.905> .PERIOD So <sil=0.465> ,COMMA what is the condition when you reach the the return <sil=0.920> .PERIOD So <sil=0.303> ,COMMA if the key is absent then you are returning null if the key is present you are returning the pointer to the node to the pointer to the first node that contains the key <sil=0.976> .PERIOD So <sil=0.403> ,COMMA convince yourself that the code works <sil=0.971> .PERIOD Now <sil=0.397> ,COMMA let us look at slightly more involved operations we have seen insert at the head of the list and that was fairly simple <sil=0.935> .PERIOD Now <sil=0.584> ,COMMA suppose you want to insert into the middle of the list you do not want to insert at the right at the front you want to insert somewhere in the middle <sil=0.980> .PERIOD Now <sil=0.346> ,COMMA there are two cases here if the list is null that is the easy case if the list is null then insert in the in the middle is essentially insert at the front <sil=0.918> .PERIOD So <sil=0.605> ,COMMA we already have seen the code for that <sil=0.906> .PERIOD Now <sil=0.425> ,COMMA the if the list is not null now it is a new algorithm <sil=0.984> .PERIOD So <sil=0.421> ,COMMA let us look at an example <sil=0.995> .PERIOD So <sil=0.521> ,COMMA suppose the list is 4 to 1 minus 2 and I want to insert a node 5 after node 2 <sil=0.927> .PERIOD So <sil=0.561> ,COMMA how do I do it <sil=0.930> ?QUESTIONMARK Two's next link was 1 and what we need to do in this case is I want to say that I have to insert this node 5 <sil=0.997> .PERIOD 5's next node will be 1 that is <sil=0.945> .PERIOD So <sil=0.647> ,COMMA think about this as a link in a chain <sil=0.982> .PERIOD So <sil=0.559> ,COMMA you need to disconnect this link say that 2 is now connected to 5 and 5 is then connected to 1 <sil=0.991> .PERIOD Now <sil=0.359> ,COMMA the only thing to be noted is that the links have to be detached in a particular sequence <sil=0.956> .PERIOD So <sil=0.594> ,COMMA first I need to say that 5's next is 1 and then I need to say that 2's next is 5 <sil=0.950> .PERIOD So <sil=0.573> ,COMMA convince yourself that the opposite sequence where I say that 2's next is 5 <sil=0.996> .PERIOD Now <sil=0.372> ,COMMA your code will has no way to proceed because you have lost the how to traverse from 2 to 1 <sil=0.936> .PERIOD If you say that 2's next is 5 then 5 has no way to know what was the original next node of 2 <sil=0.971> .PERIOD So <sil=0.433> ,COMMA you have to do it in a particular sequence 5's next is 1 and then 2's next is 5 <sil=0.935> .PERIOD We will see this code in a minute <sil=0.914> .PERIOD So <sil=0.525> ,COMMA what we do is we want to insert an insert after a node <sil=0.927> .PERIOD So <sil=0.533> ,COMMA p current is the node after which we have to insert and p new is the is pointing to the new node that we have to insert <sil=0.942> .PERIOD If p current is null then essentially the list is basically p new <sil=0.946> .PERIOD This is the case that we have seen before <sil=0.927> .PERIOD If p current is not null that means the list is not empty then what you do is the new nodes next node is p current's next node <sil=0.988> .PERIOD So <sil=0.499> ,COMMA 5's next node is the old 2's next node which is 1 <sil=0.933> .PERIOD So <sil=0.385> ,COMMA 5 next will be said to 1 and after that I will say p current next equal to p new <sil=0.911> .PERIOD Then I will say that p current which is 2's next will be said to 5 <sil=0.952> .PERIOD So <sil=0.349> ,COMMA convince yourself that if I swap these 2 lines <sil=0.494> ,COMMA if I swap the lines order then the code will not work <sil=0.970> .PERIOD So <sil=0.311> ,COMMA see this for 5 minutes and you convince yourself that that will not work <sil=0.907> .PERIOD So <sil=0.466> ,COMMA let us just see how this works <sil=0.912> .PERIOD So <sil=0.546> ,COMMA initially let us say that I want to insert after 2 and new is the new node <sil=0.962> .PERIOD So <sil=0.459> ,COMMA initial state is something like this <sil=0.907> .PERIOD The 5's next node is pointing to something <sil=0.301> ,COMMA maybe some arbitrary location <sil=0.919> .PERIOD Now <sil=0.380> ,COMMA after line 2 that is p new next equal to p current next <sil=0.303> ,COMMA this is the state of pointers <sil=0.930> .PERIOD Please look very carefully <sil=0.916> .PERIOD So <sil=0.459> ,COMMA 5's next will point to 1 and at this point 2's next is also pointing to 1 <sil=0.961> .PERIOD So <sil=0.569> ,COMMA there are 2 nodes whose next is 1 which is fine because we have not completely inserted 5 into the list <sil=0.902> .PERIOD Now <sil=0.432> ,COMMA at this point I will just detach 2's next and make it 0 <sil=0.967> .PERIOD 25 <sil=0.941> .PERIOD So <sil=0.492> ,COMMA there you go <sil=0.947> .PERIOD So <sil=0.448> ,COMMA after step 3 you have essentially inserted 5 into the list <sil=0.920> .PERIOD Now <sil=0.550> ,COMMA let us look at some syntactic conveniences that C provides you <sil=0.924> .PERIOD So <sil=0.497> ,COMMA repetitively are tripping struck node and things like that is it is just too much to type and C allows you to define short names for types <sil=0.967> .PERIOD So <sil=0.467> ,COMMA if I want to say like struck node star I want to use the name list node <sil=0.965> .PERIOD So <sil=0.407> ,COMMA I will just say struck instead of struck node star head I will just say list node head <sil=0.988> .PERIOD So <sil=0.635> ,COMMA it is a shorter way to do it <sil=0.925> .PERIOD So <sil=0.390> ,COMMA how do I write this <sil=0.963> ?QUESTIONMARK This is using what is known as a type death keyword in C <sil=0.953> .PERIOD So <sil=0.497> ,COMMA if I say type death struck node star list node what it means is that list node is another name for the long type struck node star <sil=0.922> .PERIOD So <sil=0.352> ,COMMA this is something that you may use if you want to it is not something that is that you should use <sil=0.633> ,COMMA but it is just convenient <sil=0.953> .PERIOD So <sil=0.361> ,COMMA if I say list node head this is the same as saying struck node star head comma current <sil=0.911> .PERIOD Now <sil=0.536> ,COMMA let us see why linked lists are important <sil=0.928> .PERIOD So <sil=0.593> ,COMMA first of all it is one of the first non trivial data structures that you learn <sil=0.949> .PERIOD In the earlier days when C had only fixed size arrays <sil=0.481> ,COMMA linked list was important when you needed variable size storage <sil=0.961> .PERIOD Now <sil=0.599> ,COMMA days C has variable size storage <sil=0.932> .PERIOD So <sil=0.626> ,COMMA you can in arrays <sil=0.990> .PERIOD So <sil=0.410> ,COMMA that is not so important anymore <sil=0.514> ,COMMA but here is one important thing one difference between linked list and arrays which are very important like insertion and deletion in linked list are fairly cheap <sil=0.904> .PERIOD In the case of an array <sil=0.994> .PERIOD So <sil=0.471> ,COMMA if you want to insert an element at position k in an array <sil=0.639> ,COMMA you have to copy all elements from k to n minus 1 to the last element in the array <sil=0.566> ,COMMA move each of them backwards make space for it and then insert the kth array <sil=0.930> .PERIOD So <sil=0.435> ,COMMA this involves in the worst case it involves moving all the elements of the array by one element one position each <sil=0.930> .PERIOD Similarly <sil=0.417> ,COMMA for deletes <sil=0.496> ,COMMA suppose you want to delete an element from an array <sil=0.537> ,COMMA then what you have to do is you have to take the remaining elements of the array and move them one position to the left <sil=0.964> .PERIOD So <sil=0.644> ,COMMA this will involve moving n elements in the array if array has n elements in the worst case <sil=0.929> .PERIOD Whereas <sil=0.441> ,COMMA note that in the linked list case to insert or delete any element a new node whether at the beginning or at the or in between it just takes one operation <sil=0.995> .PERIOD The other elements need not be manipulated <sil=0.944> .PERIOD So <sil=0.575> ,COMMA let us just quickly see how to delete a particular node in a linked list <sil=0.965> .PERIOD So <sil=0.496> ,COMMA we will just say that 4 to 1 minus 2 is the linked list and I want to delete this particular node is that possible <sil=0.936> .PERIOD So <sil=0.440> ,COMMA I cannot straight forward delete this node because the previous nodes next element should point to this guy's next element <sil=0.994> .PERIOD So <sil=0.303> ,COMMA if I want to delete one what do I have to do <sil=0.894> ?QUESTIONMARK I have to say that 2's next node should be minus 2 <sil=0.955> .PERIOD But in a linked list there is no way to go back from one you cannot easily get to 2 <sil=0.916> .PERIOD So <sil=0.329> ,COMMA this is slightly so <sil=0.417> ,COMMA deletion requires slightly some more information <sil=0.946> .PERIOD So <sil=0.370> ,COMMA if I can delete a node if I also have a handle a pointer to its previous node then it is very easy to say that 2's next node will be minus 2 <sil=0.975> .PERIOD And that is what we will do <sil=0.929> .PERIOD So <sil=0.395> ,COMMA we will say that let us have a delete function <sil=0.909> .PERIOD P node is the node that I want to delete and P P node is its previous node and what I will do is if there is a previous node I will say previous nodes next is the current nodes next <sil=0.974> .PERIOD So <sil=0.522> ,COMMA 2's next link will go to minus 2 <sil=0.947> .PERIOD If there is no previous node then I will say that T equal to the current nodes next and then once that is done you delete the current node P node <sil=0.924> .PERIOD So <sil=0.401> ,COMMA this is how you would delete an element from the linked list <sil=0.946> .PERIOD So <sil=0.650> ,COMMA just recap searching in a linked list will take order n time in the case of a linked list that is you have to search all the elements in the worst case which is the same in an array <sil=0.989> .PERIOD Now <sil=0.331> ,COMMA suppose you saw an array you have faster search techniques available you can do binary search in an array <sil=0.900> .PERIOD Unfortunately in a linked list even if you saw the linked list there is no way to do a binary search in the linked list <sil=0.975> .PERIOD Why is this because you cannot reach the middle element of the linked list in one shot <sil=0.990> .PERIOD In an array you can just say a mid and it will go to the so suppose you say that mid equal to 0 plus n minus 1 by 2 you can go to the middle element of the array <sil=0.929> .PERIOD But there is no way to do that in a linked list you have to go one after the other <sil=0.943> .PERIOD So <sil=0.488> ,COMMA sorting does not help in searching when you are looking at single linked list <sil=0.910> .PERIOD But on the other hand insertion and deletion are very quick in a linked list whereas <sil=0.636> ,COMMA they are very slow in an array <sil=0.964> .PERIOD In this video we will look at linear recursion in a bit more depth and describe what I mean by linear recursion <sil=0.990> .PERIOD We have mentioned earlier that when designing recursive programs think about the problem in recursive times <sil=0.590> ,COMMA do not think in terms of the stack that is used in execution <sil=0.913> .PERIOD When it is actually executed there will be a stack created and used for the execution and the depth of recursion is a term which means the maximum size of the stack while you execute the program on a given input <sil=0.966> .PERIOD The memory used by the programs includes the local memory of the function plus the depth of the stack <sil=0.991> .PERIOD Let us look at linear recursion in a bit more detail <sil=0.942> .PERIOD By linear recursion I mean problems which can be solved by calling an instance of the sub problem <sil=0.939> .PERIOD Exactly one instance of some sub problem <sil=0.932> .PERIOD We will see more general kinds in later videos <sil=0.911> .PERIOD Let us look at an example that we have seen before which is reversing an array in place <sil=0.917> .PERIOD We had to reverse an array A with n elements and it is supposed to reverse the values contained in the first n indices of A <sil=0.928> .PERIOD That is A 0 is exchanged with A and minus 1 <sil=0.938> .PERIOD A 1 is exchanged with A and minus 2 and so on <sil=0.995> .PERIOD We have to do n upon 2 exchanges approximately <sil=0.946> .PERIOD So <sil=0.646> ,COMMA let us look at the problem recursively <sil=0.937> .PERIOD We had earlier solved it using loops <sil=0.961> .PERIOD Now <sil=0.448> ,COMMA the basic idea of the recursive solution to in place reversion is the following <sil=0.973> .PERIOD If n is 0 or 1 if the array is either empty or it contains exactly one element then we do not need to do anything to reverse the array <sil=0.910> .PERIOD Otherwise it contains at least two elements <sil=0.936> .PERIOD In this case exchange A 0 with A and minus 1 that will be the first layer <sil=0.920> .PERIOD Now <sil=0.332> ,COMMA call the sub problem <sil=0.902> .PERIOD We have to solve one more sub problem which is reverse on an array which is A 1 through A n minus 2 <sil=0.965> .PERIOD Notice that we had already solved the problem of swapping A 0 and A n minus 1 <sil=0.982> .PERIOD So <sil=0.592> ,COMMA earlier we had seen a program which involved linear recursion which just went left to right <sil=0.981> .PERIOD In the case of reversal of an array it is still linear recursion in the sense that there is only one call to a sub problem <sil=0.920> .PERIOD But the way in which you call the sub problem is slightly different <sil=0.925> .PERIOD Let us see with an example <sil=0.975> .PERIOD We will consider actually two examples one for an even length array and another for an odd length array <sil=0.975> .PERIOD Let us say that A is an even length array with six elements and we want to reverse it using the function reverse A 6 and we have to do it in a recursive way <sil=0.968> .PERIOD So <sil=0.585> ,COMMA what you do is first swap A 0 with A 5 and now what is the sub problem left to be solved <sil=0.955> .PERIOD We have to solve reverse of this intermediatory which starts from A 1 and contains four elements <sil=0.951> .PERIOD So <sil=0.547> ,COMMA we have to reverse the array which starts from A plus 1 and there are four elements to be reversed <sil=0.993> .PERIOD So <sil=0.382> ,COMMA in one step even though we have only a single call to a sub problem we have actually reduce the size by two <sil=0.991> .PERIOD And now you reverse or rather swap A 1 and A 4 and now the sub problem that remains is to reverse this sub array which is A plus 3 and you have two elements to reverse <sil=0.932> .PERIOD So <sil=0.393> ,COMMA you do this and at this point you have a sub array which starts at A plus 3 and has zero elements to reverse <sil=0.982> .PERIOD At this point there is nothing left <sil=0.957> .PERIOD Now for an odd length array let us take a very small array which contains three elements and we have to reverse it <sil=0.929> .PERIOD What you do is you reverse you swap B 0 with B 2 <sil=0.941> .PERIOD At this point you have a sub problem which has exactly one element and you do not need to reverse that array that array is its own reverse <sil=0.982> .PERIOD So <sil=0.599> ,COMMA the problem just stops there <sil=0.967> .PERIOD So <sil=0.360> ,COMMA notice the difference between the even length array and the odd length array in the case of an even length array the step just before the last step involved an array of size 2 and you still had to reverse that array <sil=0.996> .PERIOD In the case of an odd length array this the last step involves a single length array which is its own reverse <sil=0.941> .PERIOD So <sil=0.539> ,COMMA you do not have to do anything <sil=0.928> .PERIOD So <sil=0.597> ,COMMA there are two basic cases to worry about one is where the sub array is of size 0 and another is where the sub array is of size 1 <sil=0.936> .PERIOD Zero corresponds to even length arrays and one corresponds to odd length arrays <sil=0.985> .PERIOD Let us write this code now <sil=0.964> .PERIOD So <sil=0.408> ,COMMA we have reverse A containing n elements and we have reverse A and we have reverse return type void which means that this function is not going to return your value but it is going to do something <sil=0.910> .PERIOD So <sil=0.435> ,COMMA if n equal to 0 or n equal to 1 return because in that case A is its own reverse <sil=0.985> .PERIOD Otherwise you swap the first element with the last element that is this operation A and A plus n minus 1 <sil=0.967> .PERIOD So <sil=0.438> ,COMMA notice that swap is a function that takes two pointers to int and exchanges them <sil=0.975> .PERIOD Once you do that you call the sub problem which is reverse A plus 1 n minus 2 <sil=0.970> .PERIOD Notice that unlike the previous examples we have discussed the sub problem reduces by 2 in size even though you have only a single call the sub problem is not of size n minus 1 it is of size n minus 2 <sil=0.938> .PERIOD So <sil=0.440> ,COMMA look at the case of the odd length array and the even length array that we have seen before and you can notice that the sub problem reduces by 2 in size for every step <sil=0.937> .PERIOD Now <sil=0.423> ,COMMA what is the depth of the stack <sil=0.964> ?QUESTIONMARK You know that roughly n upon 2 calls will be done because you start at a size n the next call will be of size n minus 2 and so on until you hit either 1 or 0 <sil=0.925> .PERIOD So <sil=0.413> ,COMMA you can work out that there will be about n upon 2 steps before you reach 1 or 0 <sil=0.999> .PERIOD The accurate expression is ceiling of the function ceiling of the expression n upon 2 plus 1 <sil=0.917> .PERIOD So <sil=0.545> ,COMMA many calls will be there before you hit 1 or 0 <sil=0.966> .PERIOD So <sil=0.609> ,COMMA each function call will take let us say constant amount of space and there are about n upon 2 function calls <sil=0.952> .PERIOD So <sil=0.649> ,COMMA the stack depth is n upon 2 and therefore <sil=0.416> ,COMMA the whole space which is stack depth times the number of variables at each function that will be about n upon 2 <sil=0.923> .PERIOD So <sil=0.488> ,COMMA now let us consider a third example which is computing the size the maximum of a particular array <sil=0.944> .PERIOD For concreteness let us consider in integer array and we have to compute the following function int max array it takes two arguments one is the array itself and the second is n which is the number of elements in the array <sil=0.942> .PERIOD Again let us think about the problem recursively we have written loops to solve the problem earlier <sil=0.386> ,COMMA but now let us think about it in a recursive manner <sil=0.931> .PERIOD If the array contains 0 elements then what is the maximum <sil=0.876> ?QUESTIONMARK So <sil=0.536> ,COMMA here it may be slightly counter intuitive if you are seeing this for the first time the maximum of an empty array is some large negative value think of it as minus infinity <sil=0.993> .PERIOD Why do we do this <sil=0.972> ?QUESTIONMARK This is because let us take maximum of let us take a concrete example 1 2 3 we know that the maximum of this array is 3 <sil=0.902> .PERIOD Now what happens when you take a larger array or list of numbers <sil=0.929> .PERIOD So <sil=0.469> ,COMMA what happens if you take let us keep this unspecified as an int you know the array is a large array that if a is less than 3 then the maximum of this array is going to be 3 <sil=0.969> .PERIOD If a is greater than 3 then the maximum of this the second one is going to be greater than that <sil=0.980> .PERIOD So <sil=0.598> ,COMMA in any case whatever be the nature of a you can always say that maximum of 1 2 3 a is going to be greater than or equal to the maximum of 1 2 3 <sil=0.982> .PERIOD Now what that means is that if you take a larger set its maximum is always going to be greater than or equal to the maximum of a subset <sil=0.955> .PERIOD This is note that this is independent of a because you can analyze by cases if a is less than or equal to 3 then this maximum will be 3 itself and 3 is greater than or equal to 3 <sil=0.947> .PERIOD If a is greater than 3 then this maximum is strictly greater than the previous maximum <sil=0.978> .PERIOD So <sil=0.503> ,COMMA maximum is always monotone in the according to the subset relation <sil=0.926> .PERIOD Now this means that what will be the maximum of the empty set the empty set is a subset of every set <sil=0.925> .PERIOD So <sil=0.605> ,COMMA no matter which S I pick maximum S has to be greater than or equal to maximum of the empty set <sil=0.946> .PERIOD This means that a reasonable value for maximum of empty set is minus infinity <sil=0.932> .PERIOD So <sil=0.327> ,COMMA we set so this is a reasonable convention that is why when any of size 0 we return some really large negative value by which I mean the absolute value of the number is really big because we are trying to say that it is essentially minus infinity <sil=0.996> .PERIOD If any of size 1 then you just return a of 0 because the array contains only one element its maximum will be a 0 <sil=0.939> .PERIOD If n has size at least 2 now we are in business we have to solve the problem in terms of a sub problem <sil=0.901> .PERIOD So <sil=0.634> ,COMMA here was an example where the base case had to be really thought of but now we are at the case where we are thinking of the recursion <sil=0.988> .PERIOD So <sil=0.549> ,COMMA what is the recursive step here <sil=0.904> ?QUESTIONMARK So <sil=0.563> ,COMMA let us take a concrete array <sil=0.976> .PERIOD We have array a which contains the numbers 2 4 3 7 5 23 minus 3 and 9 some concrete array and we want to say that I want to calculate the maximum of the array a in terms of some sub problem the natural sub problem that we can think of is the sub problem of finding the maximum of this sub array which starts from a 1 and goes on until the last element <sil=0.964> .PERIOD So <sil=0.400> ,COMMA the cursive call should be something like max array a plus 1 and there are n minus and elements in it because we omit the first element <sil=0.925> .PERIOD Now <sil=0.379> ,COMMA maximum value how can we solve the whole problem in terms of the sub problem <sil=0.931> .PERIOD Suppose we know what is the maximum value in the tail a plus 1 to containing n minus 1 elements the maximum of the whole array will be the greater of the two numbers which two numbers the maximum of this sub array and a 0 <sil=0.993> .PERIOD So <sil=0.636> ,COMMA maximum value is the larger of a 0 and the maximum of the tail sub array which is a plus 1 to a plus n minus 1 <sil=0.933> .PERIOD Now <sil=0.614> ,COMMA in order to compute the sub problem we call a recursive call to the same function it looks for the max array from a plus 1 containing n minus 1 elements <sil=0.924> .PERIOD So <sil=0.632> ,COMMA in this example the maximum of the tail sub array will be 23 and let us say that a 0 is 25 <sil=0.991> .PERIOD So <sil=0.485> ,COMMA the maximum of the whole array will be the greater of the numbers 25 and 23 <sil=0.972> .PERIOD So <sil=0.545> ,COMMA in this case the maximum value will be 25 which is a 0 <sil=0.951> .PERIOD So <sil=0.496> ,COMMA now let us write this code <sil=0.917> .PERIOD So <sil=0.396> ,COMMA the recursive function is very simple and this is one of the reasons why people like to write recursive functions because the whole array is the from a recursive function it is very clear what the function is going to do <sil=0.992> .PERIOD Usually <sil=0.384> ,COMMA recursive functions are shorter than their loop versions and it is they are easier to understand when you read someone else's code <sil=0.925> .PERIOD So <sil=0.446> ,COMMA let us solve max array using a recursive function in C <sil=0.908> .PERIOD We have int max array because it is finally going to return an int value which is the greatest value in the array <sil=0.923> .PERIOD Now <sil=0.367> ,COMMA you have an int array a and n is the size of the array <sil=0.968> .PERIOD Let us say that we set some max value if n is 0 then the maximum is simply something like minus infinity <sil=0.902> .PERIOD Let us keep it at a very large number minus 9 <sil=0.546> ,COMMA 9 <sil=0.521> ,COMMA 9 <sil=0.400> ,COMMA 9 <sil=0.325> .PERIOD So <sil=0.327> ,COMMA minus 5 <sil=0.415> ,COMMA 9 some large value it does not matter and then if n minus 1 if n is equal to 1 then the array contains only one element and therefore <sil=0.546> ,COMMA it is the maximum <sil=0.975> .PERIOD So <sil=0.478> ,COMMA you just return a of 0 <sil=0.932> .PERIOD Otherwise n is at least 2 <sil=0.917> .PERIOD So <sil=0.356> ,COMMA in this case you say that the maximum value of the sub problem is max array a plus 1 n minus 1 <sil=0.902> .PERIOD So <sil=0.422> ,COMMA this is the maximum of the Taylor array <sil=0.926> .PERIOD Now <sil=0.649> ,COMMA once you have the maximum of the Taylor array the maximum of the whole array is the greater of the two numbers which is a 0 and max value <sil=0.971> .PERIOD So <sil=0.318> ,COMMA we return max of a 0 comma max value <sil=0.929> .PERIOD Now <sil=0.340> ,COMMA max is a function that is already there in the standard math library in C <sil=0.904> .PERIOD But <sil=0.417> ,COMMA if you want to write it it is not a difficult function to write <sil=0.932> .PERIOD You can take two integers and return the greater of the two integers <sil=0.994> .PERIOD Now <sil=0.420> ,COMMA we can think about is it better than the loop version of the program <sil=0.938> .PERIOD The advantage of the recursive program is that it is easier and in some sense it contains fewer number of lines than the loop program <sil=0.937> .PERIOD The more the disadvantage is that it takes up more space by executing <sil=0.996> .PERIOD So <sil=0.381> ,COMMA the questions are how much time does the function take <sil=0.467> ,COMMA how much space does the function take <sil=0.903> .PERIOD And there is also a so these are things which are concrete and can be measured <sil=0.940> .PERIOD There is also a softer question which is how easy is it for a programmer to look at this function and understand what it does <sil=0.976> .PERIOD In the second criterion it is the recursive function that is course <sil=0.983> .PERIOD In the first criterion it is often the iterative function the loop function that is course <sil=0.997> .PERIOD So <sil=0.633> ,COMMA please think about these questions and you can work through it and say that in order to solve max array of an array of size n <sil=0.991> .PERIOD Let us take an array of size 8 <sil=0.951> .PERIOD You will see that these are the recursive calls it will make a plus 1 7 a plus 2 6 so on up to a plus 7 1 <sil=0.941> .PERIOD And when you hit an array of size 1 you get to one of the base cases which is that when you have an array which contains a single element the maximum is the only element in the array <sil=0.956> .PERIOD So <sil=0.514> ,COMMA once you hit here you will start returning <sil=0.985> .PERIOD So <sil=0.589> ,COMMA the maximum depth of function calls in this will be the size of the array <sil=0.945> .PERIOD So <sil=0.403> ,COMMA you can say that stack depth is n <sil=0.989> .PERIOD Now <sil=0.575> ,COMMA recursive programs are general programs just like loop programs are general programs <sil=0.963> .PERIOD You have written loops even before you saw water array since see <sil=0.945> .PERIOD Similarly <sil=0.474> ,COMMA you can write recursive programs which deal with general data not just array data <sil=0.987> .PERIOD And in all of these questions you can ask the question you can ask the following questions how much time does the function take and how much space does the function take <sil=0.921> .PERIOD We will see an example for recursive function that will read n numbers and returns their maximum <sil=0.941> .PERIOD Before we came to know of see arrays this is the kind of loop functions that we used to write <sil=0.940> .PERIOD We would take n numbers <sil=0.971> .PERIOD So <sil=0.471> ,COMMA first you will read how many numbers to read then you will read exactly those many numbers and find their maximum using a loop <sil=0.995> .PERIOD Now <sil=0.451> ,COMMA let us try to do that using recursion we are not going to use any arrays <sil=0.941> .PERIOD So <sil=0.477> ,COMMA we have to do is write a function read max it takes n elements and the logic is the same as finding the maximum of an array <sil=0.933> .PERIOD But we will do it without using arrays how do you do this if you have zero numbers to read then you return minus infinity or some approximation some large negative value <sil=0.954> .PERIOD Otherwise you read the first number if n is equal to 1 that is we had to read only one number then you just say that x is the maximum <sil=0.960> .PERIOD Otherwise n is greater than or equal to 2 and we have read one number <sil=0.928> .PERIOD So <sil=0.346> ,COMMA you say that return the maximum of the two values which is x and what goes inside inside you have to solve a sub problem which is the sub problem of reading n minus 1 numbers and returning their maximum <sil=0.982> .PERIOD Go back and compare the program with finding the array maximum and the recursion works exactly in the same way <sil=0.987> .PERIOD So <sil=0.340> ,COMMA we will read n minus 1 numbers and return the maximum of those and then you compare maximum of the first number and the maximum of the sub problem <sil=0.972> .PERIOD This is exactly as before except that we did not use any arrays and how do you call this function just declare a main function with n you scan of how many numbers to read and call the function read max n <sil=0.961> .PERIOD Finally <sil=0.345> ,COMMA it will return the maximum of the n numbers rate and you just print that value <sil=0.930> .PERIOD So <sil=0.603> ,COMMA think about this for a minute and see why we did not need to use arrays <sil=0.915> .PERIOD Now <sil=0.454> ,COMMA there are other functions which are typically written in a recursive manner <sil=0.958> .PERIOD We just saw that you can use recursion with arrays we saw problems where you do do not need to use arrays but you can still write a recursive routine <sil=0.985> .PERIOD Now <sil=0.359> ,COMMA we will come to arithmetic functions and many arithmetic functions are often recursively defined <sil=0.913> .PERIOD For example <sil=0.328> ,COMMA let us take the GCD function Euclid's algorithm and you can write the GCD function as follows <sil=0.950> .PERIOD You first ensure that is greater than or equal to B using the swap function and then you just call GCD of a comma B and GCD of a comma B is defined recursively as follows <sil=0.961> .PERIOD If B is 0 then GCD of a comma B is A <sil=0.920> .PERIOD If B is non-zero then you just return GCD of B comma A modulo B <sil=0.916> .PERIOD So <sil=0.633> ,COMMA this is how you write the recursive GCD routine and I will make the claim that this routine is cleaner than the iterative routine <sil=0.935> .PERIOD In the iterative routine remember we had to use an intermediate variable which will store the value of let us say A and then did the careful 3 way exchange in order to accomplish B comma A modulo B <sil=0.953> .PERIOD Here the code is very simple if B is 0 then we know that GCD of A comma B is A <sil=0.964> .PERIOD If B is non-zero then we know that GCD of A comma B is GCD of B comma A modulo B <sil=0.978> .PERIOD So <sil=0.426> ,COMMA it is a very concise way of writing the function <sil=0.918> .PERIOD Now <sil=0.474> ,COMMA which you can ask the question which is better is that the recursive formulation of the iterative formulation logic is the same <sil=0.963> .PERIOD So <sil=0.417> ,COMMA it will take the same number of steps <sil=0.970> .PERIOD So <sil=0.343> ,COMMA the time taken will roughly be the same and we have also made the claim that the recursive version is easier to understand <sil=0.908> .PERIOD The disadvantage may be the following that the recursive function may use a very deep stack <sil=0.921> .PERIOD So <sil=0.491> ,COMMA you can ask a question like how deep will be the stack in the case of the recursive program <sil=0.996> .PERIOD So <sil=0.449> ,COMMA in the following video we will talk about more general kinds of recursion <sil=0.971> .PERIOD In this video and the previous video we have seen recursive problems which can be solved by one call to a sub problem and we will see more general kinds of recursion <sil=0.999> .PERIOD So <sil=0.508> ,COMMA we are looking at a sample C program and as we had discussed in the last lecture <sil=0.561> ,COMMA we have a structure as is shown here <sil=0.925> .PERIOD You can see that there is a main function here <sil=0.393> ,COMMA a main function is there and that main function is covered by two parenthesis <sil=0.973> .PERIOD Now <sil=0.323> ,COMMA we can see that we start with a header file that includes STD I O dot H and STD I O dot H stands for standard I O <sil=0.989> .PERIOD That means <sil=0.529> ,COMMA whenever we will get some instructions to carry out input or output that will be in reference to or with respect to the standard input that is a keyboard that means <sil=0.485> ,COMMA the data will be taken from the keyboard and if anything is to be printed <sil=0.515> ,COMMA it will be printed on the screen <sil=0.986> .PERIOD So <sil=0.634> ,COMMA that we that is a default thing for any C program <sil=0.607> ,COMMA we have to put in STD I O dot H include hash include this is known as this red hash include STD I O dot H unless you want to take the file <sil=0.523> ,COMMA do not want to take it from the keyboard or do not want to print on the screen <sil=0.912> .PERIOD Next thing is that the main function which as I said in the last class that there must be a main function and the main function will have a place for the parameters you can see here for the parameters here which may or may not be empty <sil=0.993> .PERIOD The third point is the structure the overall boundary of the main function or for that matter for any function there should be a boundary specified and that boundary specified with by these two curly brackets <sil=0.993> .PERIOD Next we come to the statement as I had said that just like any other language C also has got some words which are understood by any by the compiler <sil=0.979> .PERIOD PrintF is one such word which is a statement for printing the sentence that is given within these double codes <sil=0.965> .PERIOD You can see the double codes here and so what will it print <sil=0.908> ?QUESTIONMARK It will print our first look at the C program here as is shown here that will be printed <sil=0.932> .PERIOD PrintF within code here there is a code end code and here is a start code our first look at the C program <sil=0.942> .PERIOD In addition there is I am sorry let me go up <sil=0.921> .PERIOD We can see two special symbols which are these backslash ends <sil=0.963> .PERIOD Let me just clear it up <sil=0.949> .PERIOD Here you can see this backslash end something of this sort <sil=0.930> .PERIOD This means go to a new line or end of line <sil=0.915> .PERIOD Now suppose let us see suppose I had something like this I had printed something all right I had printed something there is a screen I had printed a brown fox <sil=0.902> .PERIOD Now after I printed that means the computer printed you can see where the my pen is my pen is lying here right my pen is here <sil=0.921> .PERIOD Now if I say backslash end this is this is no red as backslash backslash end that means my pen will come to the beginning of the new line and here I will write our first C program and by default my pen is here but since I have given another backslash end the pen will come here <sil=0.961> .PERIOD So next time if I again start with the backslash end it will come to the new line and if I do not give a backslash end it will continue from here <sil=0.915> .PERIOD You will understand this more when we look at more number of programs it will be much more clear to you <sil=0.983> .PERIOD So this is a structure of a very simple C program we will see more of this <sil=0.994> .PERIOD Now here is another program again now it is easier to understand you have got an include STDIO <sil=0.955> .PERIOD H which has to be there for any C program there will be a main function as is being shown here and there are parenthesis between these two the program should be written this is the boundary of the main function <sil=0.975> .PERIOD Now here there are some more new things which are being shown to you in the form of example <sil=0.920> .PERIOD So you see the first line is INT A B C what is meant by that is that I am I will be using in this program three variables A B and C and each of them is of type integer <sil=0.923> .PERIOD Now you are already acquainted with the term variables but you are probably not acquainted with the term type of a variable <sil=0.956> .PERIOD So quickly let us go to that we have got variables variables variables and the variables can be of different type also constants can be of different type <sil=0.910> .PERIOD For example the variables can be of type integer for example 7 17 all these things 256 1099 all these are integers another type of variable can be real numbers which are say 10 <sil=0.940> .PERIOD 5 6 <sil=0.978> .PERIOD 325 fractional numbers right these are real this is also known as in C as floating point numbers now integers of these reals or floating point numbers of these similarly I can have characters like say x y p whatever these are different characters or maybe and is a character <sil=0.952> .PERIOD So each of any of these alpha numerics and all those can be characters now <sil=0.965> .PERIOD So we know what is an integer what is a real what is a floating point what is a floating point what is a character now a variable is of type integer what does it mean as you know a variable is nothing but a memory location right it means and suppose this variable I say variable A is of type integer <sil=0.951> .PERIOD So there is a memory location corresponding to A and this memory location can only hold values which are integers <sil=0.996> .PERIOD So 57 I can store here but if I try to store 57 <sil=0.970> .PERIOD 5 here it will not store 57 <sil=0.909> .PERIOD 5 because it has been told to be an integer <sil=0.977> .PERIOD Similarly if I say variable B is of type floating point I am in short I am writing float that means this variable B can store a floating point number so 57 <sil=0.934> .PERIOD 5 can be stored here even if I try to store in B 57 in B if I store 57 just 57 then that will be stored as 57 <sil=0.969> .PERIOD 0 all right <sil=0.909> .PERIOD Similarly there can be types of characters now depending on the type of the variable the compiler assigns different sizes of memory for the different variables for example in standard C compilers and it is a convention that for an integer two memory locations are allocated <sil=0.961> .PERIOD Now how big this will be say sometimes it it my each of these memory locations can be 16 bits in that case I am using two 16 bits that means 32 bits to store an integer whereas for a real number now this is a convention for locations are used for storing a real number all right <sil=0.924> .PERIOD So 64 bits 16 16 16 16 so that will be for real numbers okay <sil=0.981> .PERIOD Now so depending on what I write what how I define the type of the variable when I say A B C I also say what type of variabilities is it an integer is it a real or what it is <sil=0.954> .PERIOD Now if you come here we will see that here I have written float and I did not write floating point number <sil=0.978> .PERIOD Now in C in order to specify variable to be real we declare that to be float say P Q that means semicolon that means P and Q are two variables which are of type floating point number right and if I write int A B C that means A B and C are three variables which are of type floating integer type int <sil=0.954> .PERIOD So we do not write integer we just write in C int okay <sil=0.914> .PERIOD Now obviously then for P how many bytes how many depending on how many bits will be given how many memory locations will be given for P may be 4 Q it will be 4 but for A B C it will be only 2 all right <sil=0.957> .PERIOD Now let us therefore go back to the program here here we find int A B C now this statement this is called a type declaration all right <sil=0.934> .PERIOD This is known as a type declaration okay this is the first statement <sil=0.964> .PERIOD So I have declared the variables now in C program before a variable is used it should be declared about its type okay <sil=0.972> .PERIOD The other thing is you can see this <sil=0.999> .PERIOD So here you can see A has been assigned 10 B has been assigned 20 that means what that means in the memory location A corresponding to A memory location corresponding to A 10 has been written and to the memory location corresponding to B 20 has been written all right and this statement C assigned A plus B I had explained in another lecture that that means this data this value 10 and this value 20 will be taken out on the left hand side from the corresponding memory locations they will be added and the result will be 30 all right the result will be 30 and the 30 will be written into the location C <sil=0.995> .PERIOD So this will be 30 okay this much is clear now what about this line I know that a print of statement just tells me that I have to print whatever is there in the code <sil=0.932> .PERIOD So how will the print look like please note the sum of percentage D and percentage D is percentage D this is equivalent to writing this the sum of dash and dash is dash there are three gaps one here one here and one here now how will these gaps be filled filled they will be filled by the values of A B and C respectively each of these dashes will be filled up by the respective values of A B C <sil=0.983> .PERIOD Now this percentage D is a format statement it is saying that this gap can be filled by a digit or by an integer this gap can be filled only with an integer <sil=0.966> .PERIOD Now here I A is an integer therefore this gap will be filled with the integer value 10 and percentage D and is being printed as it is because it is within this double code and dash this dash will be filled with another digit this will be filled with another digit and what is that digit the second space B and B is 20 so it will be 20 is what is A plus B is C and what is the value of C the value of C is 30 so this is what will be printed alright <sil=0.935> .PERIOD So this is how we print a sentence where I want I have got some places for different variables and these places will be filled up by the values of the variables whose names are being specified here <sil=0.956> .PERIOD I repeat these gaps will be filled by the values of the variables whose names or whose identifiers are being specified here and the type of this variable and the specification of this dash should match <sil=0.993> .PERIOD So now so it will be printed some of 10 and 20 is 30 now coming to the third sample program <sil=0.935> .PERIOD Now this is a little more complicated and this is trying to find out the largest of three numbers that means what we had done in a flow chart exercise finding the max of three numbers <sil=0.946> .PERIOD Now that was discussed using flow charts and pseudo code and here we are discussing that using a program a C program how is that idea translated into C program again let us start with again even before that I would like to point out something again let us revise the structure of the program we start with a we start with a header stdi <sil=0.903> .PERIOD h now we start we put in a comment what is this we saw in the last class it is a comment this comment is just telling us the compiler has got nothing to do with it is just telling us that this program finds the largest of three numbers then as usual we have got a main function which must be there and there should be a parenthesis which is delineating the boundary of this program <sil=0.907> .PERIOD Now the and also we have seen this I am using three variables A B and C and I have put in the type of that the next new thing that is coming up is here scan F this is an input statement for reading three variables from the keyboard <sil=0.956> .PERIOD Now recall that I said that for every language there are there is a vocabulary there is a set of words that the language understands <sil=0.904> .PERIOD So in C in an earlier one we have seen in an earlier program we have seen the statement print F right we had seen the program print F <sil=0.915> .PERIOD So print F is a particular word now we now encounter another word int is also another word int is another word which is specific to C and the meaning of this every word we will have a meaning <sil=0.914> .PERIOD So this means that whatever follows are variable names of type integer whatever follows this word int are variable names of type integer okay <sil=0.955> .PERIOD Next new word that we are getting is scan F just like we had seen print F earlier alright print F is a word that tells us that something is being printed here scan F is an is a word that tells that whatever is inside this parenthesis inside this parenthesis is a input statement <sil=0.903> .PERIOD Now let us study this a little bit here <sil=0.996> .PERIOD Here again you will see that there is a percentage D percentage D percentage D percentage D is within quote and you know that percentage D means it is a specified for an integer some integer is being will be read scan F means say assume it is reading <sil=0.971> .PERIOD So therefore it is something like this I am going I am creating as if fee places because corresponding to each percentage D percentage D percentage D percentage D within the quote I am creating fee spaces and followed by that let us go back to this I am sorry here there should be no comma alright I am just giving 3 percentage D's <sil=0.979> .PERIOD So let me go back here so it should be within the quote here is scan F within quote percentage D blank percentage D blank percentage D and the quote is closed comma that means as if just to understand I am creating fee spaces each of which are ready to accept an integer and where will those be stored here I am writing and a and B and C <sil=0.924> .PERIOD Now here I will request you to just forget about this amperesand sign forget about this for the time being this will explain a little later just assume that A B and C but before that for any read statement we will have to put an amperesand before the variable names there is a reason for that <sil=0.926> .PERIOD What is the meaning of this sentence the meaning of this sentence is that there are 3 places which are ready to hold 3 variables which will come to the locations A B C <sil=0.993> .PERIOD When I am reading as if I am reading from the user 3 variables A B C <sil=0.980> .PERIOD Now why I put that amperesand will explain a little later <sil=0.992> .PERIOD So 3 spaces have been created and what are these spaces these spaces are nothing but these 3 memory locations which 3 memory locations whose names have been specified here <sil=0.911> .PERIOD So this is something that you have to be a little careful and practice a little bit it will be very easy later on <sil=0.904> .PERIOD So within the quote I specify the format <sil=0.512> ,COMMA specify that is integer in this case percentage D and these are the variable names <sil=0.997> .PERIOD Now let us go back through that anything that is new here <sil=0.962> .PERIOD Now a new word we are encountering here if is a conditional statement you need not bother about it if you recall we had in the flow chart we had a thing called diamond where we are taking some decisions based on some conditions yes and no <sil=0.942> .PERIOD We are doing that here we are looking at some condition here if A is greater than B and A is also greater than C if that is yes then I am printing that A is the largest number try to apply simple logic here if is a conditional word condition is a conditional word and this entire statement starting from if to this semicolon is one statement and where I check the condition whether A is greater than B and A is greater than C if that is so that is if the diamond comes out with that yes then I am printing that the largest number is A otherwise that means if the answer to this is no otherwise I am again checking again if again I am checking another condition I am checking another condition here what do I what am I checking is B greater than C yes if yes then I am printing the largest number is B otherwise this yes otherwise if it is no then I am printing the largest number is C <sil=0.942> .PERIOD So we are encountering some new words if and else if means in if in the diamond result of this diamond box is yes then this statement will be executed otherwise that means if the answer to this diamond box is no then this part will be executed this part will be executed <sil=0.912> .PERIOD Now here again the second block I am checking if B is greater than C again if this is true for this condition this will be executed when this condition is true or yes if it is false then this statement will be executed <sil=0.925> .PERIOD So it is a little more complicated program but a very useful example all right <sil=0.918> .PERIOD So we see the comments we have already mentioned now we are coming to another program <sil=0.924> .PERIOD This is using what we earlier had said that a big machine can be divide into sub machines <sil=0.911> .PERIOD So a big program of this one is not a big program but any program can be broken down into different functions here is the main function this one is main let me draw it a little nicely <sil=0.976> .PERIOD Here we have got a main function and inside there is another function whose name is my function <sil=0.914> .PERIOD Now let us look at this <sil=0.920> .PERIOD Now first here there is another new thing we are introducing and that you should understand that is define pi to be defined pi to be 3 <sil=0.992> .PERIOD 1415926 that means this wherever in this program this pi will appear there we will replace it with this value 3 <sil=0.921> .PERIOD 1415926 but inside the program I will not write pi I am just defining it once for all and this means I am replacing pi by this value before the compilation is done <sil=0.921> .PERIOD So this is again a pre-processors statement we will continue with this example in the next lecture <sil=0.915> .PERIOD We have looked at pointers and structures in detail and we have also seen how structures can also utilize pointers or in other words our pointers can be used in conjunction with structures <sil=0.985> .PERIOD Now <sil=0.385> ,COMMA we look at another very interesting use of pointers <sil=0.342> ,COMMA but in general let me say that it is a very fundamental concept from the memory allocation point of view <sil=0.563> ,COMMA dynamic memory allocation is what we will be discussing now <sil=0.927> .PERIOD Now <sil=0.356> ,COMMA what is when we say that is dynamic memory allocation then obviously there must be something called the static memory allocation <sil=0.985> .PERIOD Now <sil=0.601> ,COMMA what is static memory allocation <sil=0.878> ?QUESTIONMARK When we declare an array say int a20 you know that the compiler will allocate 20 locations <sil=0.530> ,COMMA 20 locations locations to house 20 integers to you and that will be named as A or you can also consider that there is a pointer A which is pointing to the first element of the array <sil=0.647> ,COMMA but you have got space for 20 locations <sil=0.476> ,COMMA 20 integers allocated to you <sil=0.952> .PERIOD So <sil=0.305> ,COMMA now you know size of so how many bytes will be required <sil=0.874> ?QUESTIONMARK You can say 20 times size of int so size of int will return you how many bytes your particular system allocates for an integer and 20 such allocations <sil=0.974> .PERIOD So <sil=0.383> ,COMMA so many bytes will be allocated to you <sil=0.947> .PERIOD Now <sil=0.517> ,COMMA when that is statically allocated that is allocated at compile time <sil=0.974> .PERIOD So <sil=0.633> ,COMMA when we say static allocation that means allocation at compile time right <sil=0.935> .PERIOD Now <sil=0.574> ,COMMA if for some reason you need more than 20 integers to be stored in this array A that you will need to redefine this whole thing or in some cases we do not know we do not have an idea of what will be the how many data items will come <sil=0.951> .PERIOD For example <sil=0.600> ,COMMA you are actually storing student data student records in an array class and you do not know how many students will join that class beforehand <sil=0.960> .PERIOD If you have if you know that beforehand it is fine or if you have an idea that what is the maximum amount maximum number of students that can come then it is fine you can allocate it in the form of static allocation as we do in an array <sil=0.960> .PERIOD However <sil=0.316> ,COMMA when we do not know and the information comes at run time that means <sil=0.377> ,COMMA when is being executed that will lead to what we call dynamic allocation of memory that is dynamic allocation <sil=0.907> .PERIOD So <sil=0.343> ,COMMA let us look at how we can handle it <sil=0.920> .PERIOD So <sil=0.333> ,COMMA the basic idea is I have already explained that the amount of data we cannot predict beforehand <sil=0.952> .PERIOD So <sil=0.559> ,COMMA we will use effective use dynamic memory management memory allocation technique to do that <sil=0.985> .PERIOD Now <sil=0.505> ,COMMA C language requires the number of elements to be specified in compile time when we define in an array we need to specify that in compile time <sil=0.967> .PERIOD Now <sil=0.492> ,COMMA often that leads to wastage of memory or program failure <sil=0.921> .PERIOD Why program failure program failure because if we exceed the amount of space that has been allocated there will be a failure the program will give an error or it will exit abnormally <sil=0.999> .PERIOD However <sil=0.507> ,COMMA if we take recourse to dynamic memory allocation we can solve this problem <sil=0.923> .PERIOD How memory space required can be specified at the time of execution how can we do that how can we specify the amount of memory required at the time of execution <sil=0.927> .PERIOD If while running the program just like the instructions and operators if we had some special means some special command some special operator by which we can grab memory <sil=0.996> .PERIOD Now <sil=0.312> ,COMMA here you should understand that who allocates memory to us it is the operating system who allocates the memory to us <sil=0.972> .PERIOD So <sil=0.422> ,COMMA this like the printf scanf all those things are system calls we are calling the we are making calls to the operating system which is doing the required thing for us <sil=0.905> .PERIOD Similarly <sil=0.627> ,COMMA there is a function called call of memory allocator malloc using which we can grab memory from the operating system <sil=0.919> .PERIOD How let us look at this say in memory in C I have got different types of variables I that is not so much relevant right now <sil=0.928> .PERIOD What is needed is part this global variables and instructions are there always stored <sil=0.477> ,COMMA but the local variables are kept the local variables are there and there is some free memory we can take from this free memory and put it use them as our local variables <sil=0.965> .PERIOD Will free region has got a name here <sil=0.998> .PERIOD Now <sil=0.539> ,COMMA the most important thing is that we need some functions which will give the memory gave my program some memory addresses or memory blocks from the operating system storage of memory which is known as if from there it will come be allocated to my program all right <sil=0.916> .PERIOD So <sil=0.478> ,COMMA for that we have got four different functions one is malloc <sil=0.913> .PERIOD What does malloc do <sil=0.945> ?QUESTIONMARK Malloc allocates the requested number of bytes and returns a pointer to the first byte of the allocated space <sil=0.995> .PERIOD So <sil=0.562> ,COMMA what it does is something like this <sil=0.962> .PERIOD We can break code of the <sil=0.437> ,COMMA we can break code of the <sil=0.464> ,COMMA could I mean <sil=0.959> .PERIOD Malloc allocates a requested number of bytes and returns a pointer to the first byte of the allocated space <sil=0.905> .PERIOD So <sil=0.612> ,COMMA let us try to explain this <sil=0.956> .PERIOD So <sil=0.629> ,COMMA when I do malloc malloc is just like a function will return me some memory bytes all right some memory bytes <sil=0.905> .PERIOD How many memory bytes <sil=0.953> ?QUESTIONMARK Will depend on what I am <sil=0.481> ,COMMA what I am requesting for it is a requested number of bytes <sil=0.920> .PERIOD So <sil=0.512> ,COMMA malloc will have some parameters which we will show later <sil=0.902> .PERIOD So <sil=0.331> ,COMMA it will give some <sil=0.622> ,COMMA give me some amount of memory and how do I know <sil=0.913> .PERIOD Now <sil=0.467> ,COMMA the operating system has got some free memory spread here and there <sil=0.965> .PERIOD So <sil=0.302> ,COMMA from there it is giving me some piece of memory <sil=0.974> .PERIOD But how do I know where is that piece of memory <sil=0.883> ?QUESTIONMARK For that it is returning me a pointer say pointer p which is telling me that ok <sil=0.902> .PERIOD Then if you follow this pointer you will get this piece of memory location all right <sil=0.961> .PERIOD So <sil=0.431> ,COMMA let us proceed a little bit <sil=0.930> .PERIOD Now <sil=0.542> ,COMMA similarly now when this is given that memory block is given in response to malloc request the actual memory is not initialized to some value <sil=0.949> .PERIOD It can have any garbage value <sil=0.948> .PERIOD But if I apply caloc C aloc then it allocates space for the area of elements <sil=0.599> ,COMMA area of elements and initializes them to 0 and returns a pointer <sil=0.916> .PERIOD So <sil=0.544> ,COMMA in this case if I want to have a chunk of memory where everything has been initialized to 0 then I should use caloc <sil=0.913> .PERIOD On the other hand this free what it does the free function call will return this amount of memory that was given to me in request to malloc it will be returned back to the heap return back to the operating system <sil=0.944> .PERIOD So <sil=0.382> ,COMMA that it can be utilized by somebody else in future all right <sil=0.997> .PERIOD So <sil=0.586> ,COMMA and realoc modifies the size of the previously allocated space <sil=0.932> .PERIOD So <sil=0.602> ,COMMA I have got some allocation and then I think that allocation is not enough I want to change it I can use realoc <sil=0.973> .PERIOD However <sil=0.483> ,COMMA will be mostly concerned with malloc and free in our discussion <sil=0.932> .PERIOD So <sil=0.484> ,COMMA a block of memory can be allocated using the function malloc and it reserves a block of memory and returns a pointer of type void <sil=0.963> .PERIOD You know every pointer has got some type but in this case when malloc returns some memory block the pointer that it is returned is of type void but then we have to do something what do we need to do <sil=0.953> .PERIOD I know why I needed this memory I need so accordingly I left to do that type casting all right <sil=0.933> .PERIOD So <sil=0.560> ,COMMA now the return once it returns me of type void but that return pointer can be assigned to any pointer type <sil=0.940> .PERIOD So <sil=0.544> ,COMMA here you see <sil=0.958> .PERIOD So <sil=0.325> ,COMMA here please note malloc has got a parameter byte size how much memory I want how many bytes I want <sil=0.927> .PERIOD Now <sil=0.356> ,COMMA this malloc has returned me up to this it has returned me a pointer and pointer is of type void but I type suppose if this amount of memory I want for the purpose of storing integer array then this type will be int star that means I am casting this what is malloc returning <sil=0.928> .PERIOD Malloc is returning a pointer some pointer but that pointer was of type void of type void <sil=0.996> .PERIOD Now <sil=0.306> ,COMMA when I am type casting it to int star then this void is no longer it is of type is becoming of type int and then I am assigning it to another variable PTR <sil=0.981> .PERIOD So <sil=0.321> ,COMMA think of two things first of all you have to decide on how many bytes you want accordingly you do malloc and then what type of data you want to store there <sil=0.921> .PERIOD So <sil=0.562> ,COMMA accordingly you do this type casting like int star float star <sil=0.571> ,COMMA cad star whatever you do and then you assign it to a particular pointer <sil=0.989> .PERIOD Let us see how it will work <sil=0.916> .PERIOD So <sil=0.540> ,COMMA let us look an example here how do I know how many bytes I need suppose I need to store an element an array of 100 integers <sil=0.992> .PERIOD So <sil=0.450> ,COMMA what I do here is I ask for malloc 100 times size of int size of int if it is 4 if int is 4 then I am getting 400 bytes <sil=0.926> .PERIOD Now <sil=0.326> ,COMMA these 400 bytes that have been given to me is being pointed by some pointer of type void <sil=0.968> .PERIOD So <sil=0.584> ,COMMA next I make it in star and put it to P <sil=0.991> .PERIOD So <sil=0.469> ,COMMA P is now an integer pointer that is pointing to this entire block of 400 integers <sil=0.964> .PERIOD So <sil=0.512> ,COMMA a memory space equivalent to 100 times the size we have got <sil=0.902> .PERIOD So <sil=0.390> ,COMMA here 400 bytes of space and P is a pointer pointing to the beginning of this <sil=0.964> .PERIOD So <sil=0.541> ,COMMA I have sorry I have got this just using malloc it was not declared beforehand <sil=0.937> .PERIOD Now <sil=0.384> ,COMMA so this 100 can also be a variable n if I read a particular variable n <sil=0.916> .PERIOD Now <sil=0.416> ,COMMA how many students are there scan F and n <sil=0.918> .PERIOD So <sil=0.350> ,COMMA I read the number of students then I can multiply that with n as well <sil=0.966> .PERIOD Next you see here I am initializing to I am seeking memory for 20 characters I do malloc 20 because I know a character takes 1 byte and then the pointer is of type void I am type casting it to type character <sil=0.414> ,COMMA character star and assigning it to Cptr <sil=0.996> .PERIOD Now <sil=0.601> ,COMMA it is actually wrong it is allocating 20 bytes of space for the pointer <sil=0.930> .PERIOD So <sil=0.453> ,COMMA structure start now for example <sil=0.477> ,COMMA I now need so integer character was simple <sil=0.917> .PERIOD Now <sil=0.472> ,COMMA I want to have for space for the entire structure students <sil=0.901> .PERIOD Now <sil=0.304> ,COMMA that size is larger <sil=0.961> .PERIOD So <sil=0.479> ,COMMA I do not know <sil=0.952> .PERIOD So <sil=0.518> ,COMMA I just employ this function size of structured <sil=0.949> .PERIOD So <sil=0.551> ,COMMA I get how many bytes it requires say 40 bytes and say tens as for tens as students or n such students I multiply with that I get so much memory <sil=0.970> .PERIOD Now <sil=0.329> ,COMMA I have to type cos that to struct start star and that goes to a as a structure pointer <sil=0.975> .PERIOD Now <sil=0.329> ,COMMA malloc always allocates a block of contiguous bytes <sil=0.996> .PERIOD Now <sil=0.645> ,COMMA it may be that sufficient suppose you are asking for 100 bytes and 100 bytes are not available then malloc will not be able to allocate you the space in that case malloc will return n null that is a null pointer <sil=0.973> .PERIOD That is a special character special value it will return that shows that I could not allocate a space <sil=0.905> .PERIOD So <sil=0.442> ,COMMA I could not allocate to you a valid pointer <sil=0.980> .PERIOD So <sil=0.362> ,COMMA it is a null pointer meaning thereby that I could not I failed in allocating you memory <sil=0.989> .PERIOD So <sil=0.544> ,COMMA here is an example here you can see let us look at from one side I n float is a point height is a pointer of type float some is 0 an average <sil=0.947> .PERIOD So <sil=0.599> ,COMMA what I am trying to do probably I am trying to find the average height of the class <sil=0.993> .PERIOD So <sil=0.515> ,COMMA input the number of students and I am reading amperes and so this one is amperes and n <sil=0.931> .PERIOD So <sil=0.478> ,COMMA this is n number of students <sil=0.940> .PERIOD Now <sil=0.390> ,COMMA see I did not know how many students are there <sil=0.990> .PERIOD So <sil=0.462> ,COMMA I am getting this number of students here I am getting n number of students here <sil=0.920> .PERIOD Now <sil=0.602> ,COMMA I want to have so many spaces for the height <sil=0.986> .PERIOD So <sil=0.616> ,COMMA what I am doing I am allocating n number of spaces n is a variable here and some size of float whatever size of float is 4 bytes <sil=0.986> .PERIOD So <sil=0.302> ,COMMA n times 4 bytes so much space is being allocated and the pointer is height height is a pointer of type float <sil=0.939> .PERIOD So <sil=0.548> ,COMMA this pointer is being type casted to float <sil=0.967> .PERIOD Then I get the inputs can if in a loop I am getting the inputs can if in a loop I am getting the heights one after another in an array and I am finding the sum of the heights finding the average of the heights where I am dividing sum which is a floating point number with float n here is another example of type casting <sil=0.945> .PERIOD So <sil=0.470> ,COMMA you see I am dividing by n <sil=0.603> ,COMMA but this is a floating point real number n was an integer <sil=0.983> .PERIOD So <sil=0.438> ,COMMA I convert it to float and convert it divided <sil=0.984> .PERIOD So <sil=0.382> ,COMMA this is how maloch works now <sil=0.944> .PERIOD So <sil=0.590> ,COMMA we have explained that <sil=0.909> .PERIOD So <sil=0.372> ,COMMA now how do we we are allocating space <sil=0.961> ?QUESTIONMARK Similarly <sil=0.306> ,COMMA the general format for freeing space is using by using the free function <sil=0.959> .PERIOD So <sil=0.344> ,COMMA general for now suppose I have got a space allocated to me some space is allocated to me and that space the only handle to that space is to the pointer p <sil=0.928> .PERIOD So <sil=0.465> ,COMMA I free that pointer I free p <sil=0.903> .PERIOD So <sil=0.439> ,COMMA that pointer is free that means <sil=0.509> ,COMMA this pointer is free means this location this amount of memory goes back to the storage of the operating system and that is the heap <sil=0.912> .PERIOD So <sil=0.440> ,COMMA we whatever we got in maloch so that gives us some idea about how we can get space and reallocate space <sil=0.982> .PERIOD Now <sil=0.311> ,COMMA briefly we will be talking for the next 5 or 10 minutes on file handling there is not much to understand about file handling this you will learn as you do <sil=0.981> .PERIOD Now <sil=0.401> ,COMMA what is a file that is something you have to understand file is something where wherever I want to write something write or read from <sil=0.918> .PERIOD So <sil=0.510> ,COMMA I want to store something I I will take a particular file all right I will take a particular file and I will open that file and then I will write into that file then close that file and then whenever I need in that way I may have 10 files <sil=0.937> .PERIOD Now <sil=0.422> ,COMMA at a particular point of time I want to read a particular thing <sil=0.980> .PERIOD So <sil=0.549> ,COMMA I choose the particular file what do I do next open the file and read the file <sil=0.991> .PERIOD Now <sil=0.586> ,COMMA some files may be allowed to be read by others some files can only be written into and not read from some files can have the option of read or write both <sil=0.937> .PERIOD So <sil=0.394> ,COMMA file is some space where I will be writing or reading from some storage <sil=0.939> .PERIOD So <sil=0.439> ,COMMA this is there in the secondary memory and what till now whatever variables we are talking about those were all in the primary memory <sil=0.941> .PERIOD So <sil=0.426> ,COMMA if I store it in a file it goes into the secondary memory <sil=0.965> .PERIOD So <sil=0.406> ,COMMA let us have a little idea of how files are handled <sil=0.948> .PERIOD So <sil=0.624> ,COMMA now again now we have learnt pointers <sil=0.904> .PERIOD So <sil=0.466> ,COMMA any file can be accessed using a pointer just as if I have the file of income tax <sil=0.955> .PERIOD So <sil=0.515> ,COMMA I will have a pointer that there is the file of income tax here there is some file of road tax it will be here some file of your salary it will be somewhere here some file of your expenses it will be somewhere else <sil=0.969> .PERIOD So <sil=0.494> ,COMMA there will be pointers <sil=0.985> .PERIOD So <sil=0.523> ,COMMA we use in C the sorry we use file star we use file star and we will use the file star to represent pointer to a file and if open is the command for opening a file if a file cannot be opened then it will return a null just as in the case of malloc we saw if nothing could be returned it was returning a null <sil=0.947> .PERIOD So <sil=0.388> ,COMMA here for example <sil=0.327> ,COMMA you see F p tr is a pointer of type file that means F p tr will be pointing to file <sil=0.903> .PERIOD Now <sil=0.490> ,COMMA I have got a character file name is an array file 2 dot that it is a data file <sil=0.973> .PERIOD So <sil=0.450> ,COMMA F p tr is F open file name and here when I do F open I give the file name as well as the mode in which it can be opened the mode in which it can be opened and this w means it is in the right mode <sil=0.990> .PERIOD So <sil=0.490> ,COMMA what have I done here I have called F open <sil=0.943> .PERIOD So <sil=0.359> ,COMMA I am trying to open the file if the F so this F open will return a file pointer now if this file pointer is null that means <sil=0.562> ,COMMA there was some error in file creation otherwise it will go on doing something <sil=0.919> .PERIOD So <sil=0.328> ,COMMA quickly let us look at this when I do F open it will open a file and you will open it in a particular mode read or write whatever I specify and it will return me a pointer if a file is created successfully it will return me a non null pointer <sil=0.933> .PERIOD The second argument of F open is the mode and there are three modes where a three modes are is the file is open for reading w means it creates a file for writing and writes writes over all the previous content <sil=0.967> .PERIOD So <sil=0.315> ,COMMA if I open it in the write mode whatever content was in that file is erased and a opens a file for appending that means <sil=0.531> ,COMMA whatever is there after that it will be added <sil=0.924> .PERIOD So <sil=0.302> ,COMMA if you have got something already stored and you do not want to destroy that and you want to add something mode to that you will open it in the form in the mode a and R b reads a binary file robots we did not bother about that and there is a function called exit which you have seen that exit for sometimes in the emergency we can put exit minus 1 that means <sil=0.572> ,COMMA it tells that I have exited in the function without success <sil=0.979> .PERIOD Now <sil=0.565> ,COMMA here you see use of exit file F pointer character file name is an added file to that I try to do something so <sil=0.376> ,COMMA the file pointer was null <sil=0.995> .PERIOD So <sil=0.425> ,COMMA if it be null then what can I do I will have to exit because of some reason the file could not be created <sil=0.992> .PERIOD So <sil=0.465> ,COMMA that apart so <sil=0.606> ,COMMA F open we have seen F print is a very important command F print works just like print F and F print F except that the first argument is a file pointer <sil=1.000> .PERIOD So <sil=0.392> ,COMMA we will see how it works <sil=0.931> .PERIOD So <sil=0.434> ,COMMA F PTR is again the file pointer and I have opened the file file dot that in the write mode <sil=0.902> .PERIOD Now <sil=0.561> ,COMMA F print F means now I am printing where am I printing a file called file dot that has been opened the name of the file is file dot that and how do I identify it I identify with the F PTR the file pointer <sil=0.903> .PERIOD So <sil=0.580> ,COMMA I am writing it is open in the write mode so <sil=0.506> ,COMMA everything whatever was there has been erased <sil=0.991> .PERIOD So <sil=0.408> ,COMMA I am writing just as you have done print F then automatically by default it goes to the screen here it is not default here I have said F PTR so <sil=0.547> ,COMMA whatever I write hello world it will be written in this file not in the screen <sil=0.923> .PERIOD Screen is another file but that is a default file reading data similarly we printed using F print F reading we can do using F scan F forget about that part look at this F PTR I am reading from not from the keyboard now I am now not reading from the keyboard I am reading X and Y to integers from a file which is pointed out by F PTR and what is that file F PTR I have opened the file input dot that <sil=0.911> .PERIOD So <sil=0.598> ,COMMA you see in that file input dot that 20 and 30 was written and so <sil=0.457> ,COMMA F scan F I have read that that was input dot that from I have opened that in the read mode in the read mode and I am reading from there so <sil=0.534> ,COMMA I am getting X to be 20 and Y to be 30 not from the keyboard but from the file <sil=0.986> .PERIOD So <sil=0.412> ,COMMA in that way we can now here are some powerful commands just to know we can read a string using F gets from a file I can read a string <sil=0.912> .PERIOD So <sil=0.554> ,COMMA here you see a file is F PTR and a line a file is F PTR and a line is of size 1000 while F gets line is not null that means <sil=0.408> ,COMMA I am getting from F PTR I am getting a value and if it is not null that means <sil=0.399> ,COMMA it is not the end of the line I mean I have got the file is open I am reading the line using F gets I am getting the line F gets takes three arguments what are the three arguments it is taking a string a maximum number of characters 1000 and a pointer from it returns if there is an error such as end of F end of file U F is end of file <sil=0.935> .PERIOD Now <sil=0.491> ,COMMA this I think you can understand much better when you use now when we open a file after that we must close that file we can simply to use the command F close and the file is closed and closed <sil=0.995> .PERIOD So <sil=0.623> ,COMMA here you see F PTR I opened a file in the right mode I have print written hello world over here F print F means I am printing in the file and then I am F close I am doing F closing the file by F close F PTR <sil=0.996> .PERIOD So <sil=0.357> ,COMMA here it is opening and here is access and here is closing we have got you have seen that F is closed and here STD in STD out where two special cases of files which are default files and STD error was the printing of the error <sil=0.940> .PERIOD So <sil=0.646> ,COMMA here is an example program you can see that main F print F STD out give value of I that means <sil=0.619> ,COMMA where am I printing this I am printing into the standard output I am reading I from the standard input <sil=0.911> .PERIOD Now <sil=0.525> ,COMMA F print F I am writing that the value of I is whatever value of I read <sil=0.968> .PERIOD So <sil=0.597> ,COMMA and there is no error <sil=0.997> .PERIOD So <sil=0.474> ,COMMA give value of I it will first be give value of I you give 15 then F print F that I then it will say value of I is 50 is equal to 15 and there no error but an example to show error message <sil=0.987> .PERIOD So <sil=0.577> ,COMMA if you do this STD error then you can if there is an error <sil=0.999> .PERIOD So <sil=0.542> ,COMMA for example <sil=0.643> ,COMMA I am return I am being returned a null pointer in that case I can use some output a STD error and say the file fail to open the file that sort of message <sil=0.978> .PERIOD So <sil=0.610> ,COMMA now another thing I will just talk about here that will come in very handy to you that is say for example <sil=0.439> ,COMMA must have you must be running the programs and after you compile the program and link them you are creating an executable file which is a dot out dot slash a dot out <sil=0.901> .PERIOD Now <sil=0.368> ,COMMA usually what you do you have got the dollar those of you using Linux shell a dot out and return <sil=0.953> .PERIOD Now <sil=0.626> ,COMMA this a dot out in that case dot slash a dot out what it is expecting the input from the keyboard STD N and the output is going to STD out but I do not want that I want that I have got a file I have got a file where my input data is there and I call that in dot that and I have got another file that is known as out dot that I want that the input be taken from this <sil=0.925> .PERIOD So <sil=0.374> ,COMMA I want a dot out to read the data from here and the result should be written here <sil=0.939> .PERIOD I can do that in the Unix environment very simply by this redirection operation you see a dot out will run taking data from in dot that and sending the output data to out dot that <sil=0.988> .PERIOD So <sil=0.390> ,COMMA say for example <sil=0.376> ,COMMA in dot that has got 15 <sil=0.904> .PERIOD So <sil=0.522> ,COMMA I do that and the program runs and says give the value of I think of the earlier example earlier program that we are thinking of give the value of and it means the it reads from here and it means the value of I is 15 <sil=0.918> .PERIOD So <sil=0.624> ,COMMA that is coming this whole thing is coming in out dot I <sil=0.973> .PERIOD So <sil=0.636> ,COMMA let us once again look at this thing here instead of STD out dot here I am asking them to give the value of I the value of I is being given and that is being scanned from the input file and this is being written on the output file <sil=0.917> .PERIOD So <sil=0.422> ,COMMA in the output file both these things are being written <sil=0.962> .PERIOD Consequently <sil=0.305> ,COMMA you see what am I getting is <sil=0.952> .PERIOD I will be getting this output this is my output out dot that and in dot that there are two files <sil=0.938> .PERIOD So <sil=0.416> ,COMMA this in this way you can use files for storing data you have to open the file let me summarize a little bit you will have to open the file if you want to read in the read mode read the file from there read the data from that file do the operation open another file in the write mode and write the data into that file thereby whenever you require some file operations you can easily do that and this is one example that we have shown which is very common when you during running your programs if you store some data in a particular file and read from there and write into another file you can utilize this sort of structures this sort of commands <sil=0.934> .PERIOD So <sil=0.611> ,COMMA thank you very much I think you have got an overall idea of how to write C programs and programs and solve problems using programs because our the essence of our course was to solve problems through C programming <sil=0.922> .PERIOD So <sil=0.313> ,COMMA you should choose different problems and you should try to write commands sorry I will try to write programs for solving those problems <sil=0.969> .PERIOD So <sil=0.560> ,COMMA first you have to find out the proper algorithm and then write the C code for that you have learnt everything about basic things about the C programming I have not touched upon some special features which you can also learn from the book like static variables and all those I have left out intentionally <sil=0.983> .PERIOD So <sil=0.472> ,COMMA that you are not overloaded you can solve it you can the more you run the programs using the basic concepts that has been taught it will be a good programmer and most importantly you will be able to think logically like a programmer you will be able to think of an algorithm and you will be able to translate that into a program <sil=0.935> .PERIOD Thank you very much <sil=0.949> .PERIOD We were discussing about strings and in today's discussion let me recapitulate what we the last part of what we discussed in the earlier lecture <sil=0.989> .PERIOD How can we read words from an input <sil=0.995> ?QUESTIONMARK So <sil=0.353> ,COMMA there we had introduced this percentage S format with that with percentage S if we read a name then it has to be noted that the amperes hand is not needed in this case right <sil=0.979> .PERIOD The amperes hand is not needed when I am reading a string when I am reading a string I do not need that amperes hand <sil=0.987> .PERIOD Now <sil=0.588> ,COMMA the point to remember is that whenever I am reading this in this way the string will be read the string will be read until there is some blank white space this is also called as white space or a tab sign or a carriage return or entered is pressed <sil=0.909> .PERIOD So <sil=0.538> ,COMMA if I type on a b c and then I type blank then this a b c will be taken as the word <sil=0.992> .PERIOD So <sil=0.345> ,COMMA when I perform scan F in this form in name then a b c will go in the name all right <sil=0.919> .PERIOD So <sil=0.561> ,COMMA this is what we had seen last time <sil=0.957> .PERIOD So <sil=0.321> ,COMMA that is why this example was given if we type Rupark Biswas since after Rupark there is a blank we will stop at that point of time the name will be assigned to Rupark name will be assigned to the string Rupark name will be assigned the string Rupark <sil=0.949> .PERIOD On the other hand when we read a line of text if I suppose I want to read say this Rupark Biswas I want to read this blank also this entire thing then as sentence I want to read a quick brown fox I want to read <sil=0.983> .PERIOD So <sil=0.455> ,COMMA I want to read this characters as well as this blank space as everything then what will be my delimiter by delimiter will be the carriage return the return carriage return or that is often designated as backslash n <sil=0.991> .PERIOD So <sil=0.576> ,COMMA till I get a backslash n I will go on reading this that is how I want I can read a line <sil=0.936> .PERIOD So <sil=0.581> ,COMMA in order to do that we can use the gate care function for the purpose by gate care function will be getting the characters one after another and I will go on getting the functions till the character I mean I will be going on getting the characters till I come to a character that is carriage return designating that is an end of the line <sil=0.975> .PERIOD So <sil=0.413> ,COMMA for example <sil=0.508> ,COMMA here a line has been defined to be of maximum length 81 typically as I said a line consists of 80 characters and you must be understanding now realizing now that why I put 81 the reason is here I need a space for backslash 0 and I put c to be 0 c is the number of characters c is here designating the number of characters number of characters red <sil=0.953> .PERIOD Now <sil=0.484> ,COMMA here we are doing it through a do while statement you can see that we can do we are doing it through a do while <sil=0.982> .PERIOD So <sil=0.502> ,COMMA I am reading one character here say x and that I am reading it through gate care and that character that has been red is coming to the variable array line line c c was initially 0 <sil=0.948> .PERIOD So <sil=0.599> ,COMMA here I put x then I go up then character I go on I read it and then found that the character is not amperes and I go back again read another character say x y increase c <sil=0.989> .PERIOD So <sil=0.411> ,COMMA c is now pointing here c is now pointing here and I again go back now suppose a blank has been typed in <sil=0.934> .PERIOD So <sil=0.627> ,COMMA I come here gate care is blank so that comes here and then c is pointing to the next position here and then I go again here and suppose I type in t so the c is now pointing here and then after that I read the character and the character was amperes I mean character was backslash n that means the end of the character <sil=0.902> .PERIOD So <sil=0.625> ,COMMA I put back slash n here whatever it was there and c is pointing here right c is now pointing here <sil=0.931> .PERIOD Now <sil=0.456> ,COMMA I have after insertion of backslash and I come and find here that well what I have entered is backslash n now backslash n should not be there instead of that we should have backslash 0 therefore <sil=0.355> ,COMMA I will come back I will decrement c by 1 space 1 position <sil=0.972> .PERIOD So <sil=0.505> ,COMMA it will come here and I will replace this with backslash 0 right here I will bring in backslash 0 will come here <sil=0.985> .PERIOD So <sil=0.590> ,COMMA the pattern that will be stored will be x y blank p backslash 0 <sil=0.971> .PERIOD So <sil=0.391> ,COMMA that is what the interesting will look like in that way I am reading a line that is how we are reading a line <sil=0.931> .PERIOD So <sil=0.493> ,COMMA we have seen that we can read characters as a character eddy care some line in this way line 81 <sil=0.989> .PERIOD Now <sil=0.467> ,COMMA this line I can read character by character or I can type in line to be x y blank p that is also will do the same thing otherwise I could have copied it character by character both of them are really equivalent right <sil=0.976> .PERIOD So <sil=0.499> ,COMMA here we have read the character until the carriage return or backslash n is encountered and then we make it a valid string by replacing backslash n by backslash 0 <sil=0.940> .PERIOD An alternative approach of reading a line can be this that I just specify the format here till now what we have seen is that our formats could be percentage s percentage d percentage f like that <sil=0.995> .PERIOD I can also specify my format in this way as you can see here what it means is anything I am sorry what happened <sil=0.969> .PERIOD Anything that is a b c d or whatever that this entire thing and here there is a blank here there is a blank <sil=0.981> .PERIOD I do not know what is happening here here you can see there is a blank here <sil=0.943> .PERIOD So <sil=0.377> ,COMMA that means <sil=0.320> ,COMMA what is allowed anything including bank blank capital A to Z everything is allowed as members of the variable line <sil=0.975> .PERIOD Similarly <sil=0.642> ,COMMA here the specification is that it can be carried this is a wild card it is called that means <sil=0.456> ,COMMA we can put in anything preceding backslash n <sil=0.999> .PERIOD So <sil=0.309> ,COMMA this means it is a wild card that means anything can come here as a character that can be a member of the variable <sil=0.984> .PERIOD So <sil=0.636> ,COMMA that is also another way of specifying it now these are specifics to the language c of course <sil=0.971> .PERIOD Now <sil=0.420> ,COMMA it is easier relatively simpler to display strings on the screen we can simply do a string we can display the string with percentage S and followed by the string name that is simpler <sil=0.907> .PERIOD Now <sil=0.394> ,COMMA we come to a very important aspect how do we process character strings <sil=0.968> .PERIOD Now <sil=0.450> ,COMMA for that we have got several c library functions we will soon come to functions and we have already seen different types of functions like square root maybe is did we see and we have seen we have seen the standard functions like scan F print F all those things <sil=0.981> .PERIOD Similarly <sil=0.635> ,COMMA we have got c library built in library functions for character string manipulation <sil=0.988> .PERIOD How are they looking like they are we have to in order to do that say one is S T R C P Y that means string copy that means if I have a string here say string here is my sorry let me put a blank here my space job suppose this is a string A and I want to copy it to another string B <sil=0.936> .PERIOD So <sil=0.574> ,COMMA B will also therefore <sil=0.450> ,COMMA have my blank job so that is that can be done by string copy function S T R C P Y S T R C P Y how can that be done <sil=0.954> .PERIOD We also have a similar thing like string length S T R L E N which means that I have got string say my job again blank job and automatically there is a backslash 0 at the end <sil=0.920> .PERIOD So <sil=0.482> ,COMMA when I copy it then this will also be with S T R C P Y will have my blank job backslash and will come here sorry backslash 0 will come here but S T R L E N mean string length I will count how many elements are there in the string <sil=0.940> .PERIOD Can you tell me how many elements are there in the string 1 2 3 blank is a valid character 1 2 3 4 5 6 <sil=0.995> .PERIOD So <sil=0.451> ,COMMA the string length will be returned that will be returned S 6 <sil=0.981> .PERIOD Similarly <sil=0.468> ,COMMA we have another function very popular function string comparison S T R C M P that means I have got 2 strings my job and here my job and I compared them if sorry if they are the same if they are the same then I will have a 1 <sil=0.937> .PERIOD So <sil=0.616> ,COMMA that is another function the fourth function is S T R C A T what is meant by concatenation concatenation S T R C A T is actually S T R C A T means string length I C A T <sil=0.950> .PERIOD So <sil=0.522> ,COMMA concatenation that means if I have a string here say A B C ended with this and there is another string say P Q R ended with this when I concatenate that these 2 strings <sil=0.920> .PERIOD What I get is a joining of these 2 strings 1 after another when I say that string B is concatenated with A then my pattern will be A B C note that this backslash 0 will not come P Q R and backslash 0 <sil=0.998> .PERIOD This is known as concatenation of 2 strings <sil=0.995> .PERIOD So <sil=0.361> ,COMMA that is being given by a function S T R C A T <sil=0.944> .PERIOD Now <sil=0.338> ,COMMA these are the very common functions for string operations for our job if we need some other functions we can always write function S T R C A T <sil=0.941> .PERIOD Now <sil=0.617> ,COMMA these are the very common functions for string operations for our job if we need some other functions we can always write functions which we learn in a couple of lectures from now <sil=0.995> .PERIOD But <sil=0.582> ,COMMA these are already available in the C library and therefore <sil=0.413> ,COMMA in order to do that we have to include include S T string dot H <sil=0.995> .PERIOD If you recall we had said that if you recall we can include always you do that hash include S T D I O dot H <sil=0.958> .PERIOD And also when we use that square root function earlier we had included math dot H that means all the mathematical library of all the mathematical functions <sil=0.909> .PERIOD Math dot H when we use for example <sil=0.593> ,COMMA S Q R square root <sil=0.998> .PERIOD So <sil=0.537> ,COMMA this is a function that is already inbuilt in this math library <sil=0.937> .PERIOD Similarly <sil=0.531> ,COMMA for strings if I use this S T R C P Y S T R C A T S T R C M P compare then I have to include strings dot H in my function <sil=0.943> .PERIOD So <sil=0.608> ,COMMA here are some examples very much like a string assignment operator string copy just like an assignment <sil=0.967> .PERIOD For example <sil=0.350> ,COMMA we are saying string copy string 1 string 2 <sil=0.979> .PERIOD So <sil=0.498> ,COMMA both string 2 will be copied in string 1 <sil=0.984> .PERIOD So <sil=0.523> ,COMMA assigns the content of string 2 to string 1 assigns the content <sil=0.911> .PERIOD So <sil=0.608> ,COMMA this is the source this is the destination <sil=0.985> .PERIOD It is copied from here to here say string copy C T calcutta what will happen here that means I am trying to copy C T is a string that is already defined <sil=0.985> .PERIOD I have defined C T and I am copying this string now this is a string constant this part is a string constant <sil=0.906> .PERIOD So <sil=0.362> ,COMMA what I am doing is I have got a variable C T variable of type string <sil=0.901> .PERIOD Now <sil=0.589> ,COMMA this how did you define it to be a type of type string it was care C T say something like this care C T 20 <sil=0.924> .PERIOD So <sil=0.468> ,COMMA 20 characters can come there now when I write C T S T R C copy C T to calcutta or right now we should say call cutter <sil=0.972> .PERIOD Say we do call cutter then in this variable call cutter will be loaded all right a followed by a backstab 0 <sil=0.944> .PERIOD On the other hand suppose C T is here and suppose another C T another string variable is there which is maybe Mumbai <sil=0.932> .PERIOD And I copy string copy C T my C T that means what will happen this string my C T will come into this variable C T <sil=0.997> .PERIOD So <sil=0.394> ,COMMA this call cutter will be over written and will be replaced by Mumbai now call cutter is a length 1 2 3 4 5 6 7 and Mumbai is 1 2 3 4 5 6 in that case what will happen <sil=0.928> .PERIOD As I copy this whole string over here then here Mumbai M will come you will come M B A I and this backslash 0 will come here <sil=0.976> .PERIOD And so the entire string will be kept here the last sorry up to this and with the backslash 0 here and the remaining part of unused part of Kolkata will be lost <sil=0.913> .PERIOD Now <sil=0.386> ,COMMA warning there is a warning here that is assignment operator does not work for string <sil=0.949> .PERIOD So <sil=0.545> ,COMMA I could not have done string 1 assign string 2 or as we are doing here C T assigned my C T that own do that assignment operator will not work in the case of strings <sil=0.966> .PERIOD So <sil=0.565> ,COMMA C T assigned Kolkata is invalid string length S T R A E N this is you I will ask you when we teach you function to write a function for finding the string length although it is available in the standard C library <sil=0.910> .PERIOD Counts and returns a number of characters in a string <sil=0.914> .PERIOD So <sil=0.375> ,COMMA length suppose length is a variable of type integer <sil=0.912> .PERIOD Lane is of type integer and we say S T R A E N string <sil=0.988> .PERIOD So <sil=0.487> ,COMMA string is some string some variable name S T R A E N C T <sil=0.958> .PERIOD So <sil=0.608> ,COMMA C T is a variable and whatever is the and suppose C T is moved by it will find out the length of the characters in this string and that will come into length <sil=0.947> .PERIOD So <sil=0.403> ,COMMA length here will get the value 6 when I do this function on this on the string <sil=0.934> .PERIOD The null character at the end as I said is not counted because that tells you that you need not count any further <sil=0.987> .PERIOD Counting ends with the first null character <sil=0.936> .PERIOD So <sil=0.601> ,COMMA if I do Kolkata if I copy Kolkata the string constant Kolkata to C T and if I find out the length of C T it will be 1 2 3 4 5 6 7 8 and backstarts 0 will be left out <sil=0.927> .PERIOD So <sil=0.560> ,COMMA N is assigned 8 writing the string length <sil=0.947> .PERIOD So <sil=0.568> ,COMMA one problem that can be given to you that I am not talking about this function part right now <sil=0.995> .PERIOD Suppose I am trying to find out the string length of a character string I am trying to find out how do you find out string length <sil=0.999> .PERIOD I mean it is writing a program that is finding the string length <sil=0.950> .PERIOD You need not bother about the structure of this as yet but let us look at the algorithm purely <sil=0.900> .PERIOD What is being done <sil=0.986> ?QUESTIONMARK Lens some variable has been put to 0 and then while I am not encountering now STR is an array of course <sil=0.430> ,COMMA array of characters as you can see it is an array of characters <sil=0.989> .PERIOD As long as that is not equal to backstarts 0 that means not the end of the string I am going on incrementing this length <sil=0.910> .PERIOD Lens was 0 length becomes 1 like that and then we return length after a completed then I return length <sil=0.908> .PERIOD Now <sil=0.467> ,COMMA this is provided in the of course <sil=0.322> ,COMMA I have to include the string dot h but this thing this is what I am writing if but actually this is already available <sil=0.931> .PERIOD So <sil=0.647> ,COMMA I need not write it I need to simply include hash include I call it hash include string dot h that light will be there <sil=0.990> .PERIOD Similar program is already written and when I write STR alien that is the program that is activated <sil=0.927> .PERIOD String compared is comparing two strings <sil=0.920> .PERIOD So <sil=0.609> ,COMMA we are comparing two strings and return 0 if they are identical <sil=0.998> .PERIOD What I just now said was just opposite if they are matching then it returns 0 and if they do not match a little non intuitive <sil=0.969> .PERIOD So <sil=0.312> ,COMMA keep it in mind that if the two strings match then we will return a 0 otherwise we will return a non 0 <sil=0.981> .PERIOD So <sil=0.642> ,COMMA example is here if I compare CT with the string del E is 0 then I do something <sil=0.915> .PERIOD What does it mean CT is a string already suppose that is again Chennai suppose that is Chennai and I am comparing <sil=0.971> .PERIOD So <sil=0.612> ,COMMA CT is a variable which has got this value and I am comparing with del E of course <sil=0.372> ,COMMA they are not matching so it will not it will return non 0 <sil=0.952> .PERIOD But if the CT was del E then these two have matched and I have got a 1 here <sil=0.983> .PERIOD Now <sil=0.575> ,COMMA obviously you can also just think and decide how this algorithm can be written that is so simple now we have learnt all the tidbits of writing such a program <sil=0.955> .PERIOD So <sil=0.525> ,COMMA if this is not equal to 0 then we do this <sil=0.956> .PERIOD So <sil=0.433> ,COMMA similarly I can do CT 1 CT 2 <sil=0.915> .PERIOD Now <sil=0.413> ,COMMA so before that you can simply think of how the algorithm will look like in case of this <sil=0.941> .PERIOD Suppose I have got two strings one is say Chennai and the other string is of course <sil=0.534> ,COMMA backstab 0 here instead of N there is a name here <sil=0.957> .PERIOD So <sil=0.401> ,COMMA how will you do that <sil=0.870> ?QUESTIONMARK So <sil=0.334> ,COMMA you will compare these two character by character <sil=0.976> .PERIOD So <sil=0.455> ,COMMA this is suppose CT 1 and this is CT 2 <sil=0.954> .PERIOD So <sil=0.460> ,COMMA you can very easily compare while CT 1 is 0 <sil=0.946> .PERIOD I of course <sil=0.506> ,COMMA I has been assigned to 0 here is same as CT 2 I what shall we do <sil=0.979> ?QUESTIONMARK We will go on implementing I plus plus <sil=0.992> .PERIOD But if it is not equal will come out <sil=0.979> .PERIOD So <sil=0.347> ,COMMA this here I compare here I compare I come here and here I find that CT 3 and CT 1 3 and CT 2 3 are not the same <sil=0.932> .PERIOD So <sil=0.477> ,COMMA I will come out <sil=0.987> .PERIOD But what happens if they are same <sil=0.894> ?QUESTIONMARK So <sil=0.487> ,COMMA I need to put in if they are same I how long shall I go on <sil=0.887> ?QUESTIONMARK No mismatch is there <sil=0.924> .PERIOD Suppose this is also N while CT is CT 1 is not equal to CT 2 while CT 1 is equal to CT 2 <sil=0.917> .PERIOD Do I need another condition here <sil=0.948> ?QUESTIONMARK Yes and CT I is not equal to backstab 0 <sil=0.969> .PERIOD So <sil=0.548> ,COMMA are you understanding this while this condition which I have already written there <sil=0.997> ?QUESTIONMARK That should be true in order to proceed in order to proceed further for further checking <sil=0.909> .PERIOD I should they are matching <sil=0.967> .PERIOD So <sil=0.439> ,COMMA I should proceed and but and also the fact should be that none of these two two CTs nails two strings have reached the end is not equal to M this and CT 2 I <sil=0.936> .PERIOD If any one of them has matched has reached the end then my while condition will be violated <sil=0.937> .PERIOD So <sil=0.350> ,COMMA I will not continue any further <sil=0.922> .PERIOD So <sil=0.473> ,COMMA I can keep a flag here that what should I say <sil=0.917> ?QUESTIONMARK Match is 1 <sil=0.962> .PERIOD So <sil=0.318> ,COMMA if I go on doing this match will be remaining 1 whenever I come out of this loop I will make match 0 <sil=0.933> .PERIOD That means it has there has been a match because the convention is that if they are matching then it should be 0 <sil=0.922> .PERIOD So <sil=0.521> ,COMMA you please also try to write this function write this program right now <sil=0.937> .PERIOD And ask you to make it a function a couple of lectures later <sil=0.917> .PERIOD I hope this is clear this part please try to understand this condition <sil=0.916> .PERIOD Next we have got the last one that is a STRCAT that is rather simple and you will also be able to write the program for that <sil=0.948> .PERIOD It is two strings are just being concatenated but one thing that you must remember appending concatenating means joining while appending means adding one at the end of the other <sil=0.975> .PERIOD So <sil=0.588> ,COMMA when I write this a b c p q r then p q r has been appended to a b c <sil=0.972> .PERIOD So <sil=0.416> ,COMMA string 2 is appended to string 1 that means it is joined at the end of string 1 <sil=0.945> .PERIOD So <sil=0.474> ,COMMA the null character at the end of string 1 is removed and string 2 is joined from that point <sil=0.957> .PERIOD As we said that there can be a b c backslash 0 and then when I append p q r to that then p q r will replace this and backslash 0 will come here <sil=0.944> .PERIOD So <sil=0.520> ,COMMA ultimately we will have a b c p q r backslash 0 <sil=0.915> .PERIOD So <sil=0.376> ,COMMA string copy suppose I have name 1 a string assigned by string copy omith a my t <sil=0.952> .PERIOD So <sil=0.486> ,COMMA it looks like this a m i t backslash here there is a backslash 0 and there is a blank here you see the string is not a my t a my t blank <sil=0.916> .PERIOD Another string is name 2 which is r o y then when I append them concatenate them it will be a my t blank this blank and then r o y and this this blank has been replaced by r <sil=0.946> .PERIOD So <sil=0.385> ,COMMA r has gone here and we will get this <sil=0.939> .PERIOD So <sil=0.389> ,COMMA this is string concatenation this will often come handy when you type in some character strings or type in some lines or compute using some text strings text English sentence has been given and you are trying to find out where the verb is and all those then you need a lot of string operations like this <sil=0.937> .PERIOD So <sil=0.365> ,COMMA here is an example here we are reading a line of text and counting the number of upper case letters how many upper case letters are there <sil=0.920> .PERIOD So <sil=0.402> ,COMMA what are the things we are including here stdio <sil=0.908> .PERIOD h our old friend is here string dot h is also there then look at this function I have defined the line to be of length 81 big one 81 <sil=0.931> .PERIOD Now <sil=0.320> ,COMMA I have got the variables i and carn and carn is equal to 0 I am asking the user to input the line I am reading the line using this format which we just discussed that means anything can come here I mean anything can come here like a b c slash dash percentage p whatever is coming except backslash n is coming here and then I am finding the length of the line suppose the line that was actually typed in in this way through this scan f is say apple blank is red <sil=0.986> .PERIOD And then this backslash is now this string length str alien will find out the length of the string 1 2 3 4 5 6 7 8 9 10 11 12 <sil=0.978> .PERIOD So <sil=0.517> ,COMMA 12 is n is becoming 12 <sil=0.977> .PERIOD So <sil=0.550> ,COMMA for i equal to 1 to n now here is another new function that we are finding is upper <sil=0.928> .PERIOD If the character is is upper is upper case later is upper if the character that is being read that is being passed here I put in some character and if the character is an uppercase later then I will count that <sil=0.986> .PERIOD So <sil=0.426> ,COMMA suppose here I make a little change I say this is I I say that this is capital and I say I say that this is capital <sil=0.983> .PERIOD So <sil=0.406> ,COMMA what is happening is it is reading character by character from here I 0 onwards and checking whether this character is an upper character if that is so count is becoming 1 <sil=0.946> .PERIOD So <sil=0.617> ,COMMA count becomes 1 as is uppercase later then we go on in this loop I is being incremented until it comes to 12 less than 12 <sil=0.924> .PERIOD So <sil=0.645> ,COMMA here is another one so I will get the count to be 2 it goes on and here I will get another one so 3 <sil=0.918> .PERIOD Printed the number of uppercase later is percentage D is now look at this the number of uppercase later in string percentage is percentage D <sil=0.979> .PERIOD So <sil=0.542> ,COMMA line will be printed as a line apple is read the number of uppercase later in apple is read is 3 <sil=0.997> .PERIOD So <sil=0.321> ,COMMA here this program demonstrates a couple of things one is first of all this is a new thing that you have learnt is upper I am just writing it separately so that it is clear <sil=0.900> .PERIOD But <sil=0.339> ,COMMA in actual C library the function is written in the without this gap or without any special character in between this is the first thing that we have learnt <sil=0.937> .PERIOD And how we can we have already seen it is a it is an application of what we learnt how we can read a line using this wild card format <sil=0.957> .PERIOD And then we found out what is the length of the line by our newly learnt function STR alien and using that we have this is this looping we already know we have practiced it so often <sil=0.977> .PERIOD So <sil=0.549> ,COMMA we now using this value using this for loop for so many iteration so many repetitions that is determined by the value of n will check the entire string <sil=0.955> .PERIOD So <sil=0.570> ,COMMA this is an example of applying the string function in string operations will go further with some more examples later <sil=0.991> .PERIOD We were talking about errors and round of errors and percentage errors <sil=0.910> .PERIOD Now <sil=0.530> ,COMMA I will briefly show you that if we commit an error <sil=0.549> ,COMMA how that error continuously gets accumulated and ultimately has a much larger effect <sil=0.960> .PERIOD For example <sil=0.608> ,COMMA suppose the exact value <sil=0.558> ,COMMA suppose the exact value of some variable at the first instance is 10 <sil=0.958> .PERIOD Suppose <sil=0.552> ,COMMA no <sil=0.401> ,COMMA suppose the exact value is 9 <sil=0.962> .PERIOD 98 and we compute 10 <sil=0.932> .PERIOD So <sil=0.341> ,COMMA the inherent error first the error actually is 0 <sil=0.994> .PERIOD 02 <sil=0.920> .PERIOD Now <sil=0.442> ,COMMA as we go on iterating <sil=0.458> ,COMMA suppose x 1 is 10 times x 0 <sil=0.905> .PERIOD Then the exact value should be 99 <sil=0.997> .PERIOD 8 <sil=0.505> ,COMMA but here we will get 100 <sil=0.985> .PERIOD Suppose it is 100 <sil=0.926> .PERIOD So <sil=0.562> ,COMMA you can see that the error has increased to how much 0 <sil=0.957> .PERIOD 2 <sil=0.928> .PERIOD Now <sil=0.531> ,COMMA if the next iteration x 2 is again 10 times x 1 <sil=0.607> ,COMMA then it will be 998 <sil=0.406> ,COMMA whereas the computed value will be 1000 <sil=0.922> .PERIOD So <sil=0.382> ,COMMA the error is becoming 2 <sil=0.994> .PERIOD So <sil=0.568> ,COMMA you see how with if we start with an inherent error <sil=0.319> ,COMMA how the error accumulates over time <sil=0.914> .PERIOD So <sil=0.550> ,COMMA we can see a very important term is relative accumulation of error <sil=0.496> ,COMMA which is accumulated error <sil=0.438> ,COMMA accumulated error divided by exact value for that iteration <sil=0.943> .PERIOD For example <sil=0.465> ,COMMA in the first iteration <sil=0.584> ,COMMA it was the error accumulated error was 0 <sil=0.953> .PERIOD 02 divided by the exact value <sil=0.604> ,COMMA which was 9 <sil=0.926> .PERIOD 98 <sil=0.445> ,COMMA but later on it became 0 <sil=0.967> .PERIOD 2 divided by 99 <sil=0.901> .PERIOD 8 <sil=0.439> .PERIOD So <sil=0.391> ,COMMA this was 0 <sil=0.964> .PERIOD 00 but whatever that is <sil=0.476> ,COMMA that is not that important <sil=0.621> ,COMMA I do not want to confuse with this <sil=0.920> .PERIOD Now <sil=0.469> ,COMMA there are some cases where this accumulation of error actually goes on increasing <sil=0.957> .PERIOD If the rate of accumulation error decreases <sil=0.341> ,COMMA if the rate of accumulation of error decreases or if the rate of accumulator increases <sil=0.526> ,COMMA but the rate of relative error decreases <sil=0.424> ,COMMA then we call it a stable algorithm <sil=0.986> .PERIOD However <sil=0.540> ,COMMA I am not going into the details and the intricacies of this <sil=0.432> ,COMMA but this is just to give you an idea how the error propagates through iterations <sil=0.912> .PERIOD And so <sil=0.603> ,COMMA we must be very conscious about the rate of increase of this error <sil=0.358> ,COMMA right <sil=0.975> .PERIOD With these words <sil=0.444> ,COMMA we move to the algorithm <sil=0.420> ,COMMA which we are planning to discuss in this lecture <sil=0.399> ,COMMA that is a bisection method <sil=0.906> .PERIOD I have already told you that the bisection method is given a particular function <sil=0.501> ,COMMA some function on this x and y axis <sil=0.908> .PERIOD If I have some function that moves in this way <sil=0.492> ,COMMA then we start with any two points <sil=0.624> ,COMMA any two points arbitrary points here and maybe here <sil=0.927> .PERIOD No <sil=0.526> ,COMMA these two points will not do <sil=0.478> ,COMMA because if I select these two points <sil=0.612> ,COMMA then both of them are positive <sil=0.430> ,COMMA so that if I had selected this point <sil=0.407> ,COMMA for example <sil=0.462> ,COMMA these two points x 0 and x 1 <sil=0.467> ,COMMA that would not have served my purpose <sil=0.323> ,COMMA because I do not know whether the root is there or not <sil=0.954> .PERIOD So <sil=0.548> ,COMMA I would rather select two points <sil=0.379> ,COMMA which are of opposite signs and therefore <sil=0.328> ,COMMA I know that somewhere in between the root lies <sil=0.956> .PERIOD So <sil=0.435> ,COMMA now I will take the midpoint of this somehow here <sil=0.905> .PERIOD If this point is negative <sil=0.464> ,COMMA then I will keep the positive fixed and I will find out the value of y <sil=0.360> ,COMMA so these two are opposite signs <sil=0.367> ,COMMA so the root must be somewhere here <sil=0.908> .PERIOD So <sil=0.628> ,COMMA in that way I come to this one and find out the value of the root here <sil=0.546> ,COMMA in that way I go on dividing it till I come very close to the root <sil=0.587> ,COMMA as is being shown here <sil=0.634> ,COMMA very close to the root <sil=0.996> .PERIOD Now <sil=0.650> ,COMMA how close that will depend on my decision <sil=0.474> ,COMMA that is the basic approach of bisection method <sil=0.964> .PERIOD So <sil=0.373> ,COMMA with that <sil=0.340> ,COMMA let us try to have a look at the algorithm <sil=0.949> .PERIOD Therefore <sil=0.362> ,COMMA first we start <sil=0.593> ,COMMA we define the function <sil=0.471> ,COMMA we define the function f x and get the value of the interval a b <sil=0.581> ,COMMA that is there is a function <sil=0.942> .PERIOD So <sil=0.484> ,COMMA here there is a function and the function can be long enough <sil=0.938> .PERIOD So <sil=0.589> ,COMMA I take the limits that I have to find out the root within this interval a and b and I find out how much error is required <sil=0.942> .PERIOD So <sil=0.301> ,COMMA how much error is acceptable <sil=0.917> ?QUESTIONMARK So <sil=0.466> ,COMMA this error is the allowed error is the epsilon that I was talking of and also the number of iterations <sil=0.480> ,COMMA the number of iterations because it may be that in some case <sil=0.422> ,COMMA I am not finding the root because I am going on looking at say for example <sil=0.413> ,COMMA this sort of scenario and my a is here <sil=0.521> ,COMMA my b is here <sil=0.514> ,COMMA then obviously <sil=0.452> ,COMMA the root does not lie between this <sil=0.977> .PERIOD So <sil=0.357> ,COMMA I will go on doing this bisection and again doing this bisection <sil=0.443> ,COMMA how long will I go on <sil=0.382> ,COMMA but still I am not I will not find I may it may be that I will not find the root <sil=0.954> .PERIOD Therefore <sil=0.377> ,COMMA there is a maximum limit that is kept number of iterations <sil=0.901> .PERIOD Now <sil=0.414> ,COMMA I initialize I to be 1 some I just some index to be 1 and then I call a sub root in or a function bisect the midpoint that means <sil=0.984> .PERIOD So <sil=0.333> ,COMMA here is a sub sub root in bisect <sil=0.350> ,COMMA what it does here is a sub root you see what it does or a function what does it do here <sil=0.581> ,COMMA it finds out between a and b the midpoint and increments the iteration and pins the value of x 1 <sil=0.391> ,COMMA x 1 is the middle point <sil=0.923> .PERIOD So <sil=0.428> ,COMMA if my function was like this and this was a <sil=0.417> ,COMMA this was b <sil=0.401> ,COMMA then the root must lie somewhere here <sil=0.433> ,COMMA I find out the midpoint of this <sil=0.968> .PERIOD So <sil=0.386> ,COMMA this becomes x 1 to be there is a next one and how many what is the iteration <sil=0.971> .PERIOD Next is f that means <sil=0.555> ,COMMA f of mid less than 0 <sil=0.922> .PERIOD So <sil=0.381> ,COMMA there can be two things <sil=0.646> ,COMMA all right here I select this to be my b and this to be my a <sil=0.929> .PERIOD Now <sil=0.508> ,COMMA obviously <sil=0.329> ,COMMA if I take the midpoint then the midpoint will be somewhere here a and b were of different signs <sil=0.924> .PERIOD If f mid is not less than 0 <sil=0.397> ,COMMA then a should be x that means <sil=0.641> ,COMMA I will now move it on this side and try to find out this should be this should be the next a and between these two I will have to find out and every time I am trying to find out whatever value of f x that I compute is it less than the absolute error <sil=0.908> .PERIOD If yes <sil=0.446> ,COMMA then x that is I am getting my solution otherwise I am going on doing this <sil=0.948> .PERIOD So <sil=0.503> ,COMMA this is a flow chart of the whole thing <sil=0.565> ,COMMA but I think you will be more interested in looking at the algorithm and let us look at the algorithm for a second and the program here is the algorithm you see this is much more understandable to you <sil=0.908> .PERIOD I start I read x 1 x 2 and the error here x 1 and x 2 are the initial cases all right <sil=0.916> .PERIOD Here is my thing I have taken this is x 2 this is x 1 is the absolute error that means <sil=0.390> ,COMMA how much error is permissible compute f 1 that is f x 1 compute for this function this value and f 2 compute this value all right <sil=0.997> .PERIOD If f 1 and f 2 the product of these two is greater than 0 greater than 0 that means <sil=0.427> ,COMMA my initial cases are wrong because both of them are positive <sil=0.933> .PERIOD Then I can do many things I will instead of going to 11 my initial cases are wrong I will again ask for new guess all right <sil=0.945> .PERIOD So <sil=0.565> ,COMMA I take a new guess and I find that that is less than it less than 0 <sil=0.941> .PERIOD Then I take in this step x 1 plus x 2 meet of that <sil=0.904> .PERIOD So <sil=0.639> ,COMMA suppose meet of that is this one and that is becoming x if x 1 minus x 2 by x actually here it should be if I think it is wrong here it should be if f x 1 minus f x 2 please read this as f x 1 no the error f x 1 minus f x 2 divided by x is less than e then display x that means <sil=0.492> ,COMMA if my error between these two between these two points the val difference is less is 0 <sil=0.984> .PERIOD 002 and that is I just over that I can assume as 0 then I will display this particular value of x <sil=0.939> .PERIOD So <sil=0.519> ,COMMA right now it is not the case otherwise I will make this f to be f x I take this all right <sil=0.970> .PERIOD Now <sil=0.599> ,COMMA between these two I again divide I come here and in this way I go on all right <sil=0.963> .PERIOD So <sil=0.644> ,COMMA you will be able to write the program as the program runs <sil=0.901> .PERIOD So <sil=0.582> ,COMMA just to show you I am sure you can write the program yourself how can you translate this in the form of a code <sil=0.947> .PERIOD So <sil=0.333> ,COMMA here you see let us try to understand this code it is a C program for the bi-section method I have included STI O dot H math dot H and there is some function because I have to find the root of a particular polynomial <sil=0.904> .PERIOD So <sil=0.305> ,COMMA for example <sil=0.455> ,COMMA here it is given this is a polynomial <sil=0.916> .PERIOD So <sil=0.589> ,COMMA what is this polynomial it is x cube minus 4 x minus 9 <sil=0.948> .PERIOD So <sil=0.429> ,COMMA that value of f x has to be continue computed <sil=0.900> .PERIOD So <sil=0.394> ,COMMA the function is the fun fun is the name of the function then there is another function bi-section this function performs and brings the result of one iteration <sil=0.947> .PERIOD So <sil=0.344> ,COMMA it is a plus b by 2 now in an earlier lecture we had talked about this what is this because here when I am calling this function I am calling by reference how I am calling I am just passing the address x and whatever I do here once again is a part of revision you can see if I come here flow star x that means what x is there some variable and I have just passed the address of that <sil=0.959> .PERIOD So <sil=0.431> ,COMMA star x is the content of this say 50 all right <sil=0.905> .PERIOD So <sil=0.605> ,COMMA I passed it on and in the main function I am passing on the address of x this we have seen earlier <sil=0.906> .PERIOD So <sil=0.536> ,COMMA I am taking the meat point and incrementing the iteration iteration is also a call by reference and flow tape flow b are two points in between which have been passed on <sil=0.910> .PERIOD Now <sil=0.335> ,COMMA what is being done in the main function in the main function I am setting the iteration to be 0 and here I am saying how many iterations are permitted maximum number of iterations x a b allowed error how much error is allowed and some x 1 value is given enter the values of a b allowed error and maximum iterations <sil=0.944> .PERIOD So <sil=0.555> ,COMMA all these I read the range a and b between which points I have to do a and b and how much is the allowed error and what is the maximum number of iteration then with this I call by section what do I do by section and x that means this will be give me the meat point I will call by section here a b iteration <sil=0.964> .PERIOD So <sil=0.518> ,COMMA a is being passed here b is being passed here and the number of iterations is being passed here <sil=0.920> .PERIOD Now <sil=0.579> ,COMMA here I am finding the meat point and that meat point is being returned here is common right and then here at this point I find out I call the function that is I am computing the polynomial if the polynomial at a value of the polynomial at a and the value of the polynomial at x that is the meat point is less than 0 <sil=0.967> .PERIOD So <sil=0.511> ,COMMA what happened this was my scenario here was a and here was b no let me draw it in there <sil=0.989> .PERIOD So <sil=0.419> ,COMMA here was b and here was a <sil=0.920> .PERIOD So <sil=0.549> ,COMMA now what I do I got the meat point somewhere here then the value of the function at this point and the value of the function at this point negative therefore <sil=0.624> ,COMMA I move this b to x x is becoming b and I do the same thing otherwise if it was on the other side I would have made x to be a this clear and then again I call by section after calling by section I find if the absolute error of x 1 minus x is less than the allowed error then I will print the loot <sil=0.911> .PERIOD So <sil=0.477> ,COMMA this will go on while I did this is under this do while this will go on until I exceed the maximum iteration <sil=0.970> .PERIOD So <sil=0.508> ,COMMA this is how I code and all of you should be able to practice this yourself <sil=0.921> .PERIOD Next we will move to another another algorithm another algorithm which is another method which is known as the Newton-Raphson method <sil=0.930> .PERIOD This method adopts a different approach to find the root of the function let us try to understand this briefly <sil=0.905> .PERIOD So <sil=0.382> ,COMMA I have got a function like this now Newton-Raphson method what it does at it starts at some x 0 and the corresponding value of the function at x 0 is f x 0 <sil=0.911> .PERIOD Now <sil=0.314> ,COMMA what it does it finds out the tangent at this point tangent to this point <sil=0.987> .PERIOD So <sil=0.484> ,COMMA what would the tangent b the tangent is nothing but f prime x 0 because we know that is f prime means d f x d y d x <sil=0.934> .PERIOD So <sil=0.638> ,COMMA I draw the tangent here the tangent intersects the x axis at some point <sil=0.901> .PERIOD Now <sil=0.504> ,COMMA I take the x 1 this let this be the value x 1 I drew the tangent and got the value x 1 ok <sil=0.941> .PERIOD I come here and from here since the value here f x 1 at every stage I have to check whether the value is close to 0 or not obviously <sil=0.453> ,COMMA this is not the case <sil=0.995> .PERIOD Therefore <sil=0.559> ,COMMA I draw another tangent from here and what is this tangent this tangent is f dashed x 1 derivative at this point <sil=0.929> .PERIOD So <sil=0.316> ,COMMA this becomes x 2 now I find out f x 2 <sil=0.989> .PERIOD Now <sil=0.630> ,COMMA again compare whether f x 2 is very close to 0 or not still it is not the case <sil=0.985> .PERIOD So <sil=0.647> ,COMMA I draw a tangent from here to this I am sorry I should have made it dotted as I was doing with all I draw a tangent at this point <sil=0.959> .PERIOD So <sil=0.482> ,COMMA this is x 3 and I find out f x 3 <sil=0.936> .PERIOD Suppose <sil=0.644> ,COMMA this value f x 3 is very close to 0 suppose this is within my allowed error then x 3 is the root <sil=0.911> .PERIOD Otherwise <sil=0.310> ,COMMA if it was not there from here again I would have to draw a tangent in this way it goes all right <sil=0.913> .PERIOD So <sil=0.475> ,COMMA this is the essence of Newton-Raphson's method <sil=0.941> .PERIOD So <sil=0.557> ,COMMA what are you doing here <sil=0.858> ?QUESTIONMARK We are taking a function starting with a point and finding a tangent to that curve to the function at that point and see where that tangent intersects the x axis <sil=0.916> .PERIOD From there I find out f x 2 and then I go on doing this <sil=0.973> .PERIOD So <sil=0.646> ,COMMA I think this geometric exposition will be very helpful to you <sil=0.957> .PERIOD So <sil=0.405> ,COMMA next let us try to see how Newton-Raphson method works <sil=0.979> .PERIOD So <sil=0.458> ,COMMA at every stage x n plus 1 is x n minus f x n by f dashed x n <sil=0.929> .PERIOD Why <sil=0.884> ?QUESTIONMARK Because of the simple reason that I had this curve and this was my x n all right <sil=0.905> .PERIOD From there I drew the tangent <sil=0.934> .PERIOD So <sil=0.599> ,COMMA this was f x n and I drew the tangent here then if I divide this and subtract it from here <sil=0.551> ,COMMA I will get this x n plus 1 here <sil=0.911> .PERIOD So <sil=0.369> ,COMMA you see it is coming in the other way all right <sil=0.944> .PERIOD Because at every stage I am computing this next <sil=0.952> .PERIOD Here x n is the current known value of x <sil=0.983> .PERIOD f x n represents the value of the function <sil=0.976> .PERIOD f dashed x n is the derivative of the slope at that point x n plus 1 represents the next x value that you are trying to find <sil=0.954> .PERIOD So <sil=0.370> ,COMMA this expression is coming from the fact that f x by dx where dx is delta minus x <sil=0.929> .PERIOD Therefore <sil=0.470> ,COMMA the term f x by f dashed x is actually the value of dx <sil=0.918> .PERIOD How much the dx value sorry dx value <sil=0.877> ?QUESTIONMARK That means <sil=0.586> ,COMMA how much I should come down <sil=0.931> .PERIOD So <sil=0.413> ,COMMA you can see from this expression f x by f prime x is f x by f x by delta x that means <sil=0.489> ,COMMA the delta x actually this is the delta x part and that means <sil=0.355> ,COMMA how I am shifting this x <sil=0.901> .PERIOD So <sil=0.330> ,COMMA the x was here and I am shifting it by delta x and coming here again shifting it by delta x coming here like that I am going <sil=0.953> .PERIOD All right <sil=0.911> .PERIOD So <sil=0.363> ,COMMA suppose f x let us take an example here <sil=0.930> .PERIOD Suppose f x was x square minus 4 <sil=0.997> .PERIOD Then f prime x is obviously 2 i x and x 0 was 6 <sil=0.962> .PERIOD Suppose <sil=0.531> ,COMMA I assumed x 0 to be 6 <sil=0.932> .PERIOD So <sil=0.566> ,COMMA here is how it goes <sil=0.919> .PERIOD First iteration x 0 is 6 f x 0 here <sil=0.479> ,COMMA f x 0 is suppose 32 <sil=0.369> ,COMMA 32 because 6 square 36 minus 4 <sil=0.918> .PERIOD If prime x is what <sil=0.870> ?QUESTIONMARK If prime x is 2 x that is 12 <sil=0.997> .PERIOD If prime x is 12 <sil=0.337> ,COMMA then x plus 1 <sil=0.419> ,COMMA sorry I am sorry this x n and the next value will be x n that means <sil=0.628> ,COMMA 6 minus 32 by 12 <sil=0.954> .PERIOD So <sil=0.500> ,COMMA whatever that is I subtract and I get the x 3 <sil=0.961> .PERIOD 33 <sil=0.993> .PERIOD Next iteration I come to 3 <sil=0.950> .PERIOD 33 <sil=0.935> .PERIOD So <sil=0.631> ,COMMA it was something like this that I started with 6 and then I move to 3 <sil=0.923> .PERIOD 33 <sil=0.922> .PERIOD So <sil=0.519> ,COMMA you see it is converging very fast 3 <sil=0.904> .PERIOD 33 <sil=0.928> .PERIOD Then at 3 <sil=0.901> .PERIOD 33 the value of f x 1 is 7 <sil=0.916> .PERIOD 09 here if you compute this <sil=0.391> ,COMMA the derivative will be twice of this that is 6 <sil=0.987> .PERIOD 66 <sil=0.499> ,COMMA derivative is 2 x <sil=0.308> ,COMMA 6 <sil=0.492> .PERIOD 66 <sil=0.419> .PERIOD If I subtract this 6 <sil=0.974> .PERIOD 66 divided by 7 <sil=0.910> .PERIOD 09 subtracted from 3 <sil=0.968> .PERIOD 33 is 2 <sil=0.913> .PERIOD 27 <sil=0.977> .PERIOD So <sil=0.353> ,COMMA my dx is 1 <sil=0.993> .PERIOD 06 <sil=0.930> .PERIOD I go on like this and ultimately I come to a dx of 0 <sil=0.925> .PERIOD 01 <sil=0.910> .PERIOD I assume <sil=0.915> .PERIOD So <sil=0.513> ,COMMA next time it is 2 <sil=0.950> .PERIOD 27 <sil=0.950> .PERIOD I start with that again find the next value to be 2 point instead of 2 <sil=0.997> .PERIOD 27 it will be 2 <sil=0.935> .PERIOD 01 <sil=0.971> .PERIOD And with 2 <sil=0.935> .PERIOD 01 I compute and gradually you see the dx is coming down <sil=0.971> .PERIOD As the dx is coming down <sil=0.484> ,COMMA that means I am approaching the actual route <sil=0.987> .PERIOD So <sil=0.637> ,COMMA this is Newton's Rapps and Newton Rapps and method and we can very easily code it <sil=0.981> .PERIOD And so <sil=0.509> ,COMMA here is an example <sil=0.912> .PERIOD Now <sil=0.364> ,COMMA you can see this <sil=0.445> ,COMMA it starts with 6 goes to 3 <sil=0.989> .PERIOD 33 <sil=0.930> .PERIOD Then from the 3 here is a little animation 3 <sil=0.943> .PERIOD 33 <sil=0.919> .PERIOD I am coming to 2 <sil=0.922> .PERIOD 2 <sil=0.953> .PERIOD 7 <sil=0.917> .PERIOD Then from 2 <sil=0.945> .PERIOD 2 <sil=0.949> .PERIOD 7 I am coming here and gradually the error is that it is not increasing <sil=0.938> .PERIOD So <sil=0.615> ,COMMA it is very much converging <sil=0.965> .PERIOD So <sil=0.410> ,COMMA I get the solution with 2 <sil=0.946> .PERIOD 01 and I get the solution <sil=0.981> .PERIOD So <sil=0.359> ,COMMA quickly the algorithm will look like this <sil=0.932> .PERIOD Again I will read x the a maximum error allowed number of iterations and d <sil=0.946> .PERIOD d is the checking for checking the slope <sil=0.990> .PERIOD Here the comments <sil=0.590> ,COMMA x is the initial gas <sil=0.400> ,COMMA absolute error is e <sil=0.411> ,COMMA n is the number of iterations <sil=0.949> .PERIOD So <sil=0.574> ,COMMA do in a loop i to n in steps of 2 f x <sil=0.433> ,COMMA f is equal to f x and then f 1 is f prime x <sil=0.904> .PERIOD Now <sil=0.499> ,COMMA these are two functions which you have to write <sil=0.973> .PERIOD And if the now <sil=0.406> ,COMMA why is <sil=0.614> ,COMMA why am I keeping this check <sil=0.970> ?QUESTIONMARK Why am I keeping this check <sil=0.987> ?QUESTIONMARK f 1 which is a slope <sil=0.862> ?QUESTIONMARK If f dash x is too small <sil=0.513> ,COMMA that means what <sil=0.972> ?QUESTIONMARK That the slope is nearly horizontal <sil=0.974> .PERIOD That means <sil=0.437> ,COMMA I am not going to get any suppose something is something like this <sil=0.912> .PERIOD If I come to this point and try to find a slope of this <sil=0.426> ,COMMA the slope will be very horizontal <sil=0.938> .PERIOD So <sil=0.326> ,COMMA this is not a good choice <sil=0.955> .PERIOD In that case <sil=0.534> ,COMMA I have to reduce it and come to a point where I can find a slope <sil=0.957> .PERIOD Now <sil=0.425> ,COMMA in that way I go on and find the whether the it is coming to the close to the root and go on <sil=0.929> .PERIOD Now <sil=0.551> ,COMMA if it goes on <sil=0.539> ,COMMA the iteration goes on <sil=0.438> ,COMMA say for example <sil=0.426> ,COMMA it is possible that I am missing the loop <sil=0.911> .PERIOD Coming close to that <sil=0.344> ,COMMA say a curve like this <sil=0.414> ,COMMA the slope of the curve was such that I was trying to come here and somehow I missed the root <sil=0.945> .PERIOD I go to another point <sil=0.961> .PERIOD So <sil=0.512> ,COMMA that is another special case <sil=0.996> .PERIOD I need not bother you with that right now <sil=0.940> .PERIOD So <sil=0.521> ,COMMA let us have a quick look at the program <sil=0.911> .PERIOD The program will be again <sil=0.928> .PERIOD So <sil=0.488> ,COMMA here we are trying to find out the root of a function x log x <sil=0.945> .PERIOD The function is x log x to the base 10 minus 1 <sil=0.939> .PERIOD 2 <sil=0.942> .PERIOD So <sil=0.392> ,COMMA that is the function <sil=0.906> .PERIOD That function is m body in another c function <sil=0.956> .PERIOD Now <sil=0.421> ,COMMA df is returning <sil=0.630> ,COMMA df is nothing but f dash x <sil=0.955> .PERIOD So <sil=0.345> ,COMMA if this function is given <sil=0.520> ,COMMA I also keep f dash x written <sil=0.983> .PERIOD So <sil=0.574> ,COMMA this is f x <sil=0.514> ,COMMA this is f dash x <sil=0.982> .PERIOD Now <sil=0.324> ,COMMA I know I have already precoded them and that will return with the value for different values of x <sil=0.905> .PERIOD So <sil=0.591> ,COMMA now again I read as can F <sil=0.352> ,COMMA I read the initial x 0 <sil=0.385> ,COMMA the allowed error <sil=0.418> ,COMMA the maximum iteration <sil=0.912> .PERIOD Now <sil=0.492> ,COMMA then in this loop <sil=0.358> ,COMMA what I do <sil=0.875> ?QUESTIONMARK I find f x by f dash x and that is h <sil=0.921> .PERIOD How much I should reduce <sil=0.909> ?QUESTIONMARK How much I should change the initial value <sil=0.958> ?QUESTIONMARK The initial value was x 0 with which I started <sil=0.916> .PERIOD I subtract that and come to the next point <sil=0.909> .PERIOD And if the absolute error is less than absolute value at that point <sil=0.449> ,COMMA if absolute at that point is less than error <sil=0.632> ,COMMA then that is the solution <sil=0.982> .PERIOD Otherwise <sil=0.321> ,COMMA I will go up and repeat this <sil=0.952> .PERIOD Now <sil=0.386> ,COMMA if I go on and ultimately <sil=0.368> ,COMMA if I overshoot the maximum iteration <sil=0.625> ,COMMA then I can say that the required solution does not convert or the iterations are inefficient <sil=0.962> .PERIOD So <sil=0.423> ,COMMA Newton's reaction usually gives us a very fast way of finding the root <sil=0.522> ,COMMA but sometimes it does not converge <sil=0.904> .PERIOD And that is one problem of that <sil=0.980> .PERIOD However <sil=0.515> ,COMMA there are many other sophisticated ways of finding roots <sil=0.434> ,COMMA just to summarize <sil=0.516> ,COMMA I would like to say that what we have learnt in the past couple of lectures is that one of the major technological requirements <sil=0.505> ,COMMA computational requirements are finding roots of polynomials for many solutions or many engineering solutions <sil=1.000> .PERIOD I have to solve equations <sil=0.919> .PERIOD For that <sil=0.531> ,COMMA there are many methods we have just gone through to simpler methods <sil=0.989> .PERIOD One is the bisection method and the other one that we saw just now is the Newton-Raphson method <sil=0.966> .PERIOD Next <sil=0.320> ,COMMA we will look at something else called interpolation and other things <sil=0.946> .PERIOD Thank you <sil=0.968> .PERIOD So <sil=0.331> ,COMMA we have seen the application of the constructs of if then and if else as well as while two-hoyle and four constructs till now we have seen examples in of while and two-hoyle we will see more examples for loops <sil=0.983> .PERIOD For example <sil=0.640> ,COMMA let us also see another application for the application of fall loop <sil=0.945> .PERIOD Say for example <sil=0.639> ,COMMA I want to print I want to add 20 numbers <sil=0.944> .PERIOD I think we have seen such examples we will see more interesting examples a little later <sil=0.588> ,COMMA but before that let us look at some common errors that take place often unintentionally in writing loops and that gives rise to a number of logical problems in a program <sil=0.968> .PERIOD For example <sil=0.510> ,COMMA let us look at this here you can see the first line what will happen the intention was that while sum is less than equal to norm that means it is less than equal to some a particular value may be 20 we are adding sum plus 2 <sil=0.914> .PERIOD What does this mean <sil=0.934> ?QUESTIONMARK Let us try to understand this example forget about this part what would what is the intention of doing this that means suppose <sil=0.426> ,COMMA suppose norm is 10 and sum is 0 <sil=0.952> .PERIOD So <sil=0.565> ,COMMA while sum is less than norm I will be adding sum and 2 <sil=0.962> .PERIOD So <sil=0.595> ,COMMA sum will be sum will be 2 and then sum is still less than norm <sil=0.987> .PERIOD So <sil=0.319> ,COMMA again it will be 4 sum is still less than norm it will be 6 still less than norm it will be 8 still less than equal to norm it will be 10 then still less than equal to norm it will be 12 and then when it goes there it will stop <sil=0.917> .PERIOD So <sil=0.342> ,COMMA what will be the sum sum will be 12 <sil=0.491> ,COMMA but that was my intention of the program <sil=0.321> ,COMMA but unfortunately I have put a semicolon here what does that imply that implies that the entire while statement ends here that means while sum equal to norm do nothing <sil=0.975> .PERIOD So <sil=0.511> ,COMMA there is the end of the statement so nothing has been specified there and whatever sum was there suppose sum was 0 sum will perpetually remain less than 10 or norm and will go on forever <sil=0.986> .PERIOD So <sil=0.650> ,COMMA this semicolon should not be given because the while statement is actually extending up to this point up to this point that is the whole statement <sil=0.947> .PERIOD So <sil=0.332> ,COMMA next example we take is this one for I assign 0 I less than equal to norm plus plus I forget again about this what is the intention of this program what will it do I is 0 and norm was say something like 20 then sum will be added to I <sil=0.918> .PERIOD So <sil=0.580> ,COMMA sum will be 0 then I will be incremented so I will become 1 less than norm it will be added <sil=0.963> .PERIOD So <sil=0.421> ,COMMA sum will now be sum was 0 so sum will now be 1 here was sum sum was 0 sum becomes 1 then sum becomes 2 sum becomes 3 like that it will go on <sil=0.962> .PERIOD However <sil=0.642> ,COMMA since I have put a semicolon here this part is not a part of this for statement consequently this loop is a null loop nothing is being done here and for I equal 0 I less than equal to norm I plus plus do nothing <sil=0.997> .PERIOD So <sil=0.359> ,COMMA nothing will happen here this statement will not be executed here is another type of pitfall where let us study this for I equal to 1 I not equal to 10 I assigned I plus 2 what will happen to this loop <sil=0.944> .PERIOD Can anyone guess I is 1 so sum sum sum has been computed sum is sum plus I sum was 0 so 0 plus 1 sum is 1 then I is incremented to 3 then sum equal sum plus I so sum becomes 4 then this is incremented to 5 after each incrementation I am checking with this condition so I is 5 not equal to 10 fine <sil=0.968> .PERIOD So <sil=0.374> ,COMMA I will add 5 with this so it will become 9 then become 7 I is change to 7 I check with this still not equal to 10 so 7 is added to this 16 this becomes 9 still not equal to 10 so then 9 plus 16 plus 9 maybe 25 and then this is incremented to 11 because I plus 2 still it is not equal to 10 so what will happen it will go on it will never be equal to 10 this means as long as I is I is not equal to 10 you will go on so this will be a case of another infinite loop just as in this case there is a null statement this will be done and then this statement will be done only once here it will be an infinite loop because this condition will never be made so these are some points where we should be very careful about now let us have a very interesting program we want to print this is the condition we want to print we want to print a pattern like this we want to print a pattern like this say 5 stars in a row and 3 such rows so this sort of pattern how can I do that my algorithm will be so I want to print I want to print a row of stars how many 5 stars so how can I print 5 stars in a row if I just write one statement print F star and do not give a backslash M then what will be done a star will be suppose this is my screen alright a star will be printed and if I put it in a loop say for I assign 0 I 5 I want to do less than equal to 5 I plus plus and I do this then what will happen I 0 so once it is printed then I 1 once it is printed again in the same line then again another one so since I am giving a gap what I can do here I can keep a space here star and then a space I show space by blank so exactly a star and a blank will be printed so I 0 I is 1 I is 2 I is 3 I is 4 and then it is incremented and checked I is 5 so less than 5 it will not happen then so this will be a loop after doing that so in a loop I will be printing 1 row then I will give print F I have to come to the next line so I will simply give a backslash M that means I will come to the next line and this again loop I will carry out how many times 3 times because I need 3 rows so what should I do I should do this again loop this 3 times so how should I write it how would that look like now it should be something like this for J J is another variable assign 0 J less than 3 J plus plus for I assign 0 I less than 3 J plus plus for I assign 0 I less than 5 I plus plus and then here print F star followed by a blank and then the code no backslash M at the end of this so after this loop is done then I will do print F backslash M so this part this part will be repeated 3 times <sil=0.940> .PERIOD And in this part it will be this one will be done 5 times so star star star star star will be printed then we will come to the next line and here this is my next for loop so I come to print F and again do the same thing this part star star star star star 5 times this print F by this loop this is print a row printing a row by 5 times and then again I come and do a backslash M I come here and do the same thing 3 times and then come here backslash M and then print stop so print a row of 5 stars and repeat therefore I am repeating this print star 5 times in a loop so that is a very nice interesting application of a fall loop I hope you have understood this <sil=0.951> .PERIOD So here that is exactly what I was showing you look at this here the number of rows and columns have been made a little flexible rows 3 columns 5 now row equal to 1 while row is less than rows printed row of 5 stars this I have done it with the 4 here it is shown using a while so let's see while whether you can understand this also with a while row is 1 now row is less than rows how many rows will do row is less than rows that means as long as it is sorry as long as it is three rows will print a row of 5 and what how do I do a row of 5 I will that we have already shown that how we do it and then we implement the row alright <sil=0.928> .PERIOD So here while row is less than rows print a row of 5 printing a row of 5 is done through in this manner so this is the outer loop this is the outer loop <sil=0.989> .PERIOD Column is 1 while column is less than columns so 5 columns 1 2 3 4 5 why column is less than column print if star and blank and then column is implemented now since I am doing it in a while it is done in this way okay I have already shown you in the earlier this thing how we can do it with 4 I can do the same thing with 4 right <sil=0.945> .PERIOD The same thing with 4 and here it is being shown how it can be done with a while and then I print a fan and do this you can try to understand this again yourself <sil=0.941> .PERIOD Next say here this is being done again in the way that I had written using 4 here only 3 and 5 these things are variable for O equals 1 to row less than equal to 3 plus plus row here it is plus plus row that means first is implemented then column is less than equal to columns why it is less than equal to while if you remember I was when I was doing it here when I was doing it I had less than 3 less than 5 less than 3 less than 5 but here it is being less than equal to 3 less than equal to 5 why because I started my index with 0 and here I am starting my index with 1 all right so this you should be very careful and you should always hand press your program and see whether you have done it correctly if there is a little bit of confusion because this is very important and you should be very careful about it <sil=0.977> .PERIOD So the same thing that I had shown is written again here another 2D figure this is a little more interesting first row we print 1 star second row we print 2 stars third row we print 3 stars fourth row we print 4 stars and then 5 stars so how many stars I will print that is also variable so if we think about that how many times I will print in a row that is also a variable how many times I am doing this so for the first when row is equal to 1 then I am printing 1 star when row is equal to 2 I am printing 2 stars when row is equal to 3 I am printing 3 stars so every time I can also say that I am printing row stars I am printing row stars row number of stars therefore how many times I will do in a loop in the inner loop you could see that when I we had drawn this thrice or twice whatever there was here there is an inner loop 5 times and an outer loop that was doing 2 times right now here what will change it to is inner loop row times outer loop may be 3 times so this is variable okay now let us see how we can program it constant integer rows is 5 that I have not made variable there are 2 integers row and column for row equal to 1 I start with rows row as an index and row less than rows less than 5 plus plus row what do I do column equals 1 I will do up to column less than equal to row so first row column 1 column is less than equal to only once I will print then plus plus column so column becomes 2 but what is my row row is 1 still I am pointing at this row row is 1 so I will do print F now the value of row becomes 2 as an increment but then the column this is the column this is row the column will be less than row because row has become 2 now it is pointing to this row this row so column being less than that I will come out of the first row okay second row what will happen column will start from 1 and row is 2 so column less than row I will print once I will go back here column is becoming 2 and column is still equal less equal to row right not less than but equal to row therefore I will again print here then I will come back here and now column is 3 column is 3 but row is 2 therefore I will not print any longer I will come out of this loop and go here then row will be incremented here all right row has been incremented here and now again column is initialized to 1 for the third row first it is printed incremented column comes here all right then columns column comes here so column is 3 still less than equal equal to row so I print the third one and then it is incremented so the row becomes 4 but my column is sorry the column becomes 4 but row is 3 therefore the column is I go out of the loop and again column is initialized to 1 and my row is incremented to this so that is how it is done you please look at it more carefully and you will have to understand it and this will give you a very clear idea how a nested loop is working so this is one example here what we are trying to do just think of this figure first row is 5 so row is this column is here how long shall I print in the columns keeping the row fixed what will be my logic the logic will be well here I started row with 0 and less than number of rows rows is 5 that is not that important here let us look at this first I will do 5 then I will do 4 but there is another one for the second row I am shifting one space I am shifting this should have been aligned and then I am shifting and giving a space and then doing it so graduates being shifted so let us see what is being done let us look at the first fall loop here this is the outer fall loop let us outer fall loop is up to this and let us see what is happening row is 0 to number of rows less than so I have started with 0 so I did not make it less than equal to it is less than 5 I will do this number of times internally what am I doing this doing here column is 1 and column is less than row because less than equal to row because row is 0 row is 0 and column is 1 look at the trick here the trick that has been applied is column has been in is starting with a value 1 and as long as column is less than row I am printing blank so how many blank should I print for the first column 1 blank then column less than now here from the first column look at this point column equals 1 column less than equal to rows rows is 5 as long as column is less than equal to rows minus row what is my row initially my row is 0 so rows minus row is 5 so column is 1 column is less than equal to 5 plus plus so I do print I do a print and I go on doing this as long as the column is so column is now incremented to 2 3 4 how long will it come for the first row it will come 5 times because rows minus row 5 minus 0 so I will print this and then I will come back this loop is over this loop is over I will print a backslash end up to this sorry I am sorry this for loop is actually extending up to this so from here I go back so I come to the second row so now row becomes 1 let us see now row becomes 1 less than 5 for column equal to 1 column less than equal to row 1 still valid I give 1 blank here 1 blank here for the second row my row pointer has come here row is 1 then I do column 1 2 column minus rows so once blank I have already given so I am now my starting is here how many now row is 1 so 5 minus 1 so that means 4 4 times this will loop and print star and then print FN next time I go back here and this becomes 2 so row 2 to less than 5 column is again now 2 blanks column is 1 2 less than equal to row and row is 2 so 1 to 2 so there will be 2 blanks here 1 blank here 1 blank here so I am coming here and then I am printing this is 2 so 5 minus 2 3 stars so in this way I can go on and print this figure by an intelligent way of applying the fall loops or the nested loops and putting in the spaces together spaces properly I think this gives a very interesting example for you to look at so these are some of the examples that we have seen will come to this 4 thing again later but let us just remind you a little bit about some things that we had mentioned in passing for example this operator plus equal to as for example here a plus equal to b this means a assigned a plus b this is some shortcuts all right a minus equal to b that means a is assigned a minus b here a star b plus 10 a star assigned b plus 10 that means a will be assigned a times b plus 10 so in that way we have got this one also say a assigned b that means a is assigned a divided by b these are some of the shortcuts so this is just to wrap up some of the assignment operations that we had talked about but these are as I said that you can keep this for later use right now more fundamental thing that you need to know is the use of if else for while do while etcetera in the next lecture we will start with a new concept called arrays and there we will find that this loops are becoming so important and we will have many interesting applications using arrays that will be done from next lecture onwards thank you <sil=0.974> .PERIOD In the last class <sil=0.618> ,COMMA last lecture <sil=0.427> ,COMMA we had discussed about variables and values and we explained that variables are mapped by the compiler to different memory locations <sil=0.901> .PERIOD So <sil=0.301> ,COMMA whenever we mention about any variable x <sil=0.598> ,COMMA y or z <sil=0.531> ,COMMA each of them corresponds to a memory location <sil=0.926> .PERIOD Each of them corresponds to a memory location and each of them corresponds to a memory location and whenever we assign some value like say 22 x that means <sil=0.581> ,COMMA in a particular memory location that value is written <sil=0.926> .PERIOD So <sil=0.500> ,COMMA we had done this example once again we quickly go through it that x is being assigned to n t <sil=0.955> .PERIOD So <sil=0.321> ,COMMA the memory location corresponding to x is getting the value 20 where as the memory location corresponding to y can be anything <sil=0.985> .PERIOD When we assign in this statement the value 15 to y then 15 is written in the location corresponding to y <sil=0.961> .PERIOD When we do y plus 3 and assign it to x that means <sil=0.388> ,COMMA actually we are reading this value of y here reading the value of y which is 15 and we are adding 3 with that and we are getting 18 and that 18 is written into this location <sil=0.988> .PERIOD This may appear to be very simple but this way of thinking or way of looking at the things will come in very handy as we will see at later during the later phases of programming <sil=0.979> .PERIOD Now <sil=0.567> ,COMMA here again when we are what is being meant by this statement that the value how will I read it <sil=0.999> ?QUESTIONMARK I will read it like this that the value of x value stored in x that is 18 will be divided by 6 and that result will be stored in y <sil=0.939> .PERIOD So <sil=0.331> ,COMMA x was 18 <sil=0.522> ,COMMA 18 has been divided by 6 and we get 3 and that 3 is written in y <sil=0.952> .PERIOD Now <sil=0.344> ,COMMA here there are a couple of things that what is this 18 <sil=0.933> ?QUESTIONMARK What is this <sil=0.993> ?QUESTIONMARK This 20 these are values and whereas <sil=0.453> ,COMMA these are variables these are also known as constants <sil=0.902> .PERIOD Constance are the values which do not change during the execution of the program <sil=0.918> .PERIOD Next <sil=0.368> ,COMMA we can now we can think of the software <sil=0.994> .PERIOD Now <sil=0.610> ,COMMA you know any computer system consists of hardware as well as software <sil=0.956> .PERIOD So <sil=0.537> ,COMMA we will have some hardware as well as software <sil=0.922> .PERIOD Now <sil=0.597> ,COMMA the hardware is consisting of the CPU <sil=0.360> ,COMMA the memory <sil=0.454> ,COMMA the I O devices all those things are hardware and the software is the instructions that this hardware that is executed by this hardware <sil=0.908> .PERIOD The instructions that are executed by this hardware constitute the software <sil=0.923> .PERIOD Now <sil=0.388> ,COMMA software can be of two types <sil=0.996> .PERIOD For example <sil=0.443> ,COMMA first one is the application software <sil=0.953> .PERIOD Application software is a software that we write <sil=0.996> .PERIOD So <sil=0.632> ,COMMA you can we can just have an idea of this through this onion type of diagram <sil=0.980> .PERIOD At the core we have got the hardware <sil=0.925> .PERIOD The hardware is here and I am putting two layers around this and the user is standing somewhere here and the user is not directly interacting with the hardware <sil=0.969> .PERIOD Why <sil=0.982> ?QUESTIONMARK Because the hardware merely understands 1 and 0s and it is very difficult for the user to write in 1 and 0s <sil=0.923> .PERIOD So <sil=0.647> ,COMMA the user will write in some high level language <sil=0.333> ,COMMA high level language <sil=0.544> ,COMMA HLL in which the user writes and the system automatically converts it into a way that is understood by the hardware <sil=0.948> .PERIOD And what is that automatic way of converting it <sil=0.879> ?QUESTIONMARK We have seen that is compiler is a software <sil=0.965> .PERIOD Compiler is again a software <sil=0.916> .PERIOD A compiler is a software which converts <sil=0.978> .PERIOD So <sil=0.404> ,COMMA before coming to application software let me talk about system software <sil=0.932> .PERIOD So <sil=0.632> ,COMMA we know that when the user has written something in high level language that is converted by a program called compiler into the machine level language or high machine level language which the hardware understands <sil=0.909> .PERIOD So <sil=0.590> ,COMMA the compiler is let us mark it like this is a part of this layer which is the system software <sil=0.973> .PERIOD Similarly <sil=0.365> ,COMMA operating system is another very important software that is lying in this layer internal layer which enables the user to use the computer in a much more user friendly way and in a much more efficient way <sil=0.951> .PERIOD So <sil=0.389> ,COMMA operating system <sil=0.334> ,COMMA compiler <sil=0.439> ,COMMA etc are the core very important elements of the entire computer system without which we cannot we would not be able to use the computer in as efficient way as we do it nowadays <sil=0.963> .PERIOD Now <sil=0.561> ,COMMA given this hardware and this layer of operating system and compiler and other systems software <sil=0.932> .PERIOD Now <sil=0.354> ,COMMA we are in a position to write some programs for our day to day use <sil=0.904> .PERIOD For example <sil=0.352> ,COMMA a company wants to find out the salary information of the people they can use some payroll software here or for example <sil=0.416> ,COMMA you want to design some data analysis software that will take some data and using a particular software will analyze the data statistically and give you some good insights <sil=0.979> .PERIOD So <sil=0.483> ,COMMA all those things the user is writing and they are forming the application software <sil=0.944> .PERIOD So <sil=0.304> ,COMMA most of the time the programmers who are not systems programmers not the system designers but just users they mostly use the application software <sil=0.906> .PERIOD Given this <sil=0.637> ,COMMA we come to a very important software which we just now mentioned that is an operating system <sil=0.953> .PERIOD Now <sil=0.474> ,COMMA you know that you are aware of the typical operating systems like windows <sil=0.616> ,COMMA linux or unix <sil=0.975> .PERIOD Nowadays appless becoming popular <sil=0.549> ,COMMA macways all these things are operating systems <sil=0.935> .PERIOD Now <sil=0.430> ,COMMA what is the operating system <sil=0.937> ?QUESTIONMARK The operating system is a layer around the hardware which enables a user to use the software <sil=0.637> ,COMMA use the computer system and sorry <sil=0.515> ,COMMA use the system in a much more user friendly way <sil=0.952> .PERIOD Now <sil=0.444> ,COMMA there are different varieties of operating system <sil=0.645> ,COMMA single user operating system <sil=0.312> ,COMMA multi user operating system etcetera <sil=0.974> .PERIOD Now <sil=0.618> ,COMMA this operating system also activates another system software that we have talked about that is a compiler <sil=0.940> .PERIOD The operating system will call or will activate the software system software called the compiler when you want to run a high level program <sil=0.902> .PERIOD Given this background <sil=0.481> ,COMMA let us now move to discussion on programming <sil=0.971> .PERIOD We know by now that programming means we have to express our intention of solving a problem by executing a number of steps <sil=0.926> .PERIOD And those number of steps once again <sil=0.451> ,COMMA you know that by now <sil=0.543> ,COMMA we start with the algorithm and that algorithm can be expressed in different ways like pseudo code or flow chart <sil=0.936> .PERIOD And then the programmer actually writes them in a high level language <sil=0.369> ,COMMA some high level language <sil=0.952> .PERIOD Now <sil=0.322> ,COMMA what we are going to discuss now is a particular high level language which is called C <sil=0.950> .PERIOD We are taking C just as an example of an high level language <sil=0.922> .PERIOD Because <sil=0.341> ,COMMA we have to express the logic in the form of some high level language <sil=0.465> ,COMMA we are taking C as an example <sil=0.916> .PERIOD And as I have mentioned earlier that the logic <sil=0.627> ,COMMA the style and the philosophy remains more or less the same across different programming languages like Java <sil=0.388> ,COMMA C++ and others <sil=0.973> .PERIOD Of course <sil=0.359> ,COMMA C is the simplest to start with <sil=0.981> .PERIOD Let us see <sil=0.927> .PERIOD Now <sil=0.547> ,COMMA we are using the term language <sil=0.999> .PERIOD Think of a human language <sil=0.937> .PERIOD Any language is constituted of some vocabulary <sil=0.937> .PERIOD The vocabulary <sil=0.335> ,COMMA say for example <sil=0.523> ,COMMA in English <sil=0.595> ,COMMA the vocabulary consists of some words <sil=0.927> .PERIOD Different words like say bird is a valid word in the English vocabulary <sil=0.939> .PERIOD Now <sil=0.459> ,COMMA but if I had written RBID that is possibly not a valid word in the English language vocabulary <sil=0.978> .PERIOD Now <sil=0.408> ,COMMA we have got some valid words <sil=0.908> .PERIOD Similarly <sil=0.428> ,COMMA C will also have some valid words which we will see through which we can express the basic elements of a C program <sil=0.918> .PERIOD Just as English sentence is built using English valid English words otherwise the meaning will not be understood <sil=0.922> .PERIOD In the case of C programming language say C will have its own vocabulary <sil=0.965> .PERIOD The words valid in C <sil=0.922> .PERIOD Now <sil=0.333> ,COMMA if I had written some word in English that is some string <sil=0.368> ,COMMA some pattern in English like RBID that unless this has got some special meaning this will not be and if this is a part of a sentence this will not be very clearly understood by anybody <sil=0.998> .PERIOD Now <sil=0.381> ,COMMA when I have written a C program who is going to understand this for whom am I writing this C program <sil=0.862> ?QUESTIONMARK I am writing this C program for the compiler C compiler <sil=0.996> .PERIOD I am writing it for the C compiler and the C compiler is responsible to understand this <sil=0.934> .PERIOD And just as we understand an English sentence open the door <sil=0.928> .PERIOD So <sil=0.488> ,COMMA we understand the meaning of that sentence we go and execute that we open the door <sil=0.906> .PERIOD Similarly <sil=0.498> ,COMMA in C if we write something unless the compiler understands this it will not be able to convert it to the machine language which will be executed by the hardware or the computer <sil=0.907> .PERIOD So <sil=0.445> ,COMMA the C program must constitute of valid C words and we will see what are the valid words and what are the rules for that <sil=0.985> .PERIOD Now <sil=0.600> ,COMMA the next thing if I write a particular sentence I saw a bird that is a valid English sentence <sil=0.965> .PERIOD Why is it valid <sil=0.851> ?QUESTIONMARK Because it is grammatically correct and also it is carrying a very clear meaning it is a meaningful sentence <sil=0.924> .PERIOD So <sil=0.575> ,COMMA this is both correct grammatically by grammar and also it is meaningful <sil=0.982> .PERIOD Now <sil=0.568> ,COMMA suppose I wrote it wrote something like I seize a bird <sil=0.924> .PERIOD Now <sil=0.307> ,COMMA this is grammatically wrong <sil=0.972> .PERIOD However <sil=0.488> ,COMMA it conveys some meaning I understand that the person who wrote this is weak in grammar he is not very much conversant with the subject verb agreement but still I can make a meaning out of it <sil=0.919> .PERIOD On the other hand for a compiler if I write a C sentence let me call it not say sentence let me call it C statement <sil=0.953> .PERIOD Now <sil=0.334> ,COMMA a C statement that means the statement in the language C will consist of some valid words in C and also it will have to follow some grammatical rules of C <sil=0.934> .PERIOD Unfortunately <sil=0.564> ,COMMA here although it is grammatically wrong I could understand the meaning of this but a C statement if it is grammatically wrong grammatically according to the grammar of C <sil=0.996> .PERIOD If it is not in tune with the grammar of C then it is grammatically wrong and since this C sentence will be interpreted not by a human being but by a machine a computer however smart it may look like is basically not as intelligent as human beings <sil=0.950> .PERIOD So <sil=0.497> ,COMMA that as of now so whatever we can make out the meaning out of it a compiler C program will not the compiler will not be able to make out correspondingly the correct machine language cannot be generated <sil=0.933> .PERIOD Therefore <sil=0.574> ,COMMA if there is something that is grammatically wrong according to C grammar that will be indicated marked by the compiler as a syntax error <sil=0.951> .PERIOD So <sil=0.511> ,COMMA unless we write something in the correct syntax there is always a chance of it will it not not there will there is always a chance it will obviously lead to a syntax error and the compiler will not produce the corresponding machine code <sil=0.952> .PERIOD So <sil=0.487> ,COMMA we are now supposed to learn what is therefore <sil=0.459> ,COMMA we need to know what are the valid words in C and what are the correct grammatical structures in C <sil=0.933> .PERIOD Now <sil=0.332> ,COMMA if we learn both these we learn the C language <sil=0.942> .PERIOD Similarly <sil=0.342> ,COMMA if you want to learn any other language computer language you have to exactly know these things what are the valid words in that language and what is the correct grammatical structure in that language <sil=0.955> .PERIOD So <sil=0.557> ,COMMA given this we will start looking at C programs even before that we are once again recapitulate whatever we are expressing we are expressing them using some variables constant and constants right and the variables have got we have shown x <sil=0.419> ,COMMA y <sil=0.522> ,COMMA z etc etc variables <sil=0.973> .PERIOD So <sil=0.500> ,COMMA each of these variables which are nothing but memory locations are being given some names right <sil=0.999> .PERIOD So <sil=0.356> ,COMMA we have to give some names of the variables all right there are some rules for naming them just as in English we start a proper name of the variables all right there are some rules for naming them just as in English we start a proper noun with a capital letter Ravana all right Ceta we write them with a capital letter this is the rule of English however if you write in any Indian language say you write anything ummer you write that there is no question of any capital letter here <sil=0.346> ,COMMA but it is a it is a property of English it is a rule of English that the capital first later of a proper noun must start with a capital letter similarly for naming the variables in C there are some rules <sil=0.961> .PERIOD So <sil=0.568> ,COMMA here we have seen x <sil=0.451> ,COMMA y <sil=0.530> ,COMMA z etc these are the variables <sil=0.967> .PERIOD So <sil=0.548> ,COMMA there are some rules for naming the variables we will come back to this again <sil=0.471> ,COMMA but first of all any string of alphabets say let me introduce one word alpha numeric alphanumeric means what <sil=0.877> ?QUESTIONMARK Alphabets and what are the English alphabets <sil=0.982> ?QUESTIONMARK A <sil=0.430> ,COMMA B <sil=0.519> ,COMMA C up to z small letter A <sil=0.629> ,COMMA B <sil=0.644> ,COMMA C up to z that is alphabet and numerals we know 0 to 9 all right 0 <sil=0.377> ,COMMA 1 <sil=0.308> ,COMMA 2 <sil=0.540> ,COMMA 3 up to 9 <sil=0.911> .PERIOD Now <sil=0.352> ,COMMA an alphanumeric means a union of both these either alphabet or numerals <sil=0.967> .PERIOD So <sil=0.626> ,COMMA a variable name in C can can consist of any alphanumeric character <sil=0.908> .PERIOD Now <sil=0.570> ,COMMA so it can be say apple is a valid variable name in C again if I start with small A this is also valid variable name in C <sil=0.308> ,COMMA but although these two are same since I have put in different characters one one capital one small these two will be treated as two separate variable names all right <sil=0.908> .PERIOD Similarly <sil=0.541> ,COMMA I can write say apple one two that is also a valid variable name <sil=0.940> .PERIOD Now <sil=0.387> ,COMMA there are some special characters like underscore that is allowed like I could have written something like this apple underscore one two that is also a valid variable name <sil=0.918> .PERIOD However <sil=0.620> ,COMMA I cannot start a variable name with a digit or a number for example <sil=0.506> ,COMMA one two apple is not a variable valid variable name other special characters like say apple percentage is not a valid variable name <sil=0.968> .PERIOD So <sil=0.611> ,COMMA these are some of the rules <sil=0.964> .PERIOD So <sil=0.529> ,COMMA the what are the rules of naming a C variable it can consist of any alphanumeric character any length <sil=0.562> ,COMMA but it must start with an alphabet and only some specific special characters like the underscores allowed others are not <sil=0.976> .PERIOD So <sil=0.646> ,COMMA this is not allowed <sil=0.371> ,COMMA but say apple bob three four this is a valid name <sil=0.972> .PERIOD So <sil=0.398> ,COMMA here I can use as again a p p a le b small o small b this is also valid name <sil=0.993> .PERIOD So <sil=0.418> ,COMMA in general what is the rule I can have a string of alphanumeric character starting with an alphabet and having no special characters except for this underscores <sil=0.971> .PERIOD So <sil=0.499> ,COMMA with that that is how we will name the variables and each variable I again repeat you know that a variable essentially consists of memory locations <sil=0.991> .PERIOD A variable is nothing <sil=0.468> ,COMMA but a memory location and we are putting the name to that particular memory memory location <sil=0.980> .PERIOD So <sil=0.647> ,COMMA if apple be this memory location may be a p p a le is another memory location <sil=0.982> .PERIOD Now <sil=0.583> ,COMMA which variable we will go to which memory location is decided by the compiler <sil=0.985> .PERIOD So <sil=0.311> ,COMMA might be bob is another one <sil=0.953> .PERIOD So <sil=0.447> ,COMMA these are separate memory locations <sil=0.978> .PERIOD So <sil=0.566> ,COMMA variables and naming of variables is a fundamental step in writing a C program because whatever we write we have to write them through variables <sil=0.973> .PERIOD Now <sil=0.512> ,COMMA quickly once again we look at this that whenever we are writing suppose again I am writing now suppose there are three numbers A B C or I want to find the average of that <sil=0.966> .PERIOD So <sil=0.381> ,COMMA I can write it in the form of say and say average you can see that average is a valid valid name in the case of a variable <sil=0.966> .PERIOD So <sil=0.374> ,COMMA I can say AVG is A plus B plus C whole thing divided by 3 <sil=0.992> .PERIOD Now <sil=0.313> ,COMMA this one I can call to be a C sentence or I am saying sentence so that you can have an analogy with our English <sil=0.406> ,COMMA but we will call it C statement <sil=0.995> .PERIOD And this C statement consists of several things we will come to the other things <sil=0.428> ,COMMA but you can see that we are it is consisting of 1 2 3 4 variables and one constant that is 3 <sil=0.946> .PERIOD And there are some special parenthesis and all these are also valid symbols in C and these are operators <sil=0.957> .PERIOD So <sil=0.453> ,COMMA we will see how our C statement is constituted <sil=0.487> ,COMMA but whenever we write a C statement it will consist of a number of variables <sil=0.903> .PERIOD Now <sil=0.302> ,COMMA coming to a C program a C program consists of a set of in let me call it a number of maybe 1 <sil=0.625> ,COMMA but at least 1 number of functions <sil=0.967> .PERIOD What are functions <sil=0.950> ?QUESTIONMARK There is a significance of this term functions <sil=0.370> ,COMMA but for the time being let us simply try to visualize it in this way that I am trying to build a machine which will do something <sil=0.944> .PERIOD What we will do <sil=0.853> ?QUESTIONMARK Say for example <sil=0.466> ,COMMA it is a machine that will take say 2 or 3 numbers A <sil=0.440> ,COMMA B <sil=0.581> ,COMMA C and will produce the average <sil=0.950> .PERIOD Now <sil=0.492> ,COMMA this is a machine <sil=0.973> .PERIOD It does something take some input and gives some output <sil=0.993> .PERIOD Now <sil=0.543> ,COMMA this entire machine can be built up with smaller sub machines <sil=0.930> .PERIOD And one machine each of these sub submachines can do some specific task <sil=0.977> .PERIOD For example <sil=0.448> ,COMMA if I take a complicated say paper rolling machine then there are so many things to be done in order to roll out or prepare papers <sil=0.967> .PERIOD So <sil=0.534> ,COMMA similarly there can be different sub machines which are doing different functions <sil=0.986> .PERIOD So <sil=0.345> ,COMMA each of them each of these sub machines are carrying out different functions are carrying out different functions <sil=0.962> .PERIOD This is doing one one <sil=0.620> ,COMMA this is doing another and all these three together is doing something <sil=0.904> .PERIOD Now <sil=0.368> ,COMMA as I said in the worst in a special case just like for a simple case of average I may not need many sub modules because I can very well take A <sil=0.634> ,COMMA B and C here A <sil=0.437> ,COMMA B and C <sil=0.939> .PERIOD And simply in this machine I can write a program like AVG is equal to A plus B plus C divided by 3 and that will be the output <sil=0.952> .PERIOD So <sil=0.481> ,COMMA here I do not need any sub machines because it is a simple problem <sil=0.940> .PERIOD But nevertheless I need at least one function that is what is this task is being done <sil=0.954> .PERIOD So <sil=0.475> ,COMMA any C program will require at least one function and in many cases we will see it will require more number of functions <sil=0.967> .PERIOD We will come to this in the next lecture <sil=0.919> .PERIOD Welcome <sil=0.495> ,COMMA in the last lecture we had looked at the nested Eiffel structure <sil=0.937> .PERIOD Today we will continue with that discussion <sil=0.975> .PERIOD So <sil=0.623> ,COMMA here is an example that uses the nested Eiffel structure <sil=0.953> .PERIOD Here you can see again let us come to the programming fundamentals in C <sil=0.912> .PERIOD We have got just for revision <sil=0.904> .PERIOD We start with an include stdi <sil=0.974> .PERIOD h and then we have got the main function <sil=0.978> .PERIOD Inside the main function we declare three variables A <sil=0.343> ,COMMA B and C and probably you might have guessed now that we are again trying to find out our I mean the maximum of the three integers A <sil=0.460> ,COMMA B and C <sil=0.961> .PERIOD So <sil=0.550> ,COMMA what are we doing next <sil=0.998> ?QUESTIONMARK We are first reading the three numbers from the keyboard <sil=0.960> .PERIOD scanf percentage d <sil=0.627> ,COMMA percentage d <sil=0.640> ,COMMA percentage d <sil=0.412> ,COMMA then A <sil=0.306> ,COMMA B and C preceded with an ampere sand <sil=0.909> .PERIOD And you know why this ampere sand is used <sil=0.970> ?QUESTIONMARK That is the address of the location A <sil=0.496> ,COMMA B and C <sil=0.924> .PERIOD Now comes the main logic <sil=0.925> .PERIOD Here if A is greater than equal to B <sil=0.310> ,COMMA A is 25 <sil=0.608> ,COMMA B is 20 <sil=0.995> .PERIOD So <sil=0.474> ,COMMA if A is greater than equal to B <sil=0.467> ,COMMA then I check whether C A is greater than C <sil=0.962> .PERIOD So <sil=0.577> ,COMMA this is passed then I check this <sil=0.982> .PERIOD So <sil=0.598> ,COMMA if A is greater than B <sil=0.564> ,COMMA then I proceed to do if A is greater than equal to C <sil=0.971> .PERIOD If that is also true <sil=0.468> ,COMMA then we print the largest number is A <sil=0.983> .PERIOD Otherwise <sil=0.450> ,COMMA what we do not know as yet <sil=0.906> .PERIOD So <sil=0.317> ,COMMA if A is greater than B <sil=0.416> ,COMMA A is 25 <sil=0.440> ,COMMA B is 20 <sil=0.915> ,COMMA C is 15 <sil=0.942> .PERIOD In that case <sil=0.471> ,COMMA A is greater <sil=0.948> .PERIOD But suppose C is 30 <sil=0.491> ,COMMA then what happens <sil=0.865> ?QUESTIONMARK A is greater than B true <sil=0.966> .PERIOD Then I come and compare A is greater than C <sil=0.300> ,COMMA this part <sil=0.948> .PERIOD No <sil=0.643> ,COMMA false <sil=0.982> .PERIOD Therefore <sil=0.584> ,COMMA this L is with respect to this nearest if that we learnt in the earlier lecture <sil=0.976> .PERIOD So <sil=0.642> ,COMMA if this fails <sil=0.517> ,COMMA then we print the largest number is C <sil=0.511> ,COMMA because A was greater than B <sil=0.533> ,COMMA but A is not greater than C <sil=0.957> .PERIOD Therefore <sil=0.435> ,COMMA C must be the largest <sil=0.911> .PERIOD Now <sil=0.623> ,COMMA if A is not greater than B <sil=0.304> ,COMMA suppose A is 20 and B is 25 <sil=0.922> .PERIOD Then A greater than B <sil=0.530> ,COMMA this fails <sil=0.624> ,COMMA then I am not entering this block at all <sil=1.000> .PERIOD I am straight way going to this else <sil=0.931> .PERIOD Then I am checking A is not greater than B <sil=0.599> ,COMMA but therefore <sil=0.461> ,COMMA B must be greater than or equal to A or not even equal to B must be greater than A <sil=0.976> .PERIOD Then I check if B is greater than C <sil=0.981> .PERIOD Suppose <sil=0.599> ,COMMA B is greater than C <sil=0.413> ,COMMA then the largest number is B <sil=0.946> .PERIOD Otherwise <sil=0.548> ,COMMA if that is not so <sil=0.326> ,COMMA B is not greater than C <sil=0.952> .PERIOD Suppose C was 30 <sil=0.425> ,COMMA then this else will come <sil=0.429> ,COMMA because this if will fail <sil=0.978> .PERIOD Therefore <sil=0.356> ,COMMA I will print again the largest number is C <sil=0.982> .PERIOD So <sil=0.548> ,COMMA I suggest you to work it out yourself <sil=0.968> .PERIOD And I can also write the same thing if you consider that this <sil=0.509> ,COMMA if A is greater than B <sil=0.439> ,COMMA then if A is greater than equal to C <sil=0.941> .PERIOD Tell me <sil=0.304> ,COMMA if I write it in this way <sil=0.380> ,COMMA if A is greater than equal to C and and that means <sil=0.534> ,COMMA and A is sorry here <sil=0.476> ,COMMA I write A is greater than equal to B and A is greater than equal to C <sil=0.614> ,COMMA print F this line <sil=0.921> .PERIOD Largest is E <sil=0.435> ,COMMA else print F largest is C <sil=0.907> .PERIOD So <sil=0.627> ,COMMA do you think that these two are equivalent <sil=0.882> ?QUESTIONMARK These two nested F's and this logical operator <sil=0.991> .PERIOD Now <sil=0.590> ,COMMA here I should have put a parenthesis here <sil=0.923> .PERIOD Please note <sil=0.522> ,COMMA I need a parenthesis here <sil=0.967> .PERIOD It is better that if I put it <sil=0.358> ,COMMA it becomes much clearer <sil=0.947> .PERIOD Are these two equivalent <sil=0.971> ?QUESTIONMARK If you just think of while <sil=0.349> ,COMMA you will find yes <sil=0.318> ,COMMA they are equivalent <sil=0.646> ,COMMA because I am computing this and then I am computing this <sil=0.981> .PERIOD If this any one of this is false <sil=0.576> ,COMMA I will not be executing this statement <sil=0.948> .PERIOD So <sil=0.431> ,COMMA this is an example of nested F <sil=0.981> .PERIOD We can have many such examples <sil=0.967> .PERIOD Let me give you one example <sil=0.931> .PERIOD Let us work out right now <sil=0.974> .PERIOD Suppose <sil=0.633> ,COMMA I am trying to see if a figure is a triangle or a square <sil=0.526> ,COMMA order rectangle <sil=0.628> ,COMMA or a 4 sided figure <sil=0.451> ,COMMA whether it is a triangular figure or a quadrilateral figure <sil=0.917> .PERIOD And if it is a triangular figure <sil=0.608> ,COMMA then I want to see whether it is isosceles <sil=0.623> ,COMMA that means <sil=0.326> ,COMMA two sides are equal or it is not isosceles <sil=0.995> .PERIOD Suppose <sil=0.351> ,COMMA that is what I want to do <sil=0.999> .PERIOD So <sil=0.629> ,COMMA how can I proceed to do that <sil=0.969> ?QUESTIONMARK Why would I write the logic <sil=0.986> ?QUESTIONMARK Let me just only write the relevant part <sil=0.909> .PERIOD I have done some the declarations are here <sil=0.938> .PERIOD And then I have done scan F <sil=0.439> ,COMMA percentage the number of sides <sil=0.917> .PERIOD Number of sides is a variable <sil=0.995> .PERIOD And then I also <sil=0.316> ,COMMA then what I can do <sil=0.984> ?QUESTIONMARK I check if it is a number of sides is equal to 3 <sil=0.582> ,COMMA then I will be doing something <sil=0.932> .PERIOD Because <sil=0.531> ,COMMA in that case it will be a triangle <sil=0.980> .PERIOD Then what do I do <sil=0.976> ?QUESTIONMARK I then read that is scan F <sil=0.917> .PERIOD The three sides of the triangle <sil=0.367> ,COMMA percentage D and suppose all the sides are integer has got all the sides have integer values <sil=0.949> .PERIOD Five <sil=0.380> ,COMMA six <sil=0.540> ,COMMA five something of that sort <sil=0.907> .PERIOD That is why I am putting percentage D <sil=0.977> .PERIOD Then I am reading the three sides and B and C <sil=0.935> .PERIOD Same equal to <sil=0.969> .PERIOD If A is same as B or you remember this is the logical or or A is the same equal to C or B is equal to C <sil=0.975> .PERIOD Then what can I say print F <sil=0.936> ?QUESTIONMARK EAT is ISO cellless <sil=0.994> .PERIOD Backslash end as our common practices <sil=0.949> .PERIOD If any of these conditions are true <sil=0.456> ,COMMA either this is equal to this or this is equal to this or this is equal to this <sil=0.907> .PERIOD Then it is ISO cellless <sil=0.957> .PERIOD Else <sil=0.302> ,COMMA I will print I am writing in brief <sil=0.945> .PERIOD Not ISO cellless <sil=0.957> .PERIOD You can write in a much better way <sil=0.916> .PERIOD Remember this double course <sil=0.962> .PERIOD We complete this <sil=0.950> .PERIOD Now <sil=0.369> ,COMMA that is the complete this <sil=0.964> .PERIOD Now <sil=0.463> ,COMMA this is the if part <sil=0.979> .PERIOD If the number of sides is three <sil=0.988> .PERIOD If the number of sides is not three <sil=0.624> ,COMMA then I do not do anything <sil=0.996> .PERIOD I will come at this point because this if you will fail <sil=0.594> ,COMMA I will come at this point <sil=0.918> .PERIOD I can say here <sil=0.944> .PERIOD Can I write here print F <sil=0.962> ?QUESTIONMARK Not a triangle <sil=0.976> .PERIOD Can I do this <sil=0.883> ?QUESTIONMARK Just think because here I have checked that the number of sides is three <sil=0.994> .PERIOD If it is number of sides is three <sil=0.587> ,COMMA I will do this and print <sil=0.903> .PERIOD Otherwise <sil=0.449> ,COMMA I write it here <sil=0.999> .PERIOD Is it all right <sil=0.954> ?QUESTIONMARK If you look at it <sil=0.625> ,COMMA you will see that there is a problem here <sil=0.989> .PERIOD If the number of sides is three and then it takes whether it is ISO cellless or not <sil=0.614> ,COMMA and then it comes out and again prints is not a triangle <sil=0.972> .PERIOD I do not want that <sil=0.965> .PERIOD So <sil=0.357> ,COMMA what should I do <sil=0.874> ?QUESTIONMARK How can I avoid this problem <sil=0.976> ?QUESTIONMARK Here <sil=0.505> ,COMMA you must have guessed now <sil=0.931> .PERIOD Here <sil=0.557> ,COMMA I have to put an else that goes with this if <sil=0.917> .PERIOD And then if this is not true <sil=0.308> ,COMMA then only this will be executed <sil=0.980> .PERIOD Otherwise <sil=0.321> ,COMMA some point down the line here will be executed <sil=0.975> .PERIOD Another thing that I would like to mention in this case <sil=0.955> .PERIOD Look at the use of this parenthesis <sil=0.960> .PERIOD Why was this parenthesis required <sil=0.965> ?QUESTIONMARK Because I had more than one statements for this if condition <sil=0.965> .PERIOD If this condition is true <sil=0.634> ,COMMA then there are more than one statements <sil=0.902> .PERIOD Now <sil=0.554> ,COMMA here is a puzzle <sil=0.984> .PERIOD How many statements are there <sil=0.982> ?QUESTIONMARK Inside this block <sil=0.327> ,COMMA how many statements are there <sil=0.985> ?QUESTIONMARK One <sil=0.325> ,COMMA two <sil=0.422> ,COMMA three <sil=0.455> ,COMMA four <sil=0.975> .PERIOD Let us see <sil=0.993> .PERIOD Here is one statement <sil=0.453> ,COMMA scan F <sil=0.992> .PERIOD So <sil=0.477> ,COMMA one <sil=0.928> .PERIOD And then this if statement <sil=0.571> ,COMMA you see <sil=0.611> ,COMMA goes up to this <sil=0.927> .PERIOD So <sil=0.315> ,COMMA that is one statement <sil=0.554> ,COMMA but here I am using <sil=0.535> ,COMMA I said that E fells is a structure <sil=0.939> .PERIOD So <sil=0.345> ,COMMA this entire thing is a statement <sil=0.919> .PERIOD So <sil=0.617> ,COMMA actually I have got two statements <sil=0.930> .PERIOD Since I have got more than one statement <sil=0.316> ,COMMA I had to put this braces <sil=0.970> .PERIOD Now <sil=0.495> ,COMMA suppose of course <sil=0.634> ,COMMA then the program will not work here <sil=0.942> .PERIOD Suppose <sil=0.564> ,COMMA I had not written this statement <sil=0.942> .PERIOD This statement was not there <sil=0.927> .PERIOD This statement was not there <sil=0.979> .PERIOD In that case <sil=0.491> ,COMMA I could have done away with this braces <sil=0.925> .PERIOD Because then <sil=0.366> ,COMMA within this if statement <sil=0.501> ,COMMA there is one statement only <sil=0.959> .PERIOD This brace was not essential <sil=0.992> .PERIOD So <sil=0.430> ,COMMA you could see this <sil=0.905> .PERIOD And you can practice and in the assignment <sil=0.585> ,COMMA we will also give few programs that you have to do using this sort of if else type of structure <sil=0.956> .PERIOD So <sil=0.607> ,COMMA now <sil=0.468> ,COMMA here is the example that we did <sil=0.969> .PERIOD Now <sil=0.437> ,COMMA there is a problem here <sil=0.959> .PERIOD There is a danger <sil=0.498> ,COMMA I would rather say <sil=0.966> .PERIOD You have seen earlier <sil=0.342> ,COMMA when I was writing <sil=0.398> ,COMMA I was writing if if A is equal to B <sil=0.922> .PERIOD Then <sil=0.426> ,COMMA I was doing something <sil=0.921> .PERIOD Now <sil=0.584> ,COMMA this is very important that is a common point of source of common source of error that often because we have learnt to say equal to like this <sil=0.589> ,COMMA it will we can write in this way <sil=0.917> .PERIOD Now <sil=0.328> ,COMMA the problem is if I write it in this way <sil=0.648> ,COMMA when a compiler looks at this <sil=0.521> ,COMMA what will it assume <sil=0.921> ?QUESTIONMARK It will see that is an if <sil=0.980> .PERIOD Often <sil=0.638> ,COMMA you will not find that it will cause an error <sil=0.911> .PERIOD Because what the compiler will think is <sil=0.549> ,COMMA well <sil=0.330> ,COMMA what is the meaning of this <sil=0.916> ?QUESTIONMARK A <sil=0.383> ,COMMA this means A is assigned the value of B <sil=0.931> .PERIOD So <sil=0.516> ,COMMA it will try to successfully <sil=0.304> ,COMMA it will try to transfer <sil=0.505> ,COMMA copy the value of B to A <sil=0.974> .PERIOD And <sil=0.461> ,COMMA this operation will be executed successfully <sil=0.909> .PERIOD Now <sil=0.306> ,COMMA if the expression is computed successfully <sil=0.352> ,COMMA what does it return <sil=0.972> ?QUESTIONMARK If you recall <sil=0.568> ,COMMA it returns of 1 and 1 means 2 <sil=0.980> .PERIOD That means <sil=0.637> ,COMMA this condition will evaluate to 2 <sil=0.991> .PERIOD I once again repeat <sil=0.951> .PERIOD Now <sil=0.401> ,COMMA we can use any expression that produces a value in the control structure <sil=0.998> .PERIOD Now <sil=0.419> ,COMMA if it be a non-zero value <sil=0.468> ,COMMA then it is true and 0 value is false <sil=0.917> .PERIOD So <sil=0.332> ,COMMA if I write if a plus b plus c <sil=0.506> ,COMMA printf a else printf b <sil=0.629> ,COMMA what will happen <sil=0.928> ?QUESTIONMARK A plus b plus c is <sil=0.307> ,COMMA if they will be just be added <sil=0.322> ,COMMA but there will be no assignment <sil=0.969> .PERIOD Suppose <sil=0.629> ,COMMA I make it more meaningful <sil=0.967> .PERIOD Suppose <sil=0.441> ,COMMA I make it z <sil=0.403> ,COMMA z assigned <sil=0.470> ,COMMA I make it this <sil=0.955> .PERIOD I write z assigned a plus b plus c <sil=0.909> .PERIOD Then <sil=0.633> ,COMMA this <sil=0.424> ,COMMA there is a problem here <sil=0.922> ,COMMA because there is no semicolon here <sil=0.914> .PERIOD So <sil=0.645> ,COMMA this will be <sil=0.494> ,COMMA suppose I do this <sil=0.973> .PERIOD Now <sil=0.379> ,COMMA this will be computed <sil=0.631> ,COMMA and this assignment will be done successfully <sil=0.989> .PERIOD So <sil=0.537> ,COMMA anything that is done successfully <sil=0.565> ,COMMA will return this will be equivalent to f 1 <sil=0.965> .PERIOD If 1 means it is true and so <sil=0.594> ,COMMA what will be printed <sil=0.858> ?QUESTIONMARK Printf a will be executed <sil=0.649> ,COMMA this will be printed <sil=0.911> .PERIOD Now <sil=0.624> ,COMMA similarly <sil=0.307> ,COMMA I can say <sil=0.526> ,COMMA let us see <sil=0.598> ,COMMA I just write if there and something <sil=0.948> .PERIOD What does this mean <sil=0.890> ?QUESTIONMARK Semicolon <sil=0.568> ,COMMA nothing before this <sil=0.462> ,COMMA we call it a null statement <sil=0.997> .PERIOD That means <sil=0.649> ,COMMA I have not said anything meaningful <sil=0.646> ,COMMA but it is still a statement <sil=0.535> ,COMMA remaining silent is sometimes a set statement <sil=0.925> .PERIOD Now <sil=0.480> ,COMMA this means that this is always true <sil=0.319> ,COMMA this will always be true <sil=0.960> .PERIOD So <sil=0.417> ,COMMA this is equivalent to f 1 <sil=0.976> .PERIOD This <sil=0.520> ,COMMA that means always you do this statement <sil=0.496> ,COMMA whatever is here <sil=0.315> ,COMMA you do it always <sil=0.935> .PERIOD So <sil=0.365> ,COMMA this is a interesting thing in C <sil=0.998> .PERIOD However <sil=0.394> ,COMMA sometimes you know <sil=0.318> ,COMMA it varies with the compilers also <sil=0.990> .PERIOD Some compilers take care of such situations and may give you a warning <sil=0.963> .PERIOD Some very few compilers can also give an error <sil=0.962> .PERIOD Now <sil=0.468> ,COMMA let us look at this example <sil=0.972> .PERIOD Sorry <sil=0.457> ,COMMA this example <sil=0.347> ,COMMA if pay code is equal to 4 <sil=0.424> ,COMMA what does this mean <sil=0.959> ?QUESTIONMARK This means if the pay code is 4 <sil=0.443> ,COMMA this is a logical equality <sil=0.922> .PERIOD If this is true <sil=0.422> ,COMMA then you will print <sil=0.578> ,COMMA you will get a bonus <sil=0.950> .PERIOD Now <sil=0.514> ,COMMA instead of <sil=0.491> ,COMMA so <sil=0.357> ,COMMA I want to do like this <sil=0.474> ,COMMA this means that I am coming here <sil=0.398> ,COMMA I am checking pay code in non-sea language is pay code 4 <sil=0.985> .PERIOD Yes <sil=0.632> ,COMMA I do something <sil=0.497> ,COMMA no <sil=0.323> ,COMMA I do something else <sil=0.942> .PERIOD But <sil=0.326> ,COMMA if I had written it in this way <sil=0.458> ,COMMA what would it mean <sil=0.913> ?QUESTIONMARK If pay code assigned 4 <sil=0.473> ,COMMA now pay code <sil=0.553> ,COMMA being a <sil=0.516> ,COMMA suppose pay code is an integer type of variable <sil=0.536> ,COMMA then this can be assigned the value 4 successfully <sil=0.979> .PERIOD And anything that is done successfully <sil=0.372> ,COMMA this will result in if done successfully <sil=0.402> ,COMMA one do this <sil=0.970> .PERIOD That means <sil=0.578> ,COMMA it will be successfully executed <sil=0.422> ,COMMA it is not doing what you are intending <sil=0.951> .PERIOD So <sil=0.381> ,COMMA sometimes we are saved by the compiler <sil=0.527> ,COMMA when it points out that ok <sil=0.341> ,COMMA note here <sil=0.389> ,COMMA here is something <sil=0.443> ,COMMA some syntax error that you are committing <sil=0.921> .PERIOD But <sil=0.630> ,COMMA there are situations when we unintentionally can do such mistakes <sil=0.336> ,COMMA which will go unnoticed by the compiler and the result that we will be getting may not be what we desire <sil=0.932> .PERIOD So <sil=0.624> ,COMMA this is a very critical point <sil=0.520> ,COMMA you should keep it in mind <sil=0.968> .PERIOD For all programming languages <sil=0.369> ,COMMA you will find there are such nuances <sil=0.648> ,COMMA some specialties which you will have to keep in mind <sil=0.922> .PERIOD We are just mentioning here the ones for C <sil=0.978> .PERIOD But <sil=0.388> ,COMMA if I had done it in this way <sil=0.530> ,COMMA it will be ok <sil=0.967> .PERIOD So <sil=0.401> ,COMMA generalization of expression evaluation in C is <sil=0.618> ,COMMA assignment operator is also a part of expression that we know <sil=0.977> .PERIOD Now <sil=0.615> ,COMMA let us see here <sil=0.498> ,COMMA i is assigned 3 <sil=0.905> .PERIOD So <sil=0.471> ,COMMA typically some compilers <sil=0.449> ,COMMA what they do <sil=0.975> ?QUESTIONMARK Till now <sil=0.613> ,COMMA I was saying that if an instruction is executed correctly <sil=0.478> ,COMMA it will return a 1 <sil=0.931> .PERIOD But <sil=0.351> ,COMMA generally speaking <sil=0.587> ,COMMA it will return the value that has been assigned <sil=0.966> .PERIOD So <sil=0.407> ,COMMA typically <sil=0.327> ,COMMA here i assigned 3 will return the value 3 after assigning it to it <sil=0.981> .PERIOD But <sil=0.505> ,COMMA for us <sil=0.487> ,COMMA when we do <sil=0.636> ,COMMA what we are bothered about if the condition <sil=0.339> ,COMMA this part is sorry <sil=0.373> ,COMMA I would rather now say <sil=0.617> ,COMMA this part is 0 or non-zero <sil=0.997> .PERIOD If it is non-zero <sil=0.433> ,COMMA then it is true <sil=0.906> .PERIOD I was saying <sil=0.538> ,COMMA if 1 <sil=0.635> ,COMMA then it is true <sil=0.903> ,COMMA if 3 <sil=0.432> ,COMMA that is also true <sil=0.956> .PERIOD The only false it will come if it is 0 <sil=0.992> .PERIOD So <sil=0.625> ,COMMA this returns the value 3 after assigning it to i <sil=0.953> .PERIOD And then <sil=0.633> ,COMMA so <sil=0.405> ,COMMA let us look at this code <sil=0.914> .PERIOD I give you 1 minute <sil=0.429> ,COMMA they look at this code and think <sil=0.630> ,COMMA what this code will do <sil=0.526> ,COMMA what will be the result of this <sil=0.918> ?QUESTIONMARK Look at this code carefully <sil=0.626> ,COMMA then we will analyze it <sil=0.951> .PERIOD You can see that here <sil=0.581> ,COMMA we have initialized a variable i to 4 and j has just been declared <sil=0.370> ,COMMA but not initialized <sil=0.947> .PERIOD So <sil=0.559> ,COMMA here the picture is something like this <sil=0.600> ,COMMA i has been initialized to 4 and j can have something <sil=0.555> ,COMMA but I have not initialized it <sil=0.936> .PERIOD Now <sil=0.379> ,COMMA here if this statement <sil=0.329> ,COMMA what will this statement do <sil=0.944> ?QUESTIONMARK First <sil=0.625> ,COMMA the condition part <sil=0.484> ,COMMA that means <sil=0.569> ,COMMA within the bracket <sil=0.425> ,COMMA this part will be evaluated and what will happen <sil=0.887> ?QUESTIONMARK What is this <sil=0.883> ?QUESTIONMARK i is being assigned 3 <sil=0.500> ,COMMA so this will be 3 <sil=0.925> .PERIOD And the value that will be returned by this execution of this statement will be 3 <sil=0.515> ,COMMA then j will be 0 <sil=0.556> ,COMMA then j will be 0 <sil=0.542> .PERIOD Else j equal to 1 <sil=0.345> ,COMMA that will never come because this will be done successfully <sil=0.517> ,COMMA this will never come <sil=0.994> .PERIOD So <sil=0.492> ,COMMA the output will be <sil=0.351> ,COMMA output I have not given in the print F here <sil=0.562> ,COMMA but this j value of j will be 0 <sil=0.918> .PERIOD So <sil=0.617> ,COMMA what will be the value of j <sil=0.993> ?QUESTIONMARK Whatever be the value of i <sil=0.627> ,COMMA j will be 0 <sil=0.943> .PERIOD Now <sil=0.318> ,COMMA instead if I had written it correctly <sil=0.351> ,COMMA correctly means if my intention was that if i is equal to 3 <sil=0.483> ,COMMA j should be 0 <sil=0.316> ,COMMA otherwise j should be 1 <sil=0.474> ,COMMA then I should have written it in this way <sil=0.930> .PERIOD So <sil=0.304> ,COMMA that if i is equal to 3 <sil=0.406> ,COMMA then j will be 0 <sil=0.639> ,COMMA otherwise j will be 1 <sil=0.991> .PERIOD So <sil=0.344> ,COMMA this is a very important point that you have to keep in mind and gradually with practice <sil=0.467> ,COMMA it will be okay with this <sil=0.947> .PERIOD So <sil=0.400> ,COMMA here <sil=0.565> ,COMMA so more about expression <sil=0.910> .PERIOD Now <sil=0.329> ,COMMA here we introduce two new expressions <sil=0.909> .PERIOD Typically <sil=0.625> ,COMMA when we write <sil=0.450> ,COMMA suppose <sil=0.316> ,COMMA suppose there is a variable i <sil=0.926> .PERIOD And the variable i has got a value 5 <sil=0.988> .PERIOD Now <sil=0.522> ,COMMA if I want to implement the value 5 <sil=0.321> ,COMMA if I want to implement the value of i <sil=0.447> ,COMMA I will write i assigned i plus 1 <sil=0.912> .PERIOD But <sil=0.359> ,COMMA c allows us or gives us one special increment and another special decrement operation <sil=0.936> .PERIOD So <sil=0.407> ,COMMA this thing I could have written also as instead of this part <sil=0.633> ,COMMA I could have simply written i plus plus <sil=0.952> .PERIOD i plus plus means i is assigned i plus 1 and this one will be i minus minus <sil=0.946> .PERIOD So <sil=0.374> ,COMMA this is known as the decrement operator <sil=0.449> ,COMMA this is known as the increment operator <sil=0.943> .PERIOD Sometimes <sil=0.628> ,COMMA it becomes handy to write it in this way <sil=0.579> ,COMMA but if you are new in programming <sil=0.575> ,COMMA I personally would discourage you because you should not get ground in the special features of a language initially <sil=0.301> ,COMMA okay <sil=0.935> .PERIOD Better you go by the standard features because these features have got some more complications which will come to later <sil=0.920> .PERIOD But <sil=0.333> ,COMMA you may know that this is an increment operator which is equivalent to this and this is a decrement operator which is equivalent to this <sil=0.989> .PERIOD All right <sil=0.939> .PERIOD So <sil=0.395> ,COMMA this is I can write it in two ways <sil=0.394> ,COMMA sorry i plus plus or plus plus i <sil=0.977> .PERIOD The reason why I discourage you to get into the usage of this initially will be evident soon <sil=0.914> .PERIOD If I write i plus plus <sil=0.344> ,COMMA it means this is called post operation <sil=0.637> ,COMMA this means pre operation or prefix operation <sil=0.394> ,COMMA okay <sil=0.911> .PERIOD We will soon see what that means <sil=0.974> .PERIOD So <sil=0.311> ,COMMA I can have plus plus i or minus minus i <sil=0.640> ,COMMA that is a prefix operation <sil=0.316> ,COMMA all right <sil=0.904> .PERIOD And <sil=0.340> ,COMMA post-fix operation is i plus plus and i minus minus <sil=0.911> .PERIOD Now <sil=0.326> ,COMMA plus plus i means first increment or decrement depending on whether it is plus or minus and then use it in the evaluation <sil=0.618> ,COMMA for example <sil=0.516> .PERIOD Suppose <sil=0.595> ,COMMA I have got the value i here as 5 and I write x as sin plus plus i plus z or let me make it a constant <sil=0.976> .PERIOD Let us say z is 5 <sil=0.946> .PERIOD Then <sil=0.343> ,COMMA what will happen <sil=0.934> ?QUESTIONMARK This is what <sil=0.951> ?QUESTIONMARK This is a pre increment <sil=0.306> ,COMMA i first increment <sil=0.355> ,COMMA i and then do the operation <sil=0.995> .PERIOD Now <sil=0.357> ,COMMA this has got a precedence of course <sil=0.395> ,COMMA over this <sil=0.994> .PERIOD So <sil=0.569> ,COMMA first i will be i will be incremented <sil=0.950> .PERIOD So <sil=0.336> ,COMMA i will be 6 and z was 5 <sil=0.996> .PERIOD So <sil=0.572> ,COMMA the result will be z x will be 11 <sil=0.906> .PERIOD But <sil=0.351> ,COMMA if I had done written it x assigned i plus plus plus z <sil=0.463> ,COMMA here I will here also I will first increment this 6 and then z will be added to that <sil=0.995> .PERIOD But <sil=0.505> ,COMMA there are situations where we will do it after computation of the whole thing <sil=0.925> .PERIOD I think I will need a separate session for you to explain this clearly <sil=0.921> .PERIOD We will do that in a more careful manner <sil=0.966> .PERIOD Let us look at this <sil=0.945> .PERIOD Here <sil=0.430> ,COMMA int t is an integer and the value of m is 1 <sil=0.985> .PERIOD T assigned plus plus m <sil=0.533> ,COMMA that means <sil=0.483> ,COMMA what m was 1 and m is first incremented and assigned to t <sil=0.951> .PERIOD Therefore <sil=0.388> ,COMMA t will be 2 <sil=0.971> .PERIOD Again <sil=0.454> ,COMMA if we do it like this here <sil=0.428> ,COMMA then yes <sil=0.452> ,COMMA here it makes the difference very clear <sil=0.917> .PERIOD I am sorry <sil=0.983> .PERIOD T <sil=0.468> ,COMMA here you see m was 1 and what I have done <sil=0.996> ?QUESTIONMARK I have put the assignment of <sil=0.453> ,COMMA I have done a post operation post post fix operation <sil=0.959> .PERIOD That means <sil=0.410> ,COMMA first I will be doing the assignment <sil=0.310> ,COMMA first I will be doing the assignment and then I will increment <sil=0.932> .PERIOD So <sil=0.622> ,COMMA what will happen <sil=0.924> ?QUESTIONMARK m was 1 here <sil=0.989> .PERIOD So <sil=0.597> ,COMMA the first this 1 will go over here <sil=0.991> .PERIOD So <sil=0.459> ,COMMA t will become 1 <sil=0.993> .PERIOD Then <sil=0.546> ,COMMA before I complete this operation <sil=0.352> ,COMMA I increment m <sil=0.902> .PERIOD So <sil=0.532> ,COMMA m becomes 2 <sil=0.933> .PERIOD So <sil=0.310> ,COMMA we will see more examples of such things in the subsequent lectures <sil=0.949> .PERIOD In today's lecture <sil=0.334> ,COMMA we will look at a very important concept of programming <sil=0.966> .PERIOD It is required to conceptualize and understand the thing very well <sil=0.498> ,COMMA so that you can have more flexibility with programming <sil=0.940> .PERIOD We have visited this idea <sil=0.416> ,COMMA the concept of pointers earlier in the context of our discussions of call by value and call by reference <sil=0.984> .PERIOD So <sil=0.325> ,COMMA if you recall at that time <sil=0.353> ,COMMA we had talked about the variables which are in the memory <sil=0.976> .PERIOD So <sil=0.449> ,COMMA suppose I am talking of a variable x <sil=0.505> ,COMMA y <sil=0.517> ,COMMA z is the name of a variable <sil=0.927> .PERIOD So <sil=0.594> ,COMMA that variable has got some address <sil=0.577> ,COMMA that address may be say 5000 in the memory and who has allocated this address <sil=0.552> ,COMMA that address has been allocated by the compiler <sil=0.954> .PERIOD Now <sil=0.449> ,COMMA if I have another memory location <sil=0.535> ,COMMA another memory location <sil=0.532> ,COMMA say part of this <sil=0.445> ,COMMA part of this which I am not <sil=0.648> ,COMMA I am just drawing separately <sil=0.557> ,COMMA whose address is 7000 <sil=0.527> ,COMMA say this one <sil=0.505> ,COMMA 7000 <sil=0.970> .PERIOD And inside this location 7000 as its content <sil=0.354> ,COMMA I write 5000 <sil=0.983> .PERIOD And I say that whatever is the content of this location 7000 <sil=0.429> ,COMMA that is the variable I am interested in <sil=0.970> .PERIOD So <sil=0.612> ,COMMA can I say that if I now give a symbolic name P to this 7000 <sil=0.442> ,COMMA I can say or say this is P <sil=0.563> ,COMMA that this P is pointing to x <sil=0.549> ,COMMA y <sil=0.431> ,COMMA z <sil=0.538> ,COMMA because P is containing the address of x <sil=0.566> ,COMMA y <sil=0.584> ,COMMA z <sil=0.314> .PERIOD Therefore <sil=0.529> ,COMMA P is a pointer to a variable x <sil=0.388> ,COMMA y <sil=0.506> ,COMMA z <sil=0.541> .PERIOD We also say that P <sil=0.562> ,COMMA right now it is pointing to x <sil=0.475> ,COMMA y <sil=0.500> ,COMMA z <sil=0.417> .PERIOD But if I just change the value of this location 7000 and make it say 6000 <sil=0.625> ,COMMA then it will probably point to some other location here <sil=0.926> .PERIOD So <sil=0.549> ,COMMA P is therefore <sil=0.456> ,COMMA a pointer variable <sil=0.992> .PERIOD But when I say that it is a pointer variable <sil=0.328> ,COMMA then it is not pointing to any particular data <sil=0.370> ,COMMA it can point to a type of data <sil=0.972> .PERIOD So <sil=0.480> ,COMMA instead of making this statement that P is a pointer variable 2 a variable x <sil=0.521> ,COMMA y <sil=0.510> ,COMMA z <sil=0.314> .PERIOD Say this one is P <sil=0.562> ,COMMA y <sil=0.345> ,COMMA z <sil=0.341> .PERIOD Now <sil=0.633> ,COMMA as I change this now P is a pointer variable 2 a variable P <sil=0.468> ,COMMA y <sil=0.404> .PERIOD So <sil=0.639> ,COMMA if I generalize it <sil=0.604> ,COMMA I will say that P in this situation where I have got x <sil=0.351> ,COMMA y <sil=0.537> ,COMMA z at 5000 and P q r at 6000 <sil=0.908> .PERIOD I can say and 7000 is a pointer P <sil=0.482> ,COMMA and I can say P is a pointer variable pointing to say x <sil=0.458> ,COMMA y <sil=0.396> ,COMMA z and P q r are both integers to an integer or it could be a float or it could be some other data type <sil=0.954> .PERIOD So <sil=0.534> ,COMMA pointer to a particular a particular data type <sil=0.502> ,COMMA y I specify the data type will be clear in some time from now <sil=0.924> .PERIOD So <sil=0.620> ,COMMA we have got a pointer <sil=0.934> .PERIOD The concept <sil=0.509> ,COMMA the most important concept here is that P is a pointer P is a variable <sil=0.602> ,COMMA that variable is holding some value and that value is nothing but an address of another variable <sil=0.980> .PERIOD Address of another variable <sil=0.987> .PERIOD So <sil=0.551> ,COMMA now <sil=0.380> ,COMMA let us look at this the basic concept <sil=0.956> .PERIOD Every stored data items occupies one or more memory cells whenever we declared a variable the system allocates memory locations to that variable we know that variable <sil=0.962> .PERIOD So <sil=0.467> ,COMMA need not spend more time on that <sil=0.982> .PERIOD The number of memory cells required now this is important you also already know that the number of memory cells required to store a data item depends on its type typically for care we need one byte for int we need two bytes for float we need four bytes etcetera etcetera etcetera <sil=0.965> .PERIOD So <sil=0.615> ,COMMA since every byte in memory has a unique address this location will also have its unique address <sil=0.641> ,COMMA every element will have a unique address <sil=0.990> .PERIOD So <sil=0.471> ,COMMA let us see here the same example <sil=0.978> .PERIOD Consider the statement int xyz assigned 50 this statement means that the compiler will allocate for this xyz some location and put the value 50 in that location <sil=0.950> .PERIOD Suppose the address is address of xyz is 1380 here xyz is a variable and 50 is the value and 1380 is the address of that variable we know that we have discussed it earlier <sil=0.962> .PERIOD Now <sil=0.477> ,COMMA during execution of the program when the program is being executed the system always associates the name xyz with the address 1380 <sil=0.959> .PERIOD So <sil=0.629> ,COMMA whenever in the program we find xyz the variable xyz being referred it will go to the memory location 1380 and fetch that <sil=0.955> .PERIOD So <sil=0.605> ,COMMA the value 50 can therefore <sil=0.332> ,COMMA be accessed by going to the location 1380 and accessing it <sil=0.938> .PERIOD Now <sil=0.605> ,COMMA the variables which are holding these addresses are known as the pointers <sil=0.910> .PERIOD Now <sil=0.375> ,COMMA memory addresses are just numbers <sil=0.970> .PERIOD So <sil=0.480> ,COMMA I can also store them in some variables and these variables which are for example <sil=0.575> ,COMMA the address of the variable that will hold the address of variable xyz is the pointer to xyz <sil=0.926> .PERIOD So <sil=0.576> ,COMMA it is also naturally stored in some memory location <sil=0.927> .PERIOD So <sil=0.574> ,COMMA this is just the example that I was discussing right now <sil=0.964> .PERIOD Suppose we assign the address of xyz to a variable P then P is said to point to the variable xyz <sil=0.989> .PERIOD Now <sil=0.513> ,COMMA how do I I was just drawing this I was comfortably drawing this that there is 5000 here xyz and 5000 here and I was simply saying that this variable which was in location 7000 was pointing to this <sil=0.946> .PERIOD That means <sil=0.639> ,COMMA this was being loaded with 5000 how is that being done how is 5000 being written inside this location <sil=0.995> .PERIOD The statement is just like any other assignment will be that this variable's name is P <sil=0.916> .PERIOD P is assigned the address of xyz <sil=0.904> .PERIOD So <sil=0.358> ,COMMA P assigned and xyz right <sil=0.901> .PERIOD Now <sil=0.592> ,COMMA so here we can see that the variable xyz its address is 1380 value is 50 <sil=0.953> .PERIOD P is a pointer variable whose value is 1380 because it is pointing to xyz <sil=0.977> .PERIOD In our diagram that I was drawing by hand this P was holding the value 5000 and its address here is say 2545 in my diagram it was 7000 <sil=0.916> .PERIOD So <sil=0.443> ,COMMA this is a picture 1380 is the address of 50 and P which is located as 2545 is holding the address 1380 <sil=0.903> .PERIOD Now <sil=0.367> ,COMMA this concept whenever you find difficulty in dealing with pointers my suggestion always to the students is draw a piece of diagram and then you make the whole picture clear in front of you <sil=0.991> .PERIOD Tussing the address of a variable now you know that if I put the operator and amperes and immediately before the variable that will return the address of the variable like and xyz will give me the say the value 1380 which is the address of xyz <sil=0.988> .PERIOD The address of xyz is assigned this operator and can be used only with a simple variable or with an array element <sil=0.901> .PERIOD For example <sil=0.424> ,COMMA and distance and x 0 that means the address of the first location of the array x and of x i minus 2 all these things are possible <sil=0.969> .PERIOD Now <sil=0.466> ,COMMA what is illegal <sil=0.886> ?QUESTIONMARK This is illegal the reason is obvious 235 is not a variable it is a constant <sil=0.962> .PERIOD So <sil=0.306> ,COMMA it does not have any fixed position in the memory <sil=0.945> .PERIOD So <sil=0.338> ,COMMA it is not a memory location therefore <sil=0.304> ,COMMA it does not have any address that is meaningless pointing to at a constant that is not possible <sil=0.909> .PERIOD Say int I cannot say and air because this shows that a r r is a particular variable but it is an array therefore <sil=0.557> ,COMMA I have to I cannot show it like this it is just pointing at an array name is not pointing at the array we should we cannot also do this and a plus b that is also not possible because this will be say again if I have a as some value and b has some value then I add that and that will be a value and a value does not have any address that is pointing at an expression <sil=0.909> .PERIOD So <sil=0.558> ,COMMA here is a quick example I think I had shown this to you earlier say I have got three variables number of variables one character one double floats <sil=0.956> .PERIOD So <sil=0.517> ,COMMA if I put say I am assigning some values to these here I am putting some values and print F a particular variable A is stored in the address and B B is stored in address and B C is stored in address and C so and so forth <sil=0.985> .PERIOD Therefore <sil=0.331> ,COMMA if we run it will get the addresses coming out <sil=0.904> .PERIOD So <sil=0.603> ,COMMA 10 is stored in location so and so 2 <sil=0.970> .PERIOD 5 is stored in location so and so <sil=0.972> .PERIOD Now <sil=0.317> ,COMMA here incidentally it is just incidental that just for the sake of example all these are contiguous locations but they may not be contiguous locations also all right <sil=0.948> .PERIOD So <sil=0.342> ,COMMA 10 is stored in location A is A was having the value 10 is stored in location so and so like that it goes on <sil=0.940> .PERIOD So <sil=0.335> ,COMMA pointer declarations when we declare some variable as a pointer the typical the standard form is this data type shown in red that is very important and this star this is something new that you also saw this in when we were discussing call by reference <sil=0.993> .PERIOD For example <sil=0.606> ,COMMA int is a type star x y z x what does it mean <sil=0.943> ?QUESTIONMARK It means that x is a variable of type integer x is a variable sorry sorry absolutely sorry x is a pointer which is point enabled or which is allowed to point to variables of type integer only only integers can be pointed out pointed to by x <sil=0.982> .PERIOD So <sil=0.487> ,COMMA this is similarly I could have said float star p that means p will be a pointer that can only point to floating point numbers only <sil=0.981> .PERIOD All right <sil=0.923> .PERIOD So <sil=0.554> ,COMMA 3 things are specified in this in this declaration one is that this star tells that the variable pointer name or p whatever you call it is a pointer variable not a normal variable and asterisk is so is is telling that it is a pointer variable <sil=0.904> .PERIOD Pointer name is a variable therefore <sil=0.507> ,COMMA it needs a memory location and pointer name points to a variable of the specified data type <sil=0.937> .PERIOD So <sil=0.433> ,COMMA these 3 things you must remember when you are handling with a pointer <sil=0.995> .PERIOD So <sil=0.369> ,COMMA here is an example int star count what does it mean <sil=0.946> ?QUESTIONMARK That means <sil=0.434> ,COMMA count is a pointer variable why a pointer variable because this is preceded with a star and where can this pointed variable point to to all data data variables of type integer <sil=0.965> .PERIOD Speed is again a pointer because it has got this asterisk and where can speed point to speed can point to variables of type float <sil=0.954> .PERIOD Once a pointer variable has been declared it can be made to point to a variable using an assignment statement like this in star p x y z <sil=0.919> .PERIOD So <sil=0.358> ,COMMA in star p is a point p is a pointer variable x y z is an integer <sil=0.999> .PERIOD So <sil=0.336> ,COMMA you see by the same declaration I have declared two things one is a pointer to an integer and an integer <sil=0.981> .PERIOD So <sil=0.559> ,COMMA if I make such an assignment like p is assigned and x y z <sil=0.967> .PERIOD So <sil=0.493> ,COMMA x y z is here and its location can be 5000 and p is a pointer variable and so <sil=0.407> ,COMMA when I do this assignment this might be in the location 7000 <sil=0.901> .PERIOD But when I do this what it does is it loads this 5000 here <sil=0.916> .PERIOD So <sil=0.319> ,COMMA now p is pointing to x y z <sil=0.939> .PERIOD I hope it is clear now <sil=0.990> .PERIOD So <sil=0.522> ,COMMA this is called pointer initialization <sil=0.938> .PERIOD The things to remember is the pointer variables must always point to an item of the same type one pointer variable either it points to an integer or it points to a float or it points to an array of characters whatever it is <sil=0.941> .PERIOD Assigning an absolute address now <sil=0.939> .PERIOD So <sil=0.437> ,COMMA here for example <sil=0.429> ,COMMA this is an error why <sil=0.977> ?QUESTIONMARK Why is this an error <sil=0.956> ?QUESTIONMARK x is of type floating point x a variable and p is a pointer which is allowed to point to only integer <sil=0.962> .PERIOD But here I have made an assignment where I am assigning to p the address of the floating point number that is not allowed <sil=0.913> .PERIOD So <sil=0.642> ,COMMA therefore <sil=0.334> ,COMMA I am forcing p to point to x but the type of p and the type of x are different <sil=0.958> .PERIOD So <sil=0.542> ,COMMA assigning an absolute address to a pointer is prohibited you cannot do this you cannot you cannot do this <sil=0.999> .PERIOD You cannot force a pointer to a constant value that you must keep in mind <sil=0.996> .PERIOD So <sil=0.578> ,COMMA how do I access a variable through a pointer <sil=0.932> ?QUESTIONMARK Once a pointer has been assigned the address of a variable the value of the variable can be accessed through the indirection operation <sil=0.950> .PERIOD Now <sil=0.634> ,COMMA here you have to think of again we are talking of star <sil=0.950> .PERIOD So <sil=0.567> ,COMMA let us give an example first <sil=0.938> .PERIOD For example <sil=0.440> ,COMMA a b are two integers let us draw this <sil=0.914> .PERIOD I am sorry <sil=0.975> .PERIOD Suppose a is a location <sil=0.574> ,COMMA b is another location both of them are integers and p is a variable which is allowed to point to integers and what I do I assign to p the address of a <sil=0.959> .PERIOD So <sil=0.308> ,COMMA the address of a let us say it is 1000 or 100 <sil=0.977> .PERIOD So <sil=0.648> ,COMMA 100 is written here <sil=0.953> .PERIOD So <sil=0.444> ,COMMA it comes here <sil=0.930> .PERIOD Now <sil=0.353> ,COMMA I say so this what did this statement to 100 was the address of a that has been assigned to p <sil=0.908> .PERIOD Now <sil=0.484> ,COMMA what is being done by this b is being assigned star p <sil=0.956> .PERIOD That means <sil=0.595> ,COMMA whatever is b is getting the content of where p is pointing at <sil=0.927> .PERIOD Suppose this was 50 then b is getting 50 <sil=0.923> .PERIOD So <sil=0.504> ,COMMA a little bit of confusion can occur because of these two star p's <sil=0.939> .PERIOD Please understand that this star is just telling you that p is a pointer because it is coming in a declaration statement <sil=0.955> .PERIOD On the other and here it is not a declaration statement it is an assignment statement <sil=0.979> .PERIOD I have already declared p to be a pointer <sil=0.999> .PERIOD So <sil=0.527> ,COMMA p is a pointer <sil=0.905> .PERIOD So <sil=0.613> ,COMMA once a pointer has been assigned the address of a variable <sil=0.931> .PERIOD Once a pointer has been assigned the address of the variable that is done in this step <sil=0.970> .PERIOD The value of the variable can be accessed using the indirection operation <sil=0.911> .PERIOD That means <sil=0.326> ,COMMA which variable say I could have done this p assigned a <sil=0.955> .PERIOD But <sil=0.442> ,COMMA I am not doing this sorry <sil=0.324> ,COMMA we have p assigned b assigned a <sil=0.957> .PERIOD Instead of doing that what I am saying if I make just note my two English statements <sil=0.918> .PERIOD One is the value of a is being assigned to value to b statement number 1 <sil=0.981> .PERIOD Statement number 2 is or b is being assigned the value of a statement number 1 statement number 2 is b is being assigned the value of the variable that is being pointed at by p <sil=0.960> .PERIOD So <sil=0.598> ,COMMA here one is b is assigned the value of a one statement <sil=0.973> .PERIOD Here that is this statement and this statement is b is assigned the value instead of of a I am saying is being assigned the value of the variable pointed by by p <sil=0.935> .PERIOD So <sil=0.442> ,COMMA this is an indirect way of saying that <sil=0.967> .PERIOD So <sil=0.315> ,COMMA this is something that you must very clearly understand <sil=0.939> .PERIOD Look at this once again <sil=0.961> .PERIOD So <sil=0.337> ,COMMA I can now say that this thing is equivalent to b assigned a but <sil=0.564> ,COMMA I have done in indirect way <sil=0.987> .PERIOD If you have understood this then pointers should be clear to you <sil=0.910> .PERIOD Here look at one example <sil=0.927> .PERIOD Integer a b c assigned 5 and p is a pointer to integers <sil=0.966> .PERIOD Now <sil=0.405> ,COMMA in this statement what has been done <sil=0.887> ?QUESTIONMARK a is being assigned 4 times c plus 5 <sil=0.942> .PERIOD So <sil=0.566> ,COMMA c is being added to 5 <sil=0.996> .PERIOD So <sil=0.550> ,COMMA it is becoming 10 and 4 times 10 is 40 <sil=0.975> .PERIOD 40 is being assigned to a <sil=0.965> .PERIOD Here what is being done <sil=0.858> ?QUESTIONMARK p is being assigned c is address <sil=0.961> .PERIOD So <sil=0.509> ,COMMA wherever c was say address 1000 <sil=0.969> .PERIOD So <sil=0.492> ,COMMA that is being assigned to a variable p <sil=0.946> .PERIOD So <sil=0.612> ,COMMA p is becoming 1000 <sil=0.942> .PERIOD Now <sil=0.607> ,COMMA b what is b being assigned <sil=0.885> ?QUESTIONMARK b is being assigned 4 times star p plus 5 what is star p <sil=0.963> ?QUESTIONMARK star p sorry c is a star p is nothing but the variable c is pointing to that and whatever was its value <sil=0.995> .PERIOD Suppose it was 10 it was sorry it was 5 <sil=0.992> .PERIOD So <sil=0.634> ,COMMA that value is being taken and 5 is being added to that <sil=0.964> .PERIOD So <sil=0.495> ,COMMA it becomes 10 times this <sil=0.956> .PERIOD So <sil=0.385> ,COMMA these two are essentially equivalent <sil=0.903> .PERIOD So <sil=0.384> ,COMMA here is another example you have seen this example very similar to this that I am defining a pointer p t r is a pointer x is 10 you just think of what it should print <sil=0.938> .PERIOD x is 10 p t r is the address of x p t r is the address of x here and y is being assigned star p t r what does this mean <sil=0.864> ?QUESTIONMARK p t r is pointing to 10 and y is being assigned to star p t r that means <sil=0.355> ,COMMA y is being assigned to 10 or y is being rather I should say y is being assigned x and x was 10 <sil=0.914> .PERIOD So <sil=0.542> ,COMMA y is becoming 10 <sil=0.986> .PERIOD Now <sil=0.575> ,COMMA if I print person is stored x x x instead of x what will be printed <sil=0.932> ?QUESTIONMARK Instead of x the value of x will be 10 is stored in the address this <sil=0.973> .PERIOD Similarly <sil=0.620> ,COMMA now what is this <sil=0.931> ?QUESTIONMARK star and x what does this mean <sil=0.945> ?QUESTIONMARK And x is the address of x and where that is pointing to these two should be same <sil=0.987> .PERIOD So <sil=0.592> ,COMMA if you look at the result this is equivalent y and x is the address of x and star just like star p that means <sil=0.361> ,COMMA the content of where the pointer is pointing to <sil=0.920> .PERIOD So <sil=0.508> ,COMMA these two are same right <sil=0.930> .PERIOD So <sil=0.393> ,COMMA p t r is and x p t r has is the same and x is nothing but p t r <sil=0.913> .PERIOD So <sil=0.574> ,COMMA these two are all equivalent if I say and x that means <sil=0.600> ,COMMA I am taking the address of star p t r <sil=0.944> .PERIOD So <sil=0.423> ,COMMA this is something you can toy with yourself and you will get a print out like this <sil=0.965> .PERIOD So <sil=0.402> ,COMMA these two are the same <sil=0.962> .PERIOD Now <sil=0.615> ,COMMA here we are coming to something more which is known as pointer expressions and we will deal with that in the next lecture <sil=0.980> .PERIOD So <sil=0.301> ,COMMA we had looked at parameter passing and we have looked we have seen the difference between call by value and call by difference and we have seen quite a few examples to be specific three examples on call by value <sil=0.926> .PERIOD How and also another thing that was supposed to be noted I hope you have noted that is the scope of variables that whenever there is an x in the main function and the x in the called function then these two x is a different the x that is defined in the called function is a separate location than the x in the main function and that the life of that variable ends with the end of the function <sil=0.901> .PERIOD Now let us look at this example you yourself will be able to trace this <sil=0.985> .PERIOD So <sil=0.481> ,COMMA I give you some time to trace this through and then we will continue look at this function carefully and do not look at this green part do not look at the green part yourself and try to without looking at that try to find out what the values will be for the different print statements <sil=0.929> .PERIOD Let us start <sil=0.979> .PERIOD So <sil=0.637> ,COMMA we have got x assigned to 10 and y assigned to 5 x and y <sil=0.954> .PERIOD Now <sil=0.351> ,COMMA so when I print f do this print f x is printed to be 10 y is printed to be 5 fine no issue then I call a function interchange x y look at this the type of this function interchange the type of this function interchange is void because that immediately tells us that it is not going to return anything it is going to do something as the name implies it is going to interchange x and y and what are the parameters parameters are x and y this is the argument <sil=0.980> .PERIOD So here I have got another set of x and y again note that this x and y are different <sil=0.998> .PERIOD Now <sil=0.617> ,COMMA initialize temp <sil=0.977> .PERIOD So <sil=0.504> ,COMMA temp is another variable here temp <sil=0.953> .PERIOD Now <sil=0.631> ,COMMA what I am doing here the first print f what is being done here print f x equal to x and y equal to y which x and which y the x this x and this y <sil=0.935> .PERIOD Now <sil=0.523> ,COMMA when I entered this function these values have been copied here <sil=0.942> .PERIOD So <sil=0.609> ,COMMA the print f will simply print 10 and 5 no issue <sil=0.965> .PERIOD Now <sil=0.412> ,COMMA temp is getting x x was 10 <sil=0.991> .PERIOD So <sil=0.613> ,COMMA I put 10 here and then x assigned y sorry y assigned x that means the value of y I am still within the function I am within the function <sil=0.940> .PERIOD So <sil=0.469> ,COMMA this value is being assigned <sil=0.930> .PERIOD So <sil=0.508> ,COMMA by this statement what happens this becomes 5 and this remains 5 right and then what is being done here y assigned temp that means this temp is becoming 5 right temp is becoming sorry I am sorry I am sorry I am sorry this was 10 <sil=0.983> .PERIOD Now <sil=0.329> ,COMMA for this statement temp is going to y that means y will be changed to 10 <sil=0.997> .PERIOD So <sil=0.534> ,COMMA here I find 5 and 10 <sil=0.942> .PERIOD So <sil=0.627> ,COMMA it is when it entered here I could see 10 and 5 and so <sil=0.321> ,COMMA when I come and print from here x will be 5 and y will be 10 I come out of the program and print f x and y what will be printed my God <sil=0.979> .PERIOD What I find is x is being printed as 10 and y is being printed as 5 as it was here <sil=0.913> .PERIOD So <sil=0.492> ,COMMA no change has actually taken place why did it happen like this you can immediately see the reason that whatever change took place took place here inside the function and this actually tells you the importance of the scope of variables these variables scope ended with this function and their change was not reflected in the main here that is why although I did it here it would not change <sil=0.941> .PERIOD However <sil=0.534> ,COMMA suppose suppose let us do some intellectual exercise here suppose x was 10 and y was 5 and there was a temp now temp is inside the function <sil=0.954> .PERIOD So <sil=0.321> ,COMMA I will use different colors for that <sil=0.995> .PERIOD Now <sil=0.400> ,COMMA although I I I remind you that C does not allow call by reference <sil=0.406> ,COMMA but just to see whether you have understood call by reference properly <sil=0.936> .PERIOD Suppose we are allowed to use call by reference then my main program has got this x and y <sil=0.974> .PERIOD So <sil=0.385> ,COMMA it comes here prints say prints x and y <sil=0.981> .PERIOD So <sil=0.562> ,COMMA 10 and 5 are printed x equal to 10 <sil=0.599> ,COMMA y is equal to 5 and it calls interchange <sil=0.986> .PERIOD It calls interchange and suppose just suppose that this call has been done by call by reference <sil=0.946> .PERIOD So <sil=0.533> ,COMMA what has been passed here the address of this and the address of this not the values <sil=0.990> .PERIOD So <sil=0.627> ,COMMA no other copies have been made <sil=0.910> .PERIOD So <sil=0.542> ,COMMA now I have got the local variable temp and the value of the value of the value of the value of the value of the values not the values <sil=0.924> .PERIOD So <sil=0.532> ,COMMA no other copies have been made <sil=0.903> .PERIOD So <sil=0.441> ,COMMA now I have got the local variable temp and here I do temp is assigned x <sil=0.928> .PERIOD So <sil=0.407> ,COMMA temp gets 10 then x assigned y <sil=0.964> .PERIOD So <sil=0.326> ,COMMA this is the now what is my x and what is my y <sil=0.933> .PERIOD The content of this address which have been passed will go to the content of x <sil=0.907> .PERIOD So <sil=0.448> ,COMMA this will be 5 and then y will be assigned temp <sil=0.905> .PERIOD What will happen <sil=0.884> ?QUESTIONMARK This temp this value will go to the suppose I can make call by reference then this will go to this address <sil=0.907> .PERIOD But if I just simply write in this way that does not mean it really does not tell me whether I am saying that I am copying the from the address or actually copying the value <sil=0.992> .PERIOD But I am just taking telling a hypothetical case <sil=0.941> .PERIOD So <sil=0.323> ,COMMA this 10 will go there and this 5 would be changed <sil=0.923> .PERIOD In that case when I come back from here and I print here then I would have got the change scenario reflected <sil=0.939> .PERIOD But the mechanism writing simply like this in C means it is called by value not called by reference <sil=0.923> .PERIOD So <sil=0.504> ,COMMA what is being passed is actually the value <sil=0.903> .PERIOD So <sil=0.438> ,COMMA if I could if I could do that then it was possible to have that interchange <sil=0.997> .PERIOD And there is a mechanism for passing the addresses and not the actual values by using a concept called I mean structure called pointers which are nothing but addresses <sil=0.944> .PERIOD We will have to we will see that later if time permits <sil=0.919> .PERIOD But in general remember that this interchange has not been possible by call by value in the way we wrote the program <sil=0.920> .PERIOD So <sil=0.435> ,COMMA with this we complete our discussion on parameter passing normally one of distinction between parameter passing by call by value and call by reference <sil=0.928> .PERIOD And we now start another very important point that is passing arrays to functions <sil=0.913> .PERIOD Now <sil=0.400> ,COMMA let us try to think here when we were having a variable x another variable y in the called function in the color function <sil=0.995> .PERIOD And I was having in my called function two other variables a and b in the value of this would be copied here and the value of this was copied here <sil=0.942> .PERIOD But suppose x is not an integer x is an array of 20 elements <sil=0.925> .PERIOD Then all those 20 elements I have to copy here and suppose this is an array of another 20 elements <sil=0.960> .PERIOD So <sil=0.487> ,COMMA another 20 elements I have to copy here right C allows only for arrays the parameter passing by reference <sil=0.972> .PERIOD Now <sil=0.381> ,COMMA in order to understand that let us try to look at the structure of an array <sil=0.972> .PERIOD Suppose I have got an array A 10 <sil=0.940> .PERIOD Now <sil=0.616> ,COMMA I am not making a distinction between the size of the array actual size of the array and the dimension of the array <sil=0.969> .PERIOD I am assuming that the array A has got 10 elements <sil=0.967> .PERIOD So <sil=0.623> ,COMMA I have got 1 2 3 4 5 6 7 8 9 10 <sil=0.998> .PERIOD And these are A 0 A 1 A 2 up to A 9 right these are the locations we know that we also know that an array is allocated contiguous memory locations by the compiler <sil=0.970> .PERIOD So <sil=0.411> ,COMMA all these are contiguous therefore <sil=0.416> ,COMMA it is sufficient to know the address of the starting location <sil=0.954> .PERIOD Suppose this is 1000 <sil=0.969> .PERIOD If this is 1000 and if it been integer and I assume that an integer integer takes 2 bytes say 16 bits and then this will be 1000 2 this will be 1000 4 etcetera I can compute any particular address any particular address of this <sil=0.967> .PERIOD So <sil=0.626> ,COMMA if I say A 5 the address of this A 5 can be easily computed as the starting address 1000 whatever is the starting address plus the index is 5 that means and the size of integer which I know in a particular machine say 2 bytes times how much will be 106 108 <sil=0.937> .PERIOD So <sil=0.525> ,COMMA what will be 2 into whatever is the index minus 1 sorry A 5 A 5 will be the 6th element right <sil=0.976> .PERIOD So <sil=0.532> ,COMMA 5 times whatever this is suppose this I I times I right size of the integer times I <sil=0.954> .PERIOD So <sil=0.590> ,COMMA it will be 1000 plus 2 times 5 1010 <sil=0.904> .PERIOD So <sil=0.592> ,COMMA this is A 0 A 1 A 3 will be 1000 6 A 4 will be 1000 8 and A 5 will be 1000 10 since it is contiguous it is sufficient for me to know the starting address of the array <sil=0.957> .PERIOD Therefore <sil=0.373> ,COMMA it is good enough to establish the correspondence between the name of the array and the starting point of the array <sil=0.980> .PERIOD What I mean by that is again I draw this now I name the array differently A and suppose it has got 5 elements all right <sil=0.983> .PERIOD Now <sil=0.378> ,COMMA A and A 0 are treated to be synonymous when I say A that means I am actually referring to this element this address not this element this address and since I know that therefore <sil=0.574> ,COMMA A i depending on the value of i I can compute where the actual location will be this is the fundamental concept we need to understand all right <sil=0.960> .PERIOD Therefore <sil=0.335> ,COMMA we can pass the an array array to a function as ordinary arguments for example is factor whether x i is a factor of x 0 suppose I want to do that <sil=0.977> .PERIOD So <sil=0.453> ,COMMA you see is factor earlier I did x or y here I am writing x i x 0 <sil=0.960> .PERIOD So <sil=0.425> ,COMMA x i is what suppose x is an integer array <sil=0.952> .PERIOD So <sil=0.521> ,COMMA x i is an integer x 0 is another integer <sil=0.946> .PERIOD So <sil=0.328> ,COMMA I can simply pass this sign of a particular angle where is that angle in an array x an array x is there and in that the fifth or sixth element I am taking <sil=0.987> .PERIOD So <sil=0.597> ,COMMA this element is coming as the parameter <sil=0.928> .PERIOD So <sil=0.513> ,COMMA that is procedure little further <sil=0.907> .PERIOD Now <sil=0.601> ,COMMA that is for the individual elements x i or x 5 x 0 I am just passing an element and if it is an integer array then an integer is being passed if it is a floating array floating point array then a flow to the past but what if I want to pass the entire array to a function that is what I just now explained that is an array name like a can be used as an argument to a function because a essentially means a 0 and if I can pass a 0 that dress of a 0 is known then all the elements are known because they are contiguous <sil=0.926> .PERIOD Now <sil=0.353> ,COMMA the way it is passed differs from that of the ordinary variables why here when I have got an array an array a with a 0 when I am passing the array suppose somewhere in my function f I am passing the array a and just to see that it is an array I just do something like this this is not the correct syntax I will show you the syntax a little later <sil=0.996> .PERIOD Now <sil=0.357> ,COMMA you see I write it in this way all right now that means I am passing a 0 but if I pass the value of a 0 which might be 50 I have got no clue about the other values I am not passing all the values <sil=0.956> .PERIOD So <sil=0.410> ,COMMA what do I have to pass <sil=0.853> ?QUESTIONMARK I if I pass the address of a 0 address of a 0 <sil=0.918> .PERIOD So <sil=0.579> ,COMMA this is what is being passed is address of a 0 then I can get access to all these elements a i a 1 a 2 anything because I can compute the address very easily as I have shown just now all right I can do that <sil=0.984> .PERIOD So <sil=0.556> ,COMMA this is an example this is a case where we call by reference we actually will pass the address and not the value of a 0 we are passing the address of a 0 and the address of a 0 is the same as the name a this is a very fundamental concept let us try to understand this how is it pass the array name must appear by itself <sil=0.908> .PERIOD So <sil=0.427> ,COMMA now we are talking about the some syntaxes the array name must appear by itself as argument without brackets or subscripts the corresponding formal argument is written in the same manner let us look at an example say here I am going to pass the whole array as a parameter <sil=0.947> .PERIOD So <sil=0.527> ,COMMA I have declared constant int a size 5 <sil=0.923> .PERIOD So <sil=0.649> ,COMMA something some variable a size is assigned 5 now float average average is a function which will which is taking as parameter sorry which is taking as parameter an array b all right just the name of the b only array name or address of b is passed now this symbol is mentioned to indicate that this is an array right now let us see what is happening in tie total 0 for i equals 0 i less than a size that means less than 5 i plus plus total equals total plus b i <sil=0.962> .PERIOD So <sil=0.389> ,COMMA what is happening so here is an array b here is an array b a size the array size is 5 and all these elements are being added <sil=0.958> .PERIOD Now <sil=0.442> ,COMMA all these elements are being added in this loop so b i only b 1 b 2 b 0 b 1 b 2 b 3 b 4 they are being added to total and then I am returning what I am returning I am returning total divided by a size now there is a new thing here also it is better to look into that <sil=0.966> .PERIOD Now <sil=0.617> ,COMMA the array now average will be a floating point number and b is an integer array <sil=0.973> .PERIOD So <sil=0.326> ,COMMA sometimes so when I what has been done here is float a size when we do this float some variable x that means this variable is being type-casted is being made to be represented as a float <sil=0.950> .PERIOD So <sil=0.566> ,COMMA if it was 5 5 suppose then float a size so since is 5 float a size will make it 5 <sil=0.990> .PERIOD 0 and suppose the array was 1 2 0 4 5 so 9 to 11 12 total was 12 so float total will make it 12 <sil=0.934> .PERIOD 0 <sil=0.948> .PERIOD So <sil=0.537> ,COMMA I am casting 12 forcing it to be represented as a float <sil=0.995> .PERIOD So <sil=0.561> ,COMMA then 12 <sil=0.921> .PERIOD 0 is being divided by 5 with divided by 5 <sil=0.979> .PERIOD 0 and I am getting the average and that average is being returned here <sil=0.966> .PERIOD So <sil=0.634> ,COMMA that is that was not our main contention here that is the purpose of this float but the main contention here is that I have passed this array b but who passed it the main function let us study the main function the main function x is an array of size a size that is 5 and x average is of some variable and x has been assigned as 10 20 30 40 50 x average I will compute but I am calling this function average from here and I am passing x what is x x is an array and that is appearing just as a variable here and that is being accepted as b <sil=0.981> .PERIOD So <sil=0.474> ,COMMA what is the correspondence between x and b <sil=0.910> ?QUESTIONMARK x is somewhere suppose starting with location 5000 and there are 5 elements as has been said here 10 20 30 40 50 <sil=0.963> .PERIOD Now <sil=0.588> ,COMMA when this x is passed to b this function now knows that b is an array because it had this thing and this 5000 is passed to b <sil=0.981> .PERIOD So <sil=0.302> ,COMMA now b knows where is b <sil=0.933> ?QUESTIONMARK b is the same array now whatever change I do here suppose in this function instead of computing the total if I had written this function in a different way for example <sil=0.395> ,COMMA let us do that and suppose suppose I have got this function x I have got this function x this array sorry I am sorry x where 10 20 30 40 50 are there and in my function change I can also say void change in b this and in the body of the function what I do is for please try to understand I assign 0 to this I less than equal to a size or 5 whatever it is I plus plus b i plus plus say this what will happen inside this function change I will take the first one change it to 11 this one will be 21 this one will be 31 this only 41 this only 51 and when I return I made a change in b but b and x are the same because this address 5000 was passed to the function change and this b got 5000 and so whatever change has been done here will be reflected in the main function when I return clear so that is the importance so here I have called it with the actual array name here of course <sil=0.303> ,COMMA I computed a total and returned some other value but if I had just change it inside this function I could have made it void function and the change would have been automatically reflected in the main function <sil=0.914> .PERIOD So <sil=0.361> ,COMMA here you see we do not need to write the array size it works with arrays of any size for example <sil=0.572> ,COMMA here void this etcetera where list is an array of 100 elements and average I am calling a float average in a is an integer and float x is mapped to list x is an array because here how is the correspondence done this list list is being mapped to this same address is being passed and n is being passed to a how many elements are there all right <sil=1.000> .PERIOD So <sil=0.550> ,COMMA I need not specify the size because the size is already specified here I have got 100 element added this is my list this is list right <sil=0.933> .PERIOD So <sil=0.303> ,COMMA I have got 100 element here I know what I passed to x is just the address so whatever it is 100 or 150 that we true for x also right <sil=0.987> .PERIOD So <sil=0.335> ,COMMA we do not need to write the size of the array <sil=0.999> .PERIOD Now <sil=0.589> ,COMMA similarly arrays use as output parameters <sil=0.924> .PERIOD So <sil=0.423> ,COMMA suppose I am going to do vector sum that means I have got 2 arrays a and b <sil=0.903> .PERIOD So <sil=0.607> ,COMMA what I am doing here I have got 2 arrays a an integer array another integer array b and I am adding them <sil=0.968> .PERIOD So <sil=0.621> ,COMMA I will add this element say 5 with this 7 and I have got another array v sum v sum where the sum will be stored <sil=0.947> .PERIOD So <sil=0.318> ,COMMA this will be 12 if it was 6 and this was 5 here will store I will add these 2 and I will store 11 <sil=0.934> .PERIOD So <sil=0.525> ,COMMA let us see how the vector sum now vector sum will be void you know because it is doing the addition and the addition is remaining in this vector sum <sil=0.978> .PERIOD So <sil=0.616> ,COMMA I have got let us start with the main function x is an array <sil=0.932> .PERIOD So <sil=0.542> ,COMMA this is actually x a or let me say let me put the main function first <sil=0.912> .PERIOD So <sil=0.580> ,COMMA it will be x in the main function and a in the this function y slash b I am writing slash b because this was the same because the address is here alright and vector sum will be z <sil=0.967> .PERIOD So <sil=0.393> ,COMMA z or vector sum now <sil=0.912> .PERIOD So <sil=0.410> ,COMMA x is 1 2 3 y is 4 5 6 and z z has not been initialized because <sil=0.959> .PERIOD So <sil=0.601> ,COMMA let me let me let me let me so that you are not confused let me do it like this <sil=0.925> .PERIOD I have got an array that is x having values 1 2 3 another array y having values 4 5 6 and another another array another array z which will have the final value and z alright it is 3 elements <sil=0.306> ,COMMA but we do not know the value <sil=0.963> .PERIOD Now <sil=0.584> ,COMMA I am calling vector sum and what I am passing x is being passed to this x goes to this <sil=0.964> .PERIOD So <sil=0.315> ,COMMA this is known as a for the function y goes to this <sil=0.977> .PERIOD So <sil=0.558> ,COMMA this is known as b <sil=0.916> .PERIOD So <sil=0.516> ,COMMA x and a locations are shared z and v sum the locations are shared alright <sil=0.953> .PERIOD Now <sil=0.314> ,COMMA I am calling vector sum <sil=0.999> .PERIOD So <sil=0.380> ,COMMA all these are being added in a look 5 7 9 then I come out I come out now you see when I come out of this function these are already reflected because it was passed by reference <sil=0.941> .PERIOD Now <sil=0.585> ,COMMA let us look at the print printed vector what is happening here void print vector that is another function that is I am calling here z 3 that means <sil=0.566> ,COMMA 3 elements will be printed from that z array the z array was here which had that elements like 5 7 and 9 <sil=0.944> .PERIOD Now <sil=0.314> ,COMMA with that print vector it is just in a loop I equal to 0 I less than length what is length length is 3 and what is the array z is a <sil=0.926> .PERIOD Now <sil=0.471> ,COMMA this a and this are different again this a and this a are different this a this a was this function say and this a is this function say <sil=0.933> .PERIOD So <sil=0.436> ,COMMA they are different <sil=0.998> .PERIOD So <sil=0.429> ,COMMA here they are printing 5 7 9 <sil=0.958> .PERIOD So <sil=0.597> ,COMMA that is as an output parameter <sil=0.997> .PERIOD So <sil=0.357> ,COMMA you see actually whenever I am reflecting on an array I need not pass it because essentially automatically passed right <sil=0.942> .PERIOD So <sil=0.450> ,COMMA that is what is very important <sil=0.951> .PERIOD So <sil=0.616> ,COMMA I hope you have understood this the actual mechanism is when an array is passed it is the array elements are not passed but what is passed is an address and the argument becomes a pointer to the first element or I a pointer to the first element that means <sil=0.498> ,COMMA the address of the first element <sil=0.994> .PERIOD And when an array element is accessed inside the function the address is calculated I have already explained the formula that is used for finding the array <sil=0.978> .PERIOD So <sil=0.636> ,COMMA this is known as call by reference <sil=0.953> .PERIOD So <sil=0.356> ,COMMA I think you have understood this will continue our discussions in the future lectures on some other important issues <sil=0.955> .PERIOD We have seen what a function is and why a function is required <sil=0.598> ,COMMA what are the advantages of using a function <sil=0.952> .PERIOD We have also seen what is a parameter and what is an argument and the types of the parameters and the arguments must match <sil=0.954> .PERIOD Otherwise <sil=0.405> ,COMMA the system will of course <sil=0.337> ,COMMA give you error and the reason is because the type means match and the data will not be passed properly <sil=0.973> .PERIOD Because this is essentially a parameter is being assigned to an argument <sil=0.983> .PERIOD Now in this lecture <sil=0.393> ,COMMA we will look at some more detailed nuances <sil=0.471> ,COMMA detailed points of a function <sil=0.993> .PERIOD So <sil=0.401> ,COMMA to start with <sil=0.500> ,COMMA let us revise what we have seen <sil=0.474> ,COMMA a function <sil=0.387> ,COMMA what is a function <sil=0.974> ?QUESTIONMARK A function is a self-contained program segment <sil=0.936> .PERIOD This is very important <sil=0.920> ,COMMA this is not the whole program <sil=0.416> ,COMMA but it is self-contained and it is a program segment <sil=0.476> ,COMMA part of a program that is a main task and a part of that is being executed is being implemented by this function <sil=0.909> .PERIOD And this self-contained because this can be independently tested giving data and finding out whether the task for which it has been designed is actually being fulfilled or not <sil=0.906> .PERIOD It carries out some specific and well-defined task <sil=0.976> .PERIOD Now that is a general concept of a function <sil=0.943> .PERIOD Now in C <sil=0.608> ,COMMA any C program can consist of one or more functions <sil=0.575> ,COMMA at least one should be there <sil=0.953> .PERIOD Why <sil=0.917> ?QUESTIONMARK Because we need always the main <sil=0.523> ,COMMA we have seen that we need main <sil=0.558> ,COMMA any C function must have a main and main is nothing but a function <sil=0.917> .PERIOD And why did we put here this empty bracket <sil=0.889> ?QUESTIONMARK Because the structure of a function is always a function name and a place for the arguments <sil=0.988> .PERIOD Now you can say that well when we are starting a main function <sil=0.537> ,COMMA we are writing a main function that will do the task <sil=0.313> ,COMMA it is not taking data from anywhere outside <sil=0.936> .PERIOD Therefore why there is no argument <sil=0.852> ?QUESTIONMARK Yes <sil=0.600> ,COMMA you are right <sil=0.462> ,COMMA there is no argument <sil=0.334> ,COMMA that is why we put two braces and there is an empty space here <sil=0.513> ,COMMA there is empty <sil=0.916> .PERIOD But still it looks like a function <sil=0.944> .PERIOD Moreover in the earlier lecture we have seen that the result of the function is returned in its name and since this is a VID like a variable <sil=0.544> ,COMMA it will have a type <sil=0.952> .PERIOD So some type like for average we found float <sil=0.963> .PERIOD So this main can also have a type <sil=0.937> .PERIOD So we will see later that this main can have a type <sil=0.320> ,COMMA we will have a set of empty arguments and the body of the function and there can be type <sil=0.625> ,COMMA say sometimes the type can be int <sil=0.334> ,COMMA if this main function that means this main function will return an integer and where we say that it does not return anything <sil=0.631> ,COMMA we can say also that this function is of type void <sil=0.925> .PERIOD That means it does not return in the value <sil=0.527> ,COMMA void <sil=0.957> .PERIOD So we will see this later <sil=0.946> .PERIOD But this is the reason why we say that every C program must consist of one or more than one function <sil=0.993> .PERIOD One of this function must be called the main and the execution of the program always begins by carrying out the instructions in main <sil=0.982> .PERIOD That is the entry point <sil=0.626> ,COMMA any program I mean I cannot say that main will be somewhere in the middle <sil=0.977> .PERIOD No <sil=0.353> ,COMMA when I start it must the gateway is the main and then from within main I can go out and use some function f1 and from f1 I can go out to another function f2 <sil=0.537> ,COMMA another function sorry another function f2 like that <sil=0.989> .PERIOD But the gateway the entry should be main and ultimately the exit say f2 will return here then f1 will return here ultimately the exit will also be through main <sil=0.929> .PERIOD A function will carry out its intended task whenever it is called or invoked <sil=0.932> .PERIOD So we have encountered with this term called or invoked <sil=0.970> .PERIOD So in general a function will process information that is passed to it from the calling portion of the program from where it has from where it has been called or invoked and then the function will take the data that is if some data is to be passed then it will be passed with from the calling part and it will return a single value <sil=0.907> .PERIOD So what are these points <sil=0.908> ?QUESTIONMARK Information is passed via special identifiers called arguments and parameters and the value that is returned is returned by the return statement <sil=0.937> .PERIOD Some functions do not return anything for example let us say this say I am writing a function say my function <sil=0.908> .PERIOD It is maybe it is not taking any parameters because in the body it is simply nothing doing nothing just printing print f hello that is also valid function <sil=0.984> .PERIOD So in this case the main function where it was it was just here and it just called my function here with nothing this is also possible <sil=0.975> .PERIOD So my function it goes there and does not so I do not need to give a return but if I give a return that is also fine it does not return anything so this is of type void it is not returning anything so but the control in any case it does not return in the value but the control will come back here and from here it will be executed <sil=0.931> .PERIOD So there may be some functions we do not return in the value like it is just printing some data okay that is possible for example I can make it even more realistic say here main is here and there is int a 5 int b 6 all right and here I call average a comma b right and here I write average int x int y and here I just compute average is equal to x plus y by 2 print f f v g equals backslash f v g equals I am sorry percentage f percentage f backslash n comma v g that you understand now and I can write return or I may not write return so what will happen this will come here 5 and 6 5 will be passed on here x will be 5 y will be 6 the value will be 5 <sil=0.933> .PERIOD 5 that will be printed here but I have to give a type to this average because here the average type is not defined so I have to say this will be float average because there is some value some type to this value from type to this variable which will hold the value so this also possible here you can see that I do not need to write a return but there is no harm if I write just simply return that is a good practice that means my return my control will come back here and that is the last statement that will be the end okay so let us move forward so some function may not return anything the return type is specified as void so here is an example of factorial we start with so here first I have written the function here and then I have written the main but however in whatever way we write the main the program while execution will enter the main first all right so so the execution will be something like this that will enter from here main it takes the variable n which is an integer then n1 to less than 10 n plus plus printf percentage d okay and n and then factorial all right so factorial n now when this factorial n is encountered then we this function is called this function what is doing it has got int m so m is the argument and it is being called with a parameter n which has been which is being taken first one then two then three like that till it is 10 so I am taking it n and then here let us see what we are doing int i now this i this variable i and this variable 10 these two variables are purely internal variables that means these variables are internal to the body of the function now each of the functions have got a life each has a life right so factorial as long as factorial is running factorial is live and when factorial is live whatever variables are defined within factorial they are live as soon as we exit from factorial that function is dead and the variables associated solely I repeat the variables associated solely with the function also dies with the death of the function so let us see here i and 10 then for i equal to 1 to m 10 equals 10 times i so 1 times 2 times 3 times 4 so it is what is being computed 1 times 2 times 3 times 4 like that whatever is the value of m that is being up to that we are computing a factorial all right so if I call it now here I have called it with n the value of n all right with the value of n I am calling it and I am getting the factorial and the temp is being returned why it is being returned this temp is being returned to factorial temp is being returned to factorial and that is being printed through this percentage t all right so this is being printed so return temp because why it is different here I did not write return because I have named it as factorial and I have returned temp then temp is going to this value factorial if I had not done return then ultimately because here I am keeping the result in temp not in vectorial has not been used as any variable inside the function now when I go there and suppose if I had used some other temp here this temp and this temp would have been different we will come to this later but this is just an example of a function being invoked we just recapitulating why we need functions this term may be new to you it is modularizing a program is breaking down a program into small small parts each part independent part is called a module that is why breaking down a big program into smaller parts is known as modularization so it is modularizing a program all variables declared inside function are local variables very very important which are declared inside functions are local variables that means they are known as only as long as the function is remaining running as soon as the function completes its execution they also cease to exist therefore a value variable i for example can be used as an internal variable of a function and can also be used in some other function or in the main function they will actually physically be mapped to different memory locations so we have also seen what parameters are the parameters are communicate information between functions parameter and argument they also become local variables the arguments are local variables the parameters means the arguments are also local variables the benefits are divide and conquer we know we we as we have devoted one complete lecture on that manageable program development software reusability all existing functions can use can be used as building blocks for new programs and this is another thing that you may realize later that inside a function how I am implementing or how somebody has implemented it may be very complicated and I need not bother about that I know what it asks for what variables have to be put in through this and what output I will get out of it therefore whatever is there inside is abstracted out from me is hidden from me the internal details are not needed that is another big advantage of using functions and of course avoids code repetition something with somebody has written or say for example in a main program let us take another example to understand this better say I have got a program in which I am doing some computation say computing the standard deviation here I am computing the standard deviation here and maybe so at both these places are write this write this but that is not needed if I have a function for computing standard deviation then here is my main program and there is one function for standard deviation here and from this point I can simply call this get the value again continue from wherever I need I can again call this and I can get the value and in that way I save in the number of lines of code that I write so that is known as avoiding code repetition <sil=0.902> .PERIOD Now defining a function how do we now we are till now I was trying to explain you something now we are looking at the syntactic details of C function now that can vary from language to language but more or less the ideas are same so a function definition has got two parts the first line first line and the first line and the what is happening here first line and the body of the function <sil=0.911> .PERIOD Now what is the first line typically what can we have in the first line first line we have got the function name I do not know why it is not coming in the first line we have got the function name and the parameter list I call it argument list but whatever you so a function has got the first line and we can see what the first line is the first line will contain the function name and a return value type what type of value is being returned followed by this is the body of the function the second part is the body of the function where there are declarations and statements some internal values can be declared internal variables can be declared here and the other statements are also here now so that is so this one I actually I am calling them argument some people also call both of them to be parameters <sil=0.993> .PERIOD Now so the first line contains the return value type the function name and optionally a set of comma separated arguments enclosed in parenthesis like say here I am defining a function called GCD greatest common divisor it has got a type int and has got two arguments one is a and one is b I have written the types of them in this parenthesis itself int a comma int b they are comma separated the arguments is possible that I can declare the arguments also on the next line for example I can say instead of writing it in this way I can write in this way int GCD a comma b and in the next line before the body before the before the bracket probably in an earlier example I did a mistake I had put the bracket inside the bracket it should not be inside the bracket immediately after that it you can write int a comma b that means you are declaring that these are a and b either inside or immediately after that both of them are fine now these are called the formal arguments or some people also call it formal parameters <sil=0.983> .PERIOD Now what is the body of a function the body of a function is actually a compound statement I will just take just as I had statements like for loop or say while loop or if conditions where I write if some condition then some statement else some statement like that <sil=0.982> .PERIOD So now this whole thing is a compound statement similarly here the entire body of the function can be assumed to be a complete compound statement where we are passing on to arguments and giving us some value let us look at what is being done here in GCD int a int b <sil=0.995> .PERIOD So from the calling function must be I am supplying some values p and q may be two integers of type integers which are mapping to this p and q a and b <sil=0.939> .PERIOD Now here you know we have seen this algorithm earlier we take a variable temp now that is now the body of the function is defined by this basis temp while b is not divided by a as long as that does not happen we take we divide b by a and take the remainder and then go on that classical way of finding the GCD you find the remainder and make the remainder the divisor right <sil=0.909> .PERIOD So that is exactly what we are doing in a loop ultimately the final divisor which divides and gives us a 0 that will be the when that will be the GCD <sil=0.985> .PERIOD So that GCD now that GCD is coming in this a therefore I cannot here just write simply return I have to say that return a and maybe from the main function I had something like say h c f is equal to GCD p comma q now this a is being returned to this GCD and because this is because it was a GCD function this was called and that is why it is going to a is coming to the here and then by this assignment statement that is going to h c that is how the function is being connected and we also see what is the body of the function <sil=0.957> .PERIOD So when a function is called from some other function the corresponding arguments in the function are called actual arguments or actual parameters that means what I am calling parameter some people call them actual parameters <sil=0.991> .PERIOD So just in the earlier example p q where actual parameters and what was there a b or x y whatever was there is a b are the are the formal parameters or formal arguments <sil=0.922> .PERIOD Now as we had said the formal and the actual arguments must match in their data types the identifiers used as formal arguments are local not recognize outside the function the names of formal and actual arguments may differ as we have seen here they are differing my actual arguments were p q and here it is a and b of course they are differing now this a and b whatever it is here this a and b will not be reflected anywhere outside this function suppose here there is a main the main will not get the value of a and b this completely local here and as soon as it ends the a and b vanishes a and b will no longer be available to you same is true for temp because temp has been defined internally within this function all right <sil=0.930> .PERIOD So this is a very key thing that you must understand <sil=0.924> .PERIOD So so when a function is called from some other function the arguments are passed points to note that the names and of the formal and actual arguments may differ right <sil=0.912> .PERIOD So here I will conclude with this this lecture I will conclude with this example <sil=0.959> .PERIOD So here we are computing the g c d of 4 numbers in the main function we have got n 1 n 2 n 3 n 4 4 values have been read here you can see that they are being read as n 1 and n 2 and n 3 and n 4 they have been read <sil=0.992> .PERIOD Now the result is now g c d of n 1 into g c d of n 3 n 4 <sil=0.993> .PERIOD So there is one function g c d which takes int a int b right that is what we saw <sil=0.991> .PERIOD Now first when within this parenthesis we will first compute this g c d n 1 and n 2 <sil=0.903> .PERIOD So a will have n 1 the value of n 1 b will have the value of n 2 and the function will return something return a as we saw in the last example return a and so the body of the function ultimately ends with return a and that a will come here <sil=0.981> .PERIOD Suppose that value was 3 say so 3 comes here <sil=0.970> .PERIOD So what do I have now I have got g c d of 3 comma g c d of n 3 n 4 <sil=0.910> .PERIOD So now this same function will be called with a having the value of n 3 and b having the value of n 4 and suppose I compute them and I find ultimately that the g c d is 5 <sil=0.906> .PERIOD So the 5 will come here then what happens to this then will compute again called g c d with 3 and 5 <sil=0.925> .PERIOD So again here now a will have 3 and b will have 5 and the return of course the 3 and 5 will be the result the 8th shape of 3 and 5 is 1 <sil=0.912> .PERIOD So return a that will come here and the result will be 1 that is how the g c d is computed in cascading of the function calls <sil=0.910> .PERIOD The same function you see is being called time and again repeatedly from this single statement in the main function will continue looking at functions more <sil=0.982> .PERIOD So <sil=0.605> ,COMMA we are looking at computing standard deviation <sil=0.934> .PERIOD So <sil=0.423> ,COMMA standard deviation is mean we have seen <sil=0.950> .PERIOD Now <sil=0.575> ,COMMA standard deviation is if the mean is suppose the mean is represented by mu <sil=0.363> ,COMMA then I take the sum of the deviation from the mean for every element of the array <sil=0.967> .PERIOD So <sil=0.303> ,COMMA the array was A with every element being called A i <sil=0.906> .PERIOD So <sil=0.525> ,COMMA what I am trying to do is I am taking the difference of A i from the mean <sil=0.970> .PERIOD And since its difference can be suppose there are some values and this is the mean and the value can be a little away from the mean on this side more than the mean or less than the mean <sil=0.945> .PERIOD So <sil=0.446> ,COMMA we take the square of the mean square of the difference and I do that for all the elements i equals 1 to n <sil=0.977> .PERIOD And then I take the square root of the whole thing that is my standard deviation or the my variance <sil=0.927> .PERIOD So <sil=0.525> ,COMMA I can compute either this or this whatever I like <sil=0.925> .PERIOD So <sil=0.602> ,COMMA you will simply understand that in the code that we have given a little earlier <sil=0.426> ,COMMA then there we had computed the mean that means mu has been computed which was the average that we computed last time <sil=0.957> .PERIOD So <sil=0.632> ,COMMA if I have read the elements in an array whatever the elements are 5 <sil=0.421> ,COMMA 7 <sil=0.319> ,COMMA 3 <sil=0.431> ,COMMA 2 and I have computed the mean mu has been computed mean is 12 <sil=0.341> ,COMMA 3 <sil=0.548> ,COMMA 15 <sil=0.440> ,COMMA 17 divided by 4 <sil=0.924> .PERIOD So <sil=0.399> ,COMMA it is 4 point something 4 point 1 <sil=0.498> ,COMMA 4 point 2 <sil=0.423> ,COMMA 5 that is my mean <sil=0.982> .PERIOD So <sil=0.389> ,COMMA now for every element again in this array I find out for i s i and 0 i less than equal to 3 i plus plus what do I do for every element I have got the mu and let us call it average <sil=0.915> .PERIOD So <sil=0.312> ,COMMA sum was 0 what is it look like sum was 0 <sil=0.310> ,COMMA sum will be now sum plus I am getting sigma of mu minus a i whole square <sil=0.998> .PERIOD So <sil=0.561> ,COMMA sum plus average minus a i times average minus a i <sil=0.914> .PERIOD So <sil=0.552> ,COMMA that is the square average is mu minus a i that is so <sil=0.313> ,COMMA I am doing this square and I am repeatedly doing this and getting the new sum and at the end of this loop therefore <sil=0.336> ,COMMA I have got this <sil=0.926> .PERIOD So <sil=0.608> ,COMMA I can see STD <sil=0.429> ,COMMA say dev let me call it standard deviation is square root of the sum <sil=0.992> .PERIOD In that way I can find out the standard deviation also <sil=0.929> .PERIOD Now <sil=0.595> ,COMMA let us come to the now what is the application what is the meaning of this <sil=0.908> .PERIOD So <sil=0.588> ,COMMA with this say in a class you are you are supposed to write a program where you want to find out say in a class of physics what is the average of the numbers of all the students <sil=0.933> .PERIOD So <sil=0.329> ,COMMA I will find out the mean and mean of the class marks right <sil=0.962> .PERIOD Similarly <sil=0.526> ,COMMA I can find out that what is the standard deviation how much did it vary that also I can find out <sil=0.946> .PERIOD Now <sil=0.389> ,COMMA let us look at this new another problem say a shop stores in different types of items in different types of items <sil=0.939> .PERIOD Now <sil=0.600> ,COMMA given the number of items of each type sold during a given month and the corresponding unit prices compute the total monthly sale <sil=0.969> .PERIOD So <sil=0.472> ,COMMA what is the scenario the scenario is this I have got say 5 items item 1 item 2 item 3 item 4 and item 5 and let me call it the item let me call it on this side let me call it this area is item price item cost item cost <sil=0.954> .PERIOD Suppose <sil=0.376> ,COMMA the cost here is 7 and half rupees per item of type 0 25 for item of type 1 <sil=0.983> .PERIOD This is 0 this is 1 this is 2 this is 3 this is 4 <sil=0.988> .PERIOD So <sil=0.375> ,COMMA the item cost for this for item of type 2 is 12 <sil=0.919> .PERIOD 5 item of type 3 is 10 item of item of type 4 is 50 rupees <sil=0.940> .PERIOD Now <sil=0.571> ,COMMA I want to store how many items items items items items of each type has been sold <sil=0.909> .PERIOD So <sil=0.614> ,COMMA I take another array and call it item sold <sil=0.977> .PERIOD Suppose 5 items have been sold of type 0 6 items here of type 1 2 items of type 2 4 items of type 3 and 2 items of type 1 <sil=0.989> .PERIOD Now <sil=0.448> ,COMMA my question is what is the total sale <sil=0.990> .PERIOD So <sil=0.394> ,COMMA what should I do you can easily understand that the here is item cost <sil=0.973> .PERIOD So <sil=0.589> ,COMMA I have to multiply this with this and add all these costs <sil=0.976> .PERIOD So <sil=0.548> ,COMMA it will be 7 <sil=0.974> .PERIOD 5 times 5 it will be 7 <sil=0.966> .PERIOD 5 times 5 plus 25 times 6 plus so and so forth in that way I can find the total cost <sil=0.952> .PERIOD So <sil=0.514> ,COMMA what will the program look like program will look like I will be needing to add is item cost and item sold and they should be of the same size assuming that I know beforehand that there are 5 items <sil=0.932> .PERIOD So <sil=0.389> ,COMMA I can start with item cost of type 5 but this will be cost will be of type float and they will be another the number of items is item sold the number of items sold is integer <sil=0.963> .PERIOD So <sil=0.574> ,COMMA I will have this <sil=0.988> .PERIOD I am not showing the part that here I am reading the 2 arrays <sil=0.918> .PERIOD So <sil=0.454> ,COMMA after I read the arrays I will have 2 arrays like this one is an integer array another is a floating pointer this is a float and this is an integer <sil=0.914> .PERIOD Now <sil=0.379> ,COMMA my actual body of the program will be in a loop for say I am doing it using for say I assign 0 I less than equal to 4 since the size is 5 I plus plus and what do I do here what do I do in the body of the for loop I take I write actually only one statement will do there is no harm in putting this bracket total cell which was a variable of type float total cell is total cell was initialized to 0 total cell plus item cost I times multiplied by item sold I <sil=0.984> .PERIOD So <sil=0.552> ,COMMA this will be done in a loop and so I will take the first item item cost 0 multiply with that with item cost item sold 0 add that with the total cell which was initialized to 0 <sil=0.916> .PERIOD So <sil=0.451> ,COMMA here I can have float total cell initialized to 0 0 <sil=0.916> .PERIOD 0 I can do that <sil=0.900> .PERIOD So <sil=0.361> ,COMMA now I am doing it in a loop <sil=0.948> .PERIOD So <sil=0.594> ,COMMA first I multiply these 2 add it to total cell next again in the next iteration I is incremented I take these 2 and multiply them and add it to the total cell <sil=0.965> .PERIOD Then I do this 2 and multiply them add it to the total cell and I go on in this way this is another this is in this way by using this array I will be able to add all this values and I will get the total cell at the end <sil=0.922> .PERIOD So <sil=0.457> ,COMMA here we could see 2 very nice examples of application of arrays <sil=0.949> .PERIOD Now <sil=0.419> ,COMMA one another problem that I gave you I mean is I was while comparing the arrays you can do it in multiple ways that there is 2 arrays you must have solved it by now <sil=0.959> .PERIOD That there were 2 arrays like this 7755 here 6 here 4 but again 3 3 <sil=0.937> .PERIOD So <sil=0.620> ,COMMA everywhere they are matching but intermediate they were affected and I had a flag value <sil=0.926> .PERIOD So <sil=0.368> ,COMMA flag was initialized to 1 and then in a fall loop then in the fall loop I was checking this was A and this was B flag was initialized to 1 <sil=0.936> .PERIOD So <sil=0.633> ,COMMA if A i is equal to B i this I can do because here I am doing it element wise then flag equal to 1 else flag equal to 0 and I can do exit and I come out of the loop straight way I come out of the loop because it does not really matter at which position the mismatch occurs as soon as the mismatch occurs I can say the flag is 0 and so I come out <sil=0.954> .PERIOD So <sil=0.372> ,COMMA when I was comparing this whenever I find a mismatch the flag will become 0 and it will not be reset to 1 again because of this mismatch because this part is not being computed <sil=0.962> .PERIOD I need not computed I need not computed because my objective was to see if the 2 arrays are equal and here the violation has already occurred <sil=0.963> .PERIOD So <sil=0.555> ,COMMA they are not equal however so that is one way you can try it with while loop also you can try with while to solve the same problem <sil=0.920> .PERIOD Another point is here the time and again here everywhere I am setting the flag to 1 <sil=0.922> .PERIOD I could have changed that also here if what did I need to do I go on I have in set flag to 1 and the condition I simply change I just change the condition <sil=0.901> .PERIOD If AI is not equal to BI then make flag 0 I could have done this as long as this condition is not holding I am going on doing the loop <sil=0.915> .PERIOD Is it clear I will go on doing the loop as long as there is no mismatch this condition means mismatch as soon as there is a mismatch I will set the flag to 0 and exit <sil=0.905> .PERIOD There is another way of solving the problem <sil=0.942> .PERIOD So <sil=0.617> ,COMMA you have to think logically what exactly you need to do and what exactly you are writing what is the flow and what is happening with the variables and I always suggest that you have small pictures of the different variables and see how they are changing in the course of running the program <sil=0.961> .PERIOD Now <sil=0.432> ,COMMA so we have seen a useful commercial so called toy commercial problem that how I can find out the cost of total sales or monthly sales <sil=0.936> .PERIOD So <sil=0.440> ,COMMA and here the number of items sold per month are given then you can do it <sil=0.905> .PERIOD Next let us look at a very important thing called searching <sil=0.989> .PERIOD Searching is a fundamental task in any and in fact in many computations in many computations we need to search <sil=0.939> .PERIOD What do you search there different types of searches but we will be now talking about the simplest possible search that is we are trying to find out whether a particular element is there in an array <sil=0.900> .PERIOD So <sil=0.311> ,COMMA the purpose is to check if a given element which is known as the key is there in the array or not <sil=0.975> .PERIOD We will first talk about the array is not arranged in any order and we will do that <sil=0.920> .PERIOD So <sil=0.510> ,COMMA suppose I ask the question that is there any even number in the set of numbers given suppose there are some numbers given 5 <sil=0.433> ,COMMA 7 <sil=0.629> ,COMMA 2 <sil=0.650> ,COMMA 9 <sil=0.433> ,COMMA 1 <sil=0.476> ,COMMA 8 <sil=0.571> ,COMMA 3 like that <sil=0.988> .PERIOD I want to see and suppose this is a huge this is a list of 100 numbers <sil=0.970> .PERIOD I want to find out whether there is any particular number forget about even number for the timing <sil=0.902> .PERIOD For the timing let us assume that I want to see whether in this list any 4 is there <sil=0.933> .PERIOD Is there any 4 in the list that is the question that we are asking the answer can be either yes or no <sil=0.956> .PERIOD If it is yes then the next question comes where in the list is it there is it where means in which position it is there <sil=0.913> .PERIOD I may ask like to know the position or I may not like to know the position I would be satisfied to know whether this list contains any 4 or not <sil=0.911> .PERIOD So <sil=0.379> ,COMMA 5 <sil=0.411> ,COMMA 7 <sil=0.427> ,COMMA 2 <sil=0.523> ,COMMA 9 <sil=0.371> ,COMMA 1 <sil=0.380> ,COMMA 8 <sil=0.641> ,COMMA 3 <sil=0.473> .PERIOD So <sil=0.414> ,COMMA again 5 <sil=0.586> ,COMMA 7 <sil=0.501> ,COMMA 2 <sil=0.559> ,COMMA 9 <sil=0.323> ,COMMA 1 <sil=0.405> ,COMMA 8 <sil=0.415> ,COMMA 3 and my key is 4 because I am interested in the existence of 4 <sil=0.926> .PERIOD So <sil=0.396> ,COMMA instead of writing the C which you will be writing I will be discussing how to approach this problem what would the pseudo code be <sil=0.999> .PERIOD And I am sure in the assignments in your practice you can write the program <sil=0.969> .PERIOD So <sil=0.384> ,COMMA I know I need to know beforehand this list <sil=0.963> .PERIOD So <sil=0.460> ,COMMA I need to know a list which may be an integer list of might be here 7 numbers I need to know that <sil=0.918> .PERIOD Also I need to know which key I am searching for once I know these 2 <sil=0.933> .PERIOD So <sil=0.533> ,COMMA I know 5 <sil=0.305> ,COMMA 7 <sil=0.599> ,COMMA 2 <sil=0.412> ,COMMA 9 <sil=0.576> ,COMMA 1 <sil=0.321> ,COMMA 8 <sil=0.639> ,COMMA 3 is my list and I know that 4 is my key then how should I go about it <sil=0.923> .PERIOD I have got 4 in mind I start to look at as if I am looking at through some means at different positions <sil=0.919> .PERIOD I look at this position and check this element and compare this element with the key and I ask are the equal <sil=0.984> .PERIOD If the answer is yes then obviously I can say that 4 is in the list <sil=0.924> .PERIOD But as you can see it is not true so in case of no I will shift my focus from here to here <sil=0.993> .PERIOD And I will now compare with 4 this element 7 are the equal no then I will again shift the focus and I will go on <sil=0.905> .PERIOD Shift the focus and I will compare with this element with the key <sil=0.931> .PERIOD In that I will go on how long shall I go on till the end of the list <sil=0.935> .PERIOD If suppose here there was a 4 instead of 1 there was a 4 here <sil=0.984> .PERIOD And when my focus changes to this point and then again comes to this point and then I find that this element is matching the key value then I can exit and say yes 4 is there in the list <sil=0.940> .PERIOD Then if the other question has to be answered that 4 is there but where is 4 <sil=0.921> ?QUESTIONMARK In that case what would be your answer would be this position <sil=0.958> .PERIOD And what is this position <sil=0.989> ?QUESTIONMARK This position is nothing but the current index <sil=0.634> ,COMMA current value of the index <sil=0.998> .PERIOD Here the index started this is my index which was shifting <sil=0.976> .PERIOD So now we can think of the algorithm I have got 5 <sil=0.345> ,COMMA 7 <sil=0.399> ,COMMA 2 <sil=0.574> ,COMMA 9 <sil=0.559> ,COMMA 1 <sil=0.390> ,COMMA 8 <sil=0.546> ,COMMA 3 and my key is 4 <sil=0.971> .PERIOD So I will be doing so this is a loop which is list 4 equals 0 that means the focus of the index I less than equal to 1 <sil=0.334> ,COMMA 2 <sil=0.649> ,COMMA 3 <sil=0.373> ,COMMA 4 <sil=0.311> ,COMMA 5 <sil=0.401> ,COMMA 6 <sil=0.350> ,COMMA 7 <sil=0.553> ,COMMA 6 <sil=0.429> ,COMMA I plus plus <sil=0.964> .PERIOD If list I that means the Ith element of the list is equal to the key then I can say found the list <sil=0.956> .PERIOD And I that means the Ith element of the list is equal to the key then I can say found assigned 1 <sil=0.999> .PERIOD What is found <sil=0.883> ?QUESTIONMARK Found is some variable which I have initialized at this point initially nothing is found it is not found <sil=0.989> .PERIOD So found is 0 initially I have not found the key <sil=0.963> .PERIOD Here I am comparing as soon as I compare I put found equal to 1 and then I can exit or this automatically this loop will go on <sil=0.919> .PERIOD Now if I do it in this way what is the problem <sil=0.897> ?QUESTIONMARK Suppose my key was 1 then it goes on I 0 this is never happening found is still 0 it goes on it comes to here and I count come to found equal to 1 <sil=0.995> .PERIOD And then I can say if found equal to 1 I can print F <sil=0.978> .PERIOD Print F key found at position percentage D I <sil=0.935> .PERIOD So at that point I can also print that it has been found here <sil=0.913> .PERIOD In the worst case what can happen <sil=0.974> ?QUESTIONMARK Found will remain 0 and I will come to the end of this point when I come here I can check if found equal to 1 <sil=0.959> .PERIOD If found is 0 print F key not found if I do not find it there can be different flavors of the same problem <sil=0.986> .PERIOD The other flavor could be that suppose this element 1 is there at multiple places suppose it is also here <sil=0.933> .PERIOD And what will this program result in what would be its output <sil=0.941> ?QUESTIONMARK I will go on checking here I will check the for loop is extending up to which part <sil=0.979> ?QUESTIONMARK For loop is extending up to this position and this is separate I should not have I should have written it on this side <sil=0.950> .PERIOD So I go on checking this so key is found at position number 0 1 2 3 4 key is found at position 4 the list is not exhausted <sil=0.976> .PERIOD Ultimately it will come to this point and when it and again it will say the key is found at position 6 twice it is found it will be told like that <sil=0.905> .PERIOD Key is it will print twice if at the end it comes and still the key the value of the variable found is 0 that will say print it is not found <sil=0.998> .PERIOD I could have also say the same thing same problem I do say suppose I have got a list 5792131 <sil=0.907> .PERIOD The question is how many ones are there the same algorithm will do the same algorithm will work <sil=0.906> .PERIOD The same algorithm the algorithm is I start from one point from this beginning I let me draw it in this way if this be an array where all my elements are there <sil=0.993> ?QUESTIONMARK 5792131 I start from the beginning I equal 0 and for every element I compare with the key and go on till the end <sil=0.985> .PERIOD Now if I want to do this what is the additional variable that I will require I will require another variable count which is initially 0 other than found which is also false <sil=0.911> .PERIOD So whenever I find the one and my key is one so whenever I find the one I will say found is equal to one and also I will do count plus plus and I will continue <sil=0.944> .PERIOD Here I come and I will find I will have the value of count with 2 <sil=0.921> .PERIOD So I can also say that here I could print where found is becoming one so I can say at which position it is found and how many times it is found <sil=0.951> .PERIOD Now it can another flavor could be that I have got this say this array I have got this array and some array 632915 and whenever I have been given a key say the key is 2 <sil=0.916> .PERIOD As soon as I find 2 that is enough for me I just want to know whether 2 is there in the list I am not interested to know how many times it is there or in which position it is there or at best I may like to know at which position I found it first <sil=0.983> .PERIOD So what I can do I will go on searching like this and whenever you find 2 then you print that I have found 2 here and exit <sil=0.998> .PERIOD So what will you do the loop will be the loop inside the loop you will have you can do it like this that if a i or list i let us I was writing list i is not equal to key <sil=0.956> .PERIOD So you could have done it by while also n minus 1 i plus plus you go on doing this if list i is not equal to sorry if it is equal to n minus 1 i plus plus you go on doing this <sil=0.948> .PERIOD List i is not is sorry if it is equal to the key whatever I done is equal to key say found equal to 1 and print F the position and exit <sil=0.982> .PERIOD And you did not go through the entire loop now there are so that is this sort of search which I am doing in a linear way from one side to the other is known as linear search is a simple very simple search for a particular element <sil=0.952> .PERIOD We will see a little bit more on this next lecture <sil=0.995> .PERIOD So <sil=0.626> ,COMMA we were discussing about pointers and we have seen that pointer is a variable <sil=0.904> .PERIOD So <sil=0.589> ,COMMA since it is a variable <sil=0.365> ,COMMA but a variable that points to some other variable <sil=0.964> .PERIOD But naturally the question that can arise is since pointers are variables <sil=0.502> ,COMMA we should be able to do some sort of operations like arithmetic operations on them <sil=0.960> .PERIOD So <sil=0.553> ,COMMA the answer is yes <sil=0.336> ,COMMA we can do that and in today's lecture we will look at exactly that pointer expressions <sil=0.985> .PERIOD Now <sil=0.398> ,COMMA this concept of pointers is a very strong component of the C language and it is not the case that in all languages this pointer is there <sil=0.607> ,COMMA but we are discussing pointers specifically because it will give you a very good idea about what indirection is <sil=0.936> .PERIOD We had mentioned about indirection right <sil=0.987> .PERIOD So <sil=0.523> ,COMMA for example <sil=0.459> ,COMMA I am just before moving into the actual discussion <sil=0.432> ,COMMA let me come to this that what is an indirection <sil=0.937> .PERIOD Somebody asks you the address of Tom's house <sil=0.900> .PERIOD You can do two things <sil=0.979> .PERIOD You can either give him the address of Tom's house or you can give him the address of John's house <sil=0.959> .PERIOD So <sil=0.410> ,COMMA that he goes to John's house and asks John to get the address of Tom's house <sil=0.951> .PERIOD So <sil=0.557> ,COMMA I do not know Tom's address <sil=0.507> ,COMMA but I know John who knows Tom's address <sil=0.955> .PERIOD This is indirection <sil=0.359> ,COMMA one level of indirection <sil=0.974> .PERIOD Another level of indirection could be that second level of indirection <sil=0.974> .PERIOD You can go to Ram and Ram will know the address of John who knows the address of Tom <sil=0.946> .PERIOD So <sil=0.629> ,COMMA that is second level of indirection <sil=0.984> .PERIOD So <sil=0.585> ,COMMA in our case we have got a particular variable P <sil=0.927> .PERIOD Let me just call this variable x and that x has got some value <sil=0.953> .PERIOD I am not saying and x has also got an address <sil=0.551> ,COMMA but I am not saying what is the value of x <sil=0.893> ?QUESTIONMARK What is x <sil=0.927> ?QUESTIONMARK That is my question <sil=0.963> .PERIOD And instead of answering that <sil=0.341> ,COMMA I am giving you a pointer to x and I am asking that I tell you <sil=0.582> ,COMMA I give you the answer go to P and find x <sil=0.994> .PERIOD So <sil=0.391> ,COMMA then P must be assigned the address of x <sil=0.904> .PERIOD So <sil=0.436> ,COMMA I go to this <sil=0.364> ,COMMA then I come to P and get the value of x as I want to have that in some other variable V <sil=0.379> ,COMMA where I want to have star P <sil=0.923> .PERIOD So <sil=0.457> ,COMMA indirectly I could have done simply V assigned x <sil=0.512> ,COMMA this two are equivalent <sil=0.947> .PERIOD That is what we discussed in the last class <sil=0.921> .PERIOD That is why this is an indirection that often comes in very handy <sil=0.624> ,COMMA very useful when we carry out many computations <sil=0.946> .PERIOD So <sil=0.551> ,COMMA like other variables <sil=0.308> ,COMMA pointer variables can also be used in expressions <sil=0.900> .PERIOD If P 1 and P 2 are two pointers <sil=0.563> ,COMMA the following statements are valid <sil=0.956> .PERIOD Star P 1 plus star P 2 <sil=0.945> .PERIOD So <sil=0.361> ,COMMA what is being meant by that <sil=0.955> ?QUESTIONMARK Suppose P 1 is pointing to something where there is 50 and P 2 is pointing to something <sil=0.404> ,COMMA which is stored as 60 <sil=0.966> .PERIOD Then what is some <sil=0.948> ?QUESTIONMARK Some becomes 50 plus 60 <sil=0.906> .PERIOD So <sil=0.588> ,COMMA this is star P 1 plus star P 2 <sil=0.308> ,COMMA 50 plus 60 <sil=0.947> .PERIOD So <sil=0.546> ,COMMA that should be 110 <sil=0.931> .PERIOD Next <sil=0.466> ,COMMA similarly I can have this <sil=0.405> ,COMMA but here it is a little <sil=0.454> ,COMMA it will be nicer if I had <sil=0.521> ,COMMA it will be easier nicer to read <sil=0.517> ,COMMA if I had put parenthesis <sil=0.556> ,COMMA so that I am not confused about this asterisk and this asterisk <sil=0.971> .PERIOD These have got completely different significance <sil=0.936> .PERIOD This is a multiplication and this is saying <sil=0.458> ,COMMA this asterisk is saying <sil=0.423> ,COMMA it is a content of a particular pointer <sil=0.989> .PERIOD Similarly <sil=0.341> ,COMMA these two are equivalent of course <sil=0.578> ,COMMA I have already shown that <sil=0.958> .PERIOD Now <sil=0.641> ,COMMA this is also possible <sil=0.916> .PERIOD Star P 1 <sil=0.481> ,COMMA so in my earlier drawing <sil=0.315> ,COMMA P 1 was 50 <sil=0.644> ,COMMA 50 plus 2 <sil=0.535> ,COMMA that is being coming over here <sil=0.938> .PERIOD So <sil=0.314> ,COMMA this one looks like that <sil=0.969> .PERIOD Whenever you are finding difficulty <sil=0.352> ,COMMA as I suggested <sil=0.444> ,COMMA just draw a simple diagram <sil=0.912> .PERIOD P 1 <sil=0.464> ,COMMA P 1 is pointing to some other variable <sil=0.598> ,COMMA which has got the value 40 <sil=0.952> .PERIOD So <sil=0.550> ,COMMA P 1 <sil=0.362> ,COMMA star P 1 is what <sil=0.890> ?QUESTIONMARK Star P 1 is that particular variable X and plus 2 <sil=0.520> ,COMMA that is equivalent to X plus 2 <sil=0.643> ,COMMA which is 42 <sil=0.998> .PERIOD And so <sil=0.381> ,COMMA that is coming to <sil=0.577> ,COMMA so this one is being modified to 42 <sil=0.994> .PERIOD Similarly <sil=0.636> ,COMMA I can do other operations like this <sil=0.525> ,COMMA where you must understand that this is actually talk just like another variable that an integer variable or whatever type P 1 is <sil=0.529> ,COMMA that type of variable <sil=0.942> .PERIOD And it is simple <sil=0.490> ,COMMA no other complications in that <sil=0.926> .PERIOD Now <sil=0.449> ,COMMA what are allowed in C <sil=0.858> ?QUESTIONMARK The certain things are allowed in C and some things are not allowed in C <sil=0.905> .PERIOD I can add an integer to a pointer <sil=0.903> .PERIOD I can subtract an integer from a pointer <sil=0.953> .PERIOD I can subtract one pointer from another <sil=0.980> .PERIOD And say if P 1 and P 2 are both pointers to the same array <sil=0.502> ,COMMA then P 2 minus P 1 gives the number of elements between P 1 and P 2 <sil=0.940> .PERIOD For example <sil=0.606> ,COMMA suppose here there is an array <sil=0.937> .PERIOD So <sil=0.622> ,COMMA P 1 is pointing here and P 2 is pointing here <sil=0.989> .PERIOD Then the number of elements P 2 minus P 1 will be just the subtraction of these addresses <sil=0.977> .PERIOD Suppose this was 5500 <sil=0.565> ,COMMA 5 and 1 if it be a character <sil=0.540> ,COMMA 5 and 1 <sil=0.623> ,COMMA 5 and 2 <sil=0.391> ,COMMA 5 and 3 <sil=0.906> .PERIOD So <sil=0.419> ,COMMA I have got three elements in between <sil=0.928> .PERIOD So <sil=0.471> ,COMMA these are all allowed <sil=0.921> .PERIOD I can subtract an integer from a pointer <sil=0.971> .PERIOD I can add an integer to a pointer <sil=0.919> .PERIOD So <sil=0.470> ,COMMA if I add an integer to a pointer <sil=0.436> ,COMMA that is P 1 <sil=0.402> ,COMMA P 1 plus 1 <sil=0.944> .PERIOD So <sil=0.408> ,COMMA that means it will point to this point <sil=0.332> ,COMMA this element <sil=0.973> .PERIOD What are not allowed <sil=0.873> ?QUESTIONMARK The things that are not allowed are you cannot add two pointers <sil=0.912> .PERIOD The reason is obvious <sil=0.973> .PERIOD P 1 is a pointer and P 2 is a pointer <sil=0.911> .PERIOD Now <sil=0.466> ,COMMA these two are two different locations <sil=0.972> .PERIOD So <sil=0.594> ,COMMA say P 1 is in location 7000 pointing to some variable and P 2 is in location 10000 pointing to some other variable <sil=0.940> .PERIOD So <sil=0.638> ,COMMA what does P 1 plus P 2 mean <sil=0.989> ?QUESTIONMARK 7000 plus 10000 <sil=0.304> ,COMMA 17000 that does not mean anything <sil=0.932> .PERIOD That can be a point to some garbage value or something else <sil=0.966> .PERIOD So <sil=0.450> ,COMMA that is not allowed <sil=0.910> .PERIOD Compiler we hold you for that <sil=0.985> .PERIOD Multiply or divide a pointer in an expression <sil=0.966> .PERIOD That is also not allowed <sil=0.997> .PERIOD You cannot multiply <sil=0.943> .PERIOD You can just add an integer <sil=0.380> ,COMMA subtract an integer or subtract one pointer from another <sil=0.958> .PERIOD These three you can do <sil=0.985> .PERIOD And here is something which is known as a scale factor <sil=0.954> .PERIOD Let us see whether you understand this or not <sil=0.941> .PERIOD We have seen that an integer value can be added or subtracted <sil=0.956> .PERIOD So <sil=0.625> ,COMMA here let us look at this <sil=0.908> .PERIOD P 1 and P 2 are two pointers of type integer <sil=0.965> .PERIOD I mean P 1 is pointing to an integer <sil=0.941> .PERIOD P 2 is also pointing to an integer <sil=0.935> .PERIOD Now <sil=0.335> ,COMMA I j are two integer variables <sil=0.947> .PERIOD P 1 is P 1 plus 1 <sil=0.916> .PERIOD That means what <sil=0.880> ?QUESTIONMARK P 1 was pointing somewhere <sil=0.902> .PERIOD But I am just adding some constant to that <sil=0.907> .PERIOD Here is a MA location <sil=0.917> .PERIOD And say P 1 is pointing to this <sil=0.984> .PERIOD And suppose it is an integer <sil=0.952> .PERIOD So <sil=0.306> ,COMMA this pointing to an integer <sil=0.917> .PERIOD Now <sil=0.513> ,COMMA P 1 plus 1 means this will point to the next integer <sil=0.954> .PERIOD Now <sil=0.343> ,COMMA I am not saying whether if an integer takes two bytes <sil=0.647> ,COMMA each of them are of two bytes <sil=0.970> .PERIOD So <sil=0.577> ,COMMA it just comes to the next integers <sil=0.975> .PERIOD The pointer arithmetic is that is why the type is important <sil=0.998> .PERIOD Depending on the type <sil=0.606> ,COMMA it is updating either by 2 or by 1 <sil=0.950> .PERIOD But P 1 plus 1 means I am going to the next <sil=0.924> .PERIOD I am P 2 plus P 2 is assigned P 1 plus j <sil=0.301> ,COMMA where j can be something <sil=0.986> .PERIOD So <sil=0.360> ,COMMA it goes to the so P 2 was pointing somewhere here <sil=0.940> .PERIOD I am upgrading that with the j value going to the jth next <sil=0.923> .PERIOD Similarly <sil=0.461> ,COMMA P 2 plus plus P 2 assigned any arithmetic operation I can do <sil=0.973> .PERIOD Next <sil=0.536> ,COMMA in reality it is not the integer value which is added or subtracted <sil=0.981> .PERIOD But rather the scale factor times the value <sil=0.919> .PERIOD That is one means one times the size of the integer <sil=0.970> .PERIOD So <sil=0.357> ,COMMA j times the size of an integer <sil=0.620> ,COMMA two bytes <sil=0.491> ,COMMA four bytes <sil=0.371> ,COMMA that is what <sil=0.931> .PERIOD That is why it is called the scale factor <sil=0.964> .PERIOD So <sil=0.339> ,COMMA this is not this one <sil=0.442> ,COMMA but next <sil=0.538> ,COMMA one next <sil=0.378> ,COMMA two next <sil=0.355> ,COMMA here jth next like that <sil=0.938> .PERIOD So <sil=0.553> ,COMMA for character the scale factor is one <sil=0.446> ,COMMA integer is four <sil=0.311> ,COMMA a four bytes take one integer <sil=0.464> ,COMMA float <sil=0.560> ,COMMA four <sil=0.990> .PERIOD Now <sil=0.392> ,COMMA this could be two <sil=0.445> ,COMMA that depends on what the scale factor is depends on the particular machine <sil=0.997> .PERIOD So <sil=0.323> ,COMMA if I write a for an integer pointer assuming the my computer is actually doing this <sil=0.356> ,COMMA that each of them is four <sil=0.416> ,COMMA then P 1 plus plus is adding P 1 by four <sil=0.942> .PERIOD That is going to the next integer <sil=0.440> ,COMMA going to the next integer <sil=0.933> .PERIOD Now <sil=0.375> ,COMMA in between there are four bytes <sil=0.974> .PERIOD So <sil=0.524> ,COMMA I am going to the next integer <sil=0.928> .PERIOD So <sil=0.526> ,COMMA there is one quick way of finding out how we can find out what is my representation in my system <sil=0.923> .PERIOD There is a nice inbuilt function called size of <sil=0.940> .PERIOD So <sil=0.379> ,COMMA if I give size of int <sil=0.526> ,COMMA the system returns me the value four or two depending on how much <sil=0.477> ,COMMA how many bytes does int consume <sil=0.953> .PERIOD Similarly <sil=0.576> ,COMMA I could have given size of float that will tell me how many bytes does the float consume so and so forth <sil=0.903> .PERIOD So <sil=0.617> ,COMMA that is one way to find the scale factors <sil=0.945> .PERIOD So <sil=0.389> ,COMMA number of bytes occupied by float is size of float <sil=0.917> .PERIOD If you give that the system will give you the size of returns that one that value <sil=0.945> .PERIOD The number of bytes required for that representation <sil=0.993> .PERIOD So <sil=0.335> ,COMMA in the system you would run this and you find that it is float is four <sil=0.405> ,COMMA int is four <sil=0.311> ,COMMA then you know what my scale factor is <sil=0.909> .PERIOD Now <sil=0.520> ,COMMA just like for every case we are thinking of how do we pass an array to a function <sil=0.619> ,COMMA how do we pass a structure to a function <sil=0.981> .PERIOD Here again we look at how do we pass a pointer to a function <sil=0.943> .PERIOD Pointers are often passed as parameters to a function and if you have thought about it you must have already discovered <sil=0.944> .PERIOD Now <sil=0.355> ,COMMA always it allows the data items within the calling programs to be accessed by the function altered and then return to the calling function in the altered form <sil=0.984> .PERIOD This is the calling by reference <sil=0.994> .PERIOD Normally arguments are passed to a function by value <sil=0.990> .PERIOD We have discussed this <sil=0.984> .PERIOD Now <sil=0.529> ,COMMA this is called as call by reference or call by address <sil=0.941> .PERIOD Now <sil=0.308> ,COMMA you can see this how this is done <sil=0.919> .PERIOD Because in call by value we have seen that in the swap function for example it was swapped within the function <sil=0.944> .PERIOD But that x y and the main function x y were two different entities <sil=0.922> .PERIOD Therefore <sil=0.590> ,COMMA whatever change was there that was lost <sil=0.977> .PERIOD Therefore <sil=0.419> ,COMMA here but if I had just passed on the pointer then whatever change I do in the pointer in that particular location I simply pass on the address and make a change over there then the change is reflected <sil=0.944> .PERIOD Because it is the same location that is known as call by reference <sil=0.948> .PERIOD Now <sil=0.432> ,COMMA here is an example of you have seen this passing by value <sil=0.985> .PERIOD I am repeating this a was 5 and b was 20 <sil=0.995> .PERIOD I call swap a b here what happened it took x was 5 <sil=0.456> ,COMMA b was 20 <sil=0.958> .PERIOD I changed it <sil=0.971> .PERIOD Now <sil=0.334> ,COMMA x was therefore now x was 20 and b was 5 <sil=0.908> .PERIOD But when I returned and printed this a and b they were completely different <sil=0.938> .PERIOD So <sil=0.599> ,COMMA swapping was not reflected <sil=0.982> .PERIOD Therefore <sil=0.577> ,COMMA here x and y were swapped a and b do not swap but instead so the output would be the same 5 and 20 <sil=0.949> .PERIOD But if I had done through reference here you see how I pass it on <sil=0.923> .PERIOD Here what I am passing you have must have thought about it <sil=0.925> .PERIOD So <sil=0.324> ,COMMA up instead of sending that value what I am sending is the address of a and address of b and here inside the function what am I accepting I am accepting the pointer <sil=0.944> .PERIOD So <sil=0.505> ,COMMA here x and y I know that what is coming to me is a pointer <sil=0.939> .PERIOD So <sil=0.442> ,COMMA what happened here it was 5 we discussed it earlier also but let me repeat because it is a very fundamental idea b is 20 and now I swap <sil=0.975> .PERIOD So <sil=0.603> ,COMMA here I have got do I have x no I have got this x which is nothing but and a and I have got this y which is nothing but and b <sil=0.950> .PERIOD Therefore <sil=0.385> ,COMMA they are pointing to this points <sil=0.962> .PERIOD Now when I swap I am actually swapping the content of x <sil=0.967> .PERIOD So <sil=0.542> ,COMMA the content of x that means here that is going to t and then content of y in direction I go from here follow my cursor I go here and that one is going as the content of a content of x <sil=0.996> .PERIOD So <sil=0.340> ,COMMA here it is becoming 20 and then t is coming as the content of y what is y <sil=0.957> .PERIOD Y is here <sil=0.960> .PERIOD So <sil=0.331> ,COMMA this is coming as 5 <sil=0.905> .PERIOD So <sil=0.625> ,COMMA when I come out and print here a and b as you can see has changed <sil=0.975> .PERIOD So <sil=0.347> ,COMMA you see how did I pass on the parameter look at this I have passed on the address and I have accepted them in my function as the pointer <sil=0.944> .PERIOD So <sil=0.629> ,COMMA with this we will get the correct answer x and y swap a and b also swap <sil=0.961> .PERIOD So <sil=0.422> ,COMMA the answer is that is correct one as we expected <sil=0.938> .PERIOD So <sil=0.536> ,COMMA now let us skip this a little bit and let us go to something else as pointers and addies <sil=0.966> .PERIOD When an array is declared when an array is declared the compiler allocates a base address and sufficient amount of storage <sil=0.927> .PERIOD You know that when I declare something an array int a 10 and if I say that int I have discovered using size of that int takes 4 bytes then for every element 4 bytes are kept and 40 such locations are allocated <sil=0.945> .PERIOD For me means for the array a <sil=0.914> .PERIOD Now <sil=0.528> ,COMMA this is alright <sil=0.947> .PERIOD Now <sil=0.359> ,COMMA when I refer to this array a because we saw that we pass on an array by reference to a function when we pass an array we call it by reference the reason behind that is that this name array a is the same as a pointer to the first location of that <sil=0.914> .PERIOD So <sil=0.383> ,COMMA it is as if equivalent to a is a pointer that is pointing to the first location of this array a alright they are equivalent <sil=0.978> .PERIOD So <sil=0.456> ,COMMA the base address is the location of the first element of the array the compiler also defines the array name as a constant pointer to the first element constant pointer <sil=0.944> .PERIOD When I declared the compiler also keeps a constant pointer that pointer you cannot change for example <sil=0.426> ,COMMA when I say x 5 1 2 3 4 5 then suppose the base addresses 2500 each integer requires 4 bytes then the elements will be x 0 will be 2500 x 1 will be 2500 so and so forth <sil=0.918> .PERIOD And the pointer will be 2500 if you go up 2500 so there is a pointer x means and address of x 0 which is 2500 alright <sil=0.961> .PERIOD So <sil=0.366> ,COMMA p assigned x and p assigned end of x 0 are equivalent <sil=0.933> .PERIOD So <sil=0.626> ,COMMA we can access successive values of x by using p plus plus or p minus minus to move from one element to another <sil=0.995> .PERIOD So <sil=0.494> ,COMMA I have got the p I have got this pointer is pointing to the array I cannot change that pointer but if I do p plus plus this point in the first element then I go to the next element of the array accord by the scale factor <sil=0.902> .PERIOD So <sil=0.545> ,COMMA this is if I do p plus plus I am actually doing p plus 4 set in that way I can move across <sil=0.924> .PERIOD So <sil=0.563> ,COMMA the relationships should be clear here so p plus 1 is the next one p plus 2 is the next one that we have already explained <sil=0.981> .PERIOD So <sil=0.383> ,COMMA here is a function to find average here you see we have got and a main program where I have got an array 100 elements for k assigned k to n for k 0 to n <sil=0.921> .PERIOD So <sil=0.541> ,COMMA I am reading k and then I am calling this average x I am calling average x n <sil=0.913> .PERIOD Now <sil=0.453> ,COMMA here what goes average x n you have seen this now you am passing the pointer when I am saying I am just passing the array actually I have passed on the pointer <sil=0.928> .PERIOD So <sil=0.487> ,COMMA whatever I do I am doing here I am taking another star p which is local which is pointing to the array <sil=0.957> .PERIOD So <sil=0.372> ,COMMA my array was here and I am putting another pointer p which is pointing to this array and array means what <sil=0.957> ?QUESTIONMARK array means the first location of the array then I carry on the sum here I carry on with p I here you see what I do I take p and then I change p sum assigns star p plus I <sil=0.998> .PERIOD So <sil=0.406> ,COMMA I am p plus 1 p plus 2 p plus 3 and star p plus 1 p plus 2 means the content of this these contents <sil=0.946> .PERIOD So <sil=0.445> ,COMMA here in this way I am getting the sum and returning what do I return return float sum by size <sil=0.985> .PERIOD So <sil=0.444> ,COMMA I get sum obviously the array was integer but now this is something called type casting that I can make it although it was float I put it in a bracket that means whatever is coming here I am converting that to float <sil=0.910> .PERIOD Sum will be the array sum of all integers will be any integer but when I divide by that although I did not declare sum to be floating point number just by this sort of type casting I can make it I will first do this and convert it make it a floating point number and then how do I return it <sil=0.851> ?QUESTIONMARK Yes you might have guessed correctly that I do not need to return it because whatever I have done here when I passed an array whatever was done that is being done here and this sum what I am returning I am returning this to the average so I will get this value <sil=0.919> .PERIOD So <sil=0.363> ,COMMA this should be clear so clarified now next thing that I will be discussing a little bit is on dynamic memory allocation I will take little time to explain that that is a very important concept and after that we will move to some discussion <sil=0.971> .PERIOD So <sil=0.380> ,COMMA let us discuss some basic discussions on file <sil=0.916> .PERIOD We were discussing about structures and in particular we have discussed about the way the structure is formed <sil=0.971> .PERIOD And in that context we have seen that a structure can contain within itself some members can be themselves a structure <sil=0.905> .PERIOD For example <sil=0.409> ,COMMA this one member which can itself be a structure consisting of other members <sil=0.576> ,COMMA this possible <sil=0.926> .PERIOD So this is a structure <sil=0.600> ,COMMA struct S <sil=0.428> ,COMMA S in which there is another struct <sil=0.391> ,COMMA say P which is a member of this <sil=0.497> ,COMMA it is possible <sil=0.969> .PERIOD So some member can be an array <sil=0.358> ,COMMA this can be say name 10 <sil=0.565> ,COMMA that means it is a character array of name 10 <sil=0.995> .PERIOD Similarly it could be some member can be int max 20 like that it can happen <sil=0.955> .PERIOD Now so we have seen that we can have arrays within structure also in the last lecture we have talked about arrays of structure <sil=0.980> .PERIOD So there is a scope of confusion between these two that is why I want to make it clearer that there can be an array within a structure as a member <sil=0.925> .PERIOD So on the other thing is we can have array of structure <sil=0.901> .PERIOD So in this case we have gotten array every element of that array is a structure of a particular type <sil=0.901> .PERIOD We know that an array can hold data elements of the same type <sil=0.923> .PERIOD So if I have one particular structure defined like say student and it can be an array of students <sil=0.990> .PERIOD So there will be each of them is of the type student and we have also seen so these two must be differentiated very clearly <sil=0.958> .PERIOD So as you can see that here a structure member can be an array we saw it in the last class <sil=0.363> ,COMMA last lecture that say for example a structure student has gotten array character array name 30 <sil=0.997> .PERIOD Now this is a part of an array <sil=0.941> .PERIOD Now that we know arrays within structure we have also seen arrays of structure where we can have a number of elements of that particular structure here <sil=0.991> .PERIOD So here we have seen that we have got an array class <sil=0.409> ,COMMA the array is class which can hold up to 50 elements and each element of this class is a structure of type student <sil=0.969> .PERIOD So individual members when I come to say class I then I am actually accessing a structure <sil=0.308> ,COMMA a particular structure in that array <sil=0.921> .PERIOD Now that structure has got number of fields therefore if I have class I dot name then I will get a particular name if that be the field or I can say class 2 dot role number <sil=0.977> .PERIOD So if I have class I dot name then I will get a particular name if that be the field or I can say class 2 dot role number <sil=0.970> .PERIOD So here I think this distinction must be very clear that this is an array of structures and we can handle them just as here the index is pointing to the particular element and then by the dot operator we are going inside that element and looking at that array <sil=0.994> .PERIOD Whereas in the case of an array within a structure we can we look at that in a different way that is if there be an then I come to the structure student and suppose there is a variable of name say a 1 <sil=0.922> .PERIOD So I can say a 1 dot say name and I can take a particular character of that <sil=0.923> .PERIOD So look at the difference of this this is 1 the other one was class I dot may be name j <sil=0.928> .PERIOD So here I am accessing the particular element from that structure and here I am coming to the structure and going to that array element within that structure <sil=0.984> .PERIOD So this is a usual point of confusion among many students that is why I was repeating this <sil=0.986> .PERIOD Next we will start looking at an important aspect an important style of writing programs which is type death that facilitates our programming with structure <sil=0.972> .PERIOD As the name type death implies we are defining some type we know that int is a type float is a type data type care is a type etcetera <sil=0.943> .PERIOD Now I can also define my own type that I will be using in my program using this type death statement type death command <sil=0.960> .PERIOD So we may define a structure a structure data type using a type death command like this let us see the syntax the syntax is I see type death struct member variable 1 member variable 2 member variable n and then some tag <sil=0.975> .PERIOD Tag is the name of the new data type let me illustrate this differentiating this with the earlier thing say earlier we had written something like this struct <sil=0.902> .PERIOD Student then care name 10 in role number like this <sil=0.931> .PERIOD So I was defining a structure in this way and I was later on referring to this structure as struct student say student 1 student 2 in this way <sil=0.907> .PERIOD Now what I am trying to do here is I am trying to define a type suppose I do not write this what I am doing instead I am saying type death struct same thing <sil=0.914> .PERIOD So I am trying to define a structure name 10 in role number and name this type as student if I do this then next time when I write this student declare this student 1 and student 2 <sil=0.932> .PERIOD So I can do it in a different way I can do it much simply as I am writing now in the red if I just simply write look inside this red box if I write student 1 comma student 2 that is sufficient <sil=0.977> .PERIOD So I just as compared this with the way we had declared int x float y <sil=0.938> .PERIOD So here int and float was some types now here student 1 student 2 are 2 variables of type student <sil=0.906> .PERIOD Now this type is not a default type it is not predefined in C therefore but I can use it because I have already using this type death statement has defined this structure as student <sil=0.913> .PERIOD But please differentiate between this and the normal definition of struct student as we do normally as say struct something and then I say student <sil=0.966> .PERIOD Now this is here is it clear I say struct we have seen this and I write the members here and then define that structure as the type student <sil=0.937> .PERIOD Now this is a definition once for all a particular structure as student now this if I have to use it then I have to say struct student followed by a 1 a 2 student 1 student to whatever <sil=0.995> .PERIOD But in this case if I do this type death I am saved from this problem <sil=0.958> .PERIOD So let us have a little look at how will go about it <sil=0.915> .PERIOD So that is the tag so here type death a particular structure just as here could be care name or int role just like that note that they semicolon at the end of all these declarations <sil=0.995> .PERIOD And ultimately I name this tag see me save for example here as student <sil=0.999> .PERIOD So tag is the name of the new data type so given that here is an example again the example of complex number <sil=0.988> .PERIOD So we are defining a type called complex ignore this underscore here <sil=0.905> .PERIOD So type death something having real part and imaginary part is known as the data type complex and then I am saying complex ABC just like in ABC flow ABC I can write complex ABC because complex has already been defined here <sil=0.942> .PERIOD Because complex has already been defined so I think this is clear right next we move to how do we initialize a structure we saw that we can initialize an add a similarly we can initialize a structure as well <sil=0.903> .PERIOD Say structure variables may be initialized following similar rules like an array the values are provided in the within the second braces separated by commas for example here complex a complex a is a complex variable 1 <sil=0.975> .PERIOD 0 comma 2 <sil=0.908> .PERIOD 0 what does it imply it implies that it is a is a structure <sil=0.923> .PERIOD Having two fields and one field is 1 <sil=0.934> .PERIOD 0 another is 2 <sil=0.966> .PERIOD 0 <sil=0.915> .PERIOD Similarly B is another field which is initialize to minus 3 <sil=0.994> .PERIOD 0 and 4 <sil=0.952> .PERIOD 0 <sil=0.962> .PERIOD Just as we did it in the case of arrays we do it for individual structural variables but we have to put all the values initial values for all the fields of that <sil=0.998> .PERIOD So this is what happened by this initialization <sil=0.905> .PERIOD The other thing that last thing that we will be talking about is parameter passing in a function how do we pass a structure as a parameter to a function <sil=0.960> .PERIOD We have seen how arrays can be passed similarly how can we pass structures to a function like any other variable just like any other variable we can pass it like for example here you can see that there is a swap <sil=0.953> .PERIOD Between complex variable a and complex variable b now a and e are both structures <sil=0.929> .PERIOD So I am just saying just as we used to write say void swap into int b just like that <sil=0.951> .PERIOD Here I write complex a complex b it is also call by value <sil=0.926> .PERIOD Now so here is again the typical assignment and the way we carry it out <sil=0.916> .PERIOD So here is an example program using type depth what is being done here is I am defining a type complex type depth struct there are two parts real and imaginary and this data type is known as complex <sil=0.994> .PERIOD Now I am writing a function swap them so I am taking another I have taken another variable which is of type complex temp is of type complex <sil=0.905> .PERIOD So when I do assign a to temp then this temp variable which is of type complex will get will copy the variables say here it was 3 <sil=0.939> .PERIOD 0 and minus 2 <sil=0.972> .PERIOD So this will come here it will become 3 <sil=0.910> .PERIOD 0 and this will become minus 2 <sil=0.901> .PERIOD So that is temp now I copy a to b <sil=0.901> .PERIOD So here sorry b to a I am sorry not this one there was some b and the values of b are copied to a not here <sil=0.901> .PERIOD These are copied here and here so might be this is changed to 5 this is changed to 2 <sil=0.928> .PERIOD 0 minus 2 <sil=0.940> .PERIOD 5 and then I copy again b to temp a temp to b <sil=0.987> .PERIOD So this is again copied back so member by member the copy is done <sil=0.977> .PERIOD So here we illustrate what we mean by type depth and a function that is using it <sil=0.960> .PERIOD So now suppose how can we print a structure <sil=0.941> .PERIOD Print I am now printing the comp say here is a function the main function is calling print x and print y <sil=0.951> .PERIOD So say for example my main function is initializing now we understand all these things x to 4 x real part to 4 imaginary part to 5 <sil=0.951> .PERIOD And y is real part to 10 and imaginary part to 15 <sil=0.964> .PERIOD So now I am calling print x so it is calling print x so x is being copied call by value to another local variable a which is local to this function print <sil=0.991> .PERIOD So a is holding the complex variable x and print f a dot real a dot imaginary so field by field I print them then I come back I print y <sil=0.922> .PERIOD Y is copied to a and the same thing happens then I call swap now swap was a function that we just now saw where we take temp and we copy it to temp and then I copy b to a and then temp to a in that way we carry out the swapping <sil=0.952> .PERIOD So it is purely call by value and then I print x and print y after I swap what will happen in this case if I go back to this case where I am passing among this a and b the x and y are being swapped inside that function <sil=0.916> .PERIOD But will that be swapped in actuality you check that yourself how do we return a structure from a function suppose I have done something but in the earlier case x and y were being swapped inside the function but when I come back to the main my x y remains the same <sil=0.947> .PERIOD So if we if we want to return the function for example here I carry out a real plus b real I make it temp say here is an example of adding to complex numbers here complex a and complex b are two variables which have been passed on as parameter here and I have got a temp as an <sil=0.901> .PERIOD Local function local variable so temp dot real is copying a dot real plus b dot real so what is happening here I have got structure a with a real part and an imaginary part so 3 <sil=0.979> .PERIOD 0 4 <sil=0.965> .PERIOD 2 another is b with a real part <sil=0.930> .PERIOD Which is 2 <sil=0.913> .PERIOD 5 and maybe 3 <sil=0.946> .PERIOD 6 now when I am adding two complex numbers you remember we discussed it in last class also I first add these two so a real is added to b real so I am getting in temp this is temp where I am getting 5 <sil=0.923> .PERIOD 5 and then imaginary I am getting 7 <sil=0.957> .PERIOD 8 and now I return temp now in the main function if I had written something like say x and y were two complex variables and what I did I said add x y assign to some other complex variable z in that case that temp this temp will be assigned to this complex variable z that is how we can return a structure from a function <sil=0.977> .PERIOD So structure facilitates in many ways in this so direct arithmetic operations are not possible with structure variables that means I cannot just add a and b when both of them are structures I have to do the arithmetic operations over its members <sil=0.904> .PERIOD So with that we conclude our discussion on structures and structure is we will be given assignments on structures and this will enable you to write different types of handle different types of data types together and using the type there you can design your own complex data type which you can utilize further <sil=0.905> .PERIOD So please practice using structures it is not at all difficult only a little practice and a little understanding is required <sil=0.951> .PERIOD In the last lecture <sil=0.631> ,COMMA we had concluded with a term called algorithm <sil=0.915> .PERIOD And we said that an algorithm means a sequence of steps that are followed to solve a problem <sil=0.340> ,COMMA to be followed to solve a problem <sil=0.996> .PERIOD Now <sil=0.370> ,COMMA the question is that how do we express an algorithm <sil=0.878> ?QUESTIONMARK How do we express the sequence of steps <sil=0.898> ?QUESTIONMARK How do we express that <sil=0.940> ?QUESTIONMARK There can be different ways of expressing it <sil=0.941> .PERIOD So <sil=0.494> ,COMMA usually ultimately we will have to write a program for this <sil=0.940> .PERIOD Ultimately we will have to write a program for this <sil=0.983> .PERIOD So <sil=0.591> ,COMMA obviously program is the final form of expression of the sequence of steps that we want to reach to <sil=0.916> .PERIOD But even before that <sil=0.452> ,COMMA I mean a program is for communicating the sequence of steps to a computer <sil=0.979> .PERIOD But even for our human exchange <sil=0.440> ,COMMA we may like to express what are the steps to be followed <sil=0.973> .PERIOD And the two distinct ways by which an algorithm can be expressed <sil=0.491> ,COMMA one is flow chart <sil=0.440> ,COMMA another is pseudo code <sil=0.904> .PERIOD Now <sil=0.527> ,COMMA flow chart as the name implies is a diagrammatic representation of the sequence of steps <sil=0.951> .PERIOD It is a diagram <sil=0.930> .PERIOD And pseudo code on the other hand is an English like English or whatever in human language <sil=0.387> ,COMMA English like not exactly English <sil=0.411> ,COMMA we can take a lot of liberty <sil=0.501> ,COMMA we will see how to when I express the sequence of steps <sil=0.579> ,COMMA English like language to express the sequence of steps <sil=0.961> .PERIOD Now <sil=0.559> ,COMMA we will show both the flow chart and pseudo code with respect to some of the problems that we had discussed earlier <sil=0.991> .PERIOD So <sil=0.454> ,COMMA let us start with this <sil=0.612> ,COMMA finding the average of three numbers <sil=0.903> .PERIOD This is the simplest possible way <sil=0.479> ,COMMA simplest possible problem that we can solve <sil=0.936> .PERIOD So <sil=0.355> ,COMMA we will start with the first <sil=0.394> ,COMMA we will start with the start node <sil=0.422> ,COMMA we are trying to draw a flow chart <sil=0.911> .PERIOD So <sil=0.525> ,COMMA once we draw this start <sil=0.360> ,COMMA then next will be some assign 0 <sil=0.983> .PERIOD Now <sil=0.315> ,COMMA what all of us know that in order to find the average of any number <sil=0.639> ,COMMA set of numbers <sil=0.495> ,COMMA we have to first add those numbers <sil=0.917> .PERIOD So <sil=0.402> ,COMMA the addition result is stated as sum <sil=0.945> .PERIOD So <sil=0.602> ,COMMA here when there is no number that has been <sil=0.575> ,COMMA we have already taken into account <sil=0.556> ,COMMA we initialize the sum to be 0 <sil=0.986> .PERIOD So <sil=0.496> ,COMMA right now sum is 0 <sil=0.936> .PERIOD Next <sil=0.611> ,COMMA what we do is <sil=0.514> ,COMMA we read the first number <sil=0.502> ,COMMA we read the first number <sil=0.507> ,COMMA read number 1 <sil=0.951> .PERIOD Now <sil=0.433> ,COMMA what does this read mean <sil=0.896> ?QUESTIONMARK Read means who is reading <sil=0.898> ?QUESTIONMARK Whom do you want to read <sil=0.910> ?QUESTIONMARK Whoever <sil=0.458> ,COMMA whoever will be finding the average <sil=0.582> ,COMMA he or she will have to read the number <sil=0.921> .PERIOD If I ask a human being to do that <sil=0.581> ,COMMA the human being will have to know the number <sil=0.954> .PERIOD So <sil=0.504> ,COMMA if I show that number on a piece of paper writing 5 <sil=0.341> ,COMMA he will read that number 5 and we will say <sil=0.435> ,COMMA okay <sil=0.962> ,COMMA so 5 is the first number <sil=0.949> .PERIOD Then I show the second number <sil=0.375> ,COMMA 7 <sil=0.570> ,COMMA okay <sil=0.985> ,COMMA 7 is the second number <sil=0.954> .PERIOD In that way <sil=0.464> ,COMMA that is the significance <sil=0.582> ,COMMA that is the meaning of this read <sil=0.964> .PERIOD Now <sil=0.646> ,COMMA in our case <sil=0.429> ,COMMA ultimately <sil=0.589> ,COMMA ultimately <sil=0.641> ,COMMA the computer will read it <sil=0.913> .PERIOD And earlier <sil=0.335> ,COMMA we had talked about the input and often we had discussed about this <sil=0.560> ,COMMA this is also known as an input mechanism <sil=0.961> .PERIOD So <sil=0.461> ,COMMA it is reading the number <sil=0.968> .PERIOD Now <sil=0.328> ,COMMA here <sil=0.316> ,COMMA I would like to state a few things <sil=0.483> ,COMMA that is <sil=0.632> ,COMMA say <sil=0.525> ,COMMA flow chart has got some basic fundamental elements <sil=0.948> .PERIOD This one you have already seen <sil=0.536> ,COMMA that is a start symbol <sil=0.554> ,COMMA okay <sil=0.994> .PERIOD Now <sil=0.529> ,COMMA this figure is known as oblong <sil=0.978> .PERIOD This figure is rectangle <sil=0.910> .PERIOD Now <sil=0.581> ,COMMA this oblong is actually used for input and output <sil=0.322> ,COMMA I mean <sil=0.519> ,COMMA specification <sil=0.971> .PERIOD Wherever I need to do some input or the system provides me some output <sil=0.524> ,COMMA let me explain this <sil=0.962> .PERIOD So <sil=0.544> ,COMMA input I have already explained that when I am writing some number for you to read or for anybody who will do the computation to read <sil=0.500> ,COMMA that is the input <sil=0.921> .PERIOD And you know all of you that we have got some input devices <sil=0.332> ,COMMA the most standard input devices the keyboard using which we can put in the data <sil=0.996> .PERIOD The output is after the computation is done <sil=0.581> ,COMMA the system will or system will give me the output <sil=0.906> .PERIOD Or if it be a human being who is doing the computation <sil=0.354> ,COMMA he or she will be telling me the output <sil=0.446> ,COMMA that this is the result <sil=0.909> .PERIOD So <sil=0.540> ,COMMA that is known as output <sil=0.933> .PERIOD So <sil=0.641> ,COMMA while drawing the flow chart <sil=0.501> ,COMMA sometimes we will write read for this input and maybe print or write <sil=0.337> ,COMMA print or write for output <sil=0.427> ,COMMA okay <sil=0.901> .PERIOD Now <sil=0.377> ,COMMA this diagram is essentially the computation box <sil=0.995> .PERIOD So <sil=0.374> ,COMMA whenever we do some computation that we show in this sort of a box <sil=0.921> .PERIOD For example <sil=0.432> ,COMMA we can say x is p multiplied by q <sil=0.466> ,COMMA something like this or the other very important block is the decision blocks block <sil=0.385> ,COMMA which looks like this a diamond <sil=0.936> .PERIOD Now <sil=0.375> ,COMMA here what we do <sil=0.622> ,COMMA we just take decisions depending on some conditions <sil=0.352> ,COMMA depending on some conditions <sil=0.615> ,COMMA I will either take the left path or the right path <sil=0.318> ,COMMA okay <sil=0.973> .PERIOD So <sil=0.582> ,COMMA for example <sil=0.380> ,COMMA I can say whether the age of a boy is greater than 14 <sil=0.978> .PERIOD If the age of the boy is not greater than 14 <sil=0.397> ,COMMA he is not allowed to go to a film <sil=0.366> ,COMMA okay <sil=0.989> .PERIOD So <sil=0.604> ,COMMA if it be no <sil=0.344> ,COMMA then he cannot go to a to see a particular film <sil=0.984> .PERIOD And if it be 14 or greater <sil=0.519> ,COMMA that means it is greater than 14 <sil=0.633> ,COMMA if it is yes <sil=0.339> ,COMMA then he can go to a film <sil=0.951> .PERIOD So <sil=0.634> ,COMMA we come to this particular point and make a decision looking at this sort of scenario <sil=0.913> .PERIOD So <sil=0.352> ,COMMA this is known as the decision box <sil=0.904> .PERIOD Now <sil=0.338> ,COMMA these are the basic four elements of any flow chart <sil=0.489> ,COMMA all right <sil=0.926> .PERIOD So <sil=0.376> ,COMMA now we will again come back to our flow chart <sil=0.920> .PERIOD So <sil=0.533> ,COMMA you can see here that some is 0 and the number that has been read is the first number <sil=0.560> ,COMMA right <sil=0.923> .PERIOD Now <sil=0.332> ,COMMA suppose that number that was read <sil=0.481> ,COMMA the number that was read is 5 <sil=0.982> .PERIOD Suppose <sil=0.330> ,COMMA I the number that I read is 5 <sil=0.990> .PERIOD So <sil=0.306> ,COMMA some number <sil=0.993> .PERIOD So <sil=0.637> ,COMMA next what I do is I add that particular number with the sum <sil=0.942> .PERIOD So <sil=0.541> ,COMMA now it the sum was initially 0 <sil=0.989> .PERIOD So <sil=0.510> ,COMMA I add 5 with sum <sil=0.918> .PERIOD So <sil=0.310> ,COMMA it becomes the total sum becomes 5 <sil=0.344> ,COMMA right <sil=0.984> .PERIOD Sum becomes 5 <sil=0.961> .PERIOD So <sil=0.309> ,COMMA next what should I do <sil=0.857> ?QUESTIONMARK After I computed the sum <sil=0.314> ,COMMA then I read the second number because I have to read three numbers and find the average <sil=0.902> .PERIOD I read the second number and then I add the second number with the sum <sil=0.943> .PERIOD The first number was 5 <sil=0.996> .PERIOD So <sil=0.636> ,COMMA the value of sum is now 5 <sil=0.620> ,COMMA value of sum is now 5 <sil=0.915> .PERIOD I have read the second number <sil=0.930> .PERIOD Suppose that was 8 <sil=0.304> ,COMMA then the sum becomes 8 plus 5 that is 13 <sil=0.919> .PERIOD Now <sil=0.632> ,COMMA I come and read the third number <sil=0.971> .PERIOD Suppose it is 3 <sil=0.354> ,COMMA all right <sil=0.914> .PERIOD So <sil=0.434> ,COMMA I read the third number and then I compute the sum <sil=0.956> .PERIOD So <sil=0.362> ,COMMA I have computed 3 the sum to be 13 plus 3 16 <sil=0.902> .PERIOD Next <sil=0.629> ,COMMA what do I do <sil=0.939> ?QUESTIONMARK I have to compute the average <sil=0.958> .PERIOD So <sil=0.505> ,COMMA what I do <sil=0.999> ?QUESTIONMARK I find the AVG is by AVG <sil=0.603> ,COMMA I am depicting the average <sil=1.000> .PERIOD Average is sum divided by 3 <sil=0.320> ,COMMA okay <sil=0.915> .PERIOD So <sil=0.364> ,COMMA it was what was it <sil=0.937> ?QUESTIONMARK 13 plus 3 <sil=0.598> ,COMMA 16 divided by 3 <sil=0.939> .PERIOD So <sil=0.512> ,COMMA it will be 5 points something <sil=0.945> .PERIOD So <sil=0.457> ,COMMA that result whatever I get that I will be printing <sil=0.967> .PERIOD So <sil=0.529> ,COMMA that is a flow chart <sil=0.998> .PERIOD These are the steps that I have to do <sil=0.338> ,COMMA okay <sil=0.977> .PERIOD Now <sil=0.536> ,COMMA the same thing <sil=0.375> ,COMMA the same thing I can express in the form of a pseudo code or English like language <sil=0.987> .PERIOD Let us see how it looks like <sil=0.950> .PERIOD Here <sil=0.591> ,COMMA you just see what I have done <sil=0.932> .PERIOD I have initialized what I wrote in the first step is this one is equivalent to this <sil=0.532> ,COMMA all right <sil=0.989> .PERIOD Initialize the sum to 0 and then I read the first number <sil=0.965> .PERIOD Sum is added sum equals sum plus number 1 exactly what I did here <sil=0.915> .PERIOD Read the second number then I sum equals sum plus number 2 and then I read the third number and then sum is sum plus number 3 <sil=0.911> .PERIOD So <sil=0.571> ,COMMA these are the steps <sil=0.998> .PERIOD You see exactly if you just do not look at the left part of the whole thing if you just look at this right part you can also understand what are the steps through which I must go <sil=0.644> ,COMMA okay <sil=0.929> .PERIOD And so <sil=0.405> ,COMMA ultimately I compute the average which is I just write <sil=0.956> .PERIOD So <sil=0.636> ,COMMA it is English like compute have AVG equal <sil=0.910> .PERIOD So <sil=0.487> ,COMMA it is not exactly English it is English like anybody who knows English will be able to understand this <sil=0.992> .PERIOD So <sil=0.577> ,COMMA this is known as the pseudo code <sil=0.965> .PERIOD So <sil=0.510> ,COMMA this is for the very simple problem that we are doing <sil=0.936> .PERIOD Now <sil=0.413> ,COMMA suppose let us think of for a second that suppose instead of three numbers I asked you to find the average of 10 numbers <sil=0.916> .PERIOD How the flow chart look like <sil=0.902> ?QUESTIONMARK Obviously <sil=0.349> ,COMMA this same thing that I have done here read number 3 <sil=0.537> ,COMMA read number 4 <sil=0.503> ,COMMA read number 5 <sil=0.628> ,COMMA read number 6 in that way it will go on and on and on <sil=0.443> ,COMMA okay <sil=0.977> .PERIOD Had it been 100 numbers then it would be even larger <sil=0.489> ,COMMA okay <sil=0.992> .PERIOD Now <sil=0.470> ,COMMA can we do something better in order to I do not have so much paper to waste <sil=0.973> .PERIOD So <sil=0.388> ,COMMA can I write it <sil=0.531> ,COMMA can I express it in a much better way <sil=0.877> ?QUESTIONMARK So <sil=0.439> ,COMMA let us go to the next problem where we want to find the average of N numbers <sil=0.328> ,COMMA average of N numbers I want to find out <sil=0.953> .PERIOD So <sil=0.328> ,COMMA the first thing will be again start that is from where I am starting next is read the value of N <sil=0.958> .PERIOD So <sil=0.424> ,COMMA what is this value of N <sil=0.909> ?QUESTIONMARK Now <sil=0.606> ,COMMA if I say this value of N when I read what is this N <sil=0.864> ?QUESTIONMARK This N is telling me how many numbers I will be considering for finding the average is it 100 <sil=0.327> ,COMMA is it 1000 <sil=0.536> ,COMMA is it 10 <sil=0.303> ,COMMA whatever <sil=0.955> .PERIOD So <sil=0.312> ,COMMA I am that is N <sil=0.990> .PERIOD So <sil=0.566> ,COMMA I am reading the value of N <sil=0.361> ,COMMA okay <sil=0.913> .PERIOD Now <sil=0.596> ,COMMA I am initializing the sum to 0 <sil=0.930> .PERIOD Again just as before I initialize the sum to 0 and then I read <sil=0.557> ,COMMA now you see here I have written read number <sil=0.926> .PERIOD I have not written read number 1 <sil=0.927> .PERIOD Earlier since I had to only do number 1 <sil=0.358> ,COMMA 2 and 3 here there I wrote down number 1 <sil=0.612> ,COMMA number 2 <sil=0.398> ,COMMA number 3 here I am just writing read number <sil=0.401> ,COMMA okay <sil=0.990> .PERIOD Because I do not know how many numbers I will be reading <sil=0.985> .PERIOD The reason will be very clear soon <sil=0.950> .PERIOD So <sil=0.351> ,COMMA next what do I do <sil=0.946> ?QUESTIONMARK I read the number this sum is sum plus number <sil=0.977> .PERIOD So <sil=0.556> ,COMMA I take the sum was 0 <sil=0.494> ,COMMA I take the sum and add that number which number the number that I just now read <sil=0.958> .PERIOD Say I have just now read number 5 <sil=0.554> ,COMMA okay <sil=0.985> .PERIOD I have read just now <sil=0.572> ,COMMA I am sorry <sil=0.577> ,COMMA I just read number 5 <sil=0.969> .PERIOD So <sil=0.366> ,COMMA I read number 5 and I have added that number with sum <sil=0.939> .PERIOD So <sil=0.626> ,COMMA sum is now 5 <sil=0.611> ,COMMA okay <sil=0.972> .PERIOD Next I decrement this is a new thing that is coming up here <sil=0.922> .PERIOD Since I know here at this point the user or the whoever supplied the data told me that you have to look for 100 numbers say <sil=0.642> ,COMMA N is 100 <sil=0.636> ,COMMA I have learnt that <sil=0.959> .PERIOD So <sil=0.493> ,COMMA now here I have read one number and I have taken care of that number because I have added that with sum and so therefore <sil=0.452> ,COMMA I now decrement that value of N <sil=0.935> .PERIOD What does this signify <sil=0.904> ?QUESTIONMARK This signifies that I now since initially it was 100 <sil=0.369> ,COMMA I have to read 99 more numbers 99 or yet to go <sil=0.346> ,COMMA right <sil=0.967> .PERIOD Now <sil=0.581> ,COMMA I have to check have I read all the numbers <sil=0.972> ?QUESTIONMARK What is the value of N <sil=0.930> ?QUESTIONMARK The value of N is 99 that means <sil=0.582> ,COMMA N is not 0 that means <sil=0.483> ,COMMA I have not been able to read all the numbers <sil=0.975> .PERIOD If I have since in a decision box as I have told you just a couple of minutes earlier that I can have two options <sil=0.429> ,COMMA I can either have yes or no answer <sil=0.988> .PERIOD If N is equal to 0 <sil=0.436> ,COMMA what does that signify <sil=0.908> ?QUESTIONMARK If N is equal to 0 that signifies that I have read all the numbers <sil=0.323> ,COMMA I have already read all the numbers <sil=0.987> .PERIOD Then I compute then I can compute the average as sum whatever sum I got divided by N <sil=0.982> .PERIOD Otherwise <sil=0.551> ,COMMA if N is not equal to 0 then let us look at here <sil=0.452> ,COMMA if N is not equal to 0 <sil=0.621> ,COMMA no then I will go back here again look at this part <sil=0.913> .PERIOD I will go back here again and read number <sil=0.980> .PERIOD I will read the second number read that and add it to sum I will go over here decrement <sil=0.917> .PERIOD So <sil=0.374> ,COMMA I have read two numbers <sil=0.974> .PERIOD So <sil=0.337> ,COMMA now how many are yet to go <sil=0.913> ?QUESTIONMARK 98 <sil=0.374> ,COMMA N is 0 <sil=0.353> ,COMMA no <sil=0.320> ,COMMA N is not 0 <sil=0.313> ,COMMA N is not 0 <sil=0.586> .PERIOD So <sil=0.539> ,COMMA I go up again I read another number add that particular number to the sum <sil=0.316> ,COMMA decrement N how many to go <sil=0.890> ?QUESTIONMARK 97 is it 0 <sil=0.894> ?QUESTIONMARK No <sil=0.568> ,COMMA not 80 <sil=0.996> .PERIOD So <sil=0.582> ,COMMA I go on in this way <sil=0.925> .PERIOD I will go on in this way ultimately after I have read the hundredth number this N will become 0 <sil=0.946> .PERIOD So <sil=0.449> ,COMMA at that point I will come to this average and compute the average as sum divided by N and then I will print the average and stop <sil=0.922> .PERIOD So <sil=0.629> ,COMMA see just by this thing I am sorry just by this thing which is nothing but this is called a loop <sil=0.942> .PERIOD This is called a loop and using this looping repetition I could reduce the length of the flow chart <sil=0.471> ,COMMA the repetition of the flow chart in a very elegant way <sil=0.950> .PERIOD I hope it is clear <sil=0.950> .PERIOD So <sil=0.636> ,COMMA the same thing can be also reflected in the flow chart <sil=0.966> .PERIOD Now <sil=0.402> ,COMMA compared to the with the earlier flow chart <sil=0.602> ,COMMA earlier statement here when I read it only for three numbers I did initialize sum to 0 read number 1 <sil=0.442> ,COMMA read number 2 and at every point I was adding it to sum <sil=0.904> .PERIOD Here what I do is I write it in a little bit flexible way because when I write in a pseudo code I am not very constrained <sil=0.941> .PERIOD I can take the flexibility as long as I can express myself it is good enough <sil=0.910> .PERIOD I just wrote get the value of N earlier probably I wrote read the value of N means the same thing <sil=0.906> .PERIOD So <sil=0.566> ,COMMA get the value of N initialize sum to 0 and till now here I am talking of this looping till N is as long as till means as long as N is greater than 0 it will be better to say as long as N is greater than 0 read number at the number red the number that you have red to sum <sil=0.928> .PERIOD You read number at the number red to sum and one thing I missed out here and you decrement N <sil=0.907> .PERIOD You decrement N here you have to make N equal to N minus 1 <sil=0.914> .PERIOD In your note you please take it down here it will be N <sil=0.319> ,COMMA N minus 1 and so till N as long as N is greater than 0 I will be going on doing this <sil=0.929> .PERIOD After that I will compute average as average divided by sum average is sum divided by N I am sorry and then I will print the average <sil=0.919> .PERIOD So <sil=0.594> ,COMMA I can express it either in the form of flow or in the form of a pseudo code <sil=0.959> .PERIOD Now <sil=0.331> ,COMMA let us take up I mean it is not very visible here finding the maximum of 3 numbers that was another problem that we had discussed last time <sil=0.952> .PERIOD What I am trying to do is I am trying to find the maximum of 3 numbers <sil=0.963> .PERIOD So <sil=0.571> ,COMMA how can I go about in doing the flow chart <sil=0.903> .PERIOD So <sil=0.632> ,COMMA I start just 3 numbers not a large set of numbers <sil=0.990> .PERIOD I first read the number number 1 <sil=0.963> .PERIOD Now <sil=0.538> ,COMMA tell me one thing when you have first read one number <sil=0.462> ,COMMA what is the maximum number <sil=0.867> ?QUESTIONMARK Obviously since you have read only one number that itself is the maximum only one <sil=0.947> .PERIOD So <sil=0.558> ,COMMA it is a singleton so it is the maximum <sil=0.973> .PERIOD Therefore <sil=0.572> ,COMMA I say that max is nothing <sil=0.311> ,COMMA but the first number the number that I have read max is number 1 <sil=0.974> .PERIOD Now <sil=0.417> ,COMMA I read the second number I read the second number <sil=0.953> .PERIOD Now <sil=0.536> ,COMMA which one is the maximum <sil=0.894> ?QUESTIONMARK If the second number is greater than the first number then the second number will be the max <sil=0.918> .PERIOD Now <sil=0.540> ,COMMA when I read the first number when I read the first number here I said that to be the max <sil=0.948> .PERIOD So <sil=0.541> ,COMMA now after reading the second number I can compare the second number with respect to the max <sil=0.980> .PERIOD If the second number is greater than the max <sil=0.410> ,COMMA if the second number is greater than the max then what will happen <sil=0.855> ?QUESTIONMARK Then number 2 will be the max <sil=0.923> .PERIOD If it is yes then number 2 becomes the max and if no that means what <sil=0.969> ?QUESTIONMARK Number 2 is not greater than the max then I skip this part <sil=0.956> .PERIOD I skip this part and go out by this way skipping this part that means at this point which the max obviously at this point I had number 1 and number 1 is still the max <sil=0.900> .PERIOD I hope it is clear <sil=0.981> .PERIOD Next I read the third number <sil=0.965> .PERIOD Again <sil=0.623> ,COMMA I do the same thing after reading the third number <sil=0.966> .PERIOD Is the third number greater than <sil=0.940> ?QUESTIONMARK What <sil=0.904> ?QUESTIONMARK Number 2 should I compare <sil=0.967> ?QUESTIONMARK No <sil=0.517> .PERIOD I should compare with the max because till now between number 1 and number 2 whatever is the maximum I have already remembered that in max <sil=0.929> .PERIOD So <sil=0.318> ,COMMA I read the number 3 and then again compare is number 3 greater than max <sil=0.943> .PERIOD I can have yes or no <sil=0.913> .PERIOD So <sil=0.391> ,COMMA if it be yes then number 3 becomes the max because number 3 is greater than the maximum number till now <sil=0.986> .PERIOD And then I will proceed and if not if number 3 is not greater than max then I then obviously the whatever was the max till now that is the number 1 that will remain the max <sil=0.934> .PERIOD Think of number 1 to be 5 number 2 to be 3 and number 3 to be 1 <sil=0.928> .PERIOD What will happen <sil=0.976> ?QUESTIONMARK 3 <sil=0.977> .PERIOD So <sil=0.529> ,COMMA max is 3 sorry this was 5 <sil=0.937> .PERIOD So <sil=0.358> ,COMMA I read 5 <sil=0.936> .PERIOD Next I read 3 is 5 greater than 3 <sil=0.969> ?QUESTIONMARK No <sil=0.430> .PERIOD So <sil=0.470> ,COMMA I kept 5 as the maximum alright <sil=0.932> .PERIOD I read number 3 that was 1 <sil=0.913> .PERIOD I compared is it greater than the maximum which was 5 <sil=0.932> ?QUESTIONMARK No <sil=0.548> .PERIOD Then I print that 5 which is the maximum <sil=0.977> .PERIOD But if suppose number 3 was 7 <sil=0.912> .PERIOD So <sil=0.589> ,COMMA it is greater than 5 <sil=0.970> .PERIOD So <sil=0.538> ,COMMA then I can go here and update this max to be number 3 or the 7 <sil=0.928> .PERIOD And then I come to the print max part <sil=0.932> .PERIOD So <sil=0.483> ,COMMA this is the flow chart of finding the maximum of 3 numbers <sil=0.985> .PERIOD And consequently you can see the pseudo code of this start read first number <sil=0.979> .PERIOD Then I assign max to be the first number <sil=0.961> .PERIOD Then I read the second number assign <sil=0.993> .PERIOD Now <sil=0.531> ,COMMA if number red is greater than max then I will make the max to be number 2 <sil=0.916> .PERIOD If the number red <sil=0.547> ,COMMA if the if badly written read number it is wrong <sil=0.934> .PERIOD If number 2 is greater than max then make max number 2 <sil=0.986> .PERIOD Then read number 3 <sil=0.930> .PERIOD If number 3 is greater than max then make max number 3 <sil=0.953> .PERIOD Otherwise you are continuing <sil=0.945> .PERIOD So <sil=0.593> ,COMMA if number 2 is not greater than max then I am reading number 3 <sil=0.968> .PERIOD I am not doing this part <sil=0.908> .PERIOD This is another way of explaining the pseudo code <sil=0.975> .PERIOD So <sil=0.343> ,COMMA the same thing <sil=0.510> .PERIOD Now <sil=0.444> ,COMMA we come to another variety of this finding the maximum for n positive integers <sil=0.904> .PERIOD Here I have taken a little liberty <sil=0.934> .PERIOD The finding the maximum of n positive integers <sil=0.949> .PERIOD Earlier I was doing it for all numbers <sil=0.542> ,COMMA but just as a change <sil=0.901> .PERIOD So <sil=0.644> ,COMMA let us see <sil=0.426> .PERIOD I read n again <sil=0.914> .PERIOD n means the number of numbers that I want to read <sil=0.907> .PERIOD Now <sil=0.558> ,COMMA I set max to 0 <sil=0.988> .PERIOD Why do I set max to 0 <sil=0.933> ?QUESTIONMARK Because I am trying to find the max of n positive integers <sil=0.923> .PERIOD So <sil=0.453> ,COMMA any positive integer will be greater than or equal greater than 0 <sil=0.958> .PERIOD So <sil=0.508> ,COMMA I am putting that max to the minimum value possible and then I am reading a number <sil=0.993> .PERIOD I read a number and if that number is greater than max <sil=0.318> ,COMMA if that number is greater than max which is by default 0 <sil=0.927> .PERIOD I have kept it at the bottom most possibility <sil=0.998> .PERIOD In all unless that number is 0 it will always be greater <sil=0.980> .PERIOD So <sil=0.451> ,COMMA I will set that number to be the max <sil=0.992> .PERIOD Next <sil=0.405> ,COMMA again you remember what I did for finding the average <sil=0.924> ?QUESTIONMARK I reduce the value of n <sil=0.937> .PERIOD Suppose I had to do find the max of 10 numbers <sil=0.940> .PERIOD So <sil=0.366> ,COMMA n becomes now 9 and then I check <sil=0.993> .PERIOD I if the max sorry this is mistake here <sil=0.965> .PERIOD This arrow <sil=0.335> ,COMMA this arrow should come from this point <sil=0.957> .PERIOD This arrow should come from this point <sil=0.948> .PERIOD So <sil=0.572> ,COMMA I am just drawing it here <sil=0.971> .PERIOD I am drawing it here <sil=0.955> .PERIOD It should come like this <sil=0.945> .PERIOD So <sil=0.588> ,COMMA I have read a particular number and then if that number <sil=0.577> ,COMMA if that particular number is greater than max <sil=0.485> ,COMMA I am sorry <sil=0.475> ,COMMA I read a number and if that number is greater than max <sil=0.324> ,COMMA number is greater than max <sil=0.422> ,COMMA then I will if it is true <sil=0.601> ,COMMA then I will make that number to be the max <sil=0.992> .PERIOD Max will be that particular number and then I check n <sil=0.303> ,COMMA I have already read n <sil=0.973> .PERIOD So <sil=0.607> ,COMMA is n 0 <sil=0.516> ,COMMA then I have read one number and then I reduce n just as I did in the earlier case and then I check <sil=0.902> .PERIOD n greater than 0 <sil=0.434> ,COMMA if yes <sil=0.531> ,COMMA then I have to go back <sil=0.402> ,COMMA I have to go back and again read a number <sil=0.933> .PERIOD Read num and this will go on as long as n is greater than 0 <sil=0.990> .PERIOD If n is greater than is not greater than 0 <sil=0.456> ,COMMA no <sil=0.442> ,COMMA then I will come and print the max <sil=0.945> .PERIOD So <sil=0.314> ,COMMA there was a little error in that diagram which will be so <sil=0.533> ,COMMA you can see that this line should have come from here <sil=0.401> ,COMMA here is n 0 <sil=0.371> ,COMMA yes <sil=0.367> ,COMMA then print max <sil=0.909> .PERIOD Otherwise <sil=0.467> ,COMMA this should have come from this point <sil=0.624> ,COMMA this should have come from this point <sil=0.591> ,COMMA this is wrong <sil=0.964> .PERIOD So <sil=0.357> ,COMMA in this way <sil=0.396> ,COMMA we can again find the max for n numbers <sil=0.353> ,COMMA it is a flow chat <sil=0.978> .PERIOD So <sil=0.446> ,COMMA again I can have the pseudo code for this <sil=0.945> .PERIOD So <sil=0.430> ,COMMA the pseudo code for this is shown here <sil=0.338> ,COMMA read the value of n <sil=0.553> ,COMMA here initialize max to 0 <sil=0.361> ,COMMA till until n is 0 <sil=0.504> ,COMMA read the number <sil=0.451> ,COMMA if number is greater than max <sil=0.563> ,COMMA max is equal to number <sil=0.568> ,COMMA decrement n <sil=0.644> ,COMMA n is n minus 1 and then it will be not 1 here <sil=0.576> ,COMMA it will be again print the max <sil=0.949> .PERIOD So <sil=0.331> ,COMMA in that way <sil=0.537> ,COMMA you have seen examples of some intermediate representation of the sequence of steps or the algorithms <sil=0.944> .PERIOD We will encounter a number of algorithms in the course of these lectures and the next point <sil=0.434> ,COMMA next step we will see what is to be done in order that this sequence of steps can be converted <sil=0.421> ,COMMA can be transferred to a computer language <sil=0.344> ,COMMA so that the computer can solve the problem <sil=0.468> ,COMMA that we will see in the next part <sil=0.992> .PERIOD We were discussing about structures and in particular we have discussed about the way the structure is formed <sil=0.949> .PERIOD And in that context we have seen that a structure can contain within itself some members can be themselves a structure <sil=0.949> .PERIOD For example <sil=0.484> ,COMMA this one member which can itself be a structure consisting of other members <sil=0.521> ,COMMA this possible <sil=0.949> .PERIOD So this is a structure <sil=0.457> ,COMMA struct S <sil=0.488> ,COMMA S in which there is another struct <sil=0.380> ,COMMA say P which is a member of this <sil=0.346> ,COMMA it is possible <sil=0.991> .PERIOD So some member can be an array <sil=0.426> ,COMMA this can be say name 10 <sil=0.618> ,COMMA that means it is a character array of name 10 <sil=0.976> .PERIOD Similarly it could be some member can be int max 20 like that it can happen <sil=0.979> .PERIOD Now so we have seen that we can have arrays within structure also in the last lecture we have talked about arrays of structure <sil=0.919> .PERIOD So there is a scope of confusion between these two that is why I want to make it clearer that there can be an array within a structure as a member <sil=0.920> .PERIOD So on the other thing is we can have array of structure <sil=0.997> .PERIOD So in this case we have gotten array every element of that array is a structure of a particular type <sil=0.931> .PERIOD We know that an array can hold data elements of the same type <sil=0.970> .PERIOD So if I have one particular structure defined like say student and it can be an array of students <sil=0.906> .PERIOD So there will be each of them is of the type student and we have also seen so these two must be differentiated very clearly <sil=0.999> .PERIOD So as you can see that here a structure member can be an array we saw it in the last class <sil=0.526> ,COMMA last lecture that say for example a structure student has gotten array character array name 30 <sil=0.952> .PERIOD Now this is a part of an array <sil=0.926> .PERIOD Now that we know arrays within structure we have also seen arrays of structure where we can have a number of elements of that particular structure here <sil=0.962> .PERIOD So here we have seen that we have got an array class <sil=0.393> ,COMMA the array is class which can hold up to 50 elements and each element of this class is a structure of type student <sil=0.922> .PERIOD So individual members when I come to say class I then I am actually accessing a structure <sil=0.487> ,COMMA a particular structure in that array <sil=0.974> .PERIOD Now that structure has got number of fields therefore if I have class I dot name then I will get a particular name if that be the field or I can say class 2 dot role number <sil=0.990> .PERIOD So if I have class I dot name then I will get a particular name if that be the field or I can say class 2 dot role number <sil=0.901> .PERIOD So here I think this distinction must be very clear that this is an array of structures and we can handle them just as here the index is pointing to the particular element and then by the dot operator we are going inside that element and looking at that array <sil=0.985> .PERIOD Whereas in the case of an array within a structure we can we look at that in a different way that is if there be an then I come to the structure student and suppose there is a variable of name say a 1 <sil=0.978> .PERIOD So I can say a 1 dot say name and I can take a particular character of that <sil=0.939> .PERIOD So look at the difference of this this is 1 the other one was class I dot may be name j <sil=0.910> .PERIOD So here I am accessing the particular element from that structure and here I am coming to the structure and going to that array element within that structure <sil=0.988> .PERIOD So this is a usual point of confusion among many students that is why I was repeating this <sil=0.923> .PERIOD Next we will start looking at an important aspect an important style of writing programs which is type death that facilitates our programming with structure <sil=0.970> .PERIOD As the name type death implies we are defining some type we know that int is a type float is a type data type care is a type etcetera <sil=0.933> .PERIOD Now I can also define my own type that I will be using in my program using this type death statement type death command <sil=0.995> .PERIOD So we may define a structure a structure data type using a type death command like this let us see the syntax the syntax is I see type death struct member variable 1 member variable 2 member variable n and then some tag <sil=0.981> .PERIOD Tag is the name of the new data type let me illustrate this differentiating this with the earlier thing say earlier we had written something like this struct <sil=0.941> .PERIOD Student then care name 10 in role number like this <sil=0.947> .PERIOD So I was defining a structure in this way and I was later on referring to this structure as struct student say student 1 student 2 in this way <sil=0.952> .PERIOD Now what I am trying to do here is I am trying to define a type suppose I do not write this what I am doing instead I am saying type death struct same thing <sil=0.901> .PERIOD So I am trying to define a structure name 10 in role number and name this type as student if I do this then next time when I write this student declare this student 1 and student 2 <sil=0.918> .PERIOD So I can do it in a different way I can do it much simply as I am writing now in the red if I just simply write look inside this red box if I write student 1 comma student 2 that is sufficient <sil=0.976> .PERIOD So I just as compared this with the way we had declared int x float y <sil=0.962> .PERIOD So here int and float was some types now here student 1 student 2 are 2 variables of type student <sil=0.975> .PERIOD Now this type is not a default type it is not predefined in C therefore but I can use it because I have already using this type death statement has defined this structure as student <sil=0.997> .PERIOD But please differentiate between this and the normal definition of struct student as we do normally as say struct something and then I say student <sil=0.953> .PERIOD Now this is here is it clear I say struct we have seen this and I write the members here and then define that structure as the type student <sil=0.920> .PERIOD Now this is a definition once for all a particular structure as student now this if I have to use it then I have to say struct student followed by a 1 a 2 student 1 student to whatever <sil=0.922> .PERIOD But in this case if I do this type death I am saved from this problem <sil=0.984> .PERIOD So let us have a little look at how will go about it <sil=0.908> .PERIOD So that is the tag so here type death a particular structure just as here could be care name or int role just like that note that they semicolon at the end of all these declarations <sil=0.971> .PERIOD And ultimately I name this tag see me save for example here as student <sil=0.924> .PERIOD So tag is the name of the new data type so given that here is an example again the example of complex number <sil=0.981> .PERIOD So we are defining a type called complex ignore this underscore here <sil=0.974> .PERIOD So type death something having real part and imaginary part is known as the data type complex and then I am saying complex ABC just like in ABC flow ABC I can write complex ABC because complex has already been defined here <sil=0.992> .PERIOD Because complex has already been defined so I think this is clear right next we move to how do we initialize a structure we saw that we can initialize an add a similarly we can initialize a structure as well <sil=0.981> .PERIOD Say structure variables may be initialized following similar rules like an array the values are provided in the within the second braces separated by commas for example here complex a complex a is a complex variable 1 <sil=0.928> .PERIOD 0 comma 2 <sil=0.954> .PERIOD 0 what does it imply it implies that it is a is a structure <sil=0.908> .PERIOD Having two fields and one field is 1 <sil=0.999> .PERIOD 0 another is 2 <sil=0.911> .PERIOD 0 <sil=0.983> .PERIOD Similarly B is another field which is initialize to minus 3 <sil=0.999> .PERIOD 0 and 4 <sil=0.921> .PERIOD 0 <sil=0.933> .PERIOD Just as we did it in the case of arrays we do it for individual structural variables but we have to put all the values initial values for all the fields of that <sil=0.915> .PERIOD So this is what happened by this initialization <sil=0.981> .PERIOD The other thing that last thing that we will be talking about is parameter passing in a function how do we pass a structure as a parameter to a function <sil=0.948> .PERIOD We have seen how arrays can be passed similarly how can we pass structures to a function like any other variable just like any other variable we can pass it like for example here you can see that there is a swap <sil=0.910> .PERIOD Between complex variable a and complex variable b now a and e are both structures <sil=0.928> .PERIOD So I am just saying just as we used to write say void swap into int b just like that <sil=0.966> .PERIOD Here I write complex a complex b it is also call by value <sil=0.941> .PERIOD Now so here is again the typical assignment and the way we carry it out <sil=0.974> .PERIOD So here is an example program using type depth what is being done here is I am defining a type complex type depth struct there are two parts real and imaginary and this data type is known as complex <sil=0.900> .PERIOD Now I am writing a function swap them so I am taking another I have taken another variable which is of type complex temp is of type complex <sil=0.915> .PERIOD So when I do assign a to temp then this temp variable which is of type complex will get will copy the variables say here it was 3 <sil=0.998> .PERIOD 0 and minus 2 <sil=0.986> .PERIOD So this will come here it will become 3 <sil=0.909> .PERIOD 0 and this will become minus 2 <sil=0.986> .PERIOD So that is temp now I copy a to b <sil=0.985> .PERIOD So here sorry b to a I am sorry not this one there was some b and the values of b are copied to a not here <sil=0.974> .PERIOD These are copied here and here so might be this is changed to 5 this is changed to 2 <sil=0.990> .PERIOD 0 minus 2 <sil=0.915> .PERIOD 5 and then I copy again b to temp a temp to b <sil=0.981> .PERIOD So this is again copied back so member by member the copy is done <sil=0.966> .PERIOD So here we illustrate what we mean by type depth and a function that is using it <sil=0.972> .PERIOD So now suppose how can we print a structure <sil=0.998> .PERIOD Print I am now printing the comp say here is a function the main function is calling print x and print y <sil=0.901> .PERIOD So say for example my main function is initializing now we understand all these things x to 4 x real part to 4 imaginary part to 5 <sil=0.913> .PERIOD And y is real part to 10 and imaginary part to 15 <sil=0.947> .PERIOD So now I am calling print x so it is calling print x so x is being copied call by value to another local variable a which is local to this function print <sil=0.957> .PERIOD So a is holding the complex variable x and print f a dot real a dot imaginary so field by field I print them then I come back I print y <sil=0.907> .PERIOD Y is copied to a and the same thing happens then I call swap now swap was a function that we just now saw where we take temp and we copy it to temp and then I copy b to a and then temp to a in that way we carry out the swapping <sil=0.991> .PERIOD So it is purely call by value and then I print x and print y after I swap what will happen in this case if I go back to this case where I am passing among this a and b the x and y are being swapped inside that function <sil=0.972> .PERIOD But will that be swapped in actuality you check that yourself how do we return a structure from a function suppose I have done something but in the earlier case x and y were being swapped inside the function but when I come back to the main my x y remains the same <sil=0.989> .PERIOD So if we if we want to return the function for example here I carry out a real plus b real I make it temp say here is an example of adding to complex numbers here complex a and complex b are two variables which have been passed on as parameter here and I have got a temp as an <sil=0.912> .PERIOD Local function local variable so temp dot real is copying a dot real plus b dot real so what is happening here I have got structure a with a real part and an imaginary part so 3 <sil=0.935> .PERIOD 0 4 <sil=0.972> .PERIOD 2 another is b with a real part <sil=0.901> .PERIOD Which is 2 <sil=0.979> .PERIOD 5 and maybe 3 <sil=0.918> .PERIOD 6 now when I am adding two complex numbers you remember we discussed it in last class also I first add these two so a real is added to b real so I am getting in temp this is temp where I am getting 5 <sil=0.969> .PERIOD 5 and then imaginary I am getting 7 <sil=0.918> .PERIOD 8 and now I return temp now in the main function if I had written something like say x and y were two complex variables and what I did I said add x y assign to some other complex variable z in that case that temp this temp will be assigned to this complex variable z that is how we can return a structure from a function <sil=0.922> .PERIOD So structure facilitates in many ways in this so direct arithmetic operations are not possible with structure variables that means I cannot just add a and b when both of them are structures I have to do the arithmetic operations over its members <sil=0.912> .PERIOD So with that we conclude our discussion on structures and structure is we will be given assignments on structures and this will enable you to write different types of handle different types of data types together and using the type there you can design your own complex data type which you can utilize further <sil=0.990> .PERIOD So please practice using structures it is not at all difficult only a little practice and a little understanding is required <sil=0.935> .PERIOD We were discussing about structures and in particular we have discussed about the way the structure is formed <sil=0.941> .PERIOD And in that context we have seen that a structure can contain within itself some members can be themselves a structure <sil=0.971> .PERIOD For example <sil=0.570> ,COMMA this one member which can itself be a structure consisting of other members <sil=0.369> ,COMMA this possible <sil=0.984> .PERIOD So this is a structure <sil=0.500> ,COMMA struct S <sil=0.345> ,COMMA S in which there is another struct <sil=0.452> ,COMMA say P which is a member of this <sil=0.469> ,COMMA it is possible <sil=0.973> .PERIOD So some member can be an array <sil=0.335> ,COMMA this can be say name 10 <sil=0.549> ,COMMA that means it is a character array of name 10 <sil=0.916> .PERIOD Similarly it could be some member can be int max 20 like that it can happen <sil=0.945> .PERIOD Now so we have seen that we can have arrays within structure also in the last lecture we have talked about arrays of structure <sil=0.979> .PERIOD So there is a scope of confusion between these two that is why I want to make it clearer that there can be an array within a structure as a member <sil=0.977> .PERIOD So on the other thing is we can have array of structure <sil=0.911> .PERIOD So in this case we have gotten array every element of that array is a structure of a particular type <sil=0.953> .PERIOD We know that an array can hold data elements of the same type <sil=0.955> .PERIOD So if I have one particular structure defined like say student and it can be an array of students <sil=0.925> .PERIOD So there will be each of them is of the type student and we have also seen so these two must be differentiated very clearly <sil=0.976> .PERIOD So as you can see that here a structure member can be an array we saw it in the last class <sil=0.480> ,COMMA last lecture that say for example a structure student has gotten array character array name 30 <sil=0.931> .PERIOD Now this is a part of an array <sil=0.919> .PERIOD Now that we know arrays within structure we have also seen arrays of structure where we can have a number of elements of that particular structure here <sil=0.947> .PERIOD So here we have seen that we have got an array class <sil=0.412> ,COMMA the array is class which can hold up to 50 elements and each element of this class is a structure of type student <sil=0.980> .PERIOD So individual members when I come to say class I then I am actually accessing a structure <sil=0.634> ,COMMA a particular structure in that array <sil=0.987> .PERIOD Now that structure has got number of fields therefore if I have class I dot name then I will get a particular name if that be the field or I can say class 2 dot role number <sil=0.905> .PERIOD So if I have class I dot name then I will get a particular name if that be the field or I can say class 2 dot role number <sil=0.934> .PERIOD So here I think this distinction must be very clear that this is an array of structures and we can handle them just as here the index is pointing to the particular element and then by the dot operator we are going inside that element and looking at that array <sil=0.961> .PERIOD Whereas in the case of an array within a structure we can we look at that in a different way that is if there be an then I come to the structure student and suppose there is a variable of name say a 1 <sil=0.908> .PERIOD So I can say a 1 dot say name and I can take a particular character of that <sil=0.909> .PERIOD So look at the difference of this this is 1 the other one was class I dot may be name j <sil=0.919> .PERIOD So here I am accessing the particular element from that structure and here I am coming to the structure and going to that array element within that structure <sil=0.979> .PERIOD So this is a usual point of confusion among many students that is why I was repeating this <sil=0.953> .PERIOD Next we will start looking at an important aspect an important style of writing programs which is type death that facilitates our programming with structure <sil=0.932> .PERIOD As the name type death implies we are defining some type we know that int is a type float is a type data type care is a type etcetera <sil=0.960> .PERIOD Now I can also define my own type that I will be using in my program using this type death statement type death command <sil=0.969> .PERIOD So we may define a structure a structure data type using a type death command like this let us see the syntax the syntax is I see type death struct member variable 1 member variable 2 member variable n and then some tag <sil=0.938> .PERIOD Tag is the name of the new data type let me illustrate this differentiating this with the earlier thing say earlier we had written something like this struct <sil=0.975> .PERIOD Student then care name 10 in role number like this <sil=0.961> .PERIOD So I was defining a structure in this way and I was later on referring to this structure as struct student say student 1 student 2 in this way <sil=0.925> .PERIOD Now what I am trying to do here is I am trying to define a type suppose I do not write this what I am doing instead I am saying type death struct same thing <sil=0.975> .PERIOD So I am trying to define a structure name 10 in role number and name this type as student if I do this then next time when I write this student declare this student 1 and student 2 <sil=0.914> .PERIOD So I can do it in a different way I can do it much simply as I am writing now in the red if I just simply write look inside this red box if I write student 1 comma student 2 that is sufficient <sil=0.977> .PERIOD So I just as compared this with the way we had declared int x float y <sil=0.901> .PERIOD So here int and float was some types now here student 1 student 2 are 2 variables of type student <sil=0.991> .PERIOD Now this type is not a default type it is not predefined in C therefore but I can use it because I have already using this type death statement has defined this structure as student <sil=0.979> .PERIOD But please differentiate between this and the normal definition of struct student as we do normally as say struct something and then I say student <sil=0.919> .PERIOD Now this is here is it clear I say struct we have seen this and I write the members here and then define that structure as the type student <sil=0.958> .PERIOD Now this is a definition once for all a particular structure as student now this if I have to use it then I have to say struct student followed by a 1 a 2 student 1 student to whatever <sil=0.973> .PERIOD But in this case if I do this type death I am saved from this problem <sil=0.975> .PERIOD So let us have a little look at how will go about it <sil=0.974> .PERIOD So that is the tag so here type death a particular structure just as here could be care name or int role just like that note that they semicolon at the end of all these declarations <sil=0.939> .PERIOD And ultimately I name this tag see me save for example here as student <sil=0.939> .PERIOD So tag is the name of the new data type so given that here is an example again the example of complex number <sil=0.957> .PERIOD So we are defining a type called complex ignore this underscore here <sil=0.902> .PERIOD So type death something having real part and imaginary part is known as the data type complex and then I am saying complex ABC just like in ABC flow ABC I can write complex ABC because complex has already been defined here <sil=0.913> .PERIOD Because complex has already been defined so I think this is clear right next we move to how do we initialize a structure we saw that we can initialize an add a similarly we can initialize a structure as well <sil=0.917> .PERIOD Say structure variables may be initialized following similar rules like an array the values are provided in the within the second braces separated by commas for example here complex a complex a is a complex variable 1 <sil=0.953> .PERIOD 0 comma 2 <sil=0.946> .PERIOD 0 what does it imply it implies that it is a is a structure <sil=0.980> .PERIOD Having two fields and one field is 1 <sil=0.929> .PERIOD 0 another is 2 <sil=0.904> .PERIOD 0 <sil=0.984> .PERIOD Similarly B is another field which is initialize to minus 3 <sil=0.943> .PERIOD 0 and 4 <sil=0.995> .PERIOD 0 <sil=0.928> .PERIOD Just as we did it in the case of arrays we do it for individual structural variables but we have to put all the values initial values for all the fields of that <sil=0.933> .PERIOD So this is what happened by this initialization <sil=0.974> .PERIOD The other thing that last thing that we will be talking about is parameter passing in a function how do we pass a structure as a parameter to a function <sil=0.909> .PERIOD We have seen how arrays can be passed similarly how can we pass structures to a function like any other variable just like any other variable we can pass it like for example here you can see that there is a swap <sil=0.986> .PERIOD Between complex variable a and complex variable b now a and e are both structures <sil=0.959> .PERIOD So I am just saying just as we used to write say void swap into int b just like that <sil=0.965> .PERIOD Here I write complex a complex b it is also call by value <sil=0.906> .PERIOD Now so here is again the typical assignment and the way we carry it out <sil=0.902> .PERIOD So here is an example program using type depth what is being done here is I am defining a type complex type depth struct there are two parts real and imaginary and this data type is known as complex <sil=0.983> .PERIOD Now I am writing a function swap them so I am taking another I have taken another variable which is of type complex temp is of type complex <sil=0.991> .PERIOD So when I do assign a to temp then this temp variable which is of type complex will get will copy the variables say here it was 3 <sil=0.971> .PERIOD 0 and minus 2 <sil=0.937> .PERIOD So this will come here it will become 3 <sil=0.927> .PERIOD 0 and this will become minus 2 <sil=0.912> .PERIOD So that is temp now I copy a to b <sil=0.948> .PERIOD So here sorry b to a I am sorry not this one there was some b and the values of b are copied to a not here <sil=0.969> .PERIOD These are copied here and here so might be this is changed to 5 this is changed to 2 <sil=0.925> .PERIOD 0 minus 2 <sil=0.987> .PERIOD 5 and then I copy again b to temp a temp to b <sil=0.964> .PERIOD So this is again copied back so member by member the copy is done <sil=0.930> .PERIOD So here we illustrate what we mean by type depth and a function that is using it <sil=0.925> .PERIOD So now suppose how can we print a structure <sil=0.947> .PERIOD Print I am now printing the comp say here is a function the main function is calling print x and print y <sil=0.913> .PERIOD So say for example my main function is initializing now we understand all these things x to 4 x real part to 4 imaginary part to 5 <sil=0.951> .PERIOD And y is real part to 10 and imaginary part to 15 <sil=0.932> .PERIOD So now I am calling print x so it is calling print x so x is being copied call by value to another local variable a which is local to this function print <sil=0.933> .PERIOD So a is holding the complex variable x and print f a dot real a dot imaginary so field by field I print them then I come back I print y <sil=0.951> .PERIOD Y is copied to a and the same thing happens then I call swap now swap was a function that we just now saw where we take temp and we copy it to temp and then I copy b to a and then temp to a in that way we carry out the swapping <sil=0.984> .PERIOD So it is purely call by value and then I print x and print y after I swap what will happen in this case if I go back to this case where I am passing among this a and b the x and y are being swapped inside that function <sil=0.993> .PERIOD But will that be swapped in actuality you check that yourself how do we return a structure from a function suppose I have done something but in the earlier case x and y were being swapped inside the function but when I come back to the main my x y remains the same <sil=0.901> .PERIOD So if we if we want to return the function for example here I carry out a real plus b real I make it temp say here is an example of adding to complex numbers here complex a and complex b are two variables which have been passed on as parameter here and I have got a temp as an <sil=0.908> .PERIOD Local function local variable so temp dot real is copying a dot real plus b dot real so what is happening here I have got structure a with a real part and an imaginary part so 3 <sil=0.998> .PERIOD 0 4 <sil=0.944> .PERIOD 2 another is b with a real part <sil=0.939> .PERIOD Which is 2 <sil=0.972> .PERIOD 5 and maybe 3 <sil=0.913> .PERIOD 6 now when I am adding two complex numbers you remember we discussed it in last class also I first add these two so a real is added to b real so I am getting in temp this is temp where I am getting 5 <sil=0.940> .PERIOD 5 and then imaginary I am getting 7 <sil=0.952> .PERIOD 8 and now I return temp now in the main function if I had written something like say x and y were two complex variables and what I did I said add x y assign to some other complex variable z in that case that temp this temp will be assigned to this complex variable z that is how we can return a structure from a function <sil=0.912> .PERIOD So structure facilitates in many ways in this so direct arithmetic operations are not possible with structure variables that means I cannot just add a and b when both of them are structures I have to do the arithmetic operations over its members <sil=0.980> .PERIOD So with that we conclude our discussion on structures and structure is we will be given assignments on structures and this will enable you to write different types of handle different types of data types together and using the type there you can design your own complex data type which you can utilize further <sil=0.936> .PERIOD So please practice using structures it is not at all difficult only a little practice and a little understanding is required <sil=0.967> .PERIOD So <sil=0.609> ,COMMA we were discussing about pointers and we have seen that pointer is a variable <sil=0.982> .PERIOD So <sil=0.306> ,COMMA since it is a variable <sil=0.323> ,COMMA but a variable that points to some other variable <sil=0.999> .PERIOD But naturally the question that can arise is since pointers are variables <sil=0.448> ,COMMA we should be able to do some sort of operations like arithmetic operations on them <sil=0.928> .PERIOD So <sil=0.545> ,COMMA the answer is yes <sil=0.489> ,COMMA we can do that and in today's lecture we will look at exactly that pointer expressions <sil=0.931> .PERIOD Now <sil=0.376> ,COMMA this concept of pointers is a very strong component of the C language and it is not the case that in all languages this pointer is there <sil=0.351> ,COMMA but we are discussing pointers specifically because it will give you a very good idea about what indirection is <sil=0.982> .PERIOD We had mentioned about indirection right <sil=0.901> .PERIOD So <sil=0.404> ,COMMA for example <sil=0.371> ,COMMA I am just before moving into the actual discussion <sil=0.548> ,COMMA let me come to this that what is an indirection <sil=0.923> .PERIOD Somebody asks you the address of Tom's house <sil=0.948> .PERIOD You can do two things <sil=0.902> .PERIOD You can either give him the address of Tom's house or you can give him the address of John's house <sil=0.998> .PERIOD So <sil=0.459> ,COMMA that he goes to John's house and asks John to get the address of Tom's house <sil=0.915> .PERIOD So <sil=0.321> ,COMMA I do not know Tom's address <sil=0.603> ,COMMA but I know John who knows Tom's address <sil=0.960> .PERIOD This is indirection <sil=0.399> ,COMMA one level of indirection <sil=0.997> .PERIOD Another level of indirection could be that second level of indirection <sil=0.989> .PERIOD You can go to Ram and Ram will know the address of John who knows the address of Tom <sil=0.935> .PERIOD So <sil=0.333> ,COMMA that is second level of indirection <sil=0.902> .PERIOD So <sil=0.639> ,COMMA in our case we have got a particular variable P <sil=0.934> .PERIOD Let me just call this variable x and that x has got some value <sil=0.991> .PERIOD I am not saying and x has also got an address <sil=0.427> ,COMMA but I am not saying what is the value of x <sil=0.988> ?QUESTIONMARK What is x <sil=0.985> ?QUESTIONMARK That is my question <sil=0.960> .PERIOD And instead of answering that <sil=0.486> ,COMMA I am giving you a pointer to x and I am asking that I tell you <sil=0.555> ,COMMA I give you the answer go to P and find x <sil=0.908> .PERIOD So <sil=0.312> ,COMMA then P must be assigned the address of x <sil=0.943> .PERIOD So <sil=0.453> ,COMMA I go to this <sil=0.560> ,COMMA then I come to P and get the value of x as I want to have that in some other variable V <sil=0.519> ,COMMA where I want to have star P <sil=0.915> .PERIOD So <sil=0.649> ,COMMA indirectly I could have done simply V assigned x <sil=0.563> ,COMMA this two are equivalent <sil=0.910> .PERIOD That is what we discussed in the last class <sil=0.917> .PERIOD That is why this is an indirection that often comes in very handy <sil=0.587> ,COMMA very useful when we carry out many computations <sil=0.924> .PERIOD So <sil=0.553> ,COMMA like other variables <sil=0.496> ,COMMA pointer variables can also be used in expressions <sil=0.949> .PERIOD If P 1 and P 2 are two pointers <sil=0.586> ,COMMA the following statements are valid <sil=0.946> .PERIOD Star P 1 plus star P 2 <sil=0.981> .PERIOD So <sil=0.379> ,COMMA what is being meant by that <sil=0.921> ?QUESTIONMARK Suppose P 1 is pointing to something where there is 50 and P 2 is pointing to something <sil=0.497> ,COMMA which is stored as 60 <sil=0.959> .PERIOD Then what is some <sil=0.985> ?QUESTIONMARK Some becomes 50 plus 60 <sil=0.923> .PERIOD So <sil=0.645> ,COMMA this is star P 1 plus star P 2 <sil=0.457> ,COMMA 50 plus 60 <sil=0.921> .PERIOD So <sil=0.615> ,COMMA that should be 110 <sil=0.981> .PERIOD Next <sil=0.516> ,COMMA similarly I can have this <sil=0.508> ,COMMA but here it is a little <sil=0.417> ,COMMA it will be nicer if I had <sil=0.333> ,COMMA it will be easier nicer to read <sil=0.507> ,COMMA if I had put parenthesis <sil=0.344> ,COMMA so that I am not confused about this asterisk and this asterisk <sil=0.920> .PERIOD These have got completely different significance <sil=0.966> .PERIOD This is a multiplication and this is saying <sil=0.405> ,COMMA this asterisk is saying <sil=0.338> ,COMMA it is a content of a particular pointer <sil=0.987> .PERIOD Similarly <sil=0.517> ,COMMA these two are equivalent of course <sil=0.542> ,COMMA I have already shown that <sil=0.999> .PERIOD Now <sil=0.345> ,COMMA this is also possible <sil=0.996> .PERIOD Star P 1 <sil=0.561> ,COMMA so in my earlier drawing <sil=0.577> ,COMMA P 1 was 50 <sil=0.641> ,COMMA 50 plus 2 <sil=0.379> ,COMMA that is being coming over here <sil=0.961> .PERIOD So <sil=0.484> ,COMMA this one looks like that <sil=0.976> .PERIOD Whenever you are finding difficulty <sil=0.580> ,COMMA as I suggested <sil=0.516> ,COMMA just draw a simple diagram <sil=0.943> .PERIOD P 1 <sil=0.559> ,COMMA P 1 is pointing to some other variable <sil=0.307> ,COMMA which has got the value 40 <sil=0.975> .PERIOD So <sil=0.402> ,COMMA P 1 <sil=0.583> ,COMMA star P 1 is what <sil=0.946> ?QUESTIONMARK Star P 1 is that particular variable X and plus 2 <sil=0.339> ,COMMA that is equivalent to X plus 2 <sil=0.491> ,COMMA which is 42 <sil=0.948> .PERIOD And so <sil=0.316> ,COMMA that is coming to <sil=0.317> ,COMMA so this one is being modified to 42 <sil=0.920> .PERIOD Similarly <sil=0.406> ,COMMA I can do other operations like this <sil=0.618> ,COMMA where you must understand that this is actually talk just like another variable that an integer variable or whatever type P 1 is <sil=0.608> ,COMMA that type of variable <sil=0.932> .PERIOD And it is simple <sil=0.452> ,COMMA no other complications in that <sil=0.981> .PERIOD Now <sil=0.553> ,COMMA what are allowed in C <sil=0.880> ?QUESTIONMARK The certain things are allowed in C and some things are not allowed in C <sil=0.945> .PERIOD I can add an integer to a pointer <sil=0.914> .PERIOD I can subtract an integer from a pointer <sil=0.988> .PERIOD I can subtract one pointer from another <sil=0.996> .PERIOD And say if P 1 and P 2 are both pointers to the same array <sil=0.535> ,COMMA then P 2 minus P 1 gives the number of elements between P 1 and P 2 <sil=0.975> .PERIOD For example <sil=0.486> ,COMMA suppose here there is an array <sil=0.956> .PERIOD So <sil=0.587> ,COMMA P 1 is pointing here and P 2 is pointing here <sil=0.960> .PERIOD Then the number of elements P 2 minus P 1 will be just the subtraction of these addresses <sil=0.903> .PERIOD Suppose this was 5500 <sil=0.336> ,COMMA 5 and 1 if it be a character <sil=0.566> ,COMMA 5 and 1 <sil=0.496> ,COMMA 5 and 2 <sil=0.461> ,COMMA 5 and 3 <sil=0.904> .PERIOD So <sil=0.390> ,COMMA I have got three elements in between <sil=0.924> .PERIOD So <sil=0.439> ,COMMA these are all allowed <sil=0.991> .PERIOD I can subtract an integer from a pointer <sil=0.920> .PERIOD I can add an integer to a pointer <sil=0.999> .PERIOD So <sil=0.382> ,COMMA if I add an integer to a pointer <sil=0.394> ,COMMA that is P 1 <sil=0.555> ,COMMA P 1 plus 1 <sil=0.998> .PERIOD So <sil=0.594> ,COMMA that means it will point to this point <sil=0.634> ,COMMA this element <sil=0.912> .PERIOD What are not allowed <sil=0.880> ?QUESTIONMARK The things that are not allowed are you cannot add two pointers <sil=0.983> .PERIOD The reason is obvious <sil=0.904> .PERIOD P 1 is a pointer and P 2 is a pointer <sil=0.976> .PERIOD Now <sil=0.513> ,COMMA these two are two different locations <sil=0.954> .PERIOD So <sil=0.583> ,COMMA say P 1 is in location 7000 pointing to some variable and P 2 is in location 10000 pointing to some other variable <sil=0.935> .PERIOD So <sil=0.363> ,COMMA what does P 1 plus P 2 mean <sil=0.888> ?QUESTIONMARK 7000 plus 10000 <sil=0.526> ,COMMA 17000 that does not mean anything <sil=0.949> .PERIOD That can be a point to some garbage value or something else <sil=0.996> .PERIOD So <sil=0.563> ,COMMA that is not allowed <sil=0.913> .PERIOD Compiler we hold you for that <sil=0.964> .PERIOD Multiply or divide a pointer in an expression <sil=0.912> .PERIOD That is also not allowed <sil=0.945> .PERIOD You cannot multiply <sil=0.908> .PERIOD You can just add an integer <sil=0.383> ,COMMA subtract an integer or subtract one pointer from another <sil=0.995> .PERIOD These three you can do <sil=0.922> .PERIOD And here is something which is known as a scale factor <sil=0.982> .PERIOD Let us see whether you understand this or not <sil=0.974> .PERIOD We have seen that an integer value can be added or subtracted <sil=0.971> .PERIOD So <sil=0.462> ,COMMA here let us look at this <sil=0.940> .PERIOD P 1 and P 2 are two pointers of type integer <sil=0.951> .PERIOD I mean P 1 is pointing to an integer <sil=0.966> .PERIOD P 2 is also pointing to an integer <sil=0.931> .PERIOD Now <sil=0.352> ,COMMA I j are two integer variables <sil=0.943> .PERIOD P 1 is P 1 plus 1 <sil=0.963> .PERIOD That means what <sil=0.987> ?QUESTIONMARK P 1 was pointing somewhere <sil=0.984> .PERIOD But I am just adding some constant to that <sil=0.920> .PERIOD Here is a MA location <sil=0.975> .PERIOD And say P 1 is pointing to this <sil=0.965> .PERIOD And suppose it is an integer <sil=0.959> .PERIOD So <sil=0.561> ,COMMA this pointing to an integer <sil=0.945> .PERIOD Now <sil=0.383> ,COMMA P 1 plus 1 means this will point to the next integer <sil=0.969> .PERIOD Now <sil=0.599> ,COMMA I am not saying whether if an integer takes two bytes <sil=0.378> ,COMMA each of them are of two bytes <sil=0.988> .PERIOD So <sil=0.530> ,COMMA it just comes to the next integers <sil=0.910> .PERIOD The pointer arithmetic is that is why the type is important <sil=0.933> .PERIOD Depending on the type <sil=0.639> ,COMMA it is updating either by 2 or by 1 <sil=0.995> .PERIOD But P 1 plus 1 means I am going to the next <sil=0.951> .PERIOD I am P 2 plus P 2 is assigned P 1 plus j <sil=0.639> ,COMMA where j can be something <sil=0.974> .PERIOD So <sil=0.364> ,COMMA it goes to the so P 2 was pointing somewhere here <sil=0.953> .PERIOD I am upgrading that with the j value going to the jth next <sil=0.982> .PERIOD Similarly <sil=0.502> ,COMMA P 2 plus plus P 2 assigned any arithmetic operation I can do <sil=0.985> .PERIOD Next <sil=0.592> ,COMMA in reality it is not the integer value which is added or subtracted <sil=0.959> .PERIOD But rather the scale factor times the value <sil=0.979> .PERIOD That is one means one times the size of the integer <sil=0.991> .PERIOD So <sil=0.420> ,COMMA j times the size of an integer <sil=0.303> ,COMMA two bytes <sil=0.528> ,COMMA four bytes <sil=0.650> ,COMMA that is what <sil=0.934> .PERIOD That is why it is called the scale factor <sil=0.969> .PERIOD So <sil=0.478> ,COMMA this is not this one <sil=0.329> ,COMMA but next <sil=0.585> ,COMMA one next <sil=0.476> ,COMMA two next <sil=0.492> ,COMMA here jth next like that <sil=0.933> .PERIOD So <sil=0.596> ,COMMA for character the scale factor is one <sil=0.363> ,COMMA integer is four <sil=0.622> ,COMMA a four bytes take one integer <sil=0.371> ,COMMA float <sil=0.602> ,COMMA four <sil=0.983> .PERIOD Now <sil=0.582> ,COMMA this could be two <sil=0.432> ,COMMA that depends on what the scale factor is depends on the particular machine <sil=0.900> .PERIOD So <sil=0.564> ,COMMA if I write a for an integer pointer assuming the my computer is actually doing this <sil=0.424> ,COMMA that each of them is four <sil=0.542> ,COMMA then P 1 plus plus is adding P 1 by four <sil=0.981> .PERIOD That is going to the next integer <sil=0.420> ,COMMA going to the next integer <sil=0.988> .PERIOD Now <sil=0.609> ,COMMA in between there are four bytes <sil=0.911> .PERIOD So <sil=0.453> ,COMMA I am going to the next integer <sil=0.968> .PERIOD So <sil=0.599> ,COMMA there is one quick way of finding out how we can find out what is my representation in my system <sil=0.983> .PERIOD There is a nice inbuilt function called size of <sil=0.975> .PERIOD So <sil=0.453> ,COMMA if I give size of int <sil=0.515> ,COMMA the system returns me the value four or two depending on how much <sil=0.614> ,COMMA how many bytes does int consume <sil=0.962> .PERIOD Similarly <sil=0.619> ,COMMA I could have given size of float that will tell me how many bytes does the float consume so and so forth <sil=0.972> .PERIOD So <sil=0.418> ,COMMA that is one way to find the scale factors <sil=0.965> .PERIOD So <sil=0.446> ,COMMA number of bytes occupied by float is size of float <sil=0.924> .PERIOD If you give that the system will give you the size of returns that one that value <sil=0.947> .PERIOD The number of bytes required for that representation <sil=0.981> .PERIOD So <sil=0.443> ,COMMA in the system you would run this and you find that it is float is four <sil=0.429> ,COMMA int is four <sil=0.417> ,COMMA then you know what my scale factor is <sil=0.977> .PERIOD Now <sil=0.556> ,COMMA just like for every case we are thinking of how do we pass an array to a function <sil=0.522> ,COMMA how do we pass a structure to a function <sil=0.996> .PERIOD Here again we look at how do we pass a pointer to a function <sil=0.912> .PERIOD Pointers are often passed as parameters to a function and if you have thought about it you must have already discovered <sil=0.983> .PERIOD Now <sil=0.363> ,COMMA always it allows the data items within the calling programs to be accessed by the function altered and then return to the calling function in the altered form <sil=0.972> .PERIOD This is the calling by reference <sil=0.936> .PERIOD Normally arguments are passed to a function by value <sil=0.966> .PERIOD We have discussed this <sil=0.965> .PERIOD Now <sil=0.303> ,COMMA this is called as call by reference or call by address <sil=0.943> .PERIOD Now <sil=0.330> ,COMMA you can see this how this is done <sil=0.979> .PERIOD Because in call by value we have seen that in the swap function for example it was swapped within the function <sil=0.931> .PERIOD But that x y and the main function x y were two different entities <sil=0.962> .PERIOD Therefore <sil=0.560> ,COMMA whatever change was there that was lost <sil=0.969> .PERIOD Therefore <sil=0.367> ,COMMA here but if I had just passed on the pointer then whatever change I do in the pointer in that particular location I simply pass on the address and make a change over there then the change is reflected <sil=0.916> .PERIOD Because it is the same location that is known as call by reference <sil=0.993> .PERIOD Now <sil=0.528> ,COMMA here is an example of you have seen this passing by value <sil=0.970> .PERIOD I am repeating this a was 5 and b was 20 <sil=0.939> .PERIOD I call swap a b here what happened it took x was 5 <sil=0.402> ,COMMA b was 20 <sil=0.994> .PERIOD I changed it <sil=0.902> .PERIOD Now <sil=0.314> ,COMMA x was therefore now x was 20 and b was 5 <sil=0.947> .PERIOD But when I returned and printed this a and b they were completely different <sil=0.993> .PERIOD So <sil=0.444> ,COMMA swapping was not reflected <sil=0.975> .PERIOD Therefore <sil=0.592> ,COMMA here x and y were swapped a and b do not swap but instead so the output would be the same 5 and 20 <sil=0.951> .PERIOD But if I had done through reference here you see how I pass it on <sil=0.937> .PERIOD Here what I am passing you have must have thought about it <sil=0.913> .PERIOD So <sil=0.625> ,COMMA up instead of sending that value what I am sending is the address of a and address of b and here inside the function what am I accepting I am accepting the pointer <sil=0.980> .PERIOD So <sil=0.600> ,COMMA here x and y I know that what is coming to me is a pointer <sil=0.914> .PERIOD So <sil=0.615> ,COMMA what happened here it was 5 we discussed it earlier also but let me repeat because it is a very fundamental idea b is 20 and now I swap <sil=0.941> .PERIOD So <sil=0.532> ,COMMA here I have got do I have x no I have got this x which is nothing but and a and I have got this y which is nothing but and b <sil=0.965> .PERIOD Therefore <sil=0.611> ,COMMA they are pointing to this points <sil=0.924> .PERIOD Now when I swap I am actually swapping the content of x <sil=0.997> .PERIOD So <sil=0.301> ,COMMA the content of x that means here that is going to t and then content of y in direction I go from here follow my cursor I go here and that one is going as the content of a content of x <sil=0.978> .PERIOD So <sil=0.403> ,COMMA here it is becoming 20 and then t is coming as the content of y what is y <sil=0.930> .PERIOD Y is here <sil=0.925> .PERIOD So <sil=0.459> ,COMMA this is coming as 5 <sil=0.942> .PERIOD So <sil=0.619> ,COMMA when I come out and print here a and b as you can see has changed <sil=0.908> .PERIOD So <sil=0.335> ,COMMA you see how did I pass on the parameter look at this I have passed on the address and I have accepted them in my function as the pointer <sil=0.937> .PERIOD So <sil=0.630> ,COMMA with this we will get the correct answer x and y swap a and b also swap <sil=0.938> .PERIOD So <sil=0.525> ,COMMA the answer is that is correct one as we expected <sil=0.904> .PERIOD So <sil=0.577> ,COMMA now let us skip this a little bit and let us go to something else as pointers and addies <sil=0.970> .PERIOD When an array is declared when an array is declared the compiler allocates a base address and sufficient amount of storage <sil=0.959> .PERIOD You know that when I declare something an array int a 10 and if I say that int I have discovered using size of that int takes 4 bytes then for every element 4 bytes are kept and 40 such locations are allocated <sil=0.968> .PERIOD For me means for the array a <sil=0.937> .PERIOD Now <sil=0.546> ,COMMA this is alright <sil=0.992> .PERIOD Now <sil=0.587> ,COMMA when I refer to this array a because we saw that we pass on an array by reference to a function when we pass an array we call it by reference the reason behind that is that this name array a is the same as a pointer to the first location of that <sil=0.911> .PERIOD So <sil=0.558> ,COMMA it is as if equivalent to a is a pointer that is pointing to the first location of this array a alright they are equivalent <sil=0.927> .PERIOD So <sil=0.367> ,COMMA the base address is the location of the first element of the array the compiler also defines the array name as a constant pointer to the first element constant pointer <sil=0.952> .PERIOD When I declared the compiler also keeps a constant pointer that pointer you cannot change for example <sil=0.366> ,COMMA when I say x 5 1 2 3 4 5 then suppose the base addresses 2500 each integer requires 4 bytes then the elements will be x 0 will be 2500 x 1 will be 2500 so and so forth <sil=0.940> .PERIOD And the pointer will be 2500 if you go up 2500 so there is a pointer x means and address of x 0 which is 2500 alright <sil=0.923> .PERIOD So <sil=0.566> ,COMMA p assigned x and p assigned end of x 0 are equivalent <sil=0.964> .PERIOD So <sil=0.386> ,COMMA we can access successive values of x by using p plus plus or p minus minus to move from one element to another <sil=0.987> .PERIOD So <sil=0.431> ,COMMA I have got the p I have got this pointer is pointing to the array I cannot change that pointer but if I do p plus plus this point in the first element then I go to the next element of the array accord by the scale factor <sil=0.945> .PERIOD So <sil=0.412> ,COMMA this is if I do p plus plus I am actually doing p plus 4 set in that way I can move across <sil=0.946> .PERIOD So <sil=0.406> ,COMMA the relationships should be clear here so p plus 1 is the next one p plus 2 is the next one that we have already explained <sil=0.945> .PERIOD So <sil=0.345> ,COMMA here is a function to find average here you see we have got and a main program where I have got an array 100 elements for k assigned k to n for k 0 to n <sil=0.953> .PERIOD So <sil=0.566> ,COMMA I am reading k and then I am calling this average x I am calling average x n <sil=0.950> .PERIOD Now <sil=0.613> ,COMMA here what goes average x n you have seen this now you am passing the pointer when I am saying I am just passing the array actually I have passed on the pointer <sil=0.982> .PERIOD So <sil=0.572> ,COMMA whatever I do I am doing here I am taking another star p which is local which is pointing to the array <sil=0.935> .PERIOD So <sil=0.415> ,COMMA my array was here and I am putting another pointer p which is pointing to this array and array means what <sil=0.870> ?QUESTIONMARK array means the first location of the array then I carry on the sum here I carry on with p I here you see what I do I take p and then I change p sum assigns star p plus I <sil=0.908> .PERIOD So <sil=0.402> ,COMMA I am p plus 1 p plus 2 p plus 3 and star p plus 1 p plus 2 means the content of this these contents <sil=0.930> .PERIOD So <sil=0.575> ,COMMA here in this way I am getting the sum and returning what do I return return float sum by size <sil=0.969> .PERIOD So <sil=0.567> ,COMMA I get sum obviously the array was integer but now this is something called type casting that I can make it although it was float I put it in a bracket that means whatever is coming here I am converting that to float <sil=0.904> .PERIOD Sum will be the array sum of all integers will be any integer but when I divide by that although I did not declare sum to be floating point number just by this sort of type casting I can make it I will first do this and convert it make it a floating point number and then how do I return it <sil=0.878> ?QUESTIONMARK Yes you might have guessed correctly that I do not need to return it because whatever I have done here when I passed an array whatever was done that is being done here and this sum what I am returning I am returning this to the average so I will get this value <sil=0.924> .PERIOD So <sil=0.376> ,COMMA this should be clear so clarified now next thing that I will be discussing a little bit is on dynamic memory allocation I will take little time to explain that that is a very important concept and after that we will move to some discussion <sil=0.911> .PERIOD So <sil=0.573> ,COMMA let us discuss some basic discussions on file <sil=0.987> .PERIOD So <sil=0.516> ,COMMA we are looking at computing standard deviation <sil=0.932> .PERIOD So <sil=0.314> ,COMMA standard deviation is mean we have seen <sil=0.935> .PERIOD Now <sil=0.309> ,COMMA standard deviation is if the mean is suppose the mean is represented by mu <sil=0.307> ,COMMA then I take the sum of the deviation from the mean for every element of the array <sil=0.964> .PERIOD So <sil=0.334> ,COMMA the array was A with every element being called A i <sil=0.931> .PERIOD So <sil=0.359> ,COMMA what I am trying to do is I am taking the difference of A i from the mean <sil=0.963> .PERIOD And since its difference can be suppose there are some values and this is the mean and the value can be a little away from the mean on this side more than the mean or less than the mean <sil=0.976> .PERIOD So <sil=0.445> ,COMMA we take the square of the mean square of the difference and I do that for all the elements i equals 1 to n <sil=0.982> .PERIOD And then I take the square root of the whole thing that is my standard deviation or the my variance <sil=0.962> .PERIOD So <sil=0.628> ,COMMA I can compute either this or this whatever I like <sil=0.908> .PERIOD So <sil=0.338> ,COMMA you will simply understand that in the code that we have given a little earlier <sil=0.490> ,COMMA then there we had computed the mean that means mu has been computed which was the average that we computed last time <sil=0.960> .PERIOD So <sil=0.338> ,COMMA if I have read the elements in an array whatever the elements are 5 <sil=0.621> ,COMMA 7 <sil=0.567> ,COMMA 3 <sil=0.579> ,COMMA 2 and I have computed the mean mu has been computed mean is 12 <sil=0.397> ,COMMA 3 <sil=0.602> ,COMMA 15 <sil=0.635> ,COMMA 17 divided by 4 <sil=0.944> .PERIOD So <sil=0.585> ,COMMA it is 4 point something 4 point 1 <sil=0.452> ,COMMA 4 point 2 <sil=0.615> ,COMMA 5 that is my mean <sil=0.931> .PERIOD So <sil=0.343> ,COMMA now for every element again in this array I find out for i s i and 0 i less than equal to 3 i plus plus what do I do for every element I have got the mu and let us call it average <sil=0.917> .PERIOD So <sil=0.330> ,COMMA sum was 0 what is it look like sum was 0 <sil=0.343> ,COMMA sum will be now sum plus I am getting sigma of mu minus a i whole square <sil=0.929> .PERIOD So <sil=0.636> ,COMMA sum plus average minus a i times average minus a i <sil=0.943> .PERIOD So <sil=0.307> ,COMMA that is the square average is mu minus a i that is so <sil=0.516> ,COMMA I am doing this square and I am repeatedly doing this and getting the new sum and at the end of this loop therefore <sil=0.464> ,COMMA I have got this <sil=0.905> .PERIOD So <sil=0.354> ,COMMA I can see STD <sil=0.330> ,COMMA say dev let me call it standard deviation is square root of the sum <sil=0.974> .PERIOD In that way I can find out the standard deviation also <sil=0.934> .PERIOD Now <sil=0.615> ,COMMA let us come to the now what is the application what is the meaning of this <sil=0.992> .PERIOD So <sil=0.619> ,COMMA with this say in a class you are you are supposed to write a program where you want to find out say in a class of physics what is the average of the numbers of all the students <sil=0.935> .PERIOD So <sil=0.616> ,COMMA I will find out the mean and mean of the class marks right <sil=0.999> .PERIOD Similarly <sil=0.579> ,COMMA I can find out that what is the standard deviation how much did it vary that also I can find out <sil=0.973> .PERIOD Now <sil=0.433> ,COMMA let us look at this new another problem say a shop stores in different types of items in different types of items <sil=0.943> .PERIOD Now <sil=0.565> ,COMMA given the number of items of each type sold during a given month and the corresponding unit prices compute the total monthly sale <sil=0.973> .PERIOD So <sil=0.431> ,COMMA what is the scenario the scenario is this I have got say 5 items item 1 item 2 item 3 item 4 and item 5 and let me call it the item let me call it on this side let me call it this area is item price item cost item cost <sil=0.946> .PERIOD Suppose <sil=0.605> ,COMMA the cost here is 7 and half rupees per item of type 0 25 for item of type 1 <sil=0.932> .PERIOD This is 0 this is 1 this is 2 this is 3 this is 4 <sil=0.972> .PERIOD So <sil=0.586> ,COMMA the item cost for this for item of type 2 is 12 <sil=0.991> .PERIOD 5 item of type 3 is 10 item of item of type 4 is 50 rupees <sil=0.940> .PERIOD Now <sil=0.423> ,COMMA I want to store how many items items items items items of each type has been sold <sil=0.951> .PERIOD So <sil=0.476> ,COMMA I take another array and call it item sold <sil=0.957> .PERIOD Suppose 5 items have been sold of type 0 6 items here of type 1 2 items of type 2 4 items of type 3 and 2 items of type 1 <sil=0.965> .PERIOD Now <sil=0.588> ,COMMA my question is what is the total sale <sil=0.949> .PERIOD So <sil=0.390> ,COMMA what should I do you can easily understand that the here is item cost <sil=0.982> .PERIOD So <sil=0.449> ,COMMA I have to multiply this with this and add all these costs <sil=0.923> .PERIOD So <sil=0.513> ,COMMA it will be 7 <sil=0.980> .PERIOD 5 times 5 it will be 7 <sil=0.966> .PERIOD 5 times 5 plus 25 times 6 plus so and so forth in that way I can find the total cost <sil=0.931> .PERIOD So <sil=0.407> ,COMMA what will the program look like program will look like I will be needing to add is item cost and item sold and they should be of the same size assuming that I know beforehand that there are 5 items <sil=0.905> .PERIOD So <sil=0.580> ,COMMA I can start with item cost of type 5 but this will be cost will be of type float and they will be another the number of items is item sold the number of items sold is integer <sil=0.990> .PERIOD So <sil=0.387> ,COMMA I will have this <sil=0.977> .PERIOD I am not showing the part that here I am reading the 2 arrays <sil=0.975> .PERIOD So <sil=0.475> ,COMMA after I read the arrays I will have 2 arrays like this one is an integer array another is a floating pointer this is a float and this is an integer <sil=0.907> .PERIOD Now <sil=0.615> ,COMMA my actual body of the program will be in a loop for say I am doing it using for say I assign 0 I less than equal to 4 since the size is 5 I plus plus and what do I do here what do I do in the body of the for loop I take I write actually only one statement will do there is no harm in putting this bracket total cell which was a variable of type float total cell is total cell was initialized to 0 total cell plus item cost I times multiplied by item sold I <sil=0.944> .PERIOD So <sil=0.326> ,COMMA this will be done in a loop and so I will take the first item item cost 0 multiply with that with item cost item sold 0 add that with the total cell which was initialized to 0 <sil=0.970> .PERIOD So <sil=0.337> ,COMMA here I can have float total cell initialized to 0 0 <sil=0.981> .PERIOD 0 I can do that <sil=0.971> .PERIOD So <sil=0.579> ,COMMA now I am doing it in a loop <sil=0.938> .PERIOD So <sil=0.571> ,COMMA first I multiply these 2 add it to total cell next again in the next iteration I is incremented I take these 2 and multiply them and add it to the total cell <sil=0.986> .PERIOD Then I do this 2 and multiply them add it to the total cell and I go on in this way this is another this is in this way by using this array I will be able to add all this values and I will get the total cell at the end <sil=0.976> .PERIOD So <sil=0.576> ,COMMA here we could see 2 very nice examples of application of arrays <sil=0.981> .PERIOD Now <sil=0.398> ,COMMA one another problem that I gave you I mean is I was while comparing the arrays you can do it in multiple ways that there is 2 arrays you must have solved it by now <sil=0.921> .PERIOD That there were 2 arrays like this 7755 here 6 here 4 but again 3 3 <sil=0.987> .PERIOD So <sil=0.501> ,COMMA everywhere they are matching but intermediate they were affected and I had a flag value <sil=0.929> .PERIOD So <sil=0.399> ,COMMA flag was initialized to 1 and then in a fall loop then in the fall loop I was checking this was A and this was B flag was initialized to 1 <sil=0.946> .PERIOD So <sil=0.344> ,COMMA if A i is equal to B i this I can do because here I am doing it element wise then flag equal to 1 else flag equal to 0 and I can do exit and I come out of the loop straight way I come out of the loop because it does not really matter at which position the mismatch occurs as soon as the mismatch occurs I can say the flag is 0 and so I come out <sil=0.982> .PERIOD So <sil=0.340> ,COMMA when I was comparing this whenever I find a mismatch the flag will become 0 and it will not be reset to 1 again because of this mismatch because this part is not being computed <sil=0.970> .PERIOD I need not computed I need not computed because my objective was to see if the 2 arrays are equal and here the violation has already occurred <sil=0.951> .PERIOD So <sil=0.509> ,COMMA they are not equal however so that is one way you can try it with while loop also you can try with while to solve the same problem <sil=0.992> .PERIOD Another point is here the time and again here everywhere I am setting the flag to 1 <sil=0.962> .PERIOD I could have changed that also here if what did I need to do I go on I have in set flag to 1 and the condition I simply change I just change the condition <sil=0.934> .PERIOD If AI is not equal to BI then make flag 0 I could have done this as long as this condition is not holding I am going on doing the loop <sil=0.966> .PERIOD Is it clear I will go on doing the loop as long as there is no mismatch this condition means mismatch as soon as there is a mismatch I will set the flag to 0 and exit <sil=0.981> .PERIOD There is another way of solving the problem <sil=0.973> .PERIOD So <sil=0.393> ,COMMA you have to think logically what exactly you need to do and what exactly you are writing what is the flow and what is happening with the variables and I always suggest that you have small pictures of the different variables and see how they are changing in the course of running the program <sil=0.926> .PERIOD Now <sil=0.405> ,COMMA so we have seen a useful commercial so called toy commercial problem that how I can find out the cost of total sales or monthly sales <sil=0.960> .PERIOD So <sil=0.395> ,COMMA and here the number of items sold per month are given then you can do it <sil=0.913> .PERIOD Next let us look at a very important thing called searching <sil=0.934> .PERIOD Searching is a fundamental task in any and in fact in many computations in many computations we need to search <sil=0.972> .PERIOD What do you search there different types of searches but we will be now talking about the simplest possible search that is we are trying to find out whether a particular element is there in an array <sil=0.955> .PERIOD So <sil=0.510> ,COMMA the purpose is to check if a given element which is known as the key is there in the array or not <sil=0.996> .PERIOD We will first talk about the array is not arranged in any order and we will do that <sil=0.976> .PERIOD So <sil=0.371> ,COMMA suppose I ask the question that is there any even number in the set of numbers given suppose there are some numbers given 5 <sil=0.367> ,COMMA 7 <sil=0.534> ,COMMA 2 <sil=0.531> ,COMMA 9 <sil=0.565> ,COMMA 1 <sil=0.443> ,COMMA 8 <sil=0.409> ,COMMA 3 like that <sil=0.937> .PERIOD I want to see and suppose this is a huge this is a list of 100 numbers <sil=0.956> .PERIOD I want to find out whether there is any particular number forget about even number for the timing <sil=0.956> .PERIOD For the timing let us assume that I want to see whether in this list any 4 is there <sil=0.976> .PERIOD Is there any 4 in the list that is the question that we are asking the answer can be either yes or no <sil=0.951> .PERIOD If it is yes then the next question comes where in the list is it there is it where means in which position it is there <sil=0.903> .PERIOD I may ask like to know the position or I may not like to know the position I would be satisfied to know whether this list contains any 4 or not <sil=0.963> .PERIOD So <sil=0.606> ,COMMA 5 <sil=0.506> ,COMMA 7 <sil=0.342> ,COMMA 2 <sil=0.566> ,COMMA 9 <sil=0.486> ,COMMA 1 <sil=0.305> ,COMMA 8 <sil=0.501> ,COMMA 3 <sil=0.331> .PERIOD So <sil=0.385> ,COMMA again 5 <sil=0.560> ,COMMA 7 <sil=0.445> ,COMMA 2 <sil=0.461> ,COMMA 9 <sil=0.581> ,COMMA 1 <sil=0.442> ,COMMA 8 <sil=0.562> ,COMMA 3 and my key is 4 because I am interested in the existence of 4 <sil=0.977> .PERIOD So <sil=0.546> ,COMMA instead of writing the C which you will be writing I will be discussing how to approach this problem what would the pseudo code be <sil=0.920> .PERIOD And I am sure in the assignments in your practice you can write the program <sil=0.906> .PERIOD So <sil=0.579> ,COMMA I know I need to know beforehand this list <sil=0.927> .PERIOD So <sil=0.361> ,COMMA I need to know a list which may be an integer list of might be here 7 numbers I need to know that <sil=0.939> .PERIOD Also I need to know which key I am searching for once I know these 2 <sil=0.977> .PERIOD So <sil=0.525> ,COMMA I know 5 <sil=0.376> ,COMMA 7 <sil=0.485> ,COMMA 2 <sil=0.423> ,COMMA 9 <sil=0.614> ,COMMA 1 <sil=0.328> ,COMMA 8 <sil=0.538> ,COMMA 3 is my list and I know that 4 is my key then how should I go about it <sil=0.982> .PERIOD I have got 4 in mind I start to look at as if I am looking at through some means at different positions <sil=0.937> .PERIOD I look at this position and check this element and compare this element with the key and I ask are the equal <sil=0.948> .PERIOD If the answer is yes then obviously I can say that 4 is in the list <sil=0.971> .PERIOD But as you can see it is not true so in case of no I will shift my focus from here to here <sil=0.995> .PERIOD And I will now compare with 4 this element 7 are the equal no then I will again shift the focus and I will go on <sil=0.914> .PERIOD Shift the focus and I will compare with this element with the key <sil=0.992> .PERIOD In that I will go on how long shall I go on till the end of the list <sil=0.978> .PERIOD If suppose here there was a 4 instead of 1 there was a 4 here <sil=0.990> .PERIOD And when my focus changes to this point and then again comes to this point and then I find that this element is matching the key value then I can exit and say yes 4 is there in the list <sil=0.929> .PERIOD Then if the other question has to be answered that 4 is there but where is 4 <sil=0.923> ?QUESTIONMARK In that case what would be your answer would be this position <sil=0.939> .PERIOD And what is this position <sil=0.909> ?QUESTIONMARK This position is nothing but the current index <sil=0.603> ,COMMA current value of the index <sil=0.923> .PERIOD Here the index started this is my index which was shifting <sil=0.932> .PERIOD So now we can think of the algorithm I have got 5 <sil=0.447> ,COMMA 7 <sil=0.388> ,COMMA 2 <sil=0.493> ,COMMA 9 <sil=0.592> ,COMMA 1 <sil=0.632> ,COMMA 8 <sil=0.637> ,COMMA 3 and my key is 4 <sil=0.947> .PERIOD So I will be doing so this is a loop which is list 4 equals 0 that means the focus of the index I less than equal to 1 <sil=0.331> ,COMMA 2 <sil=0.542> ,COMMA 3 <sil=0.499> ,COMMA 4 <sil=0.587> ,COMMA 5 <sil=0.477> ,COMMA 6 <sil=0.432> ,COMMA 7 <sil=0.644> ,COMMA 6 <sil=0.568> ,COMMA I plus plus <sil=0.966> .PERIOD If list I that means the Ith element of the list is equal to the key then I can say found the list <sil=0.999> .PERIOD And I that means the Ith element of the list is equal to the key then I can say found assigned 1 <sil=0.936> .PERIOD What is found <sil=0.987> ?QUESTIONMARK Found is some variable which I have initialized at this point initially nothing is found it is not found <sil=0.935> .PERIOD So found is 0 initially I have not found the key <sil=0.946> .PERIOD Here I am comparing as soon as I compare I put found equal to 1 and then I can exit or this automatically this loop will go on <sil=0.941> .PERIOD Now if I do it in this way what is the problem <sil=0.984> ?QUESTIONMARK Suppose my key was 1 then it goes on I 0 this is never happening found is still 0 it goes on it comes to here and I count come to found equal to 1 <sil=0.923> .PERIOD And then I can say if found equal to 1 I can print F <sil=0.983> .PERIOD Print F key found at position percentage D I <sil=0.991> .PERIOD So at that point I can also print that it has been found here <sil=0.921> .PERIOD In the worst case what can happen <sil=0.906> ?QUESTIONMARK Found will remain 0 and I will come to the end of this point when I come here I can check if found equal to 1 <sil=0.986> .PERIOD If found is 0 print F key not found if I do not find it there can be different flavors of the same problem <sil=0.948> .PERIOD The other flavor could be that suppose this element 1 is there at multiple places suppose it is also here <sil=0.975> .PERIOD And what will this program result in what would be its output <sil=0.912> ?QUESTIONMARK I will go on checking here I will check the for loop is extending up to which part <sil=0.965> ?QUESTIONMARK For loop is extending up to this position and this is separate I should not have I should have written it on this side <sil=0.938> .PERIOD So I go on checking this so key is found at position number 0 1 2 3 4 key is found at position 4 the list is not exhausted <sil=0.953> .PERIOD Ultimately it will come to this point and when it and again it will say the key is found at position 6 twice it is found it will be told like that <sil=0.997> .PERIOD Key is it will print twice if at the end it comes and still the key the value of the variable found is 0 that will say print it is not found <sil=0.950> .PERIOD I could have also say the same thing same problem I do say suppose I have got a list 5792131 <sil=0.946> .PERIOD The question is how many ones are there the same algorithm will do the same algorithm will work <sil=0.956> .PERIOD The same algorithm the algorithm is I start from one point from this beginning I let me draw it in this way if this be an array where all my elements are there <sil=0.859> ?QUESTIONMARK 5792131 I start from the beginning I equal 0 and for every element I compare with the key and go on till the end <sil=0.918> .PERIOD Now if I want to do this what is the additional variable that I will require I will require another variable count which is initially 0 other than found which is also false <sil=0.954> .PERIOD So whenever I find the one and my key is one so whenever I find the one I will say found is equal to one and also I will do count plus plus and I will continue <sil=0.906> .PERIOD Here I come and I will find I will have the value of count with 2 <sil=0.945> .PERIOD So I can also say that here I could print where found is becoming one so I can say at which position it is found and how many times it is found <sil=0.908> .PERIOD Now it can another flavor could be that I have got this say this array I have got this array and some array 632915 and whenever I have been given a key say the key is 2 <sil=0.937> .PERIOD As soon as I find 2 that is enough for me I just want to know whether 2 is there in the list I am not interested to know how many times it is there or in which position it is there or at best I may like to know at which position I found it first <sil=0.989> .PERIOD So what I can do I will go on searching like this and whenever you find 2 then you print that I have found 2 here and exit <sil=0.977> .PERIOD So what will you do the loop will be the loop inside the loop you will have you can do it like this that if a i or list i let us I was writing list i is not equal to key <sil=0.975> .PERIOD So you could have done it by while also n minus 1 i plus plus you go on doing this if list i is not equal to sorry if it is equal to n minus 1 i plus plus you go on doing this <sil=0.904> .PERIOD List i is not is sorry if it is equal to the key whatever I done is equal to key say found equal to 1 and print F the position and exit <sil=0.981> .PERIOD And you did not go through the entire loop now there are so that is this sort of search which I am doing in a linear way from one side to the other is known as linear search is a simple very simple search for a particular element <sil=0.918> .PERIOD We will see a little bit more on this next lecture <sil=0.994> .PERIOD Today <sil=0.616> ,COMMA we will be discussing on a new concept of programming <sil=0.644> ,COMMA which is very interesting <sil=0.352> ,COMMA but possibly not very much familiar to you <sil=0.433> ,COMMA that is known as recursion <sil=0.907> .PERIOD You know repetitions <sil=0.552> ,COMMA how they are implemented in C programming <sil=0.943> .PERIOD For example <sil=0.565> ,COMMA whenever I want to do a particular work <sil=0.538> ,COMMA for example <sil=0.314> ,COMMA I want to add 10 numbers <sil=0.622> ,COMMA then I add the sum with sum plus sum a i with i equal to 1 and then I repeat it i plus plus and I go on repeating it and this repetition is done in the form of a for loop or while loop <sil=0.362> ,COMMA you know that <sil=0.957> .PERIOD Now <sil=0.626> ,COMMA recursion is a different way of doing this when a function calls itself <sil=0.944> .PERIOD That means <sil=0.401> ,COMMA a function <sil=0.322> ,COMMA a particular function will have some inputs and will deliver one output <sil=0.955> .PERIOD Now <sil=0.632> ,COMMA a function has been <sil=0.566> ,COMMA now you know nesting of functions that in order to achieve this objective of taking these inputs and delivering these output <sil=0.511> ,COMMA a function could call other functions from there another function and then ultimately return to this function <sil=0.561> ,COMMA return back here in that way it could be done <sil=0.949> .PERIOD This was known as nesting <sil=0.490> ,COMMA but recursion is a little different <sil=0.971> .PERIOD It is that here there is a function <sil=0.625> ,COMMA which is supposed to be to deliver some output <sil=0.962> .PERIOD Now <sil=0.543> ,COMMA in order to do this <sil=0.368> ,COMMA it is actually repeating itself <sil=0.933> .PERIOD That means <sil=0.580> ,COMMA let me give you an example <sil=0.998> .PERIOD Suppose <sil=0.364> ,COMMA I have a machine which can generate one apple <sil=0.624> ,COMMA it can generate one apple <sil=0.488> ,COMMA produce one apple or maybe say apple <sil=0.307> ,COMMA let us say it produces a vending machine which can deliver one coke <sil=0.568> ,COMMA one piece of coke <sil=0.363> ,COMMA one can of coke <sil=0.961> .PERIOD So <sil=0.481> ,COMMA you put in some input <sil=0.628> ,COMMA some commands and it gives you one coke <sil=0.906> .PERIOD Now <sil=0.410> ,COMMA it has been asked to deliver five coaks <sil=0.547> ,COMMA five coaks <sil=0.997> .PERIOD So <sil=0.456> ,COMMA how can you deliver five coaks <sil=0.924> ?QUESTIONMARK It can deliver only one coke at a time <sil=0.921> .PERIOD So <sil=0.445> ,COMMA as we know in our knowledge of iteration <sil=0.407> ,COMMA so this is some function <sil=0.622> ,COMMA function is delivering coke <sil=0.966> .PERIOD So <sil=0.336> ,COMMA it can be repeated <sil=0.432> ,COMMA this switch can be pressed <sil=0.405> ,COMMA there is a switch <sil=0.506> ,COMMA it can be pressed five times <sil=0.973> .PERIOD So <sil=0.640> ,COMMA first one coke comes out <sil=0.348> ,COMMA second coke comes out <sil=0.967> .PERIOD So <sil=0.544> ,COMMA that means <sil=0.633> ,COMMA this is being repeated five times <sil=0.935> .PERIOD That is the conventional one coke <sil=0.979> .PERIOD So <sil=0.433> ,COMMA that is the conventional way of iterating <sil=0.339> ,COMMA repeating the same thing in order to get the five coaks <sil=0.971> .PERIOD Let us try to do it in another way <sil=0.998> .PERIOD Let us assume that this machine can deliver one coke at a time <sil=0.423> ,COMMA but it can also clone itself <sil=0.907> .PERIOD So <sil=0.600> ,COMMA let us see how it looks like <sil=0.935> .PERIOD So <sil=0.434> ,COMMA I need five coaks <sil=0.991> .PERIOD So <sil=0.371> ,COMMA five <sil=0.329> ,COMMA but I can deliver only one <sil=0.943> .PERIOD So <sil=0.510> ,COMMA I saw that <sil=0.517> ,COMMA I can deliver only one coke <sil=0.926> .PERIOD All right <sil=0.925> ,COMMA I will deliver one coke <sil=0.330> ,COMMA but I will not deliver it till I am ensured that all the five coaks are deliverable <sil=0.963> .PERIOD So <sil=0.638> ,COMMA what it does <sil=0.854> ?QUESTIONMARK It clones itself makes another one copy of itself <sil=0.908> .PERIOD And activates this with I can deliver one coke <sil=0.951> .PERIOD So <sil=0.385> ,COMMA I ask him to deliver four coaks <sil=0.946> .PERIOD Now <sil=0.335> ,COMMA this one can also deliver only one coke and finds that <sil=0.493> ,COMMA I cannot deliver everything <sil=0.958> .PERIOD So <sil=0.591> ,COMMA I keep one coke ready what I can <sil=0.338> ,COMMA but I clone myself and another copy <sil=0.457> ,COMMA I activate him this machine and say <sil=0.339> ,COMMA please deliver three coaks <sil=0.395> ,COMMA but it cannot also deliver three coaks <sil=0.953> .PERIOD It can deliver only one <sil=0.912> .PERIOD So <sil=0.354> ,COMMA nothing is being delivered <sil=0.377> ,COMMA but only kept noted <sil=0.994> .PERIOD So <sil=0.331> ,COMMA it puts somebody <sil=0.447> ,COMMA another another clone <sil=0.585> ,COMMA please deliver two coaks <sil=0.912> .PERIOD I have got one <sil=0.951> .PERIOD So <sil=0.557> ,COMMA it is also not delivering because it is not being able to satisfy the request of two coaks <sil=0.336> ,COMMA which was posed to it by this machine <sil=0.946> .PERIOD So <sil=0.484> ,COMMA it now comes to another clone <sil=0.938> .PERIOD So <sil=0.370> ,COMMA asks this clone <sil=0.476> ,COMMA please deliver one coke <sil=0.972> .PERIOD Now <sil=0.359> ,COMMA as you know <sil=0.648> ,COMMA this machine can deliver one coke <sil=0.962> .PERIOD So <sil=0.501> ,COMMA now <sil=0.532> ,COMMA it delivers one coke and tells <sil=0.334> ,COMMA I have delivered <sil=0.966> .PERIOD Now <sil=0.562> ,COMMA this one then <sil=0.373> ,COMMA okay <sil=0.975> ,COMMA since it has delivered <sil=0.608> ,COMMA it delivers the other coke <sil=0.449> ,COMMA which it could do <sil=0.944> .PERIOD It also tells the <sil=0.340> ,COMMA it is requested <sil=0.502> ,COMMA it is earlier <sil=0.478> ,COMMA I mean of the earlier version <sil=0.357> ,COMMA that I have done my thing <sil=0.974> .PERIOD Now <sil=0.427> ,COMMA you do yours <sil=0.964> .PERIOD So <sil=0.469> ,COMMA what it will do <sil=0.869> ?QUESTIONMARK It can only <sil=0.314> ,COMMA each can <sil=0.629> ,COMMA remember <sil=0.549> ,COMMA each can only deliver one coke at a time <sil=0.943> .PERIOD So <sil=0.516> ,COMMA it will deliver another coke <sil=0.969> .PERIOD It passes on to the <sil=0.646> ,COMMA again <sil=0.361> ,COMMA tells its collar or its generator that deliver another coke <sil=0.359> ,COMMA I have delivered <sil=0.996> .PERIOD So <sil=0.455> ,COMMA it delivers the other coke and ultimately <sil=0.565> ,COMMA this one also knows that <sil=0.438> ,COMMA its child has delivered the coke <sil=0.987> .PERIOD So <sil=0.640> ,COMMA ultimately <sil=0.547> ,COMMA we get five coaks <sil=0.907> .PERIOD So <sil=0.517> ,COMMA you can very easily see that <sil=0.333> ,COMMA if I had <sil=0.441> ,COMMA this was one <sil=0.451> ,COMMA this is one way in which <sil=0.496> ,COMMA each of this function <sil=0.430> ,COMMA each of this blocks is the same function <sil=0.640> ,COMMA but it is being activated with different requests and they are waiting till the request can be fulfilled <sil=0.320> ,COMMA but in the meanwhile <sil=0.439> ,COMMA passing on the request to another one <sil=0.904> .PERIOD And as soon as this could fulfill it <sil=0.466> ,COMMA it passes it on and then it goes back <sil=0.923> .PERIOD In the case of iteration <sil=0.496> ,COMMA what would have happened <sil=0.921> ?QUESTIONMARK This would not be done <sil=0.568> ,COMMA this same thing <sil=0.534> ,COMMA one coke and again <sil=0.622> ,COMMA call this and another coke <sil=0.590> ,COMMA another coke like that <sil=0.908> .PERIOD So <sil=0.546> ,COMMA if I call each of these as functions <sil=0.505> ,COMMA then actually this function and this function <sil=0.327> ,COMMA there is no difference between them <sil=0.925> .PERIOD Only difference is a value with which it is being called and this process is successful because <sil=0.426> ,COMMA ultimately <sil=0.611> ,COMMA there will be a situation when this function of this machine will be able to deliver what is has been asked to <sil=0.624> ,COMMA one coke <sil=0.474> ,COMMA it can deliver <sil=0.951> .PERIOD So <sil=0.344> ,COMMA that will be done <sil=0.921> .PERIOD Therefore <sil=0.568> ,COMMA we can go back and have everybody else deliver the same thing <sil=0.961> .PERIOD This is the principle of recursion <sil=0.906> .PERIOD We will <sil=0.629> ,COMMA I just used it as a fun example <sil=0.372> ,COMMA but let us now come to a little more serious <sil=0.952> .PERIOD Look at this <sil=0.991> .PERIOD So <sil=0.592> ,COMMA it is a process by which a function calls itself repeatedly <sil=0.309> ,COMMA either directly like x is calling x or cyclically in a chain <sil=0.341> ,COMMA x is calling x <sil=0.430> ,COMMA calling y <sil=0.552> ,COMMA y is calling x like that <sil=0.991> .PERIOD Use for repetitive computations <sil=0.984> .PERIOD The best thing is <sil=0.433> ,COMMA you look at this example <sil=0.921> .PERIOD Factorial N <sil=0.311> ,COMMA all of us know that <sil=0.550> ,COMMA factorial 5 is nothing but <sil=0.350> ,COMMA 5 <sil=0.385> ,COMMA 4 times 4 times 3 times 2 times 1 <sil=0.991> .PERIOD Now <sil=0.507> ,COMMA you see the same thing I can say <sil=0.303> ,COMMA what is this part <sil=0.948> ?QUESTIONMARK 4 multiplied by 3 multiplied by 2 <sil=0.625> ,COMMA multiplied by 1 <sil=0.415> ,COMMA this factorial 4 <sil=0.962> .PERIOD So <sil=0.385> ,COMMA you see I am expressing factorial 5 factorial function in terms of itself <sil=0.650> ,COMMA 5 times factorial 4 <sil=0.900> .PERIOD And factorial 4 can again be expressed as 4 times factorial 3 <sil=0.944> .PERIOD And factorial 3 can be expressed as 3 times factorial 2 <sil=0.986> .PERIOD And factorial 2 can be expressed in terms of factorial 1 <sil=0.927> .PERIOD So <sil=0.452> ,COMMA 5 <sil=0.327> ,COMMA 4 <sil=0.550> ,COMMA 3 <sil=0.387> ,COMMA 2 and factorial 1 is the end <sil=0.921> .PERIOD So <sil=0.628> ,COMMA that is 1 <sil=0.926> .PERIOD So <sil=0.396> ,COMMA I am certainly getting the factorial there without any further expansion <sil=0.981> .PERIOD So <sil=0.593> ,COMMA this is <sil=0.476> ,COMMA so we can write in general factorial of N is N times factorial of N minus 1 <sil=0.995> .PERIOD And factorial of N minus 1 will be N minus 1 into factorial of N minus 2 <sil=0.935> .PERIOD factorial of N minus 2 will be N minus 2 into factorial of N minus 3 in that way it will go on <sil=0.949> .PERIOD But <sil=0.524> ,COMMA it will be successful only if there is a terminating point where which we often call the basis condition <sil=0.966> .PERIOD I hope you have understood this <sil=0.972> .PERIOD So <sil=0.344> ,COMMA two conditions are to be satisfied in order that we can write a recursive formula <sil=0.978> .PERIOD One is it should be possible to express the problem in the recursive form just like factorial <sil=0.447> ,COMMA factorial N is N times factorial N minus 1 <sil=0.916> .PERIOD And also there should there is another point that is the problem statement must include a stopping condition <sil=0.940> .PERIOD What was my stopping condition in the case of factorial <sil=0.952> ?QUESTIONMARK Factorial 1 is 1 <sil=0.950> .PERIOD So <sil=0.626> ,COMMA that was the stopping condition <sil=0.953> .PERIOD What was the stopping condition in the terms in terms of in the example of delivering the coke when the machine was asked to deliver only one coke then it can complete <sil=0.941> .PERIOD So <sil=0.583> ,COMMA that is the stopping condition and then we go back <sil=0.448> ,COMMA go back <sil=0.979> .PERIOD So <sil=0.308> ,COMMA the stopping factorial N is 1 if N is equal to 0 or N equal to 1 <sil=0.927> .PERIOD Otherwise <sil=0.612> ,COMMA it is N into factorial N minus 1 if N is greater than 0 <sil=0.991> .PERIOD So <sil=0.413> ,COMMA ultimately it will go on and ultimately it will conclude <sil=0.922> .PERIOD Example factorial 1 we have seen that another example greatest common divisor <sil=0.945> .PERIOD We can express that in a recursive form it is very interesting you can look at it that greatest common divisor of the same number is itself that is the key to the logic <sil=0.914> .PERIOD GCD of M and M is M and GCD of M and N is GCD of M minus N and N or the other way <sil=0.997> .PERIOD So <sil=0.396> ,COMMA for example <sil=0.422> ,COMMA GCD of 15 and 5 also 75 and 15 will be GCD of 60 and 15 <sil=0.900> .PERIOD GCD of 60 and 15 will be for GCD of 45 and 15 <sil=0.945> .PERIOD GCD of 45 <sil=0.649> ,COMMA 15 would be GCD of 30 and 15 <sil=0.981> .PERIOD GCD of 30 and 15 will be GCD of 15 and 15 <sil=0.956> .PERIOD Now <sil=0.529> ,COMMA I have got the stopping condition that GCD of the same number will be 15 <sil=0.957> .PERIOD So <sil=0.532> ,COMMA my result will be 15 <sil=0.902> .PERIOD Is it clear <sil=0.868> ?QUESTIONMARK So <sil=0.352> ,COMMA that is a recursive definition of GCD <sil=0.981> .PERIOD So <sil=0.555> ,COMMA most of the interesting problems can be expressed in the form or in the recursive form and that helps in writing a very second and tight code <sil=0.938> .PERIOD Here is another example of recursion <sil=0.389> ,COMMA Fibon-Axis series <sil=0.445> ,COMMA a series like this one then one then two <sil=0.979> .PERIOD Two is what <sil=0.861> ?QUESTIONMARK The sum of the previous two elements one plus one and three <sil=0.991> .PERIOD What is three <sil=0.959> ?QUESTIONMARK Three is the sum of the previous two two and one then five <sil=0.916> .PERIOD What is five <sil=0.954> ?QUESTIONMARK Five is the sum of the previous two then eight <sil=0.952> .PERIOD What is eight <sil=0.988> ?QUESTIONMARK Eight is the sum of the previous two five and three then 13 <sil=0.965> .PERIOD What is 13 <sil=0.977> ?QUESTIONMARK 13 is the sum of the previous two eight and five then 21 <sil=0.994> .PERIOD What is 21 <sil=0.863> ?QUESTIONMARK 21 is the sum of the previous two 13 and eight <sil=0.962> .PERIOD You can see how nice pattern it is <sil=1.000> .PERIOD Can you think of how we can write it in a recursive form <sil=0.909> ?QUESTIONMARK How we can express it in a recursive form <sil=0.871> ?QUESTIONMARK If you think a little bit it will be very easy <sil=0.964> .PERIOD It will be something like Fibon-Axis number of N is Fibon-Axis of N minus one plus Fibon-Axis N minus two <sil=0.927> .PERIOD So N 21 this one is the sum of the earlier two Fibon-Axis sequences <sil=0.943> .PERIOD Now Fn minus two will be what <sil=0.994> ?QUESTIONMARK Will be Fn minus three plus Fn minus four <sil=0.960> .PERIOD Similarly Fn minus one will be Fn minus one Fn minus two plus Fn minus three <sil=0.926> .PERIOD In that it will go on but when will it stop <sil=0.996> ?QUESTIONMARK The stopping condition is that Fibon-Axis of one is one <sil=0.913> .PERIOD We will see that <sil=0.961> .PERIOD So if we try to express it in the recursive form it turns out to be Fibon-Axis of zero is one <sil=0.933> .PERIOD That means the first element is one Fibon-Axis of one is one <sil=0.910> .PERIOD That means second element <sil=0.963> .PERIOD Then Fibon-Axis of N is Fibon-Axis of N minus one plus Fibon-Axis of N minus two <sil=0.934> .PERIOD So now suppose I give you Fibon-Axis of five <sil=0.912> .PERIOD How do you write that <sil=0.875> ?QUESTIONMARK It will be Fibon-Axis of five will be Fibon-Axis of four plus Fibon-Axis of three <sil=0.937> .PERIOD Fibon-Axis of three will be Fibon-Axis of two plus Fibon-Axis of one <sil=0.988> .PERIOD Fibon-Axis of one we know is one <sil=0.918> .PERIOD So I know this and then Fibon-Axis of two will be Fibon-Axis of one plus Fibon-Axis of zero <sil=0.959> .PERIOD I know that this is one <sil=0.970> .PERIOD This is one <sil=0.905> .PERIOD So I get this <sil=0.947> .PERIOD This is done <sil=0.991> .PERIOD Similarly Fibon-Axis once this is done I got this number <sil=0.987> .PERIOD So what would that be <sil=0.974> ?QUESTIONMARK This will be two <sil=0.929> .PERIOD And so third one will be two <sil=0.984> .PERIOD Then Fibon-Axis of four will be four plus two plus three five in that will go on <sil=0.965> .PERIOD So if we try to now we see how we can write a function <sil=0.924> .PERIOD How we can express this Fibon-Axis or this factorial the recursive expression in the form of a function <sil=0.950> .PERIOD Let us see here <sil=0.914> .PERIOD I am writing this <sil=0.994> .PERIOD You had seen earlier functions written for factorial <sil=0.983> .PERIOD So you can see factorial n is if n equal to zero return one otherwise return n times factorial n minus one <sil=0.955> .PERIOD So what will happen <sil=0.882> ?QUESTIONMARK How will this be executed <sil=0.971> ?QUESTIONMARK What will it return <sil=0.986> ?QUESTIONMARK While returning it will again call this function <sil=0.996> .PERIOD Again this function will start in the same way just by replacing n with n minus one and here it will come out with n minus two <sil=0.981> .PERIOD So it will again be called with n minus two and so on so forth <sil=0.981> .PERIOD It will go on <sil=0.946> .PERIOD Now how is that executed <sil=0.851> ?QUESTIONMARK The function as I said is not executed immediately <sil=0.934> .PERIOD Just as when I asked that coke machine to deliver five coaks it did not deliver immediately <sil=0.999> .PERIOD It could deliver one coke held it back but created another machine to deliver n minus one coke and that machine held it back and generated another machine to deliver n minus two coaks in this way it went on <sil=0.947> .PERIOD They are kept aside on a stack on a stack one after another until the stopping condition is encountered <sil=0.974> .PERIOD So it remember that I have to deliver one <sil=0.998> .PERIOD So if you look at this I do not know whether that will be visible or not here <sil=0.959> .PERIOD Here you see everybody remember that I have to deliver but they did not deliver <sil=0.946> .PERIOD When the stopping condition was met after that this back chain started <sil=0.991> .PERIOD So they are kept aside but not delivered immediately <sil=0.991> .PERIOD The function calls are then executed in reverse order <sil=0.978> .PERIOD Again you can see that they are executed in reverse order <sil=0.972> .PERIOD Here they are executed in the reverse order here in order to get the solution <sil=0.924> .PERIOD Say calculating factorial 4 first the function calls will be processed <sil=0.911> .PERIOD factorial 4 is factorial 4 times factorial 3 then factorial 3 is 3 times factorial 2 <sil=0.935> .PERIOD factorial 2 is 2 times factorial 1 <sil=0.926> .PERIOD factorial 1 is 1 times factorial 0 and factorial 0 is 1 <sil=0.933> .PERIOD Therefore now the actual values will return in the reverse order 1 into 1 1 <sil=0.967> .PERIOD So it fact 1 is complete <sil=0.968> .PERIOD So 1 into 2 is 2 that goes a factor is 2 in that way it goes on <sil=0.912> .PERIOD So it goes back in this direction <sil=0.914> .PERIOD This direction <sil=0.367> ,COMMA this direction and this direction <sil=0.905> .PERIOD Ultimately we get the result from here <sil=0.921> .PERIOD So the actual values return in reverse order <sil=0.918> .PERIOD So factorial 0 is 1 <sil=0.990> .PERIOD factorial 1 is 1 times 1 1 <sil=0.955> .PERIOD factorial 2 is now the reverse order is being done 2 into 1 2 <sil=0.387> ,COMMA 3 into 2 6 and 4 into 6 6 24 <sil=0.911> .PERIOD In that way it is being computed <sil=0.948> .PERIOD So if we look at <sil=0.346> ,COMMA so here is a stack <sil=0.907> .PERIOD Stack is a data structure <sil=0.931> .PERIOD Stack is a way of storing data where we stored the data just like whatever comes in first obviously goes out last <sil=0.902> .PERIOD Because if I put something here and above that I put something <sil=0.369> ,COMMA above that I put something just like a stack of books you cannot you will have to take out in the other way <sil=0.993> .PERIOD This one will come out first then this one will come out then this one will come out like that <sil=0.997> .PERIOD So let us see how it works <sil=0.940> .PERIOD factorial 4 <sil=0.973> .PERIOD So factor step 0 executes factorial 4 that is executes <sil=0.909> .PERIOD Now return 4 times factorial 3 <sil=0.963> .PERIOD You see here is the recursive call <sil=0.932> .PERIOD It is calling itself <sil=0.951> .PERIOD Return 4 times factorial 3 <sil=0.957> .PERIOD What is factorial 3 <sil=0.850> ?QUESTIONMARK Oh you do not know what is factorial 3 <sil=0.971> .PERIOD Return 3 times factorial 2 <sil=0.943> .PERIOD Oh you do not know what is factorial 2 <sil=0.962> .PERIOD Then return 2 into factorial 1 <sil=0.924> .PERIOD Oh you still do not know what is factorial 1 <sil=0.977> .PERIOD Return 1 into factorial 0 and so now you know factorial 0 is 1 <sil=0.907> .PERIOD So you get 1 and now you could not answer these questions earlier <sil=0.928> .PERIOD I have broken it down and gave you an easier solution and so now you go back here and you return 1 into 1 <sil=0.917> .PERIOD Then you go back here <sil=0.943> .PERIOD Return 1 into 2 <sil=0.932> .PERIOD Return 2 and you go back here <sil=0.933> .PERIOD Go back here <sil=0.917> .PERIOD Go back here in that way <sil=0.943> .PERIOD This is what is meant by recursion <sil=0.913> .PERIOD If we redo it <sil=0.616> ,COMMA if we and while we are doing this <sil=0.607> ,COMMA so here is computer implementation of that <sil=0.968> .PERIOD Factorial if n is less than 0 <sil=0.387> ,COMMA return 1 <sil=0.560> ,COMMA return n times factorial n minus 1 <sil=0.929> .PERIOD So compute 5 <sil=0.937> .PERIOD So it is again recursively expressing itself <sil=0.990> .PERIOD F 4 is being expressed in terms of F 3 <sil=0.906> .PERIOD Everything is being expressed <sil=0.954> .PERIOD F is being expressed in terms of F <sil=0.942> .PERIOD F 3 is being expressed in terms of F 2 <sil=0.926> .PERIOD F 2 is being expressed in terms of F 1 <sil=0.911> .PERIOD F 1 is being expressed in terms of F 0 and I know what F 0 is <sil=0.904> .PERIOD So F 0 is 1 <sil=0.905> .PERIOD So I go back and I know that now F 0 is 1 <sil=0.910> .PERIOD Therefore F 1 is 1 into 1 and in this way I go back <sil=0.970> .PERIOD Now you see it had expanded in this way <sil=0.971> .PERIOD Now you are it is shrinking <sil=0.917> .PERIOD 1 into N 1 <sil=0.975> .PERIOD So now I know factorial 1 <sil=0.956> .PERIOD So this will shrink <sil=0.927> .PERIOD Now I know what is factorial 2 <sil=0.916> .PERIOD That is 2 <sil=0.938> .PERIOD So this will shrink <sil=0.966> .PERIOD 3 into 2 6 <sil=0.995> .PERIOD It is shrinking <sil=0.916> .PERIOD Coming here 24 and then here 120 <sil=0.945> .PERIOD That is how as if in a spring it got expanded and then it contracted back <sil=0.936> .PERIOD This is recursion <sil=0.905> .PERIOD It ultimately turns factorial 5 to be 120 <sil=0.922> .PERIOD Another example will be if 1 axi number will explain it in the next lecture <sil=0.980> .PERIOD In the last lecture <sil=0.628> ,COMMA we encountered a special notation as if like this <sil=0.608> ,COMMA where we can put in amperesand and a variable name to denote the address of that particular variable <sil=0.905> .PERIOD So <sil=0.517> ,COMMA that is what we encountered in the earlier class <sil=0.942> .PERIOD Next <sil=0.407> ,COMMA we will be now <sil=0.390> ,COMMA we will be moving ahead towards some statements which are absolutely essential for writing any C program <sil=0.933> .PERIOD Just as in English <sil=0.379> ,COMMA we write different types of sentences <sil=0.916> .PERIOD Similarly <sil=0.605> ,COMMA in the language C just as it is a language <sil=0.349> ,COMMA there are again different types of statements that we can write and through which we can express what we want to do <sil=0.944> .PERIOD The simplest type of statement that we have already encountered about is assignment statement <sil=0.969> .PERIOD Assignment statement means I have got some contents in some register <sil=0.547> ,COMMA some registers say X <sil=0.412> ,COMMA some memory locations say variable X and has got some value 50 <sil=0.965> .PERIOD Now <sil=0.595> ,COMMA how does this value come over here <sil=0.953> ?QUESTIONMARK Initially <sil=0.525> ,COMMA it was not there <sil=0.954> .PERIOD So <sil=0.368> ,COMMA suppose I have got a memory location variable say speed and I want to put in some value into this location <sil=0.544> ,COMMA all right say 500 <sil=0.964> .PERIOD So <sil=0.524> ,COMMA what we do <sil=0.860> ?QUESTIONMARK We write speed assigned 500 semicolon <sil=0.904> .PERIOD So <sil=0.548> ,COMMA the general syntax for that is a variable name followed by the expression <sil=0.389> ,COMMA the variable name followed by the expression <sil=0.911> .PERIOD As you have written here <sil=0.579> ,COMMA speed is the variable name and the expression here is nothing but the constant <sil=0.453> ,COMMA all right <sil=0.996> .PERIOD It could be something else <sil=0.964> .PERIOD For example <sil=0.644> ,COMMA I could have written speed assigned 2 times 500 or maybe V times Q whatever speed is assigned V times Q <sil=0.963> .PERIOD I hear as some examples of such assignments <sil=0.961> .PERIOD As you can see here <sil=0.610> ,COMMA velocity is a variable <sil=0.437> ,COMMA right <sil=0.964> .PERIOD On the left hand side <sil=0.522> ,COMMA the variable name is there <sil=0.942> .PERIOD On this side is an expression <sil=0.963> .PERIOD Now <sil=0.364> ,COMMA what type of expression is this <sil=0.923> ?QUESTIONMARK 20 is nothing but a constant value <sil=0.972> .PERIOD Please note that all the statements must be ended with a semicolon <sil=0.927> .PERIOD Look at the second one <sil=0.544> ,COMMA be assigned 15 again a constant <sil=0.983> .PERIOD Look at the third one <sil=0.379> ,COMMA temp assigned 12 <sil=0.962> .PERIOD 5 <sil=0.983> .PERIOD So <sil=0.573> ,COMMA what type of variable is temp <sil=0.981> ?QUESTIONMARK You will immediately answer temp must be a floating point variable or real number <sil=0.964> .PERIOD Here you see a different type of expression <sil=0.551> ,COMMA a variable a is being assigned the variable a plus 10 <sil=0.910> .PERIOD What does it mean <sil=0.937> ?QUESTIONMARK So <sil=0.531> ,COMMA a assigned a plus 10 <sil=0.979> .PERIOD So <sil=0.590> ,COMMA a being a variable a is a memory location and suppose it has got some value 25 <sil=0.938> .PERIOD 7 if a is a floating point variable <sil=0.978> .PERIOD Now <sil=0.339> ,COMMA if I do a assigned a plus 10 that means whatever is there in the as the value of the variable a is taken out <sil=0.901> .PERIOD So <sil=0.624> ,COMMA we take out we read 25 <sil=0.925> .PERIOD 7 add 10 with that and we get 35 <sil=0.906> .PERIOD 7 <sil=0.992> .PERIOD And then this 35 <sil=0.907> .PERIOD 7 comes in here and I get a new look of a the same location will now hold 35 <sil=0.965> .PERIOD 7 <sil=0.907> .PERIOD So <sil=0.524> ,COMMA you see the left hand side is the destination where the new value after computation of the expression will go and the left side sorry the right side can have the same variable as a source or might be the some other variable could be some other variable also like here this expression you see <sil=0.928> .PERIOD I am using three variables here V is one variable <sil=0.404> ,COMMA U is one variable I am sorry I am using four variables here F is another variable and T is another variable <sil=0.944> .PERIOD Now <sil=0.420> ,COMMA suppose you have U has got some value 20 F has got some value 0 <sil=0.960> .PERIOD 5 and T has got some value 2 <sil=0.993> .PERIOD Then V is being computed as U is being taken 20 plus the product of these two 2 and 5 <sil=0.913> .PERIOD So <sil=0.567> ,COMMA 2 and 0 <sil=0.959> .PERIOD 5 will be 1 and 1 is being added to 20 <sil=0.904> .PERIOD So <sil=0.394> ,COMMA these two being added is becoming 21 and this 21 is filling up this variable V <sil=0.975> .PERIOD So <sil=0.507> ,COMMA here you can see I can use more number of variables I am sorry this is let us be a little nice <sil=0.921> .PERIOD So <sil=0.380> ,COMMA it should be 21 <sil=0.916> .PERIOD 0 <sil=1.000> .PERIOD Similarly <sil=0.529> ,COMMA here you see it is a mix of variables how many variables are here S is a variable <sil=0.398> ,COMMA U is a variable T is a variable F T T F T <sil=0.941> .PERIOD So <sil=0.379> ,COMMA 1 2 3 variables are there again U F T and S and there is a constant 0 <sil=0.929> .PERIOD 5 <sil=0.931> .PERIOD So <sil=0.316> ,COMMA this side entirely this side is the expression <sil=0.942> .PERIOD Similarly <sil=0.401> ,COMMA this is again an expression this is an expression this is also an expression <sil=0.979> .PERIOD We will see more of these expressions in a moment <sil=0.990> .PERIOD So <sil=0.334> ,COMMA a value can be assigned to a variable when the variable is declared <sil=0.980> .PERIOD For example <sil=0.372> ,COMMA when I am declaring a variable just starting I want to declare a particular variable and so <sil=0.500> ,COMMA I want to declare a variable may be acceleration acceleration <sil=0.965> .PERIOD Now <sil=0.516> ,COMMA when I and I say that acceleration is a real number <sil=0.958> .PERIOD So <sil=0.438> ,COMMA when I declare it I will write float acceleration and then at some point later on I can say acceleration assigned say 2 <sil=0.981> .PERIOD 5 <sil=0.907> .PERIOD This is one way the other way is that I could have written it when I declared it as float acceleration assigned or initialized to 2 <sil=0.956> .PERIOD 5 <sil=0.974> .PERIOD This is also allowed in C <sil=0.957> .PERIOD So <sil=0.307> ,COMMA a value can be assigned when it is declared <sil=0.919> .PERIOD For example <sil=0.417> ,COMMA here speed is an integer which is declared as an integer and along with that it is being assigned the value 30 <sil=0.923> .PERIOD Here you see the care is a type of another variable flag and when I am saying that it is a flag is a character I am along with that I am also assigning it to value y <sil=0.913> .PERIOD Now <sil=0.550> ,COMMA you understand you remember that within the single code means it is the integer it is a character string <sil=0.948> .PERIOD So <sil=0.376> ,COMMA I could have done it also like this care flag and then later on flag assigned y and this equivalent to what I did here <sil=0.918> .PERIOD Several values can be assigned the same value using multiple assignment operators <sil=0.974> .PERIOD What does it mean <sil=0.894> ?QUESTIONMARK As soon as we see the example it will be clear <sil=0.925> .PERIOD For example <sil=0.434> ,COMMA a <sil=0.502> ,COMMA b <sil=0.576> ,COMMA c all these are being assigned the value 5 <sil=0.922> .PERIOD Flag one and flag two both are being assigned the value y <sil=0.932> .PERIOD Speed and flow both are being assigned the value 0 <sil=0.992> .PERIOD 0 <sil=0.937> .PERIOD So <sil=0.302> ,COMMA here say for example the correct thing would be to say float speed flow assigned 0 <sil=0.906> .PERIOD 0 <sil=0.916> .PERIOD So <sil=0.300> ,COMMA that is the simplest possible way we go about it <sil=0.996> .PERIOD Now <sil=0.598> ,COMMA when we write an expression first thing we have seen now is the assignment statement <sil=0.994> .PERIOD Now <sil=0.369> ,COMMA in the assignment statement if you have seen in the earlier slide we are using some operators for example <sil=0.513> ,COMMA u assigned say v minus f times t or right <sil=0.909> .PERIOD So <sil=0.479> ,COMMA this is an assignment statement here is the assignment <sil=0.996> .PERIOD But on this side I have written an expression <sil=0.958> .PERIOD So <sil=0.460> ,COMMA how can we write an expression in C <sil=0.993> ?QUESTIONMARK We have seen quite a few examples of such expressions in the earlier slides <sil=0.911> .PERIOD We have seen different types of expressions like S assigned u times t plus 0 <sil=0.949> .PERIOD 5 times f times t times t <sil=0.998> .PERIOD So <sil=0.616> ,COMMA this is we will immediately recall that this is our standard school formula S is equal to u t plus half f t square right <sil=0.986> .PERIOD Now <sil=0.311> ,COMMA this expression has got two components this well known expression in school has got two components <sil=0.956> .PERIOD One side is the expression here which has to be computed and then that has to be assigned to another result or another variable <sil=0.987> .PERIOD So <sil=0.409> ,COMMA that is being written here <sil=0.951> .PERIOD Now <sil=0.564> ,COMMA this is the way an expression is written in C you cannot just write it in this way as we are doing in our school this is not possible we have to write it in this way <sil=0.973> .PERIOD Now <sil=0.395> ,COMMA here when we write this expression you please observe a couple of things look at these these these these these these are known as the operators you know that this is meaning multiplication this is meaning addition these are again multiplication symbols <sil=0.993> .PERIOD Now <sil=0.357> ,COMMA these they are sets of allowed operators in C just as every language allows some constructs to form sentence and some other are not some other constructs are not valid in a sentence formation similar to that in the programming language C or for that matter for any programming language there are some allowed operators by which we can form expressions <sil=0.926> .PERIOD So <sil=0.483> ,COMMA we have got three types of operators the type of operators that we have encountered till now we have seen till now are arithmetic operators <sil=0.546> ,COMMA but besides arithmetic operators there are two other types of operators called relational operators and logical operators <sil=0.922> .PERIOD So <sil=0.362> ,COMMA let us see a little more of this arithmetic operators these are some of the very familiar arithmetic operators right you know that this is this means addition normal subtraction this is division <sil=0.956> .PERIOD Remember unlike this sort of division that we use in school we use here this symbol for division <sil=0.999> .PERIOD Unlike this symbol that we use for multiplication here we use this symbol and new symbol that we are of introducing here is this symbol like the percentage sign <sil=0.917> .PERIOD Now <sil=0.382> ,COMMA this does not mean percent computing percentage it means modulus what does modulus mean say if the modulus means finding the remainder for example <sil=0.472> ,COMMA if I compute 15 modulus 3 that means <sil=0.557> ,COMMA I am dividing 15 by 3 and whatever is the remainder is my result <sil=0.943> .PERIOD So <sil=0.337> ,COMMA what is my remainder here <sil=0.889> ?QUESTIONMARK Reminder is 0 ok <sil=0.963> .PERIOD So <sil=0.528> ,COMMA modulus is basically the remainder operator <sil=0.988> .PERIOD So <sil=0.453> ,COMMA another example let us look at say I have got 27 modulus 2 what would the result be 27 divided by 2 the quotient is 13 right quotient is 13 and the remainder is 1 <sil=0.927> .PERIOD So <sil=0.583> ,COMMA this modulus will be 1 whereas <sil=0.519> ,COMMA if I had done 26 modulus 2 that would be 0 <sil=0.925> .PERIOD Now <sil=0.485> ,COMMA again observe if I instead of modulus operator if I had done 26 divided by 2 the result would be 13 <sil=0.910> .PERIOD So <sil=0.566> ,COMMA this gives you the quotient whereas <sil=0.588> ,COMMA this gives you the remainder all right <sil=0.921> .PERIOD So <sil=0.432> ,COMMA this is a new operator that we are coming across and you should keep that in mind <sil=0.938> .PERIOD Next let us proceed <sil=0.989> .PERIOD Now <sil=0.472> ,COMMA here are some examples distance is rate or velocity or speed multiplied by time please note again as I have told earlier also that any expression must end with a semicolon as is being done here <sil=0.979> .PERIOD What does it this mean can you read this variable <sil=0.857> ?QUESTIONMARK Can you read this variable is it meaningful net income is income minus tax <sil=0.918> .PERIOD So <sil=0.584> ,COMMA operator is minus and this is the arithmetic expression and this is the arithmetic operator <sil=0.971> .PERIOD Speed is distance divided by time again ended with a semicolon <sil=0.930> .PERIOD Speed is distance divided by time <sil=0.988> .PERIOD How do we find the area of a circle <sil=0.932> ?QUESTIONMARK Pi you remember pi we can define pi we had seen this example earlier as define pi 3 <sil=0.942> .PERIOD 1415 etcetera <sil=0.974> .PERIOD We could have done that <sil=0.969> .PERIOD So <sil=0.598> ,COMMA pi is a constant times radius times radius <sil=0.949> .PERIOD Here basically what I am computing is area is being assigned is the assignment operator and the expression is pi r square <sil=0.938> .PERIOD Now <sil=0.608> ,COMMA this expression I am writing in this way pi times r radius times radius <sil=0.959> .PERIOD Here is another expression y assigned a x square what does it how do we write it typically in school <sil=0.903> .PERIOD This is expression which is a x square plus b x plus c <sil=0.952> .PERIOD This is a very familiar expression of a quadratic expression <sil=0.917> .PERIOD Now <sil=0.307> ,COMMA when we write it again here you see how many operators I have <sil=0.936> .PERIOD I have got two multiplication operations three multiplication operations and two addition operations and one assignment operation <sil=0.951> .PERIOD So <sil=0.309> ,COMMA here again quotient is dividend divided by divisor <sil=0.940> .PERIOD Now <sil=0.443> ,COMMA this is exactly what I was telling a couple of moments back that this operator is actually returning you the quotient of a division operation <sil=0.944> .PERIOD And <sil=0.539> ,COMMA this is actually giving you the remainder of a division operation <sil=0.956> .PERIOD So <sil=0.517> ,COMMA here are some examples of arithmetic expressions <sil=0.954> .PERIOD Suppose x and y are two integer variables and whose values are we know 13 and 15 then x added to y x plus y arithmetic operator plus will give me 18 x minus y 13 minus will give me 8 <sil=0.963> .PERIOD Now <sil=0.591> ,COMMA the point to note here is that here again always try to think in terms of our memory location diagram x and y are two variables x is 13 and y is 5 <sil=0.959> .PERIOD So <sil=0.428> ,COMMA x plus y means the content of the location x plus the content of the location y x minus y is the content of the location x minus the content of the location y <sil=0.943> .PERIOD Similarly <sil=0.565> ,COMMA when we multiply it is 65 <sil=0.910> .PERIOD Now <sil=0.402> ,COMMA if I add an assignment with this operation with this operation I just add an assignment <sil=0.995> .PERIOD For example <sil=0.375> ,COMMA I write I am giving two variations z assigned x times y <sil=0.939> .PERIOD That means <sil=0.404> ,COMMA what there is another location z where the content of x and the content of y are taken and multiplied and 13 times 5 is 65 that is stored there and that is possible because I have assigned it here <sil=0.925> .PERIOD Again I could have as an alternative could have done x assigned x times y <sil=0.939> .PERIOD What would have happened in this case <sil=0.893> ?QUESTIONMARK The content of x would have been taken 13 multiplied with the content of y that is 5 13 and 5 would be 65 and this product 65 where would that be written it would be written in x y because it is being assigned to x <sil=0.983> .PERIOD So <sil=0.533> ,COMMA then this would be overwritten with 65 <sil=0.932> .PERIOD Similarly <sil=0.607> ,COMMA you will recall now x divided by 2 this is a division <sil=0.991> .PERIOD So <sil=0.327> ,COMMA I am expecting the quotient 13 divided by 5 what will be the quotient 2 but x modulus y would be the remainder of when I divide 13 by 5 <sil=0.912> .PERIOD So <sil=0.608> ,COMMA that modulus is 3 <sil=0.982> .PERIOD Now <sil=0.466> ,COMMA in an expression we can have different operators <sil=0.968> .PERIOD If more than one different operator occurs in a particular expression <sil=0.315> ,COMMA how will that expression be evaluated <sil=0.917> ?QUESTIONMARK So <sil=0.408> ,COMMA now we are concerned about how will evaluate or find the result of computing an expression ok <sil=0.913> .PERIOD Now <sil=0.542> ,COMMA here is a list in decreasing order of priority <sil=0.977> .PERIOD So <sil=0.415> ,COMMA if I have something like this say x assigned p plus q times z minus x divided by l plus m <sil=0.911> .PERIOD Now <sil=0.543> ,COMMA here you can see that I have got different operators what are those <sil=0.852> ?QUESTIONMARK Our well-known operators are plus multiplication minus division plus again <sil=0.955> .PERIOD Here is another operator that is parent thesis <sil=0.939> .PERIOD Now <sil=0.341> ,COMMA as we learnt in school algebra that the parent thesis has got the highest priority alright <sil=0.918> .PERIOD So <sil=0.518> ,COMMA I will first compute the elements which are within the parent thesis <sil=0.939> .PERIOD So <sil=0.403> ,COMMA first p plus q will be computed then l plus and l plus m will be computed <sil=0.955> .PERIOD Now <sil=0.322> ,COMMA out of this p plus q and l plus m which one will be computed first whenever these two the these are of the same priority these parent thesis <sil=0.966> .PERIOD Now <sil=0.380> ,COMMA if there be more than one operator of the same priority they will be computed left to right <sil=0.997> .PERIOD So <sil=0.404> ,COMMA first we will have p plus q computed alright <sil=0.987> .PERIOD Suppose that is something say let us call it a some value a times z minus x <sil=0.988> .PERIOD Suppose this is computed to be some constant b <sil=0.961> .PERIOD So <sil=0.428> ,COMMA in that way it will be computed <sil=0.902> .PERIOD So <sil=0.609> ,COMMA the parent thesis has got the highest priority <sil=0.951> .PERIOD Next after parent thesis it is unary minus <sil=0.976> .PERIOD Unary minus means usually when we write something like x minus y then I have got two variables on which I am carrying out this subtraction <sil=0.978> .PERIOD This is a binary operator in the sense that I am needing two variables or two constants two elements on which I am carrying out this computation <sil=0.940> .PERIOD Unary minus means that particular variable is being operated on <sil=0.933> .PERIOD For example <sil=0.556> ,COMMA if I had something like this minus x plus 7 <sil=0.951> .PERIOD 5 semicolon and suppose x was 2 <sil=0.946> .PERIOD 5 <sil=0.965> .PERIOD So <sil=0.419> ,COMMA what will be the value <sil=0.910> ?QUESTIONMARK x is 2 <sil=0.979> .PERIOD 5 <sil=0.933> .PERIOD So <sil=0.458> ,COMMA first this will be done <sil=0.960> .PERIOD So <sil=0.402> ,COMMA it will be minus 2 <sil=0.906> .PERIOD 5 plus 7 <sil=0.959> .PERIOD 5 <sil=0.955> .PERIOD So <sil=0.412> ,COMMA the result will be then 5 <sil=0.996> .PERIOD It is not that I will first compute this 2 <sil=0.996> .PERIOD 5 plus 7 <sil=0.969> .PERIOD 5 and then do the negation alright <sil=0.963> .PERIOD So <sil=0.409> ,COMMA the unary minus so here I had shown a variable <sil=0.911> .PERIOD It could be something constant also minus 2 plus 6 <sil=0.913> .PERIOD That means you all know that 6 subtracted by 2 although it is plus <sil=0.911> .PERIOD So <sil=0.366> ,COMMA because this has got the higher precedence <sil=0.925> .PERIOD The next one is multiplication <sil=0.453> ,COMMA division and modulus <sil=0.982> .PERIOD These three will have the same priority <sil=0.462> ,COMMA multiplication <sil=0.591> ,COMMA division and modulus <sil=0.988> .PERIOD These three operators will have same priority <sil=0.961> .PERIOD Therefore <sil=0.529> ,COMMA if I have an expression like say x division y multiplied by z modulus q <sil=0.935> .PERIOD How will that be which one will be done first <sil=0.975> ?QUESTIONMARK This and this have got the same priority <sil=0.949> .PERIOD Therefore <sil=0.437> ,COMMA we will be carrying it out left to right <sil=0.910> .PERIOD But if the expression was something like this minus x divided by y multiplied by z modulus q <sil=0.380> ,COMMA then which one would be done first <sil=0.997> ?QUESTIONMARK First this unary minus will be done first followed by these three candidates which will be done left to right <sil=0.964> .PERIOD Next comes addition and subtraction <sil=0.980> .PERIOD So <sil=0.607> ,COMMA if I have got an expression again like say x times y even before that let me put it p plus x times y divided by z minus q <sil=0.973> .PERIOD Then in which order would it be computed <sil=0.862> ?QUESTIONMARK First plus will not be computed <sil=0.936> .PERIOD Multiplication has got an higher priority <sil=0.979> .PERIOD This also has got an higher priority <sil=0.975> .PERIOD So <sil=0.393> ,COMMA out of these two which one will be done first <sil=0.958> ?QUESTIONMARK Left to right <sil=0.984> .PERIOD So <sil=0.362> ,COMMA first I will do this <sil=0.955> .PERIOD Suppose this is yielding a result A <sil=0.997> .PERIOD So <sil=0.552> ,COMMA it will be p plus A then divided by z minus q <sil=0.969> .PERIOD And then this one will be done because left to right of the same precedence <sil=0.935> .PERIOD Suppose it is b <sil=0.384> ,COMMA then it turns out to be p <sil=0.419> ,COMMA it turns out to be p plus b minus q <sil=0.940> .PERIOD Now out of this plus and minus have got the same priority <sil=0.932> .PERIOD Then which one will be done first <sil=0.892> ?QUESTIONMARK This part will be done first <sil=0.985> .PERIOD Suppose that is c c minus q <sil=0.961> .PERIOD This is how this entire operation will be done <sil=0.908> .PERIOD For operators of the same priority the evaluation is from left to right <sil=0.968> .PERIOD In the next class we will see some more examples of this and we will proceed further <sil=0.903> .PERIOD We were discussing about arrays and we have seen how we can read an array <sil=0.598> ,COMMA we have seen how we can print an array <sil=0.579> ,COMMA we have also seen how we can access the different elements of an array using for loops and while loops <sil=0.990> .PERIOD Now <sil=0.329> ,COMMA couple of things that we cannot do using an array are as you can see here <sil=0.388> ,COMMA we cannot use this equal it is this assignment for assigning one array variable to another <sil=0.923> .PERIOD For example <sil=0.509> ,COMMA if I have suppose I have one array E <sil=0.364> ,COMMA suppose I have one array E which is this array having some elements <sil=0.507> ,COMMA suppose it is an integer array and the elements here are 15 <sil=0.523> ,COMMA 6 <sil=0.563> ,COMMA 7 <sil=0.511> ,COMMA 9 <sil=0.323> ,COMMA 10 <sil=0.394> .PERIOD Now <sil=0.528> ,COMMA and there is another array B like this <sil=0.421> ,COMMA I want that this data be transferred to 1 to this array B as 15 <sil=0.472> ,COMMA 6 <sil=0.398> ,COMMA 7 <sil=0.336> ,COMMA 9 <sil=0.384> ,COMMA 10 <sil=0.486> .PERIOD Now <sil=0.379> ,COMMA that I cannot do using A assigned B <sil=0.409> ,COMMA I cannot do this or B assigned A <sil=0.380> ,COMMA I am sorry this is wrong <sil=0.523> ,COMMA using B assigned A <sil=0.488> ,COMMA I cannot do that <sil=0.905> .PERIOD However <sil=0.353> ,COMMA it is true that A is also a variable of type array and B is also a variable of type array <sil=0.928> .PERIOD But for other variable types <sil=0.452> ,COMMA for example <sil=0.522> ,COMMA if A is a integer variable and B is another integer variable and A was 15 and then I could have assigned B assigned A <sil=0.490> ,COMMA so B will become 15 <sil=0.997> .PERIOD But this sort of straightforward assignment cannot be done in the case of an array <sil=0.911> .PERIOD What we have to do in order to do such assignments in an array is that we will have to do it component by component element by element <sil=0.910> .PERIOD For example <sil=0.450> ,COMMA I can do this <sil=0.341> ,COMMA let me again take another array A <sil=0.988> .PERIOD Now <sil=0.307> ,COMMA this time I take an array A to be a little smaller of say 4 elements <sil=0.617> ,COMMA 1 <sil=0.601> ,COMMA 3 <sil=0.426> ,COMMA 2 <sil=0.599> ,COMMA 7 and there is another element B and I actually intend my intention is that the data in A goes to the array B <sil=0.962> .PERIOD Now <sil=0.590> ,COMMA as I said for an array <sil=0.383> ,COMMA I have to do it element by element <sil=0.961> .PERIOD So <sil=0.388> ,COMMA suppose this there are 4 elements in the array and I write a for loop for I equals 0 I less than equal to 3 I plus plus B I is assigned A I <sil=0.992> .PERIOD What will happen through this A I is 0 <sil=0.388> ,COMMA so A I that means A is 0 <sil=0.462> ,COMMA this element will be taken and that will be copied to the 0th element of B here <sil=0.560> ,COMMA both of them are I <sil=0.301> ,COMMA so that 0 <sil=0.972> .PERIOD So <sil=0.363> ,COMMA this will become 1 <sil=0.961> .PERIOD Next <sil=0.386> ,COMMA I is incremented <sil=0.635> ,COMMA so I becomes 1 <sil=0.494> ,COMMA so this element is being pointed at and I transfer this element to the corresponding element <sil=0.628> ,COMMA this will also be incremented I <sil=0.613> ,COMMA this is also I <sil=0.954> .PERIOD So <sil=0.583> ,COMMA I is 1 <sil=0.903> ,COMMA so this will be copied here <sil=0.924> .PERIOD Similarly for this element <sil=0.559> ,COMMA next in this loop I will be incremented and this will be loaded here <sil=0.965> .PERIOD Similarly for the last element it will go on <sil=0.971> .PERIOD Therefore <sil=0.328> ,COMMA ultimately I will get the same thing 1 <sil=0.370> ,COMMA 3 <sil=0.437> ,COMMA 2 <sil=0.545> ,COMMA 7 as was my intention <sil=0.329> ,COMMA but I cannot do it directly <sil=0.377> ,COMMA but I have to do it in the form of a loop <sil=0.361> ,COMMA element by element I have to transfer them <sil=0.972> .PERIOD So <sil=0.407> ,COMMA we cannot use this assignment directly <sil=0.330> ,COMMA what else am I prohibited to do <sil=0.962> ?QUESTIONMARK So <sil=0.314> ,COMMA A and B are 2 add is I cannot do this <sil=0.429> ,COMMA also I cannot compare 2 arrays using this sort of equality checker <sil=0.982> .PERIOD Earlier we have seen that I can check where the 2 elements are equal logical operation <sil=0.605> ,COMMA I could do it using normal A equals B <sil=0.528> ,COMMA I am sorry <sil=0.304> ,COMMA A is B <sil=0.489> ,COMMA if A was a variable 15 and B was another variable 15 <sil=0.453> ,COMMA in that case A equality checker B will lead to a value 1 or true <sil=0.461> ,COMMA but if A is an array and B is another array <sil=0.635> ,COMMA I cannot do it directly in that way <sil=0.953> .PERIOD They are also I can write a piece of program in which I can check them element by element <sil=0.957> .PERIOD So <sil=0.569> ,COMMA please note suppose I have got an array A <sil=0.352> ,COMMA which is 2 <sil=0.365> ,COMMA 4 <sil=0.402> ,COMMA 5 <sil=0.571> ,COMMA 7 <sil=0.581> ,COMMA another array B is 2 <sil=0.478> ,COMMA 4 <sil=0.344> ,COMMA 5 <sil=0.643> ,COMMA 7 <sil=0.371> ,COMMA then these 2 arrays are equal <sil=0.556> ,COMMA however if I have an array with the same elements <sil=0.446> ,COMMA but in a different arrangement say for example <sil=0.503> ,COMMA 2 <sil=0.550> ,COMMA 5 <sil=0.574> ,COMMA 4 <sil=0.488> ,COMMA 7 <sil=0.522> ,COMMA these 2 <sil=0.615> ,COMMA this A and C are not the same <sil=0.992> .PERIOD Therefore <sil=0.336> ,COMMA how can I compare <sil=0.499> ,COMMA how can I compare these 2 arrays <sil=0.560> ,COMMA how can I compare them <sil=0.627> ,COMMA in order to compare these 2 arrays A and B <sil=0.632> ,COMMA what I need to do is I have to write a small loop like for <sil=0.512> ,COMMA let me do it clearly <sil=0.989> .PERIOD So <sil=0.492> ,COMMA I have got an array <sil=0.340> ,COMMA I have got an array 2 <sil=0.549> ,COMMA 5 <sil=0.624> ,COMMA 7 <sil=0.597> ,COMMA 4 <sil=0.379> ,COMMA another array 2 <sil=0.540> ,COMMA 5 <sil=0.547> ,COMMA 7 <sil=0.554> ,COMMA 4 A and B are the equal <sil=0.504> ,COMMA I can compare them <sil=0.562> ,COMMA I want to compare them <sil=0.516> ,COMMA compare A and B <sil=0.949> .PERIOD Now <sil=0.381> ,COMMA what can I do <sil=0.439> ,COMMA I can do it in this way for I 0 <sil=0.539> ,COMMA I less than equal to 3 because there are 4 elements in the array <sil=0.337> ,COMMA I plus plus <sil=0.966> .PERIOD Suppose <sil=0.319> ,COMMA I put a flag here <sil=0.559> ,COMMA a variable flag equals 1 <sil=0.990> .PERIOD Suppose <sil=0.448> ,COMMA I keep a flag variable <sil=0.598> ,COMMA I initialize it to 1 <sil=0.527> ,COMMA now for I equal to 1 to 0 or let me make it simpler <sil=0.462> ,COMMA I keep it 0 <sil=0.560> ,COMMA initially this is 0 <sil=0.950> .PERIOD So <sil=0.612> ,COMMA now I do <sil=0.482> ,COMMA if A i is equal to B i <sil=0.354> ,COMMA flag is assigned 1 and flag is assigned 1 <sil=0.636> ,COMMA else flag assigned 0 and I come out of this <sil=0.972> .PERIOD So <sil=0.443> ,COMMA what I am trying to do is here <sil=0.473> ,COMMA let me avoid this part for the time being <sil=0.590> ,COMMA let see we will develop it gradually <sil=0.987> .PERIOD What will happen here <sil=0.322> ,COMMA if this is done <sil=0.519> ,COMMA let see for if I do this <sil=0.509> ,COMMA if I run this piece of code <sil=0.519> ,COMMA then what will happen <sil=0.937> ?QUESTIONMARK For I equal to 0 <sil=0.420> ,COMMA that means <sil=0.308> ,COMMA I will be comparing with this and if A i is equal to B i <sil=0.639> ,COMMA that means I am comparing these two <sil=0.529> ,COMMA if these two are equal <sil=0.375> ,COMMA then flag is 1 <sil=0.517> ,COMMA that means till now it is 1 <sil=0.530> ,COMMA but this will go on here <sil=0.943> .PERIOD So <sil=0.566> ,COMMA here 1 <sil=0.598> ,COMMA now 5 and 5 is 1 <sil=0.381> ,COMMA fine <sil=0.556> ,COMMA 7 and 7 is compared <sil=0.626> ,COMMA again it is written 1 <sil=0.643> ,COMMA 4 and 4 <sil=0.520> ,COMMA again it is written 1 <sil=0.527> .PERIOD So <sil=0.442> ,COMMA it has been done and ultimately come out with the value of flag <sil=0.607> ,COMMA ultimately I come out <sil=0.492> ,COMMA when I come out of this <sil=0.564> ,COMMA the value of flag is 1 and so I can say <sil=0.354> ,COMMA if flag is 1 <sil=0.547> ,COMMA then they are equal <sil=0.946> .PERIOD But there is some problem with this program <sil=0.434> ,COMMA what is that <sil=0.992> ?QUESTIONMARK First of all <sil=0.543> ,COMMA every time I was assigning flag to be 1 <sil=0.534> ,COMMA that is one problem <sil=0.940> .PERIOD Now <sil=0.519> ,COMMA suppose another problem is <sil=0.492> ,COMMA suppose this value is 6 <sil=0.390> ,COMMA then what will happen <sil=0.927> ?QUESTIONMARK Let us trace this once again <sil=0.385> ,COMMA 2 and 2 will match <sil=0.525> ,COMMA so the value of flag will be 1 <sil=0.396> ,COMMA fine <sil=0.555> ,COMMA 5 and 5 will be matched <sil=0.987> .PERIOD Again <sil=0.323> ,COMMA I am not bothering about how many times unnecessarily <sil=0.632> ,COMMA I am writing into flag <sil=0.551> ,COMMA that apart <sil=0.571> ,COMMA flag will be 1 <sil=0.907> .PERIOD Now <sil=0.338> ,COMMA 7 and 6 <sil=0.605> ,COMMA they are not equal to 1 <sil=0.620> ,COMMA so I will come out of this if statement <sil=0.329> ,COMMA but will go again in the loop <sil=0.927> .PERIOD So <sil=0.485> ,COMMA what should I do here <sil=0.912> ?QUESTIONMARK If this is not equal <sil=0.334> ,COMMA then I will have to set flag to 0 <sil=0.613> ,COMMA if there is a mismatch <sil=0.901> .PERIOD So <sil=0.567> ,COMMA if I do it like this <sil=0.302> ,COMMA then what will happen <sil=0.876> ?QUESTIONMARK It is this part <sil=0.997> .PERIOD If I is equal to be B I <sil=0.571> ,COMMA then flag will be 1 and else <sil=0.524> ,COMMA that means <sil=0.444> ,COMMA with this <sil=0.344> ,COMMA else flag will be 0 <sil=0.969> .PERIOD So <sil=0.343> ,COMMA ultimately now <sil=0.587> ,COMMA suppose <sil=0.532> ,COMMA but here again there is a problem <sil=0.387> ,COMMA what will happen <sil=0.949> ?QUESTIONMARK So <sil=0.594> ,COMMA 7 and 6 are not matching <sil=0.604> ,COMMA so this is not true <sil=0.403> ,COMMA so flag will be 0 <sil=0.928> .PERIOD And then <sil=0.511> ,COMMA I will again go into the loop <sil=0.369> ,COMMA because the loop has not yet ended and here I will find that these two elements are equal 4 and 4 <sil=0.907> .PERIOD So <sil=0.320> ,COMMA it will come at this point and flag will be 1 and then <sil=0.617> ,COMMA I come out of the loop <sil=0.465> ,COMMA I will come out with flag equal to 1 <sil=0.393> ,COMMA but these two areas are not equal <sil=0.625> ,COMMA because I can see that the elements are different <sil=0.936> .PERIOD So <sil=0.618> ,COMMA this problem <sil=0.600> ,COMMA this program will not solve my purpose <sil=0.984> .PERIOD I leave it to you for a while to see how to think <sil=0.592> ,COMMA how you can solve this problem <sil=0.904> .PERIOD You need to apply your mind a little bit to write this piece of program <sil=0.450> ,COMMA which will simply check whether two areas are equal or not <sil=0.970> .PERIOD If they are equal <sil=0.476> ,COMMA that means <sil=0.350> ,COMMA if the elements are the same at every position <sil=0.474> ,COMMA corresponding position <sil=0.419> ,COMMA the elements are same <sil=0.924> .PERIOD In that case <sil=0.615> ,COMMA it will come out with a flag value of 1 <sil=0.595> ,COMMA otherwise it will come out with the flag value of 0 <sil=0.979> .PERIOD That is the task <sil=0.985> .PERIOD I hope you understand where the problem is in this program <sil=0.945> .PERIOD You see here <sil=0.648> ,COMMA had the mismatch been at the last point <sil=0.424> ,COMMA last moment <sil=0.400> ,COMMA at the last element <sil=0.435> ,COMMA 7 <sil=0.580> ,COMMA 6 <sil=0.480> ,COMMA then it would have worked fine <sil=0.964> .PERIOD So <sil=0.410> ,COMMA that is why at the beginning we said <sil=0.543> ,COMMA this is not just C programming <sil=0.467> ,COMMA it is learning to write programs using logic <sil=0.961> .PERIOD Suppose this <sil=0.544> ,COMMA this was 7 and this was 3 <sil=0.914> .PERIOD Then <sil=0.364> ,COMMA that is not equal <sil=0.991> .PERIOD Here <sil=0.627> ,COMMA flag would be 1 <sil=0.629> ,COMMA here flag would be 1 <sil=0.473> ,COMMA here flag would be 0 and it would come out and my answer would be correct <sil=0.950> .PERIOD The answer is correct by chance <sil=0.494> ,COMMA because as we have seen that <sil=0.402> ,COMMA here <sil=0.306> ,COMMA if I have an error <sil=0.415> ,COMMA if I have a mismatch <sil=0.641> ,COMMA here and suppose here <sil=0.407> ,COMMA the things are alright <sil=0.922> .PERIOD Then <sil=0.579> ,COMMA once gate the flag is 0 <sil=0.634> ,COMMA but next time that flag will be made to 1 and ultimately when I come out <sil=0.524> ,COMMA I will have the flag value to be 1 <sil=0.999> .PERIOD So <sil=0.504> ,COMMA the correct answer has eluded me <sil=0.939> .PERIOD So <sil=0.620> ,COMMA you just think of how I can modify this program such that I get the correct result as I intended <sil=0.907> .PERIOD So <sil=0.423> ,COMMA we cannot use these directly <sil=0.568> ,COMMA directly compare the array variables <sil=0.980> .PERIOD I cannot compare what else <sil=0.885> ?QUESTIONMARK So <sil=0.648> ,COMMA if A assigned B <sil=0.333> ,COMMA this sort of thing I cannot do <sil=0.995> .PERIOD Also <sil=0.519> ,COMMA the other thing that I cannot do is <sil=0.546> ,COMMA can if and print of statements <sil=0.413> ,COMMA I cannot read the array in one shot that is not allowed <sil=0.912> .PERIOD I could normally <sil=0.381> ,COMMA normally what could I do <sil=0.947> ?QUESTIONMARK Normally <sil=0.480> ,COMMA if I have a variable A <sil=0.571> ,COMMA some variable value 5 <sil=0.594> ,COMMA I could have simply done print F percentage D A <sil=0.994> .PERIOD So <sil=0.437> ,COMMA this could be printed <sil=0.916> .PERIOD Similarly <sil=0.452> ,COMMA I could have done scan F percentage D and A <sil=0.955> .PERIOD I could have read a value here <sil=0.906> .PERIOD But <sil=0.565> ,COMMA if it is an array <sil=0.441> ,COMMA I cannot do it in this way <sil=0.994> .PERIOD We already know how we can do that <sil=0.935> ?QUESTIONMARK We know that in order to read an array <sil=0.350> ,COMMA what we need to do is read it again in a loop <sil=0.578> ,COMMA in a fall loop <sil=0.941> .PERIOD So <sil=0.403> ,COMMA it can be for I assigned 0 <sil=0.391> ,COMMA I less than equal to whatever 3 <sil=0.417> ,COMMA I plus plus scan F percentage D and A <sil=0.929> .PERIOD So <sil=0.572> ,COMMA this array A will be read element by element I equal to 0 <sil=0.979> .PERIOD So <sil=0.393> ,COMMA first this element will be read <sil=0.620> ,COMMA might be 5 <sil=0.393> ,COMMA whatever element is 5 <sil=0.374> ,COMMA then might be 7 <sil=0.505> ,COMMA etc <sil=0.935> .PERIOD In that way <sil=0.576> ,COMMA I can read them element by element <sil=0.910> .PERIOD Similarly <sil=0.617> ,COMMA for printing an array 6 <sil=0.499> ,COMMA 4 <sil=0.505> ,COMMA for printing an array <sil=0.377> ,COMMA I can simply again do that for say J assigned 0 <sil=0.347> ,COMMA J <sil=0.912> .PERIOD Let me change a little bit <sil=0.953> .PERIOD Is any trouble here <sil=0.988> ?QUESTIONMARK J less than 3 <sil=0.443> ,COMMA J plus plus print F percentage D A I <sil=0.926> .PERIOD Here of course <sil=0.421> ,COMMA I do not give the scan F again <sil=0.935> .PERIOD Now <sil=0.558> ,COMMA is any problem with this <sil=0.961> ?QUESTIONMARK Here I made I less than equal to 3 <sil=0.922> .PERIOD Here I am making J less than 3 for the same size of array <sil=0.974> .PERIOD You can think of <sil=0.552> ,COMMA you can look at it <sil=0.976> .PERIOD This is also correct <sil=0.558> ,COMMA because here I am starting with 1 <sil=0.963> .PERIOD So <sil=0.424> ,COMMA 1 <sil=0.612> ,COMMA I am looking at now <sil=0.649> ,COMMA there is a mistake here <sil=0.995> .PERIOD I have done a couple of mistakes <sil=0.934> .PERIOD What will happen here <sil=0.500> ?QUESTIONMARK J first of all <sil=0.436> ,COMMA this was an unintentional mistake <sil=0.976> .PERIOD So <sil=0.620> ,COMMA this is J <sil=0.932> .PERIOD Now <sil=0.512> ,COMMA how will the array be printed here <sil=0.862> ?QUESTIONMARK If I do it in this way <sil=0.606> ,COMMA what will be printed <sil=0.865> ?QUESTIONMARK Here <sil=0.363> ,COMMA first thing that will be printed is J <sil=0.403> ,COMMA A J <sil=0.953> .PERIOD What is the value of J <sil=0.936> ?QUESTIONMARK 1 <sil=0.979> .PERIOD So <sil=0.523> ,COMMA what is A J <sil=0.884> ?QUESTIONMARK A 1 <sil=0.871> ?QUESTIONMARK That is this element <sil=0.959> .PERIOD So <sil=0.337> ,COMMA 7 will be printed <sil=0.981> .PERIOD Suppose <sil=0.348> ,COMMA I have got a backslash end here <sil=0.919> .PERIOD So <sil=0.325> ,COMMA 7 will be printed <sil=0.903> .PERIOD Then <sil=0.401> ,COMMA 6 will be printed <sil=0.608> ,COMMA because I is now 2 <sil=0.491> ,COMMA I is now 3 <sil=0.576> ,COMMA then 4 will be printed <sil=0.479> ,COMMA but till less than 3 <sil=0.994> .PERIOD Therefore <sil=0.343> ,COMMA 1 <sil=0.372> ,COMMA 2 <sil=0.429> ,COMMA 3 <sil=0.629> ,COMMA this will not be printed <sil=0.947> .PERIOD Also again <sil=0.645> ,COMMA I am missing this one <sil=0.901> .PERIOD What should I do <sil=0.858> ?QUESTIONMARK I can make it J minus 1 <sil=0.932> .PERIOD What will happen in that case <sil=0.944> ?QUESTIONMARK I am printing J is 1 <sil=0.404> ,COMMA and I am printing A J minus 1 <sil=0.910> .PERIOD That means <sil=0.548> ,COMMA I am printing A 0 5 <sil=0.934> .PERIOD Next <sil=0.529> ,COMMA J becomes 2 <sil=0.945> .PERIOD So <sil=0.526> ,COMMA I will be printing J minus 1 <sil=0.964> .PERIOD That means <sil=0.612> ,COMMA 2 minus 1 <sil=0.414> ,COMMA A 1 <sil=0.406> ,COMMA 7 <sil=0.362> ,COMMA then 6 <sil=0.974> .PERIOD Then <sil=0.529> ,COMMA J becomes 2 <sil=0.918> .PERIOD Then <sil=0.387> ,COMMA J becomes 3 <sil=0.904> .PERIOD So <sil=0.455> ,COMMA 3 minus 1 <sil=0.410> ,COMMA 2 <sil=0.475> ,COMMA I have printed <sil=0.975> .PERIOD Now <sil=0.460> ,COMMA J will be incremented <sil=0.945> .PERIOD It will be 3 <sil=0.966> .PERIOD The last one will not be printed <sil=0.944> .PERIOD Here <sil=0.363> ,COMMA also <sil=0.359> ,COMMA I have to make it less than equal to 3 <sil=0.917> .PERIOD Was this one all right <sil=0.911> ?QUESTIONMARK Just quickly check <sil=0.962> .PERIOD This is a common source of error <sil=0.947> .PERIOD I am reading this array <sil=0.941> .PERIOD Let me do it again <sil=0.911> .PERIOD I am reading this array <sil=0.958> .PERIOD A 0 <sil=0.516> ,COMMA then I have read A 0 <sil=0.428> ,COMMA then I is incremented <sil=0.978> .PERIOD So <sil=0.382> ,COMMA the 4 elements <sil=0.398> ,COMMA so I will come up to A 3 <sil=0.955> .PERIOD So <sil=0.312> ,COMMA the second one <sil=0.521> ,COMMA I am reading the second one <sil=0.530> ,COMMA A I is 1 <sil=0.918> .PERIOD So <sil=0.394> ,COMMA A 1 <sil=0.481> ,COMMA I is next 2 <sil=0.337> ,COMMA A 2 <sil=0.337> ,COMMA and then A 3 <sil=0.902> .PERIOD So <sil=0.601> ,COMMA this is okay <sil=0.426> .PERIOD So <sil=0.479> ,COMMA you have to be very careful about all this <sil=0.913> .PERIOD So <sil=0.447> ,COMMA reading and printing <sil=0.463> ,COMMA reading and printing <sil=0.365> ,COMMA we cannot directly do <sil=0.969> .PERIOD We have also to do it through a loop <sil=0.911> .PERIOD So <sil=0.590> ,COMMA I cannot do like this <sil=0.979> .PERIOD How to copy elements of one array to another by copying individual elements <sil=0.908> ?QUESTIONMARK I have already shown that <sil=0.979> .PERIOD So <sil=0.356> ,COMMA that is what we have to say about arrays right now <sil=0.981> .PERIOD Now <sil=0.472> ,COMMA we will come to some examples <sil=0.917> .PERIOD Say <sil=0.487> ,COMMA I want to <sil=0.359> ,COMMA this is an example of copying an array <sil=0.914> .PERIOD There are 2 arrays A <sil=0.355> ,COMMA 25 <sil=0.365> ,COMMA and B 25 <sil=0.979> .PERIOD So <sil=0.418> ,COMMA I am trying to copy them <sil=0.998> .PERIOD So <sil=0.504> ,COMMA you know that I can do it by copying it in this way <sil=0.964> .PERIOD Now <sil=0.647> ,COMMA some problems we will write to try out now <sil=0.949> .PERIOD One is finding the mean and standard deviation of a set of in numbers <sil=0.907> .PERIOD I leave this standard deviation part <sil=0.972> .PERIOD We can try to do that <sil=0.939> .PERIOD Mean <sil=0.523> ,COMMA you know mean is the arithmetic average <sil=0.936> .PERIOD So <sil=0.537> ,COMMA I will first try to find write a program where all of you will be able to write <sil=0.939> .PERIOD Find the mean and standard deviation of a set of in numbers <sil=0.994> .PERIOD So <sil=0.511> ,COMMA what are you going to do <sil=0.909> ?QUESTIONMARK Mean means the average right <sil=0.936> .PERIOD So <sil=0.440> ,COMMA I add the numbers <sil=0.503> ,COMMA all the numbers <sil=0.965> .PERIOD Suppose <sil=0.579> ,COMMA my array is A <sil=0.960> .PERIOD So <sil=0.490> ,COMMA each element i designate as A i is an element <sil=0.966> .PERIOD So <sil=0.481> ,COMMA I will have sigma A i <sil=0.452> ,COMMA i varying from 1 to 1 <sil=0.981> .PERIOD Whatever this size is divided by N <sil=0.602> ,COMMA that is the average <sil=0.994> .PERIOD I add all the numbers <sil=0.970> .PERIOD So <sil=0.406> ,COMMA it is simple to write the program <sil=0.943> .PERIOD Suppose <sil=0.478> ,COMMA I have read the array <sil=0.966> .PERIOD First of all <sil=0.512> ,COMMA I have to read the elements in an array <sil=0.956> .PERIOD So <sil=0.504> ,COMMA summarizing all what you have learnt <sil=0.626> ,COMMA what should be my first statement <sil=0.863> ?QUESTIONMARK First statement is declaring the array <sil=0.992> .PERIOD Let me declare an array in A <sil=0.908> .PERIOD Suppose <sil=0.422> ,COMMA the size of that is 5 <sil=0.906> .PERIOD Maximum size possible <sil=0.980> .PERIOD And I also have some and I have got another variable A V G <sil=0.958> .PERIOD All our integers <sil=0.997> .PERIOD Again A V G may not be integer <sil=0.965> .PERIOD Mean may not be integer <sil=0.993> .PERIOD So <sil=0.457> ,COMMA and then I have got another float A V G <sil=0.984> .PERIOD Now <sil=0.517> ,COMMA first I have to read the array <sil=0.993> .PERIOD So <sil=0.306> ,COMMA read the numbers <sil=0.950> .PERIOD I am making a shortcut <sil=0.992> .PERIOD I am leaving out the print of statement <sil=0.914> .PERIOD Please enter the array <sil=0.921> .PERIOD That part I am leaving out <sil=0.912> .PERIOD Then what I am doing here <sil=0.989> ?QUESTIONMARK Here of course <sil=0.446> ,COMMA for i assigned 0 <sil=0.322> ,COMMA i less than <sil=0.408> ,COMMA suppose there are 5 elements <sil=0.926> .PERIOD I less than 5 i plus plus <sil=0.993> .PERIOD If it was some other value <sil=0.304> ,COMMA then I would have put it N here <sil=0.943> .PERIOD And I had to read the N before I read the array <sil=0.922> .PERIOD So <sil=0.425> ,COMMA I do this <sil=0.978> .PERIOD And then initially <sil=0.394> ,COMMA I can make it the sum here to be sum is initialized to 0 <sil=0.957> .PERIOD Now <sil=0.585> ,COMMA for i equal to 0 i less than m i plus plus I read there <sil=0.976> .PERIOD So <sil=0.424> ,COMMA I am just reading the array <sil=0.952> .PERIOD So <sil=0.605> ,COMMA what I do <sil=0.992> ?QUESTIONMARK Scanif percentage D <sil=0.404> ,COMMA amperesand A i <sil=0.984> .PERIOD I am reading that <sil=0.978> .PERIOD And then here in this fall loop <sil=0.463> ,COMMA I can repeatedly compute the sum <sil=0.943> .PERIOD Sum equals sum plus A i <sil=0.901> .PERIOD So <sil=0.535> ,COMMA I will get the sum here ultimately at the end of the loop <sil=0.952> .PERIOD At the end of the loop <sil=0.470> ,COMMA I will get the sum <sil=0.924> .PERIOD So <sil=0.505> ,COMMA now here I can write average is sum divided by whatever the value was <sil=0.953> .PERIOD I have taken 5 to be a fixed value <sil=0.964> .PERIOD So <sil=0.523> ,COMMA I divided 5 <sil=0.918> .PERIOD And that is the average <sil=0.938> .PERIOD So <sil=0.398> ,COMMA in that way I can find out the mean <sil=0.992> .PERIOD This value <sil=0.904> .PERIOD The next task is computing the standard deviation <sil=0.906> .PERIOD So <sil=0.569> ,COMMA that I will leave to you for the time being <sil=0.608> ,COMMA we will take it up later <sil=0.921> .PERIOD Earlier <sil=0.595> ,COMMA we had talked about storage of data in arrays <sil=0.942> .PERIOD Now <sil=0.481> ,COMMA what we found <sil=0.339> ,COMMA what we mentioned in the case of arrays is that in an array <sil=0.359> ,COMMA we can store data only of a particular type <sil=0.469> ,COMMA particular say an array of integers or an array of floats or an array of characters <sil=0.304> ,COMMA but we could not mix different types in the same array <sil=0.994> .PERIOD For example <sil=0.306> ,COMMA we had faced the problem of representing the students' database <sil=0.619> ,COMMA where we will have the students name as well as the students' marks <sil=0.959> .PERIOD So <sil=0.305> ,COMMA we needed something like this <sil=0.580> ,COMMA actually that is what was desired <sil=0.425> ,COMMA that we will have the names here and names will be nothing but an array of characters <sil=0.913> .PERIOD So <sil=0.442> ,COMMA here will be some names <sil=0.552> ,COMMA ABC and here will be the marks 56 say <sil=0.989> .PERIOD Now <sil=0.599> ,COMMA this representation requires two arrays <sil=0.365> ,COMMA one is the representing the names as one array and representing marks as another array <sil=0.955> .PERIOD Now <sil=0.619> ,COMMA however <sil=0.381> ,COMMA as the diagram is showing here <sil=0.545> ,COMMA we are trying to represent them in an unified structure <sil=0.617> ,COMMA in the same structure <sil=0.370> ,COMMA but that is not possible in the case of an array <sil=0.985> .PERIOD Here <sil=0.494> ,COMMA we have got two different array types <sil=0.541> ,COMMA this is an array of characters and this is an integer <sil=0.951> .PERIOD For example <sil=0.422> ,COMMA similarly <sil=0.509> ,COMMA we can see that if I had stored something that say <sil=0.440> ,COMMA for example <sil=0.381> ,COMMA I want to store a graph <sil=0.377> ,COMMA a graph where at every point 1 <sil=0.449> ,COMMA 2 <sil=0.626> ,COMMA 3 seconds <sil=0.586> ,COMMA for example <sil=0.582> ,COMMA this is time in second <sil=0.370> ,COMMA and here I am measuring the temperature <sil=1.000> .PERIOD And if I have a graph <sil=0.378> ,COMMA which is something like this <sil=0.382> ,COMMA I cannot say that at every point the temperature will also be an integer <sil=0.940> .PERIOD Therefore <sil=0.457> ,COMMA if I had tried <sil=0.475> ,COMMA so suppose here at point number 2 <sil=0.541> ,COMMA the temperature is 50 <sil=0.983> .PERIOD 34 <sil=0.976> .PERIOD At point number 3 <sil=0.613> ,COMMA the temperature can be 70 <sil=0.925> .PERIOD 2 <sil=0.901> .PERIOD So <sil=0.596> ,COMMA if I had tried to represent that in the form of a 2D array <sil=0.491> ,COMMA in that case <sil=0.646> ,COMMA it was not possible because a 2D array is also an array and therefore <sil=0.544> ,COMMA is of only one type <sil=0.931> .PERIOD We have to declare a 2D array as an array of integer or as an array of characters or array of float <sil=0.960> .PERIOD So <sil=0.439> ,COMMA I cannot represent that in a 2D array <sil=0.370> ,COMMA where one side say <sil=0.453> ,COMMA for example <sil=0.415> ,COMMA one will be that one column <sil=0.319> ,COMMA will be temperature and another column will be the time and temperature <sil=0.935> .PERIOD So <sil=0.377> ,COMMA that was not possible to be done in a 2D array because time while time will be an integer 1 <sil=0.440> ,COMMA 2 <sil=0.428> ,COMMA 3 <sil=0.564> ,COMMA temperatures can be something different 50 <sil=0.928> .PERIOD 6 <sil=0.539> ,COMMA 70 <sil=0.335> ,COMMA 0 <sil=0.514> .PERIOD 3 etcetera <sil=0.982> .PERIOD So <sil=0.347> ,COMMA an array is not possible <sil=0.999> .PERIOD So <sil=0.328> ,COMMA our question is <sil=0.460> ,COMMA then what is the type of data structure <sil=0.926> ?QUESTIONMARK What is the type of arrangement by which I can represent data of different types together <sil=0.850> ?QUESTIONMARK And the answer to that is what we will be looking at today <sil=0.586> ,COMMA that is structure <sil=0.965> .PERIOD Structures in C allows us to represent a combination of different data types <sil=0.925> .PERIOD For example <sil=0.530> ,COMMA let me give an example of a structure <sil=0.996> .PERIOD Say <sil=0.647> ,COMMA I define <sil=0.389> ,COMMA I want to define student data and student data will consist of the student name <sil=0.958> .PERIOD Say <sil=0.538> ,COMMA the department of the student <sil=0.312> ,COMMA role number of the student <sil=0.427> ,COMMA may be the CGP of the student <sil=0.544> ,COMMA great point average of the student etcetera <sil=0.994> .PERIOD Now <sil=0.478> ,COMMA let us look at <sil=0.612> ,COMMA if I want to store them in <sil=0.566> ,COMMA store them together as a common piece <sil=0.491> ,COMMA a student data <sil=0.624> ,COMMA then this entire thing <sil=0.321> ,COMMA this student data has got components of different data types <sil=0.927> .PERIOD For example <sil=0.522> ,COMMA what will be student name <sil=0.901> ?QUESTIONMARK Student name say for example <sil=0.549> ,COMMA Amit will be either a string or an array of character <sil=0.904> .PERIOD Department somebody can say mechanical engineering <sil=0.506> ,COMMA that can also be a character <sil=0.588> ,COMMA character string <sil=0.947> .PERIOD Whereas <sil=0.558> ,COMMA role number 748 will be an integer <sil=0.983> .PERIOD And CGPA say 7 <sil=0.912> .PERIOD 8 will be a floating point number <sil=0.960> .PERIOD So <sil=0.348> ,COMMA what we can see that in order to store the student data <sil=0.446> ,COMMA we have to have a mixture of different data types <sil=0.945> .PERIOD So <sil=0.428> ,COMMA a structure allows us to do exactly this <sil=0.309> ,COMMA where I can consider the student data as a structure <sil=0.989> .PERIOD So <sil=0.404> ,COMMA let me redraw it in a different way <sil=0.904> .PERIOD So <sil=0.364> ,COMMA I draw a box now <sil=0.353> ,COMMA which is representing the student data <sil=0.964> .PERIOD I name it stood data <sil=0.987> .PERIOD And I have got different fields in this <sil=0.959> .PERIOD One field and each field has gotten some identification <sil=0.947> .PERIOD So <sil=0.536> ,COMMA this field is storing the name <sil=0.968> .PERIOD And this field is basically a character array <sil=0.525> ,COMMA a type of type character array <sil=0.912> .PERIOD So <sil=0.617> ,COMMA another field is name is department and its type is also character array <sil=0.909> .PERIOD Another field <sil=0.560> ,COMMA remember that every time I am using the term field <sil=0.356> ,COMMA field of student data <sil=0.945> .PERIOD So <sil=0.464> ,COMMA name department <sil=0.624> ,COMMA what is it we have <sil=0.970> ?QUESTIONMARK Role number <sil=0.648> ,COMMA which will be of type <sil=0.491> ,COMMA integer and CGPA <sil=0.574> ,COMMA which will be float <sil=0.982> .PERIOD Suppose <sil=0.550> ,COMMA there is no other field <sil=0.975> .PERIOD So <sil=0.402> ,COMMA we call this entire box to be a structure <sil=0.398> ,COMMA this is a structure <sil=0.902> .PERIOD And what is contained in this structure <sil=0.978> ?QUESTIONMARK There are four fields that define the structure <sil=0.922> .PERIOD The four fields are name <sil=0.378> ,COMMA department <sil=0.590> ,COMMA role number and CGPA <sil=0.993> .PERIOD These four fields are defining a structure <sil=0.988> .PERIOD Now <sil=0.585> ,COMMA C allows us to define structures of this type <sil=0.926> .PERIOD And we will learn how we can define such things <sil=0.917> .PERIOD And let us go ahead a little bit <sil=0.914> .PERIOD What is a structure <sil=0.965> ?QUESTIONMARK It is a convenient tool for handling a group of logically related data items <sil=0.969> .PERIOD Here of course <sil=0.510> ,COMMA the logically related data items were the different information fields or information component that are related to a particular student <sil=0.908> .PERIOD So <sil=0.475> ,COMMA till now we saw very simple data structures like array <sil=0.978> .PERIOD Now <sil=0.570> ,COMMA here for example <sil=0.367> ,COMMA I have got related components <sil=0.530> ,COMMA student name <sil=0.545> ,COMMA role number and marks or CGPA or for example <sil=0.523> ,COMMA a real part and complex imaginary part of a complex number <sil=0.933> .PERIOD For example <sil=0.456> ,COMMA if I had tried this <sil=0.647> ,COMMA say for example <sil=0.636> ,COMMA if you know that a complex number is stored as a plus i b <sil=0.343> ,COMMA that is a complex number <sil=0.997> .PERIOD Having so <sil=0.429> ,COMMA this is x <sil=0.389> ,COMMA where x is a complex number <sil=0.317> ,COMMA a plus i b <sil=0.906> .PERIOD So <sil=0.551> ,COMMA maybe x is equal to 4 plus i 3 <sil=0.925> .PERIOD All of you are aware of that <sil=0.964> .PERIOD Now <sil=0.318> ,COMMA how do I represent <sil=0.910> ?QUESTIONMARK I know how I can represent an integer <sil=0.921> .PERIOD I know how I can represent a floating point number <sil=0.969> .PERIOD But now <sil=0.412> ,COMMA the question is how I can represent such a complex number <sil=0.946> .PERIOD Now <sil=0.558> ,COMMA obviously <sil=0.467> ,COMMA I can immediately think of that well <sil=0.493> ,COMMA let me have a structure like this <sil=0.468> ,COMMA which will have two fields <sil=0.940> .PERIOD One is the real part <sil=0.647> ,COMMA this is a real part <sil=0.965> .PERIOD So <sil=0.470> ,COMMA I call it the real part <sil=0.932> .PERIOD Another part is the imaginary part <sil=0.989> .PERIOD And I can store this number simply as 4 <sil=0.318> ,COMMA 3 <sil=0.367> .PERIOD So <sil=0.497> ,COMMA the imaginary part is 3 and the real part is 4 <sil=0.986> .PERIOD So <sil=0.384> ,COMMA the complex number instead of being an integer or a float is essentially a structure <sil=0.953> .PERIOD There is another very common and easy use of structures that you can see <sil=0.997> .PERIOD So <sil=0.376> ,COMMA whenever I refer to this variable x <sil=0.343> ,COMMA which is of type complex <sil=0.484> ,COMMA I will be referring to this structure and not neither at 4 or nor at 3 <sil=0.919> .PERIOD I will be looking at this whole thing <sil=0.954> .PERIOD So <sil=0.489> ,COMMA it helps us in organizing a complex data in a much more meaningful way <sil=0.938> .PERIOD The individual structure elements that I was talking of <sil=0.338> ,COMMA which is which I was mentioning as fields is also known as members <sil=0.999> .PERIOD Now <sil=0.444> ,COMMA you will find other names to structures also <sil=0.986> .PERIOD So <sil=0.596> ,COMMA structures are sometimes called records <sil=0.930> .PERIOD And each of these horizontal boxes that we are drawing <sil=0.626> ,COMMA where fields of that record or in terms of when we refer to it as structure <sil=0.593> ,COMMA we call each of those smaller boxes as members of that structure <sil=0.976> .PERIOD So <sil=0.631> ,COMMA the composition of a structure can be defined as follows <sil=0.935> .PERIOD Say a structure <sil=0.445> ,COMMA I can put a tag <sil=0.977> .PERIOD Now <sil=0.333> ,COMMA this is very important <sil=0.986> .PERIOD What is a tag that I am putting over here <sil=0.961> ?QUESTIONMARK Say for example <sil=0.498> ,COMMA earlier I was talking of student data <sil=0.968> .PERIOD So <sil=0.643> ,COMMA my tag could be stood data as I had written <sil=0.919> .PERIOD So <sil=0.330> ,COMMA I have to write struct stood data <sil=0.975> .PERIOD And inside that I have got several members <sil=0.911> .PERIOD And what were my members <sil=0.951> ?QUESTIONMARK My member was name <sil=0.919> .PERIOD My member was role number <sil=0.631> ,COMMA department <sil=0.402> ,COMMA role number and C G P A <sil=0.991> .PERIOD So <sil=0.302> ,COMMA I had four members of this <sil=0.984> .PERIOD Now <sil=0.406> ,COMMA each of these were of different types <sil=0.909> .PERIOD That is something which is very important to understand <sil=0.913> .PERIOD So <sil=0.484> ,COMMA struct is the required keyword <sil=0.910> .PERIOD I must write this word struct so that I can really show that it is what this tag is just the name is the name of the structure like stood data <sil=0.968> .PERIOD So <sil=0.390> ,COMMA that is a structure just as we had done for other variables <sil=0.986> .PERIOD We had done say int x float y etcetera <sil=0.992> .PERIOD So <sil=0.468> ,COMMA here also instead of int or float <sil=0.543> ,COMMA I have to say struct and what the struct is that is defined <sil=0.902> .PERIOD So <sil=0.346> ,COMMA first of all I have to define the structure <sil=0.984> .PERIOD Int and float are defined by default <sil=0.966> .PERIOD NEC compiler will understand what int or float is <sil=0.992> .PERIOD But if I write struct <sil=0.570> ,COMMA then by default the compiler will not understand what the structure is because there can be different structure <sil=0.906> .PERIOD One structure for student names <sil=0.554> ,COMMA one structure for book details <sil=0.998> .PERIOD If I had thought of book detail <sil=0.592> ,COMMA I want to store that in a structure <sil=0.968> .PERIOD What will the components be <sil=0.972> ?QUESTIONMARK What will the members be <sil=0.877> ?QUESTIONMARK Can we just think of <sil=0.974> ?QUESTIONMARK The members will be of course <sil=0.413> ,COMMA the title of the book <sil=0.502> ,COMMA the author of the book <sil=0.628> ,COMMA the publisher <sil=0.466> ,COMMA year of publication <sil=0.301> ,COMMA the ISBN number etcetera <sil=0.975> .PERIOD So <sil=0.509> ,COMMA therefore <sil=0.505> ,COMMA each of these members will again be of different types <sil=0.925> .PERIOD So <sil=0.426> ,COMMA it will be a heterogeneous organization just as it was with the student data <sil=0.957> .PERIOD So <sil=0.558> ,COMMA we have to write if I want to define books <sil=0.931> .PERIOD For example <sil=0.410> ,COMMA I would have to write struct book followed by the definition of the members <sil=0.976> .PERIOD So <sil=0.338> ,COMMA this is equivalent to as if I am drawing a structure and its name is becoming book and I am defining what are the members of this structure <sil=0.980> .PERIOD Let us move a little ahead <sil=0.911> .PERIOD So <sil=0.324> ,COMMA member 1 <sil=0.535> ,COMMA member 2 etcetera are individual member declarations <sil=0.982> .PERIOD We will see more examples of this <sil=0.949> .PERIOD The individual members can be of different types and that is the beauty of structure <sil=0.942> .PERIOD The individual members can be ordinarily variables <sil=0.459> ,COMMA pointers <sil=0.337> ,COMMA arrays or other structures <sil=0.995> .PERIOD It can even be other structure that is very important <sil=0.985> .PERIOD It can be some variable just as name or it can be an array <sil=0.906> .PERIOD So <sil=0.405> ,COMMA name was a character array or it can even be a structure that means I can have a structure within a structure <sil=0.916> .PERIOD So <sil=0.432> ,COMMA it is possible that I will have something like this that I have got a structure <sil=0.938> .PERIOD One field of the structure is a character array <sil=0.958> .PERIOD Another field of the structure can be an integer variable or another field of the structure can be a structure itself <sil=0.907> .PERIOD It can be another structure where there are more members inside <sil=0.963> .PERIOD That is also possible <sil=0.993> .PERIOD So <sil=0.323> ,COMMA that is the beauty and the flexibility that we get from structures <sil=0.964> .PERIOD So <sil=0.423> ,COMMA the member names within a particular structure must be distinct from one another <sil=0.928> .PERIOD We cannot put the same name to two different structures <sil=0.958> .PERIOD Once a structure has been defined <sil=0.398> ,COMMA individual structure type variables can be declared as struct tag variable one variable to variable name <sil=0.955> .PERIOD I think it will be much more clearer if we go through an example <sil=0.985> .PERIOD Let us look at this example <sil=0.972> .PERIOD A structure definition <sil=0.952> .PERIOD First I start with a structure definition <sil=0.963> .PERIOD Struct student and then I put just two parenthesis to show that there will be some members defined inside <sil=0.906> .PERIOD Now <sil=0.473> ,COMMA how do I define the members <sil=0.861> ?QUESTIONMARK I say that name one member is name which is an array of character <sil=1.000> .PERIOD The next one is role number which is an integer <sil=0.947> .PERIOD So <sil=0.647> ,COMMA role number is a variable <sil=0.977> .PERIOD As I said that a structure can be a variable or can be the array or can be another structure <sil=0.955> .PERIOD So <sil=0.585> ,COMMA here is an example where you have an array and a variable of type int <sil=0.945> .PERIOD Again <sil=0.462> ,COMMA total marks can be integer <sil=0.961> .PERIOD Data birth can be character and the sizes <sil=0.903> .PERIOD So <sil=0.584> ,COMMA data birth is again of type array character array because the data birth can be say 10 <sil=0.417> ,COMMA Jan <sil=0.465> ,COMMA etc <sil=0.966> .PERIOD 2010 <sil=0.921> .PERIOD So <sil=0.362> ,COMMA like that it can be a character array <sil=0.906> .PERIOD So <sil=0.564> ,COMMA how do we so this is however structure is defined <sil=0.984> .PERIOD Now <sil=0.366> ,COMMA I am now defining the variables <sil=0.965> .PERIOD I have defined the structures here <sil=0.965> .PERIOD So <sil=0.476> ,COMMA I know once the compiler reads this and finds that well I have got some character <sil=0.607> ,COMMA some definition of some variable called student <sil=0.925> .PERIOD I know that that is a structure and what is the constituent of that structure <sil=0.909> ?QUESTIONMARK This is these fields <sil=0.901> .PERIOD Now <sil=0.424> ,COMMA this is just a type just as we had int <sil=0.442> ,COMMA float <sil=0.580> ,COMMA etc <sil=0.911> .PERIOD or care <sil=0.935> .PERIOD Those were data types <sil=0.908> .PERIOD Now <sil=0.530> ,COMMA I am saying that I have got a structure of type this where there are four fields but the data has not been put <sil=0.947> .PERIOD This is very important though there are four fields <sil=0.988> .PERIOD One field is name and I say that is an array of 30 characters and there is a role number role which is an int <sil=0.931> .PERIOD Total marks is an integer and data birth is an array <sil=0.970> .PERIOD But you see that there is no data already put inside this array <sil=0.949> .PERIOD Now <sil=0.552> ,COMMA we have to name variables A1 <sil=0.397> ,COMMA A2 <sil=0.323> ,COMMA A3 are variables of type student structure and what is that student structure <sil=0.964> ?QUESTIONMARK This is a structure <sil=0.996> .PERIOD So <sil=0.524> ,COMMA A1 will just be a copy of this structure and A1 <sil=0.567> ,COMMA a variable A1 may have if I take this may have some name like Amit here <sil=0.980> .PERIOD Role number may be 560 and total may be 700 and data birth can be something <sil=0.973> .PERIOD That is one particular instance of this particular structure <sil=0.905> .PERIOD This particular structure that has been defined <sil=0.993> .PERIOD This part must be very clear to all of you <sil=0.972> .PERIOD So <sil=0.539> ,COMMA I have defined three variables <sil=0.584> ,COMMA A1 <sil=0.396> ,COMMA A2 and A3 each of type type what <sil=0.855> ?QUESTIONMARK Type structure student <sil=0.993> .PERIOD So <sil=0.432> ,COMMA type is struct student <sil=0.927> .PERIOD We have got these fields as its constituents <sil=0.948> .PERIOD So <sil=0.325> ,COMMA struct student tells us a new data type and these are the variables of the data type <sil=0.971> .PERIOD So <sil=0.527> ,COMMA it is also possible to write it in a much more compact form like struct tag and then <sil=0.928> .PERIOD So <sil=0.432> ,COMMA I write struct student and I declare care name 40 int role in total marks care <sil=0.585> ,COMMA data birth <sil=0.619> ,COMMA 10 <sil=0.412> .PERIOD And then I could have put the variable say 1 <sil=0.320> ,COMMA A2 <sil=0.427> ,COMMA A3 inside this note that here the semicolon is coming here that is the end of the definition <sil=0.905> .PERIOD So <sil=0.623> ,COMMA here I have done it in a much more compact form compared to the earlier one in this form of course <sil=0.498> ,COMMA this tag is optional <sil=0.948> .PERIOD So <sil=0.410> ,COMMA what I mean is say I define once again give an example to you say a complex number <sil=0.916> .PERIOD I can write it as struct complex and members are int need not be always integers <sil=0.938> .PERIOD So <sil=0.312> ,COMMA because if I want to store data of type say data of type 4 <sil=0.999> .PERIOD 5 plus i 7 <sil=0.973> .PERIOD 2 then I want to make float real float imaginary <sil=0.903> .PERIOD And that is the end of the structure and I can say struct complex x 1 comma x 2 this is one way of representing structure <sil=0.900> .PERIOD What does it mean <sil=0.910> ?QUESTIONMARK That I have first defined the structure called complex which will have these two components and then I define that x 1 and x 2 are two variables of type this complex or I could have written it also <sil=0.913> .PERIOD Now <sil=0.312> ,COMMA if I do it in this way I have got an advantage that later on I can also once I define it I can define some other variables also y 1 <sil=0.534> ,COMMA y 2 over here or I can also define it as struct float real part <sil=0.922> .PERIOD Let me in order to that you do not face confusion let us write real part float imaginary part and then I can say x 1 comma x 2 note that here I have not written the thing complex I have not written that I could have written it would not have affected me in any adverse way but it is not necessary to write it over here <sil=0.963> .PERIOD So <sil=0.373> ,COMMA if I write this how will the compiler always you should think what will the compiler looks at it what will it think what will it possibly do <sil=0.927> .PERIOD So <sil=0.319> ,COMMA the compiler is trying to understand okay now it is there is no ambiguity because it knows that x 1 and x 2 are two variables of type structure and the structure is defined here itself I need not given in name but the advantage of giving a name is say I give the name complex here here I have defined x 1 and x 2 later on also say for example if I have done in this way I could have later on down the line in this program I could have written struct complex say y 1 z 1 is possible because I have already defined struct complex okay <sil=0.972> .PERIOD So <sil=0.326> ,COMMA there is a choice over here which you can think of let us go ahead a little bit <sil=0.979> .PERIOD So <sil=0.371> ,COMMA in this case the tag is optional so here is an example will conclude this lecture with this example <sil=0.917> .PERIOD So <sil=0.457> ,COMMA struct student character name 30 in troll number in total marks character data birth 10 a 1 a 2 a 3 that means a 1 a 2 and a 3 are 3 students student information 3 pieces of student information or I could have done it in the way I have just now shown the same thing without giving any tag over here these are equivalent okay <sil=0.997> .PERIOD Now <sil=0.566> ,COMMA next lecture we will talk about how do you process a structure that will come in the next lecture <sil=0.910> .PERIOD In the earlier lectures <sil=0.332> ,COMMA we have looked at functions and we will still be looking at functions <sil=0.935> .PERIOD We have also looked at the library functions and just to recapitulate that whenever we are using some library functions in our program <sil=0.369> ,COMMA then we have to some mathematical library functions <sil=0.396> ,COMMA then we have to ashrineclude math <sil=0.905> .PERIOD h <sil=0.930> .PERIOD And while we link it <sil=0.393> ,COMMA while we compile it <sil=0.350> ,COMMA we will also have to link it with the math library with the option minus lm as you have seen <sil=0.966> .PERIOD Now today <sil=0.559> ,COMMA since now we have got an idea of what functions are <sil=0.635> ,COMMA let us have a relook at our old friends <sil=0.472> ,COMMA Scanef and Printf <sil=0.587> ,COMMA which we were using a number of times <sil=0.923> .PERIOD Now Scanef and Printf are nothing but functions <sil=0.930> .PERIOD These are also some library functions and those are included whenever we use include stti <sil=0.981> .PERIOD h <sil=0.993> .PERIOD Now you see Scanef and Printf being functions <sil=0.388> ,COMMA when we enter data <sil=0.400> ,COMMA let us look at this structure <sil=0.997> .PERIOD We write Scanef followed by some parameters <sil=0.975> .PERIOD We have also seen that a function is a function is nothing but something like f <sil=0.414> ,COMMA say function name followed by some parameters <sil=0.987> .PERIOD Here this Scanef is that function name and the parameters are the control string <sil=0.913> .PERIOD That means say for Scanef you have got something like percentage d and then x <sil=0.930> .PERIOD This is the control string and these are the arguments <sil=0.994> .PERIOD Both of these are arguments to the function Scanef <sil=0.992> .PERIOD Scanef is nothing but a function <sil=0.922> .PERIOD Whenever in my program <sil=0.575> ,COMMA suppose I am writing a program and here I use Scanef with some parameters like this <sil=0.500> ,COMMA then it is nothing but a call to a system function which actually does the task of reading the data from the input device <sil=0.993> .PERIOD So a control string refers to typically the data types of the arguments <sil=0.944> .PERIOD They have seen percentage d <sil=0.611> ,COMMA percentage f etcetera and the arguments are pointers to data items in memory <sil=0.981> .PERIOD These arguments in Scanef are what are the typical arguments in Scanef <sil=0.949> ?QUESTIONMARK They are say whenever I use Scanef say percentage d <sil=0.304> ,COMMA then and d or something like that <sil=0.955> .PERIOD So this AND is nothing but an address of the variable A <sil=0.932> .PERIOD So in my memory wherever the variable A is <sil=0.583> ,COMMA the variable A <sil=0.341> ,COMMA the compiler has allocated this memory location for the variable A and I am passing the address of that <sil=0.983> .PERIOD So that means it is a pointer pointing to some address or a pointer that is pointing to this particular location in the case of Scanef <sil=0.963> .PERIOD So that is why it is said that the arguments <sil=0.487> ,COMMA these arguments are one or two again are representing nothing but pointers to data items in the memory <sil=0.986> .PERIOD So the typical example is say percentage d <sil=0.467> ,COMMA percentage f <sil=0.316> ,COMMA percentage c which is nothing but the control string it is designating that AND A is an integer and AND is a pointer to A and average is a floating point number and AND average is a pointer to average <sil=0.986> .PERIOD And type is a character type variable and AND type is why is type a character type variable because I have put in here and C since I have put in here and C that tells me that this type is a character type variable and AND type and type is a pointer to the variable type <sil=0.911> .PERIOD The control string consists of individual groups of characters with one character group for each input data item <sil=0.901> .PERIOD So this is one character group for this set item <sil=1.000> .PERIOD So percentage we have seen that percentage sign means it is a conversion character <sil=0.901> .PERIOD Now commonly used conversion characters we have already seen some of them <sil=0.450> ,COMMA these are known to us percentage d is for decimal or integers <sil=0.447> ,COMMA percentage f of floating point numbers <sil=0.551> ,COMMA percentage c for single character <sil=0.566> ,COMMA percentage s is a string whenever I am reading something variable as a string we have discussed that <sil=0.983> .PERIOD In that case we are reading that string using percentage s and that is a string is always terminated by null character <sil=0.997> .PERIOD Similarly percentage x denotes that the number that I am reading is a hexadecimal character hexadecimal means decimal is with a base 10 that means 0 to 9 are my elements <sil=0.930> .PERIOD So all the numbers I am describing using 0 to 9 that is my alphabet set whereas in the case of hexadecimal the base is 16 and so a base being 16 I have got 0 <sil=0.601> ,COMMA 1 <sil=0.535> ,COMMA 2 <sil=0.368> ,COMMA 3 <sil=0.511> ,COMMA 4 <sil=0.383> ,COMMA 5 <sil=0.372> ,COMMA 6 <sil=0.343> ,COMMA 7 <sil=0.406> ,COMMA 8 <sil=0.502> ,COMMA 9 these 10 numbers followed by a for the base 10 <sil=0.947> .PERIOD So this is the base 10 <sil=0.956> .PERIOD So this is the for 10 b for 11 c 12 d 13 e 14 and f 15 <sil=0.952> .PERIOD So up to that 0 to 15 I can have so in a 16 when I work with a base 16 and that is null and as hexadecimal <sil=0.946> .PERIOD So you can just establishing a similarity analogy with our binary number system that we have seen we can have say a number a b <sil=0.990> .PERIOD Now a b is a string <sil=0.973> .PERIOD So the position string is a position weights are first position is 16 to the power 0 second position is 16 to the power can have say a number A B <sil=0.920> .PERIOD Now <sil=0.344> ,COMMA A B is a string <sil=0.945> .PERIOD So <sil=0.318> ,COMMA the position string a position weights are first position is 16 to the power 0 <sil=0.308> ,COMMA second position is 16 to the power 1 <sil=0.642> ,COMMA third position is 16 to the power 2 like that <sil=0.991> .PERIOD In the case of binary we had the first position weight was 2 to the power 0 <sil=0.578> ,COMMA 2 to the power 1 <sil=0.509> ,COMMA 2 to the power 2 like that <sil=0.973> .PERIOD Now <sil=0.408> ,COMMA and each of these positions can be filled up in the case of binary by 0 and 1 <sil=0.640> ,COMMA but here in the case of hexadecimal it can be filled up with any of the 0 to A <sil=0.598> ,COMMA 0 to F <sil=0.999> .PERIOD So <sil=0.635> ,COMMA A B when I say that means B is what in decimal B is 11 12 <sil=0.941> .PERIOD So <sil=0.424> ,COMMA 12 times what is the weight of this position 16 to the power 0 plus A is 11 <sil=0.960> .PERIOD Sorry <sil=0.340> ,COMMA sorry <sil=0.479> ,COMMA sorry <sil=0.521> ,COMMA sorry <sil=0.370> ,COMMA I am sorry <sil=0.598> ,COMMA this is 10 <sil=0.321> ,COMMA 10 <sil=0.442> ,COMMA sorry <sil=0.473> ,COMMA let me correct that A is 10 and B is 11 <sil=0.999> .PERIOD So <sil=0.560> ,COMMA it is 11 into 16 to the power 0 and 10 times 16 to the power 1 <sil=0.918> .PERIOD So <sil=0.559> ,COMMA how much is that coming to 160 plus 11 <sil=0.915> .PERIOD So <sil=0.432> ,COMMA that is the number 171 now <sil=0.563> ,COMMA if I had to represent 171 in binary I would have required much more number of bits <sil=0.990> .PERIOD And since it is hexadecimal another <sil=0.622> ,COMMA so here we using hexadecimal I am being able to do that using two hexadecimal bits which we can call exits <sil=0.444> ,COMMA but let us see A B <sil=0.571> ,COMMA A being 10 and B being 11 in binary what would that B B is 11 that means 8 to 1 this is 11 and 10 is 8 to that is all <sil=0.922> .PERIOD So <sil=0.500> ,COMMA I would have required 4 bits for representing 171 which I am representing using two hexates <sil=0.960> .PERIOD So <sil=0.328> ,COMMA that is a hexadecimal integer <sil=0.923> .PERIOD So <sil=0.430> ,COMMA if I print something in hex in this format then it will be printed like 171 will be printed as A B <sil=0.480> ,COMMA otherwise it will be printed as in the binary number or in the decimal number if I do it with percentage it will be printed like this <sil=0.921> .PERIOD So <sil=0.459> ,COMMA it was a brief introduction to hexadecimal numbers <sil=0.523> ,COMMA but that you can read up yourself <sil=0.988> .PERIOD So <sil=0.613> ,COMMA let us proceed <sil=0.914> .PERIOD We can also specify the maximum field width of a data item <sil=1.000> .PERIOD Now <sil=0.346> ,COMMA this is something I had purposefully evaded till now just to not to make the things complicated I want that you first get accustomed to the normal features of C <sil=0.953> .PERIOD Now <sil=0.558> ,COMMA but now we are now I think you have you are in a position where you can write programs here I am introducing the notion of field width <sil=0.966> .PERIOD A data will be printed within a width <sil=0.929> .PERIOD So <sil=0.464> ,COMMA many positions will be given to that number data item the number indicating the field width before the conversion character <sil=0.955> .PERIOD For example <sil=0.322> ,COMMA let us make it clear <sil=0.960> .PERIOD For example <sil=0.570> ,COMMA percentage 3 D percentage 5 D for A and B that means <sil=0.443> ,COMMA A will be expected to be of 3 positions say it is 3 D decimal 171 whereas <sil=0.527> ,COMMA B will be 5 D <sil=0.963> .PERIOD So <sil=0.353> ,COMMA there will be 5 positions for this 1 2 3 4 5 <sil=0.954> .PERIOD So <sil=0.381> ,COMMA may be 5 127 be 5D <sil=0.365> ,COMMA so there will be 5 positions for this <sil=0.913> .PERIOD So <sil=0.413> ,COMMA maybe 52732 <sil=0.947> .PERIOD Now <sil=0.552> ,COMMA if I want to print 171 or D in 171 using the format 5D <sil=0.540> ,COMMA then what should I print <sil=0.860> ?QUESTIONMARK I should print <sil=0.356> ,COMMA sorry <sil=0.461> ,COMMA I should provide the data for the 5 fields <sil=0.532> ,COMMA I should put it blank blank or 00 <sil=0.622> ,COMMA then 171 <sil=0.510> ,COMMA assuming it is right justified <sil=0.996> .PERIOD So <sil=0.358> ,COMMA this is the width <sil=0.425> ,COMMA this is the width that we are talking about <sil=0.434> ,COMMA we can specify how many <sil=0.558> ,COMMA what is the when I am reading <sil=0.360> ,COMMA what is the format of the data <sil=0.322> ,COMMA how many width <sil=0.448> ,COMMA how many positions it is taking as the data <sil=0.994> .PERIOD So <sil=0.588> ,COMMA say for example <sil=0.357> ,COMMA if I have 171 <sil=0.307> ,COMMA 532 <sil=0.523> ,COMMA then 7 <sil=0.390> ,COMMA then if I read it <sil=0.572> ,COMMA the first data field is this <sil=0.398> ,COMMA I type through the keyboard and if it is in percentage 3D <sil=0.434> ,COMMA it will be fine <sil=0.978> .PERIOD So <sil=0.529> ,COMMA I will read that <sil=0.989> .PERIOD Again <sil=0.387> ,COMMA now coming to writing <sil=0.457> ,COMMA now this printf is also a system function <sil=0.407> ,COMMA just like scanf <sil=0.545> ,COMMA printf is also a system function and here also since you know already how do you write printf <sil=0.389> ,COMMA I write printf using a control string within the double code and then followed by this number of arguments <sil=0.976> .PERIOD So <sil=0.579> ,COMMA the same thing will hold here <sil=0.640> ,COMMA control string refers to the string containing formatting information and data types of the arguments to be output <sil=0.989> .PERIOD So <sil=0.321> ,COMMA now here <sil=0.476> ,COMMA while printing the arg1 <sil=0.315> ,COMMA arg2 <sil=0.470> ,COMMA these are the representing the individual data items <sil=0.919> .PERIOD In the case of scanf <sil=0.353> ,COMMA they were pointers to their data items <sil=0.949> .PERIOD Here <sil=0.575> ,COMMA they are individual data items that I have told you earlier <sil=0.632> ,COMMA that is why we use m pairs and a <sil=0.556> ,COMMA m pairs and b in this case of scanf <sil=0.525> ,COMMA but in the case of printf <sil=0.521> ,COMMA we just write a <sil=0.553> ,COMMA b because this a <sil=0.430> ,COMMA b are directly referring to the variables <sil=0.339> ,COMMA the data items <sil=0.999> .PERIOD The conversion characters are the same as scanf <sil=0.963> .PERIOD So <sil=0.436> ,COMMA let us look at some examples <sil=0.974> .PERIOD Printf <sil=0.474> ,COMMA the average of a and b is a <sil=0.581> ,COMMA bg and that a <sil=0.583> ,COMMA bg is percentage f <sil=0.377> ,COMMA you can see that <sil=0.329> ,COMMA so a <sil=0.451> ,COMMA bg is a float <sil=0.997> .PERIOD Now <sil=0.318> ,COMMA I could have also done this <sil=0.361> ,COMMA so this is nothing <sil=0.613> ,COMMA but just the control string <sil=0.984> .PERIOD Here <sil=0.600> ,COMMA you see <sil=0.303> ,COMMA I have said that 3d <sil=0.649> ,COMMA 3d <sil=0.303> ,COMMA 5d <sil=0.964> .PERIOD So <sil=0.607> ,COMMA a will be printed <sil=0.554> ,COMMA so when will be printed <sil=0.573> ,COMMA a will be printed <sil=0.475> .PERIOD There is no new line here <sil=0.492> ,COMMA you can see <sil=0.916> .PERIOD So <sil=0.422> ,COMMA a <sil=0.452> ,COMMA b and a times b plus 2 will be printed side by side <sil=0.957> .PERIOD So <sil=0.619> ,COMMA a will be printed on 3 fields <sil=0.381> ,COMMA like say <sil=0.602> ,COMMA 1 <sil=0.527> ,COMMA 7 <sil=0.373> ,COMMA 1 <sil=0.598> ,COMMA b will be printed on the same <sil=0.908> .PERIOD So <sil=0.398> ,COMMA this is the value of printed on 3 <sil=0.500> ,COMMA next 3 <sil=0.617> ,COMMA there is no space given <sil=0.918> .PERIOD So <sil=0.617> ,COMMA this will be 632 and the expression here <sil=0.475> ,COMMA a times b plus 2 will have 5 spaces <sil=0.509> ,COMMA 5 positions given <sil=0.997> .PERIOD Now <sil=0.458> ,COMMA obviously <sil=0.505> ,COMMA if my data for result for a was 1 <sil=0.487> ,COMMA 7 <sil=0.404> ,COMMA 1 <sil=0.531> ,COMMA 2 <sil=0.388> ,COMMA then only this much will be printed and the rest will be left out <sil=0.974> .PERIOD So <sil=0.465> ,COMMA here you see <sil=0.914> ,COMMA for the percentage f <sil=0.911> .PERIOD Now <sil=0.535> ,COMMA for this <sil=0.392> ,COMMA I think it is not very difficult to understand <sil=0.925> .PERIOD You can read them in any textbook <sil=0.996> .PERIOD It is clearly discussed in most of the textbook <sil=0.979> .PERIOD So <sil=0.642> ,COMMA I recommend you to go through these formats and as you practice <sil=0.609> ,COMMA you will keep that in order <sil=0.971> .PERIOD But <sil=0.580> ,COMMA just to tell you this <sil=0.499> ,COMMA sub-floating point number <sil=0.514> ,COMMA we will have 2 parts <sil=0.916> .PERIOD One is the integer part and other is the decimal part <sil=0.915> .PERIOD So <sil=0.483> ,COMMA suppose here <sil=0.319> ,COMMA when I say 7 <sil=0.956> .PERIOD 2 f <sil=0.614> ,COMMA x is a floating point number <sil=0.422> ,COMMA which is being printed in the format 7 <sil=0.934> .PERIOD 2 f <sil=0.326> .PERIOD So <sil=0.601> ,COMMA this entire width is 7 positions and the 2 positions here are kept for the decimal <sil=0.937> .PERIOD So <sil=0.460> ,COMMA these 2 are kept for the decimal and we imagine we will have a decimal point here and the rest 5 will be 5 will be for the integer part <sil=0.938> .PERIOD For y <sil=0.537> ,COMMA what will happen <sil=0.946> ?QUESTIONMARK For y <sil=0.352> ,COMMA the total field is 5 out of which <sil=0.361> ,COMMA so total field is 5 out of which only 1 position is kept after the fraction <sil=0.999> .PERIOD So <sil=0.469> ,COMMA here I assume this point and so there are 4 positions to represent an integer and 1 position to represent a fraction <sil=0.942> .PERIOD So <sil=0.410> ,COMMA if my result was 101 <sil=0.944> .PERIOD 52 in this field <sil=0.391> ,COMMA in this format <sil=0.329> ,COMMA if I print that <sil=0.615> ,COMMA then I will get 0101 or this 0 can be may not be printed <sil=0.926> .PERIOD So <sil=0.407> ,COMMA 101 <sil=0.934> .PERIOD 5 because I did not have the space for this <sil=0.980> .PERIOD Many more options are available <sil=0.323> ,COMMA you can read from the book and we will do this later <sil=0.910> .PERIOD Now <sil=0.310> ,COMMA coming to a very important concept <sil=0.393> ,COMMA that is function prototypes <sil=0.927> .PERIOD This is possibly a new name that you are getting <sil=0.604> ,COMMA what are this prototypes <sil=0.963> ?QUESTIONMARK Now <sil=0.521> ,COMMA we are going to write functions and those functions <sil=0.636> ,COMMA one of the functions which must be there is the main function <sil=0.991> .PERIOD Typically <sil=0.485> ,COMMA people write first the main function and then the first the functions and then the main function <sil=0.323> ,COMMA but you are free not to do that also <sil=0.928> .PERIOD So <sil=0.418> ,COMMA usually a function is defined before it is called <sil=0.933> .PERIOD So <sil=0.523> ,COMMA typically what we do is when our main our program starts <sil=0.537> ,COMMA so we start the program starts from here <sil=0.310> ,COMMA we define if we write a function with some parameters here and the body of the function is here and then we write say main and inside main I call f 1 this assigned to some variable x like that <sil=0.958> .PERIOD So <sil=0.648> ,COMMA this is the typically some what we do after I did this include stdi iu dot h <sil=0.439> ,COMMA I started with the function first that is one option <sil=0.962> .PERIOD Now <sil=0.509> ,COMMA but always that is not done <sil=0.950> .PERIOD So <sil=0.620> ,COMMA main in that case if I define the functions first the functions that I I am going to use I have thought about that I have designed them <sil=0.984> .PERIOD So <sil=0.321> ,COMMA first I write those functions and after that I write the main function in that case the main is the last function in the program <sil=0.919> .PERIOD So <sil=0.588> ,COMMA in that case the compiler <sil=0.449> ,COMMA so I have got my program here entire program here and I have defined the function f 1 here I have defined function f 2 here and when I write main here and in main I refer to f 1 f 2 whichever whenever is this required <sil=0.921> .PERIOD Now <sil=0.459> ,COMMA let us look at the compiler think of yourself to be the compiler <sil=0.995> .PERIOD Now <sil=0.328> ,COMMA if you had started compiling the main first and you would have come to f 1 and f 2 then you would wonder what is that f 1 and f 2 no variables are defined right you would have taken just like if you had written x in the main some function f 1 some function like f 1 a b right <sil=0.993> .PERIOD Then <sil=0.558> ,COMMA this f 1 is not recognized I mean you do not know about that here <sil=0.375> ,COMMA but if you write it before the compiler will actually start looking from the beginning of the page or beginning of the program he will understand a function has been defined here I understand that function <sil=0.964> .PERIOD So <sil=0.579> ,COMMA I know that and I know what this function does it compiles and f 2 also <sil=0.911> .PERIOD So <sil=0.337> ,COMMA when it comes to in this direction when it comes to the main and finds f 1 and f 2 it already knows that <sil=0.993> .PERIOD So <sil=0.645> ,COMMA there is no problem <sil=0.962> .PERIOD So <sil=0.508> ,COMMA easy for the compiler to identify the functions when it scans through the file this is the file right the whole thing is the file <sil=0.963> .PERIOD However <sil=0.617> ,COMMA always that is not done many programmers prefer a top down approach that I will first define main and then I will put the functions <sil=0.424> ,COMMA but then what will happen to the compiler the compiler if it starts with main it is starting from the beginning and if it encounters f 1 or f 2 in the body of the main function then it will get confused what is it just like if I had got a variable x being used and it is not defined there been error because I do not know what this x is what type it is right <sil=0.952> .PERIOD So <sil=0.475> ,COMMA I have to declared that beforehand <sil=0.987> .PERIOD Similarly <sil=0.516> ,COMMA for functions there must be some way to tell the compiler that is the function and for that function pro two types are used function pro types are used <sil=0.940> .PERIOD Let us look at this needed if the function comes later <sil=0.902> .PERIOD So <sil=0.310> ,COMMA function pro types let us look at this needed if the function comes later <sil=0.974> .PERIOD So <sil=0.530> ,COMMA function pro types let us look at are usually written at the beginning of the program ahead of any other functions including main say for example <sil=0.513> ,COMMA this is a prototype <sil=0.993> .PERIOD So <sil=0.394> ,COMMA this is a prototype int g c d int a int b <sil=0.913> .PERIOD So <sil=0.434> ,COMMA a and b are the parameters and g c d is a function of return type int <sil=0.918> .PERIOD So <sil=0.645> ,COMMA I know just by this prototype by this I know the basic parameters are the whatever is the body whatever is the body of g c d I know its interface I know its input output what is its input output there will be some a coming some parameter there two parameters internally they are named as a and b <sil=0.977> .PERIOD I also know that this is an integer and this is also an integer and I know that its name is g c d and I also know that its output is an integer <sil=0.923> .PERIOD Whatever is in between I am not bothered about right now this much I know <sil=0.994> .PERIOD So <sil=0.490> ,COMMA I will expect whenever g c d will come I will allocate two integer space for that and one return facility should be there <sil=0.912> .PERIOD Similarly <sil=0.542> ,COMMA let us look at the second one give 7 int number <sil=0.941> .PERIOD So <sil=0.562> ,COMMA the prototype tells that it is a function its name is d 7 you can guess d 7 means is testing the divisibility by 7 and there is one integer that being fed and that integers name is number and void is a type that means it is not returning anything maybe it is printing something from here it just checks takes a number it sees whether it is divisible by 7 and prints it here divisible by 7 not divisible by 7 whatever you know how to find divisibility by 7 <sil=0.920> .PERIOD So <sil=0.629> ,COMMA you take the number and find the mod of that with 7 and if this is equal to 0 then divisible by 7 otherwise not <sil=0.940> .PERIOD So <sil=0.501> ,COMMA that is in the body of the function and here we just do the printing <sil=0.938> .PERIOD So <sil=0.300> ,COMMA I am not returning anything to the calling function that is why this is known as void void is a valid type <sil=0.993> .PERIOD Note the semicolon now here this is very important whenever for hash include a stdi <sil=0.966> .PERIOD io <sil=0.998> .PERIOD hti did not give a semicolon but whenever I am declaring a function a function prototype I have to give a semicolon just as I had given a semicolon when I declared something like int x semicolon <sil=0.988> .PERIOD Similarly <sil=0.558> ,COMMA here this semicolon is very important it is just like a declaration so the argument names can be different but it is you I mean it is a good practice to use the same names in the function now <sil=0.901> .PERIOD So <sil=0.524> ,COMMA what is being said here is that the argument although I am using here showing that a and b but when I am actually writing the function later say sorry when I am writing the function later when I write later on int gcd I can make it is a sorry I can write int gcd int x comma int y that is also possible because my prototype just said that two integer places now actually I can change the name change the name of the place but that is not that important I mean that is not I mean usually it is better if we can keep both of them <sil=0.944> .PERIOD So <sil=0.477> ,COMMA here is a function of int gcd int y and then it is a function of int x comma int y that is also possible because my prototype just say that two integer places now actually I can change the name change the name of the place but that is not that important I mean that is not I mean usually it is better if we can so here is a function prototype example I will continue with this in the next lecture I will discuss this and we will move to some other important important feature of function like parameter passing in the next lecture onwards <sil=0.932> .PERIOD In the last lecture <sil=0.374> ,COMMA we had an idea of what control structures are <sil=0.946> .PERIOD Control structures are some language structures by which we can change the flow of control which normally is sequential that means <sil=0.540> ,COMMA one executed after another <sil=0.928> .PERIOD Now <sil=0.539> ,COMMA in a language we just as we had statements <sil=0.516> ,COMMA arithmetic expressions <sil=0.325> ,COMMA logical expressions all those statements in our language <sil=0.439> ,COMMA C language you also have some control statements for achieving the control structures <sil=0.973> .PERIOD What they do as I have said allow different sets of instructions to be executed depending on the outcome of a logical test <sil=0.970> .PERIOD So <sil=0.352> ,COMMA if we go back to the flow chart <sil=0.623> ,COMMA we are coming in a sequential flow <sil=0.929> .PERIOD At this point <sil=0.530> ,COMMA we encounter decision point and at this decision point <sil=0.479> ,COMMA we carry out some logical test <sil=0.923> .PERIOD For example <sil=0.361> ,COMMA is x greater than 0 <sil=0.946> ?QUESTIONMARK Yes or no <sil=0.895> ?QUESTIONMARK If it be yes <sil=0.557> ,COMMA there will be some flow and if it be no <sil=0.471> ,COMMA there will be some other flow <sil=1.000> .PERIOD Some other <sil=0.397> ,COMMA not necessarily backward <sil=0.469> ,COMMA it can go somewhere else etcetera <sil=0.933> .PERIOD So <sil=0.385> ,COMMA based on a logical test that means <sil=0.406> ,COMMA this test which will result in a logical value and what are the logical values <sil=0.952> ?QUESTIONMARK Logical values are either 0 or 1 either true or false <sil=0.906> .PERIOD So <sil=0.420> ,COMMA whether true or false <sil=0.591> ,COMMA this is called branching <sil=0.930> .PERIOD So <sil=0.578> ,COMMA again whenever I am coming to a decision box and from there I am branching out either in this direction or in some other direction <sil=0.974> .PERIOD So <sil=0.586> ,COMMA this is a branching branch point <sil=0.982> .PERIOD So <sil=0.583> ,COMMA that is the change of the control flow <sil=0.987> .PERIOD Some applications may also require that a set of instructions be executed repeatedly <sil=0.936> .PERIOD They will be going on <sil=0.634> ,COMMA they will be executing as in the case of reading the numbers <sil=0.399> ,COMMA three numbers <sil=0.970> .PERIOD I will be repeating reading a number adding that with some decrementing count <sil=0.636> ,COMMA checking whether count is equal to 0 and then again go back and read the number and this flow will continue <sil=0.924> .PERIOD Based on some condition <sil=0.342> ,COMMA how long <sil=0.988> ?QUESTIONMARK In the earlier example <sil=0.438> ,COMMA how long are we doing that based on what condition <sil=0.868> ?QUESTIONMARK The condition was whether the count is 0 or not <sil=0.936> .PERIOD As long as the count is not 0 <sil=0.620> ,COMMA we are going on doing this <sil=0.916> .PERIOD So <sil=0.487> ,COMMA this is also known as looping <sil=0.448> ,COMMA doing the thing repeatedly <sil=0.566> ,COMMA this is also known as looping <sil=0.422> .PERIOD So <sil=0.365> ,COMMA branching or if we go back to the earlier one <sil=0.560> ,COMMA then it is called a loop <sil=0.986> .PERIOD Now <sil=0.313> ,COMMA how do we specify the conditions <sil=0.958> ?QUESTIONMARK By now I am sure you have guessed how we do that <sil=0.972> .PERIOD We specify the conditions using relational operators or there are four relational operators we have seen less than equal to greater than greater than equal to <sil=0.988> .PERIOD I had said not equal to also <sil=0.503> ,COMMA but not equal to can also be seen as the negation of the equality operator <sil=0.934> .PERIOD The equality operator is this double equal to sign and not equal to its exclamation mark followed by equal to <sil=0.963> .PERIOD Now <sil=0.328> ,COMMA so using this relational operators <sil=0.489> ,COMMA we will get using one single any of these <sil=0.931> .PERIOD One single relational operator will get one logical expression <sil=0.529> ,COMMA one logical expression <sil=0.922> .PERIOD And using logical operators and connectives <sil=0.309> ,COMMA we will be able to connect a number of logical operations <sil=0.486> ,COMMA logical expressions and another logical expression <sil=0.962> .PERIOD In that way <sil=0.504> ,COMMA we can carry out <sil=0.444> ,COMMA we can generate the condition using this <sil=0.939> .PERIOD Now <sil=0.426> ,COMMA two logical operators we have seen and and or <sil=0.908> .PERIOD Another unary negation operator we did not discuss earlier <sil=0.646> ,COMMA but we are doing it now that is this means not <sil=0.946> .PERIOD All right <sil=0.988> .PERIOD For example <sil=0.516> ,COMMA suppose x is 5 and at some point I compute x greater than 5 <sil=0.575> ,COMMA the result of this logical expression will be false <sil=0.906> .PERIOD This is false <sil=0.947> .PERIOD But if I take the negative of this <sil=0.497> ,COMMA then this false will be negated and the negation of that will be taken <sil=0.906> .PERIOD So <sil=0.461> ,COMMA that will be 1 <sil=0.385> ,COMMA 2 <sil=0.396> .PERIOD That means <sil=0.566> ,COMMA what is the meaning of this <sil=0.926> ?QUESTIONMARK Is it the case <sil=0.919> ?QUESTIONMARK I can read it in this way <sil=0.965> .PERIOD Is it the case that x is x is greater than 5 is false <sil=0.898> ?QUESTIONMARK Is not true <sil=0.953> ?QUESTIONMARK Yes <sil=0.328> ,COMMA that statement is true <sil=0.993> .PERIOD I can state it in another way <sil=0.987> .PERIOD Is it the case that x is not greater than 5 <sil=0.869> ?QUESTIONMARK Yes <sil=0.368> ,COMMA that is the case <sil=0.939> .PERIOD Again <sil=0.446> ,COMMA I tell the first one that is more complicated <sil=0.901> .PERIOD Is it the case that the statement x greater than 5 is not true <sil=0.899> ?QUESTIONMARK That statement is true <sil=0.987> .PERIOD That it is not true is true <sil=0.960> .PERIOD So <sil=0.339> ,COMMA that is not means whatever logical expression I have after this that will be negated <sil=0.958> .PERIOD So <sil=0.374> ,COMMA it is equivalent to not of the logical expression <sil=0.944> .PERIOD So <sil=0.576> ,COMMA if this logical expression <sil=0.490> ,COMMA if this logical expression leads to this logical expression only is 1 <sil=0.393> ,COMMA then not of that will invert it and make it 0 <sil=0.973> .PERIOD Or if this logical expression was 0 <sil=0.398> ,COMMA then this not of this will make it 1 <sil=0.985> .PERIOD So <sil=0.484> ,COMMA this is the unary negation operation <sil=0.985> .PERIOD Let us say some examples count less than equal to 0 <sil=0.977> .PERIOD This is a logical expression <sil=0.633> ,COMMA it will be either true or false <sil=0.998> .PERIOD Maths plus physics that means here <sil=0.314> ,COMMA math is the marks obtained by a student in math plus physics <sil=0.571> ,COMMA class chemistry divided by 3 is greater than equal to 60 <sil=0.986> .PERIOD That means the average of these 3 marks is greater than equal to 60 <sil=0.930> .PERIOD Either the person <sil=0.353> ,COMMA the sex of that person is male <sil=0.306> ,COMMA sorry and let us look at this <sil=0.916> .PERIOD It is an using a logical connective <sil=0.325> ,COMMA the person this will be true <sil=0.912> .PERIOD If the person is a male and his age is greater than or equal to 21 <sil=0.996> .PERIOD So <sil=0.345> ,COMMA for a female of age 22 <sil=0.451> ,COMMA this will be false <sil=0.918> .PERIOD For a male age 20 <sil=0.644> ,COMMA it will be false <sil=0.996> .PERIOD A male age 25 <sil=0.503> ,COMMA it will be true <sil=0.981> .PERIOD Here again another one with this connective <sil=0.648> ,COMMA marks is greater than 80 and marks is less than 90 <sil=0.934> .PERIOD A sorry marks is greater than equal to 80 and marks is less than 90 <sil=0.950> .PERIOD That means what <sil=0.989> ?QUESTIONMARK Anything starting from 80 to 89 <sil=0.526> ,COMMA if the marks is between this <sil=0.609> ,COMMA then this will be true <sil=0.918> .PERIOD Another one with an OR operator <sil=0.475> ,COMMA balance is greater than 5000 or the number of transactions is greater than 25 <sil=0.956> .PERIOD So <sil=0.455> ,COMMA in a bank situation for example <sil=0.592> ,COMMA you are making a lot of transactions <sil=0.940> .PERIOD What is a transaction <sil=0.929> ?QUESTIONMARK When you deposit a money <sil=0.611> ,COMMA that is a transaction <sil=0.950> .PERIOD When you withdraw money <sil=0.573> ,COMMA that is also a transaction <sil=0.940> .PERIOD So <sil=0.528> ,COMMA they are different transactions <sil=0.956> .PERIOD So <sil=0.499> ,COMMA what we are saying here <sil=0.502> ,COMMA either I have got 5000 rupees <sil=0.504> ,COMMA greater than <sil=0.595> ,COMMA sorry <sil=0.311> ,COMMA greater than 5000 rupees in my balance or I have done more than 25 transactions <sil=0.904> .PERIOD If any on of them true <sil=0.416> ,COMMA suppose you have got 6000 rupees in a balance and number of transactions is 26 <sil=0.611> ,COMMA then also this is true <sil=0.997> .PERIOD If the balance is 6000 and number of transactions you have done is only 20 <sil=0.328> ,COMMA then also it is true <sil=0.951> .PERIOD We have already explained the role of OR operator earlier <sil=0.925> .PERIOD Now <sil=0.550> ,COMMA this <sil=0.529> ,COMMA if the grade of the student is A <sil=0.393> ,COMMA if a student has got grade A <sil=0.636> ,COMMA what will be the value of this logical expression <sil=0.399> ,COMMA true or false <sil=0.925> ?QUESTIONMARK If the student has actually got the A grade <sil=0.319> ,COMMA all right <sil=0.907> .PERIOD So <sil=0.532> ,COMMA this one <sil=0.445> ,COMMA this part will be true <sil=0.633> ,COMMA but my actual logical expression is this one <sil=0.470> ,COMMA which is the negation of that <sil=0.969> .PERIOD So <sil=0.336> ,COMMA it will be false <sil=0.993> .PERIOD Because the person has got grade A <sil=0.337> ,COMMA what does it mean <sil=0.872> ?QUESTIONMARK It means that is it the case that the student has not got grade A <sil=0.339> ,COMMA okay <sil=0.914> .PERIOD Here is another little more complicated <sil=0.412> ,COMMA X greater than 20 and Y less than 16 <sil=0.901> .PERIOD Now <sil=0.370> ,COMMA the way we should evaluate this is <sil=0.598> ,COMMA I will evaluate each of them separately <sil=0.975> .PERIOD Suppose X is greater than 20 <sil=0.472> ,COMMA suppose 21 <sil=0.965> .PERIOD So <sil=0.555> ,COMMA this is true and Y is 15 <sil=0.949> .PERIOD So <sil=0.467> ,COMMA this is true <sil=0.952> .PERIOD So <sil=0.317> ,COMMA both these together is true <sil=0.992> .PERIOD Then I take this one with this and so the result will become false <sil=0.371> ,COMMA okay <sil=0.955> .PERIOD Let me clear it again <sil=0.996> .PERIOD Suppose X is 21 <sil=0.981> .PERIOD So <sil=0.497> ,COMMA this part is true <sil=0.941> .PERIOD Then I compute this <sil=0.642> ,COMMA Y is 17 <sil=0.953> .PERIOD This part is false <sil=0.972> .PERIOD Therefore <sil=0.545> ,COMMA these two are connected by this amperes and that means logic is or not <sil=0.303> ,COMMA I am sorry <sil=0.588> ,COMMA very sorry <sil=0.984> .PERIOD It should <sil=0.371> ,COMMA it is not amperes and double ends that means and operator by logical end <sil=0.994> .PERIOD So <sil=0.527> ,COMMA these two will result in through the logical end <sil=0.459> ,COMMA it will result in 0 <sil=0.923> .PERIOD But my actual expression is a negation of that <sil=0.980> .PERIOD So <sil=0.348> ,COMMA the result will be 1 <sil=0.583> ,COMMA okay <sil=0.983> .PERIOD Clear <sil=0.900> ?QUESTIONMARK Okay <sil=0.933> .PERIOD So <sil=0.547> ,COMMA that is how we carry out <sil=0.469> ,COMMA these are the examples of evaluation of logical expressions and logical expressions <sil=0.965> .PERIOD So <sil=0.338> ,COMMA each of them <sil=0.634> ,COMMA each of these logical expressions can serve as a condition in our control structure <sil=0.436> ,COMMA in our this loop <sil=0.623> ,COMMA in our this diamond box <sil=0.486> ,COMMA decision box where we test or let us call it the test box <sil=0.422> ,COMMA in that any of these sort of logical expressions can recite <sil=0.952> .PERIOD And the result of that can be either 0 or non-zero <sil=0.513> ,COMMA false or true <sil=0.955> .PERIOD Okay <sil=0.438> .PERIOD Accordingly <sil=0.555> ,COMMA we will branch out in either this direction or in some other direction <sil=0.933> .PERIOD Okay <sil=0.470> .PERIOD So <sil=0.546> ,COMMA 0 indicates false and non-zero indicates true <sil=0.999> .PERIOD Typically <sil=0.401> ,COMMA the true is represented by the value 1 in most of the machines <sil=0.979> .PERIOD Okay <sil=0.484> .PERIOD This is something that we have already said <sil=0.372> ,COMMA the decision symbol in the flow chart indicates the decision to be made <sil=0.947> .PERIOD It contains an expression that can be true or false <sil=0.647> ,COMMA test the condition and follow the appropriate path <sil=0.989> .PERIOD That is how we will do <sil=0.997> .PERIOD It is a single entry <sil=0.443> ,COMMA single exit structure <sil=0.937> .PERIOD That means <sil=0.565> ,COMMA that means <sil=0.497> ,COMMA in this diamond box <sil=0.594> ,COMMA we will enter through any one point and we will exit from only one point either this or this simultaneously we cannot come out of this <sil=0.379> ,COMMA because the thing cannot be true or false at the same time <sil=0.908> .PERIOD Therefore <sil=0.629> ,COMMA any one exit will take <sil=0.987> .PERIOD The general syntax <sil=0.438> ,COMMA syntax means what <sil=0.925> ?QUESTIONMARK Syntax means the grammar <sil=0.620> ,COMMA the exact grammatical structure that we should write is if condition <sil=0.404> ,COMMA then I carry out some operations <sil=0.977> .PERIOD You have seen in an earlier lecture <sil=0.618> ,COMMA when we were comparing two numbers x and y and would be printing x is large <sil=0.583> ,COMMA if x is greater than y <sil=0.580> ,COMMA then what did we write <sil=0.987> ?QUESTIONMARK We wrote something like this <sil=0.962> .PERIOD We wrote if x is greater than equal to y <sil=0.301> ,COMMA print f <sil=0.525> ,COMMA what <sil=0.903> ?QUESTIONMARK We printed y <sil=0.477> ,COMMA x is greater than equal to y <sil=0.539> ,COMMA x is large or not in this form <sil=0.915> .PERIOD We wrote down that x is large here <sil=0.984> .PERIOD If this condition is true <sil=0.434> ,COMMA then I will be doing this print operation <sil=0.926> .PERIOD x is large <sil=0.592> ,COMMA then backslash n <sil=0.469> ,COMMA I am not being able to write very clearly here <sil=0.999> .PERIOD I try again <sil=0.921> .PERIOD If x is greater than y or greater than equal to y <sil=0.597> ,COMMA this is the condition <sil=0.965> .PERIOD You see this f <sil=0.593> ,COMMA this is a reserve doer in c <sil=0.416> ,COMMA then the condition <sil=0.986> .PERIOD If the condition is true <sil=0.506> ,COMMA then this is followed by a statement <sil=0.985> .PERIOD Now <sil=0.607> ,COMMA if it be a single statement <sil=0.580> ,COMMA I do not need to give this curly bracket <sil=0.316> ,COMMA but just I am giving it just to keep the parity <sil=0.909> .PERIOD Here <sil=0.420> ,COMMA I write print f <sil=0.416> ,COMMA x is large <sil=0.366> ,COMMA then backslash n <sil=0.639> ,COMMA and we end this statement <sil=0.915> .PERIOD If this condition is true <sil=0.628> ,COMMA then this statement will be executed <sil=0.927> .PERIOD That is my syntax <sil=0.968> .PERIOD Otherwise <sil=0.409> ,COMMA some other statement will be executed <sil=0.940> .PERIOD This is something which takes some time to settle down <sil=0.944> .PERIOD We will explain it repeatedly to some extent <sil=0.946> .PERIOD If there is a single statement in the block <sil=0.306> ,COMMA this braces can be omitted <sil=0.930> .PERIOD I am sorry <sil=0.968> ,COMMA this braces can be omitted <sil=0.976> .PERIOD Now <sil=0.310> ,COMMA let us come to this structure <sil=0.976> .PERIOD If statement <sil=0.318> ,COMMA first of all <sil=0.525> ,COMMA we are looking at the first and very important control statement in c <sil=0.328> ,COMMA that is the if statement <sil=0.966> .PERIOD If some condition <sil=0.943> .PERIOD So <sil=0.509> ,COMMA we come here <sil=0.941> .PERIOD The structure is <sil=0.494> ,COMMA we carry out some test on some condition <sil=0.997> .PERIOD Grade is greater than equal to 60 <sil=0.926> .PERIOD If it is true <sil=0.315> ,COMMA then we do something <sil=0.971> .PERIOD Here <sil=0.421> ,COMMA I print past <sil=0.443> ,COMMA otherwise <sil=0.514> ,COMMA I write something else <sil=0.951> .PERIOD So <sil=0.532> ,COMMA this is a selection structure <sil=0.965> .PERIOD What is it selecting <sil=0.895> ?QUESTIONMARK It is selecting which path should I go <sil=0.895> ?QUESTIONMARK Now <sil=0.420> ,COMMA you see here <sil=0.525> ,COMMA we have come <sil=0.451> ,COMMA we were coming through this path <sil=0.916> .PERIOD If this here <sil=0.443> ,COMMA I carried out a test <sil=0.948> .PERIOD If this test is true <sil=0.436> ,COMMA I do this <sil=0.911> ,COMMA do this <sil=0.525> ,COMMA execute this statement and come back and continue <sil=0.906> .PERIOD Not come back <sil=0.380> ,COMMA I will come and then continue this path <sil=0.981> .PERIOD If this statement is not true <sil=0.340> ,COMMA that means <sil=0.524> ,COMMA if this test fails <sil=0.361> ,COMMA then I will not take this <sil=0.476> ,COMMA I will not select this path <sil=0.539> ,COMMA I will continue in the path in which I was going <sil=0.965> .PERIOD So <sil=0.625> ,COMMA that is why this is often known as a selection structure <sil=0.968> .PERIOD So <sil=0.632> ,COMMA our decision can be made on any expression <sil=0.931> .PERIOD Here <sil=0.349> ,COMMA you see <sil=0.514> ,COMMA only thing that we are trying to do is test whether some condition is true or false <sil=0.976> .PERIOD Now <sil=0.585> ,COMMA if the result of an expression is 0 <sil=0.530> ,COMMA then we take it to be false <sil=0.973> .PERIOD And if it be non-zero <sil=0.339> ,COMMA then we will take it to be true <sil=0.978> .PERIOD If I evaluate something to be true <sil=0.319> ,COMMA like say for example <sil=0.374> ,COMMA if x was 5 and I carry out <sil=0.431> ,COMMA x is x equal to 5 <sil=0.541> ,COMMA this logical expression will evaluate to true <sil=0.922> .PERIOD That means <sil=0.555> ,COMMA 1 <sil=0.310> .PERIOD That means <sil=0.349> ,COMMA it is non-zero <sil=0.918> .PERIOD If I had written x less than 5 <sil=0.452> ,COMMA then it will have resulted in false <sil=0.416> ,COMMA it will be 0 <sil=0.989> .PERIOD Now <sil=0.403> ,COMMA suppose I simply do something different <sil=0.951> .PERIOD I write in this decision box <sil=0.436> ,COMMA I am coming like this and inside the decision box <sil=0.424> ,COMMA I write and x was 6 <sil=0.937> .PERIOD Say <sil=0.500> ,COMMA I do not write a logical expression here <sil=0.955> .PERIOD I write an arithmetic expression <sil=0.342> ,COMMA x or that means <sil=0.626> ,COMMA x was 5 <sil=0.982> .PERIOD I carry out some expression <sil=0.365> ,COMMA x plus 5 <sil=0.992> .PERIOD What will the result of this expression be <sil=0.967> ?QUESTIONMARK It will be 10 <sil=0.554> ,COMMA that is it is non-zero <sil=0.502> ,COMMA then also it will be taken as true <sil=0.995> .PERIOD Although we do not need it all the time <sil=0.485> ,COMMA you need not bother about it <sil=0.972> .PERIOD But in general <sil=0.597> ,COMMA a decision can be made on any expression <sil=0.648> ,COMMA typically and most conveniently <sil=0.630> ,COMMA we will be using logical expressions <sil=0.973> .PERIOD But if I carry out an arithmetic expression <sil=0.370> ,COMMA something like A times B plus C minus D <sil=0.595> ,COMMA then also this will give me a value and this value <sil=0.596> ,COMMA if 0 means it is false and not 0 <sil=0.457> ,COMMA then it will be taken as true <sil=0.915> .PERIOD Non-zero will be taken as true <sil=0.917> .PERIOD However <sil=0.317> ,COMMA this is just a matter of detail <sil=0.909> .PERIOD You need not get too much bothered about it right now <sil=0.948> .PERIOD We will try to keep as much as possible <sil=0.562> ,COMMA relational expressions or logical expressions inside this test blocks <sil=0.904> .PERIOD So <sil=0.441> ,COMMA here if grade is greater than equal to 60 <sil=0.380> ,COMMA print pass 10 <sil=0.524> ,COMMA that means <sil=0.576> ,COMMA this is the equivalent of this structure that we have shown here <sil=0.950> .PERIOD This flow chart can be simply written as this statement <sil=0.995> .PERIOD I think call of you will be able to read it now <sil=0.987> .PERIOD If has been given in a different color because this is what we have introduced here <sil=0.597> ,COMMA this if is the use of if the selection structure followed by a condition <sil=0.964> .PERIOD If the condition is true <sil=0.401> ,COMMA then this statement will be executed <sil=0.942> .PERIOD If the condition is false <sil=0.645> ,COMMA then this statement will not be executed <sil=0.432> ,COMMA we will bypass this statement <sil=0.912> .PERIOD Now <sil=0.463> ,COMMA please remember this <sil=0.907> .PERIOD When I write if some condition <sil=0.578> ,COMMA some statements <sil=0.322> ,COMMA these statements will be executed <sil=0.485> ,COMMA only if this condition is true <sil=0.913> .PERIOD I write it in a different way now <sil=0.911> .PERIOD Say for example <sil=0.629> ,COMMA I have got a number of statements <sil=0.536> ,COMMA some statements are there and then here there is an if statement <sil=0.922> .PERIOD If condition <sil=0.504> ,COMMA then some statements here may be more than one statements are in a brace <sil=0.982> .PERIOD Now <sil=0.614> ,COMMA if the condition and after that there are other statements <sil=0.990> .PERIOD Now <sil=0.590> ,COMMA if the condition is true <sil=0.331> ,COMMA then only these statements will be executed <sil=0.969> .PERIOD Let us name this statements to be a <sil=0.591> ,COMMA then this block a will be executed <sil=0.965> .PERIOD This block will be executed <sil=0.950> .PERIOD If this condition is false <sil=0.314> ,COMMA then this block a will be bypassed and on false <sil=0.573> ,COMMA I will come here and come to say this block b <sil=0.915> .PERIOD If the condition is false <sil=0.477> ,COMMA then the block b will be executed <sil=0.969> .PERIOD If the condition is true <sil=0.447> ,COMMA then this block a will be executed <sil=0.924> .PERIOD Now <sil=0.576> ,COMMA suppose let me explain in a little different way <sil=0.957> .PERIOD I am drawing another diagram <sil=0.986> .PERIOD Now <sil=0.473> ,COMMA here is some block of statements <sil=0.919> .PERIOD Let us call the block of statements to be a <sil=0.902> .PERIOD Then I have one statement if condition <sil=0.454> ,COMMA whatever the condition is <sil=0.350> ,COMMA then within parenthesis <sil=0.550> ,COMMA there is a block of statements b <sil=0.939> .PERIOD Then there is a block of statements c <sil=0.979> .PERIOD The flow of the flow will be that first a will be executed <sil=0.999> .PERIOD Then if the condition is true <sil=0.360> ,COMMA then if the condition is true <sil=0.333> ,COMMA then b will be executed <sil=0.998> .PERIOD After that what will happen <sil=0.976> ?QUESTIONMARK After that again will come here and c will be executed <sil=0.989> .PERIOD Now <sil=0.404> ,COMMA if the condition was false <sil=0.627> ,COMMA I would have computed a <sil=0.976> .PERIOD After that what would have been computed <sil=0.885> ?QUESTIONMARK Condition would be checked <sil=0.962> .PERIOD b will not be evaluated <sil=0.627> ,COMMA not be executed because condition is false <sil=0.956> .PERIOD After that c will be executed <sil=0.956> .PERIOD So <sil=0.409> ,COMMA please note that in this structure <sil=0.448> ,COMMA I am executing c either way <sil=0.917> .PERIOD Now <sil=0.371> ,COMMA the choice of whether b is being done or not is dependent on the condition <sil=0.951> .PERIOD This gives you an idea of if the condition is false <sil=0.341> ,COMMA then also this part will be executed <sil=0.905> .PERIOD Here we will conclude today with this example <sil=0.450> ,COMMA small example program <sil=0.911> .PERIOD Let us try to understand each line of them <sil=1.000> .PERIOD We start with include stdiu <sil=0.989> .PERIOD h <sil=0.954> .PERIOD I hope you have not forgotten that any c program must have a main program <sil=0.603> ,COMMA main function and here is the main function <sil=0.940> .PERIOD Inside the body of the main function what is being done <sil=0.971> ?QUESTIONMARK I have declared what is being done here <sil=0.975> ?QUESTIONMARK I have declared three variables a <sil=0.385> ,COMMA b and c <sil=0.945> .PERIOD Then what am I doing here <sil=0.854> ?QUESTIONMARK Observe this line scan f percentage d percentage d percentage d and a and b and c <sil=0.922> .PERIOD So <sil=0.591> ,COMMA I am reading three variables a <sil=0.576> ,COMMA b <sil=0.324> ,COMMA c <sil=0.998> .PERIOD Now <sil=0.504> ,COMMA what am I doing here <sil=0.918> ?QUESTIONMARK I am evaluating and if condition <sil=0.951> ?QUESTIONMARK If a is greater than equal to b and a is greater than c <sil=0.932> .PERIOD So <sil=0.421> ,COMMA you understand that if a is a number b is a number c is a number a is greater than b and a is also greater than c <sil=0.946> .PERIOD That means <sil=0.398> ,COMMA a is the largest number <sil=0.922> .PERIOD So <sil=0.415> ,COMMA then I print this <sil=0.924> .PERIOD I print this only if this condition is true <sil=0.967> .PERIOD Otherwise <sil=0.594> ,COMMA I will do something else <sil=0.923> .PERIOD Now <sil=0.382> ,COMMA suppose a is greater than b <sil=0.937> .PERIOD Suppose a is 20 <sil=0.617> ,COMMA b is 10 and c is 5 <sil=0.938> .PERIOD So <sil=0.365> ,COMMA this one will be true <sil=0.959> .PERIOD Then the largest number is a that we printed <sil=0.992> .PERIOD Next statement will come to is another if statement <sil=0.927> .PERIOD What is being done here <sil=0.944> ?QUESTIONMARK If b is greater than equal to a and b is greater than equal to c <sil=0.370> ,COMMA b is not greater than equal to a <sil=0.997> .PERIOD Therefore <sil=0.546> ,COMMA this does not evaluate to be true <sil=0.954> .PERIOD Therefore <sil=0.498> ,COMMA this statement does not execute <sil=0.975> .PERIOD Next <sil=0.518> ,COMMA I come to this statement <sil=0.942> .PERIOD I am flowing this <sil=0.944> .PERIOD I am following this flow but only branch that I took is if this condition was true <sil=0.462> ,COMMA then I printed this in this particular case of data <sil=0.936> .PERIOD In this case of data for some other case it will be different <sil=0.903> .PERIOD Now <sil=0.647> ,COMMA if c is greater than a not true <sil=0.961> .PERIOD So <sil=0.385> ,COMMA this falls this will not be executed <sil=0.956> .PERIOD So <sil=0.460> ,COMMA the only thing that will be printed is the largest number is a <sil=0.968> .PERIOD Now <sil=0.641> ,COMMA if for example <sil=0.606> ,COMMA a was 10 b is equal to c was 20 and c was 5 <sil=0.926> .PERIOD Then what would have happened <sil=0.956> ?QUESTIONMARK Let us see here a is greater than equal to b <sil=0.915> .PERIOD I try to test this fail <sil=0.982> .PERIOD So <sil=0.442> ,COMMA this will not be executed <sil=0.981> .PERIOD So <sil=0.322> ,COMMA I come here and then I test this b is greater than a and b is greater than c <sil=0.925> .PERIOD That is also right <sil=0.917> .PERIOD So <sil=0.540> ,COMMA this condition passes <sil=0.943> .PERIOD Then I execute this <sil=0.992> .PERIOD I print larger number is b <sil=0.997> .PERIOD I print that and then I come to the next statement <sil=0.954> .PERIOD What happens in this statement <sil=0.906> ?QUESTIONMARK c is greater than equal to a no falls <sil=0.960> .PERIOD So <sil=0.561> ,COMMA the only thing that is printed is the largest number is b <sil=0.942> .PERIOD So <sil=0.631> ,COMMA we stop here <sil=0.992> .PERIOD We will continue our explanations in the next lecture <sil=0.967> .PERIOD Further we will need to discuss it and also try it a little bit more because from this point onwards our logical constructs are big stuff have started becoming just a little more complicated <sil=0.917> .PERIOD But is very interesting and it is very easy to understand if you just try to think about it logically <sil=0.974> .PERIOD Thank you very much <sil=0.949> .PERIOD So <sil=0.425> ,COMMA we are looking at arrays and we have seen that all the data items constituting the array shared the same name <sil=0.926> .PERIOD So <sil=0.338> ,COMMA we can call an array to be A and array A or an array num <sil=0.935> .PERIOD If the array be A <sil=0.315> ,COMMA then the elements are A 1 <sil=0.416> ,COMMA A 2 like that up to A n <sil=0.561> ,COMMA where n is the size of the array <sil=0.907> .PERIOD And each individual elements are being accessed by this indices <sil=0.908> .PERIOD These are the different indices <sil=0.978> .PERIOD So <sil=0.615> ,COMMA for example <sil=0.317> ,COMMA here when we declare here comes a new thing <sil=0.921> .PERIOD Suppose we have an array where the size is 10 <sil=0.917> .PERIOD So <sil=0.586> ,COMMA there will be 10 elements of the array <sil=0.969> .PERIOD 10 elements of the array just as are just like variables array as a whole is also a variable <sil=0.957> .PERIOD So <sil=0.465> ,COMMA suppose I name this array to be x <sil=0.916> .PERIOD These are x 1 <sil=0.477> ,COMMA x 2 <sil=0.650> ,COMMA x 3 <sil=0.494> ,COMMA x 4 <sil=0.315> ,COMMA x 5 like that up to to x 10 <sil=0.918> .PERIOD Now <sil=0.486> ,COMMA just like we had to declare the variables like in float here <sil=0.923> .PERIOD Here also we need to declare the array and the way we declare the array is shown here in x 10 <sil=0.981> .PERIOD What does it mean <sil=0.925> ?QUESTIONMARK That means <sil=0.586> ,COMMA x is an array of now I am introducing a term of dimension 10 <sil=0.981> .PERIOD Earlier <sil=0.368> ,COMMA I was talking calling it size and here I am calling it dimension <sil=0.978> .PERIOD For the time being assume that both these both of these are the same thing <sil=0.456> ,COMMA but actually there is a difference <sil=0.942> .PERIOD We will explain that in the course of discussion <sil=0.985> .PERIOD So <sil=0.348> ,COMMA we declare it first of all the type of the array <sil=0.942> .PERIOD As I had said that an element all the elements of an array has to be of the same type <sil=0.913> .PERIOD So <sil=0.589> ,COMMA either all of them will be integers or all of them will be floats <sil=0.905> .PERIOD Therefore <sil=0.633> ,COMMA this entire array has is for type int which says that all the elements of this array are integers and x 10 <sil=0.930> .PERIOD So <sil=0.514> ,COMMA let us quickly have a look at the memory scenario <sil=0.911> .PERIOD Say in the memory this is my memory and this is the memory and in the memory some locations are kept for the array x <sil=0.923> .PERIOD Let me start from here and maybe up to this <sil=0.918> .PERIOD Now <sil=0.463> ,COMMA how much space will be given to the array must be known to the compiler because the compiler just like the compiler allocates variables to different memory locations <sil=1.000> .PERIOD The compiler will also have to allocate locations memory locations for the array elements <sil=0.910> .PERIOD Now <sil=0.321> ,COMMA when I said int x 10 that means the compiler will store space equivalent to 10 integers 10 integers in the memory <sil=0.978> .PERIOD 10 consecutive places for 10 consecutive one of the another <sil=0.980> .PERIOD No gap elements 10 consecutive integer places in the memory <sil=0.939> .PERIOD Therefore <sil=0.602> ,COMMA how many can you tell me how many bytes are required for that integers and I have assumed that any every integer is taking two bytes <sil=0.905> .PERIOD Integer is taking two bytes <sil=0.973> .PERIOD If I assume that then I will require 20 bytes here <sil=0.961> .PERIOD So <sil=0.355> ,COMMA there will be 20 locations each location consisting of two bytes in this way will go on <sil=0.928> .PERIOD So <sil=0.527> ,COMMA you must understand when I declared this what is the meaning of this <sil=0.904> .PERIOD Dimension of the array means that I am storing I am I am reserving I am reserving the compiler reserves the space for 10 integers and that has to be done before the array is used <sil=0.968> .PERIOD Therefore <sil=0.348> ,COMMA it must be declared before so that the compiler while it is compiling the program can allocate enough space <sil=0.971> .PERIOD So <sil=0.504> ,COMMA and now individual elements are accessed by specifying the index <sil=0.956> .PERIOD So <sil=0.637> ,COMMA here x this x is a 10 element one dimensional array linear <sil=0.943> .PERIOD Now <sil=0.581> ,COMMA this is the index of the array element now comes a peculiar thing if you look at this we are saying that each of these elements are stored in this locations and which are identifiable and accessible by the indices <sil=0.965> .PERIOD Now <sil=0.602> ,COMMA in C language each index the index value is equal to the index value of the index value starts from 0 <sil=0.924> .PERIOD So <sil=0.449> ,COMMA the first element although while discussing we are saying x 1 say I was I was drawing an array like this where I was saying that these elements are the first element x 1 x 2 that is true x 3 x 4 x 5 <sil=0.924> .PERIOD But in C these elements are the first elements are counted the counting is started from 0 there is a reason for that which will also be evident soon <sil=0.959> .PERIOD Just remember for the time being that the first element therefore <sil=0.347> ,COMMA x 1 is actually represented in C as x then this square bracket followed by the index and the first one will be x 0 second one will be x 1 <sil=0.946> .PERIOD Therefore <sil=0.449> ,COMMA can you tell me what will be the last element of this array how do I represent that yes you are right x 5 will be nothing but x 4 since I am starting with 0 I can go up to 4 here in this example as you can see that I have got 10 elements in that a therefore <sil=0.516> ,COMMA I start from 0 and go up to 9 that is what is followed in C language there is a reason for that let me just briefly mention the reason the reason would be this as I said that in the memory the array stored in a particular region when I declared it as int x 10 then 20 bytes have been given to me and the array starts from this point which has got some address may be 1000 and this address is starting is 1000 2 <sil=0.998> .PERIOD Now and I know that each one is of size 2 so <sil=0.359> ,COMMA where then I say what is the address of x 1 what is x 1 x 1 means here and I know the starting of this array so <sil=0.317> ,COMMA start address plus index times x 1 and x 1 <sil=0.976> .PERIOD So <sil=0.481> ,COMMA this is the first number of bytes for integer will give me the actual address <sil=0.964> .PERIOD So <sil=0.617> ,COMMA for the first address what will be the index x 0 so <sil=0.333> ,COMMA my start address is 1000 for the first one 1000 plus 0 times 2 so <sil=0.411> ,COMMA that will be 1000 for x 1 1000 plus 1 times 2 so <sil=0.341> ,COMMA that will be 1000 for x 5 in this will be 1000 for x 1 1000 plus 1 times 2 so <sil=0.409> ,COMMA that will be 1000 for x 5 in this way is which element 6 element so <sil=0.357> ,COMMA that one will be here 1 2 3 3 4 5 5 5 5 5 5 5 5 5 5 5 5 5 6 1 2 3 4 5 6 this element and what would be its address address will be 1000 plus 5 times 2 that means <sil=0.525> ,COMMA 1000 10 it starts from 1000 10 so <sil=0.560> ,COMMA 1000 2 1000 4 1000 6 1000 8 1000 10 here it will start so <sil=0.622> ,COMMA this is basically the offset how much I shift from the top that is the reason the ease of computation of the address of any of the index any index any element with any element with a particular index can be done using this method this formula and therefore <sil=0.515> ,COMMA we start with 0 that is a specific reason for starting with 0 so <sil=0.517> ,COMMA these 10 element one dimensional added that we have seen let us move ahead so <sil=0.522> ,COMMA like variables the areas that are used in a program must be declared before they are used the general syntax just like in integer or flow we had declared them as in flow before they are used why do I need to declare them before they are used because the compiler needs to allocate space for that otherwise the compiler does not know what type of variable it is therefore <sil=0.583> ,COMMA we also have to do the same for the nary and the general syntax will be type array name size now again here the size I mean the dimension type specifies the type of the element that will be contained in the array it can be int <sil=0.504> ,COMMA float <sil=0.509> ,COMMA care or whatever so <sil=0.607> ,COMMA I have a I have got fields like say here I can have an array I can dictate is float the array name can be my array and size may be 20 now this one specifies that this is the array of the this array can hold only floating point numbers and suppose floating point numbers are 4 by it is each then for how much memory will be reserved for this 80 bytes will be reserved for this because 20 is a size that means <sil=0.327> ,COMMA the maximum size that the array can take and what is my array everything just like every variable must have a name this array my this array also has got a name called my array and so <sil=0.319> ,COMMA the what will be the indices I am repeating the thing my array 0 so <sil=0.522> ,COMMA I am writing m a for short 0 and what will be the last element here m a for size 20 it will be 19 is it all right so <sil=0.507> ,COMMA this is the general syntax which I must put and also there should be a semicolon at the end just like other declaration there is no other major difference here <sil=0.922> .PERIOD Size is an integer constant here I am calling it dimension that is is a maximum number of elements that can be stored inside the array suppose I have got so much space kept for storing an array so <sil=0.441> ,COMMA much space many many elements can be stored I have received so much space but in my actual working I am using only some spaces and these are not touched that is allowed that means <sil=0.537> ,COMMA but the reverse is not allowed unless I can I have got the space unless I have got space I cannot store them so <sil=0.436> ,COMMA I must reserve the space beforehand but so <sil=0.517> ,COMMA that is why I want to I was mentioning this maximum space as dimension and the actual number of spaces which you are using to be size of the array all right the reverse is not true because suppose I have and I have reserved so <sil=0.539> ,COMMA much space for an array so <sil=0.646> ,COMMA I have and I go I go beyond that then these marks the spaces for other variables like ABC their data will be destroyed by my data which I am taking as an array therefore <sil=0.366> ,COMMA we must restrict to this but suppose out of this I am using only this much in my perlance I am calling its size and this to be the dimension you can call it in this example in the slide we are calling this to be the size of the array there is a maximum size of the array so <sil=0.507> ,COMMA what is dimension dimension is the maximum size that the array can be off but in practice in actual running it can be less than that but not more than that so <sil=0.437> ,COMMA I hope that part is clear to you so <sil=0.443> ,COMMA here what did I write in marks 5 what does it mean it means I am storing marks 5 what does it mean it means I am storing marks and the marks are all integers right 50 55 60 100 I am storing integer marks and how many marks can I store 5 so <sil=0.392> ,COMMA what will be the indices 0 marks 0 to marks 4 that is the index limit because I am starting from 0 I can have only 5 positions so <sil=0.635> ,COMMA marks is an array containing maximum of 5 integers if a teacher decides that he will give fractional marks that somebody can get 62 <sil=0.967> .PERIOD 5 somebody can get 70 <sil=0.947> .PERIOD 2 somebody can get 59 <sil=0.917> .PERIOD 7 then what change should we do the change that we should do is this will be replaced with float and if I say in my class there can be maximum 20 students then what else should I change I should change this and make it 20 that so <sil=0.404> ,COMMA I should declare here a few examples in X 10 that means <sil=0.542> ,COMMA X is an integer how do we read it X is an integer X is an array of integers of size or dimension 10 care line 80 that means <sil=0.319> ,COMMA what that means line is a variable array of type character so <sil=0.640> ,COMMA what will it be there will be 80 such positions usually when we take a print out usually when we take a print out of characters the lines were conventionally 80 characters in a line so <sil=0.515> ,COMMA there will be the positions like this all through maximum 80 so <sil=0.581> ,COMMA the size will be 80 and this variable is known as a line and what can it hold it can hold characters like A sorry A there can be a space space is also a character I denote space as a blank like this then maybe X is a character then there is a blank blank is also very very character then C then D all those things can be there so <sil=0.504> ,COMMA it is an array of say ultimately say P is a last character something like this altogether 80 spaces for character I keep in my variable line and what is the type of the variable that type of the variable is an array array of character similarly I am saying that there are 150 points there can be 150 points and each of those points are floating point numbers C name I just store a name I want to store the name of a person say name S Revikumar is the name of a student and I want to store it in a computer how I can store it in the form of an array where each of the characters are in the form of the elements is a character first one is S then dot then R then A V I K U M K and I need one more space R <sil=0.949> .PERIOD So <sil=0.611> ,COMMA you see I needed one more space here why because I had taken I did not have enough space here now each of them is a character by the way you know that a character is denoted like this so and so forth <sil=0.918> .PERIOD Now what this line says is I need one more space I need one more space I need one more space here why because I had taken I did not have enough space here now each of them is a character by the way you know that a character is denoted like this so and so forth <sil=0.913> .PERIOD Now what this line says is that name is a variable which has got the capability of holding 35 such characters it has got the ability of storing 35 such characters at the most now how much space should we keep how much should I keep here here here here here here if we are not sure of the exact size of the array we can define an array of large size <sil=0.907> .PERIOD Say if I think if I have got no idea of how the what are the typical Indian names for example or American names for example I can keep name 100 but is it advisable not always when I really do not have any idea I have got no other way but to do it but if I have an idea of how much the name length can be at the most I should keep so much size because if I keep an arbitrarily large size then what am I wasting I am wasting my memory space because each of these are a memory location ok suppose beyond this never a name can extend to then I should not keep this part in the name but when I have got no idea of course I have to a bigger large size <sil=0.902> .PERIOD So <sil=0.453> ,COMMA that is the difference between the actual dimension of the array how much is a we do and for S Ravik Kumar for example my actual size is 1 2 3 4 5 6 7 8 9 10 11 alright out of 35 35 was the available number of spaces <sil=0.954> .PERIOD So <sil=0.513> ,COMMA when I say it is a in marks 50 suppose in my class I have got say 10 students and I am going to store the marks of only one subject in that case there is no point storing so much space I mean reserving so much space for the variable marks if I know since I know only 10 students are there if I know beforehand then I could have written in marks 10 or if I had known that sometimes the number of students in a class are 10 sometimes 15 but never more than 20 then I could have kept marks 20 but I should not keep marks 50 I hope the point is earlier now I have already described this how an array is stored in a memory starting from a given memory just let us have a revision of this starting from a given memory location the successive array locations this is very important the successive array elements are created spaces in consecutive memory locations 1 after another so array A will have memory locations 1 after another like this let now the same computation let us do it again let X be the starting address of the array <sil=0.976> .PERIOD So <sil=0.603> ,COMMA let X be the starting address of the array address this address and K is the number of bytes allocated power array element I had shown it for an integer now I am showing it in a generalized form X was the first starting location say 1000 or whatever and K is the number of bytes allocated now then the next one will be plus K because it started with X and needed K locations the next one will start from X plus K the next one will start from X plus 2 K like that the Ith element therefore <sil=0.539> ,COMMA will be as we had computed earlier will be X plus I K and since we started with 0 that will be perfectly okay element I will be located some I will be located the address say I here will be located starting at X plus I times K just a little bit of puzzle here I have written it here like this a common mistake could be that I what would have happened if I written it like this what is the problem of writing in this way the problem is what is I K I K is not I times K not I multiplied by K but I have written it here I will write I K is another variable name all right <sil=0.979> .PERIOD So <sil=0.445> ,COMMA these two are not the same thing whenever we go for programming we should be very careful okay now so first array index is assumed to start at 0 in C we are doing that so a particular element of an array can be accessed by specifying two things what are the two things name of the array index index is nothing but the relative position of the array okay we will continue with this discussion further <sil=0.954> .PERIOD So <sil=0.341> ,COMMA we were discussing about sorting and in particular we were discussing about one sorting technique which is a selection sort <sil=0.960> .PERIOD So <sil=0.632> ,COMMA in selection sort what do we do <sil=0.905> ?QUESTIONMARK We have got an array and of size size <sil=0.947> .PERIOD So <sil=0.329> ,COMMA that means <sil=0.505> ,COMMA the index is 0 to size minus 1 <sil=0.943> .PERIOD So <sil=0.403> ,COMMA what we do <sil=0.874> ?QUESTIONMARK We some parts we assume that some parts are sorted <sil=0.972> .PERIOD So <sil=0.556> ,COMMA first thing that we do is find the smallest element <sil=0.918> .PERIOD So <sil=0.529> ,COMMA if from 0 to k is sorted already in the order then my job is to sort from k to size minus 1 <sil=0.942> .PERIOD So <sil=0.581> ,COMMA what we do <sil=0.988> ?QUESTIONMARK The step is that we find the smallest element minimum value in the list x from k to size minus 1 <sil=0.957> .PERIOD I find the minimum value and then swap that minimum value with the kth position <sil=0.957> .PERIOD That means <sil=0.398> ,COMMA this position with this position I carry out here in this position I bring the minimum value and this goes on and then increase k <sil=0.941> .PERIOD k will be increased to the next position and in this way I will be going on <sil=0.965> .PERIOD So <sil=0.420> ,COMMA the sub problem is to find the minimum element <sil=0.956> .PERIOD So <sil=0.613> ,COMMA if I go here as we are seen in the I mean in this array my task is to find the minimum position <sil=0.926> .PERIOD So <sil=0.594> ,COMMA where is say this part this part is already sorted I am sitting here and this is my kth position right this is my kth position and I want to find the minimum where is the minimum value where is the minimum value where <sil=0.903> .PERIOD So <sil=0.607> ,COMMA for that this is the function find the minimum location in the array x and starting from this location k up to the location size minus 1 <sil=0.952> .PERIOD So <sil=0.610> ,COMMA I need to need no size I need to need need to know k that is how we are giving the parameters as we had explained in functions <sil=0.913> .PERIOD So <sil=0.527> ,COMMA at every point you look at how the functions are written that will help you in revising this <sil=0.986> .PERIOD Now <sil=0.344> ,COMMA the body of the function <sil=0.969> .PERIOD So <sil=0.435> ,COMMA x pass x pass will be the smallest element found so far <sil=0.997> .PERIOD So <sil=0.562> ,COMMA initially I am making pause to be k <sil=0.985> .PERIOD So <sil=0.589> ,COMMA x pass is this point <sil=0.901> .PERIOD Now <sil=0.625> ,COMMA from k plus 1 to up to size I go on checking whether this x j this position is less than this position <sil=0.981> .PERIOD So <sil=0.548> ,COMMA I find out in this way I here I find the minimum right just see if you can understand the code <sil=0.973> .PERIOD I am find the minimum in between k plus 1 to size minus 1 in between this I am trying to find the minimum <sil=0.963> .PERIOD So <sil=0.407> ,COMMA whenever I get the minimum I will be returning that particular position <sil=0.927> .PERIOD So <sil=0.605> ,COMMA this is the position that I will be returning this position <sil=0.920> .PERIOD So <sil=0.580> ,COMMA what would be my full algorithm therefore <sil=0.326> ,COMMA so I have got a function I have got this function mean log which will return me the minimum location <sil=0.973> .PERIOD Now <sil=0.361> ,COMMA so it will yield me the location of the smallest element <sil=0.972> .PERIOD So <sil=0.382> ,COMMA now you see the selection sort main sorting function will be this it takes the array and the size <sil=0.997> .PERIOD So <sil=0.472> ,COMMA this is my array x and this is the size <sil=0.932> .PERIOD So <sil=0.569> ,COMMA I will have to work between 0 to size minus 1 <sil=0.978> .PERIOD I have got two intermediate variables k and m for k equal to 0 to k size minus 1 what am I doing first I am starting with this this element that is k equal to 0 and what am I doing I am finding out from k in the array x up to size I am finding the minimum location <sil=0.957> .PERIOD So <sil=0.430> ,COMMA suppose here is the minimum then I am what am I doing here temp is going to a k <sil=0.937> .PERIOD So <sil=0.480> ,COMMA this k is going to temp and this a k is being written by a m this is the minimum is coming here and then this temp is going here <sil=0.951> .PERIOD So <sil=0.426> ,COMMA here what am I doing is I am swapping x my array was internally I called the here there is a small mistake I can find it should be x k all these would be x <sil=0.940> .PERIOD Because <sil=0.481> ,COMMA I am dealing with x so x k will get x minimum m because and vice versa and this y <sil=0.958> .PERIOD So <sil=0.615> ,COMMA what is happening here let us see suppose my array was something like this 50 <sil=0.317> ,COMMA 20 <sil=0.403> ,COMMA 70 <sil=0.384> ,COMMA 10 <sil=0.449> ,COMMA 100 <sil=0.971> .PERIOD So <sil=0.342> ,COMMA I am first this is my k equal to 1 I want to bring the minimum at this position <sil=0.979> .PERIOD So <sil=0.422> ,COMMA what I do I from here I start searching for the minimum I find 10 to be the minimum then I swap here in this piece of code I swap I bring 10 here and 20 <sil=0.512> ,COMMA 70 remains and 50 I take here and then what do I do k is incremented <sil=0.949> .PERIOD So <sil=0.508> ,COMMA now k is here now I find mean lock if what is the minimum here compare less than this or not there is none so fine next <sil=0.930> .PERIOD So <sil=0.590> ,COMMA this remains next I increment this so this is also in position this is in position because it need not be exchanged <sil=0.989> .PERIOD Next my k is increased here at this step k plus plus it has been increased here I find the minimum in this area I find this to be the minimum <sil=0.987> .PERIOD So <sil=0.304> ,COMMA what is happening 10 was in place 20 was in place I swap 50 and 70 here <sil=0.904> .PERIOD So <sil=0.640> ,COMMA 50 comes here I find the minimum 70 remains here 100 remains here now I change my k and see if there is any minimum left here the mean location is not returning me anything <sil=0.988> .PERIOD So <sil=0.321> ,COMMA therefore <sil=0.593> ,COMMA I get this to be my sorted array <sil=0.908> .PERIOD So <sil=0.378> ,COMMA this is what so you can see that so in this way we can sorry here is an example now you see here the example you see here I start with this so 3 is the minimum I can see here 12 minus 5 6 etcetera I can see minus 17 is the minimum <sil=0.954> .PERIOD So <sil=0.493> ,COMMA I find out minus 17 here I swap that so minus 17 comes here and 3 goes to the place of minus 70 <sil=0.922> .PERIOD So <sil=0.322> ,COMMA these to now 12 12 and I find the minimum from 12 onwards I find minus 5 to be the minimum so that one will come here so minus 5 comes here and 12 is swapped there now within this part I find the minimum minimum is 3 so 3 will be swapped with 12 and 12 goes there in the place of 3 you see now <sil=0.916> .PERIOD So <sil=0.587> ,COMMA I start with 6 I start finding the minimum 6 is the minimum fine so it remains I increase k so now 142 in this way I go on from here with the minimum starting from 142 12 is the minimum so 12 and 142 will be swapped 12 and 142 has been swapped next 21 21 within this 21 142 45 21 is the minimum therefore <sil=0.301> ,COMMA I keep it in place next is I take 142 and 145 I find that 45 is minimum I swap that and 142 goes there next is 142 is the that is the sort it added that we get this is what is known as selection sort <sil=0.945> .PERIOD So <sil=0.505> ,COMMA the philosophy of selection sort is that I am selecting the minimum element among the unsorted elements and placing it in the position proper position where that minimum element should be that is why we are selecting and putting it so that is why it is known as selection sort <sil=0.965> .PERIOD So <sil=0.313> ,COMMA how many steps are needed to sort n things here if I do this how many steps am I taking you see how many steps am I taking all through here if you look at this how many steps am I taking if the list size of the list was n then the total number of steps that required is proportional to n square because for every element why it is why it is so let us try to understand this <sil=0.942> .PERIOD The reason is that for every position how many positions are there 1 2 3 like that there are n positions now for every position for this position how many comparisons I need to find out the minimum n minus 1 compare n comparisons for all these next I implement it here <sil=0.975> .PERIOD So <sil=0.590> ,COMMA how many do I need I need for each of these for n for n such elements for each of them I need n comparisons then n plus for this I need n minus 1 comparisons then I need n minus 2 comparisons then I need n minus 3 comparisons in this way for example for this this n 1 2 3 so n minus 4 comparisons I need in this part I have to compare between these things so in that way I go on so for every so for each of them I need to compare this for n such things I have to do this n plus n plus so n minus 1 plus n minus 2 times n so that will be of the order of n square if I find the product right and number of compare total number of steps and number of comparisons is again n into n minus 1 by 2 like as I said n minus 1 comparisons plus n minus 2 comparisons last one is one comparison so if you add this 1 to n minus 1 is n into n minus 1 by 2 you know that and that is of the order of n square if I break it up it will be n square minus n by 2 so that is again of the order of n square of the order of we write it as of the order of n square all right now next we come to another sorting algorithm which is known as insertion sort what is the general situation again just like the selection sort we have got the smallest elements sorted from 0 to this point is sorted the remaining is unsorted all right now what we do is compare and shift till x i is larger okay I go on shifting so what I do is I start with this element and I put this in the proper position I insert this in the proper position I so I move this in this side or in this side and I will come to the proper position of this element this element is being put since it is smaller the smallest elements are sorted so I am taking this and I am putting it in the place where it should belong because I have not seen up to this okay so so insert sort is something like this let us see if I can show you an example first so what I am doing is I am comparing and shifting till x i is larger I am continuously shifting the elements in this way I go on shifting this ultimately x i will be larger than all these elements so therefore my sorted position will be up to this this is larger right so I am sorry I just went the other side other way so let us study this algorithm this algorithm is void white's void because it is not returning anything it is taking the array and is sorting this is taking this array and it is sorting this so its type is void is taking a list and its size now for i equal to 1 to size I am taking item to be the least i so I have got elements like say 12 7 5 17 9 so first I am taking i is 1 so I am taking this element this item for j's now I am looking at you see j equals i minus 1 and j is greater than 0 and list so it is not I am not going into this side I will have to go in this direction what does this mean I start with j i minus 1 and go till j is greater than equal to 0 and the list is greater than i so my i is here that means I am not I am going till the end of this array on the other side I am going on the other side and I shift what was my j here j plus 1 and the list are being swapped so now it will become 7 12 5 17 9 now and then in that way I go on shifting all right so now if I come here I increment i after one item so I will come 5 and 5 I will go on checking what is the proper place of 5 so it will be 5 will be swapped with this 12 7 17 9 in that we will try to find out for every each of these is proper position okay so I think we can go for a more popular sort let us go to the more popular sort I think that will be better selection sort you have learnt insertion sort is another form but let us learn the more popular one that is the bubble sort bubble sort as the name implies it starts from the bottom and the minimum element is pushed up to the top how is that done just as a bubble floats up from the bottom and goes to the top the minimum element should be pushed up or the minimum element should be pushed up to the top so let us see how it happens so I first compare between these two elements then these two elements and in this way I go on comparing between each of them and push it up okay in every iteration the heaviest element drops at the bottom so what is happening is so if I go here from the top I try to find out if this element if this particular element I am sorry this particular element is heavier than this particular element then this particular element should go at the top and this should come down here alright next I compare sorry next I compare what is happening next I compare between this so this was a heavy element and I find that this is not an heavy element this is heavier than this so this may be more heavy much heavier than this so this is not pushed up okay remains now next I compare between and every time I am making the same mistake maybe this is a heavier lighter element so this lighter element will go up and this heavier element will come down so it will be something like this alright so in this way in one direction ultimately what I will do I will have the heaviest element at the bottom and all the elements here are lighter than this this element lighter than this element but these elements are not sorted so what I will do I will restrict my next iteration within this zone and again start between these elements and see whichever is heavier that will be pushed down am I clear you see every time I am comparing between these and I am pushing that down I think it will be clearer in a moment every iteration the heaviest element drops at the and the bottom this part is done and the bottom moves upward so next time onwards my my search will be restricted between this zone this zone to the top and the heaviest will come here next time my search will be restricted to this zone like that so the heaviest here next heaviest here next heaviest here heaviest here next heaviest here next heaviest here like that it will go on so I want to see if I can give an example first yeah so what is happening here is say this was an unsorted array the heaviest one has been first pushed down this 89 was the heaviest one so by piece by piece comparison I have pushed it down next time I was restricted to this part of the array 89 has been pushed down so and let me try to show you that say suppose I have gotten an array like this 50 16 20 30 40 so first I compare between these two 60 50 is heavier so I come here next I compare between these two 50 and 20 50 is heavier so 20 comes here 50 comes here now 50 and 30 50 is heavier so 30 50 and then 50 and 40 so I compare this so it becomes 40 50 so in one turn what do I get now I get 16 20 30 40 50 now it is such that many things were sorted only one was in out of order so that has been done but suppose this was let me just change it it becomes it became too easy so suppose it is 25 then after this swap this became 25 and 50 so I have this array now I again check between these two heavier is in place I check between these two no issue heavier in place I check between these so now what will happen 25 will come here and 30 being heavier will come here and 30 and I need not compare any further I can because this is this I know is the heaviest so what do I have now 16 20 30 not 30 30 has been swapped 25 30 I again compare between these two so there is no change as soon as I find that there is no interchange that means all these things are in order this is the idea of the selection sorry the bubble sort every time the minimum is shifting going to the bottom or I could have done it in the other way that would have justified the name of the bubble sort if I had taken the lowest element and pushed it up okay so quickly if you look at the algorithm a little bit so we have got this is a bubble sort algorithm let us see now in order to explain this I will need some time because here we are using some new ideas star x and star y I think I will take it up in a separate lecture and discuss this separately alright but just as I had explained now the way the bubble sort works I will just give you one more example to show how a bubble sort works and then in the next lecture I will show you the algorithm because that will some more explanation let us say I have got this 30 20 5 16 2 so what will be happening in the first iteration 30 will be compared with 20 30 is heavier so it will be 20 30 55 16 2 now 30 will be compared with 5 so what will happen and will be swapped 30 16 2 30 will be compared with 16 so what will happen 20 5 16 32 and 30 is again greater than 2 so 25 16 to 30 so 25 16 to 30 so 25 16 to 30 by that I get this 30 at the bottom so now I start with again 25 16 to right so now I have got 30 is at the bottom 25 16 to and 30 is already in proper place here I will swap so what will happen 5 20 16 to then 20 will and 16 so it will be 5 16 22 then 5 16 to 20 20 is in the proper place so 30 and 20 are in proper place and 5 16 to I will have to handle so what will be there 5 16 to so 5 16 to and here I have got 20 and 30 already in the proper place sorted so here 5 and 16 no change 16 and 2 there will be some change so 5 to 16 so 16 is in the proper place so now between 5 and 2 so my thing will be 16 20 30 are in place 16 20 30 are in place and 5 and 2 I have to deal with these are fine so my pointers are changing right between these two now 5 is heavier so it will be 2 5 5 is in the proper place so 2 5 in the proper place 16 proper place 20 proper place 30 proper place so only 2 there is no question of swapping so I get the complete sorted file okay so this is the principle of bubble sort I will be explaining the algorithm the code in the next class in the meanwhile you can think of you can read books and you can try to see look at this code and the algorithm yourself I will discuss it in the next week's lecture thank you <sil=0.934> .PERIOD In the earlier lectures <sil=0.582> ,COMMA we had discussed about one dimensional array as well as two dimensional we have seen how one dimensional array can be stored <sil=0.404> ,COMMA read and printed and as well as we saw how a linear search can be applied over one dimensional array <sil=0.949> .PERIOD Similarly <sil=0.443> ,COMMA we have seen for two dimensional arrays how it can be read <sil=0.481> ,COMMA it can be stored <sil=0.451> ,COMMA it is stored in a row major form and how it can be printed <sil=0.952> .PERIOD Now <sil=0.420> ,COMMA today we will start discussing on a very important and vital component of programming and also a part and parcel of the C language that is functions <sil=0.966> .PERIOD The concept of functions is very general and we will have to first look at it from the general angle why it is required what is a function and then we can look at some of the details of this <sil=0.365> ,COMMA the implementation of this concept in the C language <sil=0.903> .PERIOD So <sil=0.645> ,COMMA first let us start with functions <sil=1.000> .PERIOD So <sil=0.528> ,COMMA we will start to visualize a task <sil=0.560> ,COMMA suppose I have got a big task <sil=0.503> ,COMMA which I have to implement by programming <sil=0.960> .PERIOD Now <sil=0.403> ,COMMA any task this is one task <sil=0.498> ,COMMA this task may be too complicated and for any human programmer or any human being to solve this task from the beginning till end in one shot may be difficult <sil=0.937> .PERIOD Often what we do we break up this task into a set of smaller subtasks <sil=0.609> ,COMMA different subtasks and each of these subtasks are smaller enough <sil=0.531> ,COMMA small enough so that we can manage it better <sil=0.913> .PERIOD Each of these are possibly better managed <sil=1.000> .PERIOD We can say if you think of a program segment <sil=0.594> ,COMMA a part of a program <sil=0.395> ,COMMA if the task is broken big task is broken down into a small task <sil=0.357> ,COMMA a number of small tasks then it is easier to write the program for each of these smaller tasks and each of these tasks can be independently tested for its correctness whether it is working properly or not <sil=0.950> .PERIOD Each of these can be separately tested and then if all these are connected together <sil=0.428> ,COMMA if all these are connected together one after another and then I can ultimately get this entire task done <sil=0.924> .PERIOD So <sil=0.464> ,COMMA instead of addressing the whole task in to execute the whole task or implement the whole task as a single task it is often advisable to break it down into a number of subtasks <sil=0.922> .PERIOD Now <sil=0.467> ,COMMA let us talk about programming <sil=0.996> .PERIOD Now <sil=0.505> ,COMMA if we want to now what is a when we say the term function <sil=0.342> ,COMMA function if we take the English meaning of that function is means doing something <sil=0.925> .PERIOD So <sil=0.515> ,COMMA it is a also a task therefore this entire function can be broken down into smaller functions and each of these functions can be implemented independently <sil=0.940> .PERIOD So <sil=0.616> ,COMMA the advantage that we get by this means is that we can divide the problem into smaller parts and thereby we can conquer the small we can conquer the smaller subsegment and in the process we in the process we achieve the complete task that is the first thing <sil=0.910> .PERIOD So <sil=0.621> ,COMMA by this it is easier to implement and also easier to test or verify <sil=0.966> .PERIOD We can check whether each of these components are working correctly or not <sil=0.943> .PERIOD Now <sil=0.418> ,COMMA when we find that all the components are working correctly and if they are connected together correctly then we will have the entire problem solved correctly <sil=0.925> .PERIOD That is the first advantage of writing a complex program broken down into smaller functions <sil=0.905> .PERIOD Now <sil=0.580> ,COMMA the other advantage is suppose I had to implement one task and in order to implement this big task I had to write a number of functions smaller functions say three smaller functions together implement this big function <sil=0.972> .PERIOD So <sil=0.317> ,COMMA let us call them F 1 function 1 F 2 for function 2 and F 3 for function 3 <sil=0.943> .PERIOD Now <sil=0.568> ,COMMA suppose I have now this problem has been solved by solving each of these three functions <sil=0.521> ,COMMA each of these three functions have been written and tested and consequently they have been connected together and we have got the complete function <sil=0.912> .PERIOD Now <sil=0.379> ,COMMA suppose another friend of yours wants to write another task solve another task say this was this was also a task <sil=0.940> .PERIOD So <sil=0.377> ,COMMA this is also a function I am writing that as capital F 1 and there is another friend of yours who is trying to complete another task which we are naming as F 2 <sil=0.949> .PERIOD Now <sil=0.607> ,COMMA in order to develop F 2 he finds that okay I have to solve some problems which are solved by F 1 and another problem which is solved by F 3 <sil=0.936> .PERIOD Might be that this sub problem requires F 1 F 3 and say another function which was not written by anybody till now F 4 <sil=0.969> .PERIOD Now <sil=0.589> ,COMMA obviously since F 1 has been written and tested he the writer of F 2 did not write F 1 again because that F 1 this F 1 can be used for this purpose <sil=0.961> .PERIOD Similarly <sil=0.509> ,COMMA this F 3 can be used for this purpose and only effort that he has to spend is to write F 4 thus the functions which are written already right can be reused <sil=0.924> .PERIOD So <sil=0.459> ,COMMA this reusability is another very important advantage of writing functions <sil=0.902> .PERIOD Now <sil=0.370> ,COMMA we have said that in order to solve F 1 or F 2 we have to write we will have to independently write and test smallest functions and connect them together <sil=0.908> .PERIOD What do I mean by connecting them together <sil=0.981> ?QUESTIONMARK Let us try to understand that <sil=0.987> .PERIOD So <sil=0.521> ,COMMA say we have a function that is to be done developed and we find that okay this part has to be this part this task has to be solved by some function <sil=0.911> .PERIOD So <sil=0.439> ,COMMA I write a function here for this part let me let me let me let me do it again <sil=0.910> .PERIOD This is my whole problem that I have to solve and so I am solving some things here some steps I am solving and then I find here there is some thing that has to be done which is not very easy so for that I came at this point and for this I need to write a function or might be there is a function already existing in my library which has been written by somebody else which I can reuse <sil=0.903> .PERIOD Now <sil=0.593> ,COMMA in that case and also say here after doing that here I can do a couple of simpler tasks and then here I come to another point which requires it to be independently solved and written <sil=0.926> .PERIOD So <sil=0.404> ,COMMA I need a function for that and then after that I will do some more simple things and my task will be over say this is the situation <sil=0.974> .PERIOD So <sil=0.481> ,COMMA when I come here I will have to I means this program which is the main tasks main task that I have to solve <sil=0.967> .PERIOD So <sil=0.606> ,COMMA since we have seen the name main in our description for C earlier let me also name this to be main <sil=0.971> .PERIOD And I am just for nothing I am just putting some parenthesis here <sil=0.961> .PERIOD So <sil=0.336> ,COMMA main is the main task that I have to do and at this point I am doing some things and here I need the help of this <sil=0.994> .PERIOD Now <sil=0.401> ,COMMA remember that this function whose name is say F F 1 that can be used by my main function or somebody else's main function also <sil=0.906> .PERIOD Therefore <sil=0.401> ,COMMA when I need this to be executed with my data then I must whatever data I have prepared here that some of that I will have to pass on to this here <sil=0.965> .PERIOD And this will solve this sub task and then I will have to that means that this must give back whatever it computed to the main task and the main task will continue doing simple things here <sil=0.943> .PERIOD So <sil=0.402> ,COMMA you see that there are two links one is going in the function another is coming out or some data that is being returned by this function <sil=0.946> .PERIOD This is being returned by this function <sil=0.928> .PERIOD Then I carry out some task simpler task here and at this point I find no I need help <sil=0.911> .PERIOD So <sil=0.638> ,COMMA some part of the data from here will be used by the function F 2 and that has to come to F 2 here and F 2 will carry out the task and will return to the point here <sil=0.938> .PERIOD Now <sil=0.385> ,COMMA about this return you should observe one thing that the function was called from this point <sil=0.917> .PERIOD We call this thing to be a function call function call with some data being passed on to this and function call or function invocation and after invocation this function works and it returns where does it return <sil=0.933> ?QUESTIONMARK It returns to the point in the main task just after the point from where it was called it was called from here <sil=0.963> .PERIOD So <sil=0.441> ,COMMA it comes here and then returns to the next point just after the after this call <sil=0.926> .PERIOD So <sil=0.466> ,COMMA this is the calling point and this is the return point <sil=0.979> .PERIOD Similarly <sil=0.650> ,COMMA for here you see that it is executing and at this point it is being called and after execution the control is returning to the point immediately after the point from where it was called <sil=0.937> .PERIOD So <sil=0.349> ,COMMA this is one important thing to understand <sil=0.942> .PERIOD The other important thing is that let me draw it again <sil=0.903> .PERIOD Here I have got my main task and this is my main and here is another main task <sil=0.452> ,COMMA some other main task not written by me but somebody else this is of Mr A and this is of Mr B for Mr B there is he has written another main <sil=0.927> .PERIOD Now <sil=0.467> ,COMMA Mr A or Mr B both will require this function f <sil=0.921> .PERIOD Now <sil=0.587> ,COMMA the task the purpose of what this task does is same <sil=0.955> .PERIOD For example <sil=0.346> ,COMMA this task is computes the average of some numbers 10 numbers 5 numbers whatever it is or maybe floating point numbers integer numbers whatever it is it computes the average <sil=0.918> .PERIOD So <sil=0.532> ,COMMA let me quickly rename it not keeping it vague any longer <sil=0.914> .PERIOD Let me call it average or for a specific purpose I want to write it inside the region will be clear immediately this computes the average <sil=0.951> .PERIOD Now <sil=0.393> ,COMMA Mr A wants to use this average function for some data for 3 data he wants to compute the average of 3 integers <sil=0.999> .PERIOD Suppose this one computes the average of 3 integers but the integers can vary <sil=0.963> .PERIOD So <sil=0.416> ,COMMA this also wants to find the average of 3 integers to make it simple but the in numbers for which A wants to compute the average is different from the numbers that B will compute the average for but this AVG is common to both therefore <sil=0.969> .PERIOD Suppose the numbers that some integers say are A B and C and here this person wants to find the average of 3 integers which are P Q and R 3 variable names <sil=0.929> .PERIOD Now <sil=0.455> ,COMMA this average cannot remember P Q R or A B C it will simply just like think of a box with 3 pipes coming in and data will come in through there <sil=0.919> .PERIOD So <sil=0.503> ,COMMA he just names this average for he names these pipes as X this is Y and this is Z <sil=0.949> .PERIOD So <sil=0.379> ,COMMA when this function main wants to compute the average of A B C he must send A through the pipe X B through the pipe Y and C through the pipe Z and he will get the average computed and the average will be returned from the point where it was called it was called from this point immediately after that it will go back clear <sil=0.928> .PERIOD Now <sil=0.406> ,COMMA when let me change the color now when the function main B B wants to compute the average he wants to compute the average of P Q R so P will be sent to the pipe X Q will be sent to the pipe Y and R will be sent to the pipe Z and the average will be computed suppose it was called from this point from this point this average was called <sil=0.936> .PERIOD So <sil=0.508> ,COMMA then it will return the to this point with the value of the average with the value of the average whatever is computed here therefore <sil=0.556> ,COMMA so if this is clear then let us come to two more terms they are that this function main A A is main was sending A B C to the function as parameters we call it as parameters and this function which is our average function is not biased to A right it has got it knows that it needs three inputs and there are three input pipes three input positions <sil=0.920> .PERIOD So <sil=0.464> ,COMMA this X Y Z are arguments this we call as arguments all right that means this average when it is written it has got three input pipes <sil=0.942> .PERIOD So <sil=0.403> ,COMMA we can write simply like this function name average with three arguments X Y and Z now whoever calls it we will have to establish the mapping between the parameters that it wants to pass the parameters it wants to pass through the to the arguments <sil=0.990> .PERIOD So <sil=0.332> ,COMMA the connection that we had shown in the earlier diagram which was where both the programs were both the programs were accessing it <sil=0.950> .PERIOD So <sil=0.410> ,COMMA each of these parameters should the parameters should be matching with this arguments let us come to this once again say <sil=0.933> .PERIOD So <sil=0.560> ,COMMA now so here is main of A and here is main of B I repeat what I was saying till now and this has got P Q R now you must be must have realized now what are these P Q R's when I use this function average which has got three arguments X Y Z which are nothing but three pipes which are arguments and when I call from some point when I call this function average then I have to pass these parameters P Q R to these arguments X Y Z <sil=0.941> .PERIOD So <sil=0.636> ,COMMA P will go to X Q will go to Y and Z R will go to Z on the other hand when A is calling when A is calling what is happening when A is calling then A had the A B C to be passed on to this <sil=0.991> .PERIOD So <sil=0.584> ,COMMA A goes to X B goes to Y and C goes to Z <sil=0.974> .PERIOD Now <sil=0.586> ,COMMA since now if you just think these are three pipes now the pipes are every pipe has got a width <sil=0.956> .PERIOD So <sil=0.635> ,COMMA if I want to fit a smaller pipe into a bigger pipe that own fit right <sil=0.900> .PERIOD So <sil=0.397> ,COMMA the width of diameter of both the pipes must fit together what I mean by that what I mean by that is that whatever arguments are whatever are the types of the arguments that must match the types of the parameters or in other words the types of the parameters also must match the types of the arguments so that the pipes fit there should not be any mismatch over there <sil=0.900> .PERIOD So <sil=0.390> ,COMMA let us take a little more deeper look here <sil=0.952> .PERIOD So <sil=0.412> ,COMMA suppose I have got a main function here I am not so much bothered about the syntax now and the main main function is running and here I want to say say result is average of A B C and etcetera etcetera etcetera and the end here and let us assume that here I have declared in A B C both of them are integers now we have got the function which is average <sil=0.936> .PERIOD Now <sil=0.366> ,COMMA this average of three integers can be a float so I just write I will explain it a little later float average x y z and I can say in x y z and whatever I am computing average here and so thus this is simple you can have int sum and sum equals x plus y plus z and average is equal to x plus y plus z by 3 then I write return y divided return I will come to that now look at the two things A I will talk about this part a little later here I have declared A B C to be integers <sil=0.983> .PERIOD So <sil=0.595> ,COMMA in the memory for A B and C two bytes or four bytes as the system may demand that type of that much memory has been given ok <sil=0.936> .PERIOD Now <sil=0.461> ,COMMA when I write here A V G that means I am invoking or calling this function A V G and I am passing on A V G requires three parameters x y z and x y z are all integers and I could have written there is another way of writing it that I could have written here int x into I in z that is also possible but later we will see that now <sil=0.912> .PERIOD So <sil=0.407> ,COMMA A B C there is a correspondence between A B and C with x y and z and they are matching in the type then this computation so we come here then follow my blue line this is being computed and ultimately the value of average is computed <sil=0.957> .PERIOD Look that the value is being computed in A V G which is also the name of the function <sil=0.927> .PERIOD So <sil=0.460> ,COMMA in a way you can say that the name of the function is just like a variable that is holding the value that is holding the value <sil=0.990> .PERIOD So <sil=0.523> ,COMMA that average any variable that is holding a value must have a type that is why since average of three integers can be a float therefore <sil=0.553> ,COMMA we have to assign a type to the name of the function designating what type of value it is returning <sil=0.983> .PERIOD So <sil=0.485> ,COMMA here we can see that it will compute average and then there is a statement new statement that you are encountering here is return where is it returning it is returning to the point from where it is called at is this point and so the average suppose if the values are 1 2 and 3 then the average is 2 <sil=0.960> .PERIOD So <sil=0.325> ,COMMA then 2 goes to this A V G and that A V G is being transferred to result <sil=0.914> .PERIOD Now <sil=0.388> ,COMMA if I do print result here 2 will be printed <sil=0.968> .PERIOD So <sil=0.544> ,COMMA this is to give you an idea of what is meant by in calling a function in working a function what is meant by returning from a function and water parameters and arguments <sil=0.947> .PERIOD We will see more of this in the subsequent lectures <sil=0.555> ,COMMA but you should also understand why we do this the reasons are 2 fold as I said one is to divide or break down a complex problem into manageable sub problems and the second and test them independently and the other issue is other advanced big advantages that once we make a thing a function which is tested we can keep it for being reused that is a very very important thing and this concept is general over different languages like we have got class etcetera which we can reuse a number of times and this is this idea the implementations are varying from language to language <sil=0.640> ,COMMA but the concept is common and is used in different languages <sil=0.942> .PERIOD Thank you and we will continue with functions this subsequent lectures <sil=0.921> .PERIOD We have seen how structures are represented <sil=0.507> ,COMMA we have also learnt about pointers <sil=0.956> .PERIOD So <sil=0.474> ,COMMA today we will be looking at the structures once again in a different light <sil=0.997> .PERIOD As you can see here <sil=0.385> ,COMMA a structure can be declared as as is shown here <sil=0.303> ,COMMA a student structure <sil=0.522> ,COMMA struct stud is consisting of three members or three fields <sil=0.919> .PERIOD So <sil=0.585> ,COMMA they are the role <sil=0.593> ,COMMA the department code which is the character array and CGPA which is a floating point number and A <sil=0.594> ,COMMA B <sil=0.491> ,COMMA C are three variables of the type STUD stud <sil=0.982> .PERIOD The individual structure elements you know can be accessed by A dot role <sil=0.963> .PERIOD So <sil=0.560> ,COMMA A is this field or B dot role <sil=0.471> ,COMMA C dot CGPA <sil=0.980> .PERIOD So <sil=0.602> ,COMMA with this dot operator <sil=0.308> ,COMMA we can access them <sil=0.993> .PERIOD This was known to us <sil=0.905> .PERIOD Now <sil=0.566> ,COMMA we can also we have seen that we can define an array of structures where class is an array of students <sil=0.414> ,COMMA class sizes 100 and each element is a structure of type stud <sil=0.945> .PERIOD The structure elements of the individual records can be accessed with this dot operator like class I <sil=0.608> ,COMMA any particular element of that <sil=0.928> .PERIOD Say for example <sil=0.625> ,COMMA here any particular element I take and so this is class I where I is this index <sil=0.975> .PERIOD I come over here and get a particular field of this <sil=0.989> .PERIOD So <sil=0.486> ,COMMA this has got a number of fields <sil=0.977> .PERIOD So <sil=0.587> ,COMMA I am coming to the role field or the department code field or the CGPA field <sil=0.990> .PERIOD This was also known to us <sil=1.000> .PERIOD So <sil=0.585> ,COMMA here we are trying to apply that through an example sorting by role numbers <sil=0.941> .PERIOD So <sil=0.481> ,COMMA here we have got a set of students look at the declaration here <sil=0.984> .PERIOD Student or struct stud is the structure having role department code and CGPA <sil=0.930> .PERIOD Now <sil=0.341> ,COMMA in the main function <sil=0.300> ,COMMA what are we doing <sil=0.967> ?QUESTIONMARK We are defining struct student class 100 <sil=0.983> .PERIOD Now <sil=0.344> ,COMMA struct stud has been declared <sil=0.912> .PERIOD It has been declared globally even before main <sil=0.958> .PERIOD That is possible <sil=0.956> .PERIOD And here I am saying that class 100 is one array and t and there are some integers t is again a structure t is also a structure of type stud <sil=0.914> .PERIOD Now <sil=0.621> ,COMMA I am reading the number of students <sil=0.909> .PERIOD How many students are there in the class <sil=0.902> ?QUESTIONMARK The array can accommodate at most 100 <sil=0.570> ,COMMA but I am reading the value n <sil=0.919> .PERIOD Now <sil=0.617> ,COMMA for each of the elements <sil=0.319> ,COMMA look at this <sil=0.921> .PERIOD This is our familiar for loop here <sil=0.918> .PERIOD For k is equal to k 0 to less n <sil=0.568> ,COMMA I am scanning the class the role number of that particular student <sil=0.620> ,COMMA the department code and the CGPA <sil=0.911> .PERIOD So <sil=0.459> ,COMMA in that way <sil=0.419> ,COMMA I read here I am reading the array <sil=0.942> .PERIOD The array is being read here <sil=0.922> .PERIOD Array is read at this point <sil=0.934> .PERIOD Now <sil=0.492> ,COMMA what I am doing now <sil=0.855> ?QUESTIONMARK Next <sil=0.492> ,COMMA let us look at this loop <sil=0.964> .PERIOD What are you doing here <sil=0.933> ?QUESTIONMARK For some value of j <sil=0.318> ,COMMA if the role of that student <sil=0.569> ,COMMA so here I have got my array <sil=0.932> .PERIOD I am coming to any particular j <sil=0.473> ,COMMA a particular element and looking at the role number field of that <sil=0.453> ,COMMA if that is greater than some other value k <sil=0.454> ,COMMA if is greater than the role value of k <sil=0.398> ,COMMA then I am exchanging them just as we sort <sil=0.986> .PERIOD Now <sil=0.467> ,COMMA what are we sorting here <sil=0.891> ?QUESTIONMARK In the example earlier that we had done <sil=0.344> ,COMMA we are sorting integers or sorting real numbers <sil=0.957> .PERIOD Here <sil=0.529> ,COMMA what we are doing <sil=0.395> ,COMMA we are sorting the entire structure as you can see here <sil=0.908> .PERIOD The entire structure <sil=0.340> ,COMMA the j is coming to t <sil=0.921> .PERIOD So <sil=0.529> ,COMMA t is again a structure <sil=0.382> ,COMMA k is coming to j and so <sil=0.426> ,COMMA this is a swap operation <sil=0.321> ,COMMA swapping structures <sil=0.980> .PERIOD Swapping the structure structures <sil=0.922> .PERIOD And this I am doing for k is the internal variable and j is the external variable <sil=0.901> .PERIOD So <sil=0.596> ,COMMA my diagram should be a little different <sil=0.450> ,COMMA the diagram should be <sil=0.963> .PERIOD So <sil=0.454> ,COMMA for every j <sil=0.301> ,COMMA I am looking at 1 j and I am varying k from here <sil=0.407> ,COMMA this is k <sil=0.382> ,COMMA k is varying from this point to this point to the end of the structure and comparing with this j value <sil=0.940> .PERIOD If this is any element that is less <sil=0.536> ,COMMA that is coming over here and it is being swapped <sil=0.942> .PERIOD So <sil=0.375> ,COMMA we have seen this swap algorithm earlier <sil=0.990> .PERIOD So <sil=0.527> ,COMMA that is being swapped here and then I update j and I go on doing this <sil=0.971> .PERIOD So <sil=0.568> ,COMMA this is how I can apply the sorting algorithm that we had learnt <sil=0.307> ,COMMA that can be applied for sorting student records <sil=0.966> .PERIOD Next <sil=0.533> ,COMMA the other thing that we have to look at is the pointer and structures <sil=0.547> ,COMMA how they can be intermingled <sil=0.997> .PERIOD You may recall that the name of an array stands for the 0th element of the array <sil=0.930> .PERIOD So <sil=0.485> ,COMMA if this be an array <sil=0.585> ,COMMA then if the name of the array is name of the array is a <sil=0.547> ,COMMA then the name a and a 0 are synonymous and so <sil=0.419> ,COMMA a is also a can be considered to be a pointer that is pointing to a 0 <sil=0.939> .PERIOD Now <sil=0.483> ,COMMA consider the declaration this <sil=0.998> .PERIOD This is also true for the names of arrays of structures <sil=0.986> .PERIOD So <sil=0.588> ,COMMA if I have a declaration like this <sil=0.305> ,COMMA you look at the declaration yourself <sil=0.972> .PERIOD So <sil=0.468> ,COMMA you can see student is a structure and I have declared of the type student an array class 100 and star PTR <sil=0.975> .PERIOD Now <sil=0.425> ,COMMA what is star PTR <sil=0.931> ?QUESTIONMARK What does it mean <sil=0.990> ?QUESTIONMARK You know by now just as we had done this <sil=0.508> ,COMMA keep it side by side in star P <sil=0.942> .PERIOD What does it mean <sil=0.944> ?QUESTIONMARK It means that P is a pointer that points to integer data type <sil=0.983> .PERIOD Here it means that PTR is a pointer that points to stud type of structures <sil=0.974> .PERIOD This type only to this type of structure <sil=0.551> ,COMMA PTR points to that <sil=0.957> .PERIOD So <sil=0.470> ,COMMA now what do I have <sil=0.935> ?QUESTIONMARK I have got an array called class <sil=0.567> ,COMMA each element of which is of type student structure and I have got a pointer PTR which can point to such structures <sil=0.939> .PERIOD It can point to such structures <sil=0.345> ,COMMA any of these <sil=0.972> .PERIOD I have not yet initialized this <sil=0.916> .PERIOD The name class therefore <sil=0.634> ,COMMA represents the address of the zeroth element of the structure array <sil=0.948> .PERIOD So <sil=0.345> ,COMMA if we go back <sil=0.642> ,COMMA so if I have this <sil=0.446> ,COMMA then this class means it is a pointer that is pointing to this element class 0 <sil=0.943> .PERIOD Just like an array <sil=0.985> .PERIOD So <sil=0.547> ,COMMA and PTR is a pointer to the data objects of type star that we have seen <sil=0.990> .PERIOD The assignment class assigned to PTR <sil=0.489> ,COMMA what will it make <sil=0.890> ?QUESTIONMARK It will make PTR now to point to the first element of the array <sil=0.941> .PERIOD Here is class and PTR is now pointing when I do this assignment <sil=0.422> ,COMMA note that they are of the same type <sil=0.993> .PERIOD So <sil=0.388> ,COMMA when I do this assignment <sil=0.356> ,COMMA this is pointing to this element <sil=0.993> .PERIOD So <sil=0.614> ,COMMA it will assign PTR to class 0 understood <sil=0.968> .PERIOD When the pointer PTR is incremented by 1 that is PTR plus plus <sil=0.304> ,COMMA you should be able to tell me what will happen <sil=0.955> .PERIOD The PTR will be incremented to the next element of the array <sil=0.955> .PERIOD So <sil=0.342> ,COMMA the actual increment will be by a scale factor and what is that scale factor <sil=0.876> ?QUESTIONMARK That scale factor is size of stud <sil=0.994> .PERIOD Size of this structure stud and you know that it has got a roll number <sil=0.641> ,COMMA it has got CGPA <sil=0.930> .PERIOD So <sil=0.561> ,COMMA depending on the different data types that are housed inside that structure <sil=0.627> ,COMMA it will vary <sil=0.980> .PERIOD So <sil=0.376> ,COMMA the value of PTR will point to the next element will be incremented by size of stud fine <sil=0.912> .PERIOD This much is clear <sil=0.912> .PERIOD So <sil=0.631> ,COMMA it is made to point to the next record <sil=0.964> .PERIOD Once PTR points to a structure variable <sil=0.348> ,COMMA now this is something new <sil=0.966> .PERIOD The pointers can be accessed as PTR roll that is possible <sil=0.968> .PERIOD So <sil=0.573> ,COMMA let us see what is happening <sil=0.915> .PERIOD You are being introduced to this operator <sil=0.463> ,COMMA the arrow operator <sil=0.995> .PERIOD So <sil=0.454> ,COMMA here or this only comes if the left side of this operator is a pointer <sil=0.936> .PERIOD So <sil=0.610> ,COMMA it is if suppose I have got some structure and pointer P or PTR is pointing to this structure and it has got different fields <sil=0.982> .PERIOD So <sil=0.624> ,COMMA CGPA is a field <sil=0.961> .PERIOD If I write PTR arrow CGPA <sil=0.567> ,COMMA that means that I am now pointing to this <sil=0.646> ,COMMA I am actually accessing this element of the structure <sil=0.942> .PERIOD Just as suppose this structure is class <sil=0.447> ,COMMA and this element is class one <sil=0.966> .PERIOD I could have written class one dot CGPA <sil=0.958> .PERIOD And here what I have done is I have already done this that PTR <sil=0.631> ,COMMA the pointer PTR was assigned to class 0 and then I did PTR plus plus <sil=0.998> .PERIOD That means <sil=0.485> ,COMMA now where is PTR pointing to <sil=0.857> ?QUESTIONMARK PTR is pointing to class one <sil=0.910> .PERIOD So <sil=0.400> ,COMMA I can also do PTR now <sil=0.404> ,COMMA PTR arrow CGPA <sil=0.920> .PERIOD These two are equivalent <sil=0.542> ,COMMA this and this are equivalent <sil=0.982> .PERIOD So <sil=0.636> ,COMMA here also you can understand this <sil=0.933> .PERIOD So <sil=0.323> ,COMMA let us move ahead <sil=0.995> .PERIOD Similarly <sil=0.362> ,COMMA I can go to another field by PTR slash department code <sil=0.953> .PERIOD I can go PTR <sil=0.531> ,COMMA CGPA <sil=0.646> ,COMMA PTR role <sil=0.946> .PERIOD The symbol this <sil=0.492> ,COMMA this symbol is naturally called the arrow operator <sil=0.920> .PERIOD Example <sil=0.640> ,COMMA you can read this type def <sil=0.935> .PERIOD Now <sil=0.616> ,COMMA here I am defining a type <sil=0.971> .PERIOD The name of the type is complex <sil=0.984> .PERIOD And what is this type complex <sil=0.968> ?QUESTIONMARK It is a structure with real and imaginary parts <sil=0.958> .PERIOD This is what we have <sil=0.617> ,COMMA what we saw earlier <sil=0.918> .PERIOD Next <sil=0.627> ,COMMA I have got a function print complex star A <sil=0.963> .PERIOD What does it mean <sil=0.911> ?QUESTIONMARK A is a pointer to type complex <sil=0.948> .PERIOD So <sil=0.398> ,COMMA print F <sil=0.451> ,COMMA whatever there are two two placeholders A real A imaginary <sil=0.925> .PERIOD So <sil=0.567> ,COMMA why is it possible <sil=0.987> ?QUESTIONMARK A is a pointer <sil=0.913> .PERIOD So <sil=0.540> ,COMMA it is pointing to some complex number <sil=0.918> .PERIOD It is pointing to some complex number <sil=0.550> ,COMMA some complex number whatever that is <sil=0.988> .PERIOD A is a pointer pointing to that and I am going to the real part <sil=0.996> .PERIOD I am printing A real and this one <sil=0.644> ,COMMA this part is A imaginary <sil=0.935> .PERIOD So <sil=0.354> ,COMMA this is what is being done by this piece of function code <sil=0.999> .PERIOD So <sil=0.573> ,COMMA now swap reference <sil=0.994> .PERIOD I have got complex A and complex B <sil=0.946> .PERIOD That is now I am sorry <sil=0.592> ,COMMA it is not being visible here <sil=0.974> .PERIOD There are two A and B <sil=0.975> .PERIOD There are two pointers in complex <sil=0.993> .PERIOD So <sil=0.393> ,COMMA there is TMP <sil=0.907> .PERIOD I take another structure of named TMP of type complex <sil=0.950> .PERIOD And I swap the pointers here <sil=0.904> .PERIOD That is why you can you can work it out <sil=0.917> .PERIOD That means that A was pointing to some structure and that A is pointing to this structure <sil=0.962> .PERIOD And this particular structure is copied to another structure <sil=0.938> .PERIOD TMP and B then B was pointing to another structure <sil=0.917> .PERIOD B and A are swapped <sil=0.939> .PERIOD So <sil=0.563> ,COMMA now B is pointing to this and A is pointing to this <sil=0.917> .PERIOD Next I am making B to point to this <sil=0.953> .PERIOD So <sil=0.325> ,COMMA that is how a swap operation can be done and how we passed on the parameter to this <sil=0.969> .PERIOD So <sil=0.316> ,COMMA the main program can be can define complex X 10 and 3 Y is minus 20 minus 10 because of the resolution it is not visible <sil=0.929> .PERIOD So <sil=0.469> ,COMMA print X and Y then swap reference print X and Y <sil=0.985> .PERIOD Now <sil=0.422> ,COMMA can you guess and tell me whether the swapping will work in this case or not <sil=0.919> ?QUESTIONMARK The answer is yes <sil=0.624> ,COMMA it will work because it is a call by reference <sil=0.986> .PERIOD So <sil=0.475> ,COMMA here I by whatever I am swapping here that will be reflected in the main program also <sil=0.956> .PERIOD So <sil=0.436> ,COMMA here is an example <sil=0.967> .PERIOD So <sil=0.303> ,COMMA let us move ahead <sil=0.938> .PERIOD Now <sil=0.619> ,COMMA one warning is there that when using a structure pointers we should take care of the operator precedence because here we have seen the star symbol as well as dot symbol <sil=0.912> .PERIOD We have seen the star symbol as well as the dot symbol <sil=0.952> .PERIOD Now <sil=0.582> ,COMMA this dot has a higher precedence than star <sil=0.983> .PERIOD What does it mean <sil=0.953> ?QUESTIONMARK It means that if I have got something like PTR role then and star PTR dot role what will happen <sil=0.992> ?QUESTIONMARK This dot has got a higher precedence <sil=0.982> .PERIOD So <sil=0.609> ,COMMA these two are the same thing <sil=0.911> .PERIOD PTR role PTR is a pointer and the role is that particular field and star PTR is what <sil=0.868> ?QUESTIONMARK star PTR is the star PTR is the that particular structure and I am going to the role field of that structure <sil=0.954> .PERIOD So <sil=0.536> ,COMMA star PTR dot role that is this one equivalent <sil=0.927> .PERIOD But if I had done this that would be an error why that would be an error because this dot operator has got higher precedence than this star operator <sil=0.995> .PERIOD So <sil=0.356> ,COMMA basically I will try to get the role field from the pointer PTR but that is not the case <sil=0.904> .PERIOD I cannot get that there is no role field inside the pointer PTR <sil=0.958> .PERIOD The role field is there in the content of the pointer PTR that is star PTR <sil=0.945> .PERIOD So <sil=0.635> ,COMMA I must make first star PTR within bracket then dot role <sil=0.978> .PERIOD So <sil=0.613> ,COMMA this is correct to mean this but this is wrong <sil=0.966> .PERIOD The and the operator arrow enjoys the highest priority among operators <sil=0.929> .PERIOD Among all these operators it has got the highest priority <sil=0.918> .PERIOD So <sil=0.595> ,COMMA we have learnt <sil=0.942> .PERIOD So <sil=0.367> ,COMMA here in this case what will happen <sil=0.913> ?QUESTIONMARK Plus plus PTR arrow role as we have said that this has got the highest priority <sil=0.945> .PERIOD We will go to where the PTR is and go to the role field of that and after that we will increment this plus plus although it is shown as a pre increment <sil=0.955> .PERIOD So <sil=0.340> ,COMMA that will not have higher precedence than the arrow operator <sil=0.907> .PERIOD So <sil=0.430> ,COMMA if I want to first increment the PTR and then get the role then I should do plus plus PTR arrow role will do the intended thing <sil=0.984> .PERIOD This will not do the intended thing <sil=0.959> .PERIOD I hope this is clear this part <sil=0.959> .PERIOD Now structures and functions <sil=0.942> .PERIOD Structures can be passed as argument to a function and a function that we have already seen a function can also return a structure <sil=0.987> .PERIOD So <sil=0.509> ,COMMA we have seen that using two complex numbers how we can do that <sil=0.894> ?QUESTIONMARK So <sil=0.569> ,COMMA here again we look at that example that we have got a complex number complex structure with two fields <sil=0.944> .PERIOD I have now changed the names flow t re and flow t i m and in the main function I am scanning and a dot re real part of a real imaginary part of a then real part of b then imaginary part of b and then I call the function a d b <sil=0.919> .PERIOD What is happening here when I call this a d b <sil=0.911> ?QUESTIONMARK What am I passing a b and here x y <sil=0.996> ?QUESTIONMARK So <sil=0.466> ,COMMA it is a call by value <sil=0.916> .PERIOD So <sil=0.454> ,COMMA here this is copied <sil=0.968> .PERIOD Now struct complex x y there is no problem here it is not like so I just want to add <sil=0.962> .PERIOD So <sil=0.523> ,COMMA I have got two internal variables x and y and t that new structure t is taking x s real part and y is real part then it is I am getting the real part of t and in the imaginary part of t there is nothing here there is an x space <sil=0.987> .PERIOD Then the imaginary part of t I take the imaginary part of x and the imaginary part of y then I am returning this t to c where c is also of type complex since the types are matching I can pass it on over there <sil=0.955> .PERIOD Now this is one way of adding the complex numbers <sil=0.981> .PERIOD Now if this is clear now let us look at an alternative way of using the pointers here I just change this other things are same <sil=0.980> .PERIOD What I am doing here is I have called them now passing the address now I am passing the pointers in the earlier case I was passing the value here and now I am passing the pointers I am passing address of a address of b and address of c <sil=0.957> .PERIOD Now inside this add function what am I doing <sil=0.979> ?QUESTIONMARK I am taking x and y <sil=0.933> .PERIOD So <sil=0.557> ,COMMA these are pointers I am taking them and t is real so t is a type pointer so t sorry so t is a pointer that is pointing to another structure of the type complex and t is r e t arrow r e means the real field of this t will be taking the real part of x c x and real part of y <sil=0.931> .PERIOD So <sil=0.388> ,COMMA here x plus y the sum will come this is the real part of x and real part of y will come here and here the imaginary part here the imaginary part of x and y will be added <sil=0.964> .PERIOD Now when here I am not returning any t because this t is nothing but this c <sil=0.943> .PERIOD So <sil=0.618> ,COMMA this t and c are mapped it is a call by reference <sil=0.926> .PERIOD So <sil=0.413> ,COMMA c is also actually pointing over here so I get the result here <sil=0.956> .PERIOD So <sil=0.633> ,COMMA this is another way in which in structures we can use pointers also <sil=0.992> .PERIOD So <sil=0.470> ,COMMA these are relatively more advanced aspects and you will gradually practice this and we will get familiar <sil=0.934> .PERIOD Thank you <sil=0.944> .PERIOD So <sil=0.335> ,COMMA we have started our discussion on a specific programming language that is C and once again I repeat that a C program will be constituted of some valid words of the C language just as the an English sentence must be constituted with valid English words similarly for C and must be every language has got a grammar <sil=0.942> .PERIOD So <sil=0.633> ,COMMA C has got a very strict grammar and in his statement that is written in C that is not adhering to that grammar will not be accepted by the compiler <sil=0.965> .PERIOD The compiler will reject it saying that it is a syntax error or grammatical error <sil=0.996> .PERIOD So <sil=0.512> ,COMMA before going further into discussions on C briefly let us look at the history of C <sil=0.991> .PERIOD It was originally developed in 1970 by Dennis Richie and his book Kiewals also referred to you at 80 anti bell labs and it become very popular by the mid 1980s because it was the compilers <sil=0.929> .PERIOD Now <sil=0.618> ,COMMA a language a computer language cannot be popular cannot be used unless there is a compiler for it <sil=0.997> .PERIOD So <sil=0.592> ,COMMA it took some time although it was developed in 70s but many compilers for different platforms for work stations for PCs for different platforms were made available by mid 1980s and this became very popular and there were some standardizations that also took place <sil=0.924> .PERIOD Now <sil=0.496> ,COMMA given that we the let us look at the structure of a C program let us look at the structure of a C program here every C program will consist of one or more functions one or more functions <sil=0.980> .PERIOD One of the functions will be given the name main which is the function <sil=0.994> .PERIOD Now <sil=0.445> ,COMMA I in the last lecture I said that there should be at least one function if nothing else is there even if the program is so simple that I do not need any submachines <sil=0.905> .PERIOD In that case I can do it with only one simple function and that function has to be named main and if there be a number of say for example sub functions or submachines in that case also there has to be one program which has to be called the main and the rest can be given some other names <sil=0.901> .PERIOD The program will always begin by executing the main function <sil=0.926> .PERIOD So <sil=0.640> ,COMMA once again let us go to the diagram that we had used in the last lecture say I have got a program which has got only one function very simple then this function will be called main and no other sub functions are there it will take some inputs whatever the inputs are here will process that and the output will be made available <sil=0.938> .PERIOD Now <sil=0.626> ,COMMA suppose I have got two submachines required for this one here and after that another one <sil=0.910> .PERIOD So <sil=0.328> ,COMMA this submachine will do something then this submachine will do and then will come out and this is the output and there is some input coming in here these are the inputs and there are some submachines but I have got one machine which is the main this is again the main <sil=0.932> .PERIOD So <sil=0.382> ,COMMA although I am taking help of the submachines I have to first enter the main function and then from the main function I can enter here and go somewhere else and ultimately I will have to come out through the main function <sil=0.988> .PERIOD So <sil=0.339> ,COMMA we cannot escape the main function <sil=0.944> .PERIOD So <sil=0.644> ,COMMA the main will be there and typically we write the main any C body within two curly braces here whatever I am drawing as a diagram that is equivalent to these two curly braces inside this whatever is written is a C program whatever I write here whatever C program I want to write I have to write within these two curly braces I will come back to this in a moment <sil=0.950> .PERIOD So <sil=0.563> ,COMMA there has to be one function called the main and the program will always begin by executing the main function <sil=0.926> .PERIOD Each function must contain a heading which consists of the function name followed by something application say followed by an optional list of arguments I will explain that later <sil=0.996> .PERIOD Let us again come back to this that I have got a function I have got a program which has got one function whose name is main and I have got another function whose name is say add and there is another function whose name is find is a readable find average <sil=0.938> .PERIOD Let me let me this is a little confusing let me rename this I name it as divide sum take the example of our simple finding average all right I want to find average <sil=0.914> .PERIOD So <sil=0.536> ,COMMA what are the subtasks one is I have to read the numbers say read say ABC that reading suppose I am doing here this read ABC is here one after that I am doing add ABC say adding ABC is being done by this submachine say and therefore <sil=0.345> ,COMMA I have to give a name to this submachine that this submachine is inside the body of this submachine I will actually do the addition <sil=0.443> ,COMMA but the name of the submachine should be expressive of what this submachine or the function is supposed to do <sil=0.994> .PERIOD Similarly <sil=0.448> ,COMMA after I do that then I divide sum right I will divide sum by 3 by whatever 3 here in this case <sil=0.930> .PERIOD So <sil=0.490> ,COMMA that is being done by this submachine this is too simple these are two simple submachine <sil=0.474> ,COMMA but this is being done by this submachine <sil=0.985> .PERIOD So <sil=0.561> ,COMMA they each of them has to be given some name each of the functions including name has to be given some name <sil=0.977> .PERIOD Now <sil=0.570> ,COMMA along with that there is another point that has been mentioned here there is the argument each of these functions must have a space where I can write the arguments <sil=0.961> .PERIOD Right now I am not writing anything on main <sil=0.362> ,COMMA but say when I say what is these arguments if I just consider this separately all right any function separately any function if I consider separately now this function will have some inputs and some outputs what are the inputs and what are the outputs suppose the name of this function is my function <sil=0.966> .PERIOD Then this function will have some arguments which are given within this parenthesis and suppose these are a and b are two variables which are read by this and c is a variable that is output by this <sil=0.912> .PERIOD So <sil=0.479> ,COMMA the name of this function should be associated with the names of the variables which are taken as input or is supplied as output by this function these are called arguments <sil=0.985> .PERIOD We will come to this when we discuss some other very important properties of functions <sil=0.558> ,COMMA but for the time being just remember that a function must have a name and there should be some place for writing the arguments often we will find that a function like main suppose I am writing a function which will simply print a particular line <sil=0.905> .PERIOD So <sil=0.393> ,COMMA then inside the body of the function I just want to print or say print my name is something something whatever <sil=0.909> .PERIOD So <sil=0.446> ,COMMA my name just say my name now this function whenever it is entered it will just print my name it is not requiring any values to be passed <sil=0.403> ,COMMA but still then I will have to put this parenthesis with the name although I may keep the inside of this parenthesis blank <sil=0.927> .PERIOD So <sil=0.472> ,COMMA a function in order to a valid function in c there is a c rule that in order to have a valid function a function must have a name and a place for the arguments <sil=0.928> .PERIOD So <sil=0.436> ,COMMA a function heading is the function name followed by an optional list of arguments enclosed in parenthesis like this this optional because it can be blank and there are these other things that there will be some argument declarations etc will come to this particular part later <sil=0.516> ,COMMA but before that we have to understand a compound statement <sil=0.999> .PERIOD What is a compound sentence say simply in English if we consider you know that a simple sentence has got only one principle verb principle finite verb <sil=0.908> .PERIOD However <sil=0.367> ,COMMA I can have a compound sentence like a boy went to school and his father was happy say <sil=0.971> .PERIOD So <sil=0.494> ,COMMA here there are two sentences his father was happy and a boy went to school these are two simple sentences and we are connecting them with an aunt here alright <sil=0.921> .PERIOD So <sil=0.444> ,COMMA these are compound sentence similarly we can have complex sentence and all those here the idea is similar <sil=0.528> ,COMMA but not exactly the same <sil=0.902> .PERIOD I am saying that a function is a machine which has got a name like say add and some parameters a b c a b and the third parameter is some that means it will take a as input b as input and will produce some <sil=0.482> ,COMMA but here I write a number of c statements a number of c statements are written over here <sil=0.980> .PERIOD Each of these c statement is a statement and all these together are together forms a compound statement ok <sil=0.946> .PERIOD Whenever we find more than one c statement working together that will be a compound statement <sil=0.974> .PERIOD So <sil=0.494> ,COMMA here the entire function add will be if it consists of a number of statements then it is a compound statement in the default case in the very trivial case when the program consists of only one statement then also we can call it a compound statement <sil=0.470> ,COMMA but with only one statement ok <sil=0.906> .PERIOD So <sil=0.441> ,COMMA next each compound statement is enclosed within a sorry is enclosed within a pair of braces like this this is called braces this is called parenthesis and this is called braces right <sil=0.975> .PERIOD The braces may contain combinations of elementary statements at single one or other compound statements ok <sil=0.900> .PERIOD Now <sil=0.468> ,COMMA once again let us see till now I was drawing the I was drawing the machine as this right I was drawing it as a rectangle now I will move towards more towards c <sil=0.929> .PERIOD So <sil=0.396> ,COMMA I will say that this boundary will be specified in c as this sort of boundary whatever is here is within this parenthesis <sil=0.905> .PERIOD Now <sil=0.568> ,COMMA each of them each this each of this braces I mean inside this braces we will have some statements it can be an elementary statement like say a as in 20 or maybe more number of statements <sil=0.933> .PERIOD Now <sil=0.369> ,COMMA each of the c statements are delimited by a semicolon this is very important this you must remember each of these are delimited by semicolon <sil=0.911> .PERIOD If I do not write the semicolon the sentence is not completed just like in English we have to write a sentence and we have to complete it by a full stop right it rains very simple sentence it rains and then there is a full stop here <sil=0.910> .PERIOD Similarly <sil=0.562> ,COMMA in c the end of one single elementary statement or a set of statements is pointed out by semicolon all right otherwise it will be ambiguous can be a problem like for example <sil=0.448> ,COMMA if I write a 20 b 15 and I forget the semicolon if I I can I am writing one of another because that is nice to write one of another <sil=0.926> .PERIOD But <sil=0.592> ,COMMA if I write them side by side that is also equivalent <sil=0.632> ,COMMA but if I put semicolons here the compiler will understand that this is a one statement this is another statement <sil=0.999> .PERIOD But <sil=0.643> ,COMMA if I do not give the semicolon here for example <sil=0.583> ,COMMA I write a 20 b 15 then the compiler will be in the problem because it does not know what it is supposed to assign 20 or 20 b or whatever is it possible to assign 20 b many things will come <sil=0.988> .PERIOD So <sil=0.325> ,COMMA we must be very careful about completing the statements with semicolon <sil=0.965> .PERIOD So <sil=0.356> ,COMMA the braces may contain combinations of elementary statements and other compound statements <sil=0.938> .PERIOD Now <sil=0.464> ,COMMA there is another very important thing called commands whenever you write programs you must be generous of writing comments <sil=0.977> .PERIOD Now <sil=0.320> ,COMMA what are these comments <sil=0.887> ?QUESTIONMARK Commensure statements which are not which are not converted by the compiler to machine language <sil=0.913> .PERIOD But <sil=0.454> ,COMMA then why do we write it <sil=0.925> ?QUESTIONMARK The reason is that whenever we write a complicated or a large enough program the presence of the comments enables us or enables suppose I have written a program it will enable somebody else to understand the program <sil=0.944> .PERIOD So <sil=0.447> ,COMMA if I write something like say I am again I am not going to a complicated example as yet I am remaining with that finding the average of the numbers <sil=0.989> .PERIOD But <sil=0.368> ,COMMA suppose I am doing I am doing it in two steps <sil=0.948> .PERIOD Say I do I am writing I am just doing something like a assigned 20 b assigned 15 sum assigned a plus b and then c assigned 25 sum assigned sum plus c <sil=0.981> .PERIOD Now <sil=0.629> ,COMMA when I write this somebody may this rather too simple but somebody may say what am I doing here at both the places I am doing some <sil=0.949> .PERIOD So <sil=0.320> ,COMMA that somebody else does not get confused I can write something like this <sil=0.916> .PERIOD Let me just check the syntax here yes I was right <sil=0.987> .PERIOD So <sil=0.440> ,COMMA I can write say a assigned 20 b assigned 15 note the semicolon that I am putting after every statement sum is equal to a plus b a plus b and here I can put in a comment say adding first two numbers <sil=0.994> .PERIOD I am ending this with this symbol this is again I am doing a bad job here <sil=0.986> .PERIOD Say I write numbers and then I put this sort of symbol <sil=0.995> .PERIOD So <sil=0.374> ,COMMA here you see I put this and here the reverse this whatever I write in between that is assumed by the compiler to be a common statement <sil=0.900> .PERIOD So <sil=0.317> ,COMMA the compiler need not convert this into machine code <sil=0.950> .PERIOD So <sil=0.399> ,COMMA here again I can write later say c s sorry c assigned 25 and sum equals sum plus c <sil=0.993> .PERIOD Now <sil=0.587> ,COMMA I can explain that adding whatever I want I can write in any form adding third number to sum and put this now I am sorry here always I am making I am not being able to manage the space it should be there should be a space in between <sil=0.944> .PERIOD So <sil=0.305> ,COMMA I will have to write third number to sum and I put this end of comment <sil=0.956> .PERIOD Now <sil=0.527> ,COMMA this part will not be compiled <sil=0.916> .PERIOD So <sil=0.585> ,COMMA for any program when we write as the program becomes more and more complicated we should be generous about writing the comments that will also help us say you have written a program today and you want to look at it after say one month and see what you did such comments will be will be helping you to understand what you did or somebody else of course to understand what you did right <sil=0.932> .PERIOD So <sil=0.566> ,COMMA for examples let us see here I have got a simple thing a assigned b plus c <sil=0.986> .PERIOD So <sil=0.502> ,COMMA here you see add two numbers between these two this and the end of comment is this all right ok <sil=0.929> .PERIOD Now <sil=0.570> ,COMMA let us look at a simple c program therefore <sil=0.462> ,COMMA now this part I will be explaining separately <sil=0.507> ,COMMA but before that let us look at this part of the code is a very simple program simplest possible program what it does it simply prints our first look at c program this line as is will be printed as is will be printed where will it be printed this will be printed on the screen or on the printer or on some other file where will it be printed <sil=0.947> .PERIOD Here we are writing another statement hash include stdi <sil=0.929> .PERIOD h this stdi <sil=0.973> .PERIOD h means standard input output std for standard <sil=0.923> .PERIOD So <sil=0.592> ,COMMA it is stdi is standard input output <sil=0.935> .PERIOD Now <sil=0.314> ,COMMA if nothing is specified then the standard input is our keyboard by default it is the keyboard and the output by default is the screen <sil=0.948> .PERIOD So <sil=0.388> ,COMMA when I write this then when I write printf that means this line will be printed on the screen ok that is the meaning of stdi <sil=0.997> .PERIOD h now this single piece of simple program has got many things to illustrate <sil=0.952> .PERIOD This term hash include is an instruction to the compiler that you need not convert it to the machine language <sil=0.529> ,COMMA but before you convert the program to the machine language please do this what is doing this please include stdi standard io <sil=0.908> .PERIOD h now what is this stdi <sil=0.924> .PERIOD h in order to understand this you have to know what a library is <sil=0.948> .PERIOD Now any programming environment any programming environment provides you with a library of functions <sil=0.992> .PERIOD c provides you a library of functions ok <sil=0.938> .PERIOD Now this library of functions and library of other packages which are library of functions or codes that is already there already there <sil=0.914> .PERIOD Now <sil=0.332> ,COMMA so I am going to write a program here and here there is a library and in that library there are many things here all right <sil=0.919> .PERIOD And one such thing is stdi and all these libraries files have got an extension dot h why that is that we will see later <sil=0.926> .PERIOD Now when I am writing this part of the program if I say hash include within this corner brackets stdi <sil=0.994> .PERIOD h that means whenever I am writing this program whatever program I have written that will be converted to the machine code that will be ultimately converted to the machine code while doing that this before doing that this stdi part must be included or must be included some of the information must be included that will tell me that well you see whenever you are doing this printf that printf will be done will have to be done on standard output and what is that standard output the print it is the printer ok <sil=0.960> .PERIOD So <sil=0.497> ,COMMA that is the purpose of hash include there is a pre processing statement compiler pre processing statement <sil=0.904> .PERIOD Now <sil=0.413> ,COMMA I had said that every language has got some of its own vocabulary <sil=0.921> .PERIOD Now <sil=0.565> ,COMMA in English we now you understand whenever I write print or write these words can be meaning to you in English in C we write it as printf this is a special word of C why this F that is a meaning for that that is in C wherever we write wherever we write we consider that as if we are writing in a file say in your office or in your work desk whenever you write something you write it on a piece of paper and put it in a file in C we consider every input or every output device to be a file and this F stands for file as if I am printing on the file which file the printer file ok <sil=0.939> .PERIOD Now <sil=0.364> ,COMMA the next class we will start with this and we will describe some of the other Hebrew like statements here which will from which we will go ahead ok <sil=0.910> .PERIOD Thank you <sil=0.968> .PERIOD So <sil=0.525> ,COMMA in the last lecture we had seen how we can represent algorithms and we had mentioned particularly two different ways <sil=0.945> .PERIOD One is flow chart which is a diagrammatic way of representing the different steps and also we saw English like form which is known as a pseudo code <sil=0.970> .PERIOD It is not exactly why is it called a pseudo code <sil=0.868> ?QUESTIONMARK It is called a pseudo code because it is not exactly the code that can run on the computer <sil=0.348> ,COMMA but it is a way close to that and by which we can express ourselves and from which we can also convert to the computer language <sil=0.948> .PERIOD Now <sil=0.569> ,COMMA we had given a few examples of such flow charts for a few problems <sil=0.338> ,COMMA but you can and I strongly encourage you to take up more problems from textbooks or some mathematical problems that you may encounter and try to solve them <sil=0.406> ,COMMA try to draw the flow chart of those <sil=0.971> .PERIOD Now <sil=0.348> ,COMMA coming to the context of the books <sil=0.392> ,COMMA here are some of the suggested books <sil=0.347> ,COMMA but I will start from the end that is any book on C will serve your purpose <sil=0.930> .PERIOD You can take any good book on C language and try on that and the number one that is C programming by Carnegie Nenrichi is the most authentic book for C programming <sil=0.415> ,COMMA C language for that matter and but I suspect that for some of you you may find it to be a little difficult <sil=0.958> .PERIOD Therefore <sil=0.440> ,COMMA middle path would be this second book programming with C by B <sil=0.934> .PERIOD S Godfrey which is Shom Soutland series <sil=0.974> .PERIOD So <sil=0.321> ,COMMA and this second book has got a number of examples <sil=0.386> ,COMMA solved examples and examples given as exercises <sil=0.927> .PERIOD So <sil=0.599> ,COMMA I think that will be a very good starting point <sil=0.994> .PERIOD Now <sil=0.496> ,COMMA having said that so <sil=0.433> ,COMMA what we have right now is we have some algorithm <sil=0.390> ,COMMA and from that algorithm we want to come to a program <sil=0.909> .PERIOD Now <sil=0.591> ,COMMA algorithm is the sequence of steps that might be in our mind also <sil=0.945> .PERIOD So <sil=0.366> ,COMMA I know how exactly I want to do that <sil=0.506> ,COMMA I and I express it in some way <sil=0.550> ,COMMA expressed in some way and that is understandable <sil=0.910> .PERIOD Now <sil=0.433> ,COMMA you know about two ways <sil=0.407> ,COMMA one is the flow chart <sil=0.414> ,COMMA now there is a pseudo code which expresses how what are the steps that have to be taken <sil=0.986> .PERIOD Now <sil=0.471> ,COMMA from this algorithm to a programmer <sil=0.642> ,COMMA program is a task of a programmer <sil=0.923> .PERIOD Programmer is a person who knows how to write programs <sil=0.901> .PERIOD So <sil=0.440> ,COMMA from the algorithm to the program <sil=0.438> ,COMMA whatever language the program might be that has to be translated <sil=0.924> .PERIOD Now <sil=0.631> ,COMMA the key point to understand is that this algorithm I can express in any particular way <sil=0.931> .PERIOD However <sil=0.529> ,COMMA that program must be written in a language that is understood by a computer <sil=0.914> .PERIOD So <sil=0.453> ,COMMA a programmer is essentially a person sitting here who is translating the algorithm or the steps as expressed in some informal way into a form that is understood by the computer <sil=0.991> .PERIOD And this language just like any other language will have its own vocabulary <sil=0.645> ,COMMA will have its own grammar <sil=0.958> .PERIOD Now <sil=0.511> ,COMMA here comes the question what is the language that is understood by a computer <sil=0.901> .PERIOD Now <sil=0.405> ,COMMA in order to understand that we have to look at what is there inside a computer <sil=0.992> .PERIOD Now <sil=0.324> ,COMMA all of you many of you may be knowing it from your school days <sil=0.465> ,COMMA but just it is a quick revision <sil=0.972> .PERIOD It is a machine <sil=0.531> ,COMMA a computer is nothing <sil=0.569> ,COMMA but a machine which can accept data <sil=0.527> ,COMMA process them and output the results <sil=0.917> .PERIOD Now <sil=0.381> ,COMMA so there is an input device which can be a keyboard <sil=0.567> ,COMMA nowadays it can be speech <sil=0.341> ,COMMA a microphone <sil=0.518> ,COMMA it can be joy stick <sil=0.515> ,COMMA it can be many things <sil=0.331> ,COMMA right <sil=0.919> .PERIOD Mouse is also another one <sil=0.968> .PERIOD And ultimately we have got the computer here which consists of the CPU and the main memory and the storage peripherals <sil=0.340> ,COMMA right <sil=0.965> .PERIOD So <sil=0.471> ,COMMA this is the actual part of the computer <sil=0.924> .PERIOD Now <sil=0.594> ,COMMA the data comes over here <sil=0.488> ,COMMA it is processed here and the output is sent to the user <sil=0.981> .PERIOD So <sil=0.330> ,COMMA the user is on this side <sil=0.338> ,COMMA the user is also on this side <sil=0.966> .PERIOD So <sil=0.650> ,COMMA this side is also the user <sil=0.312> ,COMMA user and this side is also the user <sil=0.460> ,COMMA right <sil=0.947> .PERIOD Now <sil=0.409> ,COMMA there are a couple of important things to understand here <sil=0.951> .PERIOD Typically <sil=0.520> ,COMMA we tell the computer how a problem is to be solved and that is the sequence of steps that we do and whatever in sequence of steps that is specified <sil=0.991> .PERIOD Now <sil=0.529> ,COMMA whatever sequence we specify that is remembered by the computer in its memory <sil=0.980> .PERIOD Now <sil=0.607> ,COMMA the memory can be actually it is stored in the computer <sil=0.633> ,COMMA secondary memory <sil=0.567> ,COMMA we will come to that later <sil=0.945> .PERIOD But the key point to think about is that this entire box is nothing but an electronic machine <sil=0.552> ,COMMA right <sil=0.981> .PERIOD Electronic machine and consequently <sil=0.611> ,COMMA it only understands 1 San Zeros <sil=0.952> .PERIOD So <sil=0.624> ,COMMA whatever we have to express <sil=0.362> ,COMMA we have to express that using 1 San Zeros <sil=0.978> .PERIOD So <sil=0.612> ,COMMA this is the first thing a computer being an electrical machine understands only once and zeros <sil=0.907> .PERIOD Because it is an electric machine <sil=0.459> ,COMMA it only understands whether a particular switch is on or off <sil=0.393> ,COMMA right <sil=0.915> .PERIOD That is what it can at best understand <sil=0.955> .PERIOD Therefore <sil=0.337> ,COMMA whatever we have to express <sil=0.307> ,COMMA we have to express it in the form of 1 San Zeros <sil=0.955> .PERIOD So <sil=0.590> ,COMMA consequently say a <sil=0.306> ,COMMA b <sil=0.530> ,COMMA all these alphabets <sil=0.640> ,COMMA small a <sil=0.356> ,COMMA everything will have to be represented in the form of 1 San Zeros <sil=0.985> .PERIOD So <sil=0.628> ,COMMA maybe a just hypothetical is not to be taken to be accurate <sil=0.902> .PERIOD I am just saying that suppose 0 0 0 1 0 0 1 0 is a pattern that represents a <sil=0.938> .PERIOD So <sil=0.535> ,COMMA similarly <sil=0.326> ,COMMA maybe 0 0 1 0 0 1 0 this pattern represents b and maybe 1 0 0 1 0 0 1 0 represents small a <sil=0.997> .PERIOD In that way <sil=0.639> ,COMMA everything will be represented into a pattern of 1 San Zeros and you know might be knowing some of you that each of these 1 and 0's these are known as bits <sil=0.958> .PERIOD Bit stands for binary digit <sil=0.394> ,COMMA binary digit <sil=0.950> .PERIOD So <sil=0.514> ,COMMA B E I for binary and bit that last T for this <sil=0.999> .PERIOD So <sil=0.412> ,COMMA binary digit forms bits <sil=0.918> .PERIOD So <sil=0.473> ,COMMA it is a sequence of bits <sil=0.951> .PERIOD So <sil=0.480> ,COMMA anything anything is represented in a computer as a sequence of bits or we often say bit pattern <sil=0.927> .PERIOD Now <sil=0.609> ,COMMA just 1 San Zeros gives rise to a new number system that is known as the binary number system <sil=0.948> .PERIOD So <sil=0.596> ,COMMA that leads to the binary number system might be some of you might be aware of this binary number system where I have got only 2 elements 0 and 1 <sil=0.946> .PERIOD I have to do now in decimal vis-à-vis if I just consider that regularly we use decimal number system where we have got from 0 to like that up to 9 and I whatever I express I express as a combination of this <sil=0.926> .PERIOD Now <sil=0.458> ,COMMA in binary number system everything is represented just by 0 and 1 <sil=0.984> .PERIOD So <sil=0.528> ,COMMA quickly let us look at what a binary number system is that suppose I have got a 4 bit number <sil=0.958> .PERIOD So <sil=0.455> ,COMMA there are 4 positions 1 2 3 4 and suppose so <sil=0.365> ,COMMA comparally let us think of 4 digit number 4 digit number remember that in decimal we call it digit and in binary we call it bit so <sil=0.315> ,COMMA if I have 7 8 3 2 now all of you know what is the value of this number each of these plays have got a weight which are known as play I mean weights of the different places <sil=0.936> .PERIOD So <sil=0.580> ,COMMA this is 10 to the power 0 this is 10 to the power 1 this is 10 to the power 2 this is 10 to the power 3 <sil=0.914> .PERIOD 0 weight 1 weight 2 weight 3 weight <sil=0.973> .PERIOD So <sil=0.453> ,COMMA this number is actually meaning 7 times 10 to the power 3 that is 7000 8 times 10 to the power 2 that is 800 3 times 10 to the power 1 that means 30 and 2 times 10 to the power 0 that is 2 <sil=0.992> .PERIOD So <sil=0.366> ,COMMA that is giving us 7 8 3 2 it will be easier to understand with this analogy for example <sil=0.578> ,COMMA here I have got something like 1 0 1 1 <sil=0.949> .PERIOD Now <sil=0.495> ,COMMA unlike so <sil=0.462> ,COMMA here also the weights are 0 1 2 3 but the base here was 10 <sil=0.986> .PERIOD So <sil=0.315> ,COMMA here it is 2 to the power 0 it is binary here <sil=0.985> .PERIOD So <sil=0.518> ,COMMA it is 2 to the power 1 2 to the power 2 2 to the power 3 <sil=0.976> .PERIOD Here the base is 2 here the base was 10 that is why this is a binary system this is a decimal system <sil=0.951> .PERIOD So <sil=0.457> ,COMMA if I have this pattern 1 0 1 1 then I can straightway convert it to an equivalent decimal like what does this mean <sil=0.997> .PERIOD So <sil=0.527> ,COMMA I can take it there is a 1 here 1 times 2 to the power 3 that is what 8 then 0 times 2 to the power 2 that is 0 1 times 2 to the power 1 that means 2 1 times 2 to the power 0 that is 1 <sil=0.990> .PERIOD So <sil=0.533> ,COMMA the value of this will be 11 right <sil=0.978> .PERIOD So <sil=0.612> ,COMMA this is the binary number system <sil=0.909> .PERIOD So <sil=0.608> ,COMMA there are ways and means by which I can convert from a binary number system to a decimal system from a decimal system to a binary system that is possible right <sil=0.930> .PERIOD So <sil=0.629> ,COMMA if you want to see that I do not want to go into that because many of you have done it in school <sil=0.915> .PERIOD So <sil=0.333> ,COMMA let us leave it for the time being but what is more important is to know that a computer in a computer everything is represented in the binary system as a bit pattern of 1s and 0s <sil=0.915> .PERIOD Since <sil=0.535> ,COMMA everything is expressed as binary number system <sil=0.919> .PERIOD So <sil=0.315> ,COMMA if I remember the say we had something like this let us not take max let us take some equals some plus number 1 <sil=0.995> .PERIOD This is something we saw in our earlier lecture something like that <sil=0.977> .PERIOD Now <sil=0.443> ,COMMA this is a statement how do I represent it to a computer <sil=0.972> ?QUESTIONMARK In order to represent this to a computer say I want to say say this is an you have to do some addition and some assign some you have to copy it somewhere or write it somewhere all right <sil=0.967> .PERIOD See or I just take this simple part add some with number some plus number <sil=0.941> .PERIOD How do I express that <sil=0.947> ?QUESTIONMARK Everything has to be expressed say this number will be some patterns say 0 0 0 0 1 1 0 0 something of that sort some will be something 0 1 1 0 0 1 1 0 0 whatever and plus we will also have some code 0 1 1 0 1 1 0 1 1 1 might be <sil=0.986> .PERIOD Suppose this is add and suppose 0 1 1 1 0 0 1 1 1 is subtract <sil=0.982> .PERIOD Similarly <sil=0.644> ,COMMA there will be a similarly <sil=0.422> ,COMMA there will be some code of for multiplication etcetera <sil=0.921> .PERIOD Now <sil=0.528> ,COMMA since I am here I am the user and I am also the programmer and here is my computer here is my computer and I have to translate my thoughts my algorithm in a way so that a computer understands I have to translate that algorithm or the flowchart into this pattern of 0s and 1s because that is the only thing that it understands <sil=0.989> .PERIOD The language that the computer understands is known as the machine language <sil=0.985> .PERIOD So <sil=0.494> ,COMMA let me once again draw another picture here <sil=0.903> .PERIOD So <sil=0.479> ,COMMA here I have got my machine all right I have got a machine here nice looking machine and here is the programmer <sil=0.986> .PERIOD The programmer understands flowchart or the programmer understands English like pseudo code but this one only understands patterns of 0s and 1s <sil=0.956> .PERIOD Patterns of 0s and 1s and this is a language it understands and this programmer understands a language of flowchart for example <sil=0.982> .PERIOD Now <sil=0.648> ,COMMA this patterns of 0s and 1s that the machine understands this is my machine mc is the machine <sil=0.961> .PERIOD Now <sil=0.500> ,COMMA this machine understands that language is known as the machine language and that machine language is not understood <sil=0.964> .PERIOD If some genius can understand remember all those patterns of 0s and 1s for every possible combination that is a different thing but for normal people it is not it is not it is very tedious it is not possible it is not advisable also <sil=0.963> .PERIOD Therefore <sil=0.330> ,COMMA earlier people had to for small computers it was possible at the very beginning people used to program the computer by setting up different switches and thereby it was being programmed <sil=0.936> .PERIOD But at that time the operations and the capability of the computers were much more limited but once it became larger we are doing much more flexible programming and everything <sil=0.977> .PERIOD It is not no longer possible to remember the machine language <sil=0.929> .PERIOD So <sil=0.356> ,COMMA what is the other alternative <sil=0.860> ?QUESTIONMARK The other alternative is the best alternative would be that on this side I have got my normal language English and if I could directly translate it to machine language <sil=0.907> .PERIOD But there are some problems with that because in English or any natural language that we use many things are often ambiguous <sil=0.964> .PERIOD It is not very clear it can have multiple meanings just I am giving an example go to the bank go to the bank it is an English statement <sil=0.940> .PERIOD Now <sil=0.589> ,COMMA what does this word bank mean <sil=0.957> ?QUESTIONMARK It can mean many things right it can mean the bank where you deposit the money it can mean the river bank etcetera <sil=0.977> .PERIOD So <sil=0.433> ,COMMA therefore <sil=0.554> ,COMMA English language or any natural language is not yet suitable to be translated to the machine language <sil=0.939> .PERIOD So <sil=0.402> ,COMMA instead people thought if we could have some intermediate language <sil=0.967> .PERIOD So <sil=0.311> ,COMMA once again I come here I again draw the the machine here the machine is here and the person is here <sil=0.914> .PERIOD So <sil=0.310> ,COMMA on this side is my natural language like English but which I am not being able to use <sil=0.906> .PERIOD So <sil=0.389> ,COMMA people developed some intermediate language which is close to English but the grammar is much more strict and we cannot allow any ambiguity no ambiguity but it is high level language because it is easier for us to remember it is easier for us to explain <sil=0.963> .PERIOD For example <sil=0.447> ,COMMA if I write this say x equal to p plus q or I write read p <sil=0.998> .PERIOD Now <sil=0.351> ,COMMA this is meaningful this looks like English and I can understand this <sil=0.953> .PERIOD Now <sil=0.576> ,COMMA given a high level language and on this side this machine can only understand machine language <sil=0.914> .PERIOD So <sil=0.576> ,COMMA we need to have some translator some translator which will convert this high level language to the machine language <sil=0.982> .PERIOD And this translator is known as the compiler <sil=0.945> .PERIOD Now <sil=0.417> ,COMMA think of the situation that here is a person suggest forget about the computer high level language think of a person who knows French and here is a person who knows maybe English <sil=0.955> .PERIOD So <sil=0.585> ,COMMA a compiler or an interpreter is something which somebody who will translate from French to English right <sil=0.989> .PERIOD So <sil=0.349> ,COMMA here also depending on what language I am using as the high level language there will be different compilers examples of high level languages are C which will be discussing or taking as an example in our course it can be Java it can be Fortran it can be Python all right <sil=0.988> .PERIOD We can have many other languages that are coming up now a days other languages also coming up <sil=0.939> .PERIOD So <sil=0.594> ,COMMA depending on the language high level language in which we want to express our algorithm we will have to select a suitable compiler <sil=0.943> .PERIOD So <sil=0.642> ,COMMA for C we will need a C compiler for Java we will have to need a Java interpreter all right the same thing the more or less same thing that it will translate the basic function of this is translation <sil=0.973> .PERIOD So <sil=0.371> ,COMMA it will translate from a high level language to the machine language and as you had seen that here all those things will be binary I mean in binary system in the pattern of zeros and ones I have to convert if this machine has to operate with my program this have to process this my program I have to convert it into zeros and ones right <sil=0.960> .PERIOD So <sil=0.592> ,COMMA now here is something more that we have to say now whenever we write a program whenever we write a program what we do here is we write some high level program and that high level program is taken up by a compiler and is converted into a machine language <sil=0.911> .PERIOD Now <sil=0.568> ,COMMA here you have to be a little careful you have to be a little careful that depending on the different machines you can have Pentium machine you can have Apple machine and other things <sil=0.980> .PERIOD So <sil=0.377> ,COMMA depending on what machine you are using you will you may need different compilers for that particular machine <sil=0.909> .PERIOD So <sil=0.433> ,COMMA for the time being let us ignore that thing let us assume that one high level program can be translated by a compiler to a machine language <sil=0.998> .PERIOD So <sil=0.442> ,COMMA there is a program right <sil=0.928> .PERIOD So <sil=0.579> ,COMMA remember what we did in in our earlier cases we had we said find the maximum of 10 numbers and the numbers were 3 10 7 12 5 6 so and so forth right 1 to the power 7 2 1 5 <sil=0.973> .PERIOD So <sil=0.456> ,COMMA out of this I have to find out the maximum <sil=0.957> .PERIOD Now <sil=0.530> ,COMMA through the flow chart or through the pseudo code what did we specify <sil=0.903> ?QUESTIONMARK We specified the sequence of steps <sil=0.918> .PERIOD So <sil=0.576> ,COMMA those sequence of steps that have to be adopted in order to find out the maximum of this is our program and this program will be converted to the machine language <sil=0.987> .PERIOD Now <sil=0.402> ,COMMA this program will run on some data <sil=0.915> .PERIOD This program is a program that can run on this set of data or another set of data say 5 15 16 7 say for 4 data if I just run it for n number of things <sil=0.956> .PERIOD And here the n was 10 <sil=0.435> ,COMMA n was 10 remember what we did earlier and here n is 4 <sil=0.935> .PERIOD The same program should work on both of these <sil=0.955> .PERIOD Therefore <sil=0.457> ,COMMA the program remains the same but here is some data set and here is another data set <sil=0.953> .PERIOD So <sil=0.341> ,COMMA we have got two different data sets <sil=0.982> .PERIOD So <sil=0.646> ,COMMA in order to execute we need both the program and the data ok <sil=0.989> .PERIOD Now <sil=0.461> ,COMMA when we start say our program and the program when we we start with the high level program I am writing H L L is a high level language <sil=0.928> .PERIOD Now <sil=0.302> ,COMMA this by the in the context of passing I am saying this is also known as the source language <sil=0.907> .PERIOD So <sil=0.553> ,COMMA in my lecture often I will be using this term source language <sil=0.958> .PERIOD Source language means or or I will say the I am not I will not say source language I will say source program <sil=0.993> .PERIOD By source program I mean the program that is written in the high level language that will be translated by a compiler to a machine level language machine language ok <sil=0.941> .PERIOD Now <sil=0.393> ,COMMA when we now this is one side <sil=0.947> .PERIOD So <sil=0.539> ,COMMA the machine language has been generated by the compiler <sil=0.947> .PERIOD If my source language is C then I need a C compiler here and I will get the machine language and this machine language is independent of what the source language is it is only dependent on the particular machine on which it is running all right <sil=0.979> .PERIOD So <sil=0.386> ,COMMA the compiler we translate into that machines machine language <sil=0.966> .PERIOD Now <sil=0.530> ,COMMA in my computer diagram we had the CPU here and we had memory right we had memory <sil=0.915> .PERIOD Now <sil=0.432> ,COMMA the memory can be divided into two parts <sil=0.979> .PERIOD One is the RAM and ROM some let me put it three parts <sil=0.940> .PERIOD RAM and ROM are two types of memory two types of memories which are of relatively smaller capacity <sil=0.961> .PERIOD I think this is not very clearly coming <sil=0.952> .PERIOD So <sil=0.587> ,COMMA let me write it clearly <sil=0.941> .PERIOD RAM stands for random access memory and ROM stands for redone memory <sil=0.919> .PERIOD Besides that we have got the secondary memory which is the disk right the disk <sil=0.973> .PERIOD Now <sil=0.356> ,COMMA the machine language after compilation when it is saved I save it and it is saved and stored in the secondary memory all right in the disk <sil=0.907> .PERIOD Now <sil=0.422> ,COMMA when that program will be run <sil=0.917> .PERIOD So <sil=0.322> ,COMMA I have done the compilation and after compilation my program is ready to be executed is ready to run <sil=0.937> .PERIOD Now <sil=0.572> ,COMMA when I run it can I select some pen color sorry <sil=0.988> .PERIOD So <sil=0.407> ,COMMA when I run it from the secondary memory it will go to the RAM and the CPU the program will move to the RAM only when I execute it and the CPU will read that program from the RAM and will execute it ok <sil=0.929> .PERIOD So <sil=0.440> ,COMMA this is a sequence you should remember <sil=0.993> .PERIOD I repeat once again I write the program and type in the program in the machine <sil=0.931> .PERIOD After that I do the compilation after compilation it is converted to the machine language and I save it when I save it it is saved in the secondary memory <sil=0.905> .PERIOD Secondary memory is typically the disk I save it in the secondary memory <sil=0.952> .PERIOD But on execution when I execute it when I run the program then only it goes from the secondary memory to the RAM and the CPU reads from the RAM and executes it all right <sil=0.981> .PERIOD So <sil=0.349> ,COMMA we will be bothering about mostly this RAM and the secondary memory and how that is stored many variables and all those things are stored <sil=0.920> .PERIOD We will in the next lecture we will see how we can gradually move towards encoding our pseudo code to the machine language to the high level language <sil=0.925> .PERIOD So <sil=0.374> ,COMMA summarizing what we discussed in this lecture it is that we have got the pseudo code but on the other side we have got a machine which does not understand the pseudo code <sil=0.983> .PERIOD The machine only understands the patterns of 0s and 1s <sil=0.964> .PERIOD So <sil=0.405> ,COMMA we have to have some something which will convert the pseudo code cannot be directly converted because of lot of ambiguity <sil=0.934> .PERIOD So <sil=0.301> ,COMMA we will have a high level language designed which can be which is unambiguous and which can be converted to the machine code by another system that is a compiler and that compiler is nothing but another more sophisticated program using which you can convert this and keep it taking in the machine language and the machine can then read that machine language program and can execute it <sil=0.917> .PERIOD Now <sil=0.399> ,COMMA we have also seen that a program I mean if we have to run a program we need the program as well as the data both this are stored in this memory part and from which the CPU will be taking that <sil=0.917> .PERIOD Sometimes the data can be fed directly from the input device at runtime <sil=0.946> .PERIOD So <sil=0.400> ,COMMA whenever we say read n whenever we say read n then from the input device somebody will type in the value and that will come from through the CPU into the RAM <sil=0.996> .PERIOD So <sil=0.640> ,COMMA this part we will see later gradually <sil=0.920> .PERIOD Thank you very much <sil=0.933> .PERIOD So <sil=0.614> ,COMMA till now we have looked at we have looked at how in C language how in this C language we can write the identifiers this is becoming a little too thick which identifiers are used for writing the variable names and the constant names <sil=0.953> .PERIOD So <sil=0.554> ,COMMA for example <sil=0.457> ,COMMA pi or some variable names such as sum all those things <sil=0.940> .PERIOD Now <sil=0.511> ,COMMA we have seen what are the rules that the language C imposes on writing the names of variables or constants that is how we can write the identifiers <sil=0.926> .PERIOD Also we have seen that there are different data types like int with stands for integer and float which represents floating point numbers or real numbers and care is used to specify some data which is of type character <sil=0.901> .PERIOD We will see some more examples of this in the course of these lectures <sil=0.937> .PERIOD Now <sil=0.569> ,COMMA we also know that int means integer and whenever a particular variable A is declared to be an integer then typically it also varies from machine to machine and compiler to compiler to bytes or 16 bits are allocated for storing one integer <sil=0.987> .PERIOD Each of these boxes are that I am showing here are 8 bits wide <sil=0.953> .PERIOD So <sil=0.625> ,COMMA there are two such 16 bits for float we will have two more real numbers are stored using 32 bits whereas <sil=0.577> ,COMMA characters are typically stored in 8 bits <sil=0.962> .PERIOD Now <sil=0.613> ,COMMA this is not so sacrosanth as in some machine which is much more powerful and much more accurate having high resolution we can have 32 bits for storing integers 64 bits for storing floating point numbers and characters can be 8 bits or 16 bits <sil=0.939> .PERIOD However <sil=0.486> ,COMMA depending on what is the type declaration the amount of storage the amount of memory that is allocated to a particular variable varies <sil=0.964> .PERIOD We just like int float care we also have got some more like short int all right long int or unsigned int these are also different data types <sil=0.973> .PERIOD We will come across these in the course of this lecture short int means just if in an integer takes two bytes a short int will take one byte if a long int takes 16 by 16 bits that means <sil=0.327> ,COMMA two bytes a long int can be made to consume 4 such bytes or 32 bits <sil=0.593> ,COMMA but still that will be an integer <sil=0.942> .PERIOD So <sil=0.549> ,COMMA in these 4 bytes an integer that will be stored that means <sil=0.409> ,COMMA the integer accuracy will be much larger <sil=0.939> .PERIOD So <sil=0.480> ,COMMA depending on the number of bits I allocate to a particular variable depending on the number of bits suppose I allocate n bits the range of values that I can represent varies <sil=0.941> .PERIOD For example <sil=0.317> ,COMMA if there be n bits then I can go from I can have 2 to the power n distinct values stored <sil=0.912> .PERIOD For example <sil=0.496> ,COMMA if there be 8 bits then the maximum value that I can store is when all these 8 bits are once and that is your knowledge of binary arithmetic will tell you that this will be 2 to the power 8 right that is 256 will be actually 255 right <sil=0.990> .PERIOD So <sil=0.646> ,COMMA 255 and if I make everything 0 if each of them are made 0s all 0s will be 0 right <sil=0.931> .PERIOD So <sil=0.488> ,COMMA I can have the range from 0 to 255 that means <sil=0.520> ,COMMA total 0 to 255 that means <sil=0.401> ,COMMA I can store any of distinct 256 values <sil=0.643> ,COMMA out of 256 values distinct values I can store any one of them <sil=0.907> .PERIOD Now <sil=0.362> ,COMMA if this 8 would have become 16 then my maximum range would be 2 to the power 16 minus 1 all right that is a maximum value that I can store ok <sil=0.969> .PERIOD Now <sil=0.636> ,COMMA signed and unsigned means sometimes in our representation we keep one bit for the sign part in that case of course <sil=0.564> ,COMMA the range decreases <sil=0.977> .PERIOD But if we go for unsigned then we remaining within say 16 bits or 2 bytes I can have a larger representation <sil=0.969> .PERIOD We will encounter these details as and when we need them ok <sil=0.957> .PERIOD Now <sil=0.352> ,COMMA let us come to some examples of the data types <sil=0.925> .PERIOD You can see integer 0 25 minus 156 all these are examples of integers <sil=0.994> .PERIOD Now <sil=0.614> ,COMMA here I am for the first time showing some characters <sil=0.953> .PERIOD Now <sil=0.450> ,COMMA the character values are you see the character values have got something special <sil=0.967> .PERIOD See I am declaring some variable care as type care my variable I name that my var <sil=0.915> .PERIOD My var is of type character and I assign I want to assign to my var I want to assign that my variable will will hold the character a <sil=0.949> .PERIOD Now <sil=0.500> ,COMMA when I am assigning a character then I have to put a single quote around this <sil=0.978> .PERIOD For example <sil=0.552> ,COMMA I had another variable int your var your var is another variable which is of type int <sil=0.922> .PERIOD So <sil=0.484> ,COMMA if I assign into that in your var then I can straight away say an integer value 10 <sil=0.982> .PERIOD But when I write on to a character a character constant has to be always encaps I mean encapsulated within two single quotes right as here <sil=0.952> .PERIOD Now <sil=0.482> ,COMMA this single code within this single code is a character slash what about this this is just single code single code that means within that there is a blank <sil=0.978> .PERIOD So <sil=0.439> ,COMMA that means <sil=0.337> ,COMMA I am say if I say my var is assigned this that means my var will be assigned a blank character <sil=0.907> .PERIOD Now <sil=0.383> ,COMMA you should remember that each of these characters that we type in have got an ASCII value each of these characters have got an ASCII value what is ASCII <sil=0.938> ?QUESTIONMARK ASCII stands for American standard code for information interchange American standard code for information interchange <sil=0.995> .PERIOD Now <sil=0.475> ,COMMA according to this table for every English character a b c d and capital A b c d and 1 2 2 everything up to 9 all of them have got some particular code American standard code and that is accepted in all the computers <sil=0.930> .PERIOD So <sil=0.595> ,COMMA whenever I type an a when I strike the key on the keyboard when I strike the key a whenever I strike a then actually when I as I press a what goes inside the computer is an ASCII code of a <sil=0.928> .PERIOD Now <sil=0.331> ,COMMA this ASCII code of a will be stored there for and the code for b the code for capital A are all distinct <sil=0.942> .PERIOD So <sil=0.334> ,COMMA whenever I type in a character from the keyboard a particular ASCII code goes in whenever I assign some value to a variable for example <sil=0.613> ,COMMA as I did right now my var assigned a this means that my var will now have the ASCII code of a all right it will have the ASCII code of a <sil=0.968> .PERIOD Now <sil=0.558> ,COMMA the third variety that is these three are very common float for example <sil=0.340> ,COMMA 23 <sil=0.955> .PERIOD 54 or minus 0 <sil=0.926> .PERIOD 00345 25 <sil=0.947> .PERIOD 0 or I can also write it in this way 2 <sil=0.966> .PERIOD 5 E 12 what that what does this mean this means it is 2 <sil=0.963> .PERIOD 5 times 10 to the power 12 what does this mean this means 1 <sil=0.988> .PERIOD 234 times 10 to the power minus 5 because it is E minus 5 here it is E 12 I can use capital E or small E that really does not matter these are the examples of floating point constants <sil=0.957> .PERIOD So <sil=0.314> ,COMMA if I have a variable like float X and I assign I can assign X to be say X is 1 Y is 1 Z is another one <sil=0.958> .PERIOD So <sil=0.414> ,COMMA I can assign X to be 23 <sil=0.948> .PERIOD 54 semicolon or I can assign Y to be 2 <sil=0.955> .PERIOD 5 E 12 and Z to be 1 <sil=0.917> .PERIOD 234 E minus 5 all right that means now Z will have the value 1 <sil=0.979> .PERIOD 234 times 10 to the power minus 5 that is how we represent the floating point numbers given this <sil=0.957> .PERIOD So <sil=0.354> ,COMMA this part is clear that is how we write the variables now and these are the examples of the data types now coming to constants <sil=0.992> .PERIOD The constants can be integer constants on floating point constants just the ones that I was showing right now <sil=0.383> ,COMMA but there is another type of constant character constants <sil=0.993> .PERIOD So <sil=0.537> ,COMMA we have already seen example of character constants of single character like like we had say A <sil=0.947> .PERIOD Sorry what is happening here we can have a single character like A or say X all these within single quote a single characters and there is another type of character constant which is a string <sil=0.952> .PERIOD For example <sil=0.303> ,COMMA I can have a string which is another type of character constant which is not a single character <sil=0.585> ,COMMA but a string of characters for example <sil=0.424> ,COMMA I want to write down my name the name of a person <sil=0.989> .PERIOD So <sil=0.590> ,COMMA string type variable named name and I can assign some value to the string like say G O P A L all right <sil=0.923> .PERIOD So <sil=0.400> ,COMMA this is a number of characters taken together is forming a string of characters it could also be name to be X 1 2 Y double quote <sil=0.916> .PERIOD Now <sil=0.633> ,COMMA note that in this case I am using double quote whereas <sil=0.536> ,COMMA for single characters I was using single quote <sil=0.977> .PERIOD Now <sil=0.438> ,COMMA these are some of the rules of defining character constants or numeric constants in C <sil=0.992> .PERIOD Next we move to you have seen the integer constants <sil=1.000> .PERIOD Now <sil=0.567> ,COMMA couple of things to be just mentioned that the maximum and minimum minimum number of values that can be stored as an integer constant is dependent on how many bits are allocated for representation <sil=0.931> .PERIOD For example <sil=0.577> ,COMMA as I said that for 32 bit representation <sil=0.493> ,COMMA I can have 2 to the power 32 different combinations all right <sil=0.910> .PERIOD So <sil=0.373> ,COMMA if you compute this you will find that on one side here is 0 when everything if I take one bit to designate positive 1 negative then I will be left with 31 bits <sil=0.918> .PERIOD So <sil=0.438> ,COMMA the maximum I can have on the positive side is 2 to the power 31 minus 1 <sil=0.970> .PERIOD So <sil=0.594> ,COMMA for middle 1 is 0 and I can go up to this and on the other side I can go up to 2 to the power minus 2 to the power 31 right <sil=0.940> .PERIOD So <sil=0.434> ,COMMA this is the range there is a maximum integers and the minimum integers that I can represent <sil=0.986> .PERIOD But <sil=0.599> ,COMMA obviously we need not be so concerned about it because that varies with the number of bits representation in the machine <sil=0.941> .PERIOD So <sil=0.560> ,COMMA for a 64 bit representation obviously this size will be doubled will be much larger I am sorry it will be much larger <sil=0.974> .PERIOD So <sil=0.574> ,COMMA we have also seen shooting point numbers just now <sil=0.938> .PERIOD So <sil=0.487> ,COMMA I do not need to repeat this <sil=0.921> .PERIOD And very why are we going for this this type of why are we going for exponential type of representation because that enables us to represent much larger numbers and very small numbers also using less number of bits because I can always write 0 <sil=0.934> .PERIOD 123 into 10 to the power minus whatever <sil=0.906> .PERIOD So <sil=0.382> ,COMMA here minus 12 I could have written minus 15 <sil=0.940> .PERIOD So <sil=0.602> ,COMMA it has got 2 numbed 2 parts one is the mantis apart that is this part I just put the decimal part 1 2 3 I represent in binary somewhere and on this side I put some bits for the exponents <sil=0.947> .PERIOD So <sil=0.583> ,COMMA it can be minus 15 plus 15 whatever <sil=0.940> .PERIOD So <sil=0.437> ,COMMA using less number of bits I can increase the range and can go for a much larger range of representation <sil=0.974> .PERIOD This one we have already explained that single character constants <sil=0.952> .PERIOD Now <sil=0.526> ,COMMA here of course <sil=0.589> ,COMMA you can see that this operator plus also has got an ASCII code every character has got an ASCII representation whatever we have we find on the keyboard has got an ASCII representation <sil=0.996> .PERIOD Therefore <sil=0.544> ,COMMA I can also have capital Z or plus as a character <sil=0.947> .PERIOD Now <sil=0.558> ,COMMA here is something that is a little new to you <sil=0.976> .PERIOD We have already encountered one of these as our friend earlier <sil=0.922> .PERIOD Here you can see that we are using a special character like backslash <sil=0.905> .PERIOD This backslash means that whatever is following a backslash is not the normal nature of that <sil=0.903> .PERIOD For example <sil=0.347> ,COMMA if I write n it really does not mean a character n <sil=0.501> ,COMMA but backslash n has got a different meaning <sil=0.905> .PERIOD For example <sil=0.441> ,COMMA suppose I was writing something print F <sil=0.344> ,COMMA say I write you have seen that example earlier print F <sil=0.969> .PERIOD Suppose I am just writing a <sil=0.383> ,COMMA b <sil=0.321> ,COMMA c and then I put backslash n <sil=0.969> .PERIOD That means <sil=0.564> ,COMMA I am I will be printing a <sil=0.586> ,COMMA b <sil=0.558> ,COMMA c <sil=0.922> ,COMMA but after that I will not print n <sil=0.381> ,COMMA but since it is backslash n it is some other information it is telling us that go to the new line <sil=0.952> .PERIOD So <sil=0.310> ,COMMA immediately we go to the new line <sil=0.965> .PERIOD Similarly <sil=0.321> ,COMMA we can see that backslash t <sil=0.411> ,COMMA backslash t this one is the horizontal tab <sil=0.928> .PERIOD So <sil=0.576> ,COMMA if I have backslash t my cursor will move from here to some fixed tabular distances <sil=0.963> .PERIOD Backslash now you know single coat or double coat <sil=0.539> ,COMMA single coat if I put a <sil=0.607> ,COMMA if I just want to print the character single coat <sil=0.332> ,COMMA how do I do it <sil=0.987> ?QUESTIONMARK I will do it because any character I have to do within this coat <sil=0.990> .PERIOD Now <sil=0.420> ,COMMA if I put single coat here <sil=0.421> ,COMMA then it will be confused <sil=0.333> ,COMMA it will take these two and will take a blank character in between <sil=0.566> ,COMMA because a blank character is represented as n with blank within two single coats <sil=0.930> .PERIOD But I really want that here not blank <sil=0.638> ,COMMA but I want to print the single coat <sil=0.976> .PERIOD So <sil=0.328> ,COMMA in that case what should I do <sil=0.984> ?QUESTIONMARK For this I should take a single coat and then backslash single coat <sil=0.578> ,COMMA back I mean single coat <sil=0.979> .PERIOD That means <sil=0.494> ,COMMA this single coat is different from these two single coats <sil=0.984> .PERIOD So <sil=0.601> ,COMMA these are the boundaries of the character representation and what is the character that is the single coat <sil=0.978> .PERIOD Similarly <sil=0.487> ,COMMA for double coat you can now very easily reason that I must enclose it within single coat and then backslash double coat followed by single coat <sil=0.963> .PERIOD Similarly <sil=0.614> ,COMMA if I want to print backslash what should I do <sil=0.949> ?QUESTIONMARK Single coat then backslash that means <sil=0.300> ,COMMA it is something different <sil=0.579> ,COMMA backslash single coat <sil=0.919> .PERIOD Similarly <sil=0.490> ,COMMA backslash null is backslash 0 <sil=0.993> .PERIOD So <sil=0.402> ,COMMA these are some special character constants that we may encounter during our programming practices <sil=0.904> .PERIOD Then other new thing that we have learnt is string constant <sil=0.929> .PERIOD Now <sil=0.613> ,COMMA string constants are a sequence of characters <sil=0.933> .PERIOD It is a sequence of characters <sil=0.385> ,COMMA sequence of characters enclosed within double coats just like we wrote that <sil=0.908> .PERIOD The characters may be the characters within the double coat may be letters <sil=0.456> ,COMMA numbers <sil=0.511> ,COMMA special characters <sil=0.645> ,COMMA blank spaces like that <sil=0.900> .PERIOD For example <sil=0.510> ,COMMA nice good morning there is a blank here <sil=0.977> .PERIOD Now <sil=0.392> ,COMMA what will happen with this <sil=0.880> ?QUESTIONMARK When I put this as a string <sil=0.476> ,COMMA don't think that it will be computed and printed as a 9 <sil=0.919> .PERIOD It is just a string that will be printed <sil=0.987> .PERIOD So <sil=0.314> ,COMMA if I write in this way within double coat within double coat <sil=0.452> ,COMMA if I write 3 plus 6 then just 3 plus 6 that string will be printed <sil=0.918> .PERIOD The difference between the with character constants is that backslash I mean the single coat C <sil=0.479> ,COMMA this is a character <sil=0.321> ,COMMA this is a string and they are not equivalent because their representations will see will be internally they will be represented in a different way <sil=0.918> .PERIOD This one has got an equivalent integer value that is ASCII code whereas <sil=0.351> ,COMMA this does not have an ASCII code <sil=0.925> .PERIOD This is something different where they will be C and something more which we will see later <sil=0.950> .PERIOD So <sil=0.591> ,COMMA string constants are thing only thing to remember is string constants are a sequence of characters which can be letters <sil=0.541> ,COMMA numbers <sil=0.625> ,COMMA expressions whatever this sort of operator special characters enclosed within double coats <sil=0.989> .PERIOD That is a string character <sil=0.941> .PERIOD Now <sil=0.417> ,COMMA we already know what variables are <sil=0.994> .PERIOD So <sil=0.649> ,COMMA we do not need to repeat that and we have seen the variables <sil=0.904> .PERIOD We know that the variables are to be declared and the general syntax is a particular data type sorry it is it will be a particular data type followed by variable list <sil=0.942> .PERIOD So <sil=0.556> ,COMMA like examples we have already seen int velocity distance int A B C D <sil=0.563> ,COMMA A B C D velocity distance are all integer variables <sil=0.957> .PERIOD Temperature is a float temp is a floating point variable <sil=0.431> ,COMMA flag option these are character type of variables we have already seen them <sil=0.943> .PERIOD Now <sil=0.545> ,COMMA we come to something that we evaded till now <sil=0.935> .PERIOD Pointers have got a big role in C programming but we will just have a very simple look at the pointers here pointer means basically address <sil=0.909> .PERIOD So <sil=0.437> ,COMMA you please forget about the title for the time being a variable is assigned a specific memory location that we know and that memory location is assigned by the compiler <sil=0.992> .PERIOD So <sil=0.558> ,COMMA if we have some variable say when we find out int A B C then as we have discussed earlier A B C are three memory locations which are assigned by the compiler <sil=0.996> .PERIOD Now <sil=0.599> ,COMMA each of these memory locations actually have got an address right <sil=0.961> .PERIOD So <sil=0.503> ,COMMA the address can be say this is 1350 is an address just like our houses have an address just like your rooms have got some numbers just as your dryers may have some levels <sil=0.958> .PERIOD So <sil=0.498> ,COMMA similarly might be this is 1400 this is say 1450 or 1420 suppose A B C has got these three addresses all right <sil=0.967> .PERIOD Now <sil=0.646> ,COMMA when I read when I try to read something we know that I read to scan F <sil=0.937> .PERIOD Now <sil=0.547> ,COMMA in scan F what I did is percentage D and A that means I am trying to read a variable A but I did not explain to you earlier why I put this and this and means that and you know what is this percentage D <sil=0.907> .PERIOD So <sil=0.369> ,COMMA I have got some space space to hold an integer and that space is the in the variable A but when the you from the keyboard type in say the value 25 where will that value go the value will go to the address of the variable A what is the address of the variable A 1350 <sil=0.960> .PERIOD So <sil=0.552> ,COMMA it will go to 1350 25 will come here <sil=0.929> .PERIOD Similarly <sil=0.474> ,COMMA when we write say scan F percentage D percentage D comma and A and B <sil=0.984> .PERIOD Then I am going to read two values and two integers and the address of the first one suppose I type in 25 and 27 <sil=0.984> .PERIOD So <sil=0.533> ,COMMA for the at 25 will go to the address of A that is at 1350 and 27 will go to the address of B that is 1400 <sil=0.962> .PERIOD Given this let us now read this a variable is assigned a specific memory location we know that for example <sil=0.330> ,COMMA a variable speed is assigned memory location 1350 and assume that the memory location contains the data value 100 <sil=0.982> .PERIOD So <sil=0.526> ,COMMA when we use the name speed in an expression it refers to the value 100 <sil=0.965> .PERIOD So <sil=0.454> ,COMMA for example <sil=0.510> ,COMMA when we write distance is speed into time then it will take this speed from this location 1350 <sil=0.901> .PERIOD Every variable has an address and its contents <sil=0.943> .PERIOD So <sil=0.460> ,COMMA we have seen A has gotten address A is a variable A has gotten address 1350 and when I write 25 into that 25 is the content <sil=0.973> .PERIOD So <sil=0.362> ,COMMA address and content we have earlier discussed also <sil=0.522> ,COMMA but you see here integer speed I think you can read it and so <sil=0.590> ,COMMA speed is this particular location that is in 1350 and when I write speed equals speed assigned 100 then 100 is written over here when I assign it <sil=0.969> .PERIOD So <sil=0.371> ,COMMA speed is getting the value 100 whenever <sil=0.609> ,COMMA but when I say what is AND speed then I am asking the question what is the address of the variable speed what is the address of the variable speed and the answer would be 1350 <sil=0.931> .PERIOD So <sil=0.347> ,COMMA this AND sorry this AND operation this AND operation is nothing <sil=0.374> ,COMMA but asking for the pointer to speed or the address to the variable speed <sil=0.966> .PERIOD So <sil=0.401> ,COMMA this would be the answer <sil=0.963> .PERIOD So <sil=0.573> ,COMMA AND of suppose here time is given here if I just say AND time what will that be returned what is AND time AND time will be 1351 something of this sort all right <sil=0.986> .PERIOD So <sil=0.520> ,COMMA that is another thing that we needed to understand what is the purpose of this AND <sil=0.911> .PERIOD So <sil=0.525> ,COMMA here in C terminology speed refers to the contents of the memory location and AND speed refers to the address of the memory location corresponding to the variable speed <sil=0.936> .PERIOD So <sil=0.473> ,COMMA let us come to this example print F percentage F percentage F percentage F that means <sil=0.560> ,COMMA I am going to print 3 floating point numbers and what are the variables see floating point values speed time and distance that means <sil=0.634> ,COMMA what am I going to print look here I am going to print the contents of the memory location speed the content of the memory location time the content of the memory location distance and when I am reading percentage F percentage F AND speed AND time that means <sil=0.577> ,COMMA what that I am reading where I am reading in the address of the variable speed I am reading in the address of the variable time <sil=0.907> .PERIOD So <sil=0.378> ,COMMA this is required to be understood <sil=0.915> .PERIOD So <sil=0.448> ,COMMA basically when I have a speed I once again repeat suppose speed is 25 and I print speed that means <sil=0.534> ,COMMA I am printing the content of this location speed <sil=0.934> .PERIOD But whenever I am reading into speed where am I reading the value I am reading into the address of speed that is this location that is the main difference between these two <sil=0.997> .PERIOD All right let us stop here in the next lecture we will straight away move ahead to write some C expressions because <sil=0.425> ,COMMA till now whatever we have learnt are the bits and pieces the tools of C that is how the how just like in a language how the words are written what are the sum of the simple rules <sil=0.972> .PERIOD But then we will have to learn writing the real sentences in a language <sil=0.931> .PERIOD So <sil=0.391> ,COMMA that we will start from the next lecture <sil=0.960> .PERIOD Thank you <sil=0.929> .PERIOD Till now we have looked into we have seen different programming constructs using which we can implement repetition that means a set of statements will be repeated in a loop and in C such constructs where while do while and for loop right <sil=0.907> .PERIOD Now also we have seen how we can branch out coming through a sequential one after another execution of the instructions depending on a condition we can go out to one path or another path through if else structures and we have also seen some examples by in which a combination of the if else structure as well as the while loose structure are combined together to give us more powerful and useful programs <sil=0.993> .PERIOD Today we will start discussing about a new form of representation of data that is very useful and very fundamental that is called arrays <sil=0.924> .PERIOD Arrays the word arrays simply means arrangement arrangement of data <sil=0.917> .PERIOD So <sil=0.580> ,COMMA we can think of for example for example an array of soldiers or array of people standing in line <sil=0.957> .PERIOD So <sil=0.468> ,COMMA people are standing in a line this is an array we can also have two rows of people standing <sil=0.981> .PERIOD It is a very regular structure we can have three rows also <sil=0.970> .PERIOD So <sil=0.487> ,COMMA these are arrays of people now if I just have only one row in that case say for example I consider one row then it is a one dimensional array when I consider rows as well as columns then it is a two dimensional array <sil=0.947> .PERIOD However <sil=0.431> ,COMMA we will now initially concentrate on one dimensional array like this what is this <sil=0.927> ?QUESTIONMARK This is an array of people <sil=0.997> .PERIOD Similarly <sil=0.549> ,COMMA we can have array of numbers for example one seven zero five three that is again an arrangement of data arrangement of data <sil=0.932> .PERIOD In a linear fashion this is the first element and this is the last element of this arrangement <sil=0.994> .PERIOD So <sil=0.509> ,COMMA this is also an array of some numbers <sil=0.953> .PERIOD So <sil=0.435> ,COMMA in an abstract way we can say that an array can be drawn in this form it can be an array of integer or an array of real numbers depending on what I want to store here <sil=0.913> .PERIOD Suppose this be an array of integers then each of these places can have one integer stored in this two six five three three <sil=0.983> .PERIOD Maybe again two and nine so this is an array <sil=0.961> .PERIOD Now <sil=0.534> ,COMMA how many elements are there in the array <sil=0.964> ?QUESTIONMARK Each of these are elements of the array <sil=0.952> .PERIOD How many elements are there in the array <sil=0.894> ?QUESTIONMARK One two three four five six so this is the size of the array <sil=0.994> .PERIOD And these are the elements of the array <sil=0.948> .PERIOD Also another thing we need to know is how do I identify one element of the array <sil=0.950> ?QUESTIONMARK Say this element six of the array this array how do I identify that what is its identification <sil=0.951> ?QUESTIONMARK The identification is the position <sil=1.000> .PERIOD So <sil=0.583> ,COMMA this is the second position all right this is the first position this is the third position fourth position so and so forth <sil=0.985> .PERIOD Now <sil=0.365> ,COMMA this positions in the array is known as index <sil=0.990> .PERIOD Index is the position in the array index determines position in the array <sil=0.939> .PERIOD So <sil=0.354> ,COMMA position of what position of an element in the array <sil=0.899> ?QUESTIONMARK So <sil=0.393> ,COMMA for the time being we assume that arrays are linear structures linear arrangement of data <sil=0.961> .PERIOD Now <sil=0.599> ,COMMA one point to remember is one array can store data of the same type <sil=0.970> .PERIOD For example <sil=0.432> ,COMMA it is not possible to have an array in which there will be some integers some real numbers or some again characters <sil=0.907> .PERIOD So <sil=0.590> ,COMMA that is not possible that is not allowed <sil=0.932> .PERIOD So <sil=0.472> ,COMMA an array will is allowed to store data of only one type <sil=0.914> .PERIOD We know that in float <sil=0.633> ,COMMA care all these are defining different types of data or data type or data type <sil=0.937> .PERIOD So <sil=0.631> ,COMMA an array can store data of only one data type whatever that is it can be all floating point numbers it can be all characters it can be all integers whatever <sil=0.964> .PERIOD So <sil=0.558> ,COMMA these are two words of caution <sil=0.956> .PERIOD So <sil=0.460> ,COMMA what have we learnt <sil=0.944> ?QUESTIONMARK We have learnt that array is an arrangement of data of the same type and the array has is identified as a whole by a name and say for example <sil=0.433> ,COMMA this array this is not a valid array <sil=0.939> .PERIOD So <sil=0.436> ,COMMA let us have a valid array of four elements say of real numbers maybe <sil=0.948> .PERIOD So <sil=0.610> ,COMMA this array will have a name let us say R we try to put a name A that means <sil=0.313> ,COMMA A is the name to this array and this array has got a type what is the type of this array the type is float <sil=0.942> .PERIOD So <sil=0.365> ,COMMA array A is a float <sil=0.950> .PERIOD So <sil=0.351> ,COMMA A is an array of type float that means <sil=0.634> ,COMMA it can store only floating point data also an array consists of different elements each of these are elements <sil=0.972> .PERIOD And each element each element can be a floating point number and the particular element is identified by the index of an array <sil=0.911> .PERIOD Now <sil=0.527> ,COMMA and also we have we know that an array has got a size given this let us think of why are we talking about all these things why is this needed after all <sil=0.941> .PERIOD We have encountered till now quite a few example problems for example <sil=0.536> ,COMMA let us again come back to the old problem of finding the maximum of a set of integers <sil=0.937> .PERIOD Now <sil=0.413> ,COMMA in that case what did we do we read one integer we initialized a variable say first integer we read let me once again do it <sil=0.927> .PERIOD So <sil=0.521> ,COMMA if you recall we I am writing the flow chart I am not writing the C program read a number you know how to read a number by scan F then put that number to be max read again read number <sil=0.987> .PERIOD And if number is greater than max then I am writing pseudo code <sil=0.999> .PERIOD So <sil=0.412> ,COMMA I can write then then max is getting the number again I read number <sil=0.990> .PERIOD And in that way I go on or you can say that why should I write in this way I shall simply implement a loop while loop or fall loop <sil=0.992> .PERIOD So <sil=0.628> ,COMMA that this thing is carried on till I stop say for n numbers or for so here I can use for I assigned 1 to I less than equal to n I plus plus to implement the loop here <sil=0.996> .PERIOD But that is possible when I know the total number of numbers if I did not know the number of numbers there are some other ways of doing it say for example <sil=0.631> ,COMMA I am reading integers and I say when I want to stop I will enter a 0 <sil=0.904> .PERIOD So <sil=0.566> ,COMMA here I could have put in something like this while norm is greater than 0 do so we do this as long as norm is greater than 0 I am going on doing this <sil=0.978> .PERIOD And if norm is 0 or norm that we decide or some negative number I know that my job is done <sil=0.959> .PERIOD So <sil=0.437> ,COMMA but in this case if I want to remember what were the numbers already given to me suppose the numbers that were given were 5 initially here then 2 <sil=0.978> .PERIOD So <sil=0.327> ,COMMA nothing was done max was 5 then 7 then here there has been a interchange <sil=0.996> .PERIOD So <sil=0.346> ,COMMA now here max becomes 7 then again it was 3 so nothing was done then it was 8 and max became 8 <sil=0.936> .PERIOD So <sil=0.368> ,COMMA that will work for this sort of program but if I want to know what were the numbers you are saying max is 8 but what were the numbers that were input by the user we have not remembered them anywhere is it not we have not remembered them anywhere <sil=0.938> .PERIOD So <sil=0.541> ,COMMA here in my program I will not be able to say what was the second number entered what was the first number entered was there any 0 entered or was there any anything greater than 3 entered we cannot answer this questions because we read this and we operate it on this and we forgotten <sil=0.919> .PERIOD Now <sil=0.315> ,COMMA if you can think of that if I had used an array this sort of thing and I had as the user gave the numbers I stored them here 5 then 3 I stored 3 here then user gave 7 <sil=0.997> .PERIOD I stored 7 here then the user gave something maybe again 4 I stored 4 here and then user gave 9 I stored 9 here then even after or 8 here I even after reporting the max that this is the max I have got these in my array <sil=0.906> .PERIOD See my name of the array is still a which is a is an array of integers then this is stored here I have remembered them in the array <sil=0.903> .PERIOD So <sil=0.381> ,COMMA I can now say what was my first element I go to the first element of the array using the index value and second I go to the this value <sil=0.925> .PERIOD What is the fourth value first second third fourth I come to this point and I can say the fourth value was this <sil=0.933> .PERIOD So <sil=0.367> ,COMMA all these things I can remember because I have been able to store them in the form of an array <sil=0.941> .PERIOD So <sil=0.367> ,COMMA that is so array is again an arrangement in the memory <sil=0.970> .PERIOD You know that every variable is stored in a memory location right <sil=0.991> .PERIOD So <sil=0.510> ,COMMA when we had num and the program that I had written that num initially I read num <sil=0.986> .PERIOD And then I do this and then again read num if num is greater than max max assign num when I do this thing in a loop or whatever <sil=0.993> .PERIOD What is happening whenever I have got variable num is a variable one location in the memory this is num and max is another variable I have declared all of them here in num in max <sil=0.919> .PERIOD So <sil=0.485> ,COMMA here there is another location which is known as max <sil=0.991> .PERIOD So <sil=0.474> ,COMMA when I did this read num and suppose some data 5 was read that 5 is stored here 5 is stored here <sil=0.942> .PERIOD When I come here and I put max num assigned to max so it comes here <sil=0.955> .PERIOD Now <sil=0.639> ,COMMA I did num again so suppose num is 4 and no update in max next time I read it 7 <sil=0.943> .PERIOD So <sil=0.458> ,COMMA this is updated here and this becomes 7 <sil=0.999> .PERIOD So <sil=0.369> ,COMMA this is the process that goes on all right <sil=0.993> .PERIOD Now <sil=0.646> ,COMMA so every time I am losing the old value of num and storing the current value of num <sil=0.957> .PERIOD And similarly whenever there is an update required I take the current value the max up to now <sil=0.947> .PERIOD So <sil=0.416> ,COMMA I am having 2 variables of integers <sil=0.966> .PERIOD But if I had done it in the form of an array then I could have thought of like this that I have got suppose the array size is 5 <sil=0.953> .PERIOD So <sil=0.550> ,COMMA suppose the array size is 5 <sil=1.000> .PERIOD So <sil=0.553> ,COMMA that means conceptually I am talking of something like this that there are 5 positions in this array <sil=0.954> .PERIOD And as I am getting the data it is coming over here 5 <sil=0.583> ,COMMA 3 <sil=0.604> ,COMMA 7 <sil=0.388> ,COMMA 2 <sil=0.311> ,COMMA 9 whatever <sil=0.916> .PERIOD Now <sil=0.518> ,COMMA actually internally what is happening internally this is being stored in the memory <sil=0.920> .PERIOD The array size is 5 here <sil=0.933> .PERIOD So <sil=0.518> ,COMMA I have got 5 locations in my memory 4 <sil=0.449> ,COMMA 5 <sil=0.630> .PERIOD So <sil=0.449> ,COMMA these 5 locations of the memory are being given to the array A <sil=0.925> .PERIOD Suppose the name of the array is array A <sil=0.990> .PERIOD So <sil=0.581> ,COMMA for the array A <sil=0.940> .PERIOD So <sil=0.561> ,COMMA the first element is coming here when I am actually writing it here <sil=0.931> .PERIOD It is coming here <sil=0.357> ,COMMA second element is coming here <sil=0.643> ,COMMA next element is coming here <sil=0.606> ,COMMA next here <sil=0.324> ,COMMA next here <sil=0.583> .PERIOD So <sil=0.640> ,COMMA these are the memory locations <sil=0.944> .PERIOD So <sil=0.618> ,COMMA an array is actually a representation in that memory which are contiguous and you know each memory location has got an address <sil=0.964> .PERIOD So <sil=0.584> ,COMMA suppose hypothetically the address of this is 1000 and each of them are integers and integer if I say integer is requiring 2 bytes <sil=0.959> .PERIOD Then if this is 1000 location the next one will be 1000 <sil=0.502> ,COMMA 2 <sil=0.614> ,COMMA next one will be 1000 <sil=0.302> ,COMMA 4 <sil=0.331> ,COMMA then 1000 <sil=0.355> ,COMMA 6 <sil=0.478> ,COMMA then 1000 <sil=0.442> ,COMMA 8 <sil=0.536> ,COMMA 1000 <sil=0.601> ,COMMA 8 <sil=0.341> ,COMMA 2000 <sil=0.605> ,COMMA 9 <sil=0.359> .PERIOD So <sil=0.346> ,COMMA 1000 <sil=0.600> ,COMMA 2001 is for the first element this one coming here <sil=0.516> ,COMMA 2002 <sil=0.502> ,COMMA 2003 for this element <sil=0.331> ,COMMA 2004 <sil=0.362> ,COMMA 2005 is this element <sil=0.572> ,COMMA 6 <sil=0.462> ,COMMA 2007 is this element <sil=0.588> ,COMMA 2008 <sil=0.638> ,COMMA 2009 will be this element <sil=0.988> .PERIOD So <sil=0.546> ,COMMA 1000 <sil=0.586> ,COMMA 2009 that means 10 locations we are requiring for these 5 elements of the array <sil=0.960> .PERIOD Now <sil=0.401> ,COMMA since also in my program I have got 2 other variables <sil=0.376> ,COMMA 1 is the num or 1 is the max <sil=0.601> ,COMMA I can manage it with 1 more variable <sil=0.964> .PERIOD Max is a separate variable <sil=0.609> ,COMMA suppose so that is here this variable is max <sil=0.617> ,COMMA let me delete this variable <sil=0.494> ,COMMA this is not required <sil=0.926> .PERIOD Because this diagram is redundant because max is another variable which I have here <sil=0.648> ,COMMA we will write a program we will show later how we can write a program to deal with this <sil=0.981> .PERIOD So <sil=0.644> ,COMMA since I have computed I have read the numbers <sil=0.457> ,COMMA I have stored them in the memory locations and since I am going through an array I have not written over written <sil=0.908> .PERIOD So <sil=0.601> ,COMMA I can remember all the numbers <sil=0.447> ,COMMA so this is one basic reason of usage of array where I want to remember the numbers in the memory <sil=0.970> .PERIOD Given this let us quickly recapitulate what we have said till now <sil=0.934> .PERIOD So <sil=0.372> ,COMMA many applications require multiple data items that have a common characteristics <sil=0.925> .PERIOD What is that common characteristics like whether they are integer or float or character whatever that is <sil=0.607> ,COMMA it can be even more complex <sil=0.906> .PERIOD So <sil=0.574> ,COMMA we call say so that numbers that we are showing say we can in mathematics we often represent them as x 1 <sil=0.649> ,COMMA x 2 <sil=0.552> ,COMMA x 3 <sil=0.575> ,COMMA x 4 <sil=0.555> ,COMMA say up to x n <sil=0.981> .PERIOD And that whole thing I can represent as an array x where x 1 is the first element x 2 is the second element x 3 is the third element like that <sil=0.989> .PERIOD Now <sil=0.332> ,COMMA here is an example finding the minimum set of numbers minimum of a set of numbers how we can find the minimum of a set of numbers <sil=0.971> .PERIOD So <sil=0.441> ,COMMA this is what I have already discussed but just for the sake of revision let us look at it once again <sil=0.983> .PERIOD Say for three numbers you know we can this program must be familiar to you now you should be able to understand it quickly <sil=0.931> .PERIOD If a is less than b and a is less than equal to c then a is the minimum I was showing the maximum here it is an example of the minimum else if b is less than c then b is the minimum else c is the minimum <sil=0.932> .PERIOD So <sil=0.467> ,COMMA far so fine as soon as I extend from three numbers to four numbers you see the program becomes a little bigger <sil=0.938> .PERIOD If a is less than equal to b and a is less than equal to c and a is less than equal to d then minimum is a otherwise if you see everywhere I have brought in more number of comparisons and the program code has also been bigger <sil=0.920> .PERIOD And I am not storing the numbers as yet I am not storing the numbers that is one issue the problem is so from three to four we need needed so much extension <sil=0.997> .PERIOD Now <sil=0.552> ,COMMA suppose we have got ten numbers to handle that will be even bigger 20 numbers even bigger 100 numbers so how do we do that <sil=0.964> .PERIOD The solution is the solution to the problem is what is the solution the solution to the problem is use of arrays right using arrays right <sil=0.976> .PERIOD Now <sil=0.380> ,COMMA as I said that all the data items constituting the group shared the same name all these data items that I had shown say integers like 5 <sil=0.541> ,COMMA 7 <sil=0.391> ,COMMA 6 <sil=0.395> ,COMMA 3 <sil=0.470> ,COMMA 2 all these can share the same name x or may be let me give a meaningful name <sil=0.965> .PERIOD Now <sil=0.592> ,COMMA this one is number one this one is number two this one is number five <sil=0.904> .PERIOD So <sil=0.566> ,COMMA I have got just as we had shown x 1 x 2 up to x n so here n is five so I have got this five individual elements are accessed by specifying the index this is the index which is telling me in which position which number in this area of numbers I am looking at <sil=0.943> .PERIOD We will look at this further the use of arrays and many more things are to come <sil=0.995> .PERIOD We have discussed about passing arrays as parameters and for passing arrays as parameters in C to C functions we take recalls to call by reference <sil=0.938> .PERIOD Otherwise for all other parameter passing we take recalls to call by value and just to summarize the call by value and call by reference the references in call by value we copy the value of the actual parameter to the formal parameter <sil=0.321> ,COMMA formal argument and in call by reference we do not copy the value but we just pass on the address or the pointer and reference to the actual parameter <sil=0.988> .PERIOD So <sil=0.335> ,COMMA as a result what happens that if any change to that variable is resulted in the function itself in the case of call by value that will not be automatically reflected to the main program but in the case of call by reference since there is no other separate copy that will automatically be reflected <sil=0.943> .PERIOD Just to conclude that part we will see a number of applications of functions just to conclude that let us have a quick look at one function there is no array but just solution of the prototypes that you can see here finding the maximum of three integers <sil=0.948> .PERIOD So <sil=0.467> ,COMMA we have the header file here include stdiu <sil=0.908> .PERIOD h then here we declared a function prototype the actual function maximum has been written later <sil=0.954> .PERIOD So <sil=0.423> ,COMMA here you see that what does this line tell us this line tells us that maximum is a function and it consists of three integer arguments or three integer parameters will come <sil=0.971> .PERIOD So <sil=0.558> ,COMMA as if this is a function which has got three input doors and each door is wide enough to accommodate an integer <sil=0.920> .PERIOD So <sil=0.508> ,COMMA that much is told and whatever is inside this I am not aware of that and at this stage I am not aware of that and the output will also be another integer that is told by this <sil=0.951> .PERIOD Then so here the cellion point to see is that here I have just it is sufficient to just specify the types no names have been put in <sil=0.964> .PERIOD Now comes the main program that is very simple a <sil=0.638> ,COMMA b <sil=0.552> ,COMMA c are three integers <sil=0.994> .PERIOD So <sil=0.529> ,COMMA they are local to this function enter the integers a <sil=0.537> ,COMMA b <sil=0.411> ,COMMA c are entered here <sil=0.946> .PERIOD So <sil=0.431> ,COMMA you know what a is what b is and what c is and then you are calling inside c here inside the printf I can call maximum with the parameter a <sil=0.512> ,COMMA b <sil=0.370> ,COMMA c and we come here <sil=0.941> .PERIOD And here I have defined here I did not name here I did not name the variables here I have defined the names of variables in text into I in Z <sil=0.916> .PERIOD So <sil=0.583> ,COMMA this x <sil=0.303> ,COMMA y <sil=0.583> ,COMMA z are again property of this maximum <sil=0.939> .PERIOD So <sil=0.554> ,COMMA x <sil=0.439> ,COMMA y <sil=0.562> ,COMMA z are here and the algorithm of the logic is simple initially I make max to be x if y is greater than max and y is the max otherwise z is the max and then I am returning max <sil=0.957> .PERIOD I am returning max means I am coming here and then that max is being printed and return 0 <sil=0.927> .PERIOD Now <sil=0.554> ,COMMA my main function what is my main main is here main has got a type int <sil=0.986> .PERIOD So <sil=0.384> ,COMMA I am returning 0 <sil=0.980> .PERIOD So <sil=0.543> ,COMMA int will if at the end of the main function a 0 is returned I will assume that the program has successfully completed <sil=0.993> .PERIOD The reason I brought of this example is just to illustrate this case that you need not at the prototype level you can escape specifying the parameters <sil=0.913> .PERIOD So <sil=0.426> ,COMMA here is the prototype declaration function calling and function definition you know that <sil=0.984> .PERIOD So <sil=0.461> ,COMMA this are already repeated I am not going into that <sil=0.901> .PERIOD So <sil=0.346> ,COMMA instead I will be talking about a function of the parameter I will be talking about the new thing here that is hash include we have talked about hash include we have used hash include and we mentioned that hash include is nothing but a pre processor statement a pre processor statement how say hash include filing we have seen hash include a steady I O dot H <sil=0.511> ,COMMA but it can be for that matter any file name hash include file name say for example <sil=0.363> ,COMMA I can specify the full path say slash us R in a Linux environment slash home Rager my file dot H <sil=0.928> .PERIOD I want to include this file I want to include this file in my for serving this file in my program <sil=0.970> .PERIOD The content of the corresponding file will be included in the present file before compilation is done and the compiler will compile thereafter considering the content as it is <sil=0.948> .PERIOD So <sil=0.330> ,COMMA it is a pre processor statement that is I put that inside that hash include that file is included and then the compilation is done okay <sil=0.901> .PERIOD Now <sil=0.594> ,COMMA let us look at this hash include example look at this program segment which is my source program which is known as proc dot C <sil=0.999> .PERIOD So <sil=0.349> ,COMMA this my source program this source program has got hash include no steady I O dot H <sil=0.381> ,COMMA but it has just said that in hash include my file dot H and then the main program follows okay <sil=0.958> .PERIOD Now <sil=0.341> ,COMMA now this my file dot H is nothing but another file which is which has got hash include a steady I O dot H and in text <sil=0.955> .PERIOD So <sil=0.440> ,COMMA when I include my file dot H then this particular file will be included this particular file that is this segment will be included here <sil=0.943> .PERIOD So <sil=0.345> ,COMMA consequently what will happen is when I say in general hash include file name dot H it includes the file name file file name dot H from a specific directory which is known as the include directory when I say hash include it takes from the include directory and in the include directory I have kept my file dot H and consequently when that is included the ultimately the thing that looks like is it will look like this because that hash include I am sorry there should not be an inverted comma here it should be just hash include a steady I O dot H followed by in text <sil=0.953> .PERIOD So <sil=0.479> ,COMMA this whole thing whole thing has been has replaced my file dot H and where was my file dot H my file dot H was under user us are include file name dot H <sil=0.947> .PERIOD So <sil=0.418> ,COMMA that is how the include I can have other files included in my program <sil=0.912> .PERIOD Now <sil=0.334> ,COMMA another point of critical discussion is macro definition we have seen the macros like hash define <sil=0.930> .PERIOD So <sil=0.437> ,COMMA let us so that is again a pre processor directive we have seen that hash include is a pre processor command that means <sil=0.459> ,COMMA even before the compilation is done that is that is copied there on the other hand you see the pre processor directive of hash define string 1 string 2 that means <sil=0.528> ,COMMA string 1 should be replaced by string 2 <sil=0.906> .PERIOD So <sil=0.592> ,COMMA how does it happen it replaces string 1 by string 2 whenever it occurs wherever it occurs wherever it occurs before compilation <sil=0.941> .PERIOD So <sil=0.520> ,COMMA for example <sil=0.449> ,COMMA hash define pi to be 3 <sil=0.987> .PERIOD 14 <sil=0.988> .PERIOD So <sil=0.458> ,COMMA wherever it will find this pi wherever it will find this pi it will replace that with 3 <sil=0.905> .PERIOD 14 <sil=0.977> .PERIOD So <sil=0.577> ,COMMA here for example <sil=0.430> ,COMMA you see we have got hash include stdi dot H then we define pi to be 3 <sil=0.954> .PERIOD 14 as the hash define pre processor command <sil=0.996> .PERIOD Now <sil=0.527> ,COMMA in my main program I have got float R 4 time 4 R is 4 and area is another variable both are float <sil=0.904> .PERIOD Now <sil=0.398> ,COMMA area is pi timeswatch R is initialized <sil=0.943> .PERIOD So <sil=0.505> ,COMMA when we have done this we see that is pi times which we have done before this graph again we have done this graph before this graph wow our graph now we can see the <sil=0.968> .PERIOD Now if you will dynamically recall you become now as area is pi times r times r <sil=0.605> ,COMMA r is already initialized <sil=0.995> .PERIOD So <sil=0.475> ,COMMA what will happen is this will be translated to this pi will be replaced <sil=0.989> .PERIOD So <sil=0.557> ,COMMA the body will be float r assigned 4 and area and area is so r is 4 and area will be 3 <sil=0.968> .PERIOD 14 times r times r <sil=0.983> .PERIOD So <sil=0.337> ,COMMA even before compilation this pi is being replaced by the value 3 <sil=0.923> .PERIOD 14 as has been stated in the hash defined command <sil=0.985> .PERIOD We can also give hash defined with an argument <sil=0.952> .PERIOD Till now we have seen hash defined pi as a constant has defined some constant k to be 5 or whatever <sil=0.982> .PERIOD Here we can also define some functions like you see hash defined square x is x times x <sil=0.935> .PERIOD So <sil=0.396> ,COMMA wherever square x will appear that will be replaced by x times x <sil=0.954> .PERIOD So <sil=0.341> ,COMMA for example here let us look at this program again <sil=0.949> .PERIOD I think you are not being able to read this <sil=0.901> .PERIOD So <sil=0.467> ,COMMA let me go back say let me have if I have declared say hash defined square x is x times x <sil=0.928> .PERIOD Then in my program wherever I will get say p is assigned square y <sil=0.903> .PERIOD So <sil=0.516> ,COMMA this will be be translated as p assigned y times y <sil=0.966> .PERIOD So <sil=0.515> ,COMMA this what should be done that has already been told here that square x is this <sil=0.930> .PERIOD So <sil=0.329> ,COMMA this will simply replace it <sil=0.956> .PERIOD So <sil=0.587> ,COMMA that is the purpose of hash defined here we can see that <sil=0.990> .PERIOD So <sil=0.495> ,COMMA let us look at this example again main y is 5 <sil=0.976> .PERIOD Print of value is y times y <sil=0.967> .PERIOD That means <sil=0.623> ,COMMA this is being rep this is what has been generated after the square x has been square here it was square x plus 3 <sil=0.991> .PERIOD So <sil=0.352> ,COMMA that has become y times y plus 3 <sil=0.964> .PERIOD Now <sil=0.464> ,COMMA which one is faster to execute <sil=0.957> ?QUESTIONMARK You can think of I can if I write square x written as a macro definition then I am pasting as if I am pasting the body of the code inside this in the main program replacing that <sil=0.942> .PERIOD So <sil=0.623> ,COMMA I do not need to call any function <sil=0.910> .PERIOD I can write it as a macro definition and I as a result even before compilation even before compilation I can get this look <sil=0.970> .PERIOD And so <sil=0.309> ,COMMA this can be straight way applied without requiring to call a function <sil=0.920> .PERIOD Now <sil=0.577> ,COMMA if square x is written as an ordinary function not like a macro definition in that case I have to call a function and calling a function has got some overheads which I am not discussing here <sil=0.911> .PERIOD So <sil=0.342> ,COMMA if it be a very simple thing like this is better to make it a macro <sil=0.967> .PERIOD So <sil=0.437> ,COMMA that it automatically gets pasted and it becomes faster <sil=0.999> .PERIOD However <sil=0.640> ,COMMA there is a word of caution for example <sil=0.587> ,COMMA if I had defined square x now it is now when I am defining as a macro it is I have to ensure that it is correct <sil=0.957> .PERIOD Therefore <sil=0.446> ,COMMA if I define square x as x times x now how the macro definition substitution will be carried out let us look at this <sil=0.950> .PERIOD If there be something like r assign square of a plus square of 30 <sil=0.998> .PERIOD So <sil=0.360> ,COMMA it will be a times a plus 30 times 30 that is how it will happen <sil=0.906> .PERIOD Now <sil=0.542> ,COMMA what about r square of a plus b it will be simply pasted as a plus b times a plus b consequently the result will be wrong because during execution b times a will be done first and then that will be added with a and with b <sil=0.972> .PERIOD So <sil=0.571> ,COMMA this is not what I intended therefore <sil=0.334> ,COMMA if I had done this define this as like this and like this this problem would not have occurred <sil=0.941> .PERIOD So <sil=0.577> ,COMMA unless I do that this a plus b should will not be I need to take if I define it like this then it becomes this which is correct one <sil=0.956> .PERIOD But <sil=0.567> ,COMMA unless I do that it will lead to a wrong result <sil=0.929> .PERIOD So <sil=0.350> ,COMMA you must be very careful about it this is wrong and the macro definition should have been written as as I have shown square x is x times x in that case we would have got the correct result <sil=0.922> .PERIOD Now <sil=0.553> ,COMMA before moving to anything else we will now look at some applications of what we have learnt <sil=0.912> .PERIOD We are now at a position where we have to be able to see the result <sil=0.911> .PERIOD I have learnt all the fundamental tools without the sophistications that are required to write a program <sil=0.972> .PERIOD So <sil=0.442> ,COMMA suppose I want to solve a problem like this that I have got 5 students in the class and the 5 students have got 5 names of course <sil=0.593> ,COMMA and I have got 5 names of and each of them have got some marks total marks <sil=0.908> .PERIOD Now <sil=0.521> ,COMMA how do I represent that and I want to find out which student I want to print the name of the student who has got the highest marks is the problem clear <sil=0.972> .PERIOD Let me repeat the problem I have got 5 students in a class and I want to find out which student has got the highest marks and I want to know the name of that student <sil=0.908> .PERIOD How can I solve this problem this is a simple problem here what I will need is first I will need an array of the names of the students <sil=0.941> .PERIOD So <sil=0.490> ,COMMA first I need an array of the names of the students <sil=0.959> .PERIOD So <sil=0.456> ,COMMA here 5 names will be stored very very disproportionate array and let me call this array to be name or names and on this side I have got another array which holds the marks of the of the different students <sil=0.932> .PERIOD Corresponding to the next class I will have to write this name and I will have to write this name and I will have to write this name and I will have to write this name and the marks of the of the different students corresponding to the role number may be 1 <sil=0.311> ,COMMA 2 <sil=0.346> ,COMMA 3 <sil=0.513> ,COMMA 4 <sil=0.307> ,COMMA 5 the marks are stored here somebody got 50 somebody got 55 somebody got 62 somebody 70 somebody 32 say and their names are ABC and they are in the same way <sil=0.966> .PERIOD L M P Q X and Y suppose these are names these are different names <sil=0.927> .PERIOD Now <sil=0.526> ,COMMA why do I need 2 arrays these are these are the array called marks why do I need 2 arrays first of all the arrays should be holding same type of data <sil=0.980> .PERIOD So <sil=0.512> ,COMMA what is the type of data that the array names is holding it is a array of character or character string <sil=0.908> .PERIOD Now <sil=0.372> ,COMMA how can I represent these names I can represent them as an array of strings or each of these names is what how can I represent these names I can represent them as an array of strings or each of these names is what each of these names is a character <sil=0.983> .PERIOD Therefore <sil=0.610> ,COMMA if I just look at names names will look like a 2 dimensional array <sil=0.947> .PERIOD Now <sil=0.377> ,COMMA what would be my algorithm first of all come to the representation later what would be my algorithm first of all I will have to go to this marks array which is simpler it is an array of integers assuming all integer marks are given then I will have to carry out find out the maximum of this and you can write a function to find the maximum of an array right <sil=0.926> .PERIOD So <sil=0.538> ,COMMA let us try to write the function first <sil=0.983> .PERIOD So <sil=0.619> ,COMMA I have got an array marks I have got a function that I have got a function that which has got 5 elements all right <sil=0.971> .PERIOD So <sil=0.539> ,COMMA I can call a function max what let us first of all think of this maximum volume what will it return me say it will find out say if I come to this it will find out which one is the maximum and will return me an index right or this is not the maximum sorry this one is the maximum <sil=0.900> .PERIOD So <sil=0.494> ,COMMA it will return me an index 0 1 2 3 <sil=0.998> .PERIOD So <sil=0.478> ,COMMA it will return me an integer therefore <sil=0.378> ,COMMA I can start with like this that int maximum of I can call an array integer array int suppose that is m this and the main function will call it with marks and inside this what will happen you know initially let me call a value int this is a local max assigned m 0 <sil=0.929> .PERIOD So <sil=0.553> ,COMMA initialize a variable max with m 0 <sil=0.979> .PERIOD Now <sil=0.599> ,COMMA for I assigned some index I so I have to declare I also here I have got this m 0 and I have got this m 0 <sil=0.942> .PERIOD So <sil=0.557> ,COMMA I have got this m 0 and I have got this m 0 and I have got this m 0 <sil=0.979> .PERIOD So <sil=0.317> ,COMMA I assigned 1 I less than equal to 5 less than equal to 4 sorry less than equal to 4 I plus plus here if m I is greater than max then if then max is 0 <sil=0.928> .PERIOD So <sil=0.350> ,COMMA this is the maximum max is 0 <sil=0.973> .PERIOD So <sil=0.432> ,COMMA m I and that will go on now ultimately what shall I return from this should I return the max no I am returning the value of I because where I found the maximum now <sil=0.917> .PERIOD So <sil=0.497> ,COMMA for that now this I is changing <sil=0.953> .PERIOD So <sil=0.508> ,COMMA here I will also have to make say so let me just make this I to be 0 let me make this I to be initially I is 0 <sil=0.917> .PERIOD So <sil=0.620> ,COMMA I will also have to make this I to I could have done a with this and wherever I get this max I am changing this I wherever I am getting this max I can say that there is another max index and I am making max index equals I <sil=0.996> .PERIOD So <sil=0.330> ,COMMA I am remembering where I found the max and I will be returning the max index <sil=0.942> .PERIOD So <sil=0.336> ,COMMA my maximum function in this way what it will do is it will sorry it will find out the maximum <sil=0.987> .PERIOD So <sil=0.597> ,COMMA it will return 3 <sil=0.910> .PERIOD So <sil=0.488> ,COMMA the first thing is find max now I have got an adenymes how is that represented the representation can be as strings or it can be as an adiab or it can be as an adiab of characters <sil=0.928> .PERIOD If I consider this to be an adiab of characters then remember that is a 2 dimensional adiab and I in that case I will take so this 3 and I will come to this 3 this and I will print out this particular element from that adiab <sil=0.911> .PERIOD So <sil=0.524> ,COMMA now what about this names let us see names is an adiab say p q r or something <sil=0.969> .PERIOD So <sil=0.607> ,COMMA I can have this as an adiab of characters so p q r is a p q r and I can have this as a l m whatever it is and this part is blank <sil=0.905> .PERIOD So <sil=0.577> ,COMMA what is my declaration of names names will be there are 5 names 5 rows and each row is a character <sil=0.958> .PERIOD So <sil=0.434> ,COMMA it is a character adiab <sil=0.539> ,COMMA character so it is a character adiab <sil=0.467> ,COMMA care names let me write it here care names 5 rows and each row may have 3 columns <sil=0.924> .PERIOD So <sil=0.433> ,COMMA this is a character adiab of characters and right adiab like this l m p l m k p q r like that say <sil=0.902> .PERIOD Now <sil=0.403> ,COMMA I have suppose come with that maximum index was this rows so that is 3 <sil=0.901> .PERIOD Now <sil=0.485> ,COMMA how do I print this p q r name here if it is kept as a string I could have straight with percentage s format <sil=0.378> ,COMMA but here how do I do with this here I can I will have I will print which row I will print I am not writing the entire code print f which row would I print I print the names 3 <sil=0.398> ,COMMA but there are 3 characters so names 3 in a loop I have to print right <sil=0.965> .PERIOD So <sil=0.400> ,COMMA print f so how how the printing be done how do I print 1 row of an array a 2 dimensional <sil=0.909> .PERIOD So <sil=0.452> ,COMMA here I come so I will print in a loop names 3 0 3 1 3 2 actually this is 3 should be summer here it is confusing 3 should be summer here say a b c so 3 is actually this row so names I will be printing 3 0 3 1 3 2 and that I can print in a for loop <sil=0.972> .PERIOD So <sil=0.453> ,COMMA I leave it to you to try to print this in the character format you can also try it in the string format <sil=0.981> .PERIOD So <sil=0.639> ,COMMA what we have done here is we have seen the how the macros are replaced and we will see further examples of functions all through in the future lectures where we will be applying functions and add is consequently <sil=0.970> .PERIOD We are looking at the if selection structure where the structure was something like if some condition and then there were some statements and here is an example of what we are looking at <sil=0.974> .PERIOD So <sil=0.484> ,COMMA here you can see that if a is greater than b and also greater than c here is the logical connective <sil=0.926> .PERIOD So <sil=0.578> ,COMMA then this statement will be executed <sil=0.981> .PERIOD So <sil=0.345> ,COMMA in English we can just call it like if the condition is true then if the condition is true then execute a set of statements <sil=0.952> .PERIOD So <sil=0.372> ,COMMA in this case the set of statements is just only this printf otherwise if this condition is true then this statement will be printed <sil=0.952> .PERIOD So <sil=0.403> ,COMMA this is what we discussed in the last class <sil=0.925> .PERIOD Now <sil=0.368> ,COMMA one thing for those who will be writing programs in C you should remember that this condition is always within a parenthesis and within that parenthesis there can be a composite expression which is here you can see there is a logical expression here is another logical expression and here is a composite logical expression joining them by and or it could be by or etcetera <sil=0.932> .PERIOD So <sil=0.583> ,COMMA in that way we can form the condition statement and if the condition statement is true then these things will be executed <sil=0.919> .PERIOD We will see more examples as we go ahead <sil=0.955> .PERIOD So <sil=0.301> ,COMMA let us look at a little more different little more extension of the structure here <sil=0.965> .PERIOD Here we are going to see the if else structure what we actually want to mean is if a condition is true then we will be doing these things and if the condition is false then I will do these things <sil=0.925> .PERIOD Let me clarify it a little bit more <sil=0.937> .PERIOD Suppose I write if x is greater than 5 increment x by 1 and printf new value of x is percentage d <sil=0.986> .PERIOD Baxlash n x that means if x is greater than 5 suppose x is an integer I am assuming that x is an integer here <sil=0.960> .PERIOD So <sil=0.596> ,COMMA somehow somewhere up here I have written in text equal to or in text just in text and later on I have assigned x to be 7 <sil=0.941> .PERIOD Now <sil=0.558> ,COMMA when I encounter this condition this condition evaluates to true then I come to this set of statements because this condition is true <sil=0.956> .PERIOD So <sil=0.644> ,COMMA what will be the value of x now x was 7 it is greater than 5 therefore <sil=0.402> ,COMMA x will be 8 and what will be printed new value of x is 8 that is what will be printed <sil=0.904> .PERIOD Now <sil=0.460> ,COMMA suppose I write printf x not greater than 5 <sil=0.930> .PERIOD What I intend to do is if this condition is true then this will be printed otherwise this will be printed that is what my intention is that is what I want to do <sil=0.925> .PERIOD But the way I have written it will actually do something different you see when the execution will be done you know the execution is normally done in a sequential manner <sil=0.965> .PERIOD So <sil=0.545> ,COMMA here we will come x is greater than 5 <sil=0.385> ,COMMA x is 7 <sil=0.989> .PERIOD So <sil=0.481> ,COMMA x is greater than 5 this thing will be printed and we will come out and come to this next statement let me number these statements say this statement was 1 this was 2 this was 3 <sil=0.963> .PERIOD Now <sil=0.533> ,COMMA see I am calling this entire if statement to be a single statement <sil=0.948> .PERIOD So <sil=0.357> ,COMMA 3 and then 4 <sil=0.978> .PERIOD So <sil=0.597> ,COMMA normally one will be executed then 2 then 3 now 3 will be executed because x is greater than 5 <sil=0.972> .PERIOD So <sil=0.494> ,COMMA this condition is true and then what will be executed 4 <sil=0.992> .PERIOD So <sil=0.304> ,COMMA what will be the output what will be written here new value of x is 8 will be printed and here when it 4 is executed again will be printed x is not x not greater than 5 <sil=0.938> .PERIOD But that was not my intention <sil=0.912> .PERIOD So <sil=0.335> ,COMMA in order to avoid that I can write a new statement here there was an if if I write here else this that means what if this condition is true then print this otherwise that means <sil=0.551> ,COMMA if this condition is false then do this and then number 5 can be something else and that will be executed <sil=0.989> .PERIOD So <sil=0.506> ,COMMA what will be the execution suppose x is equal to 4 let us try to write down what is the execution sequence then 1 then 2 now x is equal to 4 therefore <sil=0.405> ,COMMA this condition will be false this condition will be false <sil=0.984> .PERIOD Therefore <sil=0.631> ,COMMA this statement 3 will not be executed this part of 3 will not be executed then we will come to this else statement that means <sil=0.565> ,COMMA if the condition is false then I am coming over here and so 4 will be executed 4 will be executed 3 will not be executed completely and then 5 will be executed <sil=0.964> .PERIOD But if I had not put this else then what would have happened in this case if x is 4 in that case this will not be this will not be true only this statement will be printed fine <sil=0.952> .PERIOD There would not be much problem but suppose x is equal to 7 and if this else is not there then what will be printed x is 8 x not greater than 5 <sil=0.963> .PERIOD But if I put the else here if I put the else here I am clearly repeating a little bit more because a lot of students face difficulty in this structure <sil=0.997> .PERIOD So <sil=0.474> ,COMMA if I put else here in that case this will be x is 7 so this will be printed and at this else this condition was true <sil=0.983> .PERIOD So <sil=0.370> ,COMMA this is this part will not be executed this part will be executed only if the condition was false <sil=0.968> .PERIOD So <sil=0.366> ,COMMA this contradictory situation would not occur alright <sil=0.932> .PERIOD So <sil=0.304> ,COMMA let us look at some examples of this F statement if else it is also a single entry single exit structure it allows us to specify to alternate blocks of statement one of which one of which is executed any one of them depending on the outcome of the condition <sil=0.944> .PERIOD Essentially what we are trying to say is that I will have a single entry point to a decision box and I will check for some condition I will test that particular condition if that condition is true then true then I will do some state set of statements let us call that S 1 otherwise if it is false then I will carry out some S 2 alright and then I will be meeting maybe at some other point which is S 3 <sil=0.999> .PERIOD So <sil=0.508> ,COMMA this structure I can write as if condition then I do I have named I have not writing the statements I am just writing S 1 else S 2 and then S 3 <sil=0.905> .PERIOD So <sil=0.512> ,COMMA my flow will be either this way and S 3 or this way and S 3 ok <sil=0.918> .PERIOD If I had not put this else how this diagram look like you have seen this diagram now if I had not put this else how the diagram look like the diagram would look like if here I have got the condition block decision box true then I do S 1 and then I do S 2 and S 3 <sil=0.926> .PERIOD So <sil=0.305> ,COMMA we will come at this point if it is false then I will also come at this point if it is true then also I will join at this point if this else was not there but since this else is there then I just separate out their point of joining alright we will see more examples of this <sil=0.911> .PERIOD So <sil=0.528> ,COMMA the general syntax of this is if condition then block 1 block 1 is what I was calling S 1 the set of statements else block 2 the other statements alright <sil=0.940> .PERIOD If a block contains a single statement then the braces can be deleted I am sorry if the block contains a single statement then these it is not essential that I put them but just for the sake of generality in most of the cases I will have more than one statement therefore <sil=0.394> ,COMMA I am putting that in place alright <sil=0.911> .PERIOD So <sil=0.620> ,COMMA the diagram that I was looking at I was explaining that sort of diagram suppose the grade is 60 if the grade is greater than equal to 60 suppose somebody is grade is or marks is 50 then at this point the condition is false this part will be executed if the grade is 70 that is this condition is true this part will be executed then I will come to this common point this is a common point which will come now <sil=0.904> .PERIOD So <sil=0.644> ,COMMA this I can write as if grade is 60 see here there is only one statement <sil=0.911> .PERIOD So <sil=0.474> ,COMMA I need need not put I have not put the braces here print sorry print a past else print a failed and then whatever I had to do I will do it here and then whatever was following that will follow here ok <sil=0.999> .PERIOD So <sil=0.435> ,COMMA let us come to so I hope this is clear <sil=0.936> .PERIOD So <sil=0.455> ,COMMA the syntax of e fails let us look at little bit more here I have said block 1 block 1 means or S 1 whatever you name it this is block 1 or I had named it as S 1 the same set of statements where there are number of statements each separated by a semicolon please note suppose there are n statements there separated by a semicolon ok <sil=0.906> .PERIOD Now <sil=0.466> ,COMMA next I come to this if I want to do L is also if expression statements 1 to n else state these statements 1 to n <sil=0.964> .PERIOD So <sil=0.345> ,COMMA this is my block 2 and this is block 1 ok <sil=0.942> .PERIOD So <sil=0.308> ,COMMA here we can see that based on this expression which is a condition evaluation if this condition is true I will carry out these statements else I will carry out these statements note that these individual statements have got semicolon and this is a whole body of the L statement this is the whole body of the if statement <sil=0.953> .PERIOD So <sil=0.387> ,COMMA composite if this entire thing we call an if else structure <sil=0.950> .PERIOD So <sil=0.377> ,COMMA if grade is 60 print F past else print failed <sil=0.910> .PERIOD Now <sil=0.634> ,COMMA this next we are coming to a little more complication of the same thing it is a nesting of if else structure <sil=0.966> .PERIOD Now <sil=0.375> ,COMMA by this if else what are we trying to achieve we are achieving branching that means <sil=0.505> ,COMMA we are carrying out a sequential flow we are carrying out a sequential flow and from there we made a decision box and then we branched either in this direction or in this direction <sil=0.987> .PERIOD Now <sil=0.345> ,COMMA suppose here in this direction it is true and this is false again I come and make a decision it can be if x is greater than 5 then I come here and y is greater than 7 then I do something here it can be x is greater than 5 I follow this path <sil=0.538> ,COMMA but y is not greater than 7 so <sil=0.571> ,COMMA I follow this is true this is false I follow this false path if x is greater not greater than 5 I come here and suppose I check z less than 2 true or false there can be 2 outcomes <sil=0.907> .PERIOD So <sil=0.481> ,COMMA suppose x is 4 so <sil=0.558> ,COMMA not greater than 5 I will come through this path now z is 3 so <sil=0.593> ,COMMA z is not greater than 2 less than 2 therefore <sil=0.572> ,COMMA I will follow this path <sil=0.908> .PERIOD So <sil=0.572> ,COMMA you see the paths that we follow that is a branching that we do can have the path that we follow can have more than one decision box say x is greater than x is 7 so <sil=0.447> ,COMMA here I was coming in this path then I follow this path because x is 7 this condition is true and I find that y is 8 so <sil=0.556> ,COMMA I follow this path all right if y was 6 then I would have followed this path <sil=0.963> .PERIOD So <sil=0.467> ,COMMA in the path that the program follows there can be more than one decision box so <sil=0.341> ,COMMA that is what we mean by nesting of Eiffel structures that means <sil=0.493> ,COMMA nest one Eiffel statement within another now all statements may not have the else part now rule to remember this and else clause is associated with the closest preceding unmatched Eiff really confusing what do I mean by this let us look at this how will this be executed <sil=0.948> .PERIOD Here E1 means some expression if E1 is true then S1 else if E2 then S2 now with whom does this else go this else certainly goes with this preceding F if I just quickly draw this that flow chart corresponding to this how does it look like I come here and evaluate the expression E1 on true I do S1 on true I do S1 on false here is false all right I come here and there is another Eiff here so <sil=0.648> ,COMMA I again check E2 if E2 is true then I do S2 this statement actually means this graph if E1 is true then I will carry out S1 otherwise else is there so <sil=0.355> ,COMMA this else is linked to this if then I do this one what about this let us erase this for a while and how would we interpret this one here you can see there are two else's with whom is this else paired this else is paired with I have written in a bad way this else is paired with this F so <sil=0.599> ,COMMA this means again I check E1 E1 is true so <sil=0.402> ,COMMA I carry out S1 else false that means this else is for this decision box I check here E2 E2 is true so <sil=0.631> ,COMMA I carry out S2 and else I will carry out S3 this is what I am trying to do now here I would have preferred to write it in a better way that is why if you recall in a earlier lecture we had talked about a good program writing practice that is the indentation I would have liked to write it in this way F E1 then S1 else if E2 then S2 else S3 which makes it very clear that this else is corresponding to this F and this F this else is corresponding to this F right let us look at the third scenario what does it mean if E1 if E2 S1 how do I draw that I draw that like that I take E1 if E1 that means <sil=0.594> ,COMMA if E1 is true I immediately come here and the statement starts with another if a nested if this is known as a nested if one if within another there is one if statement there is another if statement within this this is knows as nested all right so <sil=0.530> ,COMMA here sorry I will be here if E2 S1 so <sil=0.432> ,COMMA immediately I am there is no else here by the way so <sil=0.456> ,COMMA if E1 then I come here then if statement is again there therefore <sil=0.603> ,COMMA there is another decision box where I am checking the condition E2 and if E2 is true then I will follow then I will carry out S1 else S2 which else should it be here or there now this is something this else is pairing with the preceding F so <sil=0.611> ,COMMA it should be false will be S2 now this else is therefore <sil=0.574> ,COMMA covered this path is covered so <sil=0.313> ,COMMA this else can only mean this one and S3 will be because this is already covered right so <sil=0.331> ,COMMA this is the nearest one to this clear so <sil=0.618> ,COMMA if we go to the earlier slide let me go back to the presentation so <sil=0.576> ,COMMA here this one how this one actually look like how will this one look like there is something still there so <sil=0.301> ,COMMA how will this one look like coming straight here if E1 if the condition is met then I again test here if E2 this is true this is true then I come and do it here S1 and else this else is again with this F so <sil=0.647> ,COMMA it will be here S2 and I have not specified this one here all right so <sil=0.551> ,COMMA if you put a little bit of mind here so <sil=0.527> ,COMMA you can see many different other scenarios that can come and we can proceed accordingly <sil=0.914> .PERIOD Let us see here this one as I was saying it would be nicer to write it in this way because here you may feel ok there two else is two if who goes with home now here if I write it in this way if E1 S1 else that means <sil=0.543> ,COMMA this if cells else if E2 S2 here if E1 S1 else if E2 S2 else S3 so <sil=0.401> ,COMMA this else is therefore <sil=0.349> ,COMMA with I am sorry I think I think I will have to go back to a couple of slides you see and else clause I would like to be corrected a little bit and else clause is associated with the closest preceding unmatched if any if that is not there that should be it should match with that so <sil=0.505> ,COMMA that is what I explained in the these examples so <sil=0.480> ,COMMA it is a much better for example <sil=0.316> ,COMMA let us look at this how do I like to write this if E1 I would not prefer this also I would prefer that I write it in this way if E1 then if E2 S1 else S2 then it becomes very clear this if cells and else are very clear say for example <sil=0.319> ,COMMA here also this is better but still I would prefer to write this one as this one as this is one way I can write if E1 if then I mean this is the part of if if E2 S1 else S2 and under this if that is what is been done here else S3 okay so <sil=0.364> ,COMMA what we have learned today is a nesting of another structure what we are discussing now is how we can have better or more versatile flow normally it is a sequential flow but based on the decision condition points I may have to take different parts which is known as branching right and for branching or selecting the proper path the structure is F and along with that we have learned today if else structure and we have seen how if else structure can be nested to give rise to some better more versatile scenarios we will continue with this in the next lecture thank you <sil=0.954> .PERIOD Today <sil=0.518> ,COMMA we will first discuss a technique called interpolation <sil=0.915> .PERIOD We have seen how a function can be represented in a computer in the form of a table or a two dimension library <sil=0.904> .PERIOD Now <sil=0.404> ,COMMA what is interpolation <sil=0.922> ?QUESTIONMARK Let us try to understand <sil=0.926> .PERIOD Say <sil=0.510> ,COMMA I have got a function where I know the I have got a function which is something like this <sil=0.558> ,COMMA but I do not know the function beforehand <sil=0.903> .PERIOD If I had known the function <sil=0.433> ,COMMA this description of this function <sil=0.472> ,COMMA in that case given any x <sil=0.649> ,COMMA I could have found out the corresponding y <sil=0.341> ,COMMA right <sil=0.938> .PERIOD But suppose the function is not given <sil=0.909> .PERIOD Instead <sil=0.365> ,COMMA what is given to us are for some specific x's <sil=0.414> ,COMMA say x 1 <sil=0.479> ,COMMA I have been given this value <sil=0.403> ,COMMA all right <sil=0.983> .PERIOD This value of y <sil=0.592> ,COMMA for x 2 <sil=0.459> ,COMMA x equal to 2 <sil=0.334> ,COMMA I have been given this value of y <sil=0.403> ,COMMA all right <sil=0.956> .PERIOD This particular value of y <sil=0.949> .PERIOD Similarly <sil=0.381> ,COMMA for 3 <sil=0.449> ,COMMA I am given a particular value of y <sil=0.984> .PERIOD But I do not know what is the value of function for 1 <sil=0.948> .PERIOD 5 <sil=0.990> .PERIOD So <sil=0.585> ,COMMA if I call this to be the function f of x <sil=0.300> ,COMMA then f of f of 1 <sil=0.983> .PERIOD 5 is not known <sil=0.981> .PERIOD Although <sil=0.406> ,COMMA I know that f of 1 is say something 2 <sil=0.957> .PERIOD 5 <sil=0.951> ,COMMA I know f of 2 to be maybe 3 <sil=0.988> .PERIOD 2 <sil=0.914> ,COMMA f of 3 <sil=0.629> ,COMMA maybe something like 4 <sil=0.953> .PERIOD But these information are known to me <sil=0.301> ,COMMA this part is known to me <sil=0.990> .PERIOD Given this known part <sil=0.319> ,COMMA can I find out what are the intermediate values for f 1 <sil=0.970> .PERIOD 5 <sil=0.975> ,COMMA f 1 <sil=0.910> .PERIOD 3 <sil=0.304> ,COMMA 2 <sil=0.474> .PERIOD 5 <sil=0.932> ,COMMA 2 <sil=0.382> .PERIOD 6 <sil=0.558> ?QUESTIONMARK Can I find that out <sil=0.981> ?QUESTIONMARK That is the task of interpolation <sil=0.916> .PERIOD That means <sil=0.495> ,COMMA given some values known <sil=0.349> ,COMMA I want to find out the value of the function for some independent value of the dependent variable <sil=0.905> .PERIOD So <sil=0.439> ,COMMA for a particular x <sil=0.528> ,COMMA what is the y that I want to find out <sil=0.943> .PERIOD Now <sil=0.428> ,COMMA obviously <sil=0.424> ,COMMA you can look at this blue line and say it is so simple <sil=0.521> ,COMMA you draw it like this and you will find the value of y <sil=0.970> .PERIOD But unfortunately <sil=0.368> ,COMMA what I have is not the blue line <sil=0.909> .PERIOD What I have is only the red crosses and this line is not there <sil=0.911> .PERIOD I do not know that these three points <sil=0.545> ,COMMA whether the curve is something like this or the curve is could be the curve could be a straight line through this points <sil=0.912> .PERIOD In that case <sil=0.627> ,COMMA you see if it was the case <sil=0.509> ,COMMA then the value of x <sil=0.639> ,COMMA this particular x would be different from this <sil=0.964> .PERIOD So <sil=0.407> ,COMMA I have to actually see that what is the curve that best fits all these given points <sil=0.905> .PERIOD This problem is known as interpolation <sil=0.915> .PERIOD Now <sil=0.387> ,COMMA I can extend it suppose some table is given to you <sil=0.391> ,COMMA where values for f 1 <sil=0.521> ,COMMA 2 and 3 are given and so <sil=0.359> ,COMMA the range is from 1 to 3 <sil=0.994> .PERIOD But <sil=0.452> ,COMMA you are asked for some particular x prime which is beyond this <sil=0.506> ,COMMA beyond this range <sil=0.939> .PERIOD In that case <sil=0.644> ,COMMA it is also extra interpolation on the other side <sil=0.905> .PERIOD That means <sil=0.447> ,COMMA beyond the boundary that is known as extra interpolation <sil=0.916> .PERIOD Right <sil=0.961> ?QUESTIONMARK Now <sil=0.567> ,COMMA so basically the concept of extrapolation and interpolation are more or less the same <sil=0.975> .PERIOD So <sil=0.399> ,COMMA here what I try to we will try to see is given some values of f x known values of f x for some particular x's <sil=0.957> .PERIOD How do we find out the value of f x for some intermediate value of x <sil=0.941> ?QUESTIONMARK That is the task of interpolation <sil=0.966> .PERIOD Now <sil=0.321> ,COMMA the simplest possible way of interpolating <sil=0.953> .PERIOD Now <sil=0.328> ,COMMA here I show I had shown a curve usually you can also start with a table like this <sil=0.574> ,COMMA where some x's are given and some y's are some x values are given say 0 <sil=0.923> .PERIOD 1 <sil=0.465> ,COMMA 0 <sil=0.330> .PERIOD 2 <sil=0.974> ,COMMA 0 <sil=0.636> .PERIOD 3 <sil=0.330> ,COMMA 0 <sil=0.470> .PERIOD 4 <sil=0.615> ,COMMA 0 <sil=0.522> .PERIOD 5 and for each of them you have got some y value 2 <sil=0.931> .PERIOD 7 <sil=0.971> ,COMMA 3 <sil=0.473> .PERIOD 2 <sil=0.919> ,COMMA 1 <sil=0.620> .PERIOD 6 coming down again say 0 <sil=0.913> .PERIOD 6 and again it goes up say 3 <sil=0.922> .PERIOD 2 <sil=0.919> .PERIOD Now <sil=0.492> ,COMMA if this be the table then my question is for interpolation <sil=0.579> ,COMMA what is the value <sil=0.858> ?QUESTIONMARK What is the value for x which is 0 <sil=0.921> .PERIOD 27 <sil=0.936> ?QUESTIONMARK What is the value of this <sil=0.941> ?QUESTIONMARK So <sil=0.517> ,COMMA that is the task of interpolation <sil=0.918> .PERIOD Now <sil=0.356> ,COMMA obvious is the simplest possible thing is if I can fit in a line which is known as a linear interpolation <sil=0.954> .PERIOD So <sil=0.330> ,COMMA I have got some points here and I try to fit in a line in between them or let me let me do it in a different way <sil=0.905> .PERIOD Not exactly this line because this line is matching two points but not the others <sil=0.948> .PERIOD So <sil=0.600> ,COMMA this is my y and this is x <sil=0.978> .PERIOD So <sil=0.426> ,COMMA there could be some points like this here <sil=0.385> ,COMMA something here <sil=0.496> ,COMMA something here <sil=0.439> ,COMMA something here like that <sil=0.448> ,COMMA equidistant points <sil=0.919> .PERIOD See this and I try to fit in a line that is somehow I draw a line like this <sil=0.936> .PERIOD This is a straight line although my drawing is a little curved but it is a straight line <sil=0.918> .PERIOD So <sil=0.616> ,COMMA I am drawing a straight line <sil=0.957> .PERIOD So <sil=0.599> ,COMMA one way is that I try to find out a line such that I minimize the error <sil=0.986> .PERIOD So <sil=0.575> ,COMMA of course <sil=0.590> ,COMMA if I assume that this line is representing my function <sil=0.502> ,COMMA then I can see there is some error here <sil=0.532> ,COMMA there is some error here <sil=0.546> ,COMMA there is some error here <sil=0.549> ,COMMA there is some error here <sil=0.386> .PERIOD I could have fitted another line also <sil=0.574> ,COMMA I could have changed this line a little bit <sil=0.940> .PERIOD One of the ways is to find a line that minimizes the error <sil=0.997> .PERIOD Now <sil=0.471> ,COMMA it depends on how you define the error <sil=0.953> .PERIOD Here you can see it is a positive error <sil=0.643> ,COMMA it is a negative error <sil=0.584> ,COMMA it is a positive error like that it can go on <sil=0.962> .PERIOD So <sil=0.421> ,COMMA one way is to find out minimize <sil=0.463> ,COMMA find a line such that the least square or let us say such that the square sum of squared error is minimized <sil=0.969> .PERIOD That can be one way that means <sil=0.359> ,COMMA what is an error <sil=0.892> ?QUESTIONMARK Error is E i when I take whatever my line is saying <sil=0.350> ,COMMA let me call it L i <sil=0.628> ,COMMA what the line is telling me the value <sil=0.384> ,COMMA let me call it L i and whatever is the actual value minus Y i if I consider that to be the error or the other way <sil=0.975> .PERIOD Now <sil=0.433> ,COMMA I so you can see it is a positive or negative and I take the error of all these <sil=0.915> .PERIOD So <sil=0.370> ,COMMA that could be a sum of error <sil=0.612> ,COMMA but here what I am saying is that I can have the square of this error and I try to find out a line such that E i square is minimized <sil=0.939> .PERIOD So <sil=0.379> ,COMMA that I get a very good line <sil=0.970> .PERIOD Now <sil=0.559> ,COMMA suppose I get a very good line like this <sil=0.328> ,COMMA then I will have the equation of that line <sil=0.934> .PERIOD Now <sil=0.575> ,COMMA given two points it is very simple <sil=0.321> ,COMMA let us take the simplest case first <sil=0.995> .PERIOD So <sil=0.505> ,COMMA if there be only two points given <sil=0.479> ,COMMA then I can certainly draw a unique line between these two points <sil=0.926> .PERIOD And so <sil=0.591> ,COMMA I can find out the equation of these <sil=0.966> .PERIOD So <sil=0.307> ,COMMA this is school level coordinate geometry <sil=0.349> ,COMMA x 1 y 1 x 2 y 2 <sil=0.982> .PERIOD So <sil=0.518> ,COMMA you can find out the slope of this line <sil=0.647> ,COMMA you can find the slope of this line which will be nothing <sil=0.635> ,COMMA but y 2 minus y 1 divided by x 2 minus x 1 <sil=0.902> .PERIOD So <sil=0.318> ,COMMA once you get the slope <sil=0.491> ,COMMA then you can find out the line <sil=0.913> .PERIOD So <sil=0.510> ,COMMA the school level equations like y minus y 1 is equal to m into x minus x 1 <sil=0.485> ,COMMA where m is this <sil=0.625> ,COMMA m is the slope <sil=0.936> .PERIOD So <sil=0.617> ,COMMA you can find the line <sil=0.930> .PERIOD So <sil=0.617> ,COMMA when you find the line <sil=0.465> ,COMMA then your problem is solved <sil=0.573> ,COMMA because now given any particular <sil=0.469> ,COMMA suppose you get a line of the equation A x plus C <sil=0.386> ,COMMA where C is this and you get the coefficients like this <sil=0.973> .PERIOD Now <sil=0.395> ,COMMA given any x <sil=0.366> ,COMMA I give x prime <sil=0.397> ,COMMA then from that equation <sil=0.512> ,COMMA I can straight away find the value of y A x prime plus C <sil=0.902> .PERIOD That is straight forward <sil=0.309> ,COMMA but the problem is that often it is not only two points <sil=0.459> ,COMMA but the points are rather distributed as I was showing in the earlier one like this <sil=0.426> ,COMMA where I do not get an exact line that is cutting through all the points <sil=0.597> ,COMMA I have to try <sil=0.423> ,COMMA I will try to minimize the error and I will choose such a line <sil=0.947> .PERIOD Now <sil=0.362> ,COMMA when I choose such a line <sil=0.361> ,COMMA that means <sil=0.421> ,COMMA I have chosen an equation and therefore <sil=0.583> ,COMMA again from that linear equation <sil=0.362> ,COMMA I can find out the value of y for any given x <sil=0.971> .PERIOD So <sil=0.632> ,COMMA this is this approach is known as linear interpolation <sil=0.946> .PERIOD However <sil=0.373> ,COMMA the linear interpolation often as you can see <sil=0.329> ,COMMA the error will be there <sil=0.948> .PERIOD So <sil=0.420> ,COMMA people try to find out more accurate solutions <sil=0.907> .PERIOD So <sil=0.423> ,COMMA we will look at another inter <sil=0.515> ,COMMA so first of all we have seen what is linear interpolation <sil=0.915> .PERIOD The basic idea is very simple <sil=0.391> ,COMMA we try to fit in the best possible straight line through all the points <sil=0.354> ,COMMA so that the error is minimized <sil=0.931> .PERIOD Total error is minimized <sil=0.954> .PERIOD One way is to minimize the sum of the square or there could be some other measures you can take for error <sil=0.470> ,COMMA that should be minimized <sil=0.971> .PERIOD So <sil=0.527> ,COMMA you get a line to your satisfaction <sil=0.915> .PERIOD So <sil=0.313> ,COMMA once you get a line to your satisfaction <sil=0.556> ,COMMA you know the equation of the line <sil=0.966> .PERIOD Therefore <sil=0.308> ,COMMA given any x <sil=0.389> ,COMMA you can find the corresponding y <sil=0.966> .PERIOD Now <sil=0.410> ,COMMA fitting this line always the <sil=0.310> ,COMMA there may be situations where the points are distributed in such a way <sil=0.972> .PERIOD For example <sil=0.632> ,COMMA it can be the points are something like this <sil=0.569> ,COMMA all right <sil=0.903> .PERIOD It is very difficult to find a line over here <sil=0.995> .PERIOD So <sil=0.403> ,COMMA often I would like to find out a curve or maybe another curve even better <sil=0.467> ,COMMA that can be that goes through these points like this <sil=0.552> ,COMMA where I have got errors <sil=0.330> ,COMMA but I am trying to fit in a curve <sil=0.984> .PERIOD So <sil=0.572> ,COMMA that is not a line <sil=0.469> ,COMMA this is not a linear interpolation <sil=0.391> ,COMMA there are further extensions like quadratic interpolation <sil=0.433> ,COMMA spline interpolation <sil=0.585> ,COMMA cubic spline and all those <sil=0.919> .PERIOD So <sil=0.312> ,COMMA it is better to know the names <sil=0.448> ,COMMA spline interpolation <sil=0.465> ,COMMA quadratic interpolation <sil=0.389> ,COMMA where I want to fit in a quadratic curve <sil=0.428> ,COMMA etcetera <sil=0.415> ,COMMA etcetera <sil=0.530> .PERIOD But today we will discuss another interpolation technique <sil=0.428> ,COMMA which is known as Lagrange interpolation <sil=0.942> .PERIOD In the name of the mathematician who invented it <sil=0.996> .PERIOD So <sil=0.629> ,COMMA let us have a look at the Lagrange interpolation <sil=0.956> .PERIOD Interpolation as you have understood is given a set of k plus 1 data points <sil=0.308> ,COMMA x 0 y 0 x x 1 y 1 x 2 y 2 like that up to x k y k <sil=0.997> .PERIOD So <sil=0.408> ,COMMA many data points are given <sil=0.921> .PERIOD The Lagrange polynomial is this <sil=0.406> ,COMMA that is multiplication of <sil=0.981> .PERIOD So <sil=0.573> ,COMMA I have to find out for a particular x <sil=0.491> ,COMMA x minus x m divided by x j minus x m <sil=0.513> ,COMMA where m is varying from 0 to k for all these m is varying <sil=0.965> .PERIOD So <sil=0.627> ,COMMA x 0 x 1 x 2 x 3 for all these I will do that and x j minus x m <sil=0.594> ,COMMA where j is for a particular Lagrange interpolation <sil=0.975> .PERIOD So <sil=0.339> ,COMMA you see it is for L 1 <sil=0.511> ,COMMA L 1 x will be x minus x 0 by x 1 minus x 0 x minus x 0 x minus x 0 x 1 minus x 0 like that it will go on <sil=0.950> .PERIOD So <sil=0.443> ,COMMA this is the Lagrange polynomial <sil=0.962> .PERIOD So <sil=0.560> ,COMMA using this polynomial we can see <sil=0.496> ,COMMA let us see how it works just to give you an example <sil=0.984> .PERIOD I have reproduced that polynomial that I had shown in the earlier slide here again <sil=0.986> .PERIOD You can see this <sil=0.932> .PERIOD Now <sil=0.524> ,COMMA suppose I have got the points given look here <sil=0.970> .PERIOD The points that are given for x 0 for x x value 1 <sil=0.418> ,COMMA f x is 1 for x value 2 <sil=0.460> ,COMMA f x is 4 3 is 9 <sil=0.973> .PERIOD So <sil=0.410> ,COMMA I have to fit in a polynomial <sil=0.957> .PERIOD I have to fit in a polynomial <sil=0.968> .PERIOD So <sil=0.411> ,COMMA I my polynomial is capital L x <sil=0.954> .PERIOD Now <sil=0.411> ,COMMA each term of this is 1 small L x <sil=0.926> .PERIOD So <sil=0.405> ,COMMA this is L 1 x <sil=0.326> ,COMMA this is L 2 x <sil=0.635> ,COMMA this is L 3 x like that <sil=0.924> .PERIOD So <sil=0.392> ,COMMA you see the value of x is 1 <sil=0.612> ,COMMA 1 times x minus x m <sil=0.444> ,COMMA m will be something that will be not the same as j <sil=0.920> .PERIOD So <sil=0.589> ,COMMA it will be I have got 3 points <sil=0.999> .PERIOD So <sil=0.516> ,COMMA I will not take this one <sil=0.609> ,COMMA x minus 2 divided by 1 minus 2 times the second term x minus 3 divided by 1 minus 3 plus 4 <sil=0.948> .PERIOD Now <sil=0.450> ,COMMA I am taking this one <sil=0.944> .PERIOD So <sil=0.607> ,COMMA it is 4 and in that case I will leave out 2 <sil=0.491> ,COMMA my x j is now 2 <sil=0.936> .PERIOD So <sil=0.321> ,COMMA x minus 1 <sil=0.615> ,COMMA I will not take x minus 2 here <sil=0.391> ,COMMA because look at this m not equal to j <sil=0.935> .PERIOD So <sil=0.485> ,COMMA for the other x's <sil=0.603> ,COMMA I have selected this row <sil=0.918> .PERIOD So <sil=0.418> ,COMMA I will only concentrate on the other rows x minus 1 divided by 2 minus 1 into x minus 3 <sil=0.531> ,COMMA x minus 3 the other row divided by 2 minus 3 <sil=0.933> .PERIOD Here <sil=0.398> ,COMMA I take 9 this value and I am taking this row now <sil=0.974> .PERIOD So <sil=0.306> ,COMMA now I am taking this row <sil=0.310> ,COMMA I have taken 9 <sil=0.993> .PERIOD So <sil=0.542> ,COMMA x minus 1 by 3 minus 1 <sil=0.332> ,COMMA x minus 2 by 3 minus 2 <sil=0.918> .PERIOD If I solve this <sil=0.647> ,COMMA I am getting a polynomial x square <sil=0.943> .PERIOD Possibly you can see that is a perfect fit with the given data points <sil=0.911> .PERIOD x 1 <sil=0.467> ,COMMA x f x is x square that is 1 <sil=0.535> ,COMMA 2 it is x square 4 <sil=0.364> ,COMMA 3 it is x square 9 <sil=0.935> .PERIOD So <sil=0.477> ,COMMA in this case there is no error <sil=0.335> ,COMMA it is absolutely a perfect fit <sil=0.970> .PERIOD So <sil=0.498> ,COMMA this is how I get the polynomial <sil=0.988> .PERIOD Let us try once again for this data value <sil=0.919> .PERIOD For x 0 it is 1 <sil=0.648> ,COMMA x 0 1 the f x is 1 for x equal to 2 <sil=0.337> ,COMMA it is 8 <sil=0.320> ,COMMA for x equal to 3 <sil=0.425> ,COMMA it is 27 <sil=0.928> .PERIOD So <sil=0.581> ,COMMA obviously you can see it is no longer x square <sil=0.992> .PERIOD It is not also x cube <sil=0.475> ,COMMA because here it is cube <sil=0.506> ,COMMA here it is cube <sil=0.616> ,COMMA it is matching the cube <sil=0.546> ,COMMA it is actually x cube <sil=0.901> .PERIOD But let us try to fit in a polynomial here <sil=0.910> .PERIOD So <sil=0.351> ,COMMA what is that polynomial <sil=0.982> ?QUESTIONMARK Using the Lagrange method <sil=0.318> ,COMMA I will first check 1 <sil=0.958> .PERIOD So <sil=0.417> ,COMMA I am taking first row <sil=0.432> ,COMMA taking this value 1 here <sil=0.336> ,COMMA then x minus 2 <sil=0.534> ,COMMA 1 minus 2 <sil=0.643> ,COMMA times x minus 3 <sil=0.422> ,COMMA 3 <sil=0.340> ,COMMA 1 minus 3 plus next time I take the second row <sil=0.350> ,COMMA 8 times x minus 1 divided by 2 minus 1 <sil=0.426> ,COMMA because here it is the value is 2 <sil=0.910> .PERIOD In that way <sil=0.318> ,COMMA for this it will be <sil=0.332> ,COMMA for the third row it will be again x minus 1 <sil=0.471> ,COMMA 3 minus 1 <sil=0.383> ,COMMA x minus 2 <sil=0.441> ,COMMA 6 minus 2 <sil=0.930> .PERIOD By doing this <sil=0.381> ,COMMA I am not getting x cube <sil=0.531> ,COMMA which would be a perfect fit <sil=0.344> ,COMMA but I am getting a close enough polynomial <sil=0.541> ,COMMA 6 x square minus 11 x plus 6 <sil=0.603> ,COMMA which will be approximating the cube function very closely <sil=0.963> .PERIOD You can see that <sil=0.936> .PERIOD So <sil=0.601> ,COMMA it is not that Lagrange polynomial will always give you the perfect fit <sil=0.525> ,COMMA but it gives you a very close fit <sil=0.965> .PERIOD So <sil=0.370> ,COMMA this is what is known as Lagrange interpolation <sil=0.980> .PERIOD So <sil=0.609> ,COMMA if I want to write a program and try to solve it <sil=0.602> ,COMMA I will have to implement a function that I have to write a function that will implement this or this <sil=0.999> .PERIOD Let us see how we can do that <sil=0.993> .PERIOD So <sil=0.613> ,COMMA here is an algorithm <sil=0.589> ,COMMA scan the number of data available <sil=0.488> ,COMMA x and y values <sil=0.920> .PERIOD Now <sil=0.395> ,COMMA so you take the <sil=0.530> ,COMMA here is the how many data points <sil=0.385> ,COMMA this is telling how many data points here you are finding the data <sil=0.998> .PERIOD Now <sil=0.381> ,COMMA here loop for i equal to number of data factor <sil=0.461> ,COMMA then here you are computing this <sil=0.911> .PERIOD Here you see what we are trying to do <sil=0.546> ,COMMA at this point we have just read the data <sil=0.929> .PERIOD And here in a loop <sil=0.527> ,COMMA we are trying to compute <sil=0.350> ,COMMA here we are finding the sum <sil=0.562> ,COMMA but here in the loop I am finding the factor <sil=0.928> .PERIOD So <sil=0.527> ,COMMA if you go to the earlier slide <sil=0.335> ,COMMA you will find that I have got these are my factors <sil=0.594> ,COMMA I am finding these factors <sil=0.643> ,COMMA each of these factors <sil=0.318> ,COMMA I am multiplying them <sil=0.335> ,COMMA this is a factor <sil=0.427> ,COMMA this whole thing is a factor <sil=0.937> .PERIOD And then I multiply that with the coefficient and add them up <sil=0.960> .PERIOD So <sil=0.341> ,COMMA I am doing the summation at the end <sil=0.957> .PERIOD So <sil=0.530> ,COMMA here you see that I am taking the factor <sil=0.331> ,COMMA then I am taking the whatever is the value <sil=0.470> ,COMMA this you can <sil=0.493> ,COMMA this part you can yourself compute <sil=0.334> ,COMMA right <sil=0.958> .PERIOD The key part is computational the factor part <sil=0.535> ,COMMA where I am showing this part <sil=0.964> .PERIOD You can see that for i 0 to data i plus plus <sil=0.648> ,COMMA I am initially a factor is 1 <sil=0.604> ,COMMA because I am multiplying that <sil=0.343> ,COMMA then if i is not equal to j <sil=0.425> ,COMMA I will take the factor times the value minus the data <sil=0.969> .PERIOD So <sil=0.454> ,COMMA and then ultimately I am printing the coefficient <sil=0.951> .PERIOD So <sil=0.349> ,COMMA you can translate that into in the form of a C function <sil=0.907> .PERIOD That is the basic idea of lagrange interpolation <sil=0.623> ,COMMA you can similarly write programs for linear interpolation and other interpolation techniques <sil=0.905> .PERIOD So <sil=0.649> ,COMMA the point of this course is not to <sil=0.544> ,COMMA because I assume that you now know how to do programming <sil=0.430> ,COMMA and these are simple loop type of programming <sil=0.914> .PERIOD So <sil=0.585> ,COMMA you will be able to do that <sil=0.919> .PERIOD So <sil=0.482> ,COMMA whenever you want to solve <sil=0.439> ,COMMA apply some numerical methods <sil=0.905> .PERIOD You will have to first look at the technique <sil=0.645> ,COMMA then try to find out the expression <sil=0.375> ,COMMA and you will have to write an algorithm so that you can solve it <sil=0.939> .PERIOD In the next lecture <sil=0.435> ,COMMA we will discuss two other very interesting techniques for integration and differential equation solving <sil=0.980> .PERIOD Thank you <sil=0.958> .PERIOD We have seen functions in the earlier lecture and we have also seen we tried to solve a problem with where there were names of the students in one array and the marks in another array <sil=0.949> .PERIOD And we tried to find out <sil=0.491> ,COMMA tried to print out the name of the student who got the highest marks <sil=0.908> .PERIOD So <sil=0.612> ,COMMA for that we had two different areas <sil=0.969> .PERIOD Now <sil=0.550> ,COMMA the same thing I can do today <sil=0.575> ,COMMA say I have 10 students and each of them have appeared for <sil=0.503> ,COMMA each of them has appeared for four subjects <sil=0.926> .PERIOD All right <sil=0.944> .PERIOD So <sil=0.452> ,COMMA let us say there are five students and each of them has appeared for four subjects <sil=0.957> .PERIOD So <sil=0.571> ,COMMA how do I what would be a convenient way of representing them <sil=0.982> ?QUESTIONMARK One convenient way of representing them would be to have a two dimensional matrix <sil=0.458> ,COMMA two dimensional array where on this side I will have the role number of the students <sil=0.447> ,COMMA which is an integer and I have got five students <sil=0.999> .PERIOD So <sil=0.631> ,COMMA one <sil=0.970> ,COMMA two <sil=0.465> ,COMMA three <sil=0.492> ,COMMA four and five students and the marks as the columns <sil=0.971> .PERIOD So <sil=0.645> ,COMMA for any problem solving <sil=0.306> ,COMMA we will have to think of how can we represent the data so that our computation is made easy <sil=0.933> .PERIOD So <sil=0.596> ,COMMA that our computation is facilitated <sil=0.986> .PERIOD So <sil=0.387> ,COMMA suppose there are five students say role number one <sil=0.587> ,COMMA role number two <sil=0.398> ,COMMA role number three <sil=0.644> ,COMMA role number four <sil=0.425> ,COMMA role number five and for each of them <sil=0.369> ,COMMA we have got four columns for the four subjects <sil=0.963> .PERIOD Suppose the subjects are say language <sil=0.462> ,COMMA science <sil=0.479> ,COMMA mathematics and say history <sil=0.328> ,COMMA four subjects <sil=0.907> .PERIOD And so <sil=0.486> ,COMMA how would I read the marks <sil=0.874> ?QUESTIONMARK How would I first of all store the marks of the students <sil=0.866> ?QUESTIONMARK You can very easily understand now now I am not writing the program <sil=0.973> .PERIOD I am leaving the writing of the program to you <sil=0.615> ,COMMA but let us try to understand how it can possibly be solved <sil=0.943> .PERIOD So <sil=0.578> ,COMMA I will have a function <sil=0.371> ,COMMA I can write a function of acquiring data <sil=0.923> .PERIOD What will that do <sil=0.869> ?QUESTIONMARK For on this side <sil=0.312> ,COMMA I can have an index i that will talk about the role that I am talking about that means <sil=0.591> ,COMMA with student I am talking about <sil=0.954> .PERIOD And another index may be j or instead of i j <sil=0.440> ,COMMA you can say role and marks that is also fine <sil=0.928> .PERIOD So <sil=0.489> ,COMMA keeping i fixed and then you can fill up the row of the marks of the student <sil=0.994> .PERIOD So <sil=0.473> ,COMMA how would that program segment look like <sil=0.858> ?QUESTIONMARK That program segment will look like for i assigned 0 i less than equal to 4 because there are 5 students i plus plus that is for 1 row for j equal 0 j less than equal to 3 because there are 4 columns j plus plus scan F <sil=0.978> .PERIOD Now <sil=0.409> ,COMMA you know what to write within the scan F <sil=0.915> .PERIOD So <sil=0.488> ,COMMA in that way I can read the marks <sil=0.969> .PERIOD What I was saying is that instead of this <sil=0.425> ,COMMA I can say for I can be very clear about it for role equal to 0 <sil=0.325> ,COMMA role less than equal to 4 role plus plus sorry <sil=0.572> ,COMMA role plus plus and for j similarly <sil=0.482> ,COMMA I can make marks <sil=0.920> .PERIOD So <sil=0.308> ,COMMA marks 0 <sil=0.627> ,COMMA marks less than 3 <sil=0.308> ,COMMA marks plus plus etcetera in that way I can fill up the table <sil=0.930> .PERIOD So <sil=0.535> ,COMMA now in that way I can fill up the table and say I get the marks as 50 <sil=0.453> ,COMMA 25 <sil=0.395> ,COMMA 70 <sil=0.418> ,COMMA 35 like that some numbers <sil=0.976> .PERIOD Now <sil=0.565> ,COMMA I can have another function that will find out the total marks of each student <sil=0.984> .PERIOD So <sil=0.319> ,COMMA right now I do not have a space for that <sil=0.957> .PERIOD So <sil=0.352> ,COMMA I can keep that in mind when I am preparing my table then I can have the fifth column for the total marks <sil=0.469> ,COMMA right <sil=0.905> .PERIOD Now <sil=0.429> ,COMMA I will pass on I have read this <sil=0.989> .PERIOD So <sil=0.403> ,COMMA first of all I in from my main program <sil=0.582> ,COMMA I went to a particular function I called a particular function which acquired the data and filled up all these say 70 <sil=0.401> ,COMMA 20 <sil=0.471> ,COMMA 90 <sil=0.349> ,COMMA 15 <sil=0.565> ,COMMA 35 <sil=0.518> ,COMMA 75 <sil=0.407> ,COMMA 90 <sil=0.467> ,COMMA 80 <sil=0.546> ,COMMA 20 <sil=0.368> ,COMMA 25 <sil=0.531> ,COMMA 60 <sil=0.325> ,COMMA 30 <sil=0.365> ,COMMA 10 <sil=0.488> ,COMMA 20 <sil=0.513> ,COMMA 30 <sil=0.360> ,COMMA 40 like that that it has been prepared <sil=0.986> .PERIOD So <sil=0.577> ,COMMA quickly let us see what we did we had we entered into a main function and from the main function I called invoked a function which is acquired data and what should the type of that function be acquired data is it returning anything <sil=0.936> ?QUESTIONMARK No <sil=0.392> .PERIOD So <sil=0.357> ,COMMA it should be something like void acquired data d and what is it acquiring the data in the integer array <sil=0.508> ,COMMA int say let us call that array a and there should be it is a two dimensional array <sil=0.980> .PERIOD So <sil=0.440> ,COMMA I should have something like this just I am writing clearly int a if that array was a that was the parameter <sil=0.958> .PERIOD Now <sil=0.589> ,COMMA so here that was array a and here it has been called like acquire data say my array and also the size has been specified the size is suppose globally specified <sil=0.963> .PERIOD So <sil=0.620> ,COMMA I get that array size suppose it is defined that role size is 5 and subject size is 4 <sil=0.914> .PERIOD So <sil=0.629> ,COMMA I know but this this says subject size plus 1 <sil=0.955> .PERIOD So <sil=0.308> ,COMMA I needed one more <sil=0.944> .PERIOD So <sil=0.342> ,COMMA I can I can go here and from there I returned here and then I can call another find total of my array <sil=0.985> .PERIOD Then what will you do <sil=0.851> ?QUESTIONMARK Essentially <sil=0.536> ,COMMA I come to this and what does that function do that piece of function that is finding out the total of each student <sil=0.982> .PERIOD So <sil=0.394> ,COMMA that will again be a for look like the one that we had done earlier and I will add keep I to be fixed and add this and write the total here <sil=0.958> .PERIOD Now <sil=0.365> ,COMMA I could have kept it here or I can have another array total <sil=0.933> .PERIOD Let us do that <sil=0.936> .PERIOD Suppose <sil=0.629> ,COMMA I am not having I am just having the marks here and the total array is not here <sil=0.348> ,COMMA but a separate array altogether <sil=0.922> .PERIOD So <sil=0.312> ,COMMA I have another array which is total <sil=0.998> .PERIOD So <sil=0.320> ,COMMA I can have the sum of each of them being passed to this <sil=0.958> .PERIOD So <sil=0.506> ,COMMA in that case when I am calling when I am calling when I am calling find total <sil=0.353> ,COMMA then I am passing on this array as well as the total array 2 arrays because I want to put the sum on the total array <sil=0.958> .PERIOD With that I can find the sum of this sum of this sum of this sum of this sum of this and then I can make another function where it finds the max or whatever I want to do <sil=0.903> .PERIOD So <sil=0.484> ,COMMA accordingly the point is that for each of the activities <sil=0.636> ,COMMA I can make small small functions <sil=0.932> .PERIOD One is for acquiring data <sil=0.407> ,COMMA one is for finding the total <sil=0.552> ,COMMA one is for finding the maximum number or maybe some other things also sorting and all those <sil=0.972> .PERIOD I can do I can find out the failure list another function <sil=0.996> .PERIOD So <sil=0.452> ,COMMA I can have a complete set of small small functions each independently done say <sil=0.530> ,COMMA did acquiring data <sil=0.627> ,COMMA finding total <sil=0.338> ,COMMA finding max all these and they are communicating through a main program and the main program my data is one array <sil=0.990> .PERIOD So <sil=0.612> ,COMMA let me let me draw the data using red <sil=0.992> .PERIOD So <sil=0.402> ,COMMA here I have got my array which was called my array <sil=0.493> ,COMMA array which had the size 5 <sil=0.517> ,COMMA 5 and 4 and I had another array total <sil=0.510> ,COMMA total which is a one dimensional array <sil=0.598> ,COMMA how many 5 students <sil=0.928> .PERIOD So <sil=0.311> ,COMMA these two <sil=0.943> .PERIOD So <sil=0.527> ,COMMA the main function is invoking from different points for different tasks these functions and this function is working on this array shared array <sil=0.920> .PERIOD This function is working on this array and generating the total <sil=0.638> ,COMMA maybe this function is doing something else <sil=0.952> .PERIOD So <sil=0.371> ,COMMA the these arrays are being shared by the main function and the small functions that is how using functions I can divide a task into smaller short tasks and can do it very nicely <sil=0.927> .PERIOD Now <sil=0.423> ,COMMA with this now let us move to another problem one a version of which we had encountered earlier that is searching an array <sil=0.974> .PERIOD When we have got an array for example <sil=0.353> ,COMMA here when we found say suppose I found the total here I found the total and from there I find out which one is the maximum or is it that if there is any student whose total is less than 100 I want to test that <sil=0.984> .PERIOD So <sil=0.392> ,COMMA I have to search this array similarly I can search if there is any student who has got in science more than 90 I can search that along this array <sil=0.995> .PERIOD I find if there is any 40 is the pass mark if there is any student who has not passed in maths I find here there is a failure case <sil=0.911> .PERIOD So <sil=0.310> ,COMMA for that I need to do a search so search is very fundamental search is absolutely fundamental to computation and so first we have already seen linear search but once again have a journey through that <sil=0.962> .PERIOD So <sil=0.578> ,COMMA we know that in a search we are given a key which we are searching for a particular key that we want to find out if the key is present in the array then we have to say that the key is present and also the position where the key is present <sil=0.989> .PERIOD Now <sil=0.584> ,COMMA we will consider two cases one is that the array is unsorted what do I mean by unsorted by unsorted I mean that the elements are not in any particular order for example <sil=0.535> ,COMMA think of this array where the elements are 5 <sil=0.606> ,COMMA 3 <sil=0.566> ,COMMA 2 <sil=0.630> ,COMMA 9 <sil=0.314> ,COMMA 8 <sil=0.441> ,COMMA 17 <sil=0.344> ,COMMA 6 <sil=0.367> .PERIOD Now <sil=0.609> ,COMMA this array is not in any increasing order not in some decreasing order it is decreasing here decreasing here again increased here decreased here again increased here decreased here on the other hand if the array was something like this say to 65 <sil=0.438> ,COMMA 5 65 <sil=0.616> ,COMMA 6 <sil=0.456> ,COMMA 8 <sil=0.369> ,COMMA 9 and 7 <sil=0.978> .PERIOD 17 <sil=0.978> .PERIOD Then this array is sorted in an increasing order that as I go from top to down it is in an increasing order it is sorted in increasing order <sil=0.908> .PERIOD It could be sorted in the decreasing order also <sil=0.945> .PERIOD Like say for example <sil=0.471> ,COMMA I start with 17 <sil=0.619> ,COMMA then 9 <sil=0.596> ,COMMA then 8 <sil=0.400> ,COMMA then 6 <sil=0.909> ,COMMA then 5 <sil=0.474> ,COMMA then 3 <sil=0.382> ,COMMA then 2 <sil=0.946> .PERIOD So <sil=0.377> ,COMMA this is as we go down the numbers are decreasing <sil=0.956> .PERIOD So <sil=0.639> ,COMMA these are ordered or sorted and this is unsorted <sil=0.985> .PERIOD This is also sorted <sil=0.306> ,COMMA but in a different order <sil=0.946> .PERIOD So <sil=0.619> ,COMMA I may have to search from an array that is either unsorted or sorted <sil=0.927> .PERIOD So <sil=0.303> ,COMMA first let us think of dealing with unsorted arrays <sil=0.942> .PERIOD And we will look into the linear search algorithm for doing that <sil=0.955> .PERIOD And if the elements are sorted we have got a more efficient search algorithm called the binary search <sil=0.915> .PERIOD So <sil=0.597> ,COMMA linear search we have already seen in an earlier lecture <sil=0.971> .PERIOD So <sil=0.475> ,COMMA the basic idea is we started the beginning of the array <sil=0.940> .PERIOD So <sil=0.510> ,COMMA if we come here we start say I want to search this <sil=0.973> .PERIOD I start at the beginning of the array <sil=0.975> .PERIOD I start here and I have got a key <sil=0.934> .PERIOD A key is there say key is 8 <sil=0.965> .PERIOD So <sil=0.425> ,COMMA I start from the top look for the availability of look for the element matching the key <sil=0.921> .PERIOD 5 is not matching 8 <sil=0.929> .PERIOD Then I go on increasing this index and go on comparing till I find either if 8 is not there I will come to the end of the array <sil=0.930> .PERIOD All the elements have been checked <sil=0.905> .PERIOD I have not found the match or when I get the match I will say that at this position I have got the key matching <sil=0.953> .PERIOD So <sil=0.415> ,COMMA we will start at the beginning of the array and inspect every element to see if it matches the key <sil=0.901> .PERIOD Now <sil=0.396> ,COMMA if I want to do it in this way we often talk about time complexity it is a measure I am not going into the formal way of the measure the measure of how long an algorithm takes to run <sil=0.910> .PERIOD So <sil=0.495> ,COMMA as you can understand if there are any elements in the array then the best case would be let us you will find out what it will be <sil=0.969> .PERIOD Say I start with this it may be suppose the key was 5 <sil=0.938> .PERIOD Suppose the key was 5 in that case that is the best case with one one comparison I find it how many comparisons how many inspections I needed only one <sil=0.977> .PERIOD So <sil=0.429> ,COMMA that is the best case the worst case could be if my key was 6 if my key was 6 then I would have to inspect every element and since there are 7 elements here I had to carry out 7 comparisons 7 inspections till I found the match <sil=0.940> .PERIOD So <sil=0.434> ,COMMA the best case would be first element 1 inspection 1 search operation and the worst case would be no match found either the last element or not at all found or even after that in that case I need n search operations <sil=0.937> .PERIOD So <sil=0.397> ,COMMA the best case is 1 the worst case is if the size of the array is n then n <sil=0.998> .PERIOD So <sil=0.541> ,COMMA the average would be n plus 1 by 2 search operations n plus 1 by 2 that is a cost how much time that gives a measure of the time the algorithm will take to run <sil=0.956> .PERIOD So <sil=0.442> ,COMMA now we are trying to write it we had explain this algorithm also earlier but now that we have done functions let us write a function for linear search why am I writing the function say again if I go to this case <sil=0.987> .PERIOD Now <sil=0.489> ,COMMA I may like to say my task is to find out whether I any student who has got more than 80 <sil=0.995> .PERIOD So <sil=0.643> ,COMMA I will need to write this case <sil=0.952> .PERIOD So <sil=0.310> ,COMMA I will write this case <sil=0.966> .PERIOD Now <sil=0.597> ,COMMA I may like to say my task is to find out whether I any student who has got more than 80 <sil=0.966> .PERIOD So <sil=0.401> ,COMMA I will need to write a function I have to search this in a linear way in a sequential way one of another and for that I have to write a function <sil=0.909> .PERIOD So <sil=0.463> ,COMMA how is that function how will that function look like let us see what are the things I need I have gotten at <sil=0.941> .PERIOD So <sil=0.625> ,COMMA I need to know which array I will be working with and that is this array a and what is the size of the array n whatever that is 7 may be in our case the example that I was showing was 7 <sil=0.902> .PERIOD So <sil=0.643> ,COMMA that is so after I compare 7 elements if I do not find the key then I am unsuccessful in finding the search is not yielding in result the other thing is key the element for example <sil=0.644> ,COMMA 8 which I am finding out in this which I am finding out in this array of numbers say something like this I am trying to find out 8 <sil=0.975> .PERIOD So <sil=0.389> ,COMMA now let us look at the algorithm int pause equal to 0 pause means position <sil=0.925> .PERIOD So <sil=0.505> ,COMMA initially I am in this position that is this array is a so a 0 <sil=0.947> .PERIOD So <sil=0.615> ,COMMA this is a 0 and while pause is less than size it is right now 0 it is less than size that means the pause is not has not exceeded the last element that means I have not yet checked the last element that is why this is said and the this pause the element a pause a pause pause the element a pause a pause pause is the index is 5 and suppose my key is 8 if a pause is not equal to key then I will increment pause I will check for the next element <sil=0.902> .PERIOD Now <sil=0.610> ,COMMA look at this this is an and here if either of these conditions fail that means if I have not found it fine <sil=0.375> ,COMMA but I have exceeded the key exceeded the array size I mean limit then I will stop or if I have found the key 8 here although I have not reached the end I will stop <sil=0.955> .PERIOD So <sil=0.405> ,COMMA that is the condition then I go on increasing pause if pause is not less than n that means when I come out of this while loop when any of these conditions are not satisfied <sil=0.982> .PERIOD So <sil=0.440> ,COMMA if pause is less than n that means actually it should have been pause is less than size if I have come if still pause is let it should be pause is less than size if pause is less than size that means I have not come to the end of the array then obviously <sil=0.504> ,COMMA why did I come out because this condition was false this condition was false means what I have already found the key right then I will return the position <sil=0.953> .PERIOD So <sil=0.349> ,COMMA pause increments from 0 to 1 to 2 to 3 then to 4 when I do that the same thing is size was 5 I have not exceeded 5 is still less than 5 and so pause could be but I have come out I have come out because I have found this so at pause position 4 I am getting the key so pause is returned otherwise if this is not true then I will return minus 1 I will return minus 1 minus 1 if it is returned that means that I have not found the key <sil=0.931> .PERIOD So <sil=0.456> ,COMMA this is the look of the linear search function very simple now I have found the function so the key appears in if the key appears within this limit then I will return the pointer P O S otherwise I will return the key <sil=0.994> .PERIOD So <sil=0.615> ,COMMA here is an example say this is the array x 12 minus 378 67 6 50 etcetera I want to trace the following calls I call so I will return the search so if you go up the linear search let me call this is linear search it should be written down as linear search I am calling with the array x the size of the array 8 and the key is 6 here what will happen size of the array is 8 <sil=0.974> .PERIOD So <sil=0.647> ,COMMA I will start with the start from here 12 no minus 3 no my key is 6 right I implement pause from here to here no it is not matching pause is not the key a pause is not the key here a pause is the key so I come out with 0 1 2 3 4 pause value is 4 here what will happen for this I the same array x size 8 but my key is 5 you can see that I will go up to this and after that I will implement pause plus plus so it will be more than 8 and so the size is 8 so I will not be able to I will say that I have not got the key all right <sil=0.975> .PERIOD So <sil=0.618> ,COMMA that is so this one will return 4 and this one will return minus 1 that is how the linear search algorithm works <sil=0.937> .PERIOD Now <sil=0.417> ,COMMA let us stop here for today next we will look at another more efficient search but it that demands something more from us that the array must be sorted in that case we can apply the binary search algorithm to make it more efficient <sil=0.984> .PERIOD So <sil=0.587> ,COMMA today what we saw is how we can write small small functions to solve a big problem after I break down that big problem into smaller parts and also we found how we can the concept of linear search which we learnt earlier how we can write a function for that <sil=0.900> .PERIOD In the earlier lecture <sil=0.565> ,COMMA we have seen how we can search in a list of items <sil=0.315> ,COMMA maybe list of integers <sil=0.547> ,COMMA or maybe list of names <sil=0.480> ,COMMA or list of real numbers in a linear way <sil=0.944> .PERIOD That means <sil=0.562> ,COMMA we start from one end of the list and we have got a key and we check for every element <sil=0.614> ,COMMA whether the element in the list matches the key or not <sil=0.927> .PERIOD In that way <sil=0.486> ,COMMA we go on from top to bottom and ultimately <sil=0.429> ,COMMA if we get the match of the key to an element of the list <sil=0.463> ,COMMA we declare it is found and we also say where it is found <sil=0.984> .PERIOD Otherwise <sil=0.315> ,COMMA if we exhaust the list and still do not find the element <sil=0.619> ,COMMA then we say that the list is not found <sil=0.945> .PERIOD And the way in which we are searching from the top to bottom <sil=0.565> ,COMMA that process is known as linear search <sil=0.925> .PERIOD We have also seen that the time that is required to search for an element <sil=0.593> ,COMMA in the best case <sil=0.514> ,COMMA it would be of order 1 <sil=0.327> ,COMMA that means <sil=0.348> ,COMMA at the very beginning <sil=0.391> ,COMMA we can find the element <sil=0.929> .PERIOD Otherwise <sil=0.487> ,COMMA we have to come in a comparison <sil=0.904> .PERIOD So <sil=0.603> ,COMMA we have to do the minimum is 1 <sil=0.377> ,COMMA if we get a match at the beginning of the top of the list <sil=0.936> .PERIOD Otherwise <sil=0.412> ,COMMA we may have to exhaust all the elements and whether it is found or not found <sil=0.321> ,COMMA we can say only after we have compared all the elements <sil=0.913> .PERIOD So <sil=0.358> ,COMMA if there is a list of n elements <sil=0.639> ,COMMA then the maximum number of comparisons that I may have to do will be n <sil=0.999> .PERIOD Therefore <sil=0.515> ,COMMA on an average <sil=0.488> ,COMMA it will be n plus 1 by 2 <sil=0.422> ,COMMA that we say in complexity of algorithms <sil=0.318> ,COMMA parlance in that parlance <sil=0.604> ,COMMA in that terminology <sil=0.481> ,COMMA we call it order of n <sil=0.905> .PERIOD That is not the main issue with us <sil=0.476> ,COMMA but we can say <sil=0.435> ,COMMA therefore <sil=0.614> ,COMMA that in a list of elements <sil=0.392> ,COMMA if I have got n elements and the list is not sorted <sil=0.921> .PERIOD So <sil=0.518> ,COMMA maybe 5 <sil=0.468> ,COMMA 2 <sil=0.551> ,COMMA 7 <sil=0.346> ,COMMA 9 <sil=0.611> ,COMMA 11 <sil=0.468> ,COMMA 1 <sil=0.426> ,COMMA say this is a list and I want to search for a key <sil=0.913> .PERIOD So <sil=0.533> ,COMMA this in this case <sil=0.620> ,COMMA it is 6 <sil=0.610> ,COMMA but in general <sil=0.623> ,COMMA I can say that there are n elements <sil=0.493> ,COMMA in general <sil=0.589> ,COMMA I can say <sil=0.605> ,COMMA number of elements is n <sil=0.980> .PERIOD So <sil=0.381> ,COMMA the best case <sil=0.320> ,COMMA I can get a match here <sil=0.397> ,COMMA the number of comparisons I require is 1 <sil=0.987> .PERIOD In the worst case <sil=0.460> ,COMMA I have to come up to this and compare all these n elements <sil=0.928> .PERIOD So <sil=0.413> ,COMMA the number of comparisons on an average <sil=0.625> ,COMMA will be n plus 1 by 2 <sil=0.506> ,COMMA that is the average number of comparisons that we denote in computer parlance as of the order of n <sil=0.913> .PERIOD This O has got a name called Bgo <sil=0.351> ,COMMA I am sorry <sil=0.541> ,COMMA let me write it in this way <sil=0.983> .PERIOD This is called Bgo notation <sil=0.576> ,COMMA Bgo notation <sil=0.995> .PERIOD So <sil=0.511> ,COMMA where it just denotes the how much time a computer can a program will take to run in terms of the input size <sil=0.991> .PERIOD What is this n <sil=0.861> ?QUESTIONMARK This is the size of the input data <sil=0.614> ,COMMA we call it input size <sil=0.986> .PERIOD So <sil=0.417> ,COMMA obviously <sil=0.446> ,COMMA you can see that as this list increases <sil=0.611> ,COMMA if it becomes 100 <sil=0.620> ,COMMA then the average time that will be taken <sil=0.500> ,COMMA average <sil=0.423> ,COMMA this is the average <sil=0.947> .PERIOD Complexity will be more than this <sil=0.560> ,COMMA if it will be 1000 <sil=0.509> ,COMMA it will be even more and as increases <sil=0.438> ,COMMA the time will increase in a linear fashion <sil=0.509> ,COMMA as n increases <sil=0.304> ,COMMA the time will increase in a linear fashion <sil=0.432> .PERIOD However <sil=0.320> ,COMMA the way we are searching is known as linear search <sil=0.958> .PERIOD One thing to note is that in this case <sil=0.343> ,COMMA we are not making any assumption <sil=0.483> ,COMMA this is time <sil=0.996> .PERIOD We are not making any assumption about the way in which the data items are organized <sil=0.966> .PERIOD Now <sil=0.422> ,COMMA in an endeavor to see <sil=0.579> ,COMMA if we can make it better <sil=0.377> ,COMMA we today discuss another very important type of search algorithm <sil=0.531> ,COMMA which is known as binary search <sil=0.978> .PERIOD Why the name binary is coming <sil=0.550> ,COMMA you will be very clear in a moment <sil=0.925> .PERIOD But the important thing to note is that in this case <sil=0.454> ,COMMA the list or the array must be sorted <sil=0.972> .PERIOD That means <sil=0.320> ,COMMA it is organized in some particular way either in an ascending order or in the descending order <sil=0.936> .PERIOD Why is it called binary <sil=0.970> ?QUESTIONMARK Let me just try to explain it with an example <sil=0.917> .PERIOD Say <sil=0.467> ,COMMA I have got the array <sil=0.537> ,COMMA but in a sorted way <sil=0.950> .PERIOD So <sil=0.578> ,COMMA I have got one <sil=0.371> ,COMMA two <sil=0.364> ,COMMA the elements were there in the earlier case <sil=0.612> ,COMMA one <sil=0.936> ,COMMA two <sil=0.333> ,COMMA five <sil=0.468> ,COMMA seven <sil=0.552> ,COMMA nine <sil=0.303> ,COMMA 11 <sil=0.597> ,COMMA one <sil=0.939> ,COMMA two <sil=0.559> ,COMMA five <sil=0.398> ,COMMA seven <sil=0.535> ,COMMA nine <sil=0.334> ,COMMA 11 <sil=0.538> .PERIOD So <sil=0.504> ,COMMA one <sil=0.974> ,COMMA two <sil=0.571> ,COMMA five <sil=0.634> ,COMMA seven <sil=0.627> ,COMMA nine <sil=0.320> ,COMMA 11 <sil=0.481> .PERIOD Now <sil=0.437> ,COMMA suppose my key is <sil=0.370> ,COMMA well <sil=0.344> ,COMMA let the key be two <sil=0.970> .PERIOD Now <sil=0.520> ,COMMA we will start at the middle of this array <sil=0.953> .PERIOD First <sil=0.335> ,COMMA we look at the middle <sil=0.911> .PERIOD Now <sil=0.643> ,COMMA since this is an even number <sil=0.447> ,COMMA even sized array <sil=0.600> ,COMMA six elements <sil=0.612> ,COMMA the middle can be somewhere here <sil=0.987> .PERIOD So <sil=0.412> ,COMMA let me take this <sil=0.913> .PERIOD This is the midpoint <sil=0.934> .PERIOD Now <sil=0.440> ,COMMA I compare the key with the middle element <sil=0.449> ,COMMA two and seven are being compared <sil=0.957> .PERIOD Two things can happen either to the key <sil=0.918> .PERIOD I will rather say either the key is less than the mid element or the key is equal to the mid element or the key is greater than the mid element <sil=0.906> .PERIOD Three things can happen <sil=0.920> .PERIOD Now <sil=0.444> ,COMMA if the key is equal to the middle element <sil=0.358> ,COMMA then my search immediately stops <sil=0.955> .PERIOD Yes <sil=0.313> ,COMMA I have found it <sil=0.986> .PERIOD And where did I find it <sil=0.993> ?QUESTIONMARK The index is mid <sil=0.938> .PERIOD If the key is less than the mid element as is the case here <sil=0.471> ,COMMA then what can I say <sil=0.915> ?QUESTIONMARK I can immediately say that the I still do not know whether the key is there in this area or not <sil=0.589> ,COMMA whether the key is here or not <sil=0.364> ,COMMA I do not know as here <sil=0.961> .PERIOD But the thing that I can say is that the key <sil=0.377> ,COMMA since it is less than the mid <sil=0.585> ,COMMA it cannot be on this side <sil=0.929> .PERIOD It cannot be on this side <sil=0.924> .PERIOD Not possible <sil=0.911> .PERIOD It must be if at all on this side <sil=0.553> ,COMMA because the key is less than the mid <sil=0.973> .PERIOD Therefore <sil=0.586> ,COMMA I can restrict my search within this period <sil=0.314> ,COMMA suppose within this zone <sil=0.971> .PERIOD Now <sil=0.371> ,COMMA what I will do <sil=0.866> ?QUESTIONMARK I will again take the middle point of this area <sil=0.994> .PERIOD So <sil=0.469> ,COMMA here it is becoming very simple <sil=0.925> .PERIOD So <sil=0.347> ,COMMA the middle point of this part is suppose 5 <sil=0.998> .PERIOD I could have had it from 1 to 5 <sil=0.420> ,COMMA but I am just taking from 1 to 7 <sil=0.941> .PERIOD I come at this point and again now I compare this element with the key <sil=0.954> .PERIOD And still it is less <sil=0.939> .PERIOD Therefore <sil=0.307> ,COMMA I am sure that it is not in this area <sil=0.452> ,COMMA it must be in this zone <sil=0.949> .PERIOD Now <sil=0.327> ,COMMA I again only for this part <sil=0.412> ,COMMA I apply again <sil=0.469> ,COMMA I find the mid element and this is here <sil=0.968> .PERIOD And I find that the key and the element are matching <sil=0.991> .PERIOD So <sil=0.498> ,COMMA it is found <sil=0.946> .PERIOD So <sil=0.630> ,COMMA how many comparisons I needed here <sil=0.867> ?QUESTIONMARK In this case <sil=0.623> ,COMMA I needed 1 to 3 comparisons <sil=0.974> .PERIOD In the case of linear search <sil=0.471> ,COMMA of course <sil=0.462> ,COMMA you could have got it luckily here in 2 comparisons <sil=0.957> .PERIOD But what would have happened if my key was 9 <sil=0.969> ?QUESTIONMARK In the case of linear search <sil=0.494> ,COMMA suppose the key was 9 <sil=0.986> .PERIOD In that case <sil=0.368> ,COMMA in the case of linear search <sil=0.591> ,COMMA what would have happened <sil=0.870> ?QUESTIONMARK I would have started from here <sil=0.629> ,COMMA 1 comparison <sil=0.408> ,COMMA 2 comparison <sil=0.353> ,COMMA 3 comparison <sil=0.467> ,COMMA 4 comparison and the 5th comparison <sil=0.401> ,COMMA I would have got it <sil=0.985> .PERIOD On the 5th comparison <sil=0.509> ,COMMA I would have got it <sil=0.971> .PERIOD But let us see what would have happened in the case of the new search technique that we are looking at <sil=0.344> ,COMMA 1 <sil=0.462> ,COMMA 2 <sil=0.338> ,COMMA 1 <sil=0.409> .PERIOD So <sil=0.610> ,COMMA again I have 1 <sil=0.567> ,COMMA 2 <sil=0.637> ,COMMA 5 <sil=0.612> ,COMMA 7 <sil=0.641> ,COMMA 9 <sil=0.386> ,COMMA 11 and my key is 9 <sil=0.977> .PERIOD I know that in case of linear search <sil=0.628> ,COMMA I needed 5 comparisons <sil=0.984> .PERIOD What will happen here <sil=0.613> ?QUESTIONMARK I will come to the middle point here <sil=0.977> .PERIOD I find that the key is greater than mid <sil=0.928> .PERIOD This is mid <sil=0.971> .PERIOD The key is greater than mid <sil=0.982> .PERIOD Therefore <sil=0.528> ,COMMA I know that the key <sil=0.362> ,COMMA if at all <sil=0.519> ,COMMA cannot remain in this zone <sil=0.991> .PERIOD This part is ruled out <sil=0.993> .PERIOD This part is ruled out <sil=0.930> .PERIOD It must be in this zone <sil=0.967> .PERIOD So <sil=0.599> ,COMMA again within this <sil=0.317> ,COMMA I find the new mid <sil=0.957> .PERIOD So <sil=0.492> ,COMMA the new mid comes here and I find this new mid <sil=0.649> ,COMMA new <sil=0.944> .PERIOD I check this <sil=0.950> .PERIOD Now <sil=0.640> ,COMMA I find that the key is equal to mid <sil=0.924> .PERIOD Therefore <sil=0.302> ,COMMA I find my search completes here with this index as the output <sil=0.953> .PERIOD Now <sil=0.445> ,COMMA how many comparisons I needed here <sil=0.939> ?QUESTIONMARK 1 <sil=0.911> ,COMMA 2 <sil=0.495> .PERIOD Only 2 comparisons <sil=0.953> .PERIOD So <sil=0.640> ,COMMA 2 comparisons versus 1 <sil=0.514> ,COMMA 2 <sil=0.336> ,COMMA 3 <sil=0.603> ,COMMA 4 <sil=0.352> ,COMMA 5 comparisons in the case of linear search <sil=0.961> .PERIOD Now <sil=0.518> ,COMMA why was it reduced <sil=0.854> ?QUESTIONMARK The same thing would have happened with if my key was 11 <sil=0.999> .PERIOD Let us have a look <sil=0.942> .PERIOD If the key was 11 <sil=0.580> ,COMMA in that case <sil=0.620> ,COMMA suppose the key was 11 <sil=0.991> .PERIOD In the case of linear search <sil=0.547> ,COMMA I would have required 6 comparisons here to reach at 11 <sil=0.991> .PERIOD However <sil=0.314> ,COMMA in this case <sil=0.461> ,COMMA I would be sure if key is greater than this <sil=0.505> ,COMMA then my next iteration will be between these two and would have found the mid <sil=0.382> ,COMMA new mid and I would have got it within 3 comparisons <sil=0.906> .PERIOD Now <sil=0.332> ,COMMA why is it becoming so <sil=0.851> ?QUESTIONMARK Why is the number of comparisons being reduced <sil=0.912> ?QUESTIONMARK The reason is we have got this array and at every stage <sil=0.621> ,COMMA what I am doing is <sil=0.485> ,COMMA I am looking at the key and depending on whether the key is greater than the mid <sil=0.583> ,COMMA I am concentrating on only one half of the array either this array or this array <sil=0.989> .PERIOD Then <sil=0.469> ,COMMA depending on the key value <sil=0.611> ,COMMA I take <sil=0.477> ,COMMA suppose it is greater than I will concentrate on this zone <sil=0.934> .PERIOD If it is less <sil=0.349> ,COMMA I will concentrate on this zone and iteratively <sil=0.325> ,COMMA I will be reducing my search to a smaller array <sil=0.948> .PERIOD Let us have another example <sil=0.929> .PERIOD Let us have another example <sil=0.903> .PERIOD Let us have it a little bigger <sil=0.907> .PERIOD Let us have 17 <sil=0.528> ,COMMA 19 <sil=0.307> ,COMMA 20 <sil=0.485> ,COMMA 21 <sil=0.472> ,COMMA 25 <sil=0.418> ,COMMA 32 <sil=0.629> ,COMMA 38 <sil=0.333> ,COMMA 40 <sil=0.996> .PERIOD Now <sil=0.637> ,COMMA I have got <sil=0.635> ,COMMA again <sil=0.633> ,COMMA even number <sil=0.640> ,COMMA let me have 42 <sil=0.993> .PERIOD Say odd number <sil=0.569> ,COMMA that is <sil=0.605> ,COMMA 1 <sil=0.411> ,COMMA 2 <sil=0.305> ,COMMA 3 <sil=0.420> ,COMMA 4 <sil=0.475> .PERIOD Now <sil=0.363> ,COMMA I have got 9 elements <sil=0.923> .PERIOD Now <sil=0.348> ,COMMA I will start with the mid element <sil=0.960> .PERIOD What is the mid element <sil=0.898> ?QUESTIONMARK Here <sil=0.416> ,COMMA between this <sil=0.571> ,COMMA the mid element is this <sil=0.902> .PERIOD And suppose my key is 19 <sil=0.955> .PERIOD Then <sil=0.370> ,COMMA I know that my key cannot lie <sil=0.522> ,COMMA since it is less than 19 <sil=0.487> ,COMMA it cannot lie in this part of the array <sil=0.952> .PERIOD If at all <sil=0.481> ,COMMA it will lie on this part of the why <sil=0.469> ,COMMA why do I say that <sil=0.986> ?QUESTIONMARK I can say that because this array is sorted <sil=0.961> .PERIOD Otherwise <sil=0.397> ,COMMA I could not have said <sil=0.421> ,COMMA since it is in an increasing order <sil=0.470> ,COMMA I can say that since the key is less than the mid element <sil=0.442> ,COMMA therefore <sil=0.515> ,COMMA it must be in this zone <sil=0.964> .PERIOD And so <sil=0.410> ,COMMA I come to this zone and find out the mid element again <sil=0.409> ,COMMA maybe in this zone or up to this <sil=0.952> .PERIOD Say <sil=0.635> ,COMMA I come here and find out the mid element to this <sil=0.981> .PERIOD Again <sil=0.303> ,COMMA so <sil=0.633> ,COMMA I am looking <sil=0.398> ,COMMA I am immediately reduced my list to half <sil=0.949> .PERIOD This half <sil=0.487> ,COMMA it could have been if my key was say <sil=0.407> ,COMMA 38 <sil=0.341> ,COMMA then I would have restricted to this half <sil=0.539> ,COMMA not this half <sil=0.929> .PERIOD But for 19 <sil=0.540> ,COMMA I am restricted to this half <sil=0.984> .PERIOD Now <sil=0.592> ,COMMA again <sil=0.554> ,COMMA 19 is less than 20 <sil=0.906> .PERIOD So <sil=0.608> ,COMMA immediately <sil=0.597> ,COMMA I will restrict myself to this half <sil=0.914> .PERIOD And I will not consider this part <sil=0.913> .PERIOD So <sil=0.399> ,COMMA gradually <sil=0.643> ,COMMA I am going to the lower half or the higher half at every stage <sil=0.949> .PERIOD So <sil=0.472> ,COMMA what is happening is something like this <sil=0.987> .PERIOD I am starting with the whole array <sil=1.000> .PERIOD Then <sil=0.507> ,COMMA I am concentrating either on the left half or on the right half <sil=0.939> .PERIOD Then <sil=0.461> ,COMMA again <sil=0.620> ,COMMA depending on that either on the left half or on the right half <sil=0.946> .PERIOD If it is in the right half <sil=0.370> ,COMMA then among this <sil=0.623> ,COMMA I am coming to left half and right half <sil=0.999> .PERIOD So <sil=0.562> ,COMMA at every stage <sil=0.531> ,COMMA I am dividing the array to half <sil=1.000> .PERIOD That is why this is called binary search <sil=0.982> .PERIOD Either it is here or it is not here <sil=0.511> ,COMMA not in this zone <sil=0.915> .PERIOD So <sil=0.317> ,COMMA in that way <sil=0.472> ,COMMA I carry on <sil=0.959> .PERIOD So <sil=0.489> ,COMMA consequently <sil=0.363> ,COMMA the number of elements that I restrict my search to gets reduced at every iteration <sil=0.966> .PERIOD Let us look at this in a little more detail <sil=0.929> .PERIOD So <sil=0.438> ,COMMA in every stage <sil=0.471> ,COMMA we reduce the number of elements by half <sil=0.933> .PERIOD I think this is clear now that this statement <sil=0.997> .PERIOD Now <sil=0.455> ,COMMA if you do not find it <sil=0.382> ,COMMA you can ignore the half of the array and repeat the process <sil=0.961> .PERIOD So <sil=0.578> ,COMMA now <sil=0.431> ,COMMA let us look at this <sil=0.986> .PERIOD Basic strategy <sil=0.482> ,COMMA what do you want <sil=0.871> ?QUESTIONMARK The array is from 0 to n minus 1 <sil=0.628> ,COMMA n elements <sil=0.980> .PERIOD Here <sil=0.429> ,COMMA I was showing me only <sil=0.907> .PERIOD So <sil=0.576> ,COMMA this is the mid M and this is the left end <sil=0.498> ,COMMA this is the right end <sil=0.923> .PERIOD So <sil=0.544> ,COMMA there are two index indices <sil=0.958> .PERIOD Now <sil=0.586> ,COMMA I am taking the key and I am checking this part <sil=0.581> ,COMMA M <sil=0.580> ,COMMA the element M <sil=0.546> ,COMMA this element <sil=0.955> .PERIOD That is xm and depending on whether <sil=0.404> ,COMMA if it is greater than the key <sil=0.580> ,COMMA if xm <sil=0.470> ,COMMA if the key is greater than xm <sil=0.386> ,COMMA key is greater than xm is less <sil=0.991> .PERIOD Then <sil=0.576> ,COMMA I would be concentrating here <sil=0.949> .PERIOD If xm is greater than the key <sil=0.565> ,COMMA then I will be concentrating on this half <sil=0.319> ,COMMA on this half or on this half <sil=0.922> .PERIOD That is what I was explaining till now <sil=0.907> .PERIOD So <sil=0.401> ,COMMA here <sil=0.537> ,COMMA if it is no <sil=0.376> ,COMMA then I will <sil=0.546> ,COMMA if it is xm is less than the key <sil=0.486> ,COMMA then I will come to this half <sil=0.977> .PERIOD Otherwise <sil=0.374> ,COMMA if it is yes <sil=0.473> ,COMMA I will come to this half greater than the key <sil=0.977> .PERIOD So <sil=0.372> ,COMMA we will first <sil=0.553> ,COMMA given this a and r <sil=0.565> ,COMMA what is my mid element <sil=0.929> ?QUESTIONMARK How will I compute my mid element or M <sil=0.876> ?QUESTIONMARK That is L plus r divided by 2 <sil=0.964> .PERIOD And then <sil=0.508> ,COMMA depending on whether it is less or greater <sil=0.582> ,COMMA we will move the left or L or r to the middle <sil=0.382> ,COMMA depending on the test <sil=0.937> .PERIOD So <sil=0.492> ,COMMA again <sil=0.478> ,COMMA let me show it with that example that we are showing <sil=0.950> .PERIOD So <sil=0.484> ,COMMA something like this <sil=0.541> ,COMMA 1 <sil=0.381> ,COMMA 2 <sil=0.436> ,COMMA 5 <sil=0.607> ,COMMA 7 <sil=0.547> ,COMMA 9 <sil=0.481> ,COMMA 11 <sil=0.558> ,COMMA what is being said is 9 <sil=0.515> ,COMMA 11 <sil=0.541> .PERIOD So <sil=0.378> ,COMMA L is L equals 0 and r is equal to 1 <sil=0.383> ,COMMA 2 <sil=0.549> ,COMMA 3 <sil=0.315> ,COMMA 4 <sil=0.485> ,COMMA 5 <sil=0.637> ,COMMA 6 <sil=0.583> ,COMMA 0 <sil=0.540> ,COMMA 1 <sil=0.626> ,COMMA 2 <sil=0.472> ,COMMA 3 <sil=0.396> ,COMMA 4 <sil=0.627> ,COMMA 5 <sil=0.597> .PERIOD So <sil=0.613> ,COMMA R is equal to 5 <sil=0.942> .PERIOD So <sil=0.434> ,COMMA mid is L plus r divided by 2 <sil=0.951> .PERIOD So <sil=0.449> ,COMMA that is 5 divided by 2 <sil=0.995> .PERIOD So <sil=0.339> ,COMMA we can take 2 or or we can take 3 <sil=0.503> ,COMMA depending on <sil=0.931> .PERIOD So <sil=0.519> ,COMMA I come to <sil=0.504> ,COMMA if I take 2 <sil=0.433> ,COMMA if I take 3 <sil=0.504> ,COMMA then I am coming to mid <sil=0.960> .PERIOD So <sil=0.402> ,COMMA what I will do is <sil=0.646> ,COMMA if 3 is my mid point <sil=0.470> ,COMMA if I take 5 by 2 is 3 <sil=0.526> ,COMMA then that means <sil=0.321> ,COMMA it will be in case of odd <sil=0.326> ,COMMA I will add 1 to that <sil=0.956> .PERIOD So <sil=0.337> ,COMMA I can move <sil=0.974> .PERIOD Now <sil=0.334> ,COMMA if the key is suppose key is 9 <sil=0.987> .PERIOD Suppose the key is 9 <sil=0.956> .PERIOD So <sil=0.470> ,COMMA my mid was the third is 0 <sil=0.649> ,COMMA 1 <sil=0.449> ,COMMA 2 <sil=0.575> ,COMMA 3 <sil=0.597> .PERIOD Let me <sil=0.446> ,COMMA 0 <sil=0.605> ,COMMA 1 <sil=0.633> ,COMMA 2 <sil=0.557> ,COMMA 3 <sil=0.541> ,COMMA this is my mid <sil=0.923> .PERIOD Now <sil=0.510> ,COMMA since the key is greater than the element x <sil=0.515> ,COMMA m <sil=0.552> ,COMMA x mid <sil=0.327> ,COMMA since it is <sil=0.431> ,COMMA x mid is less <sil=0.613> ,COMMA I will be restricting my search in this area <sil=0.921> .PERIOD Therefore <sil=0.451> ,COMMA what I will do <sil=0.900> ,COMMA I will move this L to mid <sil=0.983> .PERIOD So <sil=0.553> ,COMMA this will be my new L and I will find the mid with <sil=0.487> ,COMMA now next mid will be this new L plus r by 2 <sil=0.977> .PERIOD So <sil=0.517> ,COMMA that will be this element <sil=0.924> .PERIOD If my search was on the other side <sil=0.308> ,COMMA that means <sil=0.522> ,COMMA if the key was not 9 <sil=0.385> ,COMMA but the key was 2 or 1 <sil=0.380> ,COMMA let us make it 1 <sil=0.370> ,COMMA then at this point <sil=0.365> ,COMMA I find that the key is less than x <sil=0.636> ,COMMA then I will be restricting my search in this area <sil=0.946> .PERIOD Then <sil=0.341> ,COMMA that case <sil=0.647> ,COMMA I will move this r <sil=0.421> ,COMMA I will shift this r over here and this the mid will be r will be the mid <sil=0.960> .PERIOD So <sil=0.327> ,COMMA next I will be restricting my search in this half and forget about this half <sil=0.923> .PERIOD So <sil=0.419> ,COMMA that is how we at every iteration <sil=0.510> ,COMMA we break down the entire array into halves <sil=0.984> .PERIOD So <sil=0.304> ,COMMA if you have understood this <sil=0.611> ,COMMA let us proceed <sil=0.907> ,COMMA repeat the search operation in the reduced interval <sil=0.965> .PERIOD So <sil=0.611> ,COMMA what we are doing is <sil=0.592> ,COMMA we are looking at this binary search algorithm and we are trying to design a function and binary search is a function whose name I am just keeping as bin search <sil=0.986> .PERIOD This is the name of the algorithm and what are the parameters <sil=0.921> ?QUESTIONMARK Let us see <sil=0.369> ,COMMA the parameters are one is the array that is being passed <sil=0.398> ,COMMA the list that I have to search <sil=0.581> ,COMMA I also need the size of the array and I need the key <sil=0.903> .PERIOD So <sil=0.375> ,COMMA these are the three things <sil=0.988> .PERIOD So <sil=0.350> ,COMMA bin research is a function <sil=0.579> ,COMMA what are its inputs <sil=0.601> ,COMMA the list or the array which is x <sil=0.563> ,COMMA the size or what we are calling about right now n and the key <sil=0.939> .PERIOD And what will the output be <sil=0.935> ?QUESTIONMARK Bin search will tell us whether it has been found or not <sil=0.525> ,COMMA but so it will be a 0 or 1 found or not <sil=0.562> ,COMMA 0 or 1 or it can return us an index also <sil=0.991> .PERIOD So <sil=0.578> ,COMMA now if we proceed with this idea <sil=0.500> ,COMMA then let us develop the algorithm step by step <sil=0.970> .PERIOD Inside this function <sil=0.539> ,COMMA I have got the search <sil=0.506> ,COMMA I have got the list <sil=0.446> ,COMMA the list is given to me <sil=0.434> ,COMMA this array is known to me <sil=0.408> ,COMMA I declare internally LR and I have to use another index called MEDE <sil=0.969> .PERIOD Now <sil=0.356> ,COMMA this has got no meaning outside this function <sil=0.988> .PERIOD Next step <sil=0.446> ,COMMA what should I do <sil=0.909> ?QUESTIONMARK Next step would be while some condition <sil=0.553> ,COMMA MEDE I have to find out L plus R by 2 <sil=0.919> .PERIOD As you know <sil=0.435> ,COMMA if this is the array x <sil=0.386> ,COMMA if the MEDE element is greater than the key <sil=0.962> .PERIOD So <sil=0.599> ,COMMA the key say this MEDE is 7 and my key is 9 <sil=0.910> .PERIOD So <sil=0.428> ,COMMA this element is greater <sil=0.587> ,COMMA then I know that this element is greater <sil=0.915> .PERIOD So <sil=0.382> ,COMMA this is 17 <sil=0.389> ,COMMA this is greater than the key <sil=0.301> ,COMMA then I will have to keep my search within this zone <sil=0.972> .PERIOD So <sil=0.416> ,COMMA this R will be updated and the R will come here <sil=0.925> .PERIOD Otherwise <sil=0.603> ,COMMA L will be moved here <sil=0.985> .PERIOD This much is clear <sil=0.921> .PERIOD You think over this and build upon this algorithm <sil=0.646> ,COMMA we will take it up in next step again <sil=0.966> .PERIOD You have to decide on how to build these things up <sil=0.960> .PERIOD In the last lecture <sil=0.364> ,COMMA we had talked about two different types of operators <sil=0.622> ,COMMA relational operator and arithmetic operators <sil=0.921> .PERIOD Today <sil=0.546> ,COMMA we will be discussing about the third type of operator <sil=0.416> ,COMMA which is known as a logical operator <sil=0.931> .PERIOD Logical operators are also known as logical connectives <sil=0.904> .PERIOD So <sil=0.367> ,COMMA there are two essentially there are two logical operators in C <sil=0.997> .PERIOD One is logical and and the other one is a logical or <sil=0.977> .PERIOD Now <sil=0.369> ,COMMA what do they do <sil=0.926> ?QUESTIONMARK They act upon the operands themselves <sil=0.444> ,COMMA which are logical expressions <sil=0.937> .PERIOD For example <sil=0.363> ,COMMA let us say I am writing a logical expression temperature is greater than 50 <sil=0.961> .PERIOD Now <sil=0.488> ,COMMA this will this statement suppose the temperature now is 40 degrees centigrade <sil=0.930> .PERIOD Then temperature greater than 40 <sil=0.332> ,COMMA greater than 50 will result in false value <sil=0.986> .PERIOD So <sil=0.300> ,COMMA because a relational operator will always generate either true or false <sil=0.914> .PERIOD And suppose there is another logical expression A times B plus C is greater than equal to 25 <sil=0.922> .PERIOD Now <sil=0.523> ,COMMA this is another logical expression sorry this is another relational expression on the left hand side of this expression <sil=0.957> .PERIOD I have got an arithmetic expression and on the right hand side I have got a constant and I am connecting them with a logical relational operator greater than equal to <sil=0.998> .PERIOD Now <sil=0.630> ,COMMA if A times B plus C is greater than 25 or equal to 25 then this will result in true <sil=0.937> .PERIOD Now <sil=0.326> ,COMMA I can connect these two <sil=0.501> ,COMMA this one and this two together and write another expression like temperature greater than 50 and A times B plus C is greater than equal to 25 <sil=0.938> .PERIOD Now <sil=0.624> ,COMMA this expression is a combination of two relational expressions and a logical operator or logical connective <sil=0.975> .PERIOD This logical and means that this entire thing expression will be true or will result in a one if both of them are true <sil=0.958> .PERIOD So <sil=0.570> ,COMMA if the temperature is 40 then this will become false or 0 and if this is 25 then this is true but 0 and 1 both are not true therefore <sil=0.358> ,COMMA this 0 and 1 will result in 0 <sil=0.916> .PERIOD But <sil=0.520> ,COMMA suppose if the temperature was 50 and A times B plus C is equal to 25 or greater than 25 then this is true and also this is true in that case these two together and because they are ended then this will be true <sil=0.946> .PERIOD So <sil=0.614> ,COMMA the logical and operator what it does is returns a true value or one if all the components of the expression logical expression connected by the and operator logical and operator is true <sil=0.909> .PERIOD Now <sil=0.393> ,COMMA one thing you can note here that since this ampere sand is a character and we have already used this ampere sand in expressions like and scan F and we have discussed that this and actually means we are trying to get the address of a particular I am sorry I am sorry absolutely sorry I actually what I write is scan F etcetera percentage D and velocity say where velocity is a variable right <sil=0.971> .PERIOD So <sil=0.587> ,COMMA this and in that case use is used to mean the address of this variable velocity ok <sil=0.928> .PERIOD So <sil=0.476> ,COMMA in order to differentiate between this usage of and and the logical operator logical and is denoted as two ampere sands two ants <sil=0.973> .PERIOD Similarly <sil=0.302> ,COMMA logical or means that some expression say I have I write it in an abstract we say x expression 1 or expression 2 or expression 3 <sil=0.976> .PERIOD Now <sil=0.578> ,COMMA this composite expression will be true if any one of them either expression 1 or expression 2 or expression 3 is true <sil=0.904> .PERIOD If any one of them is true then this entire thing will be true <sil=0.982> .PERIOD If two of them are true then also it will return true if all the three are true then also it will be true <sil=0.925> .PERIOD But if none of them are true if none of them are true then it will not be true ok then none of them will be true <sil=0.982> .PERIOD So <sil=0.390> ,COMMA what is the difference between this logical or and logical and therefore <sil=0.381> ,COMMA in logical and if instead of this it was written like if instead of this it was written like expression 1 and expression 2 and expression 3 this composite and expression would be true only if all these three expressions are true <sil=0.967> .PERIOD So <sil=0.361> ,COMMA that is logical or now what do they do they act upon the operands that are themselves logical expressions why logical expressions where from did I get logical expressions I got the logical expressions from relational operators for example <sil=0.323> ,COMMA now I am writing some time is greater than 20 is a logical expression what is this this is a relational operator <sil=0.922> .PERIOD But this expression is a logical expression why it is a logical expression because this will return only true or false nothing in between <sil=0.995> .PERIOD So <sil=0.637> ,COMMA t greater than 20 if t is time or whatever value t might be if that is greater than 20 then it will return 1 or it will return 0 ok <sil=0.972> .PERIOD So <sil=0.390> ,COMMA the logical connectives or the logical operators they are acting upon the operands themselves and the connecting them <sil=0.938> .PERIOD The individual logical expressions get combined into a more complex condition that are either true or false ok we will see some examples <sil=0.985> .PERIOD So <sil=0.311> ,COMMA logical and the result is true if both the operands are true or for two for two operands if for three operands if all the operands are true it should be corrected as if all operands are true and logical or the result is true if at least one of the operands are true if at least one this is most important <sil=0.968> .PERIOD So <sil=0.583> ,COMMA let us look at the truth table here x and y any of them can have the value false or true accordingly we can have four combinations x false y false x false y true x true y false and both x and y are true <sil=0.945> .PERIOD Now <sil=0.502> ,COMMA if I carry out the logical and then for all these cases say false false the result will be false or 0 false and one true still it will be false because here I want all operands should be true <sil=0.945> .PERIOD So <sil=0.402> ,COMMA one is x is true y is false the result will be false if both of them are true the result will be true while in the case of or x or y will result in false if x is false and y is false <sil=0.945> .PERIOD But if x is false and y is true will get a true because I am interested in getting at least one to be true if this is true and this is false and also true if both of them are true then also it is true <sil=0.992> .PERIOD So <sil=0.550> ,COMMA I think it is clear to you what is made by the logical operators and how we can combine logical expressions based on that <sil=0.968> .PERIOD Now <sil=0.317> ,COMMA we have so we have seen three types of operations one is actually operators one is the arithmetic operators <sil=0.924> .PERIOD The next is relational operators and the third one is logical operators <sil=0.983> .PERIOD Now <sil=0.394> ,COMMA arithmetic operations use of arithmetic operations lead to arithmetic expressions <sil=0.986> .PERIOD The use of relational operators lead to logical expressions why logical expressions they lead to true or false value right logical expressions and use of logical operators will combine and get more complex logical expressions complex or let me let me not write complex let me write composite that communicates the meaning better composite logical expressions composite logical expressions composite logical expressions <sil=0.941> .PERIOD So <sil=0.586> ,COMMA we will see the use of this pretty soon when we will be looking at the control operators right <sil=0.973> .PERIOD Next just to wrap up the things let us come to the input output statements by the way besides this besides the arithmetic expressions logical expressions we had seen another type of expression those are assignment expressions or assignment operators <sil=0.998> .PERIOD But that means the left hand side is an expression and right hand side is a variable we assign the result of the computation of the right hand sorry I just said the opposite the right hand side is an expression on this side is an expression and here on that right on the left side is a variable and we compute the expression and assign the value of that computation to this variable and this is the assignment operator ok <sil=0.957> .PERIOD Now <sil=0.555> ,COMMA besides that we had seen two other statements one is the printf statement we have seen that performs the output to the standard output device typically when we declare a steady i o dot h then by default it is taken as the screen and the other one and it requires a format string in which we can specify the text to be printed out and the specifications on how to print the values like printf number is dash and that dash can be filled up by percentage d for that means the specification is that an integer can come here and then you remember what this means this means I am going to the new line all right and then followed by the number the format specification causes the value listed to be embedded here I have discussed that that you can consider this format to be a placeholder all right the number is dash and how can this dash be filled out the dash since its percentage d some integer value can come and fill it up right we have seen that <sil=0.946> .PERIOD The other statement that we saw is scanf that is for reading the values <sil=0.901> .PERIOD So <sil=0.348> ,COMMA it performs input from standard input device normally by default it is a keyboard and then it also requires a format string and a list of variables like it is required to put an ampere sand before the names of the variables we have also explained why that is so the reason is that this ampere sand essentially means the address of that variable where the value that is being read will be put ok <sil=0.973> .PERIOD So <sil=0.368> ,COMMA here are some examples scanf percentage d and size that means what that I am reading in a variable size size is the name of a variable and in which I am putting in some integer value all right <sil=0.962> .PERIOD Similarly next care say is a say this one is a character variable <sil=0.908> .PERIOD So <sil=0.422> ,COMMA I am specifying that only a character can come in here and that is why I have put in the specification percentage c percentage f means some floating point number will come here <sil=0.644> ,COMMA but in all these cases this ampere sand means the address of the corresponding variables all right <sil=0.960> .PERIOD Here percentage d percentage d means sequentially I am going to read two integer variables a and b <sil=0.924> .PERIOD So <sil=0.598> ,COMMA all these we have seen and you will be best learning this by practicing it time and again and we will see a number of examples and in the in this course there will be quite a few assignments which you will have to do ok <sil=0.901> .PERIOD Next we will move to next we will move to a new topic which is the control structures and control statements ok <sil=0.961> .PERIOD We have seen if you recall in a flow chart let us go back to the flow chart where we have got some computation statements where we are doing some computations and we usually carry out one statement of time other right that is how we do and in that we go till the end of the program <sil=0.923> .PERIOD For example <sil=0.601> ,COMMA read number 1 read number 2 etc divide add the numbers and divide the numbers to get the average <sil=0.967> .PERIOD So <sil=0.641> ,COMMA when we computed the average it was something like this and at the end we did some print f and in the meanwhile there were some reading the numbers these were some of them were input some were computations right <sil=0.916> .PERIOD But it was a complete sequential thing but if you recall the other type of the other type of flow charts that we had seen there we had started we did some computation and then we took some decisions and based on the decisions I have sometimes gone back to the earlier operation that earlier thing that I had done and otherwise I would have followed this path <sil=0.909> .PERIOD Typically in the example that I had seen we just see the pseudo codify right say for computing the average of 3 numbers I will be read number 1 read number 2 read number 3 and then some equals to number 1 plus number 2 like that I add them and then I compute the average to be some divided by 3 right <sil=0.972> .PERIOD So <sil=0.526> ,COMMA and then we print the sum print the average so this entire thing is going in a sequence all right just one after another one after another no change in the path but in this case for example when we try to if you recall when we are not writing the this program in this form of pseudo code instead I initialize say count to be 3 then read number 1 and initial count here and say sum was 0 assign 0 and then sum is let me just make it just num I am reading one number and sum plus num and then count I decrement so I may count to be count minus 1 because I have one I have already read now I check if count is greater than 0 then what I do in my flow chart I go back to reading the number again otherwise otherwise else I come to the computation of the average right otherwise so if as long as count is greater than 0 I am continuously doing this thing right these steps <sil=0.907> .PERIOD So <sil=0.505> ,COMMA here at this point you check that I am looking at the value of count and depending on the value of count I am deciding whether I will be going in this direction or I will go back and change the direction of the flow <sil=0.983> .PERIOD So <sil=0.304> ,COMMA that means as if the at this point the the execution is undergoing a decision making to decide which part it will go through this path or this path as if you are count therefore <sil=0.386> ,COMMA you are controlling the flow of the program either in this way or you change the path we will see that we can change the path in two different ways one is that sequentially I am coming and I may go ahead I can skip some of the operations and I can go jump forward that is also a change of the path this dotted line is showing the normal sequential execution or could be that from here I can go back to another path <sil=0.997> .PERIOD So <sil=0.611> ,COMMA these are the two types of change of flow change of flow that is that can be resulted in and that can be resulted in using the control structure <sil=0.933> .PERIOD So <sil=0.612> ,COMMA we will soon go into the details of the control structure and see how such control structures or change of the sequential flow can be achieved in any programming will exemplify as we are doing for all other examples using the constructs of C <sil=0.630> ,COMMA but that does not mean that it is restricted only to C it can be there are similar control constructs for other languages as well we will come to that in the next lecture <sil=0.949> .PERIOD So <sil=0.524> ,COMMA we are looking at solving a quadratic equation and we have seen that there are three cases <sil=0.943> .PERIOD One is if the discriminant is 0 <sil=0.568> ,COMMA we print the roots that the roots are real <sil=0.936> .PERIOD Sorry <sil=0.538> ,COMMA if the discriminant is greater than 0 <sil=0.521> ,COMMA then the roots are real <sil=0.964> .PERIOD Otherwise <sil=0.443> ,COMMA if it is equal to 0 <sil=0.567> ,COMMA then the roots are equal and if the discriminant is neither greater than 0 <sil=0.343> ,COMMA nor equal to 0 <sil=0.537> ,COMMA that means it is less than 0 <sil=0.446> ,COMMA then the roots are imaginary <sil=0.961> .PERIOD So <sil=0.575> ,COMMA next what we did is <sil=0.450> ,COMMA we started with a program like this <sil=0.525> ,COMMA where we declared the coefficients here and then the discriminant and the intermediate variable D and 2 roots <sil=0.584> ,COMMA root 1 and root 2 <sil=0.996> .PERIOD Next we proceeded with this and we modified this part <sil=0.907> .PERIOD If disk is greater than 0 <sil=0.582> ,COMMA print a roots are real and then I modified this part and replace this part with this <sil=0.985> .PERIOD If discriminant is 0 <sil=0.559> ,COMMA print the roots are real and also compute the root <sil=0.961> .PERIOD Now <sil=0.446> ,COMMA if the discriminant is equal to 0 <sil=0.561> ,COMMA then the roots are equal <sil=0.441> ,COMMA compute the root and print it <sil=0.940> .PERIOD Now <sil=0.428> ,COMMA I asked you to see how you will deal with the third case <sil=0.310> ,COMMA if the discriminant is not equal to 0 <sil=0.993> .PERIOD So <sil=0.531> ,COMMA this if <sil=0.547> ,COMMA when this if comes <sil=0.563> ,COMMA then it has already failed the condition that discriminant is greater than 0 and if the discriminant is not equal to 0 <sil=0.559> ,COMMA then we will come to just an else here right and let me go to the next page to write the else part of this <sil=0.968> .PERIOD So <sil=0.302> ,COMMA it will be else simply I am sorry here did I give the parenthesis yes I did <sil=0.966> .PERIOD So <sil=0.627> ,COMMA I am this is please note these are the points where we often make the mistakes <sil=0.935> .PERIOD Else print F <sil=0.391> ,COMMA the roots are imaginary <sil=0.613> ,COMMA the roots are imaginary <sil=0.371> ,COMMA backslash and fine and what are the roots <sil=0.982> .PERIOD So <sil=0.558> ,COMMA if you if the roots are imaginary <sil=0.647> ,COMMA then the real part say one part one root is minus B by 2 A is a real part and the image plus I that is what we I d by 2 A is it clear <sil=0.905> .PERIOD Another this is one root <sil=0.489> ,COMMA another root is B by 2 A minus I d by 2 A what does so this d <sil=0.995> .PERIOD So <sil=0.572> ,COMMA basically you see what we are doing is x is minus B plus minus root over B square minus 4 A C by 2 A <sil=0.970> .PERIOD So <sil=0.321> ,COMMA this is my discriminant and I take the square root of that <sil=0.933> .PERIOD So <sil=0.385> ,COMMA plus minus root over d by 2 A right in my program what did I did D or discriminant square root of disk sorry disk <sil=0.955> .PERIOD So <sil=0.545> ,COMMA I should not use different name <sil=0.939> .PERIOD So <sil=0.508> ,COMMA it should be disk by 2 A and that square root of disk can be either imaginary <sil=0.996> .PERIOD So <sil=0.595> ,COMMA negative if this is negative <sil=0.371> ,COMMA then I will find its absolute value and so this can be written as minus B by 2 A plus square root of disk by 2 A is one root <sil=0.318> ,COMMA another root is B by 2 A minus root over disk by 2 A and since it is imaginary it should be I the imaginary part <sil=0.962> .PERIOD So <sil=0.488> ,COMMA I can print it as a real part to be B minus 2 A and imaginary part is square root of disk by 2 A and so square root of disk is nothing but D <sil=0.917> .PERIOD So <sil=0.640> ,COMMA minus B by 2 A plus I d by 2 A that is what I am writing here <sil=0.901> .PERIOD So <sil=0.339> ,COMMA this is the real part this is the imaginary part <sil=0.957> .PERIOD So <sil=0.600> ,COMMA I can print it in different ways <sil=0.909> .PERIOD So <sil=0.334> ,COMMA I can just say else print F roots are imaginary or rather I should have said this is wrong to say what should I have said you should have I mean I am doing a mistake here all through starting from this point you must have observed it here the roots are complex roots in that case not the imaginary roots because it has got a real part and the imaginary part <sil=0.962> .PERIOD So <sil=0.640> ,COMMA the roots are complex I should have written roots are I should written complex roots and then I could print real part percentage F back slash n I can put an expression here minus B divided by 2 A <sil=0.987> .PERIOD Let me make it a little thinner looks very nasty here B divided by 2 A that is the imaginary part that is a real part and print F imaginary part as plus i percentage f comma minus i percentage f backslash n followed by what is my imaginary part imaginary part is d by 2 a <sil=0.992> .PERIOD So <sil=0.583> ,COMMA you see I have put this i part plus i and minus i here comma d divided by again d divided by twice a <sil=0.996> .PERIOD So <sil=0.635> ,COMMA this and then of course <sil=0.323> ,COMMA everything is done <sil=0.983> .PERIOD So <sil=0.342> ,COMMA I come to the end of my program before that here there should be a parenthesis <sil=0.960> .PERIOD So <sil=0.379> ,COMMA this is the complex part <sil=0.992> .PERIOD Now <sil=0.517> ,COMMA as we will become little more conversion with programming <sil=0.423> ,COMMA you can see that I have repeated many things <sil=0.980> .PERIOD So <sil=0.408> ,COMMA instead of doing it there are some common you can think of how you can write it in a much more elegant and shorter way <sil=0.919> .PERIOD But <sil=0.361> ,COMMA this is an example which gives you an exposure to the use of if then else statements e fail statements in c <sil=0.964> .PERIOD Next well another example we can take up say for example <sil=0.439> ,COMMA we are going to compute the income tax of a person <sil=0.912> .PERIOD Suppose the if the income tax is less than 100 <sil=0.394> ,COMMA 000 rupees <sil=0.355> ,COMMA then income tax is nil <sil=0.929> .PERIOD If it is between 100 <sil=0.607> ,COMMA 000 to 200 <sil=0.495> ,COMMA 000 rupees <sil=0.588> ,COMMA then you pay 10 percent of the amount above 100 <sil=0.542> ,COMMA 000 <sil=0.923> .PERIOD For income above this 200 <sil=0.551> ,COMMA 000 if the income is above 200 <sil=0.356> ,COMMA 000 <sil=0.913> ,COMMA then you pay 20 percent of the amount whole amount not how much is exceeding 10 <sil=0.366> ,COMMA 000 <sil=0.937> .PERIOD Suppose this is our income tax policy <sil=0.305> ,COMMA how can we do this <sil=0.951> .PERIOD So <sil=0.631> ,COMMA what is the input that I need from the user <sil=0.903> ?QUESTIONMARK I need this income from the user and what is the other variable that I want to compute the tax <sil=0.952> .PERIOD So <sil=0.332> ,COMMA here earlier I needed math <sil=0.989> .PERIOD leab in this case <sil=0.643> ,COMMA probably I will not need that <sil=0.559> ,COMMA but I will not need that <sil=0.931> .PERIOD If needed I can always add it later <sil=0.486> ,COMMA and then you can say put a comment computation of income tax computation <sil=0.968> .PERIOD Now I start my program <sil=0.621> ,COMMA I can put the parenthesis above <sil=0.912> .PERIOD Then print F <sil=0.456> ,COMMA it is always better to do this <sil=0.997> .PERIOD Please enter your income <sil=0.344> ,COMMA because if you do that <sil=0.617> ,COMMA then you make your program interactive <sil=0.950> .PERIOD That means the user can see what you are doing <sil=0.942> .PERIOD Please enter your income <sil=0.508> .PERIOD Well <sil=0.505> ,COMMA I have not yet declared the variables at all <sil=0.971> .PERIOD So <sil=0.417> ,COMMA here I should write float income tax <sil=0.425> ,COMMA and tax <sil=0.946> .PERIOD Then here scan F <sil=0.360> ,COMMA percentage F <sil=0.410> ,COMMA and income <sil=0.919> .PERIOD So <sil=0.419> ,COMMA I read the income here <sil=0.914> .PERIOD Fine <sil=0.992> .PERIOD Then what should I do <sil=0.918> ?QUESTIONMARK Let me come to the next page then <sil=0.321> ,COMMA because there will be a number of if conditions <sil=0.966> .PERIOD So <sil=0.455> ,COMMA this part is okay <sil=0.926> .PERIOD I have read the income here <sil=0.929> .PERIOD Now <sil=0.529> ,COMMA if income is less than or equal to 100 <sil=0.619> ,COMMA 000 print F <sil=0.436> ,COMMA no tax <sil=0.932> .PERIOD What is my principle <sil=0.933> ?QUESTIONMARK 10 <sil=0.359> ,COMMA 1 lakh to 2 lakhs <sil=0.975> .PERIOD 10 percent of the income <sil=0.530> ,COMMA 10 percent of the income above 100 <sil=0.328> ,COMMA 000 <sil=0.984> .PERIOD So <sil=0.610> ,COMMA else if income is less than equal to 200 <sil=0.621> ,COMMA 000 <sil=0.908> .PERIOD So <sil=0.558> ,COMMA it is not when it is coming here <sil=0.395> ,COMMA it is already greater than 100 <sil=0.612> ,COMMA 000 <sil=0.923> .PERIOD So <sil=0.470> ,COMMA if it is less than 200 <sil=0.463> ,COMMA 000 <sil=0.914> ,COMMA then tax will be 10 percent <sil=0.901> .PERIOD That means <sil=0.598> ,COMMA 0 <sil=0.413> .PERIOD 1 times the amount exceeding 100 <sil=0.440> ,COMMA 000 <sil=0.953> .PERIOD So <sil=0.425> ,COMMA income minus 100 <sil=0.362> ,COMMA 000 print F tax equals percentage F <sil=0.320> ,COMMA backslash N tax <sil=0.955> .PERIOD Is this part clear <sil=0.898> ?QUESTIONMARK This part is <sil=0.903> .PERIOD So <sil=0.646> ,COMMA when am I coming here <sil=0.907> ?QUESTIONMARK This if condition has failed <sil=0.992> .PERIOD So <sil=0.312> ,COMMA I am coming here <sil=0.962> .PERIOD That means <sil=0.483> ,COMMA it is not less than 100 <sil=0.375> ,COMMA 000 <sil=0.959> .PERIOD So <sil=0.621> ,COMMA it is more than 100 <sil=0.493> ,COMMA 000 <sil=0.949> .PERIOD But if it is less than 200 <sil=0.404> ,COMMA less than equal to 200 <sil=0.464> ,COMMA 000 <sil=0.902> ,COMMA then I am in the second bracket <sil=0.996> .PERIOD And I will be paying 10 percent of the amount that is exceeding 100 <sil=0.480> ,COMMA 000 <sil=0.990> .PERIOD That is why I computed this <sil=0.960> .PERIOD And then I am printing this <sil=0.997> .PERIOD So <sil=0.505> ,COMMA here it is more than one statement <sil=0.940> .PERIOD I put a bracket <sil=0.975> .PERIOD Here you see under if I had only one statement <sil=0.957> .PERIOD So <sil=0.604> ,COMMA putting a bracket is not mandatory <sil=0.451> ,COMMA but here it is mandatory <sil=0.983> .PERIOD Otherwise <sil=0.504> ,COMMA it will mean something else <sil=0.908> .PERIOD So <sil=0.400> ,COMMA else this <sil=0.918> .PERIOD Now <sil=0.382> ,COMMA if this is also not true <sil=0.401> ,COMMA that is if this if does not satisfy <sil=0.347> ,COMMA then I am in the third bracket <sil=0.944> .PERIOD That is here <sil=0.588> ,COMMA what should I do <sil=0.961> ?QUESTIONMARK Else tax is 20 percent of the income <sil=0.909> .PERIOD And print F tax assigned percentage F backslash n tax <sil=0.952> .PERIOD Now <sil=0.597> ,COMMA here then I come to the end <sil=0.984> .PERIOD So <sil=0.623> ,COMMA I come to this beginning point and I end the program here <sil=0.999> .PERIOD Now <sil=0.452> ,COMMA you can see that I can reduce this program a little bit <sil=0.975> .PERIOD Now <sil=0.321> ,COMMA I have written this printing the tax <sil=0.916> .PERIOD This thing the same thing twice <sil=0.927> .PERIOD I am sorry here <sil=0.932> .PERIOD There should be another bracket for completing this <sil=0.925> .PERIOD This should be completed and then the next bracket <sil=0.988> .PERIOD Now <sil=0.479> ,COMMA this I could have done later after these two years <sil=0.900> .PERIOD But under this else under this else <sil=0.919> .PERIOD So <sil=0.644> ,COMMA you can also try to reduce it <sil=0.998> .PERIOD And as an assignment <sil=0.330> ,COMMA you should run this program and get yourself satisfied <sil=0.986> .PERIOD So <sil=0.636> ,COMMA this is another classical example of if then else usage <sil=0.964> .PERIOD Given this <sil=0.647> ,COMMA we will now move to some more examples of the other construct that is while and do while type of constructs <sil=0.934> .PERIOD So <sil=0.433> ,COMMA here is an example to show if a number is prime or not <sil=0.986> .PERIOD Now <sil=0.621> ,COMMA how do I go about it <sil=0.936> ?QUESTIONMARK Let us first think of the algorithm for finding out whether a number is prime or not <sil=0.995> .PERIOD Say for example <sil=0.496> ,COMMA I take a number 13 <sil=0.951> .PERIOD I want to find out whether 13 is prime or not <sil=0.968> .PERIOD So <sil=0.438> ,COMMA when is a number called prime <sil=0.923> ?QUESTIONMARK When the number is not divisible by any other number other than the number itself and one <sil=0.934> .PERIOD So <sil=0.585> ,COMMA in order to find out whether 13 is prime or not <sil=0.411> ,COMMA what shall I do <sil=0.957> ?QUESTIONMARK I will start with two and I will try to see whether 2 is dividing 13 <sil=0.995> .PERIOD How do I know whether 2 is dividing 13 <sil=0.937> ?QUESTIONMARK So <sil=0.529> ,COMMA if there are 2 integers say 14 modulus 2 <sil=0.610> ,COMMA the modulus leads gives me the remainder <sil=0.991> .PERIOD So <sil=0.455> ,COMMA if 14 is divisible by 2 <sil=0.638> ,COMMA the remainder will be 0 <sil=0.955> .PERIOD 26 divided by 2 <sil=0.619> ,COMMA the remainder will be 0 <sil=0.934> .PERIOD But 13 divided by 2 <sil=0.518> ,COMMA the remainder will be 1 <sil=0.942> .PERIOD So <sil=0.530> ,COMMA similarly <sil=0.462> ,COMMA so I suppose I want to see whether number 15 is divisible by 3 <sil=0.970> .PERIOD I will do the modulus operation of 15 with 3 and the remainder will be 0 <sil=0.923> .PERIOD So <sil=0.554> ,COMMA 15 is divisible by 3 <sil=0.910> .PERIOD So <sil=0.591> ,COMMA now if I want to find out whether 13 is a prime or not <sil=0.355> ,COMMA I will first try to divide c whether it is divisible by 2 <sil=0.964> .PERIOD If it is divisible <sil=0.417> ,COMMA yes will tell me not prime <sil=0.913> .PERIOD It will tell me not prime <sil=0.301> ,COMMA but no <sil=0.907> .PERIOD Then I will try to divide it by 3 <sil=0.993> .PERIOD If this is divisible by 3 <sil=0.365> ,COMMA then again not prime <sil=0.959> .PERIOD No <sil=0.647> ,COMMA I will divide by 4 <sil=0.522> ,COMMA then obviously not divisible <sil=0.950> .PERIOD Then I will divide it by 5 <sil=0.475> ,COMMA so and so forth <sil=0.908> .PERIOD I will go till I divide it by 12 <sil=0.975> .PERIOD Since of course <sil=0.581> ,COMMA by 13 it will be divisible <sil=0.957> .PERIOD So <sil=0.622> ,COMMA if the answer continuously up to 12 is no <sil=0.389> ,COMMA then we say it is not prime <sil=0.946> .PERIOD So <sil=0.388> ,COMMA here you see there are two things happening <sil=0.960> .PERIOD One is I am taking a check <sil=0.424> ,COMMA branching here <sil=0.961> .PERIOD I am dividing it by 2 <sil=0.960> .PERIOD If it is divisible <sil=0.618> ,COMMA I say it is not prime <sil=0.902> .PERIOD If no <sil=0.553> ,COMMA then I am taking another path <sil=0.986> .PERIOD What is that path <sil=0.943> ?QUESTIONMARK That path is again trying with the next successor of this two <sil=0.965> .PERIOD Yes <sil=0.302> ,COMMA if the result is yes <sil=0.580> ,COMMA I take this path <sil=0.957> .PERIOD Otherwise <sil=0.318> ,COMMA I will follow this path with a successor of this <sil=0.906> .PERIOD So <sil=0.457> ,COMMA the same thing trying with the successor <sil=0.417> ,COMMA I am doing continuously repeatedly if the divisibility result is false <sil=0.932> .PERIOD That means <sil=0.580> ,COMMA if it is not divisible <sil=0.368> ,COMMA I will continuously go on till I reach if this number is n till I reach n minus 1 <sil=0.973> .PERIOD Up to that I will try up to n minus 1 I will try <sil=0.916> .PERIOD So <sil=0.633> ,COMMA this is an example where there is a branching as well as looping <sil=0.956> .PERIOD Another real life <sil=0.577> ,COMMA mathematically important application <sil=0.917> .PERIOD So <sil=0.548> ,COMMA let us look at the program now <sil=0.933> .PERIOD Let us try to understand the program here <sil=0.913> .PERIOD This include stduiu dot h is known to you main <sil=0.936> .PERIOD I am declaring two different variables <sil=0.914> .PERIOD One is n another is i <sil=0.983> .PERIOD n is an integer i is also an integer initialized to 2 <sil=0.976> .PERIOD I am reading the number here say 13 <sil=0.944> .PERIOD While i is less than n <sil=0.634> ,COMMA that means i was 2 <sil=0.974> .PERIOD If you look at this page <sil=0.463> ,COMMA we started with 2 and then went on <sil=0.967> .PERIOD So <sil=0.457> ,COMMA this is the value of i <sil=0.990> .PERIOD So <sil=0.447> ,COMMA this is the value of n <sil=0.962> .PERIOD So <sil=0.312> ,COMMA now while i is less than n <sil=0.994> .PERIOD So <sil=0.506> ,COMMA I had 13 <sil=0.640> ,COMMA I had 13 and I had 13 <sil=0.954> .PERIOD So <sil=0.468> ,COMMA I had 13 <sil=0.511> .PERIOD So <sil=0.476> ,COMMA I had 13 <sil=0.439> .PERIOD So <sil=0.628> ,COMMA I had 13 <sil=0.418> .PERIOD So <sil=0.620> ,COMMA I had 13 <sil=0.305> .PERIOD So <sil=0.478> ,COMMA I had 13 and i is 2 <sil=0.917> .PERIOD This is n <sil=0.998> .PERIOD I will go on up to 13 <sil=0.515> ,COMMA up to while i is less than n <sil=0.941> .PERIOD That means up to 12 <sil=0.940> .PERIOD I will go on trying this thing <sil=0.920> .PERIOD But if n is divisible by i <sil=0.308> ,COMMA is n divisible by i <sil=0.883> ?QUESTIONMARK Yes <sil=0.300> ,COMMA then print that the number n is not a prime <sil=0.952> .PERIOD And then exit <sil=0.461> ,COMMA we come out of this loop <sil=0.992> .PERIOD Just like break <sil=0.390> ,COMMA we come out of this loop <sil=0.971> .PERIOD But break is not applicable in if statement exit <sil=0.521> ,COMMA we can write <sil=0.925> .PERIOD So <sil=0.522> ,COMMA I come out of the loop <sil=0.556> .PERIOD Otherwise <sil=0.584> ,COMMA what I am doing still in the while loop <sil=0.908> .PERIOD The while loop is starting from this point and going up to this point <sil=0.954> .PERIOD I am incrementing i <sil=0.920> .PERIOD So <sil=0.504> ,COMMA i becomes 3 <sil=0.900> .PERIOD And again <sil=0.396> ,COMMA I go and try to see if it is divisible with 3 <sil=0.985> .PERIOD No <sil=0.459> ,COMMA then I come make it 4 <sil=0.549> ,COMMA make it 4 <sil=0.962> .PERIOD I again try this one fails <sil=0.987> .PERIOD It is not divisible <sil=0.996> .PERIOD So <sil=0.495> ,COMMA I do not do this part <sil=0.908> .PERIOD I do not do this part <sil=0.950> .PERIOD I come here <sil=0.411> ,COMMA make it 5 and go on in this way while i is 12 <sil=0.635> ,COMMA up to 12 by check <sil=0.971> .PERIOD And then it becomes 13 <sil=0.934> .PERIOD So <sil=0.535> ,COMMA I come here and ultimately <sil=0.620> ,COMMA I come out of the loop <sil=0.629> .PERIOD And till 13 <sil=0.548> ,COMMA I could see that no <sil=0.307> ,COMMA I could find no number <sil=0.560> ,COMMA no integer that is dividing it <sil=0.933> .PERIOD So <sil=0.574> ,COMMA we say that this is a prime number <sil=0.934> .PERIOD Say for example <sil=0.590> ,COMMA what would have happened if I had given the instead of n <sil=0.375> ,COMMA 13 <sil=0.568> ,COMMA if I had given it 14 <sil=0.497> ,COMMA what would be the change in this flow <sil=0.935> .PERIOD I would start with the 2 <sil=0.365> ,COMMA 2 <sil=0.475> .PERIOD And again <sil=0.585> ,COMMA I divide it by 2 <sil=0.301> ,COMMA try dividing it by 2 <sil=0.901> .PERIOD It is divisible <sil=0.901> .PERIOD I print that it is not a prime <sil=0.955> .PERIOD And I exit and come out of this entire while loop <sil=0.982> .PERIOD So <sil=0.603> ,COMMA in the while loop <sil=0.502> ,COMMA here I am exiting from the while loop altogether <sil=0.646> ,COMMA not from the if loop <sil=0.912> .PERIOD I am exiting from the while loop <sil=0.593> ,COMMA if it is not a loop by the way <sil=0.942> .PERIOD I am exiting from the while loop completely <sil=0.950> .PERIOD So <sil=0.617> ,COMMA this example also illustrates the use of if here and the while loop here <sil=0.951> .PERIOD We will see a few more examples in the future lectures <sil=0.943> .PERIOD We were looking at C constructs by which we can achieve reputations or loops <sil=0.961> .PERIOD That means <sil=0.585> ,COMMA a set of statements will be executed repeatedly for a fixed number of times <sil=0.917> .PERIOD So <sil=0.418> ,COMMA one of such constructs that we came across was the wild statement as is being shown here wild <sil=0.974> .PERIOD And you can see the structure of this that <sil=0.505> ,COMMA while a particular condition is true will carry out a set of statements <sil=0.943> .PERIOD It can be one statement or it can be a number of statements as is shown here <sil=0.982> .PERIOD A number of statements will be repeated as long as this condition is true <sil=0.949> .PERIOD An example that we had seen in the last lecture was this that is as long as I can read this while as long as <sil=0.955> .PERIOD As long as the weight is greater than 65 you will have to do exercise <sil=0.977> .PERIOD And here you again check the weight and if it is greater than 65 you will carry it out <sil=0.974> .PERIOD That is the structure of the wild statement <sil=0.930> .PERIOD Now <sil=0.342> ,COMMA how can you use it fruitfully <sil=0.867> ?QUESTIONMARK Let us take an example of using the wild look for some meaningful computation <sil=0.981> .PERIOD For example <sil=0.441> ,COMMA I want to add 10 numbers the example that we are doing earlier we had shown the pseudo code for that <sil=0.943> .PERIOD So <sil=0.557> ,COMMA I have got a value n let us see let us do it for a smaller number n equals 5 <sil=0.976> .PERIOD So <sil=0.495> ,COMMA I will carry out the sum of 5 numbers <sil=0.958> .PERIOD So <sil=0.649> ,COMMA I will have a count another variable count which may be initialized to 0 <sil=0.952> .PERIOD Now <sil=0.608> ,COMMA we can write something like so initially count is 0 <sil=0.601> ,COMMA count is an integer count is 0 <sil=0.939> .PERIOD While count is less than n and also I do another thing I am going to add 5 numbers <sil=0.955> .PERIOD So <sil=0.591> ,COMMA I create another variable sum <sil=0.967> .PERIOD So <sil=0.420> ,COMMA sum is 0 and count is 0 <sil=0.938> .PERIOD So <sil=0.331> ,COMMA while count is less than n I can write a complete program now print if please enter a number <sil=0.958> .PERIOD And then so <sil=0.447> ,COMMA on the screen on the screen I will have please enter the number printed here <sil=0.923> .PERIOD Then I am doing scan F percentage D and num <sil=0.969> .PERIOD num is the variable which I am really and then I am adding updating sum initially sum was 0 <sil=0.945> .PERIOD So <sil=0.608> ,COMMA sum plus num all right I do this and then how many numbers I have read I have read one number <sil=0.901> .PERIOD So <sil=0.457> ,COMMA I will do count plus plus that means count now 1 <sil=0.947> .PERIOD So <sil=0.579> ,COMMA 1 number has been read <sil=0.906> .PERIOD So <sil=0.608> ,COMMA I will be completing here <sil=0.994> .PERIOD Now <sil=0.392> ,COMMA let us see what will happen suppose n was 5 <sil=0.944> .PERIOD So <sil=0.518> ,COMMA sum is 0 <sil=0.909> .PERIOD So <sil=0.587> ,COMMA the first number has been read <sil=0.932> .PERIOD So <sil=0.481> ,COMMA count was 0 <sil=0.937> .PERIOD Please enter a number and sum number has been entered and suppose that number was 5 <sil=0.912> .PERIOD Then sum is sum plus number <sil=0.956> .PERIOD So <sil=0.519> ,COMMA this one becomes 5 <sil=0.959> .PERIOD Then I increment count <sil=0.924> .PERIOD So <sil=0.405> ,COMMA count becomes 1 <sil=0.981> .PERIOD I come back here I find count is still less than 5 because I am going to n is 5 right <sil=0.989> .PERIOD So <sil=0.638> ,COMMA count is still less than 5 <sil=0.918> .PERIOD I again do that suppose I did the second number 6 <sil=0.997> .PERIOD So <sil=0.385> ,COMMA then this becomes here I add this becomes 11 and count becomes 2 <sil=0.913> .PERIOD Please note that count in this case is therefore <sil=0.526> ,COMMA keeping account of how many numbers I have already read because I am reading the number here and then incrementing count <sil=0.939> .PERIOD So <sil=0.557> ,COMMA count now I have read 2 numbers and I have added the sum <sil=0.975> .PERIOD So <sil=0.322> ,COMMA now after doing this count is becoming 2 I have read 2 numbers I again go here <sil=0.953> .PERIOD Now <sil=0.428> ,COMMA 2 is less than 5 I take another number say 11 <sil=0.969> .PERIOD So <sil=0.592> ,COMMA I add sum <sil=0.962> .PERIOD So <sil=0.582> ,COMMA it becomes 22 and I increment count 3 <sil=0.977> .PERIOD I have read 3 numbers I go up again here and read the fourth number 15 <sil=0.989> .PERIOD Add that with sum <sil=0.999> .PERIOD So <sil=0.466> ,COMMA 22 plus 15 will be 37 and then count will be upgraded it will become <sil=0.921> .PERIOD So <sil=0.402> ,COMMA I have read 4 numbers 5 6 11 15 <sil=0.903> .PERIOD Now <sil=0.405> ,COMMA I again go up here and check count count is 15 sorry count is 4 which is less than 5 <sil=0.920> .PERIOD So <sil=0.446> ,COMMA I read another number suppose that is 7 <sil=0.928> .PERIOD I come here add it it becomes 44 and I increment count I first add that number <sil=0.923> .PERIOD So <sil=0.322> ,COMMA it becomes 44 and then I increment count <sil=0.918> .PERIOD So <sil=0.341> ,COMMA count becomes 5 meaning that I have already read 5 numbers <sil=0.976> .PERIOD Now <sil=0.304> ,COMMA when I go back here I check is count less than no <sil=0.905> .PERIOD Therefore <sil=0.381> ,COMMA I will come out of that and maybe here I will write something like print F <sil=0.959> .PERIOD The sum is assuming integers is percentage d max large n and here I print sum and whatever I do <sil=0.905> .PERIOD Here are the other components of the complete program declarations integers and all those things are there <sil=0.938> .PERIOD Now <sil=0.632> ,COMMA a point to be careful about I must be very careful about expressing the condition <sil=0.904> .PERIOD Look here if instead of this I had if instead of this I had made it less than equal to n then what would have happened if instead of count less than n if I had written count less than equal to n <sil=0.981> .PERIOD What would have happened after count is 5 that means <sil=0.594> ,COMMA I have read 5 numbers I have added 5 numbers and 44 is my result <sil=0.928> .PERIOD I would again go back here and I would find that count is less than equal to 5 count is 5 <sil=0.929> .PERIOD Therefore <sil=0.611> ,COMMA this condition would be true I would again come and would have read another number sorry I should not cut it out I would have read another number and then count would be incremented 6 I would have 45 which would be a wrong result because here actually I have read 6 numbers <sil=0.957> .PERIOD So <sil=0.334> ,COMMA you must be very careful to specify this particular statement so that the number of times you want the loop to work should be accurate should be correct <sil=0.939> .PERIOD So <sil=0.412> ,COMMA I think you have understood this example a very simple program but some care is needed about this <sil=0.985> .PERIOD So <sil=0.472> ,COMMA that was an example of wild statement <sil=0.947> .PERIOD So <sil=0.634> ,COMMA here is another example suppose the digit is 0 what would this one do can you find out what this will do this is a wild statement all of you try to look at it and find out what this loop does this wild loop does <sil=0.911> .PERIOD If you look at it carefully you will see that I am starting the digit I have initialized digit to be 0 <sil=0.924> .PERIOD Now <sil=0.396> ,COMMA wild digit is less than equal to 9 first time I come here it is less than equal to 9 <sil=0.944> .PERIOD So <sil=0.528> ,COMMA what will it do careful it will come to this print up statement and will print digit now it is a post increment or pre increment it is a post increment that means <sil=0.595> ,COMMA first digit will be printed so 0 will be printed then digit will be incremented <sil=0.992> .PERIOD So <sil=0.466> ,COMMA this digit will now become 1 I again go back here and find that digit is less than equal to 9 right <sil=0.975> .PERIOD So <sil=0.578> ,COMMA I will come here print the digit 1 and then again increment digit digit will become 2 I go back here check whether it is less than equal to 9 it is still less than equal to 9 I will come inside the loop will print the digit 2 in that way it will go on ultimately 8 will be printed and 8 has been printed and I go back after printing 8 this has been incremented to 9 I go back here now yes you see here less than equal to 9 therefore <sil=0.545> ,COMMA I will still executed that means <sil=0.524> ,COMMA I will print 9 and then increment it it will be 10 and then when I go up here this condition is no longer true therefore <sil=0.625> ,COMMA I will come out of this loop <sil=0.991> .PERIOD So <sil=0.548> ,COMMA what will be printed 0 to 9 the 10 numbers will be printed ok <sil=0.995> .PERIOD So <sil=0.508> ,COMMA that is how the while loop works <sil=0.972> .PERIOD So <sil=0.546> ,COMMA this flow chart is very important to remember what while does you have actually understood it by now <sil=0.412> ,COMMA but the key point to note the most important point to note is this that when I am executing the program in this direction I first compute the condition first I compute the condition and if the condition is true I execute the body of the loop then I again go up go up check the condition and this will be going on <sil=0.908> .PERIOD So <sil=0.376> ,COMMA first the condition is checked if it is false I will go out of the loop <sil=0.936> .PERIOD So <sil=0.383> ,COMMA if initially say for example <sil=0.466> ,COMMA I write something like this say digit is equal to 20 and I start something like while digit is less than equal to 15 something I will be doing <sil=0.921> .PERIOD Now <sil=0.489> ,COMMA in this case when it comes to this condition at the very beginning at the very beginning it will fail because this condition is not true <sil=0.962> .PERIOD So <sil=0.349> ,COMMA it will come out through this false path and this loop will not be executed will be just coming to the next statement after the loop ok <sil=0.913> .PERIOD So <sil=0.483> ,COMMA in while the condition is first evaluated and depending on the success of the test of the condition will either enter the loop or will bypass the loop <sil=0.940> .PERIOD So <sil=0.319> ,COMMA this flow chart is very important <sil=0.987> .PERIOD Now <sil=0.522> ,COMMA you will be contrasting while statement with another statement which is the do while statement what is the difference looks like very similar <sil=0.969> .PERIOD So <sil=0.462> ,COMMA there is a scope of confusion while and do while <sil=0.939> .PERIOD So <sil=0.392> ,COMMA as the name implies here do comes first do something and then check the condition what it means is say do some statements here while condition you will do all these statements and then check the condition <sil=0.901> .PERIOD So <sil=0.351> ,COMMA let us see what will happen here the weight loss program again rewritten with while is do go exercise <sil=0.948> .PERIOD So <sil=0.542> ,COMMA you start with a do you do go exercise print F come back whatever whatever then read the weight and while weight is 65 <sil=0.920> .PERIOD So <sil=0.398> ,COMMA at least the condition is being checked here the condition is being checked here <sil=0.914> .PERIOD So <sil=0.327> ,COMMA it will at least carry out the computation once <sil=0.949> .PERIOD So <sil=0.613> ,COMMA that digit thing if we do suppose I write something like this <sil=0.960> .PERIOD So <sil=0.349> ,COMMA digit is 20 and I write while digit is less than equal to 15 say I do digit plus plus print F digit <sil=0.981> .PERIOD Now <sil=0.316> ,COMMA in this case since the digit is 20 what will be printed here nothing all right or say say let me let me make it even simpler let me make it a little different digit is 20 while do 15 digit plus plus print F percentage D backslash and digit <sil=0.931> .PERIOD If I do this since digit is 20 what will be printed here 20 will be printed because this plus plus will not be executed right because here it will fail <sil=0.940> .PERIOD But if I do it now if I do it as digit equals 20 do I need to give the bracket I may or may not but let me give it it really does not matter digit plus plus while digit is less than 15 less than equal to 15 and here I write print F percentage D backslash and digit all right <sil=0.940> .PERIOD What will happen let us contrast this here also digit is 20 here also digit was 20 <sil=0.949> .PERIOD Now <sil=0.572> ,COMMA here it was tested at this point so this digit plus plus will not be executed it will straight way come here and will print digit it will be 20 whereas in this case I first encounter this do and as I do I check this digit I make this digit plus plus that means it becomes 21 and then I check while digit is less than equal to 15 now I find digit is not less than equal to 15 of course I will not do it again but once I have already done it so when I take the print F digit will be printed to be 21 <sil=0.983> .PERIOD So <sil=0.550> ,COMMA here is the difference between while and do while so these are two constructs by which just two example constructs by which we can carry out the loop <sil=0.906> .PERIOD So <sil=0.478> ,COMMA at least one round is carried out so if I take if I look at the flow chart it will be looking like this it will have a set of statements which will be executed at least once whatever the condition be condition is <sil=0.923> .PERIOD So <sil=0.372> ,COMMA this will be executed first it will be first executed here and then we check the condition if it is false I will not do it again I will come out otherwise I will repeat <sil=0.949> .PERIOD So <sil=0.420> ,COMMA here again that old example digit was 0 do print F digit plus plus while digit is less than 9 <sil=0.931> .PERIOD So <sil=0.334> ,COMMA you remember in the earlier case we had printed 0 1 2 3 4 5 6 7 8 9 now what will be printed in this case let us see digit is 0 initially <sil=0.934> .PERIOD Now <sil=0.489> ,COMMA we come here first we print digit so 0 is printed 0 is printed then digit plus plus is done so digit is 1 right <sil=0.950> .PERIOD So <sil=0.401> ,COMMA digit now becomes 1 digit was 0 so it becomes 1 and then I check is digit less than 9 yes it is less than 9 <sil=0.978> .PERIOD So <sil=0.561> ,COMMA I again print digit 1 is printed let us make this 9 let us say that is 5 all right let us say so we have done make made it 1 and after printing 1 digit has been made 2 plus plus has been done I check again it is less than 5 so I will do go go to the loop again I will do it again so I will be printing 2 and then make digit to be 3 it is still less than 5 I will go again I will print 3 and then I make digit to be 4 still less than 5 I print 4 I make it 5 all right less than equal to 5 right <sil=0.920> .PERIOD So <sil=0.307> ,COMMA I print 5 ok print 5 I first print 5 and then incremented to 6 as I do it I incremented to 6 and then I check whether it is less than equal to 5 <sil=0.998> .PERIOD So <sil=0.483> ,COMMA if it is since it is less than not less than equal to 5 I will come out of the loop <sil=0.980> .PERIOD So <sil=0.374> ,COMMA what I will be printing is 012345 so this is an example of while do while next <sil=0.917> .PERIOD So <sil=0.465> ,COMMA this is one type of statement that we have encountered here that is while and do while here we are not pre specifying any number of times that it will be doing as long as a condition is not met I will be doing it <sil=0.923> .PERIOD Now <sil=0.330> ,COMMA how is it that the condition is being affected it is through the computation inside <sil=0.917> .PERIOD So <sil=0.628> ,COMMA for example <sil=0.430> ,COMMA the computation here this plus plus that is being done by that this condition variable is changing all right <sil=0.907> .PERIOD There are cases where I know a priority beforehand I know beforehand that I will have to carry it out 10 times I will have to carry it out 20 times so and so forth ok <sil=0.953> .PERIOD So <sil=0.521> ,COMMA for that another construct is very important and is used in C language that is the 4 construct <sil=0.969> .PERIOD We will come to the 4 construct this is a little complicated you should pay attention <sil=0.906> .PERIOD There are 3 components of this 4 one is an initial x value <sil=0.943> .PERIOD Now <sil=0.452> ,COMMA this initial value can be assigned to a control variable <sil=0.929> .PERIOD So <sil=0.601> ,COMMA there is a look a program and how many times it will look how many times it will look that is being determined by some control variable <sil=0.961> .PERIOD In the case of while what was our control variable say for example <sil=0.593> ,COMMA in the earlier case of earlier example the value of digit was the control variable <sil=0.930> .PERIOD Here we put some control variable and initialize the control variable with some value <sil=0.930> .PERIOD Here some control variable is initialized and then we have a condition <sil=0.958> .PERIOD If that condition is true then I will enter the loop and do that and after doing this loop I have got some iteration parameter by which we update the control variable and check the condition ok <sil=0.981> .PERIOD In that way it will go on <sil=0.984> .PERIOD So <sil=0.385> ,COMMA let us have a look at the structure in a little more detail <sil=0.938> .PERIOD Say here we have got some initial expression some condition and iteration and we have got some statements which will be looping ok <sil=0.959> .PERIOD Here is an example <sil=0.928> .PERIOD Say I am calculating the factorial of 10 <sil=0.901> .PERIOD So <sil=0.318> ,COMMA I am trying to compute the factorial of 10 <sil=0.980> .PERIOD Some people write it in this way some people write it in this way <sil=0.952> .PERIOD Now <sil=0.453> ,COMMA here what is being done I will explain it in a little bit more detail <sil=0.999> .PERIOD Fact is a variable which is standing for factorial it is initialized to 1 <sil=0.904> .PERIOD Now <sil=0.563> ,COMMA you know factorial of 5 is what <sil=0.860> ?QUESTIONMARK 1 times 2 times 3 times 4 times 5 right <sil=0.928> .PERIOD So <sil=0.616> ,COMMA I am starting with some variable and multiplying it with successor and then the product I take and multiply with the successor of the last integer and in that way it goes on <sil=0.967> .PERIOD So <sil=0.612> ,COMMA here is a look of how it will look like we have got a four statement here and I am saying for I assigned 1 <sil=0.913> .PERIOD Now <sil=0.409> ,COMMA this is what I was talking about <sil=0.981> .PERIOD I is a control variable here that is being initialized to 1 <sil=0.912> .PERIOD So <sil=0.624> ,COMMA that is less than 10 of course <sil=0.570> ,COMMA because here I am trying to compute factorial n 10 and then what I do <sil=0.890> ?QUESTIONMARK Fact was 1 <sil=0.970> .PERIOD So <sil=0.592> ,COMMA fact will be fact multiplied by i <sil=0.932> .PERIOD What was i <sil=0.929> ?QUESTIONMARK I was 1 <sil=0.997> .PERIOD So <sil=0.504> ,COMMA it is 1 times 1 <sil=0.962> .PERIOD Then after this operation is done after this operation is done <sil=0.320> ,COMMA I go and do this iteration operation <sil=0.907> .PERIOD Iteration operation what it is doing <sil=0.900> ?QUESTIONMARK It is incrementing i and i is becoming 2 and then before I enter I just check whether it is still less than 10 <sil=0.991> .PERIOD Yes <sil=0.532> ,COMMA it is less than 10 <sil=0.926> .PERIOD I will again do that <sil=0.916> .PERIOD So <sil=0.640> ,COMMA fact will be it was 1 <sil=0.526> ,COMMA 1 times what is i now <sil=0.989> ?QUESTIONMARK 2 <sil=0.497> ,COMMA 1 times 2 <sil=0.953> .PERIOD After I compute 1 times 2 <sil=0.520> ,COMMA I will increment i <sil=0.973> .PERIOD So <sil=0.345> ,COMMA that will become now 3 <sil=0.909> .PERIOD It is still less than 10 <sil=0.999> .PERIOD Please follow my pen <sil=0.967> .PERIOD It is still less than 10 <sil=0.986> .PERIOD I go in compute <sil=0.952> .PERIOD What was i <sil=0.899> ?QUESTIONMARK 3 <sil=0.933> .PERIOD So <sil=0.389> ,COMMA whatever was fact <sil=0.974> ?QUESTIONMARK Fact was the product of 1 and 2 <sil=0.912> .PERIOD So <sil=0.647> ,COMMA I multiply that with 3 and then I increment the iteration variable <sil=0.913> .PERIOD It becomes 4 <sil=0.910> .PERIOD Again <sil=0.415> ,COMMA I come and check is it less than 10 <sil=0.966> ?QUESTIONMARK Yes <sil=0.482> ,COMMA it is I go on here and I multiply it in that way it goes on and on <sil=0.906> .PERIOD Now <sil=0.414> ,COMMA ultimately <sil=0.620> ,COMMA ultimately it will be like that 5 <sil=0.444> ,COMMA 6 <sil=0.508> ,COMMA 7 <sil=0.545> ,COMMA 8 <sil=0.526> .PERIOD Now <sil=0.329> ,COMMA suppose i is 9 <sil=0.918> .PERIOD So <sil=0.313> ,COMMA I come here <sil=0.922> .PERIOD I multiply fact with 9 <sil=0.498> ,COMMA i plus plus <sil=0.925> .PERIOD So <sil=0.537> ,COMMA I become 10 <sil=0.993> .PERIOD I come here <sil=0.620> .PERIOD I is still less than equal to 10 <sil=0.996> .PERIOD It is equal to 10 <sil=0.965> .PERIOD I come here <sil=0.364> .PERIOD Multiply 10 <sil=0.632> ,COMMA i plus plus <sil=0.921> .PERIOD It becomes 11 <sil=0.925> .PERIOD I come here <sil=0.385> .PERIOD This condition is not satisfied <sil=0.939> .PERIOD I come out <sil=0.929> .PERIOD This is the first statement <sil=0.974> .PERIOD We will look at it in a little more detail in the next class <sil=0.936> .PERIOD So <sil=0.601> ,COMMA in the last lecture we have seen how we can write a program to find out whether it is prime or not <sil=0.990> .PERIOD Now <sil=0.382> ,COMMA this program that you see that we have we are discussed in the last class will certainly give us correct result <sil=0.991> .PERIOD Now <sil=0.546> ,COMMA our job is not only to write a correct program <sil=0.478> ,COMMA it is also very stimulating intellectually to think of how we can make it a more efficient program <sil=0.945> .PERIOD Often the program can be correct <sil=0.594> ,COMMA but it is not very efficient <sil=0.958> .PERIOD What do I mean by this efficiency <sil=0.886> ?QUESTIONMARK See if we look at this program and again I take the earlier example that suppose I have my n is 13 <sil=0.980> .PERIOD Now <sil=0.504> ,COMMA and I start with the value of i to be 2 <sil=0.533> ,COMMA i is 2 and n is 13 <sil=0.978> .PERIOD And since it is prime <sil=0.400> ,COMMA I am checking this condition time and again and since this is third prime number <sil=0.550> ,COMMA how many times it will never come here <sil=0.477> ,COMMA it will never succeed <sil=0.995> .PERIOD So <sil=0.625> ,COMMA I will have to carry on this loop and ultimately when I exhaust all the possibilities <sil=0.464> ,COMMA then only I will come to this point <sil=0.950> .PERIOD So <sil=0.638> ,COMMA how many times do I have to do this <sil=0.981> ?QUESTIONMARK Let us see I am starting with 2 checking once <sil=0.549> ,COMMA then start incrementing and making it 3 <sil=0.319> ,COMMA then 4 <sil=0.434> ,COMMA then testing with 5 <sil=0.377> ,COMMA then testing with 6 <sil=0.304> ,COMMA testing with 7 <sil=0.369> ,COMMA testing with 8 <sil=0.386> ,COMMA testing with 9 <sil=0.531> ,COMMA 10 <sil=0.572> ,COMMA 11 <sil=0.601> ,COMMA 12 <sil=0.537> .PERIOD So <sil=0.480> ,COMMA how many times did I check it <sil=0.894> ?QUESTIONMARK 1 <sil=0.927> ,COMMA 2 <sil=0.531> ,COMMA 3 <sil=0.318> ,COMMA 4 <sil=0.404> ,COMMA 5 <sil=0.499> ,COMMA 6 <sil=0.447> ,COMMA 7 <sil=0.373> ,COMMA 8 <sil=0.434> ,COMMA 9 <sil=0.327> ,COMMA 10 <sil=0.317> ,COMMA 11 times <sil=0.929> .PERIOD I had checked it with 11 times <sil=0.957> .PERIOD Now <sil=0.648> ,COMMA do I really need to check it with 11 times <sil=0.852> ?QUESTIONMARK If you think a little bit <sil=0.346> ,COMMA if this number is n <sil=0.464> ,COMMA then I need not check it and I am starting with 2 <sil=0.912> .PERIOD So <sil=0.629> ,COMMA n minus 2 times I am checking <sil=0.444> ,COMMA do I really need to check n minus 2 times <sil=0.924> ?QUESTIONMARK If I do not find it divisible by square within square root of n times <sil=0.902> .PERIOD So <sil=0.373> ,COMMA square root of 13 as an integer <sil=0.632> ,COMMA what would it be <sil=0.977> ?QUESTIONMARK 13 would be 3 point something <sil=0.910> .PERIOD So <sil=0.485> ,COMMA 4 times within 4 <sil=0.642> ,COMMA if it is not divisible <sil=0.510> ,COMMA it will not be divisible by the future numbers also <sil=0.931> .PERIOD So <sil=0.403> ,COMMA if I just apply <sil=0.303> ,COMMA if I do not find it <sil=0.367> ,COMMA this knowledge that if it is not divisible within square root of n <sil=0.422> ,COMMA then it will not be divisible later <sil=0.915> .PERIOD I can make this program much more efficient <sil=0.919> .PERIOD So <sil=0.533> ,COMMA now <sil=0.538> ,COMMA let us go to another example <sil=0.970> .PERIOD This is again finding the sum of some of the digits of a number <sil=0.923> .PERIOD Now <sil=0.514> ,COMMA this one we did not do <sil=0.315> ,COMMA some of the digits of a number <sil=0.608> ,COMMA what is meant by this <sil=0.945> ?QUESTIONMARK Suppose <sil=0.391> ,COMMA I have got a number 123 <sil=0.434> ,COMMA some of the digits of a number means 1 plus 2 plus 3 6 <sil=0.915> .PERIOD If my number is 243 <sil=0.367> ,COMMA then the sum of the digits will be 2 plus 4 plus 3 6 and 3 9 <sil=0.982> .PERIOD This is what I want to find out <sil=0.951> .PERIOD So <sil=0.497> ,COMMA how do you go about doing that <sil=0.969> ?QUESTIONMARK How do I find out the digits <sil=0.983> ?QUESTIONMARK Say 1 <sil=0.331> ,COMMA 2 <sil=0.573> ,COMMA 3 from there <sil=0.439> ,COMMA how do I extract out 1 <sil=0.353> ,COMMA 2 and 3 <sil=0.423> ?QUESTIONMARK Just think over <sil=0.628> ,COMMA if I have got 1 <sil=0.602> ,COMMA 2 and 3 and I divide it by 10 <sil=0.312> ,COMMA I will get a quotient 12 and the remainder <sil=0.938> .PERIOD So <sil=0.580> ,COMMA the remainder is 1 digit <sil=0.918> .PERIOD Now <sil=0.473> ,COMMA I take the quotient divided by 10 <sil=0.534> ,COMMA I will get a remainder <sil=0.378> ,COMMA I will get a quotient 12 and the remainder <sil=0.926> .PERIOD So <sil=0.388> ,COMMA the remainder is 1 digit <sil=0.960> .PERIOD Now <sil=0.416> ,COMMA I take the quotient divided by 10 <sil=0.342> ,COMMA I will get a remainder <sil=0.604> ,COMMA sorry <sil=0.376> ,COMMA a quotient and a remainder <sil=0.974> .PERIOD The remainder is another digit and then I go on till it is the number is not equal to 0 <sil=0.926> .PERIOD So <sil=0.336> ,COMMA next I take 1 and divided by 10 <sil=0.409> ,COMMA the quotient is 0 and the remainder is another digit <sil=0.981> .PERIOD And then I go on till it is the number is not equal to 0 <sil=0.922> .PERIOD So <sil=0.625> ,COMMA next I take 1 and divide it by 10 <sil=0.549> ,COMMA the quotient is 0 and the remaining there is 1 <sil=0.975> .PERIOD So <sil=0.642> ,COMMA you see I have got all the digits from the right hand side <sil=0.600> ,COMMA one after another <sil=0.370> ,COMMA so I can add them <sil=0.953> .PERIOD That is my basic way <sil=0.986> .PERIOD So <sil=0.649> ,COMMA let us keep it on the side and see what we have done in this program <sil=0.943> .PERIOD I have got a number n <sil=0.987> .PERIOD Now <sil=0.306> ,COMMA this number that has been given initially <sil=0.362> ,COMMA 1 <sil=0.542> ,COMMA 23 <sil=0.901> ,COMMA I do not need to preserve that number <sil=0.980> .PERIOD So <sil=0.422> ,COMMA I can play with that and I have to make a sum of this <sil=0.512> ,COMMA 1 <sil=0.402> ,COMMA 2 and 3 <sil=0.557> .PERIOD So <sil=0.455> ,COMMA I keep a sum to be initially 0 <sil=0.945> .PERIOD I keep a variable sum which is initialized to 0 as we saw in the earlier examples and sum is also an integer <sil=0.973> .PERIOD Then I read the number that is say 1 <sil=0.448> ,COMMA 23 has come <sil=0.905> .PERIOD Now <sil=0.546> ,COMMA while the number n that is 1 <sil=0.546> ,COMMA 23 <sil=0.926> ,COMMA 1 <sil=0.562> ,COMMA 23 is not 0 <sil=0.914> .PERIOD Then I take add n modulus 10 <sil=0.601> ,COMMA n modulus 10 will give me what the remainder 3 and add it to the sum <sil=0.966> .PERIOD So <sil=0.525> ,COMMA my sum now becomes 3 and then I want to find out this thing also <sil=0.942> .PERIOD I make my n to be n divided by 10 <sil=0.924> .PERIOD Now <sil=0.550> ,COMMA this operation gives you the quotient <sil=0.606> ,COMMA this operation gives you the remainder <sil=0.994> .PERIOD So <sil=0.430> ,COMMA now I get n by 10 means now 12 and I go back to this loop <sil=0.905> .PERIOD I check that 12 is not 0 <sil=0.959> .PERIOD So <sil=0.584> ,COMMA I will again do that <sil=0.972> .PERIOD Sum will be sum what was that 3 plus n modulus 10 <sil=0.904> .PERIOD So <sil=0.498> ,COMMA I again divide it by 10 and take the remainder and that remainder is added some plus this <sil=0.957> .PERIOD So <sil=0.600> ,COMMA 3 plus 2 will be 5 and then I divide n by 10 <sil=0.992> .PERIOD So <sil=0.477> ,COMMA now I find out 1 <sil=0.976> .PERIOD Still I go back 1 is not I go back actually here 1 is not 0 <sil=0.982> .PERIOD So <sil=0.363> ,COMMA I again divide it by I take the remainder divided by 10 and take the remainder <sil=0.923> .PERIOD So <sil=0.355> ,COMMA the remainder is 1 <sil=0.322> ,COMMA I add it to the sum <sil=0.998> .PERIOD So <sil=0.324> ,COMMA it will be 6 <sil=0.924> .PERIOD And then I divide I find the quotient and that is 0 <sil=0.929> .PERIOD I go back again here and find that n is not equal to 0 condition is not true <sil=0.940> .PERIOD So <sil=0.645> ,COMMA I come out of the loop and I apply this primitive statement <sil=0.918> .PERIOD What is the primitive statement doing <sil=0.889> ?QUESTIONMARK The sum of digits of the given number I cannot say given number n because n has already changed <sil=0.917> .PERIOD I will come to that in a moment <sil=0.926> .PERIOD Now <sil=0.580> ,COMMA is sum <sil=0.967> .PERIOD So <sil=0.479> ,COMMA I have got the sum <sil=0.918> .PERIOD So <sil=0.488> ,COMMA this is another example of a while loop <sil=0.986> .PERIOD Now <sil=0.577> ,COMMA my question is if I have understood it <sil=0.936> .PERIOD I want the output to come as printf the sum of digits of the number 123 is 6 <sil=0.925> .PERIOD How can I do what modification should I do in this program <sil=0.967> ?QUESTIONMARK What I want to be printed is the sum of digits of 123 is 6 <sil=0.970> .PERIOD What should I modify <sil=0.887> ?QUESTIONMARK Of course <sil=0.480> ,COMMA I should modify this statement <sil=0.985> .PERIOD This statement should be the sum of the digits of the number percentage d is 6 <sil=0.976> .PERIOD d is percentage d and here before sum what should I do <sil=0.989> ?QUESTIONMARK My n that was provided by the user has already been destroyed in this loop <sil=0.996> .PERIOD So <sil=0.328> ,COMMA what because every time I am dividing it by 10 and making a new number 123 is becoming 12 and then it is becoming 1 then it is becoming 0 <sil=0.907> .PERIOD So <sil=0.363> ,COMMA I have to save it somewhere this 123 <sil=0.945> .PERIOD So <sil=0.540> ,COMMA what I can do here <sil=0.962> ?QUESTIONMARK After this reading this I can save it in another variable norm as n and here I will put norm comma <sil=0.948> .PERIOD Now <sil=0.519> ,COMMA because I am destroying n here but I am not touching norm <sil=0.915> .PERIOD So <sil=0.647> ,COMMA norm will remain intact only another thing that I have to do I have to add this norm here <sil=0.912> .PERIOD I must declare it norm as an integer otherwise it will give you syntax error <sil=0.980> .PERIOD So <sil=0.395> ,COMMA this is another nice example of while using which we can find the number of digits the sum of the number of digits of a number <sil=0.920> .PERIOD With that we move to another example decimal to binary conversion <sil=0.945> .PERIOD Some of you may know it and some of you may not be very very conversant with that we know that we have got the binary number system where the base is 2 <sil=0.941> .PERIOD So <sil=0.390> ,COMMA everything is expressed using 0 and 1 <sil=0.990> .PERIOD So <sil=0.422> ,COMMA if I have a binary digit sorry decimal digit 4 its binary equivalent is 1 0 0 <sil=0.952> .PERIOD If we have 5 that is 1 0 1 if it is 1 then it is 0 0 1 or just 1 if it is 2 it is 0 1 0 like that <sil=0.913> .PERIOD The question is that given our decimal digit how can I convert it to binary what is the algorithm <sil=0.995> ?QUESTIONMARK The algorithm is something like this <sil=0.976> .PERIOD Let us take the number 4 and I want to find out what is the binary equivalent of this the algorithm goes like this I first divide it by 2 because 2 is the base of any binary system <sil=0.917> .PERIOD I divide it by 2 so I get the quotient as 2 and remainder as 0 <sil=0.977> .PERIOD Next I divide it again by 2 so my quotient is 1 and remainder is 0 <sil=0.948> .PERIOD Next I divide it again by 2 my quotient is 0 and remainder is 1 <sil=0.974> .PERIOD So <sil=0.419> ,COMMA I go on dividing till I get a quotient to be 0 and I have remembered all the remainder that I got <sil=0.988> .PERIOD Now I can get the binary if I did it in this direction so it is 1 0 0 <sil=0.985> .PERIOD Let us take another example suppose I want to have the number 15 <sil=0.968> .PERIOD Now what is the binary of 15 to understand that let us look at the weights of the different positions in binary this one is with 2 to the power 0 2 to the power 1 2 to the power 2 2 to the power 3 that means this is 8 4 2 1 <sil=0.939> .PERIOD Now 15 if I have to have I must have a 1 here and 7 more so 1 here 8 and 4 12 and 1 here 12 13 14 and 15 all this should be 1 <sil=0.941> .PERIOD So can we find out find this out let us see 15 I divide by 2 my quotient is 7 and remainder is 1 <sil=0.923> .PERIOD I again divided by 2 my quotient is 3 and remainder is 1 <sil=0.940> .PERIOD I divide it by 2 again my quotient is 1 <sil=0.348> ,COMMA remainder is 1 <sil=0.926> .PERIOD I divide it by 2 again my quotient is 0 and the remainder is 1 <sil=0.936> .PERIOD I did it in this direction and we get 1111 <sil=0.991> .PERIOD Let us take another example again the weights of this system are 1 2 4 8 2 to the power 0 2 to the power 1 2 to the power 3 2 to the power 2 2 to the power 3 <sil=0.972> .PERIOD 1 will be 16 is 2 to the power 4 <sil=0.990> .PERIOD Now let us take a number 23 what will be the binary representation of that let us see here 16 will be there of course it is higher greater than 16 <sil=0.972> .PERIOD So 23 16 and 6 and 7 more so this should be 0 I cannot put a 1 here because that be 16 and 8 will be 24 <sil=0.967> .PERIOD So 1 here 20 this this so my binary is 1 0 1 1 1 <sil=0.973> .PERIOD Let us try in our algorithm divided by 2 my quotient is 11 I have got a remainder 1 I divide by 2 my quotient is 5 <sil=0.402> ,COMMA remainder is 1 <sil=0.983> ,COMMA I divide by 2 <sil=0.534> ,COMMA quotient is 2 <sil=0.516> ,COMMA remainder is 1 <sil=0.913> ,COMMA divided by 2 <sil=0.487> ,COMMA it is 1 and 0 <sil=0.901> .PERIOD And 0 and divided by 2 is 0 and 1 <sil=0.922> .PERIOD So I reach a 0 I stop and this is the pattern 1 0 1 1 1 1 1 0 1 1 1 <sil=0.984> .PERIOD Now let us see how this algorithm that we are talking of can be encoded in C program you see here <sil=0.997> .PERIOD I have declared one variable as dash that means the decimal number that I will be reading <sil=0.967> .PERIOD So I am reading that number here <sil=0.955> .PERIOD Now in the earlier example we did it while do now here we will that is also very interesting and known to us that is finding the greatest common divisor of 2 numbers <sil=0.927> .PERIOD What is the algorithm <sil=0.925> ?QUESTIONMARK The algorithm is shown here <sil=0.945> .PERIOD Suppose I have got a number 45 and 12 I am to find out the greatest common divisor or the 8 shape of these 2 numbers <sil=0.941> .PERIOD What I do is I divide the bigger number with the smaller number and get a remainder <sil=0.989> .PERIOD You see the remainder are becoming so important we come to the remainder <sil=0.910> .PERIOD And then if the remainder is not 0 I divide now the smaller number this one with the remainder and then I get again a remainder which is non 0 <sil=0.962> .PERIOD Then I take the divisor current divisor and divided by this until we get 0 that is what we used to do in school <sil=0.946> .PERIOD So ultimately when I get 0 whatever is the divisor currently current divisor that is our 8 shape or GCD <sil=0.964> .PERIOD Here you see how the code is written <sil=0.999> .PERIOD Let us look at the code a little bit and try to understand it <sil=0.990> .PERIOD A and B are 2 numbers <sil=0.922> .PERIOD Now I do not know as yet which one is smaller and which one is bigger <sil=0.931> .PERIOD Here in our example we can see 1 is 12 <sil=0.460> ,COMMA 1 is 45 but 1 is 12 <sil=0.362> ,COMMA 1 is 45 but I am going to try this <sil=0.996> .PERIOD Here the computer does not know which one is 12 which one is 45 and I am taking another variable temp <sil=0.940> .PERIOD I am reading the numbers a and b <sil=0.993> .PERIOD Now if a is greater than b that means I am taking the greater number and moving that in temp <sil=0.965> .PERIOD Out of this 1245 which one is greater than 45 so temp becomes 45 and b becomes a <sil=0.980> .PERIOD B is the smaller number so 12 becomes a and b becomes temp <sil=0.931> .PERIOD Now you see I have written this 3 in one short so let us see here what is happening after this <sil=0.943> .PERIOD First temp is 45 <sil=0.397> ,COMMA a is 12 and b is 45 <sil=0.901> .PERIOD Now what I am doing here I am keeping this temp <sil=0.649> ,COMMA what I am doing here I am dividing b by a <sil=0.947> .PERIOD So 45 is being divided by a 12 and I am checking the remainder <sil=0.949> .PERIOD The remainder is not 0 you can see that <sil=0.919> .PERIOD Since it is not 0 I am taking temp to be the modulus of 12 sorry b was 45 <sil=0.984> .PERIOD So here b was 45 and a was 12 by this point <sil=0.926> .PERIOD So then and temp was 45 I try this it is not 0 <sil=0.957> .PERIOD So then I take this remainder 9 and again make that to be b <sil=0.963> .PERIOD So now b becomes 9 and a becomes the temp which was this number <sil=0.964> .PERIOD And I go on dividing this and I go on carrying out this loop what till this becomes 0 <sil=0.975> .PERIOD As soon as this becomes 0 then I have got my gcd stored in a because every time I am taking the a in a I am storing the temp <sil=0.992> .PERIOD And what is temp temp is after I divide I get the remainder and that I am storing in temp and that temp is coming in a is being stored in a and that is also copied in b <sil=0.958> .PERIOD But in the next loop that is being divided by so here you are having 3 9 and here 3 <sil=0.928> .PERIOD So look at this iteration 1 here looking at this picture first temp will become 9 b is 12 and a is 9 <sil=0.997> .PERIOD Next time temp is becoming 3 b is 9 this 9 and a is becoming temp and whenever I find that b divided by a this part is 0 <sil=0.572> ,COMMA remainder is 0 then that is my gcd a is my gcd I get the 3 <sil=0.914> .PERIOD This is another very interesting example of computing using this while loop and repeatedly I am doing this till I find the remainder to be 0 <sil=0.918> .PERIOD So there are many such nice examples and will give you some more during for assignments which you will have to solve and get more confidence about it <sil=0.947> .PERIOD So next we will look we will come to some of the pitfalls of loop and then move to something more useful something very useful that is the concept of arrays <sil=0.908> .PERIOD So <sil=0.362> ,COMMA you were discussing about the bubble sort algorithm and the approach as was discussed in the last class was that every element <sil=0.523> ,COMMA every iteration pushes the heavier element at the bottom and that is what we had and the lighter elements therefore <sil=0.532> ,COMMA goes up <sil=0.984> .PERIOD So <sil=0.460> ,COMMA we had shown an example a couple of examples by which we can show that the heavier elements go down and the other lighter elements go up for a we had given a number of examples to that effect <sil=0.974> .PERIOD So <sil=0.622> ,COMMA if there be 50 here I do not know this visible let me write it here 50 here and 6 here then and say 12 here and 7 here then what will happen is 50 will be swapped with 6 because 50 is heavier than 6 or larger than 6 <sil=0.964> .PERIOD So <sil=0.493> ,COMMA first it will be 6 and 50 and then 50 will be compared with 12 again they will be a swap <sil=0.995> .PERIOD So <sil=0.626> ,COMMA there will be 12 50 50 will be compared with 7 so <sil=0.342> ,COMMA it will be 750 in that way ultimately the 50 if it is the heaviest will come at the bottom <sil=0.920> .PERIOD So <sil=0.369> ,COMMA we swap only if the element at the top is heavier <sil=0.945> .PERIOD Thereby the heaviest element is coming to the top and the others which are less than this I mean less than this heaviest element will be going at the top the bottom moves upward <sil=0.913> .PERIOD Now <sil=0.346> ,COMMA we are going to write the algorithm for this or the program for this <sil=0.933> .PERIOD Now <sil=0.354> ,COMMA before writing the program we need to understand a very interesting and fundamental concept of C programming that is pointers will not formally introduce pointers here <sil=0.300> ,COMMA but we will be talking about pointers in a different way in the context of this bubble sort <sil=0.968> .PERIOD Now <sil=0.306> ,COMMA what is a pointer <sil=0.883> ?QUESTIONMARK Pointer is something that points right <sil=0.953> .PERIOD Now <sil=0.508> ,COMMA suppose there is a variable here <sil=0.916> .PERIOD Suppose the variable is named V and till now we have seen that we can write declare the variable as int V <sil=0.936> .PERIOD Now <sil=0.569> ,COMMA suppose I do not so <sil=0.618> ,COMMA V has got a particular address maybe that address is 1000 <sil=0.997> .PERIOD 1000 is the address of V <sil=0.937> .PERIOD Now <sil=0.304> ,COMMA if instead so <sil=0.582> ,COMMA if I say int V equals 50 that means in the address 1000 50 is written <sil=0.447> ,COMMA but now suppose we have got this address V and which is an integer <sil=0.398> ,COMMA but I am not declaring V as such <sil=0.602> ,COMMA but there is another variable P which will always point to some integers <sil=0.946> .PERIOD So <sil=0.518> ,COMMA P will point to this V right P is pointing to this V <sil=0.924> .PERIOD In that case <sil=0.542> ,COMMA I can say P is a pointer to V <sil=0.923> .PERIOD Now <sil=0.317> ,COMMA so therefore <sil=0.383> ,COMMA what did I say <sil=0.964> ?QUESTIONMARK I said that V is stored in the location 1000 <sil=0.983> .PERIOD Now <sil=0.394> ,COMMA pointer P this variable P therefore <sil=0.416> ,COMMA stores the value 1000 <sil=0.954> .PERIOD Now <sil=0.516> ,COMMA this V is of type integer <sil=0.961> .PERIOD So <sil=0.594> ,COMMA V is of type integer <sil=0.983> .PERIOD So <sil=0.586> ,COMMA P is a pointer to an integer V <sil=0.917> .PERIOD That we know because V I have earlier said that V is an integer <sil=0.584> ,COMMA but say so <sil=0.410> ,COMMA I can I can variable say int V <sil=0.595> ,COMMA but what is the type of P <sil=1.000> ?QUESTIONMARK P is a pointer to V which is an integer <sil=0.913> .PERIOD So <sil=0.614> ,COMMA we write that as int star P <sil=0.348> ,COMMA what does it mean <sil=0.891> ?QUESTIONMARK It means that P is a is a pointer to an integer <sil=0.945> .PERIOD If I write it <sil=0.420> ,COMMA it is not concerned with V only <sil=0.963> .PERIOD It says that P is a pointer to an integer <sil=0.970> .PERIOD So <sil=0.493> ,COMMA what is the value of P now <sil=0.905> ?QUESTIONMARK Value of P is 1000 <sil=0.983> .PERIOD We need to say and what is the address of P <sil=0.996> ?QUESTIONMARK The address of P now this <sil=0.489> ,COMMA where is this P <sil=0.971> ?QUESTIONMARK This is in location 1000 and where is this <sil=0.897> ?QUESTIONMARK This might be in location 2000 <sil=0.992> .PERIOD Therefore <sil=0.352> ,COMMA what is the address of P <sil=0.967> ?QUESTIONMARK And of P is 2000 <sil=0.968> .PERIOD We know that this and operator gives us the address <sil=0.953> .PERIOD We have encountered this during scan F when we are discussing about scan F <sil=0.999> .PERIOD So <sil=0.313> ,COMMA let us have this diagram <sil=0.951> .PERIOD To understand the concept of pointer <sil=0.629> ,COMMA suppose there are different things written in different pages of the book <sil=0.923> .PERIOD This is one page <sil=0.539> ,COMMA this is another page <sil=0.522> ,COMMA this is another page and this is another page <sil=0.959> .PERIOD Each of these pages have got a page number <sil=0.991> .PERIOD Now <sil=0.328> ,COMMA what I have <sil=0.907> ?QUESTIONMARK I have got a table where suppose this has got some content A <sil=0.938> .PERIOD This has got some other story B <sil=0.965> .PERIOD This has got some other story C <sil=0.946> .PERIOD This has got some other story D <sil=0.991> .PERIOD Therefore <sil=0.584> ,COMMA the content of each of these pages are the stories A <sil=0.525> ,COMMA B <sil=0.484> ,COMMA C or B <sil=0.973> .PERIOD But which page I am looking at <sil=0.951> ?QUESTIONMARK Suppose <sil=0.350> ,COMMA here is a page number table table of page numbers <sil=0.951> .PERIOD So <sil=0.533> ,COMMA I have got there are four pages <sil=0.992> .PERIOD So <sil=0.364> ,COMMA the pages are 1 <sil=0.589> ,COMMA 2 <sil=0.634> ,COMMA 3 <sil=0.527> ,COMMA 4 <sil=0.510> .PERIOD Now <sil=0.334> ,COMMA suppose I want to <sil=0.431> ,COMMA I just want to come to this page number <sil=0.997> .PERIOD So <sil=0.576> ,COMMA this page number does not tell me <sil=0.338> ,COMMA what story is there <sil=0.910> ?QUESTIONMARK But this page number tells me that I have to go to this page <sil=0.987> .PERIOD This entry is telling me <sil=0.451> ,COMMA this particular page number is telling me that I have to go to this page <sil=0.970> .PERIOD This is telling me that I have to go to this page and this is telling me that I have to go to this page <sil=0.956> .PERIOD So <sil=0.389> ,COMMA what are these <sil=0.855> ?QUESTIONMARK What are these <sil=0.988> ?QUESTIONMARK What are these <sil=0.956> ?QUESTIONMARK What are these <sil=0.979> ?QUESTIONMARK These are nothing but pointers to pages and what is a <sil=0.873> ?QUESTIONMARK A is a content of the page <sil=0.947> .PERIOD So <sil=0.354> ,COMMA a or C or D is a is content of page 4 <sil=0.922> .PERIOD And these are pointers to the pages that means <sil=0.635> ,COMMA if I want to go to page 4 <sil=0.455> ,COMMA where should I go <sil=0.856> ?QUESTIONMARK Because this page may be located at some other table <sil=0.446> ,COMMA maybe <sil=0.999> .PERIOD Suppose <sil=0.410> ,COMMA these pages of a book are torn out and have been kept on different tables <sil=0.913> .PERIOD So <sil=0.463> ,COMMA page number 1 is giving me the table address <sil=0.939> .PERIOD So <sil=0.581> ,COMMA that it is on this particular table <sil=0.973> .PERIOD So <sil=0.577> ,COMMA it can be on table T 1 <sil=0.570> ,COMMA this can be on table T 2 <sil=0.987> .PERIOD Maybe <sil=0.643> ,COMMA the third page is on table <sil=0.611> ,COMMA the third page is on table T 4 and this is on table T 5 <sil=1.000> .PERIOD It's possible <sil=0.985> .PERIOD So <sil=0.565> ,COMMA the first table <sil=0.642> ,COMMA I have to if I want to read the first page <sil=0.517> ,COMMA I have to go <sil=0.978> .PERIOD I will come here <sil=0.574> ,COMMA the first entry <sil=0.960> .PERIOD This is a pointing to table T 1 <sil=0.938> .PERIOD So <sil=0.461> ,COMMA and I go to table T 1 and find this particular page and read the content of that <sil=0.930> .PERIOD So <sil=0.319> ,COMMA these are pointers to pages <sil=0.972> .PERIOD But these pointers also have to be in some memory location <sil=0.930> .PERIOD Let me draw the diagram in a different way now <sil=0.937> .PERIOD Suppose <sil=0.471> ,COMMA this is my memory and I have got 4 variables <sil=0.906> .PERIOD Suppose <sil=0.600> ,COMMA I have got 4 integer variables and each integer variable takes 2 bytes <sil=0.919> .PERIOD I am showing 2 bytes here <sil=0.528> ,COMMA one of another <sil=0.909> .PERIOD This is the variable V 1 <sil=0.975> .PERIOD This is the variable V 2 <sil=0.924> .PERIOD This is the variable V 3 and this is the variable V 4 <sil=0.980> .PERIOD Similarly <sil=0.377> ,COMMA let me just change the color <sil=0.944> .PERIOD So <sil=0.341> ,COMMA these are suppose in locations <sil=0.949> .PERIOD Sorry <sil=0.338> ,COMMA let this be in locations <sil=0.947> .PERIOD V 1 is in location 1000 <sil=0.644> ,COMMA assuming that an integer takes 2 bytes <sil=0.983> .PERIOD This one is in location 1000 <sil=0.501> ,COMMA 2 <sil=0.411> .PERIOD This one is in location 1000 <sil=0.385> ,COMMA 4000 <sil=0.393> ,COMMA 2000 <sil=0.492> ,COMMA 2004 and this is in location 1000 <sil=0.593> ,COMMA 2006 <sil=0.907> .PERIOD And let me extend my table a bit <sil=0.993> .PERIOD Now <sil=0.381> ,COMMA suppose I have got here <sil=0.617> ,COMMA again 4 integers <sil=0.983> .PERIOD This is <sil=0.515> ,COMMA this is <sil=0.629> ,COMMA so this is <sil=0.553> ,COMMA sorry <sil=0.301> .PERIOD I will say mixed up a little bit <sil=0.989> .PERIOD I want to come to this <sil=0.998> .PERIOD So <sil=0.529> ,COMMA here I have got P 1 is a pointer variable with again since it is an integer <sil=0.929> .PERIOD Let me say P 2 <sil=0.579> ,COMMA P 3 and P 4 <sil=1.000> .PERIOD If they are integer pointers <sil=0.596> ,COMMA I am not bothering about that <sil=0.991> .PERIOD I am not bothering about how many locations it is taking <sil=0.905> .PERIOD Now <sil=0.567> ,COMMA this P 1 is actually <sil=0.614> ,COMMA I am not bothering about this division here <sil=0.315> ,COMMA 2 bytes <sil=0.962> .PERIOD I am just showing those 2 bytes together <sil=0.901> .PERIOD That will be easier for me to write <sil=0.960> .PERIOD All right <sil=0.908> .PERIOD So <sil=0.440> ,COMMA here the P 1 is storing the value 1000 <sil=0.982> .PERIOD Why <sil=0.973> ?QUESTIONMARK P 1 is a pointer to this variable <sil=0.913> .PERIOD So <sil=0.416> ,COMMA this P 1 tells me not the value of V 1 <sil=0.600> ,COMMA but it tells me where is V 1 located <sil=0.972> .PERIOD So <sil=0.509> ,COMMA 1000 is a position where V 1 is located <sil=0.934> .PERIOD So <sil=0.564> ,COMMA P 1 is storing that pointer <sil=0.944> .PERIOD And P 2 is say <sil=0.301> ,COMMA 1000 to P 3 is 1000 to P 4 and P 4 is 1000 to P 6 <sil=0.909> .PERIOD Now <sil=0.392> ,COMMA these locations also have got address <sil=0.987> .PERIOD Suppose <sil=0.561> ,COMMA these addresses are 5000 <sil=0.487> ,COMMA 5000 to 5000 <sil=0.410> ,COMMA 4 and 5000 to 6 <sil=0.911> .PERIOD This is 5000 to 6 <sil=0.903> .PERIOD So <sil=0.532> ,COMMA please try to understand <sil=0.954> .PERIOD When I say P 1 <sil=0.616> ,COMMA what is P 1 <sil=0.853> ?QUESTIONMARK P 1 is a pointer to an integer <sil=0.958> .PERIOD So <sil=0.305> ,COMMA int star P 1 <sil=0.990> .PERIOD That means <sil=0.633> ,COMMA that P 1 is an integer <sil=0.986> .PERIOD And P 1 is an integer <sil=0.522> ,COMMA sorry <sil=0.322> ,COMMA P 1 is a pointer to an integer variable <sil=0.950> .PERIOD It could be a floating point variable also <sil=0.988> .PERIOD Had it been a floating point number <sil=0.509> ,COMMA then suppose this V 1 <sil=0.360> ,COMMA V 2 <sil=0.338> ,COMMA V 3 <sil=0.303> ,COMMA V 4 <sil=0.456> ,COMMA I am just for the sake of <sil=0.458> ,COMMA I am just for the sake of clarity <sil=0.949> .PERIOD I am just not bothered about how many locations variable is taking <sil=0.913> .PERIOD I am just seriously this <sil=0.922> .PERIOD Whatever it requires depending on the machine that is taken <sil=0.955> .PERIOD Now <sil=0.549> ,COMMA suppose each of them is a float <sil=0.980> .PERIOD So <sil=0.618> ,COMMA float V 1 <sil=0.999> .PERIOD So <sil=0.323> ,COMMA V 1 is a floating point number <sil=0.937> .PERIOD Right <sil=0.932> ?QUESTIONMARK V 1 is a floating point number <sil=0.954> .PERIOD So <sil=0.473> ,COMMA then and if P 1 points to V 1 <sil=0.430> ,COMMA then I should write float star P 1 <sil=0.925> .PERIOD That means <sil=0.311> ,COMMA P 1 is pointing to a floating point number <sil=0.915> .PERIOD So <sil=0.318> ,COMMA since it is a floating point number <sil=0.343> ,COMMA if so <sil=0.443> ,COMMA if I say now and P 1 <sil=0.559> ,COMMA what will I get <sil=0.904> ?QUESTIONMARK What is the address of P 1 <sil=0.994> ?QUESTIONMARK If I try to get this not an assignment <sil=0.639> ,COMMA what what is and P 1 <sil=0.918> ?QUESTIONMARK What is the address of P 1 <sil=0.914> ?QUESTIONMARK Address of P 1 is 5000 <sil=0.905> .PERIOD And what is star P 1 <sil=0.947> ?QUESTIONMARK What is the meaning of this <sil=0.949> ?QUESTIONMARK Please do not be confused <sil=0.916> .PERIOD This star and this star has got two different meanings <sil=0.987> .PERIOD This star means it is just saying that P 1 is a pointer to pointer to what type of variable <sil=0.888> ?QUESTIONMARK Pointer to a floating point type of variable <sil=0.954> .PERIOD So <sil=0.610> ,COMMA for V 1 <sil=0.348> ,COMMA I am just writing float V 1 <sil=0.942> .PERIOD So <sil=0.322> ,COMMA that means that V 1 is purely a floating point number not a pointer <sil=0.927> .PERIOD But when I say float star P 1 <sil=0.417> ,COMMA then P 1 is a pointer to some floating point number <sil=0.921> .PERIOD Now <sil=0.558> ,COMMA if I just what is star P 1 in this case <sil=0.853> ?QUESTIONMARK What is the content of P 1 <sil=0.916> ?QUESTIONMARK Content of P 1 <sil=0.981> ?QUESTIONMARK Content of P 1 is 1000 <sil=0.917> .PERIOD All right <sil=0.953> ?QUESTIONMARK Content of P 1 is 1000 <sil=0.975> .PERIOD So <sil=0.346> ,COMMA let me just repeat it once again <sil=0.992> .PERIOD So <sil=0.602> ,COMMA we have seen in declaration something like int star P 1 int V 1 <sil=0.979> .PERIOD All right <sil=0.928> ?QUESTIONMARK Now <sil=0.493> ,COMMA that means P 1 is a pointer <sil=0.955> .PERIOD P 1 is a pointer <sil=0.944> .PERIOD Suppose located at location 5000 and P 1 is a pointer to a variable V 1 <sil=0.382> ,COMMA which is also an integer <sil=0.984> .PERIOD V 1 located at location 1000 <sil=0.978> .PERIOD All right <sil=0.962> ?QUESTIONMARK These two lines are just meaning these two things <sil=0.519> ,COMMA these two pictures <sil=0.946> .PERIOD This 5000 or 1000 <sil=0.330> ,COMMA this part is not known to us because that is known by the compiler not by us <sil=0.980> .PERIOD But logically to us <sil=0.315> ,COMMA this is the picture <sil=0.901> .PERIOD Leave us out leave us at this 5000 and 1000 <sil=0.963> .PERIOD Only these two parts are declared by this <sil=0.941> .PERIOD Now <sil=0.326> ,COMMA if I say star P 1 <sil=0.345> ,COMMA that means the content of P 1 <sil=0.418> ,COMMA what is the content of P 1 <sil=0.872> ?QUESTIONMARK Whatever is the content of P 1 <sil=0.948> ?QUESTIONMARK Now <sil=0.388> ,COMMA if I make P 1 to point to V 1 <sil=0.380> ,COMMA in that case <sil=0.591> ,COMMA if I make P 1 point to V 1 <sil=0.965> .PERIOD So <sil=0.335> ,COMMA what will that be <sil=0.994> ?QUESTIONMARK Content of P 1 should be assigned to end of V 1 <sil=0.974> .PERIOD End of V 1 will give me the address of this and the content of P 1 will get that <sil=0.921> .PERIOD So <sil=0.550> ,COMMA therefore <sil=0.320> ,COMMA this 1000 will be written over here <sil=0.928> .PERIOD That means <sil=0.399> ,COMMA this pointer is pointing to this V 1 <sil=0.972> .PERIOD I will not go into further details of this right now <sil=0.980> .PERIOD We will come to this as and when the context comes later <sil=0.953> .PERIOD Right now <sil=0.613> ,COMMA with this in mind <sil=0.648> ,COMMA let us go back to the algorithm of bubble sort <sil=0.936> .PERIOD What is being done in the algorithm of bubble sort <sil=0.965> ?QUESTIONMARK Let us try to understand each of the functions <sil=0.979> .PERIOD First thing is <sil=0.573> ,COMMA we have got the standard declaration <sil=0.581> ,COMMA fine no issue <sil=0.955> .PERIOD Now <sil=0.522> ,COMMA first let us start with this function void bubble sort <sil=0.978> .PERIOD Bubble sort is void because it is not returning any value any value <sil=0.994> .PERIOD It is just sorting some array <sil=0.947> .PERIOD What array <sil=0.895> ?QUESTIONMARK X array and the size of the array is n <sil=0.909> .PERIOD In Taij <sil=0.374> ,COMMA they are two local variables because they are usually used as indexes of these two loops <sil=0.924> .PERIOD In this loop <sil=0.608> ,COMMA what is happening <sil=0.931> ?QUESTIONMARK For i assigned n minus 1 to 0 i minus minus that means what <sil=0.986> ?QUESTIONMARK That means <sil=0.498> ,COMMA if I have an array here <sil=0.467> ,COMMA this is my array <sil=0.366> ,COMMA I have got i pointing here because that is the size of the array minus 1 <sil=0.968> .PERIOD So <sil=0.349> ,COMMA i is pointing here and it will go up to 0 <sil=0.973> .PERIOD So <sil=0.471> ,COMMA gradually it will go in this direction up <sil=0.944> .PERIOD That is what the first for loop is saying <sil=0.935> .PERIOD First for loop is saying that i is starting from the bottom and going up to 0 as long as it is greater than 0 <sil=0.990> .PERIOD And then for j equal to 0 <sil=0.462> ,COMMA j minus j equal to 0 to j less than i j plus plus <sil=0.919> .PERIOD If x j is greater than x j plus 1 <sil=0.388> ,COMMA that means what <sil=0.990> ?QUESTIONMARK If x j is greater than x j plus 1 <sil=0.998> .PERIOD So <sil=0.404> ,COMMA let us again go back to this <sil=0.908> .PERIOD j is starting from 0 and I am comparing this value 50 with the value 2 with j plus 1 <sil=0.986> .PERIOD This is j plus 1 <sil=0.995> .PERIOD If x j is greater than x j plus 1 <sil=0.351> ,COMMA what would I do <sil=0.956> ?QUESTIONMARK I will swap <sil=0.942> .PERIOD Let us go to here <sil=0.993> .PERIOD If x j is greater than x j plus 1 <sil=0.620> ,COMMA I am swapping x j and x j plus 1 <sil=0.966> .PERIOD I will come to the swap function later <sil=0.928> .PERIOD I am assuming that the swap is working correctly <sil=0.985> .PERIOD That means it is swapping them <sil=0.932> .PERIOD So <sil=0.545> ,COMMA what is happening <sil=0.998> ?QUESTIONMARK So <sil=0.315> ,COMMA this loop will go on j equal to 0 <sil=0.521> ,COMMA then j will be 1 and that way it will go on <sil=0.920> .PERIOD So <sil=0.340> ,COMMA let us see <sil=0.562> .PERIOD Again <sil=0.554> .PERIOD So <sil=0.554> ,COMMA next when I swap it <sil=0.576> ,COMMA it becomes 2 and 50 <sil=0.986> .PERIOD Now <sil=0.318> ,COMMA I have got other values <sil=0.985> .PERIOD Now <sil=0.429> ,COMMA j is being incremented <sil=0.961> .PERIOD So <sil=0.535> ,COMMA now this is becoming j and this is becoming j plus 1 <sil=0.905> .PERIOD In that way <sil=0.483> ,COMMA this swapping will be done <sil=0.996> .PERIOD Suppose <sil=0.467> ,COMMA this is 70 <sil=0.940> .PERIOD So <sil=0.370> ,COMMA there will be no swap <sil=0.953> .PERIOD So <sil=0.420> ,COMMA let us see here <sil=0.612> .PERIOD If this condition does not hold <sil=0.643> ,COMMA swap is not taking place <sil=0.999> .PERIOD I am going back to this loop <sil=0.979> .PERIOD So <sil=0.567> ,COMMA now 70 remains here <sil=0.969> .PERIOD And then suppose the next one <sil=0.949> .PERIOD So <sil=0.645> ,COMMA now j changes and j plus 1 is pointing here <sil=0.972> .PERIOD Now <sil=0.347> ,COMMA there will be a swap here <sil=0.964> .PERIOD So <sil=0.531> ,COMMA this is 12 <sil=0.927> .PERIOD Say <sil=0.516> ,COMMA 12 and 70 will be swapped <sil=0.944> .PERIOD So <sil=0.355> ,COMMA 250 <sil=0.563> ,COMMA 12 <sil=0.597> ,COMMA 70 <sil=0.353> .PERIOD In this way <sil=0.359> ,COMMA I will go on up to this point <sil=0.942> .PERIOD And next <sil=0.901> .PERIOD So <sil=0.409> ,COMMA ultimately in this iteration <sil=0.463> ,COMMA ultimately I will have this heaviest element <sil=0.924> .PERIOD So <sil=0.316> ,COMMA 70 is the heaviest element coming over here <sil=0.900> .PERIOD Then I will be decremented and I will come here <sil=0.943> .PERIOD And then for this zone again <sil=0.575> ,COMMA I will do the same thing as I did till now <sil=0.946> .PERIOD Exactly that is being done here <sil=0.995> .PERIOD So <sil=0.538> ,COMMA I will be doing this and then I will increment <sil=0.534> ,COMMA I will decrement n a little bit and I will go on doing this <sil=0.908> .PERIOD I will be then looping doing the same loop again for one level less <sil=0.979> .PERIOD I mean <sil=0.376> ,COMMA the last element is already having the heaviest element <sil=0.961> .PERIOD So <sil=0.365> ,COMMA I will do it among the remaining part <sil=0.952> .PERIOD So <sil=0.517> ,COMMA this part <sil=0.976> ,COMMA this part is already covered <sil=0.993> .PERIOD So <sil=0.328> ,COMMA I have decremented it <sil=0.962> .PERIOD So <sil=0.351> ,COMMA I will be now playing in this zone <sil=0.980> .PERIOD And once that is done <sil=0.456> ,COMMA this part will also be covered <sil=0.922> .PERIOD I will be playing in this zone <sil=0.964> .PERIOD I will be playing in this zone <sil=0.960> .PERIOD And in every zone <sil=0.462> ,COMMA so once every time I am deciding on the zone <sil=0.570> ,COMMA n <sil=0.512> ,COMMA n minus 1 <sil=0.403> ,COMMA n minus 2 like that it is going on <sil=0.923> .PERIOD And every time I am doing this loop for each of the pair wise element comparison and thereby I am pushing the heaviest element at the bottom <sil=0.923> .PERIOD That is the code for bubble shot <sil=0.942> .PERIOD However <sil=0.635> ,COMMA this swap keeps <sil=0.479> ,COMMA I have not yet explained this swap <sil=0.930> .PERIOD Earlier we have seen that if we do swap in any arbitrary way <sil=0.321> ,COMMA for example <sil=0.400> ,COMMA if I want to swap two variables <sil=0.640> ,COMMA say I write swap in T in B <sil=0.994> .PERIOD Let me do it here <sil=0.990> .PERIOD Let me do it here <sil=0.970> .PERIOD If I do it like this in T <sil=0.621> ,COMMA sorry <sil=0.387> .PERIOD If I just do swap in T in B and inside <sil=0.436> ,COMMA I use another variable temp <sil=0.941> .PERIOD Then temp gets A <sil=0.393> ,COMMA I sorry <sil=0.596> ,COMMA B gets A and A gets sorry <sil=0.315> ,COMMA sorry sorry sorry <sil=0.915> .PERIOD A is stored here <sil=0.578> ,COMMA A gets B and then temp has been remembered there <sil=0.909> .PERIOD So <sil=0.330> ,COMMA B gets temp <sil=0.996> .PERIOD And so this was my function return <sil=0.933> .PERIOD So <sil=0.529> ,COMMA here suppose A was when it came <sil=0.400> ,COMMA it was called with x and y <sil=0.954> .PERIOD So <sil=0.485> ,COMMA main program called swap with x and y and x was 5 <sil=0.453> ,COMMA y was 7 <sil=0.918> .PERIOD So <sil=0.441> ,COMMA x was a location here <sil=0.304> ,COMMA 5 and y was a location 7 <sil=0.947> .PERIOD Now <sil=0.494> ,COMMA when it came here <sil=0.623> ,COMMA A was a local location and I know that the functions are called by value <sil=0.936> .PERIOD So <sil=0.589> ,COMMA 5 was copied in A and 7 was copied in B <sil=0.943> .PERIOD 7 was copied in B and then by this temp became 5 <sil=0.547> ,COMMA B became 5 and A became <sil=0.562> ,COMMA very 7 <sil=0.907> .PERIOD B was stored in A <sil=0.582> ,COMMA sorry <sil=0.443> ,COMMA this was stored in this <sil=0.508> ,COMMA this became 7 and this became 5 <sil=0.902> .PERIOD That is how it was done <sil=0.953> .PERIOD So <sil=0.336> ,COMMA 7 <sil=0.603> ,COMMA A was 5 <sil=0.945> .PERIOD So <sil=0.639> ,COMMA temp was 5 <sil=0.593> ,COMMA 7 went over here to A and here 5 was copied again here <sil=0.961> .PERIOD This was fine <sil=0.993> .PERIOD So <sil=0.450> ,COMMA the swapping was done by A by B and then when I returned <sil=0.402> ,COMMA no changes reflected in x and y <sil=0.957> .PERIOD That was the problem <sil=0.971> .PERIOD So <sil=0.611> ,COMMA we will now see how the swap function can be implemented <sil=0.905> .PERIOD But and again another point is <sil=0.379> ,COMMA here I have just done returned <sil=0.922> .PERIOD I and a function can return only one value <sil=0.910> .PERIOD I could not return A and B to the main function <sil=0.914> .PERIOD So <sil=0.630> ,COMMA how can the thing be managed <sil=0.913> ?QUESTIONMARK So <sil=0.523> ,COMMA that after the swapping <sil=0.635> ,COMMA the result is reflected back in the main function <sil=0.902> .PERIOD We will see that in the next lecture <sil=0.904> .PERIOD We are looking at a new construct for building up loops in C language and that construct is a four construct <sil=0.915> .PERIOD So <sil=0.575> ,COMMA let me first write a simple program again the same program that we are writing for reading for finding the sum of 10 numbers <sil=0.950> .PERIOD So <sil=0.420> ,COMMA just I am writing and you try to follow what the meaning of this program is then we will go and further explain it <sil=0.931> .PERIOD My intention is to read n numbers and find the sum the simple thing how can I write that <sil=0.996> .PERIOD So <sil=0.350> ,COMMA I put a variable again sum is 0 and I have read some value n whatever that value is suppose say n equals 5 user has provided me or I can initialize it to 5 <sil=0.958> .PERIOD So <sil=0.473> ,COMMA 5 numbers I will read and add <sil=0.938> .PERIOD Now <sil=0.479> ,COMMA I write for I what is this I I is a control variable or we also call it as very common name of this is an index variable index variable it need not be I it can be anything but an integer variable <sil=0.950> .PERIOD So <sil=0.408> ,COMMA that has to be declared at the beginning <sil=0.954> .PERIOD So <sil=0.393> ,COMMA so I can I can declare let me start with normal declarations int <sil=0.921> .PERIOD So <sil=0.581> ,COMMA some program has started main int sum i and the number that I will read I will see if I need any other variables later and also n sorry and also n and here I do sum 0 n equals to 5 <sil=0.922> .PERIOD Now <sil=0.361> ,COMMA this thing I could have read from the user could have taken from the user the value how could I take it from the user by doing a scan f scan f print f please enter the number of numbers you want to add then scan f percentage d amperes and n in that way I could read this <sil=0.986> .PERIOD But here for the sake of saving time I am just initializing it n is 5 <sil=0.933> .PERIOD Now <sil=0.442> ,COMMA where I do for I this I equals 1 semicolon so <sil=0.554> ,COMMA this 1 complete statement I less than equal to n semicolon i plus plus what does it mean we will see what it means then what would I do I will print f please enter number let us say integer I call it n <sil=0.473> ,COMMA please enter an integer scan f percentage d norm amperes and norm <sil=0.916> .PERIOD Then sum assigned sum plus norm that is all here I do not have to increment this control variable why after I add the number that has been read here after I add that with sum I am going back to this fall loop and where am I going to I am now doing this operation that is incrementing I <sil=0.956> .PERIOD So <sil=0.505> ,COMMA I will become it was I was 1 so <sil=0.621> ,COMMA I will become 2 and then again I add the number after I make I equal I increment I so <sil=0.585> ,COMMA initially I was 1 here so <sil=0.523> ,COMMA what is happening let us look at what is happening to the control variable of the index I was 1 I do it once so <sil=0.567> ,COMMA the sum becomes number suppose the number was 5 suppose the number was 5 that was entered so <sil=0.374> ,COMMA the sum becomes 5 I increment I so <sil=0.644> ,COMMA I becomes 2 I check it is less than 5 less than this n I again read another number suppose I did 7 as a second number so <sil=0.304> ,COMMA sum becomes 5 plus 7 12 and then I go back here increment it it becomes 3 I check again after doing this I come here check it is still less than 5 so <sil=0.609> ,COMMA less than n I again do this I read another number suppose it is 12 so <sil=0.568> ,COMMA 12 plus 12 will be 24 here increment this so <sil=0.321> ,COMMA it becomes 4 I still go over there still it is less than 5 I read the next number which was 6 say so <sil=0.550> ,COMMA sum becomes 30 here then I is increment it to be 5 I again come here and check that is less than equal to n true so <sil=0.484> ,COMMA I come here I read another number say 10 sum becomes 40 come back here I become 6 I come at this point this condition is not true therefore <sil=0.424> ,COMMA I will come to this point where maybe I will be writing something like print F percentage D backslash and sum so <sil=0.305> ,COMMA the sum will be printed at this point 40 so <sil=0.517> ,COMMA now you see I have read how many numbers 5 7 12 6 10 5 numbers and that's what I wanted to do now I can look at this now I can I could have done several this thing in a different way also for example <sil=0.544> ,COMMA if I had just instead of this I equal to 1 I make it I initialize this to be 0 all right I initialize I to 0 and keep everything the same what will be changing a n is 5 so <sil=0.432> ,COMMA here I will start not from 1 <sil=0.415> ,COMMA but from 0 so <sil=0.349> ,COMMA first will be 0 then only 1 then will be 2 then with 3 then before then will 5 so <sil=0.641> ,COMMA ultimately how many numbers should I read 6 numbers <sil=0.579> ,COMMA but I was actually trying to read 5 numbers I am sure you are confused so <sil=0.523> ,COMMA let me show it in another through another example suppose I read I want to read 3 numbers if I write it in this way for I now by the way it need not be I I could have written declared it properly and I could have taken any variable to be my index I could have said that it is my index <sil=0.419> ,COMMA but the only constraint is that this must be an integer variable my index is 0 note the semicolon here because this is one statement then I write my index less than equal to 5 say less than equal to I am trying to read 3 so <sil=0.555> ,COMMA my index is less than equal to 3 semicolon again and then my index plus plus and I just read the numbers so <sil=0.430> ,COMMA I am dropping of the print F just writing scan F percentage D and now I since it is only one statement I can simply remove this parenthesis now let us see I wanted to read 3 numbers now what will happen here I write my value the value of my index and the value of norm my index has been initialized to 0 and I check with my index my I check with this statement it is less than equal to 3 so <sil=0.600> ,COMMA I read the number suppose the number is 15 I increment my index so <sil=0.537> ,COMMA my index now becomes 1 right my index becomes 1 still less than equal to 3 I read another number 5 my next I come here so <sil=0.404> ,COMMA I do this and come here and my index becomes 2 still less than equal to 3 I read the number say 14 I again come here my index becomes 3 less than equal to 3 I read another number 5 I come here my index becomes 4 I compare this condition is not satisfied so <sil=0.554> ,COMMA I come out of this loop but in the process how many numbers have I read I have read 4 numbers 1 2 3 4 but what was my intention my intention was to read 3 numbers so <sil=0.632> ,COMMA where did I go wrong where did my logic go wrong this is what as a programmer you must be very careful and cautious about where did I go wrong you can say that I have gone wrong in either of the two places one is I could have simply initialize my index not with 0 but I could have initialized it to 1 in that case what would have happened first this part we forget we will start with my index 1 read 1 number less than 3 so <sil=0.646> ,COMMA then it become 2 less than 3 I read the other number increment it it becomes 3 still less than equal to 3 I read this number whenever I come to 4 then my index becomes 4 this condition is violated so <sil=0.644> ,COMMA I will not be reading this number it will be alright otherwise another thing I could have done what could I have done you must have discovered it by now that suppose I had kept my index to be 0 I decide no I like this circular figure 0 very much so <sil=0.394> ,COMMA I keep it like that then what should I do in order that I can still be logically correct I would have changed this condition from less than equal to to less than then let us see what would have happened then also my index starts with 0 I read 1 number incremented so <sil=0.554> ,COMMA it becomes 1 I check for the condition my index is still less than 3 so <sil=0.472> ,COMMA I read the other number 5 my index is incremented 2 still less than 3 I read the other number 14 fine as soon as I after I read I make it 3 incremented and I check the condition now it is no longer true it is not less than but equal to but less than equal to is not my condition my condition is less than therefore <sil=0.588> ,COMMA I will not read the 4 number so <sil=0.501> ,COMMA this is a point where often people make mistakes while writing for loops so <sil=0.535> ,COMMA I encourage all of you to very carefully study this we will look into the for loop a little bit more so <sil=0.458> ,COMMA we have seen the initial so <sil=0.562> ,COMMA I have given you some example one point that is very important you must have noticed while I was writing this that there is no semicolon at the end of this statement why because the entire the 4 statement has not ended here it is going on for this period do this that is the end of the statement so <sil=0.498> ,COMMA no semicolon is given for this 4 4 conditional part and here all these are expressions you can see that this you can see that this is an expression sorry sorry this is an expression this is another expression this is another expression now since these are expressions it can be very general for example <sil=0.584> ,COMMA I could have written initialization is fine but here I could have done something I plus p times 2 is less than 25 that is very much valid and here also I could have done I assigned I could have written I assigned I plus 5 or I could have written I assigned I times 5 anything this is a modifier modulator I am changing the condition and changing the index variable and then testing that index variable with respect to a condition only point that you should remember is that this must be an integer variable <sil=0.974> .PERIOD So <sil=0.402> ,COMMA how it works the expression 1 that is say typically I assigned 1 the expression 1 is used to initialize some variable call index that controls the looping action expression 2 I less than equal to 5 represents a condition that must be true so <sil=0.372> ,COMMA that the loop continues and expression 3 say I assigned I plus 2 all right that is a bracket I assigned I plus 2 or I plus plus as you are seen till now they are used to alter the value of the index initially assigned by expression 1 we have seen this so <sil=0.302> ,COMMA not much to worry about it <sil=0.948> .PERIOD So <sil=0.649> ,COMMA expression 1 is used to initialize so <sil=0.303> ,COMMA here so <sil=0.583> ,COMMA what is the way it is done is first expression 1 is executed so <sil=0.612> ,COMMA for j equals 0 j less than equal to k plus 5 can be anything it can mean expression j plus plus so <sil=0.465> ,COMMA first this expression is executed then after we execute this I check by initialization have I violated the condition in that case of course <sil=0.567> ,COMMA there is no point getting into the loop I will go out otherwise if it is not done then I go inside the loop carry out the loop and then instead of going into the loop straight back I will first come to this alteration or modulator statement <sil=0.987> .PERIOD So <sil=0.611> ,COMMA it is sorry what did I write here I wanted to write j assigned j plus 1 here or j plus plus whatever <sil=0.927> .PERIOD I do that and after I do that what do I do I immediately come back to this expression and test it again is it true if so <sil=0.609> ,COMMA I will get into otherwise I will exit <sil=0.963> .PERIOD So <sil=0.524> ,COMMA this is the structure of the 4 statement ok <sil=0.999> .PERIOD Now <sil=0.567> ,COMMA there are couple of critical issues but before that let us write a simpler program with 4 suppose I want to find the sum of first 10 natural numbers what are the first in natural numbers 1 2 3 4 5 up to n <sil=0.956> .PERIOD So <sil=0.435> ,COMMA in school mathematics you know that the sum for 10 numbers it is the formula is n times n plus 1 by 2 right <sil=0.947> .PERIOD So <sil=0.390> ,COMMA one simple program is if I want to find the sum of 10 numbers you can simply do in your main in sum assigned 0 and then in one short you can write sum assigned 10 because I want to write 10 natural numbers 10 times 11 divided by 2 and then print if sum that could be one way but that is not what I am going to do I want to illustrate the volume <sil=0.920> .PERIOD So <sil=0.336> ,COMMA the way I can do it is main function and here I put in int sum equals 0 <sil=0.972> .PERIOD Now <sil=0.388> ,COMMA I know that it is not I am not going to find the sum of n natural numbers I am going to find the sum of 10 natural numbers <sil=0.968> .PERIOD So <sil=0.567> ,COMMA I can write it in this way for so <sil=0.359> ,COMMA in sum equal to 0 another variable will have to initialize that is my index I write it in my index not necessarily i or j all right but it must be an integer <sil=0.946> .PERIOD So <sil=0.609> ,COMMA for but I am not initializing it here for mindx assigned 0 mindx less than 10 please verify whether I am right or wrong mindx plus plus sum assigned sum plus mindx plus 1 what will happen sum was 0 mindx was 0 so mindx plus 1 so <sil=0.582> ,COMMA the sum will be 1 what am I expecting 10 times 11 by 2 right so <sil=0.396> ,COMMA that will be 55 right sum of first 10 natural numbers now mindx becomes 1 so <sil=0.530> ,COMMA mindx is 1 now less than 10 I again add that so <sil=0.531> ,COMMA sum was what was my sum my sum was 1 so <sil=0.574> ,COMMA here is first iteration sum was 1 then sum was 1 I have written it here so <sil=0.470> ,COMMA sum plus mindx mindx was 1 so <sil=0.330> ,COMMA 1 plus 1 am I right so <sil=0.577> ,COMMA here it was right now sum was 1 and mindx is 1 plus so <sil=0.509> ,COMMA 2 1 plus 1 so <sil=0.627> ,COMMA it will be 1 plus 2 so <sil=0.371> ,COMMA this will be added so <sil=0.526> ,COMMA the sum will be 3 next mindx will be incremented to 2 so <sil=0.420> ,COMMA now sum is 3 mindx is 2 plus 1 so <sil=0.596> ,COMMA 3 plus 2 5 and 1 so <sil=0.353> ,COMMA sum will be 6 in that it will go on and ultimately I will come to this point where it will exceed 10 and then I can stop so <sil=0.469> ,COMMA here is now you can also do that so <sil=0.446> ,COMMA sum of natural numbers you can do that in a loop using the index itself being updated and creating the different natural numbers every time so <sil=0.380> ,COMMA if I had written it in this way for I equals 1 that is the first one I less than 10 would that be okay I plus plus sum equals sum plus I what would have happened I is 1 sum is 1 right now next I is incremented I is 2 and then sum was 1 so <sil=0.597> ,COMMA that will be added sum is 3 again this will be added 3 sum is 4 as sum is 3 so <sil=0.504> ,COMMA then will be 6 again 4 then will be 10 in that it will go on ultimately so <sil=0.437> ,COMMA suppose I was trying to do it for 5 numbers so <sil=0.319> ,COMMA I just I less than 5 first 5 natural numbers so <sil=0.435> ,COMMA sum is 5 so <sil=0.492> ,COMMA now 4 I have already taken now I plus first it becomes 5 but I will get stuck here so <sil=0.530> ,COMMA if I start it with 1 what should I do I just did it in a couple of moments earlier in the earlier lecture so <sil=0.315> ,COMMA what should I do here I should make it I less than equal to 5 in that case I will take the 10 plus 5 15 so <sil=0.523> ,COMMA 5 natural numbers sum of 5 times 6 by 2 is 15 right so <sil=0.357> ,COMMA I can compute that using this loop all right so <sil=0.523> ,COMMA that is a very interesting application so <sil=0.425> ,COMMA 4 is a very powerful we will see in future application that 4 is a very powerful construct using which we can do <sil=0.932> .PERIOD Today <sil=0.594> ,COMMA we will be having a look at how the techniques that we have learnt can be applied to different problem solving and this will continue from this lecture onwards for a few more lectures <sil=0.987> .PERIOD We have learnt quite a few things we have seen the overall structure of the sea language <sil=0.925> .PERIOD We have seen the if then else if else structure the iteration structure like the loops <sil=0.978> .PERIOD We also know how the variables are defined <sil=0.917> .PERIOD We have seen arrays how data can be stored in one dimensional array and two dimensional arrays <sil=0.936> .PERIOD We have also seen functions and the most important thing about functions is that it enables us to take a complex problem and divide it into different parts and solve each of the parts separately using functions <sil=0.995> .PERIOD A very important thing about functions is passing of the parameters and how the function returns a value returns a value to the calling function <sil=0.988> .PERIOD We have also seen that there are two there are two ways in which parameters can be passed from the calling function to a called function one is call by value another one is call by reference in sea language in general always call by value is adopted <sil=0.904> .PERIOD However <sil=0.310> ,COMMA in call by value we have to copy the value of the data the parameter value or the parameter value to the argument value <sil=0.970> .PERIOD However <sil=0.586> ,COMMA for the case of arrays whenever I want to pass a particular array at that point an array can be 100 by 100 array or 10 by 10 array if it be a 10 by 10 array then I will have to copy 100 values so that is not advisable for that we just pass the array name and let us quickly have a look that the array name is essentially an address and array whenever we pass suppose there is an array a two dimensional 10 by 10 array all right two dimensional array like this <sil=0.926> .PERIOD Now all the elements I am not passing so it is essentially it happened to be a 4 by 4 array so that is all the 16 elements I will not be passing so here is my called function the function called function and on this side is the calling function the calling function and the array name is say a so the calling function refers to suppose let this function be called f so from the body of the calling function whenever I am calling f I am passing the array say if it been integer array into a and here I just pass the array a and here in this function body we have got say int a and just saying that the size of the or it may not be a it can be x also int x something and the size of the array and here int a and maybe n so here I am actually passing the name of the array and the name of the array is nothing but the beginning of the address of the first element of the array <sil=0.949> .PERIOD So here I am actually copying the address so it is a call by reference in the case of an array and in the last lecture we have also seen that we can also use pointers to sort of establish call by reference another major thing that you have to keep in mind is that suppose this array is 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 now these are organized in C in a row major form so it is stored in the memory like 1 so the rows first 2 3 4 then 5 6 like that so when I refer to the array a I actually pass on the address of the first location of the array ok <sil=0.928> .PERIOD So a 0 0 in the case of a 2 dimensional points to this element and that is this element ok that is how we pass on arrays <sil=0.971> .PERIOD So for functions and we have also seen some applications of all these techniques that we have learned in particular we have seen how we can carry out search and we have seen 2 search techniques one is linear search another is binary search now in linear search the complexity the time is proportional to the number of elements whereas in binary search it is reduced its faster its log of the number of elements to the base 2 and search is a very fundamental problem solving technique in technique because suppose you have got the names of students in the class all right here are the names atul sham gargi in that way the names are there and each of them have got a rule number 1 2 3 4 right there now you want to find out how many shams are there in the class <sil=0.932> .PERIOD So you have to search this array and find out where sham is ok maybe here and there is another sham here <sil=0.931> .PERIOD So that is searching and counting both the things but you cannot avoid searching this array all right it may be that along with that there is an array of marks obtained by rule number 1 rule number 2 etcetera so maybe this is 50 this is 70 this is 30 all right now here tell me I want to say now they are in 2 arrays this is 1 array called name and this is another array called marks of the corresponding students <sil=0.985> .PERIOD Now I want to know how much what is the marks that gargi has obtained how do you go about it what will be the first step in solving this problem what is the marks that gargi has obtained in order to do that I have to first I do not know what is gargis rule number if I had known what is gargis rule number suppose gargis rule number is 3 then I could have gone in the marks array and I could have taken marks rule number what if I knew the rule number rule number minus 1 that marks I could have taken as a result all right but I do not know the rule number if I had known the rule number 3 then I would have gone to the second element so is marks 2 would have been would have given me the rule number but suppose I do not know the rule number then what should I do first I will have to search this array and what would be my key what is my key key will be the screen gargis because I want to know the marks obtained by gargis and what should I do with this key I should carry out a search it can be a linear search or it can be a binary search let us for the time being assume that it is a linear search so we will be searching and I will be finding gargis here I am assuming for simplicity that there is only one gargis in the class so I will take this and I find what will the search if you recall what will the search algorithm return me the search algorithm will return me the index of the position where gargis located and that position will be actually it will automatically come since this positions will be marked as 0 1 2 I will get this 2 returned so I will get so I get the key I search the array name this is a character array a care name size whatever size is a n and the key and this search will return me the value position 2 plus equal to 2 then I will simply take the value of marks I will go to the array marks plus which will be my result right so you see we needed the searching now while I was talking of searching this array I said that the searching I am assuming they searching to be a linear search would it be possible to search this array using binary search if you just think it over would it be possible to search it using binary search what does binary search require binary search requires that the array be sorted right array be sorted so an array like this a tool amol Varghis and joy this is an array of 4 elements can I sort it the type of sort if I want to sort it I will have to organize it in increasing or decreasing order let us assume that I am trying to do it in an increasing order now this sort will be this character array can be sorted in a way which is called the lexicographics sort that means I go I sort the character array according to the alphabets or the words as they written obviously a comes first so therefore a character a is smaller than character b all right so here between these two elements both of them has got e but similarly t is greater than m so in this sorting I will first check between these say a they are same think of bubble sort I am trying to compare them in normally what we did we found that say array x xj is less than xj plus 1 and then we did something if it was if it is the case no issue if it was the other way round I I wanted to swap but in this case it will not be so simple I can take a string and compare these two strings as to which one is whether they are same or not or whichever is greater but another way you can write a small function to compare I leave it to you I leave it to you that you now know sorting techniques so you should try to write a function that will sort a string of characters all right so a and a are same if they are same the function what will do it will now look at t and m now m is smaller than t therefore amal is smaller than atul so amal will come here and atul will come here now between atul and gargi you can see a is greater than smaller than g so gargi is in a proper space please now if say for example I do not have joy here I am having another name go thumb here now when I am comparing between gargi and go thumb g and g are the same so they recall no change next a and a are also same no issue so there is no change but r r is smaller than u because r appears earlier than u but in terms of our computer code technology the asci code of r is less than the asci code of u so in both the ways it is meaningful so r is less than u therefore gargi is smaller than go thumb so in that way I can carry out with another small function compare string is greater say is you can write a function is greater two strings okay care S 1 comma care S 2 two strings will be passed on this function and this function will find out which character if S 1 is greater than is 2 it will just return if S 1 is greater than is 2 it will return a 1 if S 1 is greater than S 2 try to write such a function okay now that is that I am giving you as a home assignment all of you should try to do that and with a little effort I am sure you will be able to do that so I could have just as I had done in the earlier one here in this thing I said that I will be doing linear search I could have done binary search also provided I had provided I had sorted them okay provided I had sorted them in the proper way and then with the sorted I had a I could have done binary search now will be also doing some problem solving will in this course will be doing some problem solving in the field of numbers or equations mathematical problem solving but before that in order to do this today let us have a relook at the strings we had looked at strings earlier as an array of characters so let us have a relook at the whole thing today how can I represent an array of strings like the one that I was showing here an array of strings all these names are tool Amal Gargi and Gautam all these are nothing but this is a string this is a string all these are different strings so how can I represent them let us have a look at that see I can I have got three strings one is spike as is Tom as is JD Now <sil=0.450> ,COMMA these three strings I have to store and I am saying that each string can be at best 10 characters at most 10 characters and I am looking at three such names so it is an array three rows and each row having 10 characters so the definite the definition would be I named them as CHR I could have done character array and it is three rows and 10 columns now I can initialize that as spike as character S character P so S comes here P comes here I comes here K comes here E comes here and that is the end so it is backslash 0 I also put that and so 1 2 3 4 5 6 4 places are still vacant 4 places are still vacant similarly for the next one is Tom so T O M backslash 0 and the rest are rest 6 are all free all right but my string has ended here so one way I is that I can represent them in this way where I specifically talk about the characters in the array and terminate them with backslash 0 the other way I can do it is simply I initialize them as 3 10 the same array with three strings spike comma Tom comma jelly now internally even if I do that it is essentially becoming the same thing internally it is being stored in the same way with three rows and each row having this characters S P I K E backslash 0 and so on so forth they can be more P O M backslash 0 and so on so forth here also J E R R Y and so on sorry backslash 0 and so on so forth it is being stored so both of them are equivalent I can do it in either of these ways all right so a string can be represented in any of these ways so we already know this again the name of the array is a pointer to the 0th element of the array so if I have this array S P I K E backslash 0 T O M backslash 0 J E R R Y backslash 0 when I am calling that CHR the name itself is pointing to the first element of this array so CHR are 00 it is pointing to that so this and CHR 0 0 are the same they mean the same thing okay so this you just like an array this is also true here therefore if CHR points to the address 1000 CHR plus 1 will point to address 10 why the reason is again I have got this array and CHR is pointing CHR or AR is pointing to the 0th element of the first row if this is 1000 then 1000 to 109 this at this location is 109 because the size is 10 okay size is 10 so although S P I K E backslash 0 etc is there then when I go to the next one CHR underscore AR plus 1 that means wherever this pointer is this entire thing is taken 0 to 10 so I am taking here it is taking all these 10 elements as one it will be pointing to the next one that means it will be 1010 okay again if I make it CHR plus 2 it will come to this one all right that is how the pointer works but how can I get this character this will be CHR 0 1 that is pointing to this element okay now this thing must be clearly understood so CHR points to a 0th string or the 0th 1 dimensional array CHR 1 points to the first string or the first 1 dimensional array I mean number 1 0th first CHR 2 points the second 1 dimensional array so each of them are one dimensional arrays and CHR is pointing to each of these one dimensional arrays CHR is pointing to one one dimensional array and as I increment the pointer this pointer is going on increasing all right in general CHR I points to the i th string or the i th dimensional array clear the following program let us look at the program and the following program demonstrates how to print an array of strings please take one minute to read this array a program yourself and try to understand it you can see here that I am starting with the main function and although it is written in a in a very cryptic way so my program starts from this point and ends at this point i is an integer CHR is again an array of three strings and each can be of maximum length 10 so spike <sil=0.380> ,COMMA tau and jere are there so I can print I just print first way next line I go to next line and tune next line so I just put first way and then what do I do so I will print first way and then two lines have been given blank then for i 0 2 less than 3 i plus plus print f string I am printing the string so what will be printed string equals a place holder for the string and then there will be some tab one space and then so the first will be string here some space and then tab this is tab so I give some space and write address and then sorry string equal to string equal to address equal to and there will be some space for the address and that format is unsigned integer so it will become longer alright because unsigned and signed integer whenever I am putting suppose I have got 16 bits for representing an integer if it be a signed if I distinct between plus 5 and minus 5 and keep one bit kept for the plus or minus then for the 16 bit for I will be actually having 15 bits for this size but if I make it unsigned then I can have all the 16 bits so I can represent more numbers alright more numbers so that apart so string and address and then what am I printing here care i care plus i that means 0 care 0 the first string and then I am again putting the care this now what is the difference between this care this and this this is being printed in percentage s that means the string will be printed and here in an unsigned integer what I am printing here is the address of that string so this string spike was here when I print this just the name of the array that means I am in this format if I do I am printing the address of it therefore the output will be somehow like this so this is something to be understood very clearly that this array when I am actually looking at this I am taking the content of the array otherwise I am taking the array itself so here is a program this program asks the user to enter a user name if the user name entered is one of the names in the master list then the user is allowed to calculate the factorial of a number otherwise an error message is displayed so we have got a master list of names now if you are a valid user your name is there in the list so first what is doing is including stdiu dot h is including string dot h that means some string functions are also included I am defining the factorial proto type the factorial function has been written later suppose this part this part is later than the main function okay now the main is here and what is the main doing it has got some integer i and found is 0 initially the name is not found here and some n number for which I have to compute the factorial master list 5 by 20 that means each of these each of these can be 20 character long and there are 5 such and I have put the valid names as admin <sil=0.544> ,COMMA Tom <sil=0.326> ,COMMA Bob <sil=0.420> ,COMMA Tim and Jim now I am asking and name is and so I am and I am asking from the user enter user name now the user gives the name so get s here you are getting a new function being introduced here that is get s what is get s get carry and get c h you know and here get s means get the string so in one shot it is getting the string as the name so name I am getting from the user some name say it is Jim suppose the user enters Jim now for i equals to 0 to 5 y5 there are all the 5 names are here if string compare name and master list i if this character this string and this string matches then found is one otherwise I am again going in the fall loop so at every stage of the loop I am trying to compare this name with this string here there is no match so I come here no match no match in that way come and find Jim so here ultimately I will get found and then I will break now when I come out suppose it was not Jim it was a Jimmy then I do not get a match here so I can come out with found equal to 0 or found equal to 1 if found equal to 1 then welcome then welcome exclamation and then the name is printing welcome Jim and asking please enter the number is entering the number for the factorial and then here you see in this printf I have called the factorial that factorial of the number is this n is this so I call factorial and this part you know now that this n and this n and may not be the same I mean the two different locations but this n it could have been x also in that case internally it had it had to be x here so this is being passed over here the factorial is being computed all right once the factorial is computed now how the factorial is computed I will be discussing that later because here they some trick forget about that trick now I will be discussing that later that is recursion which we have not yet discussed and after this I am coming back here and I am printing so the purpose of this program was to show how we can handle strings so these are very common very common thing I mean you try to log in in a machine right and you type in your log in name and your password if they do not match the system says log in failure now how does it do it internally internally it has got a list of just like this it has got a list of all the users and it takes your user name and checks it with all these that is a problem that is being solved a sub problem that is being solved in the operating system and that is the basic principle is depicted in this program all right we will continue with other problem solving approaches in the future lectures In this lecture <sil=0.385> ,COMMA we will be looking at another numerical method technique that is we will actually look at two <sil=0.946> .PERIOD First we will look at integration <sil=0.560> ,COMMA how we can integrate a function <sil=0.942> .PERIOD There are several methods for doing that we will look at only one method and you can after that you can look up for other methods <sil=0.929> .PERIOD Next we will proceed to see how ordinary differential equation can be solved using numerical techniques using programming <sil=0.923> .PERIOD So <sil=0.436> ,COMMA first of all let us start with integration <sil=0.994> .PERIOD Now <sil=0.351> ,COMMA all of you know what integration means given a particular function <sil=0.475> ,COMMA in a particular function integration is say I have got a function like this and I want to integrate suppose this function is f x and I want to integrate it within the range a and b <sil=0.998> .PERIOD So <sil=0.630> ,COMMA we write that as integral a to b of f x <sil=0.959> .PERIOD And you also know that this integration actually means the area that is under this curve alright this value is the integration <sil=0.924> .PERIOD So <sil=0.572> ,COMMA we will look at how we can solve this problem <sil=0.943> .PERIOD The simplest a very simple method is a trapezoidal method which we will discuss here <sil=0.961> .PERIOD So <sil=0.601> ,COMMA you can see that let me go back to this this case <sil=0.901> .PERIOD Now <sil=0.388> ,COMMA you can see that I can approximate this curve in a very simplistic case using a trapezoid right <sil=0.961> .PERIOD So <sil=0.534> ,COMMA I have got a trapezoid here let me draw in blue <sil=0.968> .PERIOD So <sil=0.308> ,COMMA the area under this trapezoid this is way itself <sil=0.980> .PERIOD So <sil=0.318> ,COMMA the area under this trapezoid is approximating under this trapezoid is approximating the area under the curve <sil=0.946> .PERIOD But that is becoming possible here except for this error that is becoming possible here here because the curve was very much not very skewed in that sense <sil=0.938> .PERIOD But if the curve were something like this that say it was something like this and I was trying to integrate it between these ranges then if I had fitted a trapezoid here here then the amount of error would be much more because I will be committing errors at these points <sil=0.966> .PERIOD I am not considering this I am over considering this points etcetera <sil=0.974> .PERIOD So <sil=0.634> ,COMMA the error would be more <sil=0.956> .PERIOD So <sil=0.433> ,COMMA it is not always the case that a simple trapezoid one single trapezoid will solve <sil=0.917> .PERIOD But let us start with that and try to understand how we can go ahead with the problem <sil=0.976> .PERIOD So <sil=0.553> ,COMMA the area under the curve in this particular curve as you can see here this particular curve that has gone through this is a trapezoid under the curve is a trapezoid this part if I assume it to be a trapezoid in that case the integral of f x d x is the area of the trapezoid and we know that the area of a trapezoid is nothing but half the sum of the parallel sides that means <sil=0.384> ,COMMA f a plus f b divided by the height <sil=0.952> .PERIOD Now <sil=0.609> ,COMMA if I look at it these are the parallel sides then the height is this b minus a this this amount <sil=0.953> .PERIOD So <sil=0.448> ,COMMA this is a known result therefore <sil=0.486> ,COMMA I can say if I can approximate a curve by a single trapezoid in this way b minus a times f a f b plus f a by 2 or f a plus f b by 2 <sil=0.990> .PERIOD But of course <sil=0.629> ,COMMA we will see that there can be errors due to this approximation but this is a simple formula which we can quickly compute is very easy to write a program for that you have got a function that will compute the curve <sil=0.953> .PERIOD So <sil=0.463> ,COMMA you call it for a and call it for b and compute this expression you will get the integral integral <sil=0.944> .PERIOD So <sil=0.302> ,COMMA here is an example why is this important suppose the vertical distance covered by a rocket from time 8 to 30 <sil=0.981> .PERIOD So <sil=0.642> ,COMMA my timeline is from 8 seconds to 30 second is given by this formula <sil=0.928> .PERIOD So <sil=0.306> ,COMMA the vertical distance overall total vertical distance is this this is a complicated formula <sil=0.986> .PERIOD Now <sil=0.358> ,COMMA using single segment trapezoidal rule let us try to find the distance covered <sil=0.931> .PERIOD Let us try to find out the distance covered for this <sil=0.973> .PERIOD So <sil=0.347> ,COMMA we know for 8 and for 30 if I compute this function this was my function <sil=0.993> .PERIOD So <sil=0.519> ,COMMA for f 8 my function is yielding this value and for f 30 the function is yielding this value <sil=0.990> .PERIOD We can compute using you can use your calculator and find it out that you need not do right now <sil=0.928> .PERIOD So <sil=0.320> ,COMMA you can compute the values at these two points because this is the overall function and next <sil=0.953> .PERIOD So <sil=0.370> ,COMMA this is the f 8 and f 30 <sil=0.975> .PERIOD So <sil=0.529> ,COMMA what will be my integral my integral will therefore <sil=0.442> ,COMMA b 30 minus 8 b minus a f a plus a b by 2 <sil=0.958> .PERIOD So <sil=0.584> ,COMMA that is coming to this value sorry that is coming to 1 1 8 6 8 meter the distance covered is this <sil=0.977> .PERIOD But however <sil=0.478> ,COMMA the exact value if you computed the exact value if you do a detailed computation will be 1 1 0 6 1 meter <sil=0.900> .PERIOD So <sil=0.348> ,COMMA there is an error obviously <sil=0.530> ,COMMA there is an error because I have approximated the curve using a trapezoid <sil=0.959> .PERIOD Now <sil=0.466> ,COMMA let us see how great is the error how big is the error <sil=0.974> .PERIOD So <sil=0.410> ,COMMA we can see that the true error is minus 807 meter right that is quite significant 800 meters and the absolute relative error which is the actual error true value and the computed value and divided by the true value you find that I am getting 7 percent more than 7 percent error how can you better it how can you better it therefore <sil=0.907> .PERIOD So <sil=0.362> ,COMMA our answer will be we will instead of applying a single fitting in a single trapezoid I can try to fit in more than one trapezoid here like something like this that there is a trapezoid here I fit in one trapezoid here I fit in another trapezoid here and I thereby I can approximate I can minimize my error to some extent <sil=0.970> .PERIOD So <sil=0.377> ,COMMA here what we are trying to do instead of taking 8 and 30 and fitting in one trapezoid for the whole thing instead of fitting in a one trapezoid for the whole thing what we are trying to do is we are fitting in one trapezoid for 8 to 19 another for 19 to 30 ok <sil=0.934> .PERIOD So <sil=0.589> ,COMMA now again using the same formula we find then here is 1 19 to 8 to 19 this is the integrand plus the other trapezoid is giving me this <sil=0.950> .PERIOD So <sil=0.479> ,COMMA I am fitting in two trapezoids now clear <sil=0.963> .PERIOD So <sil=0.456> ,COMMA if I do that then let us see whether the result is being bettered <sil=0.935> .PERIOD So <sil=0.613> ,COMMA I compute f 8 at f 30 and f 19 and compute both of these values the areas under the curve here and here and the result is 1 1 2 6 6 meters <sil=0.918> .PERIOD Now <sil=0.582> ,COMMA how how far is it from the actual now we can see that the true error is now has reduced from 800 7 meters to 205 meters <sil=0.966> .PERIOD So <sil=0.597> ,COMMA that tells us that if we can extend this procedure and fitting more and smaller but more number of trapezoids my error will come down further still taking q from this idea what is being done is the multiple segment trapezoidal rule therefore <sil=0.500> ,COMMA is that we divide into equal segments say here is one trapezoid here is one it is not coming here let us see select on the color say here is one trapezoid here is another trapezoid here is another trapezoid and here is another trapezoid I am getting four trapezoids here and trying to formulate this I can do that in this way <sil=0.952> .PERIOD So <sil=0.331> ,COMMA the integral is this whole thing which will be some of these trapezoids remember each these lines these lines these this distance is the same <sil=0.993> .PERIOD So <sil=0.569> ,COMMA I am dividing b minus a by some particular value n and that is my h <sil=0.956> .PERIOD So <sil=0.483> ,COMMA this is h this is h like that I am going for equidistant points and drawing the trapezoids from there <sil=0.929> .PERIOD So <sil=0.389> ,COMMA therefore <sil=0.348> ,COMMA if I follow this as is shown in this way the trapezoidal rule trapezoidal rule can be written as integral of a from a to b is sum of half f n plus f n plus 1 that is f a plus f b by 2 times the particular distance that is there x o x 1 minus a x 2 minus x 1 usually you do it in the equidistant mode ok <sil=0.997> .PERIOD So <sil=0.409> ,COMMA now multi segment trapezoidal rule is therefore <sil=0.576> ,COMMA and integral r can be broken down this is simple from a to a plus h I can have f x d x a plus h 2 a plus 2 h f x d x plus a plus n minus 2 h 2 a plus n minus 1 h f x d x a plus n minus 1 h 2 b <sil=0.998> .PERIOD So <sil=0.308> ,COMMA all the segments are being added together applying this I get this formula b by a divided by 2 n because n is coming 2 is coming n times <sil=0.974> .PERIOD So <sil=0.323> ,COMMA f a plus f b plus 2 into f f a plus h because that is coming twice here once and here once you see here f a plus h will come here f a plus h will come right ok <sil=0.961> .PERIOD So <sil=0.552> ,COMMA using this let us do the example again the same thing using 2 segment trapezoidal rule we could find that the error is coming down we have already seen that the true value of error is coming down and the absolute latent error has come to 1 <sil=0.920> .PERIOD 853 <sil=0.983> .PERIOD So <sil=0.415> ,COMMA now let us come to c programming straight away how can we encode it using the c program you see here <sil=0.974> .PERIOD So <sil=0.513> ,COMMA I am reproducing the result here again <sil=0.939> .PERIOD So <sil=0.365> ,COMMA integral of f x d x between a and b will be h by 2 f a plus 2 f f a plus h plus 2 f a plus 2 h why this 2 is coming because in the first zone f a and f f f a plus h second zone f a plus h plus f a plus 2 h <sil=0.958> .PERIOD So <sil=0.526> ,COMMA each of these intermediate points are coming twice that is why this 2 and I have got this formula <sil=0.998> .PERIOD Now <sil=0.477> ,COMMA as a c programmer your task is very simple you see here that I have defined a and i whatever I am asking the user for the necessary inputs how many number number of sub intervals that you want to have the initial limit a you are reading the initial limit b all those things you are reading now the integral computation is done here what is being done h is I am finding out the absolute value of b because b and a b minus a divided by n and I am taking the absolute value of that all right because it could have gone on the other side also <sil=0.983> .PERIOD So <sil=0.637> ,COMMA now here I am just computing the sum what sum this part what initially x is a plus i h sum sum plus f x <sil=0.987> .PERIOD So <sil=0.395> ,COMMA each of them next time it is becoming 2 all those things I am adding here <sil=0.904> .PERIOD So <sil=0.525> ,COMMA here I am in a loop I am doing a plus i h initially i is 1 <sil=0.983> .PERIOD So <sil=0.448> ,COMMA 1 h 2 h like that I am going on doing that and ultimately and I am computing the sum here sum plus f x <sil=0.956> .PERIOD Now <sil=0.428> ,COMMA note that f x is a separate function that has been kept somewhere here and then ultimately I find the sum sum is these things a plus a this this points <sil=0.984> .PERIOD Now <sil=0.602> ,COMMA integral is h by 2 this part f a plus f b plus f a plus f b plus twice the sum a plus a h a plus 2 h a plus k h like that that part has been a plus i h has been computed inside this loop and that I add with 2 here and here is my integral <sil=0.993> .PERIOD So <sil=0.452> ,COMMA that is the trapezoidal rule it is the program is so simple if you understand the concept ok <sil=0.931> .PERIOD Next we will move to another very important engineering computation that is needed is solving ordinary differential equations <sil=0.971> .PERIOD Quickly let us all of you know what a differential equation is and we will in particular look at Rungi Kutta's 4th order method and here I will show examples that you can also find in this site of University of South Florida numerical methods and I have taken the slides from them with the permission now you see how to write an ordinary differential equation <sil=0.996> .PERIOD Now <sil=0.410> ,COMMA an ordinary differential equation you know is dy dx f x y ok <sil=0.904> .PERIOD Now <sil=0.644> ,COMMA dy dx so how do I write it <sil=0.958> ?QUESTIONMARK I write it as suppose this is something given dy dx plus 2 y is 1 <sil=0.910> .PERIOD 3 into it is the power minus x and what is this part <sil=0.902> ?QUESTIONMARK This is the initial condition ok <sil=0.960> .PERIOD Now <sil=0.385> ,COMMA this can be rewritten as by just changing the direction because I have to bring it to this form dy dx is 1 <sil=0.947> .PERIOD 3 E minus x minus 2 y <sil=0.975> .PERIOD So <sil=0.367> ,COMMA in this case we will assume that our f x y f x y that is the dy dx is 1 <sil=0.982> .PERIOD 3 this thing into e to the power minus x minus 2 y this is our function differential equation that we will have to solve <sil=0.958> .PERIOD So <sil=0.322> ,COMMA for dy dx the Rungi Kutta 4th order method I am not going into the derivation of it for positive of time and you can always look at look into this at any website or you can look at any numerical method textbook <sil=0.999> .PERIOD So <sil=0.347> ,COMMA the Rungi Kutta 4th order method takes 4 terms and this is the expression given this dy dx my task of solving a differential equation is to find the particular y right <sil=0.930> .PERIOD So <sil=0.399> ,COMMA what we are trying to do y i plus 1 is y i some particular y i plus 1 by 6 followed by a term and what is that term K 1 plus 2 K 2 plus 2 K 3 plus K 4 this whole thing multiplied by H <sil=0.916> .PERIOD H is the again the sampling gap that is the distance between the individual points that we look at <sil=0.911> .PERIOD Now <sil=0.554> ,COMMA what is K 1 <sil=0.950> ?QUESTIONMARK So <sil=0.520> ,COMMA K 1 is nothing but when I am taking for y i f x psi y i that particular function is K 1 what is K 2 K 2 is f of <sil=0.919> .PERIOD So <sil=0.645> ,COMMA suppose there is a curve now I have been given the slope I do not know the curve <sil=0.992> .PERIOD So <sil=0.337> ,COMMA I have to if I know the curve again the same problem if I know the curve then I can find out the value of any particular y i plus 1 given any y i <sil=0.951> .PERIOD Now <sil=0.301> ,COMMA given any y i I am trying to guess the curve right I am trying to solve the curve <sil=0.970> .PERIOD So <sil=0.376> ,COMMA x i was here x i plus half h I am taking whatever was my h I am taking half of h and what is the y part of this function y i plus half of K 1 h <sil=0.942> .PERIOD So <sil=0.546> ,COMMA because K 1 was if I K 1 was the function that was giving y given an x that was giving y for an x <sil=0.929> .PERIOD So <sil=0.590> ,COMMA I am taking this what is K 3 K 3 is again this part is same x i plus half h <sil=0.551> ,COMMA but this part is now becoming much more predictive <sil=0.946> .PERIOD So <sil=0.634> ,COMMA it is half of K 2 h half of K 2 that means <sil=0.441> ,COMMA whatever has been computed here times h and K 4 is x i plus h the last one is x i plus h because I am trying to find solve the equation within this zone h <sil=0.944> .PERIOD So <sil=0.596> ,COMMA x i plus h I start with x i and this is x i plus h all right times K 3 h here there is no half <sil=0.934> .PERIOD Now <sil=0.457> ,COMMA this derivation you can look at <sil=0.531> ,COMMA but ultimately I multiply it with 1 by 6 <sil=0.981> .PERIOD So <sil=0.528> ,COMMA given this Runga Kutta formula <sil=0.552> ,COMMA let us quickly look at an example that will be a very nice thing to look at <sil=0.976> .PERIOD Suppose a ball is at 1200 Kelvin and is allowed to cool down in air in an ambient temperature of 300 Kelvin <sil=0.971> .PERIOD So <sil=0.519> ,COMMA the air the ball was heated and cooling down assuming that the heat is lost only due to radiation the differential equation for the temperature is given here this one all right <sil=0.954> .PERIOD Where theta 0 we know initial condition is 1200 Kelvin <sil=0.609> ,COMMA find the temperature at T 4 H T <sil=0.960> .PERIOD So <sil=0.447> ,COMMA what is my x i and so now <sil=0.355> ,COMMA if I assume a step size of 240 I want to find out the temperature at 480 <sil=0.967> .PERIOD So <sil=0.589> ,COMMA suppose it was a particular temperature after 480 seconds <sil=0.924> .PERIOD So <sil=0.560> ,COMMA here is time it was at 1200 and I have got some radiation formula using which it is coming down <sil=0.990> .PERIOD So <sil=0.519> ,COMMA I want to find out what would the temperature be at 480 seconds <sil=0.621> ,COMMA 480 seconds from the starting point where it was 1200 degree Kelvin <sil=0.922> .PERIOD I want to find out this temperature that is the y i I want to find out <sil=0.375> ,COMMA find out given the slope of this differential equation <sil=0.949> .PERIOD So <sil=0.578> ,COMMA assuming a step size of H to be 240 half of this if I take half of this 240 then d theta dT you can compute that here if you compute the dT that dT that dT is here <sil=0.971> .PERIOD So <sil=0.532> ,COMMA my formula will be theta i and theta i k 1 plus 2 k 2 plus 2 k 3 plus k 4 divided by 6 times H that is the Rungi Kutta formula R k formula <sil=0.968> .PERIOD So <sil=0.333> ,COMMA that is what I want to find out <sil=0.914> .PERIOD So <sil=0.318> ,COMMA now step 1 you see I am not going into all these calculations <sil=0.444> ,COMMA but I am finding out the value of k 1 all right <sil=0.916> .PERIOD I am finding out the value of k 2 using this value of k 1 k 1 is being used here and I find out the value of k 2 again the value of k 2 is being used here I find out the value of k 3 and k 3 is being used here I find out the value of k 4 I find out those values all right manually manually I am doing that now <sil=0.979> .PERIOD So <sil=0.317> ,COMMA the solution therefore <sil=0.429> ,COMMA the approach then theta 0 was 1200 initial condition and here I put in the values of this times H H was 240 <sil=0.994> .PERIOD So <sil=0.591> ,COMMA I have taken it at the midpoint <sil=0.903> .PERIOD So <sil=0.340> ,COMMA I find that the temperature sorry the temperature that would be would be 675 <sil=0.922> .PERIOD 65 that is the approximate temperature at 240 all right <sil=0.931> .PERIOD So <sil=0.417> ,COMMA this will be the value at 240 <sil=0.962> .PERIOD Next I have to find out at 480 <sil=0.971> .PERIOD So <sil=0.455> ,COMMA what would I do <sil=0.997> ?QUESTIONMARK Step 2 I have taken I have taken at half point I found out now my initial value theta 0 is changing now I again do the same thing find out k 1 find out k 2 find out k 3 find out k 4 now with this initial condition using the same function all right H is again what is what will be H H will be again 240 because I have to find it out at 480 right at 480 in the temperature <sil=0.961> .PERIOD So <sil=0.486> ,COMMA now I find out that using theta 1 is now 675 <sil=0.936> .PERIOD 65 that is the approximate value that I got earlier and I compute this I find out using the same Rungi Kutta method that this is the approximate temperature at 480 degree at at 480 seconds would be 594 <sil=0.992> .PERIOD 91 degree Kelvin <sil=0.922> .PERIOD This is how we apply Rungi Kutta method and very useful <sil=0.906> .PERIOD So <sil=0.573> ,COMMA the exact solution of the differential equation is 647 <sil=0.913> .PERIOD 57 if I solve it now it was and we got it how much 594 <sil=0.915> .PERIOD 91 and 594 <sil=0.988> .PERIOD 91 <sil=0.918> .PERIOD So <sil=0.485> ,COMMA it was not very far not very far around 50 degree Kelvin that is certainly an approximation <sil=0.960> .PERIOD So <sil=0.638> ,COMMA now we have understood what is Rungi Kutta method now I want to write a C program for it again you might find the approach to be mathematically very novel maybe intricate you may find some initial difficulty in understanding <sil=0.454> ,COMMA but I am sure you will understand it very fast <sil=0.925> .PERIOD You will see that the encoding it as a C program is or as a program is really simple <sil=0.948> .PERIOD Now <sil=0.505> ,COMMA you are learning C you can in future you will be using MATLAB and other things you will be able to solve it very easily <sil=0.907> .PERIOD I am showing you the C solution here on this side I have kept what we learnt till now right <sil=0.998> .PERIOD Y i plus 1 that means <sil=0.517> ,COMMA in our case the temperature at 480 degree is temperature at 240 degree plus this and k 1 is f x y k 2 is f x i this one f x i plus half h plus y i plus half k 1 h etcetera etcetera etcetera <sil=0.971> .PERIOD So <sil=0.473> ,COMMA now let us look at the program we have got the math function everything ready <sil=0.937> .PERIOD Now <sil=0.557> ,COMMA this function somehow this function has to be written now this function is here it is being shown as a very simple function it can be any function the differential equation function the earlier function that we have shown the log function that you have to write <sil=0.958> .PERIOD So <sil=0.432> ,COMMA here is an example of a simple function x minus y by x plus y just for illustrative function whatever is your differential I mean sorry the divide x given that will come in this function <sil=0.905> .PERIOD So <sil=0.610> ,COMMA now you see here I read how many times and the h value x 0 x 1 value all these things I read <sil=0.913> .PERIOD Now <sil=0.648> ,COMMA the key thing comes here this is the implementation of the Runga Kutta method <sil=0.911> .PERIOD So <sil=0.320> ,COMMA very simple you see I am computing k 1 k 1 is f x 0 y 0 <sil=0.947> .PERIOD So <sil=0.517> ,COMMA I am coming to this function computing x 0 y 0 then I am going back computing k 2 for x 0 plus h by 2 h has been read here scan F h h has been read this h has been read then y 0 plus m 1 I am sorry here it should be k 1 k 1 and this should be k 2 all these m c read as k this is k 3 this is k 3 this is k 3 this is k 2 times h <sil=0.954> .PERIOD So <sil=0.401> ,COMMA actually we are computing this thing straight away I am computing all these and then y is assigned y plus k h sorry this whole thing is k h here this will also be k <sil=0.938> .PERIOD So <sil=0.427> ,COMMA it will be this statement will be y will be y plus k h y plus k h right and x x plus h I am implementing x and going on all right I am doing it for two intervals still I come over here <sil=0.925> .PERIOD So <sil=0.302> ,COMMA I ultimately come to this print F and I print the value of y for a particular x that is the Runga Kutta <sil=0.952> .PERIOD So <sil=0.505> ,COMMA this this is straight away amenable to some c program and for each of these F's you are calling you are calling the function every time all right <sil=0.956> .PERIOD So <sil=0.587> ,COMMA this is the Runga Kutta method for solving a differential equation <sil=0.903> .PERIOD So <sil=0.373> ,COMMA I would encourage you to look at other methods of integration like Simpsons 1 third rule is a very popular method and differentially equation Runga Kutta this is known as Runga Kutta 4th order method because we are taking 4 terms here there are even but this works very well for most of the engineering problems <sil=0.969> .PERIOD So <sil=0.542> ,COMMA I will encourage you to write programs on this and later on henceforth we will move to another interesting aspect that is known as recursion a new style of programming which will take up in the next lecture <sil=0.940> .PERIOD Thank you <sil=0.956> .PERIOD So <sil=0.618> ,COMMA in the earlier lecture we have seen how a function can be invoked and it returns the values <sil=0.967> .PERIOD As we had mentioned that it is not the case that always a function will return a value <sil=0.955> .PERIOD Here is an example <sil=0.961> .PERIOD You look at this function <sil=0.608> ,COMMA D7 which says that means the purpose of this function is to find out whether a particular number that is passed on to it as a parameter or a parameter whether that is divisible by 7 or not <sil=0.923> .PERIOD So <sil=0.522> ,COMMA the program the code is very simple <sil=0.940> .PERIOD What should we do <sil=0.947> ?QUESTIONMARK If n is divisible by 7 that means if n modulus 7 is equal to 0 then we say printf n is divisible by 7 otherwise we print n is not divisible by 7 <sil=0.952> .PERIOD Now <sil=0.417> ,COMMA in this case we are just printing from here straight the printout is coming printing is coming out from here <sil=0.966> .PERIOD The main function is only passing on the value reading some value of n and passing on that value of n here or maybe here it is n is the argument <sil=0.964> .PERIOD So <sil=0.590> ,COMMA might be the main program is reading a value num and passing that value num here <sil=0.985> .PERIOD Now <sil=0.324> ,COMMA this num is also type integer and the rest of the things are being done by the function <sil=0.940> .PERIOD It is testing whether it is divisible by 7 if it is divisible by 7 is printing like that otherwise it is printing the other message <sil=0.956> .PERIOD Now <sil=0.464> ,COMMA in this case putting this return is optional because if n if I did not put the return because even if I did not put the return when I would have met this parenthesis this n bracket it would automatically return to the calling point <sil=0.936> .PERIOD However <sil=0.313> ,COMMA there is no harm if I put the return <sil=0.943> .PERIOD So <sil=0.523> ,COMMA returning control we have seen that how the thing is invoked by parameter passing <sil=0.975> .PERIOD Now <sil=0.353> ,COMMA returning control if nothing is returned then you can simply write return semicolon or we can skip that and until it comes to the right brace that is last right brace that is automatically taken as the return <sil=0.944> .PERIOD But if something is to be returned if something is to be returned then we must put the return statement with say may be return a times b some expression or it could be return c or it could be something <sil=0.989> .PERIOD Like return 0 or return 1 whatever we have to do something some expression and expression automatically or I mean you know will also capture the constants <sil=0.961> .PERIOD So <sil=0.306> ,COMMA now let us look at this example here you see the layout is also important here we are first writing the function the function declaration is coming first square of x square of an integer x and square of an integer x will also be an integer <sil=0.967> .PERIOD Therefore <sil=0.336> ,COMMA the type of the function is int as you can see here <sil=0.990> .PERIOD So <sil=0.428> ,COMMA that is this whole thing is the function declaration then starts the body of the function <sil=0.909> .PERIOD So <sil=0.595> ,COMMA here the function declaration consists of the name of the function and the parameter that is x of type integer and this int here is a return data type the type of the data type that will be returned <sil=0.925> .PERIOD So <sil=0.481> ,COMMA these three together make the function declaration next we are coming to the body of the function int y what is that that is a temporary variable <sil=0.966> .PERIOD Temporary variable why I am calling it temporary because it leaves as long as this function is active as soon as the function is function ends the role the definition of this y is also lost <sil=0.958> .PERIOD So <sil=0.584> ,COMMA here you see will come to that later but here you see that this is an internal variable here I am computing the square y assigned x times x and I am returning y and after return that y vanishes <sil=0.949> .PERIOD Why where is y returning to wherever the square has been called now here you see here is a sum of square what is mean doing now let us come to mean mean has got some variables a b and sum of square is another variable <sil=0.939> .PERIOD So <sil=0.360> ,COMMA print f g v and b I am reading a and b now I am calling this function twice first with the parameter a next with the parameter b and a and b how I mean in sequence goes to this argument x and the square of a is computed <sil=0.961> .PERIOD So <sil=0.591> ,COMMA return y will return first here a square so we get a square here then this is called and y is returned here so we get b square and then these two are added and we get sum of square <sil=0.951> .PERIOD So <sil=0.472> ,COMMA you need to you can also try to see what is a flow of data in such cases let us move ahead <sil=0.925> .PERIOD So <sil=0.366> ,COMMA these are the parameters past and here are the here is the argument you can see that now invoking a function call here the same thing what is happening when the thing that I just now explain when I am saying now let us see what happens the variables assume that the value of a that is been read here is 10 then square of a mean square of 10 so 10 goes to x <sil=0.911> .PERIOD So <sil=0.380> ,COMMA a is 10 here that goes to x so x becomes 10 now we compute y which is 10 times 10 I am getting y y is becoming 100 right now this 100 is coming here actually actually the saddle is a little wrong here so it will be actually coming to this point clear <sil=0.906> .PERIOD So <sil=0.461> ,COMMA in that case similarly it will be for b if b was some value that is how then x suppose b was 7 then x will get 7 and then y will be 49 and 49 will come to that square of b <sil=0.982> .PERIOD So <sil=0.471> ,COMMA 100 plus 49 will now be added and will be kept as the sum of square <sil=0.970> .PERIOD So <sil=0.366> ,COMMA in the earlier example you could see that in the earlier example the first the function was written and then the mean <sil=0.938> .PERIOD Now <sil=0.367> ,COMMA let us look at go ahead function definition so we have seen that a function name preceded by a return value type and declaration statement and then the function body I am repeating certain things variables can be declared declared inside the blocks the blocks can be nested that means they can be multiple blocks function cannot be defined inside another function <sil=0.956> .PERIOD This must be clearly understood a function cannot be defined within another function and returning of control the control will have to be returned as we have seen if nothing returned then return we have already seen that if something is returned then return that expression here again another example of function the more examples you do the better you will understand <sil=1.000> .PERIOD Here the function as the name implies you see it is always better to use meaningful names for functions some of digits of n <sil=0.942> .PERIOD So <sil=0.625> ,COMMA if there be number like 125 then I am trying to extract this digits 1 plus 2 plus 5 so that will be 8 that is what my program wants to do <sil=0.931> .PERIOD So <sil=0.361> ,COMMA initially some is equal to 0 while n is not equal to 0 some is some plus remainder so 125 if I divide by 10 then I will have 12 here and remainder is 5 so some plus 5 so some becomes 5 <sil=0.907> .PERIOD Now <sil=0.604> ,COMMA then we find out the device dividend that is 12 and again divide that by 10 we get 2 to be the remainder so we take some to be 5 plus 2 and so on so forth ultimately I am getting the sum so return some this another example of a function here you can see that we have to be given the number of digits <sil=0.938> .PERIOD You can see that this n is coming as a parameter all this sum sum is an internal variable and will not have life beyond the body of the program <sil=0.941> .PERIOD So <sil=0.588> ,COMMA here you see some of digits is a function name int is a return data type parameter list is that local variable is some some is a local variable and return statement is return some clear all this we have already discussed this is merely a division and here you can see that the return can have an expression here only a variable is an expression <sil=0.990> .PERIOD Now <sil=0.572> ,COMMA we come to a very important concept which I was mentioning in the passing that the life of an intern variable internal to a function exists as long as the function is live as long as the function is active <sil=0.962> .PERIOD Now <sil=0.604> ,COMMA that formally is known is called the scope of the variable or the variable scope <sil=0.972> .PERIOD So <sil=0.494> ,COMMA let us look here there is an interesting program <sil=0.994> .PERIOD Now <sil=0.348> ,COMMA here you see my entry point is the main but even before that I have declared a variable int a that means this a is a global variable <sil=0.979> .PERIOD That means it is there always suppose it is a value 100 then it remains that this is retained <sil=0.920> .PERIOD So <sil=0.456> ,COMMA let us keep this and let us see what happens <sil=0.912> .PERIOD Now <sil=0.475> ,COMMA I am entering main and I have assigned a to 1 now that means now inside this function inside this main I have got mains a which is another a let me write it in is it visible let me let me do it in a better way <sil=0.934> .PERIOD So <sil=0.406> ,COMMA there is 1 a I am calling that a g that is this a is a g that is the globally and suppose that is 100 <sil=0.940> .PERIOD Now <sil=0.498> ,COMMA this is another a which is defined in the main so the function this will be live inside main so let me call it a m <sil=0.911> .PERIOD So <sil=0.621> ,COMMA now a becomes 1 here as I come here a 1 then I am calling my proc a function my proc from here it comes to my proc and suppose my proc has got another a here <sil=0.931> .PERIOD So <sil=0.584> ,COMMA let me call that to be a x just for understanding that it is of my proc or let me call it let me call it of the function <sil=0.959> .PERIOD Now <sil=0.621> ,COMMA that is initialize to 2 now you see how many different a's I have multiple a's now inside this block I initialize another a to be 3 <sil=0.949> .PERIOD So <sil=0.357> ,COMMA that is another a that means this one is not being disturbed a is to when while a is to I am making another a because here I am declaring you see this is a pure declaration in t <sil=0.913> .PERIOD If I had just written a if I had just written a assign 3 then this a would be assign 3 but here I have declared another a in t therefore <sil=0.417> ,COMMA there is another a coming within this while block that I am calling a b and that is becoming 3 <sil=0.964> .PERIOD Now <sil=0.387> ,COMMA I am printing a which a will be printed the inner most the current a that means 3 will be printed then I break break means what I come out of the while loop we have learnt break so we come out of the while loop and then I print a which is so as soon as I break out of this this is gone no longer live <sil=0.974> .PERIOD So <sil=0.496> ,COMMA I am coming here now which a is in my scope which a is in my scope my scope is this I am within this function so these say so that will be printed here so 2 <sil=0.936> .PERIOD So <sil=0.344> ,COMMA there is some backstation I am ignoring them that will come one of another and then I come out of this it is over so I go to this main fun go back sorry not here I am sorry I am sorry it should go back to this point that means I will now execute print which a is in my scope now I have come out of this <sil=0.955> .PERIOD From out of this function so the its scope is also gone so the scope of this function main is now live so what is the value one so that will be printed that is how the things will be printed so we will repeat it if necessary but let us try to see the execution now <sil=0.944> .PERIOD So <sil=0.451> ,COMMA if I first do it then this one will be printed a assign 3 next that is gone so here a will be this will be assigned a assign 2 then I will go up there and the a that is in the scope of this function that will be assigned and then so that will be assigned <sil=0.915> .PERIOD You see although I declared a global a internally when I declare some other a this global a I have look here a point has to be seen I declared a a global a here a global a was here a g that was declared <sil=0.951> .PERIOD Here I have assigned to a I have not declared another a I have not written in the I have simply written a assigned one that means the a that was there is already existing globally that has been assigned one <sil=0.997> .PERIOD But when I come here and I am declaring int a internally inside this process another a is created which is the a of the function and that is assigned by with to 2 not this one they are two distinct entities now again here I have declared another a <sil=0.959> .PERIOD So <sil=0.511> ,COMMA since I have declared another a this is the a of this while loop might be and that is becoming 3 and accordingly the corresponding whenever I say print which one will be printed which one will be printed will be the one that is within its scope this a is in the scope of this so that was printed this and gone this a was in the scope of this <sil=0.903> .PERIOD So <sil=0.320> ,COMMA this is so printed and gone and this a is in the scope of this and this is so this is known as the scope of variables <sil=0.909> .PERIOD So <sil=0.318> ,COMMA if we summarize functions you can see this I do not know how much is visible <sil=0.915> .PERIOD So <sil=0.469> ,COMMA main function I am calling a function factorial and we have already seen that and then the function is having different it is a self contained program which has got its definite named function definition <sil=0.903> .PERIOD Where the type of the argument is also specified now main is a function and here I am calling a function I am actually calling a function by name calling by name and is a return data type repeating that the function name is there the parameter is there and the return statement <sil=0.931> .PERIOD And the other variables like temp and all those are local variables we have repeated now some point is a function cannot be defined within another function which we have told but I am repeating it again all function definitions must be disjoint that means I cannot define one function within another nested function calls are allowed what is meant by nested function called nested function <sil=0.957> .PERIOD nested function called means that suppose here is a main program going on I call a function this is function say f 1 and this was my main from some point in the function in order to solve this problem f 1 I may call another function f 2 this is nesting calling but not defined they are defined separately f 1 defined separately f 2 defined separately m defined separately now from f 2 I may call another function f 3 and f 3 completes f 2 has called f 3 because of some reason <sil=0.959> .PERIOD So <sil=0.426> ,COMMA that reason is answered I mean for some value or for some computation that computation has been done from here it returns to the point from where it was called so this is a return point <sil=0.919> .PERIOD So <sil=0.348> ,COMMA is it clear or should I use some other color for the return point is it necessary <sil=0.975> .PERIOD So <sil=0.466> ,COMMA I am not getting the color so let me let me use the existing color whatever was there so where did not go <sil=0.928> .PERIOD So <sil=0.572> ,COMMA from here now the color has come so I can show the return here I am returning but then again I am continuing with this function and when f 2 is over then I again return to f 1 <sil=0.975> .PERIOD So <sil=0.424> ,COMMA it was called f 1 called f 2 for some purpose that purpose is solved so I return here and then f 1 continues again in its whatever it was doing and f 1 was called by mean for some particular reason when that purpose is served then we return to this point and then main continues and ultimately main ends with this function <sil=0.929> .PERIOD Now <sil=0.441> ,COMMA here this is known as nesting that means I nesting of calls so I have made a call and from that call I can make another call from there I can make another call but the point to point to note is that all these functions must be independently and separately defined <sil=0.976> .PERIOD They cannot be defined one among the other so nested function calls are allowed a calls b b calls c as I have shown m calls f 1 f 1 calls f 2 f 2 calls f 3 like that it can happen <sil=0.923> .PERIOD The function called last will be the first return obviously we have seen that in our earlier slide that we go back to the f 4 from f 4 I return to f 2 and like that and so a function can call also call itself either directly or in a cycle we will see this separately what is made by that a calls b this is this function is called as f 2 <sil=0.967> .PERIOD This can mean two ways one is that say a calls b b calls c calls back a that is possible like say here if we see that mean was running it called f 1 called f 1 f 1 called f 2 <sil=0.954> .PERIOD And then f 2 can again call f 1 and then this call ultimately for this call the return has to come here and ultimately it will have to return here etcetera <sil=0.996> .PERIOD So <sil=0.531> ,COMMA this part will have to see separately that is it is a function one function is calling another and that can mean a cycle f 1 calling f 2 calling f 1 it can happen or recursion means say a particular function f 1 calling itself f 1 is calling itself a number of times that requires a special attention and a special discussion that we have to carry out <sil=0.982> .PERIOD We will do that in the subsequently but right now just let us remember that this calls can be in a cycle or it can be called to itself which is a recursion <sil=0.964> .PERIOD Now <sil=0.567> ,COMMA we have got some math library functions which perform common mathematical calculations and I do not remember whether in an earlier class I mistakenly said that I had mistakenly I do not remember exactly whether I did that or not that you need to include just as we include math dot STDIO dot H <sil=0.951> .PERIOD Similarly <sil=0.488> ,COMMA we have to include math dot H <sil=0.947> .PERIOD So <sil=0.482> ,COMMA just as we include STDIO dot H if we use some mathematical functions which are already available in the C library we have to include math dot H <sil=0.920> .PERIOD I do not remember whether while first introducing the square root function I have might be mistakenly mistakenly I wrote math dot lib that is library function <sil=0.959> .PERIOD So <sil=0.344> ,COMMA dot lib if I had said that you should ignore it is math dot H include math dot H and so here there is an important thing <sil=0.964> .PERIOD When I compile you know any function that we any program that we write we have to compile it in order to get an executable code <sil=0.957> .PERIOD Now <sil=0.513> ,COMMA in your exercises you must have done by now that typically you compile a C program like this C C myproc dot C <sil=0.941> .PERIOD But if you use some mathematical library in your function then you should write C C minus L M myproc dot C or that means link to the mathematical library <sil=0.971> .PERIOD You compile first you compile now you see what is happening is the mathematical libraries are here say some square root function somebody has written for you and that is in the C library <sil=0.909> .PERIOD Maybe some other function like two upper which converts from lower case to upper case all these things are there <sil=0.975> .PERIOD Now <sil=0.520> ,COMMA two upper is a separate library where square root is a math library <sil=0.958> .PERIOD So <sil=0.320> ,COMMA if in your function you if in your program you write you refer to the square root some mathematical library then you must do this why because purely myproc dot C will generate some object code <sil=0.954> .PERIOD Now <sil=0.483> ,COMMA the code for this has to be linked to this has to be linked so that your ultimate is a full executable code also takes this into account this code linked to this code will be forming your executable code because the square root will need anyway at the time of running it <sil=0.934> .PERIOD So <sil=0.557> ,COMMA here it has is shown minus element the later also C C program name and then link with the mathematical library format for calling the functions <sil=0.920> .PERIOD So <sil=0.648> ,COMMA forget about this let us make it for the time being ignored this just say percentage F function name <sil=0.979> .PERIOD So <sil=0.484> ,COMMA this is point number one there are many mathematical library functions in order to include in order to use them we have to include immediately after a studio dot H hash include math dot H and we must use this give this linking command <sil=0.902> .PERIOD Now <sil=0.562> ,COMMA when we call the function the function name argument if multiple arguments then we can use a comma separated list say for example <sil=0.481> ,COMMA if some format the square root 9 there is only one argument not much arguments may be constant variables or expressions all math now this is important all math functions all math functions return the data type double this is important you should keep in mind this for C <sil=0.936> .PERIOD All the math functions are returning the data type double so in order to make it compatible with the variable where you accept the value return by the math function that should also be double arguments may be constants or variables <sil=0.996> .PERIOD So <sil=0.395> ,COMMA here are some examples of math library function like finding the cost of some angle x finding the sign that all these functions are known as assign a cause a tan inverse tan arc tan ceiling function flow or function flow or function means it finds the greatest largest integral value that is less than x suppose some is 200 <sil=0.900> .PERIOD 56 so the largest integral value is 200 that is the flow or function <sil=0.997> .PERIOD So <sil=0.491> ,COMMA a cause is finding the cost of an angle in degree whereas a cause sorry cause is for finding the cosine of an angle in radian now there is no point in memorizing them as and when you need them look at the manual look at the book and very soon you will get a custom to the different library which are available for C <sil=0.962> .PERIOD And we will come back to this in the next lecture about some more well known functions which you have already encountered with and then we will proceed further with recursion <sil=0.911> .PERIOD Thank you <sil=0.942> .PERIOD Till now <sil=0.397> ,COMMA we have learnt about some constructs of programming to implement some very generalized structures <sil=0.571> ,COMMA programming structures <sil=0.928> .PERIOD What are they <sil=0.909> ?QUESTIONMARK First <sil=0.606> ,COMMA we have seen how we can do branching <sil=0.628> ,COMMA right <sil=0.933> .PERIOD And branching means that whenever there is a sequential flow <sil=0.415> ,COMMA we take a decision we come to a decision box and depending on whether the result is true or false <sil=0.513> ,COMMA we take different paths <sil=0.455> ,COMMA right <sil=0.901> .PERIOD That is what we have seen and that is implemented by F L's statement <sil=0.596> ,COMMA right <sil=0.919> .PERIOD We have seen that <sil=0.909> .PERIOD The other thing that we have learnt is <sil=0.385> ,COMMA repetition or looping <sil=0.554> ,COMMA all right <sil=0.981> .PERIOD That means we have come to a particular point <sil=0.385> ,COMMA we take a decision and based on the decision <sil=0.521> ,COMMA we decide whether we will go back to an earlier point or we will continue forward <sil=0.308> ,COMMA okay <sil=0.928> .PERIOD So <sil=0.475> ,COMMA this is this repetition <sil=0.577> ,COMMA we have we could achieve by while statement <sil=0.392> ,COMMA do while statement or while do statement or for statement <sil=0.994> .PERIOD So <sil=0.347> ,COMMA if else and do while do for all these are constructs in the C language <sil=0.423> ,COMMA whereas the concept of branching and repetition or looping is general for most of the programming languages <sil=0.915> .PERIOD So <sil=0.621> ,COMMA these are general concept while while this is a specific construct corresponding to the C language <sil=0.966> .PERIOD Now <sil=0.301> ,COMMA to start our journey into the world of real examples <sil=0.502> ,COMMA let us first start with the school level equation solving when we try try to solve a quadratic equation of the form A x square plus B x plus C equals 0 <sil=0.968> .PERIOD We try to solve it means we wanted to find the roots of the equation <sil=0.451> ,COMMA roots of the equation of this form and what are the roots <sil=0.927> ?QUESTIONMARK The roots are the values of x that will satisfy this equation <sil=0.956> .PERIOD For example <sil=0.376> ,COMMA I can have 3 x square plus 5 x plus 1 equals 0 <sil=0.388> ,COMMA all right <sil=0.991> .PERIOD What are the values of x that we will solve that will solve this <sil=0.311> ,COMMA right <sil=0.949> .PERIOD So <sil=0.454> ,COMMA we knew we know that we can solve this general equation that is x is minus B plus minus root over B square minus 4 AC divided by 2 A <sil=0.988> .PERIOD By this <sil=0.569> ,COMMA we can find the roots of this equation and since it is a quadratic equation <sil=0.406> ,COMMA how many roots will be there <sil=0.865> ?QUESTIONMARK There will be 2 roots <sil=0.947> .PERIOD We also know that if B square minus 4 AC is equal to 0 <sil=0.393> ,COMMA then this part will be 0 <sil=0.546> ,COMMA what will be the roots <sil=0.882> ?QUESTIONMARK Roots will be minus B by 2 A only <sil=0.988> .PERIOD So <sil=0.518> ,COMMA there will be 2 roots which are equal the same roots <sil=0.980> .PERIOD For example <sil=0.406> ,COMMA if I have x minus a whole square that is equal to x square minus 2 A x plus what will that be plus a square <sil=0.319> ,COMMA right <sil=0.901> .PERIOD Now <sil=0.303> ,COMMA if I saw and if I say that this is equal to 0 <sil=0.471> ,COMMA from here I say that this is equal to 0 <sil=0.968> .PERIOD So <sil=0.510> ,COMMA if I solve it <sil=0.512> ,COMMA I will make this as x minus a whole square and that means x assigned A will be the root <sil=0.396> ,COMMA right <sil=0.915> .PERIOD That means x minus a is 0 <sil=0.922> .PERIOD So <sil=0.430> ,COMMA x both the roots will be equal <sil=0.971> .PERIOD So <sil=0.319> ,COMMA if I have root over B square minus 4 AC equal to 0 <sil=0.556> ,COMMA in that case I will have both the roots equal <sil=0.984> .PERIOD If root over B square minus 4 AC is negative <sil=0.636> ,COMMA we know then our roots which are minus B plus minus root over B square minus 4 AC by 2 A <sil=0.975> .PERIOD If this part is negative <sil=0.384> ,COMMA then the roots will be imaginary <sil=0.512> ,COMMA right <sil=0.990> .PERIOD If B square minus 4 AC is greater than 0 <sil=0.353> ,COMMA then we will have real roots <sil=0.300> ,COMMA right <sil=0.998> .PERIOD And the real roots will be minus B plus this and minus B minus this by 2 A <sil=0.981> .PERIOD So <sil=0.444> ,COMMA that will be that is a school level knowledge that we have <sil=0.926> .PERIOD Now <sil=0.520> ,COMMA if I want to apply this knowledge to write a program <sil=0.649> ,COMMA that can take as input any equation of that form A x square plus B x plus C and find its root <sil=0.601> ,COMMA how will the program look like <sil=0.906> .PERIOD Suppose <sil=0.464> ,COMMA I want to write such a program and now henceforth in my discussion about this problem <sil=0.325> ,COMMA I will call this B square minus 4 AC to be the discriminant <sil=0.984> .PERIOD I write it for short <sil=0.593> ,COMMA DISC as the discriminant <sil=0.907> .PERIOD Because that is what is telling me discriminating between the roots DISC <sil=0.911> .PERIOD So <sil=0.334> ,COMMA whenever I refer to discriminant <sil=0.563> ,COMMA that means I am talking of B square minus 4 AC <sil=0.909> .PERIOD Now <sil=0.436> ,COMMA I want to write a generalized program for finding the roots of A x square plus B x plus C <sil=0.935> .PERIOD So <sil=0.389> ,COMMA equal to 0 <sil=0.999> .PERIOD So <sil=0.459> ,COMMA I want to write a program that will be equally applicable to solve this root <sil=0.507> ,COMMA this equation <sil=0.596> ,COMMA solve this equation or 25 A x square plus <sil=0.611> ,COMMA sorry <sil=0.470> ,COMMA here I should not write C <sil=0.915> .PERIOD Let me put it something like 5 <sil=0.347> ,COMMA 25 A x square plus 17 equals 0 or any such equation <sil=0.965> .PERIOD So <sil=0.429> ,COMMA you see here <sil=0.582> ,COMMA what is the coefficient of x <sil=0.881> ?QUESTIONMARK coefficient of x square is 25 <sil=0.917> .PERIOD What is the coefficient of x in this equation <sil=0.885> ?QUESTIONMARK It is 0 <sil=0.344> ,COMMA that is why this term has vanished <sil=0.935> .PERIOD And what is the value of C here <sil=0.908> ?QUESTIONMARK 17 <sil=0.964> .PERIOD Whereas <sil=0.561> ,COMMA in this equation <sil=0.624> ,COMMA the coefficient of x is 3 <sil=0.344> ,COMMA x square is 3 <sil=0.350> ,COMMA the coefficient of x is 4 and the constant term is 5 <sil=0.960> .PERIOD So <sil=0.602> ,COMMA since I am going to solve any general equation of this form <sil=0.578> ,COMMA how can I define the specific equation <sil=0.909> ?QUESTIONMARK An equation of this form can be specified by specifying the coefficients <sil=0.960> .PERIOD So <sil=0.540> ,COMMA I have to accept the values of A <sil=0.417> ,COMMA B and C from the user <sil=0.904> .PERIOD And you can see that the root is dependent on the value of these coefficients because we know the root x is minus B plus root over B square minus 4 AC by 2 A <sil=0.908> .PERIOD So <sil=0.533> ,COMMA the roots are determined only by the value of these coefficients <sil=0.946> .PERIOD Therefore <sil=0.402> ,COMMA the first step that I will have to do here <sil=0.323> ,COMMA we can start with the flow chart <sil=0.952> .PERIOD So <sil=0.649> ,COMMA I will first <sil=0.490> ,COMMA I write read A <sil=0.418> ,COMMA B <sil=0.555> ,COMMA C <sil=0.506> ,COMMA read them from the user <sil=0.964> .PERIOD Then <sil=0.484> ,COMMA I compute <sil=0.493> ,COMMA find discriminatory <sil=0.973> .PERIOD And equal to B square minus 4 AC <sil=0.321> ,COMMA I just compute this part <sil=0.940> .PERIOD B square minus 4 AC because depending on this <sil=0.413> ,COMMA we will have the different values of the root <sil=0.912> .PERIOD Or I would say <sil=0.351> ,COMMA alright <sil=0.564> ,COMMA alright <sil=0.447> .PERIOD So <sil=0.370> ,COMMA now <sil=0.619> ,COMMA so earlier to earlier I said that the discriminant is root over B square minus 4 AC <sil=0.990> .PERIOD I would like to correct myself <sil=0.926> .PERIOD I would say discriminant is this part B square minus 4 AC because depending on the value of this <sil=0.631> ,COMMA if this is negative <sil=0.615> ,COMMA then the roots will be imaginary because the square root of this will be imaginary <sil=0.929> .PERIOD So <sil=0.372> ,COMMA this is the discriminant part <sil=0.969> .PERIOD If this is 0 <sil=0.597> ,COMMA then the roots are equal <sil=0.339> .PERIOD If this is greater than 0 <sil=0.382> ,COMMA then the roots are positive and real <sil=0.977> .PERIOD And if it is negative <sil=0.611> ,COMMA then the roots are imaginary <sil=0.981> .PERIOD So <sil=0.607> ,COMMA at this point <sil=0.305> ,COMMA I will make a decision <sil=0.944> .PERIOD So <sil=0.506> ,COMMA I will make a decision <sil=0.911> .PERIOD And greater than 0 <sil=0.459> ,COMMA yes <sil=0.539> .PERIOD Then <sil=0.625> ,COMMA what shall I do <sil=0.972> ?QUESTIONMARK I will print roots are real <sil=0.933> .PERIOD And then <sil=0.628> ,COMMA I will print the roots <sil=0.942> .PERIOD If the discriminant is not greater than 0 <sil=0.482> ,COMMA then I come here and I check whether discriminant is 0 <sil=0.370> ,COMMA if yes <sil=0.342> ,COMMA then my decision is roots are equal and then <sil=0.568> ,COMMA I go and print the roots <sil=0.929> .PERIOD If this is no <sil=0.486> ,COMMA then obviously <sil=0.311> ,COMMA I will print imaginary roots <sil=0.908> .PERIOD I can see this part and then <sil=0.413> ,COMMA I will go and print the roots <sil=0.982> .PERIOD That is the flow chart of the whole thing <sil=0.958> .PERIOD So <sil=0.485> ,COMMA I am computing this value and based on that <sil=0.533> ,COMMA I am finding the roots <sil=0.935> .PERIOD Now <sil=0.650> ,COMMA if the flow chart is clear to you <sil=0.310> ,COMMA let us proceed to write the program for this <sil=0.902> .PERIOD Now <sil=0.384> ,COMMA here <sil=0.601> ,COMMA obviously <sil=0.458> ,COMMA I should have said that the discriminant is actually this part <sil=0.393> ,COMMA b square minus 4 <sil=0.608> ,COMMA and then <sil=0.590> ,COMMA I take the square root of that <sil=0.932> .PERIOD So <sil=0.649> ,COMMA now <sil=0.349> ,COMMA if we start writing the program <sil=0.587> ,COMMA if I am a nice programmer <sil=0.568> ,COMMA I will always start with <sil=0.571> ,COMMA so first <sil=0.610> ,COMMA of course <sil=0.451> ,COMMA has include STDIO <sil=0.925> .PERIOD H <sil=0.930> .PERIOD Then <sil=0.503> ,COMMA I am including another thing <sil=0.469> ,COMMA which is a library <sil=0.997> .PERIOD called math <sil=0.946> .PERIOD leaf <sil=0.942> .PERIOD leaf stands for library <sil=0.986> .PERIOD Why I am including that <sil=0.992> ?QUESTIONMARK I will come to that later <sil=0.911> .PERIOD Now <sil=0.300> ,COMMA we start our program main and we start <sil=0.909> .PERIOD I can give a comment <sil=0.967> .PERIOD And program to find roots of a quadratic equation <sil=0.917> .PERIOD So <sil=0.510> ,COMMA that is the comment <sil=0.960> .PERIOD So <sil=0.456> ,COMMA anybody can understand what I am writing here <sil=0.927> .PERIOD Now <sil=0.406> ,COMMA I will have to declare a number of variables <sil=0.987> .PERIOD I will declare <sil=0.534> ,COMMA let us say <sil=0.301> ,COMMA the coefficients are all integers <sil=0.979> .PERIOD So <sil=0.397> ,COMMA int a b c <sil=0.992> .PERIOD Now <sil=0.628> ,COMMA b square minus 4 is <sil=0.565> ,COMMA you can be anything <sil=0.911> .PERIOD So <sil=0.566> ,COMMA I put float discriminant <sil=0.962> .PERIOD Also <sil=0.560> ,COMMA float root 1 root 2 roots <sil=0.903> .PERIOD Next <sil=0.578> ,COMMA what should I do <sil=0.858> ?QUESTIONMARK Let me proceed to the next page <sil=0.926> .PERIOD With this declarations <sil=0.472> ,COMMA I hope you have been able to take down this declarations <sil=0.943> .PERIOD Now <sil=0.441> ,COMMA let us proceed and go to the next page <sil=0.920> .PERIOD I am continuing with that <sil=0.900> .PERIOD I start with printf <sil=0.961> .PERIOD Enter coefficients a then b then c <sil=0.977> .PERIOD So <sil=0.638> ,COMMA the user is told that he is supposed to enter the coefficients <sil=0.967> .PERIOD Now <sil=0.500> ,COMMA next thing will be scanf <sil=0.945> .PERIOD Since <sil=0.484> ,COMMA I know I can also say that please enter integer coefficients <sil=0.941> .PERIOD I am just restricting it here like that <sil=0.947> .PERIOD Though it is not necessary <sil=0.942> .PERIOD So <sil=0.621> ,COMMA scanf percentage d <sil=0.613> ,COMMA percentage d <sil=0.611> ,COMMA and b and c <sil=0.929> .PERIOD So <sil=0.314> ,COMMA what I will do <sil=0.885> ?QUESTIONMARK My system will read the three integers a <sil=0.640> ,COMMA b and c <sil=0.922> .PERIOD Now <sil=0.426> ,COMMA start the main program <sil=0.974> .PERIOD And as if you have studied the flow chart that I had shown here <sil=0.505> ,COMMA here you can see that I have got only one decision box <sil=0.944> .PERIOD And I can proceed through that decision box <sil=0.922> .PERIOD There are two decision boxes actually <sil=0.377> ,COMMA one in this direction <sil=0.613> ,COMMA another in this direction <sil=0.989> .PERIOD So <sil=0.320> ,COMMA accordingly I do not have any loop here <sil=0.951> .PERIOD So <sil=0.380> ,COMMA what is the construct that I will be needing here <sil=0.859> ?QUESTIONMARK The construct that I will be needing here is if <sil=0.948> .PERIOD So <sil=0.313> ,COMMA what should I do <sil=0.957> ?QUESTIONMARK First <sil=0.631> ,COMMA let me compute the discriminant <sil=0.950> .PERIOD I have got b <sil=0.380> ,COMMA a and c <sil=0.926> .PERIOD So <sil=0.367> ,COMMA I do <sil=0.904> .PERIOD Discriminant assigned b square minus 4 a <sil=0.310> ,COMMA c <sil=0.907> .PERIOD So <sil=0.439> ,COMMA b times b minus 4 times a times c <sil=0.940> .PERIOD So <sil=0.313> ,COMMA this is an arithmetic expression <sil=0.986> .PERIOD I get discriminant <sil=0.957> .PERIOD Now <sil=0.644> ,COMMA I will have to take the path depending on the discriminant <sil=0.903> .PERIOD So <sil=0.482> ,COMMA what I will write here is if then apparent thesis for the condition <sil=0.918> .PERIOD If discriminant is greater than 0 <sil=0.514> ,COMMA greater than 0 <sil=0.336> ,COMMA print F <sil=0.487> ,COMMA roots are real <sil=0.923> .PERIOD And I can put a backslash in here <sil=0.907> .PERIOD Else <sil=0.529> ,COMMA I have not computed the roots as yet <sil=0.962> .PERIOD So <sil=0.314> ,COMMA let me write the roots as close to the E as possible as we have learnt about indentation <sil=0.901> .PERIOD So <sil=0.644> ,COMMA else <sil=0.531> ,COMMA if I should have written this if also in small just for the sake of uniformity <sil=0.916> .PERIOD And not only for the sake of uniformity <sil=0.367> ,COMMA c is very much case sensitive <sil=0.989> .PERIOD So <sil=0.407> ,COMMA capital I f is not if <sil=0.976> .PERIOD So <sil=0.311> ,COMMA if discriminant is equal to 0 <sil=0.358> ,COMMA print F <sil=0.588> ,COMMA roots are equal <sil=0.365> ,COMMA backslash and else <sil=0.934> .PERIOD Else <sil=0.573> ,COMMA now this else comes under this if you remember that else and ifs are tighter based on the closest <sil=0.391> ,COMMA the else is connected to the closest the closest <sil=0.902> .PERIOD So <sil=0.511> ,COMMA these two else <sil=0.386> ,COMMA else the only option is discriminant is neither greater than 0 <sil=0.418> ,COMMA not equal to 0 <sil=0.950> .PERIOD So <sil=0.484> ,COMMA discriminant is less than 0 <sil=0.533> ,COMMA then print F <sil=0.394> ,COMMA roots are imaginary <sil=0.457> ,COMMA backslash and again <sil=0.981> .PERIOD Now <sil=0.601> ,COMMA so I have just said what type of roots they are <sil=0.568> ,COMMA but I have not printed the roots as yet <sil=0.987> .PERIOD We have not found out the roots <sil=0.948> .PERIOD So <sil=0.324> ,COMMA what I can do <sil=0.902> ?QUESTIONMARK I can modify this a little bit or how do I find out the roots <sil=0.908> ?QUESTIONMARK Let me go to the next page <sil=0.956> .PERIOD I do this and then I come back to a particular stage or I can I can I can do it here itself <sil=0.968> .PERIOD How do I how do I find out the roots <sil=0.979> ?QUESTIONMARK Say <sil=0.428> ,COMMA let me go back and do it here <sil=0.958> .PERIOD Here I have I have not written down what the roots are <sil=0.952> .PERIOD How could I suppose I modify this part a little bit <sil=0.893> ?QUESTIONMARK I modify this part a little bit <sil=0.989> .PERIOD So <sil=0.478> ,COMMA let me modify this part <sil=0.475> ,COMMA I will rewrite this part in the next page <sil=0.939> .PERIOD So <sil=0.403> ,COMMA I rewrite it as if disk is greater than 0 <sil=0.359> ,COMMA print F <sil=0.595> ,COMMA roots are greater than 0 <sil=0.432> ,COMMA real <sil=0.964> .PERIOD Now <sil=0.473> ,COMMA I compute I compute say I compute let us call it I should have declared this also discriminant one another part <sil=0.981> .PERIOD That is I had the I had the discriminant part <sil=0.926> .PERIOD So <sil=0.582> ,COMMA I can certainly make another variable <sil=0.930> .PERIOD So <sil=0.563> ,COMMA I add one more variable here in A B C and here I entered another variable say D Y I will show later <sil=0.922> .PERIOD So <sil=0.465> ,COMMA I have entered another variable there <sil=0.910> .PERIOD So <sil=0.478> ,COMMA print F roots are equal and D is square root of disk <sil=0.919> .PERIOD So <sil=0.640> ,COMMA I called disk to be B square minus 4 AC <sil=0.971> .PERIOD Now <sil=0.474> ,COMMA I am finding the root of that <sil=0.997> .PERIOD Now <sil=0.301> ,COMMA here I have committed one mistake <sil=0.970> .PERIOD Can you tell me what the mistake is <sil=0.972> ?QUESTIONMARK So <sil=0.367> ,COMMA this discriminant can be integer <sil=0.914> .PERIOD But <sil=0.553> ,COMMA when I take the square root of that it can be a float <sil=0.987> .PERIOD And also here I have already declared if you look at I look I disk I somehow declared disk as float <sil=0.919> .PERIOD But <sil=0.474> ,COMMA since A B C are integers then this will also be an integer <sil=0.944> .PERIOD So <sil=0.300> ,COMMA I should correct it a little bit <sil=0.975> .PERIOD What should I do <sil=0.887> ?QUESTIONMARK Or it really does not matter if I keep it as float <sil=0.973> .PERIOD So <sil=0.574> ,COMMA only thing is that I cannot keep the D here <sil=0.931> .PERIOD I will have to remove this D <sil=0.934> .PERIOD And I will also remove this and will make this small D as a float <sil=0.925> .PERIOD So <sil=0.612> ,COMMA then I come here D is square root of the discriminant <sil=0.914> .PERIOD Now <sil=0.385> ,COMMA what is this square root <sil=0.888> ?QUESTIONMARK Who will compute this square root <sil=0.973> ?QUESTIONMARK This square root computation is done by an inbuilt function in C library <sil=0.926> .PERIOD C compiler provides us with a library of some inbuilt function mathematical functions which we can call and invoke whenever we need them <sil=0.992> .PERIOD So <sil=0.310> ,COMMA you can see here that is why I have included this math dot leap <sil=0.911> .PERIOD That means I will be using some library function here dot leap means library <sil=0.962> .PERIOD So <sil=0.473> ,COMMA you will find in the course of this lectures and more examples where you will see more number of library functions <sil=0.997> .PERIOD But <sil=0.635> ,COMMA just for this we need the square root function <sil=0.976> .PERIOD So <sil=0.325> ,COMMA I compute the square root of disk D assign the square root of disk and then root 1 is what <sil=0.931> ?QUESTIONMARK root 1 is minus B plus D by 2 A is it clear <sil=0.897> ?QUESTIONMARK The two roots <sil=0.986> .PERIOD One is I have my formula is B plus minus root over of B square minus 4 AC by 2 A <sil=0.978> .PERIOD So <sil=0.562> ,COMMA this B square minus 4 AC is D here <sil=0.966> .PERIOD So <sil=0.327> ,COMMA B plus D whole divided by 2 A I should also put a parenthesis here is root 1 and root 2 is minus B minus B <sil=0.937> .PERIOD Minus D divided by 2 A <sil=0.915> .PERIOD Then I have got the two roots and I can print here <sil=0.965> .PERIOD So <sil=0.611> ,COMMA I have computed the roots <sil=0.925> .PERIOD So <sil=0.599> ,COMMA I can either print it here <sil=0.971> .PERIOD I can print F <sil=0.932> .PERIOD Now <sil=0.481> ,COMMA the roots can be float <sil=0.999> .PERIOD I can say the roots are R percentage F <sil=0.907> .PERIOD Roots are floats percentage F <sil=0.308> ,COMMA percentage F <sil=0.618> ,COMMA max slash N and root 1 comma root 2 <sil=0.963> .PERIOD So <sil=0.427> ,COMMA this is the whole part compound statement if disk is greater than 0 <sil=0.956> .PERIOD So <sil=0.496> ,COMMA if we go up <sil=0.937> .PERIOD So <sil=0.313> ,COMMA I will modify this part in this way <sil=0.911> .PERIOD You will also have to modify this part <sil=0.953> .PERIOD What should you do <sil=0.944> ?QUESTIONMARK Simply what can I do to write this <sil=0.972> ?QUESTIONMARK If disk is 0 then I will print roots are equal as I have written roots are real <sil=0.953> .PERIOD And then I will find out now I do not need to find out this part <sil=0.983> .PERIOD So <sil=0.632> ,COMMA let me just show you this part and I will leave the other part for you <sil=0.914> .PERIOD That second part if disk oh my god what did I do here <sil=0.865> ?QUESTIONMARK This is alright <sil=0.948> .PERIOD It is greater than equal to <sil=0.967> .PERIOD If disk is 0 then print F will be more than 1 sentences <sil=0.982> .PERIOD So <sil=0.456> ,COMMA this is coming else at else part <sil=0.996> .PERIOD Else if disk is 0 print F the roots are equal and here I do not need to bother much <sil=0.903> .PERIOD I can put a backslash in that you know by now <sil=0.992> .PERIOD Print F the roots are equal root is what <sil=0.897> ?QUESTIONMARK Now if in this B plus minus root over B square minus 4 A C by 2 A <sil=0.947> .PERIOD If this part is 0 then my root is only minus B divided by 2 A 2 multiplied by A and print F the root is percentage F backslash N root or I can say root 1 because I did not declare anything as root <sil=0.981> .PERIOD So <sil=0.459> ,COMMA root 1 any one root that is same <sil=0.902> .PERIOD This is this part if the discriminant is 0 <sil=0.936> .PERIOD See so I have just mentioned root 1 Y sorry <sil=0.905> .PERIOD You see here I declared only root 1 and root 2 I did not declare root <sil=0.902> .PERIOD So <sil=0.556> ,COMMA I can make root 1 root 2 <sil=0.957> .PERIOD Now so this is replacing this part <sil=0.984> .PERIOD Now what will you do here <sil=0.911> ?QUESTIONMARK The roots are imaginary but the same thing the values will be the same only thing is roots are imaginary <sil=0.977> .PERIOD I leave it to you as an assignment you think of what will you do for that part for the imaginary part <sil=0.949> .PERIOD You can understand that only thing that you need to do is to print some roots as say the real part real part is this and imaginary part is this <sil=0.957> .PERIOD So <sil=0.466> ,COMMA you think about it we can discuss about it in the next lecture <sil=0.907> .PERIOD So <sil=0.523> ,COMMA we saw a program where we are finding the minimum of a set of 10 numbers <sil=0.996> .PERIOD So <sil=0.605> ,COMMA here the program is restricted as you can see to 10 numbers and accordingly I have declared the array A to be of size 10 and also this iteration values are also iteration limit has been kept to 10 <sil=0.940> .PERIOD Now <sil=0.445> ,COMMA when we did that just a quick recapitulation of what we did in the last lecture that here is the array declaration and this is where we are accessing the array elements <sil=0.934> .PERIOD Here you can see I am accessing the array element A i a particular array element here and assigning that to another variable mean <sil=0.930> .PERIOD Now <sil=0.590> ,COMMA here is very important how I am by reading the element <sil=0.953> .PERIOD Now <sil=0.535> ,COMMA since an array consists of a number of elements sorry the since the array consists of a number of elements I have to read them in a loop that is a very fundamental thing that you want to should understand that at a time I cannot read the entire array in one short except for the case where I initialize it and when I declared that I give in A so and so values within curly bracket that is one way <sil=0.960> .PERIOD But <sil=0.614> ,COMMA if you have to do it at runtime that means whenever you are asking the program is running and you are asking from the user that you enter the values then you have to take one bit of value at a time just like this and store it in the array <sil=0.936> .PERIOD So <sil=0.643> ,COMMA that has to be done in a loop for by varying this indexes one of another as the index moves I load the different locations with the values <sil=0.922> .PERIOD Now <sil=0.606> ,COMMA given this we can have an alternate version of the same program you can see that here we have added one line that is this line define size 10 this is again the use of has defined that we had learnt when we defined pi to be 3 point we had encountered this we had encountered this define pi 3 point 1 4 etcetera <sil=0.976> .PERIOD So <sil=0.306> ,COMMA similarly here I am defining size a variable size to have the value 10 <sil=0.929> .PERIOD Therefore <sil=0.342> ,COMMA I now can write this dimension as size now please note that the compiler look at it from the angle of the compiler the compiler will try to allocate some memory location some amount of memory location <sil=0.957> .PERIOD Now <sil=0.315> ,COMMA if there be a variable size it really does not know how much memory location to allocate but since I have defined it earlier it now knows size means 10 <sil=0.939> .PERIOD So <sil=0.391> ,COMMA it will replace in size with in size sorry in A size to be in a size 10 <sil=0.981> .PERIOD So <sil=0.500> ,COMMA this is the size 10 <sil=0.454> ,COMMA so now next thing you do is wherever I had I less than 10 I make it size I less than size here also for the for loop I make I less than size why did I do that what is the advantage of doing it now suppose you have got this program and how many places is size being used in 1 2 3 places in another program it could have been used in more number of places here we have not printed the array I have only printed the minimum <sil=0.948> .PERIOD So <sil=0.603> ,COMMA there could be more places where size could be used now now suppose I want to modify this program I reuse this program for an array of size 100 only thing I need to do is I change this 10 to 100 and please note that after define any hash defined does not have a semicolon because these are not part of the program these are commands to the compiler or preprocessing commands <sil=0.943> .PERIOD So <sil=0.314> ,COMMA if I could make it 100 then this would be replaced by 100 it would be A 100 and here it should be I less than 100 automatically I less than 100 I need not change it at all the places that is the advantage of the hash defined <sil=0.979> .PERIOD We change we can change only one line to change the problem size the problem size from 10 to 100 to 1000 we can change by just changing one line here is another version of the program here we have not defined hash defined but I have kept a large size 100 now so I have got an array space of 100 elements 100 elements so much space is kept for me by the array of this line now what I am doing is I am asking from the user you please tell me how many elements you are going to input suppose here and that I am taking as a variable n n is a variable where I am just asking the user give the number of elements n and when the user is typing say 25 then that goes as n so out of this 25 is of course less than the size of this which is 100 is less than that <sil=0.978> .PERIOD So <sil=0.490> ,COMMA now I will just work not for 100 elements but for 25 elements why because the user has already told me that I want to input 25 elements therefore what modification should I do again here I want to make it interactive so I again tell the user on the screen you will see this message input all in integers and the user is entering them one after another okay he can type in 25 enter 35 enter 42 enter like that or he can give space and go on typing that so for I less than 0 to n now what is n n is 25 so now it is for I to I 0 to 25 I read the number so I will be doing 25 numbers here 5 20 16 12 9 etcetera etcetera I go on and I will go up to 25 not 100 all these so this space will be wasted this is a wasted space why wasted space because I had reserved 100 locations but the user has just agreed to give only 25 numbers and then the remaining part remains the same here also I will be dealing with n why n I will be at 100 boom and the market is 8 actually I know the market I lost this market for FDA can wear this market because here I have made this world for this basic market and I am going to give only some things one should not be shown as the market <sil=0.913> .PERIOD again I will be searching <sil=0.984> .PERIOD So <sil=0.461> ,COMMA when I did this the array that I got is actually although they were 200 elements the array was actually of 25 elements right the array was of 25 elements <sil=0.969> .PERIOD So <sil=0.440> ,COMMA I will have to find the minimum within this zone and I did not go here <sil=0.993> .PERIOD So <sil=0.628> ,COMMA that is another version of the same program <sil=0.969> .PERIOD So <sil=0.558> ,COMMA here what is done is we define an array of largest size and only use the required amount out of that <sil=0.912> .PERIOD Now <sil=0.520> ,COMMA let us do a programming ourselves <sil=0.990> .PERIOD Suppose I want to read the sum integers and I want to find out the sum of all the integers that old example that we had done earlier <sil=0.942> .PERIOD How did you do it earlier let us recall we did let me write it in this way sum do something like sum assign 0 then print F enter the number and scan F percentage D and NAMM sum equals sum plus NAMM and then this is to be done in a loop <sil=0.983> .PERIOD So <sil=0.323> ,COMMA what how can I make a loop out of this <sil=0.961> .PERIOD So <sil=0.604> ,COMMA I also read another variable the number of numbers <sil=0.922> .PERIOD So <sil=0.520> ,COMMA some N was read here <sil=0.967> .PERIOD So <sil=0.438> ,COMMA I had done some scan F or say let us say of 10 numbers <sil=0.920> .PERIOD So <sil=0.615> ,COMMA I need not scan F <sil=0.990> .PERIOD So <sil=0.330> ,COMMA this thing I have to loop this part I have to loop how long <sil=0.917> .PERIOD So <sil=0.528> ,COMMA what should I put here at the beginning for doing the loop for I since I know beforehand that there are 10 numbers I assign 0 I less than 10 I plus plus then I put a parenthesis here and a parenthesis here <sil=0.968> .PERIOD So <sil=0.521> ,COMMA the fourth statement comes here confusing should I write it again is it clear <sil=0.991> .PERIOD So <sil=0.541> ,COMMA I can write for I assign 0 I less than 10 I plus plus print F please enter the number backslash N then here I had done some assign 0 scan F percentage D and NAMM sum assigned sum plus NAMM that is how the loop will go on <sil=0.971> .PERIOD But here I am not remembering the number <sil=0.941> .PERIOD So <sil=0.410> ,COMMA what I can do using an array what I can do is let me now do it using an array int NAMM say 10 comma I is another integer variable <sil=0.953> .PERIOD Now <sil=0.607> ,COMMA then also I need some sorry sum is also another integer sum <sil=0.999> .PERIOD Now <sil=0.478> ,COMMA I will first read the array <sil=0.921> .PERIOD So <sil=0.543> ,COMMA first is reading the array <sil=0.985> .PERIOD So <sil=0.615> ,COMMA let me put a comment read the numbers all the numbers earlier you see the scan F every time I was doing scan F I was reading the number here I am reading the numbers and storing them <sil=0.980> .PERIOD So <sil=0.369> ,COMMA what should I do for I 0 to I less than 10 I plus plus this increment array what am I doing print F N 10 number backslash N scan F <sil=0.987> .PERIOD Now <sil=0.587> ,COMMA what should I do I am reading an integer so percentage D and amperes and what should it be what am I reading first here is an array whose name is NAMM <sil=0.935> .PERIOD So <sil=0.450> ,COMMA what is the first thing that I will be reading first thing that I will be reading is NAMM 0 this element <sil=0.909> .PERIOD So <sil=0.613> ,COMMA scan F percentage D and NAMM I Y I because I is the index and I can see that initially I is 0 <sil=0.976> .PERIOD So <sil=0.614> ,COMMA whatever is being scanned will be stored here then I will go back in this loop then the next one will be stored then the next one will be stored in this way the entire array will be stored after that I am trying to find the sum <sil=0.970> .PERIOD So <sil=0.425> ,COMMA now add the next part that I do is add the elements <sil=0.979> .PERIOD Now <sil=0.341> ,COMMA in this here I will have to again add the elements <sil=0.943> .PERIOD So <sil=0.501> ,COMMA the suppose the suppose the array that has been formed has got some elements like say 5 <sil=0.616> ,COMMA 7 <sil=0.600> ,COMMA 13 <sil=0.619> ,COMMA 12 <sil=0.423> ,COMMA 6 so and so forth <sil=0.980> .PERIOD So <sil=0.445> ,COMMA this I have to add this with this then I will get a sum and with that 12 I will be adding 13 <sil=0.977> .PERIOD So <sil=0.357> ,COMMA I will be getting 25 then 25 and 12 37 in that 12 gone <sil=0.977> .PERIOD So <sil=0.438> ,COMMA here I initialize sum to be 0 and then for again I assign the same index I can use I could have used other index also I less than 10 sorry I plus plus I hope you remember that after each of these we put a semicolon in for loop <sil=0.923> .PERIOD Some assigned sum plus num i so what will happen <sil=0.924> ?QUESTIONMARK Sum was 0 sum is 0 first in the first iteration of the loop what will happen <sil=0.867> ?QUESTIONMARK I take my value of I is 0 so num i will be taken and what is num i the first element of the num array <sil=0.931> .PERIOD So <sil=0.345> ,COMMA that is 5 sum plus 5 so sum will be 5 now <sil=0.992> .PERIOD Next I go back here I becomes 1 so I come to the second element and I add that with sum so sum becomes 12 automatically go there I take the index is updated I is being updated here so I take the third element and add with sum so it becomes 25 and in this way I go on adding them all the elements in an array <sil=0.980> .PERIOD So <sil=0.309> ,COMMA the same thing I could do using but in this case what is the advantage that I am getting <sil=0.863> ?QUESTIONMARK I have got I have not forgotten the numbers that I have read so I can do that and again I can print all these numbers I can say now the sum of these numbers is so much so that is how we can use an array <sil=0.909> .PERIOD Now suppose I had I had to find the average of the elements what should I do <sil=0.863> ?QUESTIONMARK I have got the sum here and then find average what should I do here <sil=0.902> ?QUESTIONMARK Here of course I will need another variable average and so I can say and average is sum divided by 10 <sil=0.983> .PERIOD This is a mistake another variable average and so I can say and average is sum divided by 10 <sil=0.995> .PERIOD This is a mistake that is there <sil=0.975> .PERIOD What is the mistake can you find out <sil=0.991> ?QUESTIONMARK Here I found sum that is and then I am finding the average and why I am why why I am finding the average <sil=0.888> ?QUESTIONMARK I am dividing sum whatever What is the mistake <sil=0.946> ?QUESTIONMARK Can you find out <sil=0.892> ?QUESTIONMARK Here I have found some <sil=0.329> ,COMMA that is okay and then I am finding the average and why I am finding the average <sil=0.402> ,COMMA I am dividing some whatever some I got here by the number of elements which is 10 <sil=0.943> .PERIOD I knew beforehand that these are 10 elements <sil=0.996> .PERIOD Where is the error <sil=0.870> ?QUESTIONMARK Where is the mistake <sil=0.931> ?QUESTIONMARK The mistake is that the average elements cannot be <sil=0.340> ,COMMA need not be an integer <sil=0.970> .PERIOD Suppose my sum was 25 and I divide by 10 <sil=0.983> .PERIOD So <sil=0.490> ,COMMA it will be 2 <sil=0.916> .PERIOD 5 <sil=0.918> .PERIOD Therefore <sil=0.544> ,COMMA this average should not be kept here <sil=0.964> .PERIOD I should have declared it as a float average and not with the int <sil=0.960> .PERIOD So <sil=0.621> ,COMMA you must be very careful about it <sil=0.974> .PERIOD So <sil=0.507> ,COMMA this is how <sil=0.306> ,COMMA what we have shown here is how we can read an array and how we can use an array <sil=0.940> .PERIOD So <sil=0.380> ,COMMA let us look at this example of computing the great point average of the students <sil=0.914> .PERIOD Let us try to understand what this program does <sil=0.920> .PERIOD We have defined a variable n sub to be 6 <sil=0.944> .PERIOD This n sub means number of subjects <sil=0.940> .PERIOD Now <sil=0.386> ,COMMA there are 6 subjects <sil=0.996> .PERIOD So <sil=0.404> ,COMMA 0 <sil=0.565> ,COMMA 1 <sil=0.387> ,COMMA subject 0 <sil=0.626> ,COMMA subject 1 <sil=0.541> ,COMMA subject 2 <sil=0.585> ,COMMA subject 3 <sil=0.647> ,COMMA subject 4 <sil=0.331> ,COMMA subject 5 <sil=0.979> .PERIOD Now <sil=0.581> ,COMMA for each of them we are taking a great point which is nothing but a Marxian <sil=0.519> ,COMMA an integer 3 or 5 or 6 whatever <sil=0.980> .PERIOD For every how many 6 <sil=0.894> ?QUESTIONMARK Here you see I have used defined <sil=0.995> .PERIOD So <sil=0.418> ,COMMA this line essentially means grade point 6 for 6 subjects and credit for each subject <sil=0.920> .PERIOD So <sil=0.333> ,COMMA suppose I have got the subject and the grade point and each subject has got a credit and I have got 6 subjects <sil=0.919> .PERIOD So <sil=0.439> ,COMMA subject 0 has got a grade point <sil=0.925> .PERIOD He has got a grade point of 3 maybe he has got a B grade or whatever and the credit that means the importance of that subject is 5 <sil=0.951> .PERIOD Subject 1 he has got a grade point of 5 <sil=0.950> .PERIOD He did really well here and the credit of that was also 5 <sil=0.915> .PERIOD There was another subject 2 in which his grade point was 4 and the credit of that subject was 4 <sil=0.910> .PERIOD That is the importance weightage <sil=0.901> .PERIOD The subject 3 he got 5 and the credit was 3 like that <sil=0.931> .PERIOD And since we have got 6 subjects let us do that <sil=0.905> .PERIOD Subject 4 is grade he got 3 and the importance was 4 and this one he got 5 out of 5 and the credit was again 4 <sil=0.926> .PERIOD Now <sil=0.549> ,COMMA the credit point is the grade point is computed here as for each of them we will multiply the grade point with the credit <sil=0.983> .PERIOD So <sil=0.524> ,COMMA it will be 3 times 5 that means 15 plus 5 times 5 that is 25 plus 4 times 4 that is 16 then 15 then 12 then 20 and all these are added up <sil=0.934> .PERIOD So <sil=0.504> ,COMMA 40 56 66 71 and 12 71 and 12 is 83 and 20 <sil=0.949> .PERIOD So <sil=0.561> ,COMMA he got 103 points and how many credits were there <sil=0.968> ?QUESTIONMARK 5 5 10 10 and 7 17 and 8 25 <sil=0.928> .PERIOD So <sil=0.342> ,COMMA his grade point average GPA will be when I divide this by 25 is thing will be 4 point something 4 point 1 etcetera <sil=0.931> .PERIOD So <sil=0.557> ,COMMA 4 point 1 5 or something like that <sil=0.975> .PERIOD So <sil=0.566> ,COMMA this is what I want to compute <sil=0.997> .PERIOD Therefore <sil=0.534> ,COMMA what I need is to find out that I have to find the sigma of the sum of the credit for a course I times the grade point of that course I I will do it for all the courses and then the whole thing should be divided by the total number of credits total number of credits <sil=0.984> .PERIOD Now <sil=0.482> ,COMMA let us see how we have done we can do this program here we can find that the grade point for 6 and credit for 6 and there is I the grade point sum <sil=0.905> .PERIOD So <sil=0.551> ,COMMA I have to do this sum is 0 credit sum is 0 and I have to find out a GPA <sil=0.999> .PERIOD So <sil=0.590> ,COMMA what I am asking from the user here <sil=0.871> ?QUESTIONMARK So <sil=0.452> ,COMMA the input grade points and credits for the 6 subjects <sil=0.901> .PERIOD So <sil=0.443> ,COMMA where are those being stored <sil=0.872> ?QUESTIONMARK Those are those are being stored in two different arrays <sil=0.955> .PERIOD Here is the grade point array this thing and there is another credit array 6 subjects <sil=0.907> .PERIOD So <sil=0.300> ,COMMA I read for each of the subjects I less than I 0 to n sub I read the grade point say 3 and the credit for that subject say 4 and again I go and store the grade point of that subject grade point that has been obtained is 5 and say credit is 3 <sil=0.926> .PERIOD In that way I go on filling up reading two arrays <sil=0.923> .PERIOD So <sil=0.436> ,COMMA here I am reading two arrays you see here I am reading two arrays in one scan if statement and through one for loop through one for loop I am filling up these two arrays <sil=0.916> .PERIOD So <sil=0.359> ,COMMA the reading part is complete here next I come to the computation grade point sum will be you now know what is meant by this this means grade point sum is equal to grade point sum plus grade point I times credit I <sil=0.951> .PERIOD So <sil=0.504> ,COMMA it is g p sum is whatever is the g p sum initially g p sum was made 0 g p sum plus grade point I times the credit of I and that has to be done in a loop just as we had added the elements of an array <sil=0.945> .PERIOD So <sil=0.558> ,COMMA and credit sum also I am also finding out the credit sum the credit sum was 0 <sil=0.903> .PERIOD So <sil=0.615> ,COMMA whatever the credits are I am also adding them <sil=0.907> .PERIOD So <sil=0.508> ,COMMA by adding this array I am getting the total number of credits here and here I am getting the grade point sum now the grade point I have some a grade point average is grade point sum by credit sum and then I print out the g p a <sil=0.995> .PERIOD So <sil=0.329> ,COMMA please try to understand this part what I am trying to do is sigma grade point I times credit I divided by sigma of credit I <sil=0.935> .PERIOD So <sil=0.394> ,COMMA the sigma of credit I is being computed here this is computing sigma of credit I why because this is being done in a loop and here I am doing this part sigma of grade point of I times credit I and adding that with grade point sum <sil=0.998> .PERIOD So <sil=0.649> ,COMMA these are very useful program which illustrates a number of things and in the assignments you will be given more number of programs to do which will give you a very good practice <sil=0.964> .PERIOD So <sil=0.604> ,COMMA we are looking at recursion and that is a new style of programming where we can express the particular function in terms of itself <sil=0.948> .PERIOD Like I can express factorial n in terms of factorial itself <sil=0.596> ,COMMA factorial n minus 1 and n into factorial n minus 1 <sil=0.992> .PERIOD Another very common example of an easy example of recursion is Fibonacci numbers <sil=0.903> .PERIOD We have already told you what Fibonacci sequence is <sil=0.910> .PERIOD The Fibonacci sequence can be expressed as F 0 Fibonacci 0th Fibonacci number is 0 <sil=0.942> .PERIOD The next one is all 1 and henceforth all other ones are some of the previous two <sil=0.964> .PERIOD So <sil=0.367> ,COMMA 0 <sil=0.619> ,COMMA 1 <sil=0.645> ,COMMA 1 <sil=0.321> ,COMMA 2 <sil=0.534> ,COMMA 3 <sil=0.479> ,COMMA 5 <sil=0.623> ,COMMA 8 <sil=0.503> ,COMMA 13 <sil=0.625> ,COMMA 21 <sil=0.417> ,COMMA so and so forth <sil=0.916> .PERIOD Therefore <sil=0.320> ,COMMA we should be able to define it in terms of a recursive function because you can see this function F and this function F are the same only variations are in this parameters <sil=0.927> .PERIOD I am expressing the same function in terms of this parameters <sil=0.940> .PERIOD So <sil=0.379> ,COMMA the function definition will be very simple F in 10 some integer <sil=0.913> .PERIOD If n is less than 2 then return n <sil=0.911> .PERIOD If n is less than 2 <sil=0.322> ,COMMA if it is 0 then 0 if it is 1 then it is 1 <sil=0.951> .PERIOD Otherwise what you do return <sil=0.891> ?QUESTIONMARK Return F n minus 1 plus F n minus 2 some of the previous two Fibonacci numbers <sil=0.990> .PERIOD Now <sil=0.380> ,COMMA this is interesting because again if you see how this will be computed it will be first expanding what are the things have to compute and when it meets the stopping condition then it starts collecting back and come back <sil=0.906> .PERIOD So <sil=0.529> ,COMMA how many times say if I say if I want to compute Fibonacci of 4 how many times will that function be called <sil=0.983> ?QUESTIONMARK Let us look at the expansion of this <sil=0.927> .PERIOD So <sil=0.517> ,COMMA how will it happen <sil=0.991> ?QUESTIONMARK Fibonacci of 4 will be I want to compute Fibonacci of 4 is Fibonacci of 3 Fibonacci of 2 these two should be added <sil=0.928> .PERIOD So <sil=0.364> ,COMMA I have not yet found out anything I am just decomposing the problem <sil=0.924> .PERIOD This is a very very important concept that in order to solve the problem I want to decompose it in those smaller sub problems <sil=0.988> .PERIOD For F 4 I have to solve it by solving F 3 and F 2 <sil=0.979> .PERIOD Now <sil=0.623> ,COMMA for solving F 3 I have to solve F 2 and F 1 I further decomposed it <sil=0.911> .PERIOD Now <sil=0.398> ,COMMA for solving F 2 I have to solve F 1 and F 0 fortunately and for solve now the even now the entire thing has not been broken down F 2 for that I have to solve F 1 and F 0 <sil=0.909> .PERIOD Now <sil=0.466> ,COMMA I have expanded the whole thing <sil=0.931> .PERIOD Now <sil=0.523> ,COMMA I know that F 1 is 1 F 0 is 1 <sil=0.939> .PERIOD So <sil=0.609> ,COMMA F 2 will be 1 plus 1 2 this is known all these end points of this structure unknown 1 0 1 1 0 1 <sil=0.905> .PERIOD So <sil=0.302> ,COMMA I go on adding them and ultimately I will get F 4 <sil=0.909> .PERIOD Now <sil=0.631> ,COMMA it is in a way inefficient but because the same thing is being computed repeatedly <sil=0.944> .PERIOD But it has it will make for 2 and x to a practiced programmer it will make you programming writing the program much more <sil=0.939> .PERIOD I mean less lines of course if you can express it in much better way <sil=0.977> .PERIOD So <sil=0.380> ,COMMA you can see here how many times the condition was called 1 2 3 4 5 6 7 8 9 times 9 times the same function was called in order to compute F 4 <sil=0.936> .PERIOD So <sil=0.570> ,COMMA the code for the Fibonacci sequence will be if now the stopping condition of the base condition is very very important is very very important <sil=0.910> .PERIOD So <sil=0.565> ,COMMA if n is 0 all n is 1 then I return 1 this is the base case unless I reach at this point I will not be able to compute the entire solution <sil=0.924> .PERIOD Otherwise return Fibonacci of n minus 1 plus Fibonacci of n minus 2 that is the code for the Fibonacci number <sil=0.976> .PERIOD Now <sil=0.413> ,COMMA I mean this sort of Fibonacci of whenever I will have too many calls in that case I should be should avoid them as much as possible <sil=0.941> .PERIOD So <sil=0.583> ,COMMA what is the difference between recursion and iteration <sil=0.931> ?QUESTIONMARK In recursion we have the repetition I sorry in iteration it is both in iteration in iteration there is an explicit loop explicit loop for I equals 0 I less than equal to n minus 1 I plus plus <sil=0.947> .PERIOD So <sil=0.439> ,COMMA there is an explicit loop whereas <sil=0.472> ,COMMA in case of recursion it is a repeated function calls <sil=0.992> .PERIOD Termination iteration if the loop condition is no longer satisfied while this condition do if that condition fails then we come out of the loop <sil=0.972> .PERIOD In the case of recursion the base condition must be recognized whenever we are getting the base condition factorial 1 or factorial 0 Fibonacci of 0 or Fibonacci of 1 <sil=0.976> .PERIOD So <sil=0.425> ,COMMA those are the base conditions both can have a wrongly programmed both can have infinite loop <sil=0.943> .PERIOD So <sil=0.424> ,COMMA the performance wise iteration often gives faster result <sil=0.618> ,COMMA but it is a good software engineering practice to gradually get accustomed to recursion as you do more and more programming you will see that you will be able to express the things in a much subtler way <sil=0.966> .PERIOD So <sil=0.594> ,COMMA whenever there is a performance issue try to avoid recursion it will require additional memory also there is a particular type of storage that is required in recursion that is known as stack stack is a last in first type of structure <sil=0.927> .PERIOD So <sil=0.404> ,COMMA those things briefly let me tell you how this thing is done because stack is nothing but a structure where we can push in data from one side say I put say 5 I push so 5 comes here then I push 4 then I do n minus 1 3 is a plus 1 plus 1 plus pushed then 2 is pushed then n minus 1 again and 1 is pushed <sil=0.975> .PERIOD Now <sil=0.528> ,COMMA when I take out the data the data will come out as 1 then 2 then 3 then 4 then 5 in the reverse order <sil=0.947> .PERIOD So <sil=0.471> ,COMMA the two operations are push and pop popping out from the stack and pushing inside the stack <sil=0.999> .PERIOD So <sil=0.569> ,COMMA this stack data structure becomes very handy for implementation of function recursive functions will show some examples like here for example <sil=0.579> ,COMMA I want to compute the GCD of AB <sil=0.987> .PERIOD Now <sil=0.567> ,COMMA typically what happens is I call this GCD is computed I read it in the description <sil=0.996> .PERIOD Now <sil=0.392> ,COMMA here when I call something I call something all the say here was I was here my program flow was here I went in and when I went in all the local variables and everything here were stored and I had to remember where I will be turning back <sil=0.979> .PERIOD So <sil=0.456> ,COMMA all those things are stored in the stack and without a stack data structure it is very difficult to implement recursion and for that matter any function call <sil=0.957> .PERIOD So <sil=0.506> ,COMMA you see here is a function and so all those return address is stored before call this stack was empty <sil=0.929> .PERIOD Now <sil=0.642> ,COMMA after when it is returning it is taking out from the top of the stack and again I come to know where I was <sil=0.929> .PERIOD So <sil=0.424> ,COMMA that is similarly you see here it is an N 2 R AB that means NCR what we compute N 2 R if I compute then you know N 2 R is factorial R divided by factorial of N minus R divided by factorial of N minus R or some people write it in this way by factorial of N minus R <sil=0.958> .PERIOD So <sil=0.359> ,COMMA how do I do that <sil=0.951> ?QUESTIONMARK So <sil=0.346> ,COMMA how can I implement it <sil=0.956> ?QUESTIONMARK So <sil=0.315> ,COMMA here NCR has been called from here factorial has been called and then where do I return I return I have to come here ultimately I have to return here <sil=0.919> .PERIOD So <sil=0.307> ,COMMA I should not lose the path <sil=0.942> .PERIOD So <sil=0.436> ,COMMA what the stack does is when I make the call first call then when I make the call ins here then the local variables here will be stored on the stack and again I make another call from here <sil=0.967> .PERIOD So <sil=0.428> ,COMMA local variables are there I am calling fact as I go in here the local variables here are stacked up and then when I return this part this part this part will be taken out and passed on to this <sil=0.950> .PERIOD So <sil=0.534> ,COMMA what happens is this part is as it returns this part is taken out and I am here it can again continue and then it returns when it returns here this part will be taken out this part will be taken out this part will be taken out and so that is for normal function call how the stack remembers where I should go back <sil=0.920> .PERIOD In the case of recursive calls what happens what we have seen is this is the case activation record gets pushed into the stack when a functional call is made in recursion of function calls itself <sil=0.969> .PERIOD So <sil=0.650> ,COMMA several function calls are going on with none of the calls are getting back so all the activation records are collected <sil=0.907> .PERIOD So <sil=0.499> ,COMMA you need not delve into that too much let us see I will show it by an example of computing factorial <sil=0.988> .PERIOD So <sil=0.621> ,COMMA this and activation record is the local variables and the return value what the function should return and where it should return <sil=0.958> .PERIOD So <sil=0.537> ,COMMA with that say the main function is calling fact 3 alright fact 10 and here is the fact 10 if n equal to 0 return 1 otherwise n times fact n minus 1 <sil=0.943> .PERIOD So <sil=0.498> ,COMMA main calls fact so when it calls the function is the function is the value is n equal to 3 there is no return value return address is in main I am remembering that next again fact is calling itself <sil=0.923> .PERIOD So <sil=0.420> ,COMMA now fact is calling fact 3 is calling fact 2 and my return address is fact so you see it has been stacked up next fact 2 will call fact 1 <sil=0.964> .PERIOD So <sil=0.500> ,COMMA that is what the stack is going and return is in fact alright now next time it will be fact 0 now the return value till now there was no return value now the return value is 1 return address is fact <sil=0.957> .PERIOD So <sil=0.493> ,COMMA as I do that I return then I have got a return value because now I have come to this point so 1 into 1 will be 1 and I am returning to fact as I return the stack will contract and what is the return result 2 times 1 that is 2 that is the factorial 2 and return I am returning to fact <sil=0.938> .PERIOD So <sil=0.323> ,COMMA I return again now I am coming to the last time in the fact with n equal to 3 that started here so and the result is 6 now I return to main so at every stage look at this I have I know I remember from where I started and from where I am returning back nothing is lost using this stack so stack is a very interesting data structure that helps us in many ways especially in implementing things like recursion and all those <sil=0.989> .PERIOD So <sil=0.437> ,COMMA one assignment that I am living to you do it yourself <sil=0.417> ,COMMA press the activation record for the following version of even an axis please note down the code include stdi <sil=0.943> .PERIOD h in depth f is the few an axis function a and b if n is less than 2 return n if it is 0 then return 0 if it is 1 return 1 otherwise a is f n minus 1 b is f n minus 2 I have done it in a different way f n minus 1 and f n minus 2 so f n minus 1 has to be solved separately and f n minus 2 should be solved separately then will return a plus b and then the main will be so just as a fun you try to draw the activation record of this version of the function please note it down take some time and note down this function and you see on this side have shown how the activation record will look like local variables you can see n a and b return value you have to keep whether it is in Fibonacci or in main either in main or in x or y where is x and what is y this is is x and this sorry this there is a problem in this I am drawing it again so you see this this is x this is x and this is y all right not these two these are not these are not aligned properly all right so either where do I return and here is the return to the main either I return to main or to x or to y and what is the return value draw the activation record of this and then we will see how much you could do it I am sure you will be able to do it and recurs so today we have learnt a new style of programming that is recursion and also we discussed in the last class so recursion is a type of writing functions where the function calls itself and that makes many functions to be written much more secondly much more subtly and that is a very good software engineering practice although at the beginner if you find difficulty in that you need not bother too much about you you have got iteration at your disposal and you can solve most of the problems with iteration practically all the problems you can do may be in some cases it may be a little more difficult to write but ultimately it is possible <sil=0.923> .PERIOD So <sil=0.520> ,COMMA if you find difficulty with recursion you can set it aside for the time being but we have to discuss it because that is a very nice way of writing functions will continue with the concept of structures in the next lecture a new thing will be introduced that is called structure <sil=0.935> .PERIOD Thank you <sil=0.985> .PERIOD Now <sil=0.518> ,COMMA we are discussing about formation of loops creation of loops in a program using force statement <sil=0.927> .PERIOD Before that <sil=0.558> ,COMMA we have seen the wild statement and do wild statement and now and then we have seen the force statement as well <sil=0.981> .PERIOD Now <sil=0.473> ,COMMA the force statement as we had shown we had discussed in the last class it is basically starting to check an expression <sil=0.575> ,COMMA arithmetic expression and then it starts with initialization expression and then we check a particular condition <sil=0.967> .PERIOD So <sil=0.459> ,COMMA something like this for some variable <sil=0.458> ,COMMA integer variable j assigned some value 5 maybe and then some expression here this one is j less than equal to 25 and then here there will be some statements which will be executed and after that there is a third expression which is altering it and that can be j assigned j plus 5 and the body of the x look <sil=0.964> .PERIOD This is a structure that we had seen <sil=0.939> .PERIOD So <sil=0.519> ,COMMA now there are some critical issues that are to be noted for the force structure <sil=0.931> .PERIOD So <sil=0.536> ,COMMA if you look at this <sil=0.446> ,COMMA you can see that we are using arithmetic expressions for example <sil=0.350> ,COMMA x assigned to and y assigned 10 that is an arithmetic expression <sil=0.954> .PERIOD So <sil=0.625> ,COMMA similarly this is a valid arithmetic expression for j assigned x j less than equal to 4 times x times y that is the condition that means <sil=0.592> ,COMMA after some computation we will have to find out whether j is satisfying this condition and here j here probably this is something this construct we have not shown you this is I do not like it very much and initially you need not bother about this j plus equal to y by x this is a c structure say c syntax expressing j equals j plus y by x <sil=0.911> .PERIOD So <sil=0.386> ,COMMA the whole thing can be written in this way <sil=0.968> .PERIOD So <sil=0.521> ,COMMA this but that is not important for the purpose of understanding for for expressions <sil=0.925> .PERIOD So <sil=0.617> ,COMMA here is just an expression and this is equivalent to like this for say x was 2 and y was 10 then this is equivalent to j assigned 2 because j assigned x and j assigned 2 are essentially same j as less than equal to 4 times x times y that means <sil=0.515> ,COMMA 4 times 2 times 10 that means <sil=0.491> ,COMMA 80 and j equals assigned j plus y by x is 5 <sil=0.991> .PERIOD So <sil=0.589> ,COMMA this is equivalent all right <sil=0.932> .PERIOD So <sil=0.345> ,COMMA this is initialization and this is loop continuation condition and this is the increment or I as I was saying that this is the modulator or the alteration <sil=0.970> .PERIOD Now <sil=0.376> ,COMMA increment can be negative <sil=0.951> .PERIOD So <sil=0.639> ,COMMA this increment although we are calling it increment that is why we should not call it increment let us call it a modulator because say like the same thing I can write as for j assigned 2 maybe something j less than equal to 80 and might be j minus minus it can be the case when can it be say say for example <sil=0.558> ,COMMA if I add if I want that I will be printing the numbers in the reverse order starting from 10 <sil=0.947> .PERIOD So <sil=0.475> ,COMMA what should I do <sil=0.882> ?QUESTIONMARK So <sil=0.572> ,COMMA can I do this <sil=0.861> ?QUESTIONMARK What I want to do is that I want to print something like 10 <sil=0.502> ,COMMA 9 <sil=0.500> ,COMMA 8 <sil=0.599> ,COMMA 7 <sil=0.481> ,COMMA 5 in this order <sil=0.900> .PERIOD So <sil=0.410> ,COMMA simply I can do this repeatedly in a loop <sil=0.999> .PERIOD For example <sil=0.609> ,COMMA for j assigned 10 and j sorry j greater than equal to 5 j minus minus and here I just do print f percentage d backslash n j <sil=0.945> .PERIOD So <sil=0.559> ,COMMA what will happen <sil=0.981> ?QUESTIONMARK Initially j is 10 less greater than equal to 5 <sil=0.929> .PERIOD So <sil=0.499> ,COMMA 10 will be printed then I go back I decrement j <sil=0.983> .PERIOD So <sil=0.356> ,COMMA j will become 9 still greater than equal to 5 I come in here print j 9 I again decrement j decrement j becomes 8 I compare with this still it is greater than equal to 5 I I get in and print it in that way I can do it I can repeatedly do the same thing <sil=0.994> .PERIOD But here as you can see I am being able to achieve this reverse order by instead of incrementing I am decrementing this index that is why I can increment decrement I can multiply it I change it I modulate it that is why this to be an alteration expression or modulation expression is a better term than increment or decrement <sil=0.924> .PERIOD So <sil=0.425> ,COMMA if the loop continuation if the loop continuation condition is initially false is initially false then the body structure the force structure will not be executed <sil=0.914> .PERIOD It will proceed with the statement for the next statement <sil=1.000> .PERIOD So <sil=0.505> ,COMMA for example <sil=0.419> ,COMMA if I write something like this as you have seen earlier j equal to 20 and for i equals i assigned 1 i greater than j i plus plus say and then I want to do some things here all right <sil=0.966> .PERIOD Now <sil=0.488> ,COMMA j is 20 I will first initialize i to 1 and immediately I find the first thing that I do is it is false I check this and it is false i is not greater than j therefore <sil=0.316> ,COMMA this stay these statements will not be executed even once and the statements following the for loop will be executed <sil=0.977> .PERIOD So <sil=0.502> ,COMMA now here are some examples of for loops this is again computing the factorial <sil=0.920> .PERIOD Fact factorial is a the variable fact is storing the factorial factorial all of you know factorial n is n multiplied by n minus 1 multiplied by n minus 2 so and so forth up to 1 <sil=0.906> .PERIOD So <sil=0.575> ,COMMA it is 1 and I have got a variable i <sil=0.998> .PERIOD Now <sil=0.484> ,COMMA you can see simply I can do it like this i assigned 1 i less than 10 i plus plus fact assigned fact time psi <sil=0.944> .PERIOD Now <sil=0.530> ,COMMA what is happening here <sil=0.978> ?QUESTIONMARK So <sil=0.363> ,COMMA I have got fact to be 1 <sil=0.913> .PERIOD So <sil=0.450> ,COMMA i equals 1 then with that what I do is 1 times 1 is fine and I then make i to be 2 and then I so i becomes then 2 so 1 times 2 then i becomes 3 then 1 times 2 times 3 then i becomes 4 then 1 times 2 times 4 times 3 times 4 and so on so forth it will go on in this loop <sil=0.938> .PERIOD So <sil=0.431> ,COMMA that is a nice way of writing factorial and here is another example you can see what it does quickly you can explain it yourself what it does <sil=0.936> ?QUESTIONMARK Some is 0 and n is a variable and count is another integer variable <sil=0.987> .PERIOD All right some is 0 <sil=0.354> ,COMMA n is a one variable and count is another integer variable <sil=0.991> .PERIOD Now <sil=0.499> ,COMMA we are reading n and for i equals 1 i less than equal to n I am adding some <sil=0.935> .PERIOD So <sil=0.545> ,COMMA what is being done here <sil=0.872> ?QUESTIONMARK What will happen if I trace this program what is going to happen <sil=0.870> ?QUESTIONMARK Let us do that <sil=0.992> .PERIOD Suppose I have read n to be here I have read n to be 5 <sil=0.962> .PERIOD Now <sil=0.381> ,COMMA what am I doing here <sil=0.869> ?QUESTIONMARK I here there is one problem here I should have been declared there is a mistake here int n and here I also add i I should have been declared here <sil=0.931> .PERIOD Now <sil=0.564> ,COMMA i assigned 1 so i is 1 n was 5 i less than 5 less than equal to 5 <sil=0.940> .PERIOD So <sil=0.354> ,COMMA sum is sum was 0 <sil=0.958> .PERIOD So <sil=0.638> ,COMMA sum is 0 plus i times i i was 1 so 0 plus 1 square and then I check I increment i so <sil=0.472> ,COMMA I becomes 2 <sil=0.973> .PERIOD I becomes 2 and I check that i is less than not less than a still less than equal to 5 <sil=0.918> .PERIOD So <sil=0.469> ,COMMA I got this sum and with that I add now i square i times i so <sil=0.362> ,COMMA 2 square <sil=0.997> .PERIOD Similarly <sil=0.361> ,COMMA it will go on it will do 3 square <sil=0.901> .PERIOD So <sil=0.344> ,COMMA I will become then 4 and then still it is less than equal to so <sil=0.504> ,COMMA 4 square then I will become 5 and still it is true so <sil=0.325> ,COMMA it will be 5 square <sil=0.967> .PERIOD Then I become 6 this condition will be violated and I will come to this printer <sil=0.961> .PERIOD So <sil=0.373> ,COMMA what will sum be <sil=0.877> ?QUESTIONMARK sum is 1 square plus 2 square plus 3 square and if I make it n then up to n square <sil=0.977> .PERIOD So <sil=0.343> ,COMMA this is the very well known series the sum of the square of natural numbers we can compute by this small program using for loop <sil=0.911> .PERIOD So <sil=0.620> ,COMMA it is a nice example <sil=0.993> .PERIOD Now <sil=0.555> ,COMMA we introduce the comma operator as I say as we say that here for when we write for then I assigned 1 <sil=0.977> .PERIOD Instead of that I can put in more than one statements here using a comma operator <sil=0.945> .PERIOD For example <sil=0.451> ,COMMA for fact 1 i equals 1 i less than equal to 10 now this part is what <sil=0.892> ?QUESTIONMARK This part is the initialization <sil=0.918> .PERIOD Now <sil=0.586> ,COMMA remember that this will not be continuously initialized <sil=0.936> .PERIOD This is just a statement that I have put here an assignment statement <sil=0.627> ,COMMA but my index variable for the control variable for the loop is i <sil=0.961> .PERIOD So <sil=0.638> ,COMMA I could have written this earlier example of factorial may be earlier example of factorial this could be initialized here also <sil=0.986> .PERIOD So <sil=0.456> ,COMMA that is just saving space saving the number of lines of code <sil=0.576> ,COMMA but personally I suggest as I did earlier also that for of those of you who are beginners in programming you should not try this tricks or should not try this thriftiness reducing the number of lines that is not so important to how much you can reduce <sil=0.943> .PERIOD The most important thing is to be logically and syntactically correct while you write a program <sil=0.903> .PERIOD So <sil=0.348> ,COMMA we can give several things in comma like sum here again <sil=0.903> .PERIOD So <sil=0.584> ,COMMA the program becomes even smaller looks smarter <sil=0.637> ,COMMA but sometimes at the beginning if you try to do that you try to be smart and in the process you may result in some wrong program long long logic better avoid that <sil=0.961> .PERIOD Now <sil=0.491> ,COMMA infinite loop in general what is an infinite loop <sil=0.904> ?QUESTIONMARK When a program when a program continues program continues in a loop repeatedly it goes on and it is never completing it is going on because the condition that is supposed to turn out to be false at a particular point of time <sil=0.948> .PERIOD So <sil=0.363> ,COMMA that it comes out of the loop never happens <sil=0.948> .PERIOD That can always happen that say if I write something like for i equals 1 i less than n and whatever i plus plus <sil=0.968> .PERIOD Now <sil=0.445> ,COMMA every time inside the loop when you get in you read you do something and then increment i and when you come inside the loop you do i minus minus say <sil=0.971> .PERIOD Then whatever has been done here will be cancelled out here <sil=0.920> .PERIOD So <sil=0.372> ,COMMA this loop will never is this condition i less than n <sil=1.000> .PERIOD Therefore <sil=0.517> ,COMMA that this loop will continue forever such situations are known as the condition of infinite loop <sil=0.988> .PERIOD Now <sil=0.438> ,COMMA sometimes usually we do not like that <sil=0.448> ,COMMA but sometimes it may be necessary to specify that something will happen forever <sil=0.943> .PERIOD Say some particular work has to be done continuously <sil=0.905> .PERIOD Now <sil=0.612> ,COMMA in order to specify that for loop provides us some facility like say for and while everything <sil=0.938> .PERIOD Say this one we had discussed earlier while 1 that means always it is true it is non-zero <sil=0.949> .PERIOD This while of this expression part condition expression part should return non-zero and so it will go on <sil=0.923> .PERIOD Now <sil=0.350> ,COMMA here for and I put null that means the for has had 3 parts for the initialization part <sil=0.439> ,COMMA some condition part and some incrementation <sil=0.400> ,COMMA decrementation part whatever <sil=0.955> .PERIOD Now <sil=0.496> ,COMMA I just keep everything blank <sil=0.988> .PERIOD So <sil=0.434> ,COMMA I turn it to be for nothing and nothing all these things have blank <sil=0.934> .PERIOD In that case what will happen <sil=0.917> ?QUESTIONMARK In that case what will happen <sil=0.902> ?QUESTIONMARK If I keep some statements that will go on forever <sil=0.945> .PERIOD Similarly <sil=0.377> ,COMMA if I in the case of due while if I just put while 1 that is again infinite loop <sil=0.984> .PERIOD So <sil=0.354> ,COMMA by this I can express my desire that some things will have should continue forever <sil=0.914> .PERIOD So <sil=0.332> ,COMMA this is another trick that you can utilize in some cases for the for and the while constructs <sil=0.989> .PERIOD Now <sil=0.596> ,COMMA we come to another statement which we have encountered a little few lectures earlier in the context of switch statements <sil=0.909> .PERIOD While we are considering the switch statements if you recall you have seen that after every case statement switch on a particular variable then their case red <sil=0.566> ,COMMA case green <sil=0.462> ,COMMA case blue if you recall then we did something and then gave a break <sil=0.937> .PERIOD Did something give a break like that we proceeded <sil=0.904> .PERIOD So <sil=0.443> ,COMMA the break statement of course <sil=0.641> ,COMMA we know can help us we can use it with several things one is while due while for and switch <sil=0.920> .PERIOD Now <sil=0.470> ,COMMA this switch switch part we have seen but we can also use it for while due while and for for breaking out of the loop we want to break out of the loop <sil=0.961> .PERIOD Sometimes that is required it works with while due while for but does not work with if and else statements <sil=0.940> .PERIOD It causes immediate exit from a while for or due while or case we have seen that switch statements earlier <sil=0.964> .PERIOD So <sil=0.488> ,COMMA the program continues after with the next statement <sil=0.955> .PERIOD Let us see why do we why do we want to use it it helps us to escape early from a loop <sil=0.936> .PERIOD Sometimes we want to escape early I do not want to go till the end of the loop when a particular condition is met I want to come out I am doing it in a loop but waiting for some condition to take place as soon as that condition takes place I come out of the loop <sil=0.954> .PERIOD Maybe I as we we have seen in the case statement switch some expression all right color then case or we do something and then give break right case G we do something and then give break right we do like that <sil=0.952> .PERIOD So <sil=0.361> ,COMMA we skip the remaining part of the switch block all right we come out of that <sil=0.964> .PERIOD So <sil=0.613> ,COMMA similarly we will see couple of examples of this say here there is a complete example <sil=0.957> .PERIOD Let us look at that is a complete example complete program once again include stdiu <sil=0.929> .PERIOD h you are running some programs main then fact and I are integers fact we are computing factorial <sil=0.921> .PERIOD So <sil=0.491> ,COMMA fact is 1 i is 1 while i is less than 10 that means i want to break out while i is less than 10 fact fact times i if fact is greater than 100 then factorial is above 100 factorial of a number is above 100 <sil=0.918> .PERIOD So <sil=0.600> ,COMMA for example I am going on up to 10 numbers <sil=0.950> .PERIOD So <sil=0.397> ,COMMA what will happen with the factorials let us see <sil=0.914> .PERIOD So <sil=0.380> ,COMMA factorial 1 will be 1 factorial 2 will be 2 factorial 3 will be 3 times 2 that is 6 factorial 4 will be 4 times 3 4 times 6 it will be 4 times 3 times 2 so 4 times 6 that means 24 then 24 times 5 so that will be how much it will be more than how much will it be if i I have got this 4 3 2 and multiply that with 5 <sil=0.993> .PERIOD So <sil=0.597> ,COMMA 20 60 so here just with 5 numbers I am exceeding the value 120 but I do not know when I am going to reach the value 100 <sil=0.938> .PERIOD So <sil=0.333> ,COMMA I have written the program in this way fact while i is less than 10 I will test it up to 10 numbers every time I compute fact if fact is greater than 100 print so here as soon as fact becomes 100 will say factorial of 5 is above 100 factorial of 5 is above 100 and then I break out otherwise if I had not put this break then this would have continued till this loop all for all the 10 numbers up to factorial 10 <sil=0.910> .PERIOD But I just want to stop whenever my result becomes more than 100 so this is one way we can utilize break right <sil=0.971> .PERIOD Similarly there is another statement although we do not use it often it is better to know that sometimes it can come handy that is a continuous statement that means the remaining part of the body of a loop we will skip if I put a continuum all right <sil=0.984> .PERIOD So <sil=0.453> ,COMMA let us see and it proceeds to the next iteration of the loop <sil=0.992> .PERIOD So <sil=0.540> ,COMMA what happens is let us look at one example here <sil=0.968> .PERIOD So <sil=0.523> ,COMMA while 1 that means what that means it is always true it will continually go on doing it <sil=0.915> .PERIOD So <sil=0.373> ,COMMA fact is fact times i i plus plus so I start with i 1 then 2 then 3 if i is less than 10 I will go into the loop otherwise I will break <sil=0.903> .PERIOD So <sil=0.412> ,COMMA this continue is basically remain forcing me to go back to this point by forsaking this part <sil=0.902> .PERIOD I am not coming to the remaining of the loop <sil=0.911> .PERIOD But if this condition is not holding then I will not execute continue I will stay to a come here and to break <sil=0.926> .PERIOD I think it will need a couple of moments for you to just realize what is happening here all right <sil=0.994> .PERIOD So <sil=0.524> ,COMMA just look at this <sil=0.903> .PERIOD So <sil=0.560> ,COMMA in this way it will I think you can understand it <sil=0.904> .PERIOD So <sil=0.321> ,COMMA I have got i to be 1 <sil=0.993> .PERIOD So <sil=0.332> ,COMMA fact will be 1 times 1 then i becomes 2 and then I go back <sil=0.958> .PERIOD So <sil=0.569> ,COMMA it will be fact will be 1 times 1 times 2 I will be 3 and in that will go on <sil=0.933> .PERIOD But it will go on as long as i is to it 10 less than 10 then I will not come to break I will go back here <sil=0.932> .PERIOD But if i is less than 10 I will come to break and I will come out of the loop <sil=0.907> .PERIOD So <sil=0.441> ,COMMA it is a combination of continuing break <sil=0.965> .PERIOD This is but what I want is that you should understand how the fall loop is used for repetition that is very important to understand and we will carry out with some examples in the next lecture <sil=0.924> .PERIOD So <sil=0.556> ,COMMA we move to the next module of this course <sil=0.921> .PERIOD In the earlier module we have seen some example problems and the problems which can be some example problems which can be solved through programming using computers <sil=0.951> .PERIOD And also we said that all problems cannot be solved by computers <sil=0.952> .PERIOD So <sil=0.639> ,COMMA what are the problems that can be solved using computers <sil=0.911> ?QUESTIONMARK That is a natural question that can be asked <sil=0.998> .PERIOD The answer to that is that if we know the if it is known what are the steps that we must execute or perform in order to arrive at the desired result then we can solve it by program <sil=0.972> .PERIOD Now <sil=0.435> ,COMMA those steps may be directly known for example <sil=0.480> ,COMMA in the case of finding the average marks in a class for N students we know the steps right <sil=0.966> .PERIOD So <sil=0.511> ,COMMA let us see if we write down the steps following which we can solve this problem how would it look like <sil=0.981> ?QUESTIONMARK I want to read one number <sil=0.927> .PERIOD Suppose I am reading phone numbers I want to find the average of phone numbers <sil=0.933> .PERIOD Read means I just know get I can also say get get first number to get second number <sil=0.947> .PERIOD Suppose we want to find for three numbers <sil=0.546> ,COMMA get third number add the numbers that means first number plus second number plus third number <sil=0.910> .PERIOD And let that be the sum and then I say divide sum is this sum by the number of numbers <sil=0.932> .PERIOD And what is the number of numbers <sil=0.930> ?QUESTIONMARK Number of numbers here is 3 because there are 3 numbers and then say announce result <sil=0.930> .PERIOD So <sil=0.585> ,COMMA this one divide the sum by numbers <sil=0.965> .PERIOD So <sil=0.412> ,COMMA that is something like say something like this that result is equal to sum divided by 3 in this case right and announce result <sil=0.928> .PERIOD So <sil=0.649> ,COMMA these 3 these steps are very well known very clear and since these are very clear <sil=0.966> .PERIOD So <sil=0.598> ,COMMA I can solve them by programming why <sil=0.862> ?QUESTIONMARK Because programming what is programming <sil=0.898> ?QUESTIONMARK Programming is informing a computer as how to solve a particular problem <sil=0.902> .PERIOD So <sil=0.551> ,COMMA I can say let me just do it afresh <sil=0.996> .PERIOD If programming is nothing but letting the computer know how to solve a problem <sil=0.989> .PERIOD Now <sil=0.333> ,COMMA there are some important aspects to the sentence this phrase <sil=0.954> .PERIOD Letting the computer know is one important thing <sil=0.461> ,COMMA but what do we let the computer know <sil=0.941> ?QUESTIONMARK How to solve a problem <sil=0.878> ?QUESTIONMARK So <sil=0.578> ,COMMA how to means I have to tell the computer that what are the steps to be followed to solve a problem <sil=0.910> ?QUESTIONMARK I have to be very clear about it and I have to let the computer know <sil=0.993> .PERIOD So <sil=0.460> ,COMMA there is a big problem here how I let the computer know I will come to that later <sil=0.990> .PERIOD The steps to be followed is what we have to tell the computer <sil=0.994> .PERIOD So <sil=0.575> ,COMMA in the earlier example we just saw that the steps for finding the mean of 3 numbers are very clearly stated and I can inform the computer often this is informing the computer is also known as instructing the machine <sil=0.979> .PERIOD The machine is nothing but the computer itself and these are the computer instructions <sil=0.917> .PERIOD A program therefore <sil=0.612> ,COMMA consists of a number of instructions to be executed <sil=0.995> .PERIOD Now <sil=0.540> ,COMMA the example that we saw was for adding 3 numbers <sil=0.932> .PERIOD Now <sil=0.389> ,COMMA we will soon see that the thing becomes a little more complex <sil=0.906> .PERIOD If I I wrote get first number <sil=0.353> ,COMMA get second number <sil=0.337> ,COMMA get third number <sil=0.908> .PERIOD Suppose there are 20 numbers then I will have to write them 20 times get first number <sil=0.452> ,COMMA get second number <sil=0.333> ,COMMA get third number like that up to get 20th number that is boring is not it <sil=0.972> .PERIOD So <sil=0.329> ,COMMA instead I can possibly write that for 20 numbers let me let me do it in a let me do a number here for 20 numbers repeatedly get number all right that is possible <sil=0.962> .PERIOD So <sil=0.617> ,COMMA for 20 numbers I will be getting the numbers <sil=0.911> .PERIOD So <sil=0.586> ,COMMA I do not need to write down one get first number two get second number three get third number not like that <sil=0.970> .PERIOD I can straight away with one instruction I can express myself <sil=0.357> ,COMMA but whether this will be understood by the computer or not is a different question <sil=0.971> .PERIOD So <sil=0.555> ,COMMA I am keeping that question open understood by machine and whenever I talk about machine I mean a computer all right <sil=0.914> .PERIOD So <sil=0.423> ,COMMA for 20 numbers get number in that way I can say that or say I could have written that in a little more smarter form let us let me try to do that <sil=0.958> .PERIOD Now <sil=0.604> ,COMMA if I do that then what would be the next one I have not I have to add those 20 numbers <sil=0.908> .PERIOD So <sil=0.314> ,COMMA one thing is that again I can write here add number one number two number three up to number 20 then divide some by 20 there is one way of saying that <sil=0.303> ,COMMA but this is again boring right this very boring I mean it is not interesting to look at this why should I write in this dot dot dot form instead say I can write it in a smarter form say I write it in this way and you just see whether you can understand what I am writing for 20 numbers I am using my own language it is not a computer's language it is an English and it is a version my version of English all right <sil=0.956> .PERIOD I just need to express it to you and then whether that will be understood by the computer or not is a different question and we will address it separately for 20 numbers get number sorry I say repeat get number or let me the number with the current sum that means presently whatever is the value of sum I add that number that I read with that <sil=0.961> .PERIOD Now <sil=0.405> ,COMMA initially therefore <sil=0.477> ,COMMA what should be the current sum initially when I am starting the current the sum is 0 all right <sil=0.975> .PERIOD So <sil=0.462> ,COMMA I can say let sum be 0 initially <sil=0.961> .PERIOD Now <sil=0.391> ,COMMA I get a number at the number to the current sum and this repeat I am just using my so just showing as if it is a bracket that this part I am repeating I am repeating this part how many times I am repeating this part this part I am repeating how many times I am repeating 20 times because for 20 numbers I am getting the number adding the number getting the number adding the number and I am going on doing this and adding the number and I am keeping that number in sum all right <sil=0.927> .PERIOD So <sil=0.321> ,COMMA ultimately I do it 20 times and then this part is finished then what I have to do so this was step 1 this was step 2 this was step 3 <sil=0.990> .PERIOD So <sil=0.340> ,COMMA this step 3 was repeated 20 times I am sorry I am sorry let us make it sorry actually this is the second step which I did 20 times and after that I have got the all the numbers added <sil=0.939> .PERIOD So <sil=0.388> ,COMMA next I come and I say result is sum divided by 20 <sil=0.940> .PERIOD So <sil=0.592> ,COMMA that will be my result and then I can announce the result print the result whatever <sil=0.953> .PERIOD So <sil=0.421> ,COMMA here you see in the earlier example what I did is read first number <sil=0.547> ,COMMA read second number <sil=0.447> ,COMMA read third number <sil=0.506> ,COMMA read fourth number like that here I have just expressed it in a smarter way that for 20 numbers do this activity repeatedly 20 times <sil=0.984> .PERIOD So <sil=0.350> ,COMMA that is another way I can express it all right <sil=0.923> .PERIOD And that shows that I can specify very clear steps by which the problem can be solved <sil=0.952> .PERIOD And since I can specify the steps clear steps through which the problem can be solved this problem can be solved by programming ok I can program a machine to solve this problem <sil=0.926> .PERIOD So <sil=0.570> ,COMMA similarly say how many times the second problem that we had looked at how many times a particular word human occurs in a particular text <sil=0.966> .PERIOD So <sil=0.419> ,COMMA I have to do something like this I have to open the text I have to see look at the text and read a word and see is it human no is it human no is it human yes <sil=0.951> .PERIOD So <sil=0.339> ,COMMA I will have to have some sort of counter some sort of a counter or count which I will increase every time I am sorry every time I encounter the word human and this will go on this will go on as many times for every word in the text <sil=0.915> .PERIOD So <sil=0.459> ,COMMA I can write that down as for every word in the text <sil=0.934> .PERIOD If the word is human increment count <sil=0.970> .PERIOD So <sil=0.505> ,COMMA this will go on only if the word is human I will increment the count otherwise I will go on reading the word <sil=0.988> .PERIOD So <sil=0.341> ,COMMA this is a very clear step which I can express to the computer in its own way <sil=0.958> .PERIOD So <sil=0.536> ,COMMA that it can find out how many times the word human has occurred <sil=0.901> .PERIOD Now <sil=0.628> ,COMMA there are different other variants of this that I had told you that whether it is a human being or whether it is an equivalent man <sil=0.463> ,COMMA a woman <sil=0.554> ,COMMA boy girl whether it refers to a human being or not then obviously the instruction will be a little more complicated than this <sil=0.988> .PERIOD So <sil=0.641> ,COMMA in these ways <sil=0.978> .PERIOD So <sil=0.387> ,COMMA I once again come back to my statement that what are the problems that I can solve using a computer I can solve the problems where I can enunciate I can express the clear steps set of steps one after another by which I can solve the problem correctly <sil=0.971> .PERIOD So <sil=0.648> ,COMMA that is now for example <sil=0.445> ,COMMA now if we take the example of that searching in a maze where I was trying to use the diagonal up down whichever there also I can express some intelligent ways by which I can instruct the computer to approach the problem <sil=0.986> .PERIOD But everything as I said do not render themselves to such enunciation of very clear steps I do not really know <sil=0.909> .PERIOD I really do not know exactly that maybe either the problem is not well understood <sil=0.902> .PERIOD I mean a student a friend of yours is feeling depressed is not feeling well <sil=0.930> .PERIOD Now <sil=0.625> ,COMMA there may be you really do not know exactly what is the reason for that <sil=0.937> .PERIOD If you know the reason then you can try to solve it help him out <sil=0.949> .PERIOD Now <sil=0.511> ,COMMA when the problem is not well understood then of course <sil=0.496> ,COMMA we cannot solve it in such clear through such clear steps <sil=0.914> .PERIOD If the information that you are getting or are not very reliable then also there are ways and means by which we can think of how we can get a good enough solution <sil=0.976> .PERIOD Another thing is that there are some things which we do not know <sil=0.929> .PERIOD So <sil=0.571> ,COMMA we cannot solve that using programming or maybe some cases where the problem is so complicated for example <sil=0.345> ,COMMA solving the problem of hunger <sil=0.978> .PERIOD Now <sil=0.382> ,COMMA obviously if you say buy food <sil=0.535> ,COMMA gave food by that hunger will be solved <sil=0.906> .PERIOD Now <sil=0.313> ,COMMA that is too simplistic solution and that is not a realistic solution <sil=0.980> .PERIOD There are many angles many interacting variables which are working towards that <sil=0.903> .PERIOD So <sil=0.602> ,COMMA that is not directly amenable to solving using programming <sil=0.968> .PERIOD So <sil=0.437> ,COMMA however <sil=0.357> ,COMMA we have been able to give an idea of the category of problems which can be attempted to be solved by programming <sil=0.984> .PERIOD And I have also said what is programming once again programming is the set of instructions <sil=0.901> .PERIOD I am rewriting it in different way <sil=0.905> .PERIOD Set of instructions to be provided to a computer to solve the problem <sil=0.924> .PERIOD Now <sil=0.334> ,COMMA a computer is an electronic machine till now what I was doing I was writing the set of the statements in the form of somehow like English <sil=0.957> .PERIOD So <sil=0.347> ,COMMA you could understand that but a computer being an electronic machine will not be able to understand that <sil=0.985> .PERIOD An electronic machine is made of switches <sil=0.900> .PERIOD So <sil=0.620> ,COMMA since it is made of switches it will understand only only it understands only zeros and ones <sil=0.957> .PERIOD So <sil=0.546> ,COMMA whatever I say get number <sil=0.935> .PERIOD Now <sil=0.604> ,COMMA each of these get and number is one simple instruction or you can always understand this you can all of you can understand this <sil=0.988> .PERIOD But for a computer I will have to somehow write it in the form of some zeros and ones <sil=0.906> .PERIOD So <sil=0.640> ,COMMA maybe something like this 0 0 0 1 1 1 0 0 <sil=0.993> .PERIOD Suppose this is representing get and number can be this any mb or that number can be say 1 1 1 0 0 0 1 0 1 something like that <sil=0.928> .PERIOD So <sil=0.641> ,COMMA that is a completely different type of expressions <sil=0.352> ,COMMA alphabets <sil=0.994> .PERIOD So <sil=0.440> ,COMMA the way we are writing it here cannot be directly understood by the computer <sil=0.945> .PERIOD I think in the last lecture I had mentioned that how to let the computer know the steps <sil=0.999> .PERIOD Now <sil=0.567> ,COMMA if I want to let somebody know of I want to express myself to somebody I must do it in the form of a language that he or she understands <sil=0.981> .PERIOD For example <sil=0.547> ,COMMA whenever I am talking to a French person I will have to talk in French otherwise he will not understand if he does not know other languages <sil=0.945> .PERIOD Similarly <sil=0.378> ,COMMA if I encounter an alien for example <sil=0.462> ,COMMA I will have to talk in his language or I will not understand his language <sil=0.915> .PERIOD Therefore <sil=0.334> ,COMMA but how do you do that if I meet a person who does not understand my language some the natural solution is that will have somebody will be acting as an interpreter who understands both my language and the other parties language <sil=0.998> .PERIOD So <sil=0.452> ,COMMA he can understand my language and convert it to the other language <sil=0.999> .PERIOD So <sil=0.527> ,COMMA what is the other parties language <sil=0.992> ?QUESTIONMARK So <sil=0.592> ,COMMA what are the parties here <sil=0.942> ?QUESTIONMARK Let us see on one side it is we who want to do something on the other side we have got this machine called computer this machine which is lying in front of you <sil=0.907> .PERIOD Now <sil=0.433> ,COMMA I have to communicate with this machine and this machine we will have to communicate to me and this communication <sil=0.428> ,COMMA but this understands its world consists of zeros and ones and my world consists of A B C D's and with that I can say apple <sil=0.353> ,COMMA but this apple to this machine is 0 1 0 1 0 0 0 1 something like that <sil=0.992> .PERIOD So <sil=0.584> ,COMMA I will not understand this to be apple and he will not understand this to be apple <sil=0.916> .PERIOD So <sil=0.469> ,COMMA there we need some sort of mechanism that is this is the translator some sort of translation is required <sil=0.963> .PERIOD So <sil=0.575> ,COMMA we will be talking about this translation process in the next class <sil=0.520> ,COMMA but before that let us summarize what we have learnt till now <sil=0.962> .PERIOD We have seen that there are problems which can be solved by computers and there are problems which cannot be solved by computers <sil=1.000> .PERIOD The problems which can be solved by computers have we have to in order to solve them we have to express the specific steps to be followed for solving that particular problem <sil=0.943> .PERIOD We have to express that to the machine we have to we have to express that to the machine in its own language somehow <sil=0.937> .PERIOD We have to express it in its own language and this specific steps the steps that to be followed to solve a problem this is also known as algorithm <sil=0.946> .PERIOD The algorithm consists of the specific steps or the methods that have to be followed in order to solve a problem <sil=0.943> .PERIOD In the next lecture we will see how we can express these algorithms <sil=0.971> .PERIOD How can we express the algorithms <sil=0.938> ?QUESTIONMARK That is what we will do in the next module next lecture <sil=0.928> .PERIOD How can we express algorithms <sil=0.934> ?QUESTIONMARK There are different ways even I mean when I say how can we express algorithms not to the computer but maybe I want to communicate an algorithm to you or you want to communicate an algorithm to me <sil=0.909> .PERIOD I was showing some examples in which I was writing in English <sil=0.905> .PERIOD So <sil=0.534> ,COMMA there are different ways of doing that we will discuss that in the next class <sil=0.974> .PERIOD So <sil=0.570> ,COMMA in the last lecture we have discussed about function prototype before moving to some other topic <sil=0.969> .PERIOD Let us look at an example of function prototype and so that we can understand it better <sil=0.938> .PERIOD Here you see here is a program where I have got a function NCR <sil=0.462> ,COMMA N choose R and another function fact <sil=0.947> .PERIOD Now <sil=0.549> ,COMMA the functions are actually written later <sil=0.989> .PERIOD Here you see N choose R is like the standard N choose R that we do <sil=0.937> .PERIOD Here that is a factorial N by factorial R <sil=0.912> .PERIOD So <sil=0.349> ,COMMA factorial N divided by factorial R into factorial N minus R that we know from our school <sil=0.918> .PERIOD So <sil=0.573> ,COMMA that is one function that is one function <sil=0.935> .PERIOD The other function is the factorial <sil=0.955> .PERIOD So <sil=0.350> ,COMMA here is another function <sil=0.960> .PERIOD This is one function <sil=0.489> ,COMMA this is another function <sil=0.916> .PERIOD Now <sil=0.574> ,COMMA look at the beauty of this function <sil=0.922> .PERIOD This function is in a simple one return statement I have written everything <sil=0.951> .PERIOD So <sil=0.579> ,COMMA here you see the body of the function is merely a computation of an expression factor divided by factor divided by and factor minus R <sil=0.967> .PERIOD And this will be computed and that will be returned as an integer <sil=0.934> .PERIOD Now <sil=0.436> ,COMMA what will be the input <sil=0.891> ?QUESTIONMARK The input will be the N and the R both of them are integers <sil=0.961> .PERIOD Another point to note here is this function itself <sil=0.385> ,COMMA this function itself when it is running <sil=0.954> .PERIOD First say I get into this function and I try to compute the return value <sil=0.919> .PERIOD First I find fact N and from here I am calling another function that is the factorial function <sil=0.963> .PERIOD And the factorial function is taking only one input <sil=0.325> ,COMMA one integer N and based on that it is computing the factorial <sil=0.953> .PERIOD Computing the factorial you must be remembering by now or knowing by now that is I am starting with 1 and 1 times 2 times 3 etcetera I am going on doing and that is what is being done here <sil=0.913> .PERIOD Temp is 1 and temp is equal to temp times I <sil=0.982> .PERIOD This is wrong <sil=0.458> ,COMMA this should be small I <sil=0.923> .PERIOD Temp is temp times I whatever the I value is 1 times 2 <sil=0.614> ,COMMA 1 times 3 it goes on till I reaches N and then I return temp <sil=0.903> .PERIOD So <sil=0.639> ,COMMA the point to that you know this thing you know <sil=0.998> .PERIOD So <sil=0.449> ,COMMA what is being done here is when I am computing this function then I come to this I call this function return temp I return here and then I move here <sil=0.927> .PERIOD And again I find again a call to this fact again this time with a different parameter R <sil=0.943> .PERIOD And so again fact R is computed after this is computed <sil=0.902> .PERIOD Second time I return back here and then I again call this fact using N minus R <sil=0.914> .PERIOD So <sil=0.455> ,COMMA just to make the things clear <sil=0.988> .PERIOD So <sil=0.419> ,COMMA the first time I am calling this from here and returning back here second time I am calling this from here the same thing and returning back here and third time I am calling from here and returning back here <sil=0.966> .PERIOD Now <sil=0.606> ,COMMA for the third call I am so here is 1 N and so here is 1 N and that this N and here what I am passing I am passing N minus R I am first computing this and that is being passed here and that is being computed <sil=0.946> .PERIOD So <sil=0.633> ,COMMA here you see it is an example of nested call <sil=0.964> .PERIOD This was called from the main and this in turns call another function and in this way it goes on that is about the beauty of these two functions <sil=0.939> .PERIOD But now here is my main function here is my main function <sil=0.925> .PERIOD So <sil=0.369> ,COMMA the compilers comes from in this way and recognizes at this point that NCR is a function how does it know it looks at end <sil=0.932> .PERIOD But how does it recognize that it is a function it recognizes NCR to a function because of this parameter argument list <sil=0.959> .PERIOD Here it is said there are two integers coming in as parameters next it understands that fact is also a function <sil=0.953> .PERIOD So <sil=0.541> ,COMMA it is expecting to encounter NCR and fact somewhere down the line and it proceeds here it takes M and N reads M and N then it is in a loop where it is calling NCR <sil=0.914> .PERIOD It is a series you can understand NCR is computing some with some value I initially one <sil=0.951> .PERIOD So <sil=0.613> ,COMMA it is basically N C 1 plus N C 2 plus N C 3 plus etcetera it will go up to M <sil=0.939> .PERIOD So <sil=0.625> ,COMMA that is what is being computed here and so from here a call is made to this and as we have seen earlier while this is being executed this one is calling here this is returning back here then again this one now we are making a journey in this line <sil=0.970> .PERIOD So <sil=0.511> ,COMMA this one is calling this and we are returning back here as we have seen just now now ultimately when this entire thing is computed then we will come to this last bracket here sorry I should not this bracket here that means it is the end of NCR <sil=0.945> .PERIOD So <sil=0.313> ,COMMA I had called NCR from here so I will return back here and will whatever NCR value is that will be added to some and that will go to this some and then will proceed in this way <sil=0.990> .PERIOD I hope this clear now here I have not written NCRs I could have I could have written this earlier in that case this prototype would not be needed but since I decided that I will be writing it later <sil=0.995> .PERIOD So <sil=0.384> ,COMMA I decided to just introduce them as prototypes here now you should be very careful about the syntax of the of writing the prototypes it should have the function type just like a function name and the parameters now you will see later that it is also possible that I could have written something like NCR <sil=0.437> ,COMMA NCR <sil=0.629> ,COMMA NCR <sil=0.426> ,COMMA NCR <sil=0.623> ,COMMA NCR <sil=0.536> ,COMMA NCR <sil=0.563> ,COMMA NCR <sil=0.447> ,COMMA NCR <sil=0.425> ,COMMA NCR <sil=0.433> ,COMMA NCR <sil=0.444> ,COMMA NCR <sil=0.609> ,COMMA NCR <sil=0.523> ,COMMA NCR <sil=0.345> ,COMMA NCR <sil=0.379> ,COMMA it also mean that this NCR takes two integers as very I mean arguments that will also that is also allowed but it is nice to write this in this way <sil=0.965> .PERIOD Now <sil=0.403> ,COMMA next we will move to a very important concept <sil=0.994> .PERIOD So <sil=0.358> ,COMMA let us quickly have a look at this the prototype declaration and the function definitions are actually here <sil=0.943> .PERIOD Now <sil=0.559> ,COMMA we are moving to a very important concept of passing the parameters how do we pass the parameters from the calling function to the called function <sil=0.968> .PERIOD There are two distinct ways in which it can be done one is calling by value as this calling by reference <sil=0.991> .PERIOD So <sil=0.347> ,COMMA right now let us think of calling by value <sil=0.936> .PERIOD Now <sil=0.509> ,COMMA let us try to understand it in a simple way <sil=0.994> .PERIOD See here is my mean function <sil=0.477> ,COMMA let us call it mean function as we have seen there can be nested functions <sil=0.962> .PERIOD So <sil=0.460> ,COMMA this is the calling function <sil=0.986> .PERIOD Now <sil=0.549> ,COMMA in the function <sil=0.631> ,COMMA we have seen the function of the calling function <sil=0.969> .PERIOD Inside the calling function <sil=0.553> ,COMMA I have got some variable x and which may have the value say somewhere 5 it is an integer <sil=0.949> .PERIOD Now <sil=0.578> ,COMMA somewhere here I am calling a function let us call a simple function decrement or not decrement add 2 or say say add 2 <sil=0.959> .PERIOD So <sil=0.515> ,COMMA I am going to say that means <sil=0.426> ,COMMA whatever is the value will add 2 to that simple thing <sil=0.942> .PERIOD So <sil=0.608> ,COMMA here I say y is add to x and then semicolon and I go on and here is my function <sil=0.932> .PERIOD Add 2 in A and add 2 is also type integer <sil=0.928> .PERIOD Now <sil=0.329> ,COMMA so A we know is of local variable to the function <sil=0.968> .PERIOD So <sil=0.579> ,COMMA here I will take so what will happen suppose it was 5 <sil=0.981> .PERIOD So <sil=0.490> ,COMMA this will result in A will get 5 and here may be here I declare another variable say B <sil=0.933> .PERIOD So <sil=0.370> ,COMMA here I declare another although it was not necessary <sil=0.310> ,COMMA but I am just saying B is A plus 2 because it is task is to add 2 and then I say return B <sil=0.955> .PERIOD So <sil=0.328> ,COMMA this B which is an integer is being returned <sil=0.944> .PERIOD So <sil=0.307> ,COMMA B which will be in this case it was 5 it will be going back here <sil=0.901> .PERIOD I hope this is clear <sil=0.949> .PERIOD Now <sil=0.303> ,COMMA when you know the scope of variables that B is a variable or A or B whatever the value of those are restricted only during the life of this function <sil=0.956> .PERIOD So <sil=0.382> ,COMMA but however <sil=0.483> ,COMMA in the case of looking from the point of view of compiler I have got a variable A and I have got another variable B and here I have another variable X <sil=0.926> .PERIOD Now <sil=0.371> ,COMMA this variable X was having the value 5 <sil=0.964> .PERIOD So <sil=0.484> ,COMMA here in X I had 5 by this statement this statement made it 5 now since X is 5 and this one is expecting the value A in Y area <sil=0.915> .PERIOD Now <sil=0.468> ,COMMA this 5 will be copied in A <sil=0.480> ,COMMA what is being copied <sil=0.937> ?QUESTIONMARK Not X <sil=0.402> ,COMMA but the value of X <sil=0.927> .PERIOD So <sil=0.361> ,COMMA this one will be getting 5 <sil=0.987> .PERIOD So <sil=0.368> ,COMMA the copy value is being copied <sil=0.945> .PERIOD The value is copied in this variable 5 <sil=0.927> .PERIOD Now <sil=0.587> ,COMMA it takes B was something <sil=0.629> ,COMMA but here so B becomes 5 plus 2 <sil=0.630> ,COMMA B becomes 7 <sil=0.403> ,COMMA 7 comes out <sil=0.977> .PERIOD Now <sil=0.318> ,COMMA suppose I change this program a little bit <sil=0.549> ,COMMA I erase this B and make it <sil=0.470> ,COMMA so this B is no longer there <sil=0.359> ,COMMA this is not required <sil=0.986> .PERIOD This variable has not been defined <sil=0.325> ,COMMA I say that this line is also not there <sil=0.944> .PERIOD In T and I just do A plus <sil=0.593> ,COMMA A assigned A plus 2 <sil=0.968> .PERIOD So <sil=0.330> ,COMMA now <sil=0.647> ,COMMA when it was called add X <sil=0.556> ,COMMA then from here <sil=0.542> ,COMMA from here this X was copied here and A will be incremented to 7 <sil=0.927> .PERIOD So <sil=0.361> ,COMMA this will be incremented to 7 and obviously <sil=0.442> ,COMMA this will be returned A <sil=0.440> ,COMMA not return B <sil=0.635> ,COMMA because B is not there anymore <sil=0.970> .PERIOD So <sil=0.398> ,COMMA 7 that 7 will be returned here <sil=0.485> ,COMMA but you see if here now 7 has been returned and 7 will be Y <sil=0.957> .PERIOD Now <sil=0.311> ,COMMA suppose if I say I am not following the syntax <sil=0.363> ,COMMA I am just saying because there is no space here <sil=0.610> ,COMMA print if something X <sil=0.462> ,COMMA what would be printed for X <sil=0.622> ,COMMA what would be printed <sil=0.867> ?QUESTIONMARK 5 will be printed because X is still 5 <sil=0.421> ,COMMA X has not changed <sil=0.974> .PERIOD I have simply copied the value to the argument variable and have played with that <sil=0.555> ,COMMA changed it <sil=0.439> ,COMMA whatever I wanted to do <sil=0.511> ,COMMA I have done <sil=0.995> .PERIOD So <sil=0.587> ,COMMA take a little time to understand this <sil=0.394> ,COMMA this means that the variable that I have in the calling function <sil=0.405> ,COMMA the value of that will be copied to the argument of the called function <sil=0.919> .PERIOD So <sil=0.523> ,COMMA there are several advantages to this <sil=0.317> ,COMMA one is <sil=0.345> ,COMMA so it passes the value of the argument <sil=0.625> ,COMMA execution of the function does not change the actual parameter <sil=0.639> ,COMMA like the actual parameter was X <sil=0.522> ,COMMA which was 5 <sil=0.384> ,COMMA it remains as 5 <sil=0.599> ,COMMA although the function added 2 to that and it came back <sil=0.497> ,COMMA all changes to a parameter done inside the function are done on a copy of the actual parameter <sil=0.609> ,COMMA not the original parameter <sil=0.980> .PERIOD The copy is removed when the function returns to the caller <sil=0.623> ,COMMA that entire variable location that was given for the variable A in our example <sil=0.556> ,COMMA is returned back to the pool of memory locations <sil=0.908> .PERIOD The value of the actual parameters in the caller is not affected <sil=0.495> ,COMMA consequently it also saves us from some accidental changes programming that can come <sil=0.361> ,COMMA copying due to programming errors <sil=0.944> .PERIOD On the other hand <sil=0.496> ,COMMA the other thing that is another type of parameter passing is known as call by reference <sil=0.515> ,COMMA call by reference <sil=0.932> .PERIOD Here <sil=0.380> ,COMMA we are not copying the variable <sil=0.364> ,COMMA we are passing the address of the original argument <sil=0.951> .PERIOD So <sil=0.628> ,COMMA let us take the earlier example again <sil=0.504> ,COMMA if I had my main function here and I had similarly <sil=0.338> ,COMMA in text and here y was 0 <sil=0.387> ,COMMA 0 <sil=0.640> ,COMMA 0 <sil=0.303> ,COMMA 0 <sil=0.479> ,COMMA 0 <sil=0.476> ,COMMA 0 <sil=0.475> ,COMMA 0 <sil=0.511> ,COMMA 0 <sil=0.525> ,COMMA add to x here <sil=0.347> ,COMMA print f something x <sil=0.907> .PERIOD Here <sil=0.317> ,COMMA I had that function add to int a and here in the body <sil=0.438> ,COMMA I did assign a plus 2 and returning returning <sil=0.909> .PERIOD Now <sil=0.346> ,COMMA here is a variable x <sil=0.342> ,COMMA this is the variable and that has got an address <sil=0.336> ,COMMA say that address is whatever 5000 <sil=0.980> .PERIOD Now <sil=0.318> ,COMMA its value here somewhere <sil=0.584> ,COMMA x was 5 <sil=0.916> ,COMMA so its value is 5 <sil=0.934> .PERIOD Here <sil=0.416> ,COMMA what I am in the case of reference <sil=0.526> ,COMMA I am not copying the value of 5 to a <sil=0.957> .PERIOD Instead <sil=0.368> ,COMMA in the parameter passing <sil=0.486> ,COMMA I will write it in a different way <sil=0.395> ,COMMA not in this way <sil=0.511> ,COMMA which I will discuss later <sil=0.981> .PERIOD If I assume that this one a is not taking the value <sil=0.585> ,COMMA but the address is of the parameter <sil=0.431> ,COMMA address of the parameter means what means that this time <sil=0.602> ,COMMA this a <sil=0.357> ,COMMA here I am passing not the value 5 <sil=0.649> ,COMMA but I am just simply saying that whatever data you want to work with <sil=0.384> ,COMMA that is the data is in this location 5000 <sil=0.924> .PERIOD And it accepts that reference <sil=0.359> ,COMMA that the data that I am working on <sil=0.519> ,COMMA my a is actually staying in 5000 <sil=0.965> .PERIOD So <sil=0.633> ,COMMA what it does <sil=0.950> ,COMMA it takes the when it computes a assigned a plus 2 <sil=0.493> ,COMMA this is not looking nice <sil=0.970> .PERIOD So <sil=0.592> ,COMMA this is the data that I am working on <sil=0.434> ,COMMA let me write it a <sil=0.383> ,COMMA a assigned a plus 2 <sil=0.342> ,COMMA it now knows that it is not the value a is here <sil=0.476> ,COMMA I have to get the value from this location <sil=0.948> .PERIOD So <sil=0.631> ,COMMA it gets the value from this location <sil=0.616> ,COMMA but no other variable location has been allocated <sil=0.346> ,COMMA because I know where there is only one common place <sil=0.518> ,COMMA only one common place <sil=0.631> ,COMMA you have done given something here and you have told me where you have kept the data and I am also working in that vessel itself <sil=0.968> .PERIOD So <sil=0.492> ,COMMA what is happening here is this 5 will be changed to 7 <sil=0.366> ,COMMA here only and return I need not return 8 <sil=0.464> ,COMMA it was just return to be sufficient <sil=0.969> .PERIOD So <sil=0.596> ,COMMA changes have been done here <sil=0.343> ,COMMA so in this case when I come to this print FX <sil=0.503> ,COMMA what will happen <sil=0.902> ,COMMA what will be printed <sil=0.863> ,COMMA 7 will be printed <sil=0.915> ,COMMA because the actual data has changed here <sil=0.943> .PERIOD Let me show it with another example <sil=0.340> ,COMMA here is my calling function and I think this vessel analogy will be fine <sil=0.914> .PERIOD Now <sil=0.557> ,COMMA it says that here is the data where I have pulled <sil=0.494> ,COMMA it only tells you where it has pulled <sil=0.318> ,COMMA the name of the vessel <sil=0.331> ,COMMA suppose the name of the vessel is a <sil=0.346> ,COMMA there are many other vessels <sil=0.320> ,COMMA a <sil=0.589> ,COMMA b <sil=0.594> ,COMMA c and only this vessel name has been passed <sil=0.957> .PERIOD And when this one is doing something <sil=0.577> ,COMMA it knows the vessel name a <sil=0.325> ,COMMA so it comes here and takes the data from here <sil=0.435> ,COMMA does something and returns the data from here <sil=0.946> .PERIOD And here this program when it is computing <sil=0.351> ,COMMA when it returns and then ultimately it returns there and while it returns <sil=0.328> ,COMMA it takes this value <sil=0.407> ,COMMA this value <sil=0.334> ,COMMA the change value and continues <sil=0.927> .PERIOD So <sil=0.379> ,COMMA in the case of calling by reference <sil=0.621> ,COMMA we are not copying the value <sil=0.337> ,COMMA on the other hand what would have happened in the case of call by value using the same vessel analogy <sil=0.932> .PERIOD Say this program was running <sil=0.587> ,COMMA the value was in a vessel <sil=0.405> ,COMMA the value was there in a vessel <sil=0.400> ,COMMA but my function do not bother about the interchange of colors <sil=0.948> .PERIOD The my function was also having its own vessel and when the function has been called <sil=0.554> ,COMMA the main function calls this <sil=0.335> ,COMMA a calls or say <sil=0.580> ,COMMA x calls y <sil=0.456> ,COMMA then also x copies y copies the value of the variable <sil=0.314> ,COMMA suppose that was a <sil=0.576> ,COMMA that is copied in the vessel that is belonging to the function <sil=0.526> ,COMMA it may be b <sil=0.925> .PERIOD So <sil=0.398> ,COMMA this one does whatever it does here and returns this value over here <sil=0.936> .PERIOD So <sil=0.634> ,COMMA this one is not disturbed <sil=0.601> ,COMMA whatever changes are being done <sil=0.602> ,COMMA are done here <sil=0.938> .PERIOD So <sil=0.345> ,COMMA that is a very fundamental concept in parameter passing <sil=0.476> ,COMMA there are two types of parameter passing <sil=0.565> ,COMMA one is called by value and another is called by reference <sil=0.960> .PERIOD Now <sil=0.343> ,COMMA so here you see <sil=0.322> ,COMMA execution of the function may affect the originals because I am sharing the same vessel <sil=0.946> .PERIOD Now <sil=0.468> ,COMMA this in C <sil=0.427> ,COMMA in C we actually we are <sil=0.384> ,COMMA in C we actually carry out only call by value <sil=0.342> ,COMMA only call by value <sil=0.944> .PERIOD Except for the case of arrays <sil=0.371> ,COMMA except for the case of arrays <sil=0.416> ,COMMA there is a reason for that you will understand and for arrays we are not passing the values <sil=0.563> ,COMMA we are passing by reference <sil=0.921> .PERIOD Otherwise <sil=0.381> ,COMMA it is always called by value <sil=0.942> .PERIOD So <sil=0.465> ,COMMA let us have a look at some of the examples here <sil=0.491> ,COMMA first example <sil=0.593> ,COMMA we have got the main <sil=0.532> ,COMMA let us see what is happening <sil=0.913> ,COMMA A has been initialized to 10 and B is not initialized <sil=0.356> ,COMMA print F initially A <sil=0.997> .PERIOD So <sil=0.534> ,COMMA what will be printed <sil=0.916> ,COMMA look at this <sil=0.911> ,COMMA this will print this first line <sil=0.647> ,COMMA initially A equals the value of A which is 10 <sil=0.925> .PERIOD So <sil=0.546> ,COMMA here there is a variable A which has got the value 10 <sil=0.956> .PERIOD Then B is being assigned <sil=0.364> ,COMMA change A <sil=0.647> ,COMMA what is change A <sil=0.525> ,COMMA change A is a function <sil=0.997> .PERIOD So <sil=0.627> ,COMMA one mistake is here <sil=0.643> ,COMMA I should have declared this change prototype here <sil=0.973> .PERIOD However <sil=0.597> ,COMMA I should have <sil=0.301> ,COMMA the function prototype should have been defined earlier <sil=0.994> .PERIOD Now <sil=0.342> ,COMMA I come here <sil=0.990> ,COMMA print F before <sil=0.434> ,COMMA what does the function do <sil=0.302> ,COMMA prints before x <sil=0.370> ,COMMA x <sil=0.422> .PERIOD So <sil=0.455> ,COMMA before <sil=0.525> ,COMMA so this point <sil=0.391> ,COMMA before x equal to x <sil=0.642> ,COMMA whatever x was <sil=0.354> ,COMMA it has got the copy of that x <sil=0.454> ,COMMA it has got the copy of that x <sil=0.547> .PERIOD So <sil=0.537> ,COMMA this <sil=0.306> ,COMMA it was A and that has been copied here for its own x <sil=0.940> .PERIOD X is also 10 <sil=0.531> ,COMMA copied because when it called <sil=0.346> ,COMMA you actually copied this <sil=0.917> .PERIOD When this call was made <sil=0.457> ,COMMA when this call was made first <sil=0.459> ,COMMA then before that <sil=0.406> ,COMMA it was also copied here and then only this was done <sil=0.913> .PERIOD So <sil=0.403> ,COMMA it was printed <sil=0.341> ,COMMA then x divided by 2 <sil=0.931> .PERIOD So <sil=0.302> ,COMMA x becomes 5 by this statement <sil=0.967> .PERIOD So <sil=0.646> ,COMMA what is being printed <sil=0.915> ?QUESTIONMARK After here <sil=0.612> ,COMMA this line is being printed here <sil=0.630> ,COMMA after x equals x <sil=0.915> .PERIOD So <sil=0.441> ,COMMA what will be printed <sil=0.857> ?QUESTIONMARK I am still inside the function <sil=0.534> ,COMMA please remember <sil=0.517> ,COMMA I am still inside the function <sil=0.939> .PERIOD So <sil=0.531> ,COMMA 5 will be printed and then I return <sil=0.650> ,COMMA return x <sil=0.951> .PERIOD So <sil=0.343> ,COMMA what is being returned <sil=0.891> ?QUESTIONMARK 5 is being returned <sil=0.967> .PERIOD Where it is being returned <sil=0.901> ?QUESTIONMARK Here <sil=0.442> ,COMMA x has been <sil=0.572> ,COMMA A has been changed and that is going to be print F <sil=0.409> ,COMMA A assigned <sil=0.957> .PERIOD So <sil=0.589> ,COMMA this print F is <sil=0.348> ,COMMA this print F <sil=0.477> ,COMMA A <sil=0.908> ,COMMA sorry <sil=0.490> ,COMMA A equals here <sil=0.522> ,COMMA I am printing A <sil=0.433> ,COMMA A is A <sil=0.929> .PERIOD So <sil=0.335> ,COMMA A is not changed <sil=0.985> .PERIOD So <sil=0.537> ,COMMA it is being printed as 10 and B is being printed as 5 <sil=0.977> .PERIOD So <sil=0.585> ,COMMA you see <sil=0.446> ,COMMA A has not been changed <sil=0.906> .PERIOD The reflection of the change has been reflected in this function and is being assigned to B <sil=0.943> .PERIOD Now <sil=0.428> ,COMMA let us take another example and you will yourself try to look at this example and a little change has been done <sil=0.970> .PERIOD Let us all together try to follow this example <sil=0.902> .PERIOD So <sil=0.336> ,COMMA starting again <sil=0.397> ,COMMA a mistake is <sil=0.327> ,COMMA I should have declared the function prototype here <sil=0.982> .PERIOD So <sil=0.509> ,COMMA those things I have not shown here <sil=0.926> .PERIOD So <sil=0.392> ,COMMA but you should do it <sil=0.963> .PERIOD Now <sil=0.564> ,COMMA let us see <sil=0.458> .PERIOD Here again <sil=0.598> ,COMMA int x equals 10 <sil=0.948> .PERIOD So <sil=0.581> ,COMMA x is a variable to the main function <sil=0.985> .PERIOD So <sil=0.636> ,COMMA x is having 10 <sil=0.910> .PERIOD Print F M here <sil=0.429> ,COMMA main function <sil=0.956> .PERIOD Printing initially x is 10 <sil=0.966> .PERIOD Then <sil=0.603> ,COMMA it is calling the function <sil=0.919> .PERIOD So <sil=0.512> ,COMMA here the function is being called <sil=0.962> .PERIOD And whenever this function is being called <sil=0.509> ,COMMA there is a local to the function <sil=0.925> .PERIOD There is an argument x where this 10 is being copied <sil=0.957> .PERIOD Now <sil=0.517> ,COMMA print F here <sil=0.513> ,COMMA this print F in the function <sil=0.987> .PERIOD It prints before x was x <sil=0.474> ,COMMA before changing <sil=0.982> .PERIOD So <sil=0.559> ,COMMA x was x <sil=0.971> .PERIOD So <sil=0.400> ,COMMA what will you printed <sil=0.979> ?QUESTIONMARK 10 will be printed <sil=0.911> .PERIOD Then <sil=0.648> ,COMMA I change x here <sil=0.910> .PERIOD So <sil=0.332> ,COMMA at this point <sil=0.325> ,COMMA x is becoming 5 <sil=0.962> .PERIOD Then <sil=0.318> ,COMMA I am saying print after the change <sil=0.939> .PERIOD This is this print out <sil=0.934> .PERIOD After that change <sil=0.400> ,COMMA x is what <sil=0.969> ?QUESTIONMARK It has been changed 5 <sil=0.970> .PERIOD And then <sil=0.365> ,COMMA I return to the main function with the change value of x <sil=0.989> .PERIOD So <sil=0.595> ,COMMA b gets 5 <sil=0.952> .PERIOD Now <sil=0.345> ,COMMA I am printing in the main function x is 10 and b is 5 <sil=0.936> .PERIOD So <sil=0.373> ,COMMA it has been changed <sil=0.935> .PERIOD That is being reflected in this print F <sil=0.953> .PERIOD And b is also 5 <sil=0.906> .PERIOD b was here <sil=0.963> .PERIOD b is in the main function <sil=0.983> .PERIOD So <sil=0.598> ,COMMA that b has been assigned after this change <sil=0.972> .PERIOD And that is also 5 <sil=0.919> .PERIOD Now <sil=0.605> ,COMMA the distinction <sil=0.403> ,COMMA I think will be clear <sil=0.971> .PERIOD So <sil=0.572> ,COMMA these are the two cases that we have shown <sil=0.941> .PERIOD So <sil=0.437> ,COMMA now <sil=0.335> ,COMMA here let us see <sil=0.923> .PERIOD Here <sil=0.476> ,COMMA the slight change that has been done is <sil=0.518> ,COMMA that the change value I am keeping in x <sil=0.914> .PERIOD Now <sil=0.563> ,COMMA this was x and x was 10 <sil=0.940> .PERIOD Now <sil=0.327> ,COMMA note <sil=0.648> ,COMMA x was 10 <sil=0.907> .PERIOD So <sil=0.353> ,COMMA initially x is 10 <sil=0.405> ,COMMA fine from this line <sil=0.925> .PERIOD Now <sil=0.577> ,COMMA this is the change value of x <sil=0.910> .PERIOD Now <sil=0.585> ,COMMA this is the change value of x <sil=0.958> .PERIOD Now <sil=0.648> ,COMMA this is the change value of x <sil=0.902> .PERIOD Now <sil=0.378> ,COMMA note <sil=0.549> ,COMMA x was 10 <sil=0.947> .PERIOD So <sil=0.615> ,COMMA initially x is 10 <sil=0.491> ,COMMA fine from this line <sil=0.961> .PERIOD Now <sil=0.557> ,COMMA I have called change x <sil=0.974> .PERIOD So <sil=0.482> ,COMMA it is coming here <sil=0.970> .PERIOD But <sil=0.487> ,COMMA its parameter is also x <sil=0.956> .PERIOD But <sil=0.360> ,COMMA that really does not matter <sil=0.928> .PERIOD This x from here <sil=0.607> ,COMMA I will create another x <sil=0.950> .PERIOD This <sil=0.555> ,COMMA who is the owner of this x <sil=0.926> ?QUESTIONMARK The owner of this x is only this function <sil=0.925> .PERIOD As long as this function is running <sil=0.549> ,COMMA this x has got a meaning <sil=0.984> .PERIOD It is existing <sil=0.503> ,COMMA after that it is not there <sil=0.935> .PERIOD But <sil=0.398> ,COMMA since I called it <sil=0.563> ,COMMA the value 10 was copied in this <sil=0.958> .PERIOD But <sil=0.369> ,COMMA you see these two are two different memory locations <sil=0.912> .PERIOD Consequently <sil=0.379> ,COMMA what is happening <sil=0.943> ?QUESTIONMARK When I printed here before x was 10 <sil=0.980> .PERIOD Now <sil=0.451> ,COMMA see which x is being printed <sil=0.963> ?QUESTIONMARK This x is being printed because this x is not known to this function <sil=0.945> .PERIOD This function only knows its own x <sil=0.904> .PERIOD Then <sil=0.635> ,COMMA x is changed to 5 <sil=0.989> .PERIOD That is also done locally here <sil=0.991> .PERIOD And <sil=0.376> ,COMMA it is being said here <sil=0.388> ,COMMA after that the x is 5 <sil=0.905> .PERIOD Because <sil=0.407> ,COMMA this x is known <sil=0.946> .PERIOD Then <sil=0.590> ,COMMA I return x <sil=0.918> .PERIOD So <sil=0.621> ,COMMA 5 is returned <sil=0.929> .PERIOD And 5 is assigned to x <sil=0.916> .PERIOD Now <sil=0.301> ,COMMA whenever I have gone out of this function <sil=0.367> ,COMMA this x is no longer existing <sil=0.973> .PERIOD Vanishes <sil=0.937> .PERIOD That means <sil=0.610> ,COMMA the compiler returns it to the memory pool <sil=0.990> .PERIOD Now <sil=0.487> ,COMMA which x is this x <sil=0.973> ?QUESTIONMARK This x <sil=0.972> .PERIOD So <sil=0.592> ,COMMA this value that is 5 <sil=0.359> ,COMMA that is being changed <sil=0.989> .PERIOD We will come here <sil=0.933> .PERIOD Now <sil=0.587> ,COMMA here I am doing print f x x <sil=0.991> .PERIOD That means <sil=0.430> ,COMMA both b is <sil=0.926> .PERIOD So <sil=0.445> ,COMMA x will be printed as 5 <sil=0.984> .PERIOD And <sil=0.535> ,COMMA b equals x <sil=0.943> .PERIOD So <sil=0.440> ,COMMA x is also 5 <sil=0.993> .PERIOD Here <sil=0.488> ,COMMA you see that the same value is the variable is x <sil=0.985> .PERIOD So <sil=0.534> ,COMMA both will be 5 <sil=0.969> .PERIOD So <sil=0.525> ,COMMA I hope you could understand this difference <sil=0.957> .PERIOD Let us take the another example <sil=0.904> .PERIOD Or <sil=0.556> ,COMMA we will come back to this in the next class <sil=0.945> .PERIOD And <sil=0.644> ,COMMA we will start with a new example and continue with parameter passing <sil=0.962> .PERIOD So <sil=0.479> ,COMMA what we learnt in today's lecture is a very important concept of call by value and call by reference <sil=0.994> .PERIOD And <sil=0.461> ,COMMA we could see that in C <sil=0.595> ,COMMA in general call by value is adopted except for arrays <sil=0.951> .PERIOD And <sil=0.439> ,COMMA what is call by value <sil=0.914> ?QUESTIONMARK Call by value means the calling function copies the value of the parameter to the variable <sil=0.915> .PERIOD Corresponding to the argument <sil=0.905> .PERIOD Whatever change is done is done locally inside that argument <sil=0.919> .PERIOD And <sil=0.501> ,COMMA when it is returned <sil=0.617> ,COMMA it goes back to the main function <sil=0.945> .PERIOD The value goes back to the main function <sil=0.970> .PERIOD Whereas <sil=0.634> ,COMMA in case of call by reference <sil=0.638> ,COMMA there is only one vessel <sil=0.389> ,COMMA one variable <sil=0.987> .PERIOD And <sil=0.469> ,COMMA I am not creating another variable <sil=1.000> .PERIOD I am simply passing the address of that variable to the called function and the call function changes in that particular variable <sil=0.954> .PERIOD And <sil=0.520> ,COMMA whatever changes are happening <sil=0.446> ,COMMA they are reflected in the main function <sil=0.602> ,COMMA a calling function as well <sil=0.993> .PERIOD We will continue with this <sil=0.945> .PERIOD In the last lecture <sil=0.537> ,COMMA we had discussed about two new operations that is post increment and pre increment <sil=0.980> .PERIOD Here <sil=0.428> ,COMMA you can see that we are calling them as prefix operation because the operator is before the operand <sil=0.931> .PERIOD Here <sil=0.351> ,COMMA you can see also the operator is before the operand and what is the operator <sil=0.968> ?QUESTIONMARK Operator is implementation <sil=0.378> ,COMMA but that is being denoted as plus plus twice the addition operation or twice the subtraction operation <sil=0.920> .PERIOD And in this <sil=0.539> ,COMMA here we are talking of we are calling it to be post-fix operation <sil=0.914> .PERIOD Here <sil=0.581> ,COMMA you can see that the operand is coming first and the operators are following <sil=0.968> .PERIOD So <sil=0.577> ,COMMA the operators are following that <sil=0.982> .PERIOD So <sil=0.495> ,COMMA that is why this is known as post-fix <sil=0.988> .PERIOD Here also <sil=0.543> ,COMMA you can see the operator operand to be I followed by the operator minus minus <sil=0.902> .PERIOD So <sil=0.329> ,COMMA that is why these are called post-fix of prefix <sil=0.966> .PERIOD The significance of these as we discussed in the last class is that a particular variable will be first implemented here in this case <sil=0.995> .PERIOD It will be first implemented and then used in the operation <sil=0.936> .PERIOD Here <sil=0.591> ,COMMA it will be first decremented <sil=0.599> ,COMMA then will be used in the operation <sil=0.926> .PERIOD While here <sil=0.330> ,COMMA it will be first the operation will be done and then the decrement will be done <sil=0.916> .PERIOD Here <sil=0.593> ,COMMA first the operation will be done <sil=0.613> ,COMMA then the increment will be done <sil=0.939> .PERIOD So <sil=0.518> ,COMMA we can so that is what we have written here first increment or decrement and then use it in the evaluation <sil=0.969> .PERIOD Here <sil=0.333> ,COMMA increment or decrement is done after being used in evaluation <sil=0.950> .PERIOD So <sil=0.371> ,COMMA it will be clearer when we come with some examples here was the examples that we have shown in the last class <sil=0.948> .PERIOD P and m are two variables <sil=0.986> .PERIOD M is initialized to 1 and when I am saying plus plus m that means <sil=0.338> ,COMMA first I increment m <sil=0.948> .PERIOD So <sil=0.411> ,COMMA m will be here you can see so m will be here you can see as soon as I do that m will become 2 and then that is being assigned to t <sil=0.934> .PERIOD So <sil=0.331> ,COMMA t becomes 2 whereas <sil=0.512> ,COMMA here you can see that m is 1 and we have done post increment <sil=0.973> .PERIOD So <sil=0.341> ,COMMA first the assignment operation will be done that means m was 1 <sil=0.912> .PERIOD So <sil=0.343> ,COMMA sorry m was 2 here after this I am doing this <sil=0.934> .PERIOD So <sil=0.543> ,COMMA m will be so t will be 1 <sil=0.975> .PERIOD So <sil=0.366> ,COMMA what will happen is m is 1 <sil=0.985> .PERIOD So <sil=0.608> ,COMMA that m will be assigned to t <sil=0.980> .PERIOD So <sil=0.574> ,COMMA t becomes 1 and after that m will be incremented <sil=0.918> .PERIOD So <sil=0.450> ,COMMA ultimately m will be 2 <sil=0.312> ,COMMA but t will be 1 <sil=0.998> .PERIOD So <sil=0.475> ,COMMA if you look at these two you will find the difference between them <sil=0.921> .PERIOD Let us have a few more examples <sil=0.968> .PERIOD Suppose we have got two variables A and B was initial values at 10 and 20 <sil=0.994> .PERIOD They are initialized to 10 and 20 <sil=0.917> .PERIOD Next we carry out look at this operation very carefully it looks a little clumsy <sil=0.989> .PERIOD Here there are two operators one is this one another one is this one <sil=0.908> .PERIOD So <sil=0.561> ,COMMA this is pre increment <sil=0.948> .PERIOD So <sil=0.542> ,COMMA this is equivalent to x is assigned 50 plus as if I have put a parenthesis that is not required that first A will be incremented and then that will be added to 50 <sil=0.991> .PERIOD So <sil=0.410> ,COMMA what result do we expect A was 10 <sil=0.328> ,COMMA A was 10 <sil=0.935> .PERIOD So <sil=0.304> ,COMMA first that will be incremented <sil=0.962> .PERIOD So <sil=0.577> ,COMMA that will be 11 and that will be added to 50 and so x will be x will get the value 61 <sil=0.962> .PERIOD So <sil=0.527> ,COMMA x will get 1 that is what will happen in this case <sil=0.906> .PERIOD So <sil=0.437> ,COMMA A is 11 and x is 61 as we have shown <sil=0.969> .PERIOD Now <sil=0.631> ,COMMA let us take this again this is the this is post increment <sil=0.985> .PERIOD So <sil=0.319> ,COMMA what do we expect here <sil=0.970> ?QUESTIONMARK Let us see what will happen in this case first here after the operation is done then A will be incremented <sil=0.941> .PERIOD So <sil=0.389> ,COMMA what will happen <sil=0.862> ?QUESTIONMARK x was 50 sorry I am sorry A was 10 and I am adding 50 and 10 and A that means 50 plus 10 <sil=0.980> .PERIOD So <sil=0.610> ,COMMA that becomes 60 and that 60 is being assigned to x because the assignment operation is taking precedence over this post increment <sil=0.902> .PERIOD So <sil=0.611> ,COMMA we get x to be 60 <sil=0.351> ,COMMA but I have my job is not yet clear because after A is participation in this operation it will be incremented by 1 <sil=0.964> .PERIOD So <sil=0.485> ,COMMA A was 10 then will be incremented by 1 <sil=0.967> .PERIOD So <sil=0.439> ,COMMA it will become 11 <sil=0.906> .PERIOD So <sil=0.620> ,COMMA consequently this is the result what we will get <sil=0.985> .PERIOD Now <sil=0.338> ,COMMA let us see what will happen in this case <sil=0.978> .PERIOD Now <sil=0.521> ,COMMA let us see what will happen in this case again here what do we expect to happen <sil=0.869> ?QUESTIONMARK A is 10 as usual A is 10 and B is 20 <sil=0.908> .PERIOD A is 10 as usual A is 10 and B is 20 <sil=0.943> .PERIOD What is being said here <sil=0.857> ?QUESTIONMARK A is post increment <sil=0.598> ,COMMA but B is pre increment <sil=0.479> ,COMMA pre decrement <sil=0.579> .PERIOD So <sil=0.313> ,COMMA first B will be decremented <sil=0.949> .PERIOD So <sil=0.307> ,COMMA B will become 19 <sil=0.929> .PERIOD Decrement means by 1 <sil=0.988> .PERIOD So <sil=0.354> ,COMMA it will be decremented it will be 19 <sil=0.979> .PERIOD It will be added to A <sil=0.980> .PERIOD What was A 10 <sil=0.999> ?QUESTIONMARK So <sil=0.470> ,COMMA these two will be added and what is that 29 and that 29 will go to x <sil=0.907> .PERIOD So <sil=0.516> ,COMMA x will be 29 and then my job is not yet clear and not it over <sil=0.993> .PERIOD So <sil=0.336> ,COMMA this will be incremented and A will be 11 <sil=0.976> .PERIOD So <sil=0.518> ,COMMA this is how the thing will happen <sil=0.986> .PERIOD So <sil=0.552> ,COMMA the result that we get in this case will be B will be 19 because B has been decremented <sil=0.995> .PERIOD x will be 29 and A will be 11 <sil=0.915> .PERIOD I hope you have understood the flow <sil=0.939> .PERIOD So <sil=0.625> ,COMMA now this is another one here we really do not know what to do because here I am implementing pre incrementing A post incrementing A here <sil=0.930> .PERIOD Now <sil=0.465> ,COMMA I will take this value of A <sil=0.968> .PERIOD Now <sil=0.511> ,COMMA what will happen <sil=0.932> ?QUESTIONMARK Suppose the problem here is suppose A is let us take the case here A to be taken as usual A <sil=0.923> .PERIOD So <sil=0.516> ,COMMA again now first I will decrement A <sil=0.956> .PERIOD I will increment A <sil=0.993> .PERIOD So <sil=0.614> ,COMMA A will be 11 but A was this A is not incremented <sil=0.999> .PERIOD So <sil=0.474> ,COMMA A minus 11 <sil=0.942> .PERIOD So <sil=0.605> ,COMMA 11 minus 11 will it be 0 and then this will be A will be 12 or which one will be done first <sil=0.944> .PERIOD This is a particular scenario <sil=0.905> .PERIOD For the same variable if the post incrementer <sil=0.441> ,COMMA post incrementer given often that is implementation dependent and the compiler does not take it well <sil=0.972> .PERIOD So <sil=0.529> ,COMMA it often results in undefined value <sil=0.926> .PERIOD So <sil=0.632> ,COMMA you should try to avoid this as much as possible <sil=0.920> .PERIOD Actually <sil=0.540> ,COMMA you should not use this <sil=0.970> .PERIOD You should use you can use this pre increment post increment <sil=0.964> .PERIOD But as I said in the last class <sil=0.338> ,COMMA I strongly suggest that the initial phase of programming you avoid using this pre increment post increment operation <sil=0.920> .PERIOD Instead <sil=0.448> ,COMMA although it will be a little laborious you write x assigned x plus 1 or x assigned x minus 1 for pre increment and pre increment <sil=0.964> .PERIOD But it is good to know that C allows us with this phase <sil=0.999> .PERIOD Now <sil=0.584> ,COMMA here is another one which at the initial phase you should not try to use unless you are very confident <sil=0.960> .PERIOD We know if condition then we do something else something <sil=0.992> .PERIOD So <sil=0.305> ,COMMA there are three things <sil=0.994> .PERIOD So <sil=0.501> ,COMMA this is the condition <sil=0.959> .PERIOD If some condition then although we do not write the then <sil=0.586> ,COMMA then we do some operation else we do some other operation <sil=0.902> .PERIOD Now <sil=0.363> ,COMMA the same thing can be written <sil=0.930> .PERIOD So <sil=0.561> ,COMMA it is call it a termed operation <sil=0.472> ,COMMA conditional operation <sil=0.974> .PERIOD Here we write it in a different way just to save space or now size I mean the size of the program <sil=0.937> .PERIOD What we do here say grade greater than equal to 60 print a past otherwise print a field <sil=0.945> .PERIOD So <sil=0.444> ,COMMA this means here this is the part is the condition part and this part is the part that will be computed if the condition is true and this part will be computed if the condition is false <sil=0.991> .PERIOD So <sil=0.500> ,COMMA this is equivalent to writing if grade greater than equal to 60 print f is equal to 60 <sil=0.908> .PERIOD So <sil=0.601> ,COMMA this is the past else print f failed <sil=0.913> .PERIOD This is equivalent to that <sil=0.922> .PERIOD So <sil=0.433> ,COMMA what is happening here in this example <sil=0.935> .PERIOD So <sil=0.525> ,COMMA the general syntax is if there is an expression if there is an expression there is a condition expression then we carry out if that is true then we carry out expression to otherwise if it is false then we carry out if it is true then we carry out this part this part that is the condition expression <sil=0.911> .PERIOD So <sil=0.321> ,COMMA this is the condition expression if there is an expression if there is an expression then we carry out if that is true then we carry out this part this part that is following interrogation mark and we carry out expression see that is the expression that is following the colon mark for the else case or if the condition is false <sil=0.975> .PERIOD So <sil=0.401> ,COMMA this is again writing that if then else in a cryptic shorter way this is known as turn in turn a conditional operation <sil=0.991> .PERIOD But again I say that this is a specialty of it is good to know that but initial phase at the initial phase of programming I discourage you to use this <sil=0.925> .PERIOD So <sil=0.355> ,COMMA here is an example what will this be can anyone tell me we are computing the interest on the amount of money you have got in bank this means here let us look at this part this is a turn ready operator if the balance is greater than 5000 then you compute balance times point 2 that means 20 percent of the balance or compute 10% of the balance if somebody has got a balance 6000 then have 20 percent of that computed and assign it to the interest part <sil=0.914> .PERIOD So <sil=0.463> ,COMMA you see a bigger statement if balance is bigger statement if balance is greater than 500 then interest equals balance multiplied by point 0 to else interest equal to balance multiplied by point 0 1 all these things can be done in one single sentence or one single statement using C <sil=0.966> .PERIOD So <sil=0.606> ,COMMA that is why some people prefer to use such turn ready operators and you will also certainly use it but when you are very confident about your program <sil=0.952> .PERIOD So <sil=0.449> ,COMMA this now we come to a new construct in order that is the switch construct now in order to understand thus let us quickly go to the flow chart for a while see I draw a flow chart like this I am evaluating some value here all right or maybe I get some value from the user here I read some value I make it clear I read some value from the user all right something read color now here depending on the color that the user supplies earlier in this decision box whatever you doing we were either going for true or for false now here what we are seeing if the color is red then we do something things here depending on the color that the user supplies earlier in decision box whatever you do and you are either going for true or for false now here what you are seeing If the color is red <sil=0.617> ,COMMA then we do something <sil=0.936> .PERIOD If the color is blue <sil=0.420> ,COMMA we do something <sil=0.913> .PERIOD If the color is magenta <sil=0.541> ,COMMA we do something <sil=0.970> .PERIOD If the color is orange <sil=0.403> ,COMMA then we do something <sil=0.945> .PERIOD If the color is violet <sil=0.424> ,COMMA we do something <sil=0.943> .PERIOD So <sil=0.613> ,COMMA the same diagram I can draw in a different way <sil=0.987> .PERIOD There is <sil=0.406> ,COMMA I am reading color and then as if I am coming to a switch box <sil=0.984> .PERIOD Think of this to be a switch box <sil=0.596> ,COMMA where number of switches are there <sil=0.940> .PERIOD And <sil=0.514> ,COMMA number of switches are there <sil=1.000> .PERIOD Now <sil=0.488> ,COMMA depending on what value of the color is coming <sil=0.997> .PERIOD So <sil=0.619> ,COMMA this may be the red switch <sil=0.513> ,COMMA this may be the blue switch <sil=0.414> ,COMMA this may be the orange switch <sil=0.942> .PERIOD Depending on which switch <sil=0.370> ,COMMA which value is coming <sil=0.928> .PERIOD So <sil=0.312> ,COMMA let the value be V <sil=0.934> .PERIOD If V is R <sil=0.366> ,COMMA then this switch gets closed and we follow this path <sil=0.982> .PERIOD If the V is blue <sil=0.631> ,COMMA then this switch gets closed and we follow this path <sil=0.972> .PERIOD If V is orange <sil=0.468> ,COMMA then this switch gets closed and we follow this path <sil=0.936> .PERIOD That is why <sil=0.612> ,COMMA because of this analogy with switch <sil=0.606> ,COMMA this statement is also known as switch statement <sil=0.950> .PERIOD This is also very much used for branching <sil=0.916> .PERIOD Branching we have seen with if L type of thing <sil=0.912> .PERIOD And <sil=0.314> ,COMMA here also we will see another variety of a C construct called switch using which we will do that <sil=0.936> .PERIOD So <sil=0.646> ,COMMA let us see here <sil=0.346> .PERIOD Now <sil=0.463> ,COMMA let us look at the construct of this <sil=0.944> .PERIOD The syntax of the switch statement is switch expression <sil=0.487> ,COMMA then case expression 1 <sil=0.573> ,COMMA expression 2 <sil=0.927> .PERIOD Let me give an example first <sil=0.455> ,COMMA then it will be better <sil=0.912> .PERIOD I will come back to this <sil=0.959> .PERIOD So <sil=0.640> ,COMMA here is the total switch structure <sil=0.901> .PERIOD It is a multiple selection structure <sil=0.939> .PERIOD So <sil=0.388> ,COMMA I come to this point <sil=0.600> ,COMMA switch if the case is A <sil=0.519> ,COMMA if it is the case that the color is red like that <sil=0.935> .PERIOD If the case is A <sil=0.445> ,COMMA then I take the case A action and then come out <sil=0.995> .PERIOD Otherwise <sil=0.479> ,COMMA I take the case B actions <sil=0.952> .PERIOD If the case B B <sil=0.348> ,COMMA then only I will take the case B action and then come out <sil=0.911> .PERIOD Similarly <sil=0.351> ,COMMA if there may be different cases <sil=0.918> .PERIOD So <sil=0.461> ,COMMA what we are getting here is an example that we are showing here <sil=0.982> .PERIOD What we are getting here is using this case construct multiple branching we are accommodating in one shot <sil=0.987> .PERIOD Let us look at this <sil=0.989> .PERIOD I was giving an example with color <sil=0.921> .PERIOD Here it is an example with a later <sil=0.946> .PERIOD So <sil=0.353> ,COMMA I have read some later from the user <sil=0.917> .PERIOD Some later has been now that later can be anything A to Z say A to Z <sil=0.907> .PERIOD So <sil=0.470> ,COMMA if the case is that the later is A <sil=0.507> ,COMMA look at how it has been written <sil=0.577> ,COMMA K A <sil=0.901> .PERIOD Before that switch <sil=0.626> ,COMMA what is my variable on which I am switching <sil=0.902> ?QUESTIONMARK Switch on variable later <sil=0.926> .PERIOD In the earlier example <sil=0.438> ,COMMA it was switch on the variable color <sil=0.974> .PERIOD So <sil=0.323> ,COMMA here we start with switch on the variable later and what are the possible switches <sil=0.890> ?QUESTIONMARK I encapsulate that in two places just as we do <sil=0.985> .PERIOD Now <sil=0.543> ,COMMA within this I am taking multiple decisions <sil=0.969> .PERIOD Multiple possibilities are there <sil=0.982> .PERIOD Multiple possibilities for example <sil=0.457> ,COMMA if the later is E that means <sil=0.472> ,COMMA if it is a case that the later is A <sil=0.458> ,COMMA then we put a semicolon <sil=0.948> .PERIOD Then I write down print a first letter <sil=0.911> .PERIOD So <sil=0.590> ,COMMA what will be printed <sil=0.945> ?QUESTIONMARK First letter and then there is a break statement <sil=0.983> .PERIOD What this break statement does <sil=0.999> ?QUESTIONMARK That you execute this and then you come out of this entire switch box <sil=0.999> .PERIOD Come out here <sil=0.987> .PERIOD It means <sil=0.567> ,COMMA join the next statement <sil=0.937> .PERIOD If the later was B <sil=0.331> ,COMMA then here it is not written <sil=0.991> .PERIOD I am writing K S B print F <sil=0.973> .PERIOD Second letter <sil=0.374> ,COMMA backslash N and then break <sil=0.905> .PERIOD That means <sil=0.637> ,COMMA if the case is B <sil=0.611> ,COMMA then I will print this and after that with a break <sil=0.555> ,COMMA I will come out of this <sil=0.998> .PERIOD Now <sil=0.410> ,COMMA after that I have not written anything else <sil=0.434> ,COMMA but I have written K S Z only this K S Z <sil=0.925> .PERIOD Print F last letter as is shown here and then break <sil=0.947> .PERIOD Now <sil=0.383> ,COMMA if somebody this later was P <sil=0.375> ,COMMA if this later was Q or some other alphabet <sil=0.375> ,COMMA sorry <sil=0.509> ,COMMA I mean anything small alphabet or capital alphabet X whatever <sil=0.345> ,COMMA in that case <sil=0.309> ,COMMA if it is B <sil=0.397> ,COMMA then I will write this as K S Z <sil=0.927> .PERIOD Now <sil=0.509> ,COMMA if somebody this later was P <sil=0.333> ,COMMA if this later was Q or some other alphabet <sil=0.469> ,COMMA sorry <sil=0.567> ,COMMA I mean anything small alphabet or capital alphabet X whatever <sil=0.573> .PERIOD In that case <sil=0.597> ,COMMA what do I do <sil=0.923> ?QUESTIONMARK This one only tells me what I can do if the later is A or if the later is Z or in my case <sil=0.418> ,COMMA if the later is B <sil=0.975> .PERIOD But <sil=0.438> ,COMMA if it be something else otherwise <sil=0.603> ,COMMA then we use this statement called the default statement <sil=0.918> .PERIOD If anything is other than what has been specified here <sil=0.522> ,COMMA then we will say that it is some other letter and then break <sil=0.918> .PERIOD You see here <sil=0.354> ,COMMA if the later is A <sil=0.400> ,COMMA then only I entered here and then went out <sil=0.999> .PERIOD If the later is B <sil=0.647> ,COMMA then I only entered here <sil=0.905> .PERIOD If the later is C <sil=0.637> ,COMMA then I will come to default <sil=0.965> .PERIOD If the later is C <sil=0.507> ,COMMA it is not specified here <sil=0.975> .PERIOD I will come here and I will F K <sil=0.963> .PERIOD I will do it right <sil=0.998> .PERIOD It is an intermediate letter and then come out <sil=0.994> .PERIOD So <sil=0.313> ,COMMA with this understanding <sil=0.534> ,COMMA if we can go back to the earlier slide <sil=0.501> ,COMMA the flow chart <sil=0.352> ,COMMA then we can see that the flow chart will be something like this <sil=0.941> .PERIOD If we start <sil=0.447> ,COMMA then we evaluate expression <sil=0.909> .PERIOD If we evaluate expression <sil=0.520> ,COMMA then we come here <sil=0.991> .PERIOD If it is equivalent to case A <sil=0.436> ,COMMA yes <sil=0.349> ,COMMA do something and then break <sil=0.934> .PERIOD Otherwise <sil=0.560> ,COMMA it will come here <sil=0.907> .PERIOD I am just doing this <sil=0.947> .PERIOD If K is Z <sil=0.580> ,COMMA if true <sil=0.364> ,COMMA then do something and then break <sil=0.916> .PERIOD Otherwise <sil=0.407> ,COMMA so this is true <sil=0.582> ,COMMA this is false <sil=0.982> .PERIOD Otherwise <sil=0.405> ,COMMA default <sil=0.305> ,COMMA I will come here <sil=0.592> ,COMMA do something and then break <sil=0.973> .PERIOD Now <sil=0.439> ,COMMA all these breaks <sil=0.484> ,COMMA all these breaks brings me to the next statement after the case statement <sil=0.944> .PERIOD So <sil=0.596> ,COMMA anything that is here <sil=0.377> ,COMMA whenever I encounter a break <sil=0.329> ,COMMA this brings me here <sil=0.960> .PERIOD This also brings me here <sil=0.971> .PERIOD And I continue following the sequential nature of program from here <sil=0.936> .PERIOD So <sil=0.532> ,COMMA we have seen <sil=0.969> .PERIOD Here is another nice example <sil=0.914> .PERIOD You can look at it <sil=0.954> .PERIOD Here <sil=0.474> ,COMMA switch <sil=0.501> ,COMMA I am switching on an expression <sil=0.939> .PERIOD What is that choice <sil=0.950> ?QUESTIONMARK Two offers <sil=0.901> .PERIOD Now <sil=0.477> ,COMMA this has got some multiple parameters into this <sil=0.963> .PERIOD Let me take it up in the next lecture so that I can devote some time on this <sil=0.994> .PERIOD Hello all <sil=0.618> ,COMMA welcome back to this lecture <sil=0.983> .PERIOD In this lecture we are going to look at what is called dynamic memory allocation <sil=0.904> .PERIOD So <sil=0.644> ,COMMA in all this time so far what we have been looking at is we know the size of the arrays or we know the number of different integers we want or the number of floating points we want and so on and that is not always something that you get <sil=0.949> .PERIOD So <sil=0.620> ,COMMA many times you may want to ask the user how big the number of elements you want and based on that you want to allocate arrays of an appropriate size and such <sil=0.987> .PERIOD So <sil=0.305> ,COMMA in this lecture module what we are going to look at is the notion of dynamic memory allocation <sil=0.972> .PERIOD So <sil=0.465> ,COMMA fundamental to various programming languages to be able to allocate memory only on demand <sil=0.329> ,COMMA only if the program needs it you allocate memory and whenever you do not need it that memory has to be reclaimed back and so on <sil=0.904> .PERIOD So <sil=0.443> ,COMMA to come to this lecture you should have a reasonable understanding of what pointers are and if you have not gone through the lecture on pointers <sil=0.915> .PERIOD So <sil=0.371> ,COMMA is strongly suggest that you go and review the lectures on pointers before you come back here <sil=0.977> .PERIOD So <sil=0.434> ,COMMA let us go back to the very first set of things that I talked about the notion of allocation of space <sil=0.927> .PERIOD So <sil=0.587> ,COMMA whenever we declare a variable of any data type there is allocation of space done to that <sil=0.988> .PERIOD So <sil=0.389> ,COMMA you take the amount of memory that is that and you go and reserve a certain sequence of bytes and say that this is useful for this variable and no other variable can use this location this is what we have been doing so far right <sil=0.983> .PERIOD Whenever I have int x or float y and so on we assume that there is a particular set of bytes that is already allocated by the compiler to go on for you to go and use <sil=0.958> .PERIOD So <sil=0.649> ,COMMA sometimes right when you look at these data types there are two questions that one could ask right and these two are not the same they are related but they are not the same <sil=0.942> .PERIOD When do we know the size to allocate <sil=0.856> ?QUESTIONMARK So <sil=0.595> ,COMMA if I ask you in if I have int x right do we know the size that we have to allocate <sil=0.968> ?QUESTIONMARK Yes if I specify int x I know that I have to reserve space for an integer right <sil=0.987> .PERIOD If I do if I do int of a comma a of 10 I want a to be an array of size 10 elements <sil=0.982> .PERIOD So <sil=0.490> ,COMMA I do know the size that I want but this is not the same as actually allocating space right <sil=0.981> .PERIOD So <sil=0.612> ,COMMA if I know the space that has to be allocated I do not have to immediately allocate the space I can allocate it when the program starts running right <sil=0.954> .PERIOD So <sil=0.351> ,COMMA I could do it at two possible times one is called compile time or static allocation and another is called run time or dynamic allocation right <sil=0.983> .PERIOD So <sil=0.409> ,COMMA generally if you know the size that has to be allocated which means if you know statically how much has to be allocated you would also do the allocation statically <sil=0.948> .PERIOD However <sil=0.316> ,COMMA if you do not know the size of the array that you want and so on right you have to wait till the program starts running when the program starts running you may have to ask the user how much you want based on that you need a mechanism by which you make reservation for only as many bytes as the programmer wanted right <sil=0.977> .PERIOD So <sil=0.597> ,COMMA that is called dynamic memory allocation and let us see what how the process goes <sil=0.970> .PERIOD So <sil=0.342> ,COMMA let us see this example character C <sil=0.907> .PERIOD The moment a compiler looks at it it knows that it needs only one byte because characters require only one byte <sil=0.917> .PERIOD However <sil=0.582> ,COMMA if you have a declaration of size int array of 10 <sil=0.941> .PERIOD So <sil=0.440> ,COMMA you need an integer is 4 bytes typically and that into 10 times you need at least 40 bytes right <sil=0.926> .PERIOD If the size is known it is generally also good to go and allocate the space as soon as the program starts running you will have 41 bytes allocated one byte for character C and another 40 bytes for array of 0 to array of 9 <sil=0.943> .PERIOD However <sil=0.423> ,COMMA sometimes we do not know how much memory to allocate <sil=1.000> .PERIOD So <sil=0.426> ,COMMA if I have int star array we may not know how big the array is going to be <sil=0.969> .PERIOD So <sil=0.615> ,COMMA it is a pointer to an integer right now <sil=0.997> .PERIOD So <sil=0.648> ,COMMA is it pointer to just one integer is it is it a pointer to 10 integers 100 integers 1 million integers we do not know that yet right <sil=0.901> .PERIOD But all we know is at this point of time we know that it is a pointer to a pointer to an integer right <sil=0.945> .PERIOD So <sil=0.618> ,COMMA how do we use this <sil=0.963> ?QUESTIONMARK So <sil=0.610> ,COMMA in star array if I have that I could make array 0 <sil=0.944> .PERIOD 2 something that is already allocated <sil=0.927> .PERIOD So <sil=0.565> ,COMMA I may have something like this <sil=0.988> .PERIOD So <sil=0.504> ,COMMA let us say I had a declaration of this form int B of 10 <sil=0.971> .PERIOD So <sil=0.508> ,COMMA B is already allocated its space for 10 into 4 40 bytes at least and I could make array 0 <sil=0.972> .PERIOD 2 B <sil=0.915> .PERIOD So <sil=0.516> ,COMMA I have B which is of 10 integers and I could make array point to that <sil=0.957> .PERIOD So <sil=0.331> ,COMMA when you make it point to that it will point to the 0th location of B <sil=0.926> .PERIOD So <sil=0.595> ,COMMA in this case allocation is already done <sil=0.924> .PERIOD But there are also places when the declaration is not done in which case you have to go and declare or you have to go and claim memory you have to allocate new memory and claim that space to be yours right now <sil=0.935> .PERIOD So <sil=0.576> ,COMMA this is something that you have to you probably remember from an earlier lecture <sil=0.986> .PERIOD So <sil=0.321> ,COMMA when I said something like instar p right p is just a point of variable it does not allocate an integer <sil=0.987> .PERIOD It only allocates a pointer which can point to some integer right <sil=0.963> .PERIOD But the integer itself is not allocated <sil=0.945> .PERIOD So <sil=0.518> ,COMMA in star array may have to be pointed to something that is already allocated <sil=0.974> .PERIOD But if it is already allocated I should know this size <sil=0.999> .PERIOD So <sil=0.488> ,COMMA this gets into a loop right this gets into a problem of knowing the size ahead of time <sil=0.990> .PERIOD So <sil=0.338> ,COMMA what we want is a mechanism by which the size may not be known and during the runtime of the program and the program already starts running only then you get to know the size and you want to allocate sizes appropriately <sil=0.977> .PERIOD So <sil=0.587> ,COMMA to do that there is a function called malloc or mloc as some people would call it <sil=0.905> .PERIOD So <sil=0.645> ,COMMA malloc is a function in C and it can take an integer as its input and it returns a pointer as its output <sil=0.955> .PERIOD And this function is it is in this library file called sdlib <sil=0.959> .PERIOD h <sil=0.994> .PERIOD So <sil=0.588> ,COMMA it is already given as a library to you you do not have to go and write your version of malloc <sil=0.994> .PERIOD So <sil=0.370> ,COMMA malloc is a function that is already defined in sdlib for you <sil=0.914> .PERIOD What it does is it follows <sil=0.929> .PERIOD You pass a size to it you pass a number of bytes that you want <sil=0.943> .PERIOD Let us say I want 10 integers right each integer is of 4 bytes I will pass 40 which is 10 times 4 to malloc <sil=0.903> .PERIOD What malloc would do is it would go and scan the memory that is there find out if there is a new space <sil=0.977> .PERIOD If there is a continuous chunk of unused space of 40 bytes it will claim that as a space that you want now and return it to you <sil=0.901> .PERIOD So <sil=0.324> ,COMMA if I have a huge array if I have a huge memory it is possible that some portions of the memory are already taken and some portions are not <sil=0.967> .PERIOD When malloc is called let us say I called it with 40 bytes I want 40 bytes to be allocated <sil=0.970> .PERIOD We will go and look at the first free space and ask is there 40 bytes in this space <sil=0.965> .PERIOD If the answer is no it would go and look at the next wide space wherever there is no allocation done is there 40 bytes there <sil=0.994> .PERIOD Once it finds out some free space with 40 bytes which are continuous it will return a pointer to the caller <sil=0.962> .PERIOD So <sil=0.533> ,COMMA in this case in this line here the caller is at this point right the caller called malloc malloc would return a pointer and what pointer does it return it actually returns what is called a wide pointer <sil=0.923> .PERIOD So <sil=0.596> ,COMMA it returns something called a wide pointer which means the data type is not important I have given you space right and then it is up to you to take that and typecast it to integer pointer or a character pointer and so on <sil=0.911> .PERIOD So <sil=0.346> ,COMMA in this case we ask for 10 integers 40 bytes you will get a pointer to 40 bytes you make that a pointer to in star <sil=0.981> .PERIOD So <sil=0.329> ,COMMA you make that a data type in star it now means you have a pointer which is an integer pointer data type <sil=0.995> .PERIOD On the left side you have an integer pointer data type and once you typecast the right side is also an integer pointer data type these two are matching <sil=0.991> .PERIOD So <sil=0.326> ,COMMA you can copy the value of this to the left side <sil=0.952> .PERIOD So <sil=0.540> ,COMMA now how do we ask for 40 bytes <sil=0.986> ?QUESTIONMARK We did not ask for 40 bytes explicitly instead we said give me number of items into size of an integer <sil=0.939> .PERIOD So <sil=0.324> ,COMMA this is something which is a common theme that you will see in malloc instead of actually specifying the number of bytes you say the number of elements that you want into size of each element <sil=0.906> .PERIOD So <sil=0.342> ,COMMA in this case num items is the number of items that we want and what we want we want integers of so many count <sil=0.949> .PERIOD So <sil=0.644> ,COMMA size of is an operator and see if you pass a variable to it it will return the number of bytes required we have already seen this before <sil=0.928> .PERIOD So <sil=0.544> ,COMMA this void star in this case is typecast into in star and this is a way to allocate memory <sil=0.966> .PERIOD So <sil=0.310> ,COMMA again in summary malloc is a function which is in STD lib <sil=0.923> .PERIOD If you pass the number of bytes to it it will go and scan the memory and find out if there is an unused space of so many bytes and once it finds out it it tells that this location is free for you to use go ahead and use it and you use it as a contiguous space of memory and contiguous space of memory is usually arrays <sil=0.977> .PERIOD So <sil=0.523> ,COMMA you get a pointer to an array <sil=0.976> .PERIOD So <sil=0.595> ,COMMA let us look at this small example here <sil=0.906> .PERIOD So <sil=0.362> ,COMMA we have two pointers namely star i and star array <sil=0.984> .PERIOD So <sil=0.629> ,COMMA i is a pointer of integer type and array is also a pointer to integers <sil=0.930> .PERIOD So <sil=0.441> ,COMMA in this line here we have i equals star malloc of size of int <sil=0.957> .PERIOD So <sil=0.367> ,COMMA we are claiming space only for one integer and i is going to point to it <sil=0.924> .PERIOD So <sil=0.320> ,COMMA i is a pointer to an integer whereas <sil=0.616> ,COMMA here we had asked for number of items into size of int we are asking for more than one integer depending on numby num items <sil=0.982> .PERIOD You get a pointer to so many bytes which can occupy num items integers and you get a pointer to that that goes into array <sil=0.968> .PERIOD So <sil=0.434> ,COMMA both i and array are pointers to integers only that i is pointing only to one integer whereas <sil=0.514> ,COMMA array is pointing to a series of locations right in this case num items locations <sil=0.946> .PERIOD So <sil=0.395> ,COMMA num array sorry array is pointing to num items integers <sil=0.915> .PERIOD So <sil=0.471> ,COMMA you can do star i equals 3 <sil=0.985> .PERIOD So <sil=0.328> ,COMMA that will change the contents of the memory location pointed to by i to 3 and you can do things like array of 3 is 5 <sil=0.982> .PERIOD So <sil=0.311> ,COMMA array of 3 is 5 is valid because if num items is greater than 4 then array of 3 is valid <sil=0.936> .PERIOD So <sil=0.643> ,COMMA array of 3 will point to the third location in the array and that is change to 5 <sil=0.968> .PERIOD i and array are interchangeable just because I have one integer allocated here and 4 integers or 5 integers allocated here it does not mean that i and array are incompatible <sil=0.970> .PERIOD If you go back to the definition both are integer pointers right <sil=0.992> .PERIOD So <sil=0.401> ,COMMA i and array are interchangeable <sil=0.911> .PERIOD So <sil=0.484> ,COMMA arrays can be thought of as pointers to the 0th element we have been doing this for a long time whenever I have an array I have been saying that we can abuse the notion of an array and say that is actually pointed to the 0th location <sil=0.961> .PERIOD So <sil=0.574> ,COMMA i could also point to an array as well <sil=0.946> .PERIOD So <sil=0.357> ,COMMA in fact <sil=0.422> ,COMMA I can do i equals array and I would start pointing to the array which array was pointing to earlier and these things can be changed over time both the variables i and array can change over course of the program <sil=0.912> .PERIOD So <sil=0.358> ,COMMA one thing that you have to be careful about is I said if maloch goes and finds out a chunk of space if that is free it will return the pointer to the chunk of space <sil=0.972> .PERIOD What if maloch does not find any free space <sil=0.948> ?QUESTIONMARK You wrote a program which is supposed to have process a lot of data and you want more memory allocated to the program you called maloch maloch went and looked at the memory and what if there was no more memory available <sil=0.964> .PERIOD In this case actually maloch does not return a valid location in the memory it returns the special case called null <sil=0.949> .PERIOD We have seen this before this NUL in capital letters is a special symbol it this cannot be any valid pointer right <sil=0.989> .PERIOD Because it is not any valid pointer and maloch if it returns that you know that there is some error that happened maloch tried to find out your 40 bytes or 100 bytes or 1 million bytes or whatever and if it was not able to find out continuous chunk of space of so many bytes it returns with null <sil=0.960> .PERIOD So <sil=0.477> ,COMMA it is your duty to go and check if maloch returned null or not <sil=0.975> .PERIOD If it returned null it means some problem happened in memory allocation you can print to the user that you actually ran out of the memory and you can do exit <sil=0.996> .PERIOD So <sil=0.334> ,COMMA this exit of 1 is again a function call which indicates some kind of an error <sil=0.946> .PERIOD So <sil=0.469> ,COMMA the moment some problem happens you may want to exit from the program and say I did not have enough space I could not have continued running the program <sil=0.960> .PERIOD But however <sil=0.310> ,COMMA if A is not null you will not print anything on the screen you will not call exit <sil=0.929> .PERIOD So <sil=0.375> ,COMMA A is successful successfully pointing to some allocation that you did and you can use the A you want it right <sil=0.973> .PERIOD So <sil=0.590> ,COMMA this is something that you have to keep in mind even though I am not going to show this thing in all the subsequent code <sil=0.981> .PERIOD So <sil=0.358> ,COMMA I will not have maloch followed by this check every time it is something that you have to do every time you have to go and check whenever you do a maloch it is possible that there is something that maloch cannot allocate therefore <sil=0.501> ,COMMA you have to check whether it return null or not <sil=0.941> .PERIOD It is not it is also not enough to just allocate memory you also have to think about what is called deallocation of memory <sil=0.967> .PERIOD So <sil=0.537> ,COMMA let us go and look at this piece of code here <sil=0.910> .PERIOD I have a function f which has int y and array of 10 these are local variables within the function f and I could so <sil=0.340> ,COMMA I know this from functions that since these are local variables they become alive only when the function is called and they are automatically killed and returned when the function returns they are automatically destroyed <sil=0.941> .PERIOD So <sil=0.303> ,COMMA we talked about this when we dealt with functions <sil=0.924> .PERIOD So <sil=0.439> ,COMMA local variables are good because when you call the function they become alive and when you return from the function they become dead <sil=0.990> .PERIOD So <sil=0.388> ,COMMA when you go to the end of this line f here y is an integer is deallocated array which is an array of 10 integers is also deallocated <sil=0.933> .PERIOD You cannot refer to y or you cannot refer to array the variable array anywhere outside f this is something that we know already <sil=0.913> .PERIOD So <sil=0.378> ,COMMA all automatic variables are created automatically and destroyed automatically that is why they are called automatic variables whereas <sil=0.619> ,COMMA if you do call something with malloc you are getting a pointer to the memory that was pointed to and it is your duty now you claim the memory you wanted some memory and you have to free it up <sil=0.949> .PERIOD So <sil=0.364> ,COMMA it has to be done using this function called free and forgetting to deallocate <sil=0.908> .PERIOD So <sil=0.625> ,COMMA let us say I claim some memory and I do not have use for it anymore I have to deallocate it and for that I will use free <sil=0.905> .PERIOD So <sil=0.610> ,COMMA for example <sil=0.526> ,COMMA here in star a is malloc so many bytes as nummitem integers demands and I use that if I do not have any use for it I should go and free up a <sil=0.939> .PERIOD So <sil=0.460> ,COMMA if you do not do that what might happen is that this chunk that you allocated may remain as somebody claimed it and somebody made a reservation and it is still being used that is how the compiler would treat it <sil=0.936> .PERIOD So <sil=0.482> ,COMMA this is like you go to a hotel let us say you go to a restaurant you make a phone call and you reserve a table right you reserve the table but you never turned up <sil=0.926> .PERIOD Then the restaurant would have to know at some point whether somebody is going to turn up and use the table or not right and if you are not going to call if you are not going to go to the restaurant it is good for you to call the restaurant and tell them I even though I called I made a reservation I do not want it anymore <sil=1.000> .PERIOD So <sil=0.416> ,COMMA that is equivalent to free or you actually went to the restaurant you had your meal you return back at that point it is not reserved anymore <sil=0.996> .PERIOD So <sil=0.624> ,COMMA you have to say that this table is not reserved anymore it has to be freed again <sil=0.919> .PERIOD So <sil=0.305> ,COMMA this is the equivalent or analogy that I can give you for maloch and free whenever you claim some space that is your duty to go back and tell the system to reclaim it you do not need a you do not need this anymore so <sil=0.472> ,COMMA once you free it you cannot use a anymore below this line <sil=0.912> .PERIOD So <sil=0.489> ,COMMA once I have freed a I do not have space reserved for a anymore a is not pointing to anything therefore <sil=0.422> ,COMMA I cannot say a of i equals 5 and so on I cannot do that I should either go and do new allocation or I should make a point to something that is already allocated <sil=0.937> .PERIOD So <sil=0.458> ,COMMA I could do something like a equals b if b was declared as int b of 10 or I could do new allocation as it was given here <sil=0.950> .PERIOD So <sil=0.643> ,COMMA you must not use a freed pointer unless it is reassigned or reallocated <sil=0.937> .PERIOD So <sil=0.478> ,COMMA keep this in mind <sil=0.917> .PERIOD So <sil=0.471> ,COMMA space allocated by maloch is freed when the program terminates <sil=0.954> .PERIOD So <sil=0.435> ,COMMA if you do not free up memory ever so <sil=0.368> ,COMMA you use allocate some memory you use it <sil=0.551> ,COMMA but let us say you do not do free and you keep doing that <sil=0.907> .PERIOD So <sil=0.316> ,COMMA slowly and steadily your memory will get used up at some point of time your memory might become full <sil=0.915> .PERIOD So <sil=0.495> ,COMMA in any of these cases right if you do not do explicit memory deallocation when the program exits your program is done with its work you do not need to claim the space anymore automatically everything gets deallocated by your operating system right <sil=0.936> .PERIOD So <sil=0.402> ,COMMA you can wait for your program to terminate and free up all memory that you that your program claimed <sil=0.900> .PERIOD So <sil=0.514> ,COMMA some people do that <sil=0.551> ,COMMA but that is not good practice <sil=0.983> .PERIOD So <sil=0.306> ,COMMA the good practice is as and when your program does not need some memory as well deallocated because your own program may need more memory for doing some more work later <sil=0.962> .PERIOD So <sil=0.442> ,COMMA let us look at a small function called create date it is going to take three integers month day and year and it is supposed to return a date right <sil=0.919> .PERIOD So <sil=0.315> ,COMMA let us say I did this date start d <sil=0.902> .PERIOD So <sil=0.340> ,COMMA d is a pointer of the type date and remember it does not allocate memory to it does not allocate three things for month day and year right <sil=0.912> .PERIOD It only this it declars a pointer to type date <sil=0.900> .PERIOD So <sil=0.524> ,COMMA you have space for a pointer <sil=0.388> ,COMMA but the actual members are not allocated yet and let us say you did this d is month is supposed to be the month that you passed on d is day is supposed to be the day that you passed on and d is year is supposed to be the year that you passed on and return the pointer d <sil=0.970> .PERIOD Let us say we did this right <sil=0.945> .PERIOD So <sil=0.531> ,COMMA this would be this would be wrong because d is not allocated any memory right <sil=0.980> .PERIOD So <sil=0.646> ,COMMA the correct way to do that is as follows d is a pointer first allocate space and how much space do you want to allocate <sil=0.907> ?QUESTIONMARK I want to allocate space for one date type and what does this date type have <sil=0.898> ?QUESTIONMARK It has one month field one day field and one year field right we need three things <sil=0.983> .PERIOD So <sil=0.611> ,COMMA when you see size of date size of date is three integers one for month one for day and one for year and when you do malloc of size of date that returns a pointer that is assigned to d <sil=0.996> .PERIOD So <sil=0.527> ,COMMA now d is actually pointing to an allocated space <sil=0.994> .PERIOD Once it is pointing to allocated space it is okay to do d arrow month d arrow day and d arrow year and when you return d you are actually returning a pointer to the result space <sil=0.922> .PERIOD So <sil=0.377> ,COMMA the result space still exists and you are returning a pointer to the result space <sil=0.907> .PERIOD So <sil=0.551> ,COMMA the function on the right side is correct whereas <sil=0.416> ,COMMA the function on the left side is not because you do not allocate space on the left side you explicitly allocated space on the right side <sil=0.971> .PERIOD So <sil=0.561> ,COMMA one thing we have to do is even though the space is explicitly allocated remember create date is not responsible for deallocating it right you are not explicitly deallocating it yet <sil=0.942> .PERIOD You have only explicitly allocated it that somebody is job to come and deallocated later we will see who the somebody must be later <sil=0.936> .PERIOD Let us see a small thing here right <sil=0.903> .PERIOD So <sil=0.510> ,COMMA date start today today is create date 9 1 2005 and do return <sil=0.986> .PERIOD So <sil=0.381> ,COMMA I want to do let us say 9th of January 2005 <sil=0.902> .PERIOD I created a variable called today <sil=0.955> .PERIOD So <sil=0.409> ,COMMA today is a pointer to the date type called date create date in turn returns a pointer to data type called date I use today and then I returned it <sil=0.965> .PERIOD So <sil=0.304> ,COMMA at this point create date allocated some memory and you got that in today <sil=0.915> .PERIOD So <sil=0.452> ,COMMA let us look at the sequence of things right <sil=0.901> .PERIOD So <sil=0.531> ,COMMA inside this function called FU so <sil=0.482> ,COMMA today is a local variable and what is today <sil=0.892> ?QUESTIONMARK It is actually a pointer it is supposed to point to a point to a date data type and when you called create date <sil=0.937> .PERIOD So <sil=0.530> ,COMMA inside create date you allocated space 1 for date 1 for month and 1 for year you allocated space for the structure you return the pointer to this <sil=0.966> .PERIOD So <sil=0.415> ,COMMA at this point your today field is pointing to the location that you gave for the structure and let us say we used today and we return we came to the end of it <sil=0.985> .PERIOD At this point we return from FU what would happen now since today is a local variable within FU today gets destroyed it is an automatic variable right the automatic variable gets destroyed <sil=0.912> .PERIOD So <sil=0.306> ,COMMA whoever called FU cannot access today because today is a local variable within FU and because today is lost you also lost a pointer to some reserved space that you had <sil=0.979> .PERIOD You reserved space for a structure but today which was holding the pointer to the structure was destroyed <sil=0.991> .PERIOD Therefore <sil=0.491> ,COMMA you lost the trail to go back to the memory that you allocated <sil=0.987> .PERIOD So <sil=0.456> ,COMMA this is a problem <sil=0.959> .PERIOD So <sil=0.485> ,COMMA whenever you have something that is allocated from a function and if you put that in the local variable and if you did not explicitly deallocate it that thing is still going to lurk around this structure that you had is still going to lurk around and you will have no way to free it this will get freed only when the program gets done <sil=0.985> .PERIOD So <sil=0.610> ,COMMA you have to be careful about it <sil=0.976> .PERIOD So <sil=0.330> ,COMMA there are various possible solutions and the cleanest solution is let us say I did create date I did whatever I want to do with date I know that I do not need date anymore and I am returning from the function as well free today <sil=0.978> .PERIOD So <sil=0.563> ,COMMA that so <sil=0.467> ,COMMA when you say free today the function will go and look at the space allocated or reserved for it and remove the reservation <sil=0.915> .PERIOD So <sil=0.442> ,COMMA that space can be used by the program some other part of the program <sil=0.919> .PERIOD So <sil=0.616> ,COMMA this free takes care of that and when you return it you have already taken care of whatever allocation you have done you have removed your reservation <sil=0.928> .PERIOD So <sil=0.517> ,COMMA now I am good to see show you sequence of various things and I want to argue about why something is correct or why something is incorrect <sil=0.982> .PERIOD So <sil=0.438> ,COMMA let us look at the function on the left side <sil=0.945> .PERIOD So <sil=0.416> ,COMMA in star f so <sil=0.319> ,COMMA f is a function and I is a local variable within the function and you are returning address to the local variable right <sil=0.943> .PERIOD So <sil=0.392> ,COMMA that is what this in star does <sil=0.991> .PERIOD So <sil=0.345> ,COMMA in star means you are returning pointer to an integer is this something that you can do this is not possible because when the function gets returned I is a local variable I gets destroyed it is not correct to track the address of I anymore <sil=0.924> .PERIOD So <sil=0.369> ,COMMA this is not correct it is deallocate in I you cannot track it anymore <sil=0.930> .PERIOD Let us look at this function on the right side it is also supposed to return an integer star it is it is returning a pointer to an integer <sil=0.903> .PERIOD So <sil=0.354> ,COMMA here you have a local variable called array which is an array of 10 integers and you return array which means you are returning the location of the zeroth element of array <sil=0.925> .PERIOD But again you this return array is supposed to return a pointer to the zeroth location <sil=0.336> ,COMMA but since array is local to make array array gets destroyed when you return from make array <sil=0.901> .PERIOD So <sil=0.364> ,COMMA you are having a pointer that is actually pointing to a location that you cannot claim to be yours anymore <sil=0.958> .PERIOD So <sil=0.531> ,COMMA this is a problem <sil=0.943> .PERIOD So <sil=0.542> ,COMMA if you do this sometimes it will look like this whole thing is actually working <sil=0.982> .PERIOD So <sil=0.365> ,COMMA this might work because when you return back from this make array maybe the space is still containing all the values nobody reclaimed it <sil=0.975> .PERIOD So <sil=0.349> ,COMMA when you go back to that location you still see the values <sil=0.409> ,COMMA but if you are unfortunate this memory location that you did not want anymore got used up somewhere else and now you are actually accessing something that is not supposed to be used by you <sil=0.961> .PERIOD So <sil=0.344> ,COMMA the space if it is reallocated this becomes unpredictable <sil=0.319> ,COMMA but if the space is not reallocated to anyone else it might work <sil=0.970> .PERIOD In general you should not rely on the space to be unallocated you should not believe that oh I am hoping that it is unallocated let me go and use it that is not correct you should treat it should be conservative and you should say that I will assume that it is going to be reallocated therefore <sil=0.472> ,COMMA I will free it up here and I will not pass pointers back to local variables <sil=0.981> .PERIOD So <sil=0.327> ,COMMA if you want to really pass pointers to local variables or anything that you allocate inside if you first of all do dynamic allocation and you pass on a pointer this is correct <sil=0.945> .PERIOD Similarly <sil=0.487> ,COMMA here you did dynamic allocation <sil=0.966> .PERIOD So <sil=0.513> ,COMMA these 10 integers are not going to be deallocated when the function returns and because of that it is ok to return a pointer to that <sil=0.948> .PERIOD So <sil=0.519> ,COMMA you allocate with malloc and return the pointer <sil=0.933> .PERIOD So <sil=0.490> ,COMMA this is allowed <sil=0.983> .PERIOD So <sil=0.639> ,COMMA now let us go and look at how to allocate multi-dimensional arrays <sil=0.901> .PERIOD It is not just that we look for single-dimensional arrays or an array of integers array of characters and so on many times you want to build matrices or 3D matrices and so on how do we do it <sil=0.914> .PERIOD So <sil=0.311> ,COMMA we start with in star star p <sil=0.979> .PERIOD So <sil=0.491> ,COMMA the meaning of that is p is a pointer to a pointer to an integer <sil=0.912> .PERIOD So <sil=0.359> ,COMMA let us see what that means <sil=0.919> .PERIOD So <sil=0.400> ,COMMA p is not pointing to an integer <sil=0.969> .PERIOD P in turn is pointing to another pointer which is in turn pointing to a some integer <sil=0.966> .PERIOD So <sil=0.403> ,COMMA that is the meaning of in star star p <sil=0.961> .PERIOD So <sil=0.415> ,COMMA p is supposed to be pointing to another pointer which is in turn pointing to an integer <sil=0.952> .PERIOD And int is a so int i is declaring space for an integer i <sil=0.994> .PERIOD Now <sil=0.541> ,COMMA let us see how to allocate a multi-dimensional array <sil=0.932> .PERIOD So <sil=0.396> ,COMMA the first thing you do is let us say I want m rows and n columns <sil=0.910> .PERIOD So <sil=0.513> ,COMMA the first thing you do is allocate m pointers first <sil=0.992> .PERIOD So <sil=0.322> ,COMMA we have m pointers that are being allocated and this is not going to get pointed to anything <sil=0.924> .PERIOD So <sil=0.583> ,COMMA you have m pointers <sil=0.986> .PERIOD We do that first and then each pointer variable you now make an allocation of n integers <sil=0.999> .PERIOD So <sil=0.302> ,COMMA you allocate m pointers to integers and then you allocate n integers at a time and this will suppose this is supposed to give you n integers <sil=0.932> .PERIOD So <sil=0.359> ,COMMA each row you get from a malloc and you have m rows that gives you a m cross n matrix <sil=0.906> .PERIOD So <sil=0.427> ,COMMA let us break this down <sil=0.976> .PERIOD The first thing we have done is a malloc of size of in star <sil=0.920> .PERIOD So <sil=0.352> ,COMMA size of in star is size of integer pointer not size of integer it is size of integer pointer and we want m integer pointers <sil=0.920> .PERIOD Let us say you got them you got m integer pointers and they are not going to point to anything because malloc does not initialize <sil=0.998> .PERIOD So <sil=0.496> ,COMMA what do you get in return <sil=0.877> ?QUESTIONMARK malloc will return a pointer to 10 let us say 10 rows you will get pointers to an array of pointers and these are pointing to 10 integer arrays <sil=0.903> .PERIOD So <sil=0.588> ,COMMA an in star star tells you that the left side is expecting a pointer to a pointer it is not a pointer to an integer it is a pointer to a pointer to an integer <sil=0.998> .PERIOD And once you have that you have all these pointers which can which are ready to now point to the 10 different rows <sil=0.645> ,COMMA but you have not allocated space for the rows yet and that is done inside a loop <sil=0.937> .PERIOD So <sil=0.550> ,COMMA this loop goes from i equals 0 to m minus 1 and you are allocating one row at a time and each row is of size n integers <sil=0.990> .PERIOD So <sil=0.302> ,COMMA that is what you have here <sil=0.905> .PERIOD So <sil=0.342> ,COMMA this is a very basic way in which m rows by n columns is allocated at the end you actually have m and elements <sil=0.926> .PERIOD In fact <sil=0.554> ,COMMA once you have this you can use p of i j to access the elements <sil=0.965> .PERIOD So <sil=0.440> ,COMMA just like you would access array of i comma j to dimensional array of i comma j <sil=0.624> ,COMMA p is a pointer to a pointer to an integer you can use p of i comma j to get to the basic elements <sil=0.985> .PERIOD So <sil=0.528> ,COMMA it would be incorrect to access p of i j if you have not done this or if you have not done this <sil=0.939> .PERIOD You should have done both these mallocs <sil=0.974> .PERIOD So <sil=0.567> ,COMMA you have you should have done a malloc for 10 pointers to integers and you should have allocated for each pointer to point to a row of n numbers <sil=0.994> .PERIOD So <sil=0.519> ,COMMA that will give us 10 rows by n columns <sil=0.970> .PERIOD So <sil=0.515> ,COMMA let us look at how to de-allocate multi-dimensional arrays <sil=0.973> .PERIOD So <sil=0.354> ,COMMA right now you have let us say 10 pointers pointing to one row each and each row is of size n elements <sil=0.922> .PERIOD So <sil=0.551> ,COMMA you have m of these and you have n of those <sil=0.964> .PERIOD What you do is you first go and do free of p of i and you iterate i from 0 to m minus 1 <sil=0.914> .PERIOD So <sil=0.335> ,COMMA when you say free p of i you start with p of 0 <sil=0.432> ,COMMA p of 0 free p of 0 will de-allocate that free p of 1 will de-allocate this row p of 2 being freed will de-allocate this row and so on free p of m minus 1 will de-allocate this row <sil=0.947> .PERIOD So <sil=0.314> ,COMMA you have done with deallocating all the integers <sil=0.409> ,COMMA but you still have all these pointers that you allocated <sil=0.571> ,COMMA right <sil=0.935> .PERIOD And the way you allocated that was p was pointing to all these 10 things as though they were an array of pointers <sil=0.969> .PERIOD And when you do free of p it also de-allocates all the pointers <sil=0.927> .PERIOD At this point the point of p is not pointing to anything valid you make p equals null <sil=0.974> .PERIOD So <sil=0.521> ,COMMA essentially what you have is you have a sequence of steps <sil=0.902> .PERIOD When you want to allocate two dimensional arrays you first go and allocate a pointer to a pointer to the basic data type and you iterate over that one at a time and allocate rows <sil=0.950> .PERIOD When you de-allocate you de-allocate all the rows one at a time and then you de-allocate the array of pointers itself <sil=0.976> .PERIOD So <sil=0.497> ,COMMA this is the way you allocate and de-allocate pointers <sil=0.964> .PERIOD So <sil=0.478> ,COMMA first free all the rows <sil=0.473> ,COMMA free the array of pointers make p point to the null and you are done <sil=0.993> .PERIOD So <sil=0.602> ,COMMA this is you keep p will keep pointing to null until there is new allocation <sil=0.957> .PERIOD So <sil=0.331> ,COMMA with this we are end of at this lecture about pointers and how to use dynamic memory allocation for not just one de arrays it can also be two de arrays <sil=0.996> .PERIOD The basic element that you store in an array can be an integer can be a float it can be a character it can also be structures <sil=0.915> .PERIOD You can have a 2D matrix of structures where each element could be an integer containing x and integer containing y maybe you have a 2D array of pointers that is possible <sil=0.954> .PERIOD So <sil=0.387> ,COMMA to summarize what we have is we have a mechanism a general mechanism by which as long as I know the size of the basic data type that I want I will allocate bytes as many as I need I will get a pointer done by returned by malloc I should point it to the appropriate data type and whenever this memory is not needed anymore you should be really careful and de-allocate the memory <sil=0.920> .PERIOD So <sil=0.484> ,COMMA that your memory is not hogged your program itself further down may need more memory <sil=0.903> .PERIOD If you did not free up something that you do not need you may get stuck <sil=0.960> .PERIOD So <sil=0.431> ,COMMA this brings us to the end of the lecture <sil=0.927> .PERIOD Thank you <sil=0.928> .PERIOD There are many other applications like constructing the expression tree from the post order expression <sil=0.968> .PERIOD I will leave you with an idea as to how to go over it <sil=0.957> .PERIOD Suppose <sil=0.566> ,COMMA I have A <sil=0.508> ,COMMA B <sil=0.447> ,COMMA C plus and star <sil=0.429> ,COMMA what we do is <sil=0.535> ,COMMA when we have symbols <sil=0.364> ,COMMA first we have again a forest of trees <sil=0.479> ,COMMA pointing to A <sil=0.549> ,COMMA this pointing to B <sil=0.346> ,COMMA this point <sil=0.586> ,COMMA as you traverse from the left to right of this expression <sil=0.388> ,COMMA as you move from left to right of this expression <sil=0.574> ,COMMA what you do <sil=0.613> ,COMMA you just create pointers to trees in a forest <sil=0.921> .PERIOD Then <sil=0.522> ,COMMA what you do is <sil=0.609> ,COMMA you come across plus <sil=0.329> ,COMMA then you create a new node with plus and then you take the topmost two <sil=0.614> ,COMMA it is like a stack <sil=0.633> ,COMMA this is actually like a stack <sil=0.621> ,COMMA then you <sil=0.403> ,COMMA this is actually a stack of trees <sil=0.596> ,COMMA what we do is <sil=0.304> ,COMMA now I put this from left to right <sil=0.409> ,COMMA I put the trees <sil=0.508> ,COMMA A <sil=0.984> ,COMMA B <sil=0.380> ,COMMA and C and then as you come across the operator <sil=0.534> ,COMMA what do I do <sil=0.929> ,COMMA I pop the most recent two trees <sil=0.324> ,COMMA then I create a new tree with a plus and I make the first tree <sil=0.474> ,COMMA the left child <sil=0.345> ,COMMA the most recently popped out tree <sil=0.478> ,COMMA the left child and the previously popped out tree <sil=0.570> ,COMMA the right child <sil=0.950> .PERIOD Now <sil=0.647> ,COMMA again I have one more symbol left <sil=0.387> ,COMMA I come across the star <sil=0.433> ,COMMA so I pop out these trees and I create <sil=0.587> ,COMMA put on to the stack <sil=0.320> ,COMMA the star and the two popped trees become the <sil=0.528> ,COMMA the most recently popped tree becomes the right child and the most recently popped tree becomes the left and the previously popped tree becomes the right child and as soon as until you get a single tree which exists on the stack <sil=0.936> .PERIOD So <sil=0.542> ,COMMA there is another application of binary trees and stacks <sil=0.519> ,COMMA both of them can be used quite efficiently to build what are called expression trees <sil=0.907> .PERIOD So <sil=0.495> ,COMMA this is a very <sil=0.564> ,COMMA very useful application of binary trees <sil=0.331> ,COMMA now there is another thing that we always like to do when we build binary trees <sil=0.562> ,COMMA let us take this expression tree itself <sil=0.390> ,COMMA let us to cut an expression <sil=0.508> ,COMMA let say we have something like this <sil=0.558> ,COMMA then we have what are we doing when an expression is evaluated <sil=0.370> ,COMMA it is evaluated from the left <sil=0.915> .PERIOD So <sil=0.344> ,COMMA let say I have this <sil=0.502> ,COMMA here plus star <sil=0.395> ,COMMA we see actually you go over this from the right and let me <sil=0.366> ,COMMA let say I form an expression tree <sil=0.633> ,COMMA I do not know how many of you are familiar <sil=0.558> ,COMMA we use this kind of a expression parsing to do this expression term or expression and term is factor or factor and let say factor is a name as in this example <sil=0.464> ,COMMA what is name let say this a b so on over here <sil=0.983> .PERIOD Suppose I use this grammar <sil=0.411> ,COMMA let say factor is a name as in this example <sil=0.480> ,COMMA what is name let say this a b so on over here <sil=0.991> .PERIOD Suppose I use this grammar to generate this expression <sil=0.575> ,COMMA you have already done a course on compilance <sil=0.334> ,COMMA let see this is completely an unambiguous grammar <sil=0.397> ,COMMA the add of here is plus or minus <sil=0.493> ,COMMA melt off is star or slash let say <sil=0.938> .PERIOD So <sil=0.380> ,COMMA how do we parse this given expression <sil=0.587> ,COMMA so start from the root over here <sil=0.588> ,COMMA expression is defined as expression add operator term <sil=0.593> ,COMMA so I stop it <sil=0.594> ,COMMA start it over here plus then what do we have <sil=0.599> ,COMMA then on the left hand side <sil=0.534> ,COMMA another plus again at the plus <sil=0.356> ,COMMA then I will get a here <sil=0.462> ,COMMA I will get star b c and star d plus e f <sil=0.380> ,COMMA this is how you will get a binary tree <sil=0.409> ,COMMA what have I done now all this exercise that I have done is to this show that an expression <sil=0.381> ,COMMA harmless expression that is written like this can be written as a binary tree <sil=0.985> .PERIOD Now <sil=0.636> ,COMMA what we will do is we will talk about other things now <sil=0.518> ,COMMA we will talk about traversal of these trees of this tree <sil=0.622> ,COMMA let say what it gives us <sil=0.534> ,COMMA there are three types of traversals <sil=0.524> ,COMMA pre order <sil=0.527> ,COMMA post order and in order <sil=0.625> ,COMMA okay <sil=0.939> .PERIOD Now <sil=0.558> ,COMMA the definitions are given over here <sil=0.444> ,COMMA how to traverse these trees <sil=0.409> ,COMMA so pre order traversals says visit the root <sil=0.547> ,COMMA then what do you do <sil=0.323> ,COMMA you visit the left child in pre order recursively <sil=0.503> ,COMMA visit the right child in pre order recursively means what now <sil=0.419> ,COMMA let us take the <sil=0.648> ,COMMA then the in order traversals says visit the left child in in order recursively <sil=0.628> ,COMMA visit the root <sil=0.617> ,COMMA visit the right child in in order recursively <sil=0.623> ,COMMA okay <sil=0.971> .PERIOD Then post order traversals says visit the left child in post order and visit the right child in post order recursively visit the root <sil=0.639> ,COMMA okay <sil=0.911> .PERIOD Alright <sil=0.363> ,COMMA let us see what this gives <sil=0.308> ,COMMA so everything has to be done recursively <sil=0.536> ,COMMA what is the meaning of this <sil=0.999> ,COMMA okay <sil=0.928> ,COMMA let us look at in order traversal <sil=0.461> ,COMMA visit the left child in in order recursively <sil=0.513> ,COMMA okay <sil=0.983> .PERIOD Let us say I want to do this traversal of the tree <sil=0.560> ,COMMA okay <sil=0.958> ,COMMA traversal means simply walking around the tree <sil=0.435> ,COMMA okay <sil=0.947> .PERIOD That is the way the list of notes is what changes <sil=0.945> .PERIOD Now <sil=0.606> ,COMMA what does it say <sil=0.432> ,COMMA let us look at in order traversal <sil=0.420> ,COMMA it says first we look at in order because it will become clear to you what we are doing <sil=0.426> ,COMMA visit left child recursively <sil=0.341> ,COMMA visit root and visit right child recursively is what you are in order traversal <sil=0.419> ,COMMA so let us look at the tree what would we do <sil=0.413> ,COMMA that means I am starting from the root here and I am going to recursively keep on going down to this until I reach the leaf note <sil=0.931> .PERIOD Then what do we do <sil=0.578> ,COMMA so let us look at the tree what would we do <sil=0.400> ,COMMA so that means I am starting from the root here and I am going to recursively keep on going down to this until I reach the leaf note <sil=0.918> .PERIOD Then what do I do <sil=0.918> ,COMMA I display the leaf note <sil=0.302> ,COMMA so I keep going down because I have to visit the left most children <sil=0.590> ,COMMA then what happens I go up <sil=0.553> ,COMMA okay <sil=0.917> ,COMMA then I visit the root and get plus <sil=0.343> ,COMMA then again I go to the right child and again after recursively do the same thing <sil=0.484> ,COMMA that means what free order in order all these are recursive traversals <sil=0.449> ,COMMA okay <sil=0.901> ,COMMA so I go to the right child <sil=0.499> ,COMMA then again I will do left child recursively root <sil=0.530> ,COMMA then then right child and then go back up <sil=0.564> ,COMMA then what happens here <sil=0.592> ,COMMA so I come down this plus go down here <sil=0.587> ,COMMA this becomes B star C <sil=0.518> ,COMMA okay and then what happens <sil=0.535> ,COMMA this is node has already been visited <sil=0.314> ,COMMA so I go back up to the root of the tree <sil=0.459> ,COMMA give me plus <sil=0.428> ,COMMA then again I come to the right node star <sil=0.371> ,COMMA again I have to do recursively left child <sil=0.623> ,COMMA right <sil=0.946> ,COMMA so I do D <sil=0.404> ,COMMA I come to the leaf node star <sil=0.571> ,COMMA then I have to have E plus F <sil=0.368> ,COMMA the bracket has to come because it is one level lower <sil=0.547> ,COMMA so in order traversal essentially gives me the expression back <sil=0.505> ,COMMA so what does it tell me now <sil=0.400> ,COMMA when I look at the in order traversal of the tree I get the infix expression of the given tree <sil=0.524> ,COMMA okay <sil=0.945> ,COMMA there is one extra information that we have used here <sil=0.361> ,COMMA we use the fact that star is done after plus because it is one level lower in the tree <sil=0.548> ,COMMA okay <sil=0.980> ,COMMA so I get the infix expression <sil=0.564> ,COMMA so let us look at what post order expression <sil=0.402> ,COMMA post order traversal of the tree will give you <sil=0.349> ,COMMA what does post order traversal say <sil=0.515> ,COMMA post order traversal say <sil=0.316> ,COMMA visit left child post order <sil=0.559> ,COMMA post order recursively <sil=0.547> ,COMMA then visit right child in post order recursively <sil=0.613> ,COMMA visit root and the same thing keeps on getting repeated again and again <sil=0.494> ,COMMA so I take the left child recursively visit in post order <sil=0.588> ,COMMA let me just explain this over here <sil=0.483> ,COMMA let us see what this will give us <sil=0.329> ,COMMA what does it give you <sil=0.419> ,COMMA so I visit the left child <sil=0.343> ,COMMA I come came down there are no more leaf nodes <sil=0.481> ,COMMA so I display A <sil=0.448> ,COMMA then I have to go to the right child <sil=0.596> ,COMMA go back <sil=0.950> ,COMMA right <sil=0.916> ,COMMA left child <sil=0.485> ,COMMA right child and then root is what it is <sil=0.381> ,COMMA go to the right child <sil=0.335> ,COMMA then right child again I have to recursively go down do post order <sil=0.522> ,COMMA right left child <sil=0.650> ,COMMA right child <sil=0.535> ,COMMA then root <sil=0.310> ,COMMA so what will happen <sil=0.596> ,COMMA I get A <sil=0.467> ,COMMA B <sil=0.352> ,COMMA C <sil=0.404> ,COMMA star <sil=0.476> ,COMMA then what do I get <sil=0.445> ,COMMA now all of them have been visited <sil=0.351> ,COMMA I go back up <sil=0.310> ,COMMA so left child <sil=0.465> ,COMMA right child <sil=0.618> ,COMMA then root <sil=0.488> ,COMMA plus here and then what happens <sil=0.635> ,COMMA so the left child of this root tree is completed <sil=0.616> ,COMMA now so I go to the right tree over here <sil=0.647> ,COMMA then what do I get now <sil=0.389> ,COMMA what do I get here <sil=0.641> ,COMMA now I get D <sil=0.569> ,COMMA then again this is the left child is the leaf node <sil=0.581> ,COMMA there is nothing else to see <sil=0.322> ,COMMA therefore I display the leaf node <sil=0.308> ,COMMA then I go to its right child <sil=0.305> ,COMMA again I have to look at post order over there <sil=0.560> ,COMMA therefore I get E F plus <sil=0.341> ,COMMA because E left child post order <sil=0.503> ,COMMA right child post order root <sil=0.386> ,COMMA then I put the plus over here <sil=0.479> ,COMMA that is how it comes here and then finally the star and then finally the plus <sil=0.396> ,COMMA the last plus sign <sil=0.551> ,COMMA let me have <sil=0.436> ,COMMA sorry <sil=0.494> ,COMMA may be mistake here <sil=0.304> ,COMMA this plus should not be here <sil=0.637> ,COMMA see A <sil=0.360> ,COMMA B <sil=0.328> ,COMMA C <sil=0.614> ,COMMA star <sil=0.606> ,COMMA then I have to do the right child <sil=0.469> ,COMMA D <sil=0.517> ,COMMA F plus star plus <sil=0.561> ,COMMA so what did we get now <sil=0.568> ,COMMA we got A <sil=0.480> ,COMMA B <sil=0.440> ,COMMA C <sil=0.550> ,COMMA star plus correct <sil=0.441> ,COMMA D <sil=0.527> ,COMMA E <sil=0.589> ,COMMA F correct <sil=0.565> ,COMMA sorry <sil=0.313> ,COMMA plus is there <sil=0.631> ,COMMA correct <sil=0.511> ,COMMA D <sil=0.305> ,COMMA F plus star plus <sil=0.308> ,COMMA how many are there <sil=0.455> ,COMMA 1 <sil=0.339> ,COMMA 2 <sil=0.328> ,COMMA 1 <sil=0.325> ,COMMA 2 <sil=0.312> ,COMMA 1 <sil=0.596> ,COMMA 2 <sil=0.349> ,COMMA 1 <sil=0.420> ,COMMA 3 <sil=0.584> ,COMMA correct <sil=0.488> ,COMMA so this is what we get as the expression <sil=0.465> ,COMMA what is this expression now <sil=0.430> ,COMMA this is nothing but the post fix expression <sil=0.327> ,COMMA which all of us have already been done <sil=0.329> ,COMMA where we talked about stacked <sil=0.571> ,COMMA we talked about generating a post fix expression from an infix expression <sil=0.376> ,COMMA so what is interesting here is <sil=0.390> ,COMMA once it is represented as a binary tree <sil=0.381> ,COMMA if I do in order to the traversal <sil=0.611> ,COMMA I get the infix expression <sil=0.366> ,COMMA where I do post order traversal <sil=0.613> ,COMMA I get the post fix expression and obviously if I do pre order traversal <sil=0.453> ,COMMA I will get the prefix expression <sil=0.618> ,COMMA so this is also a very big application of binary trees <sil=0.459> ,COMMA now once this expression is given like this <sil=0.337> ,COMMA I can use this stack of trees to evaluate this particular expression <sil=0.634> ,COMMA so I hope you are with me here and you have understood what I have said <sil=0.401> ,COMMA so what is it that we are doing <sil=0.370> ,COMMA notice that <sil=0.539> ,COMMA another way of looking at these various traversals <sil=0.318> ,COMMA to make it simpler is pre order traversal can be thought of as <sil=0.551> ,COMMA you display the node the first time you visited <sil=0.440> ,COMMA in order traversal you display the node the second time you visited <sil=0.551> ,COMMA remember I have drawn this path over here <sil=0.557> ,COMMA which goes around the tree and in post order traversal <sil=0.385> ,COMMA you display the node the last time you visited <sil=0.378> ,COMMA so these are simple traversal schemes <sil=0.572> ,COMMA so now the next question that we would like to ask is <sil=0.493> ,COMMA suppose you are given only the traversals <sil=0.478> ,COMMA only the traversals are given <sil=0.480> ,COMMA can we construct the tree exactly <sil=0.639> ,COMMA let us look at only with respect to binary trees and see if I am given the <sil=0.415> ,COMMA what is it that we have <sil=0.412> ,COMMA you have two traversals now <sil=0.548> ,COMMA in order traversal and we have the post order traversal <sil=0.496> ,COMMA we can also do the pre order <sil=0.537> ,COMMA I encourage you to do the pre order traversal of the tree <sil=0.608> ,COMMA now given the in order traversal can I construct the tree uniquely <sil=0.512> ,COMMA without any other information and given the post order traversal can I construct the tree uniquely <sil=0.592> ,COMMA let us see how we will do this in the next lecture <sil=0.954> .PERIOD Good morning students <sil=0.336> ,COMMA this is the course on programming and data structures and Professor Shankar Balchandran has already taught you programming in C and I will be teaching you data structures and algorithms in this part of the course <sil=0.983> .PERIOD So <sil=0.577> ,COMMA first what we will do is as part of this course <sil=0.611> ,COMMA before we go on to data structures <sil=0.549> ,COMMA we will first do a basic recap of the building blocks for programs <sil=0.496> ,COMMA especially we look at the controlled structures which you have already studied <sil=0.395> ,COMMA we just do a recap <sil=0.624> ,COMMA we will do a little formally <sil=0.975> .PERIOD We will also look at arrays and functions which are where arrays are data structures that are already available in C or C plus plus or Java or whatever and also recursive data structures which are available for you to work with in program programming languages <sil=0.936> .PERIOD You already study this but we will just recap that and then once you write a program <sil=0.494> ,COMMA we want to see how efficient a program is <sil=0.345> ,COMMA how well does it work on a particular kind of input data <sil=0.937> .PERIOD So <sil=0.470> ,COMMA we will study complexity analysis and here what I will do is I will give some kind of formal way of finding the complexity of programs <sil=0.564> ,COMMA there are those square be some rule in the product too which we will learn in great detail <sil=0.390> ,COMMA we will also analyze recursive functions <sil=0.965> .PERIOD Then we will also recap basic sorting and searching algorithms <sil=0.607> ,COMMA we will look at primarily two types of sorting algorithms and two types of searching algorithms <sil=0.948> .PERIOD Then once we have done this and by then we are equipped with the ability to analyze programs in a big way <sil=0.328> ,COMMA we will start defining what are called abstract data types <sil=0.961> .PERIOD What are abstract data types <sil=0.987> ?QUESTIONMARK There are special types of organizations of data structures and programs which make an abstract data type and these abstract data types are actually user defined and why do we do this <sil=0.948> ?QUESTIONMARK Because we define operations and abstract data types which can be done in a very efficient way for problem solving <sil=0.459> ,COMMA trees and other abstract data type <sil=0.941> .PERIOD For example <sil=0.519> ,COMMA if I want to represent by family tree <sil=0.493> ,COMMA I would need a different kind of a data structure and we will define operations in the tree <sil=0.498> ,COMMA I would define who is a grand parent and who is a grand child and so on and so forth <sil=0.926> .PERIOD So <sil=0.423> ,COMMA you need a specific structure called tree with operations defined on it <sil=0.919> .PERIOD Then we will define what are called priority cues which are similar to the cues that we see originally <sil=0.449> ,COMMA but the priority added to them <sil=0.906> .PERIOD Then we will do data structures on hash tables where we would like that any operation can be performed very quickly and finally <sil=0.317> ,COMMA we will look at graphs <sil=0.963> .PERIOD For example <sil=0.319> ,COMMA if you look at the internet today <sil=0.426> ,COMMA internet is actually a graph of nodes that are connected together <sil=0.918> .PERIOD So <sil=0.641> ,COMMA if I want to any kind of analysis of the network <sil=0.424> ,COMMA I need a graph abstract data and we will talk about that <sil=0.902> .PERIOD So <sil=0.387> ,COMMA let us look at the recap of basic programming <sil=0.925> .PERIOD You already learned problem solving using C <sil=0.980> .PERIOD So <sil=0.350> ,COMMA you might not have heard or might not have heard of this <sil=0.918> .PERIOD So <sil=0.485> ,COMMA basically what we talk about is here is when you given a problem to solve <sil=0.337> ,COMMA you define what is called an algorithm to solve the problem <sil=0.981> .PERIOD When you have an algorithm now <sil=0.451> ,COMMA it is a prescription to solve a program problem which provided it is hopefully executed is a result of finite number of steps <sil=0.940> .PERIOD That means <sil=0.368> ,COMMA what am I going to write <sil=0.911> ?QUESTIONMARK I am going to it is like a recipe to solve a problem and the recipe is such that if it is followed by a pattern <sil=0.608> ,COMMA it will solve the problem in a finite number of steps <sil=0.976> .PERIOD I like to define programming as borrowing from Gugano <sil=0.901> .PERIOD It is a means to translate the sequence of steps that you have written in some kind of English like sentences <sil=0.905> .PERIOD You set such instructions that can be understood by the computer <sil=0.955> .PERIOD For example <sil=0.328> ,COMMA what we are trying to do here is <sil=0.551> ,COMMA we are separating algorithm and programming here <sil=0.907> .PERIOD And algorithm is written in an English type of statement <sil=0.914> .PERIOD Whereas <sil=0.632> ,COMMA a programming is done in a particular language C or C plus plus Java <sil=0.529> ,COMMA Python <sil=0.459> ,COMMA whatever it may be <sil=0.948> .PERIOD Here is a functional specification of a program that I have given <sil=0.915> .PERIOD This is something that I advise all my students <sil=0.997> .PERIOD When you write a program to solve a problem <sil=0.630> ,COMMA I would say instead of just going to the computer and start keying in right away <sil=0.474> ,COMMA first thing that you have to start looking at is define a name for the program <sil=0.951> .PERIOD What is it solve <sil=0.947> ?QUESTIONMARK Give it a name <sil=0.974> .PERIOD Then you <sil=0.518> ,COMMA it is like making a recipe to bake a cake or whatever it may be <sil=0.982> .PERIOD You have to find the ingredients <sil=0.951> .PERIOD What are the ingredients here <sil=0.894> ?QUESTIONMARK The declaration of local variables <sil=0.949> .PERIOD Then <sil=0.429> ,COMMA we to solve the particular problem <sil=0.992> .PERIOD Then <sil=0.499> ,COMMA you define what are called on the local variables <sil=0.947> .PERIOD What are the conditions that must be satisfied by the local variables so that the program as expected that is called a pre-condition <sil=0.974> .PERIOD Then <sil=0.303> ,COMMA you give the body of the program <sil=0.596> ,COMMA which is a gamma set of instructions <sil=0.955> .PERIOD Then after the program is executed <sil=0.320> ,COMMA what is the post-condition <sil=0.872> ?QUESTIONMARK What are the results or the goal that you expect to reach <sil=0.962> ?QUESTIONMARK So <sil=0.418> ,COMMA first you <sil=0.499> ,COMMA I would say that give the name of the program <sil=0.513> ,COMMA the declaration of local variables <sil=0.541> ,COMMA pre-condition and post-condition <sil=0.989> .PERIOD And then you start set out to write a program that solves this <sil=0.971> .PERIOD So <sil=0.522> ,COMMA let us take a specific example now <sil=0.936> .PERIOD Let us take <sil=0.587> ,COMMA I want to write a program to exchange <sil=0.929> .PERIOD I am sure you have already seen this two variables <sil=0.921> .PERIOD X and Y <sil=0.985> .PERIOD Let us assume <sil=0.975> .PERIOD X and Y are integer <sil=0.919> .PERIOD So <sil=0.551> ,COMMA what is the function specification say <sil=0.870> ?QUESTIONMARK I will write this in C <sil=0.985> .PERIOD Although <sil=0.456> ,COMMA ideally you should write it in English like statement <sil=0.909> .PERIOD So <sil=0.536> ,COMMA you give the program a name <sil=0.345> ,COMMA program exchange <sil=0.919> .PERIOD In the name that is given to be program <sil=0.922> .PERIOD And I am writing the main program name and integer <sil=0.903> .PERIOD I define the local variables now <sil=0.303> ,COMMA X <sil=0.562> ,COMMA Y <sil=0.981> .PERIOD If I want to effect the six change <sil=0.611> ,COMMA I will need a temporary variable unless I want to do a more efficient program <sil=0.395> ,COMMA which does not use a temporary variable <sil=0.924> .PERIOD Then maybe I want to read the values <sil=0.966> .PERIOD X <sil=0.394> ,COMMA M percent <sil=0.924> .PERIOD Of course <sil=0.334> ,COMMA I am assuming that you have included standard IO dot H <sil=0.976> .PERIOD Then what do we do <sil=0.365> ?QUESTIONMARK We assign temp equals x and x equals Y and then Y equals temp and that is the end of the program <sil=0.948> .PERIOD So <sil=0.528> ,COMMA now what do I need now <sil=0.980> ?QUESTIONMARK I need to know what is the precondition on this <sil=0.872> ?QUESTIONMARK X and Y are arbitrary <sil=0.960> .PERIOD That means it can take any values <sil=0.954> .PERIOD And what you see is the post condition <sil=0.461> ,COMMA the values of X and Y are interchange <sil=0.907> .PERIOD You have already seen the statement <sil=0.981> .PERIOD So <sil=0.408> ,COMMA look at the body of the program here <sil=0.519> ,COMMA scan F <sil=0.948> .PERIOD This is not relevant to the exchange process <sil=0.953> .PERIOD We are just reading the variable X and Y <sil=0.900> .PERIOD So <sil=0.630> ,COMMA this is the main body of the program <sil=0.929> .PERIOD And where are these statements <sil=0.934> ?QUESTIONMARK This is a particular control structure that is available in any programming language and it is called the assignment statement <sil=0.968> .PERIOD You can write very large programs with simply assignment statements <sil=1.000> .PERIOD For example <sil=0.468> ,COMMA what is an assignment statement now in general <sil=0.883> ?QUESTIONMARK It is a variable on the left hand side of the equal sign and C <sil=0.907> .PERIOD And on the right hand side <sil=0.516> ,COMMA it can have an expression and so on <sil=0.979> .PERIOD This is an arithmetic expression <sil=0.911> .PERIOD I can also have suppose X equal to 0 <sil=0.953> .PERIOD I can also write Y is equal to 0 <sil=0.963> .PERIOD And when it becomes a Boolean expression <sil=0.968> .PERIOD So <sil=0.623> ,COMMA you can write large programs simply writing the assignment statement itself <sil=0.925> .PERIOD But there is a bit of a drawback with this because all that I can do is simply expression evaluation whether it is an arithmetic expression <sil=0.517> ,COMMA logical expression or whatever <sil=0.915> .PERIOD Now <sil=0.471> ,COMMA suppose now I want to modify this and say I want to exchange X and Y only if X and Y are both greater than 0 <sil=0.968> .PERIOD Then what do I have to do <sil=0.908> ?QUESTIONMARK I have to make a change to the body of the program <sil=0.920> .PERIOD What do I do to the body of the program <sil=0.855> ?QUESTIONMARK I say X greater than 0 and the sand and the sand Y greater than 0 to flower bracket <sil=0.943> .PERIOD Then these statements will be executed <sil=0.908> .PERIOD Y equal to n <sil=0.983> .PERIOD Then what happens now <sil=0.948> ?QUESTIONMARK My first condition also is staged <sil=0.988> .PERIOD So <sil=0.507> ,COMMA what is the post condition become here <sil=0.887> ?QUESTIONMARK The post condition will be X and Y are exchanged if both X and Y are greater than 0 <sil=0.989> .PERIOD So <sil=0.357> ,COMMA you need to whereas the input condition on the other hand is still remaining the same <sil=0.943> .PERIOD So <sil=0.616> ,COMMA this is how I would expect you to do this <sil=0.969> .PERIOD And as you keep on increasing the size of programs for this small segment it is nice to put a pre condition and a post condition to show what you will what we expect <sil=0.949> .PERIOD Now <sil=0.572> ,COMMA what I could do is this is an F statement over here and this is a new type of a control structure which you have already seen <sil=0.941> .PERIOD It is called alternative statement sometimes also known as a selection statement <sil=0.958> .PERIOD Now <sil=0.470> ,COMMA clearly the alternative statement is not <sil=0.332> ,COMMA it is not only one alternative <sil=0.906> .PERIOD They can be a number of alternatives <sil=0.995> .PERIOD I could say X greater than 0 <sil=0.549> ,COMMA Y greater than 0 <sil=0.489> ,COMMA do one thing <sil=0.985> .PERIOD X greater than 0 <sil=0.471> ,COMMA Y less than 0 <sil=0.524> ,COMMA do something else <sil=0.924> .PERIOD X equal 0 <sil=0.646> ,COMMA Y equal to 0 <sil=0.360> ,COMMA do something <sil=0.987> .PERIOD So <sil=0.393> ,COMMA one then all these can be written F condition 1 body of program <sil=0.928> .PERIOD Let me call it program 1 <sil=0.368> ,COMMA then L sif condition 2 <sil=0.605> ,COMMA then you have another body of the program <sil=0.476> ,COMMA L sif condition 3 and so on <sil=0.974> .PERIOD Can keep on extending this to a large number of alternative statements <sil=0.909> .PERIOD So <sil=0.558> ,COMMA the alternative statement is a very powerful statement using which you can satisfy a large number of conditions that may be there on the input data <sil=0.946> .PERIOD Notice that and every time what I will advise you to do is in every case for every small piece of code <sil=0.510> ,COMMA what is the input condition <sil=0.481> ,COMMA what is the output condition <sil=0.991> .PERIOD So <sil=0.412> ,COMMA this is the alternative statement <sil=0.964> .PERIOD The next statement which you have already learnt is what is called the repetitive statement <sil=0.931> .PERIOD Suppose <sil=0.352> ,COMMA we want to perform an operation a number of times <sil=0.404> ,COMMA then we use what is called a repetitive statement <sil=0.955> .PERIOD Let me give you an example <sil=0.353> ,COMMA a simple for block statement that is made up of a for block plus plus let us say n is equal to 10 <sil=0.931> .PERIOD And I have initialized sum to 0 <sil=0.529> ,COMMA sum is equal to sum plus i <sil=0.952> .PERIOD So <sil=0.537> ,COMMA what do we have now <sil=0.415> ,COMMA what is it tell me here <sil=0.366> ,COMMA this for statement says for i equal to 0 and while i is less than n <sil=0.417> ,COMMA that means this is the initial value <sil=0.931> .PERIOD And till it reaches the final value of n <sil=0.411> ,COMMA just increment i by 1 and compute sum of i plus i <sil=0.317> ,COMMA sum plus i <sil=0.988> .PERIOD So <sil=0.589> ,COMMA what have we done here <sil=0.619> ,COMMA we just computing the sum of the first n number starting from 0 <sil=0.934> .PERIOD So <sil=0.557> ,COMMA the simple form of a repetitive statement <sil=0.929> .PERIOD Now <sil=0.372> ,COMMA whatever you do is <sil=0.626> ,COMMA I am going to take you a little further and let us look at this <sil=0.302> ,COMMA you already done the latest common divisor and in the programming part of the course <sil=0.984> .PERIOD And we will see how you learnt about Euclid's algorithm there and we will put this in the form that I have been talking about <sil=0.917> .PERIOD So <sil=0.518> ,COMMA what is the greatest common divisor <sil=0.476> ,COMMA all of you know what it is <sil=0.630> ,COMMA let us just recap again <sil=0.922> .PERIOD Suppose <sil=0.343> ,COMMA I have two numbers <sil=0.458> ,COMMA one is of size 30 and other is of size 80 and let us say I want to find the GCD of 30 and 80 <sil=0.937> .PERIOD GCD is also the highest common factor between these two numbers <sil=0.902> .PERIOD You have done this in school <sil=0.365> ,COMMA what did you do in school <sil=0.608> ,COMMA you took the number 30 and said let me write it in terms of its prime factors <sil=0.939> .PERIOD All of you know what a prime number is <sil=0.301> ,COMMA prime number is 1 <sil=0.358> ,COMMA which is divisible only by itself and 1 <sil=0.907> .PERIOD I take 18 also <sil=0.595> ,COMMA write it in terms of its prime factors to 3 <sil=0.972> .PERIOD All right <sil=0.945> ,COMMA then what would you do <sil=0.523> ,COMMA you cross out the common terms in both the numbers <sil=0.572> ,COMMA this is to common terms in both the numbers <sil=0.591> ,COMMA multiply these two and you will write that 6 is the highest common factor or GCD of the two numbers <sil=0.950> .PERIOD Now <sil=0.457> ,COMMA what will do is you already done I guess <sil=0.612> ,COMMA nuclear solverism <sil=0.546> ,COMMA let us just recap it <sil=0.363> ,COMMA this is slightly more efficient algorithm <sil=0.967> .PERIOD When you put it on the computer <sil=0.404> ,COMMA what we normally do is the following <sil=0.310> ,COMMA as indicated in this program here <sil=0.626> ,COMMA we take 30 <sil=0.598> ,COMMA we divide by 80 <sil=0.430> ,COMMA we get the value of 12 <sil=0.956> .PERIOD So <sil=0.487> ,COMMA let me say this is 12 <sil=0.488> ,COMMA then what do we do <sil=0.596> ,COMMA then we divide 18 by 12 <sil=0.552> ,COMMA this will give me 6 and then I divide 12 by 6 and the remainder becomes 0 <sil=0.528> ,COMMA that means I have found the latest common divisor <sil=0.971> .PERIOD So <sil=0.563> ,COMMA to recap again <sil=0.529> ,COMMA I take the number 30 divided by 18 <sil=0.629> ,COMMA then what happens <sil=0.852> ,COMMA the remainder is 12 <sil=0.543> ,COMMA which I have marked here <sil=0.383> ,COMMA then I take the smaller two numbers 18 and 12 <sil=0.303> ,COMMA I divide 18 by 12 <sil=0.453> ,COMMA then the remainder is 6 <sil=0.323> ,COMMA then once again I take the smaller of the two three numbers <sil=0.322> ,COMMA just 12 and 6 <sil=0.614> ,COMMA I divide 12 by 6 <sil=0.498> ,COMMA the remainder becomes 0 <sil=0.959> .PERIOD So <sil=0.325> ,COMMA once the remainder is 0 <sil=0.609> ,COMMA we are done <sil=0.558> ,COMMA this algorithm is called U-clitz algorithm for computing G-cd <sil=0.981> .PERIOD So <sil=0.499> ,COMMA what have I done here <sil=0.518> ,COMMA I have written this in C over here <sil=0.938> .PERIOD So <sil=0.343> ,COMMA notice that <sil=0.618> ,COMMA this is a different form of a repetitious statement <sil=0.640> ,COMMA it is saying do until the remainder is m percent n and m is set to n <sil=0.613> ,COMMA n is set to the remainder <sil=0.502> ,COMMA while the remainder not equal to 0 <sil=0.922> .PERIOD So <sil=0.572> ,COMMA what will be the precondition <sil=0.551> ,COMMA m and n have to be non-zero positive integers and the <sil=0.496> ,COMMA what is the post condition that is satisfied <sil=0.621> ,COMMA that you found the G-cd of m and n <sil=0.963> .PERIOD Here <sil=0.517> ,COMMA another way of writing this same program <sil=0.480> ,COMMA using another type of repetition statement called while n not equal to n <sil=0.575> ,COMMA if m greater than n <sil=0.624> ,COMMA then you keep on reducing one number by the other until it becomes equal to <sil=0.306> ,COMMA until both the numbers become equal <sil=0.574> ,COMMA when the two numbers become equal <sil=0.506> ,COMMA it will give you the G-cd of the two numbers <sil=0.954> .PERIOD So <sil=0.555> ,COMMA what have we done here <sil=0.490> ,COMMA notice that within this two block <sil=0.621> ,COMMA you have a set of <sil=0.511> ,COMMA the body of the program consists of a set of assignment statements <sil=0.600> ,COMMA here within the by-by block <sil=0.600> ,COMMA here for example <sil=0.422> ,COMMA there is an alternative statement and within the alternative statement <sil=0.614> ,COMMA there is an assignment statement and so on <sil=0.916> .PERIOD So <sil=0.452> ,COMMA what we have done is <sil=0.520> ,COMMA we have looked at the basic building blocks of programs <sil=0.550> ,COMMA assignment statements <sil=0.445> ,COMMA alternative statements <sil=0.420> ,COMMA repetitive statements and what we do <sil=0.395> ,COMMA we basically kept on adding complexity to the way we wrote programs such that all these statements were being used <sil=0.972> .PERIOD Next <sil=0.399> ,COMMA what we will do is <sil=0.619> ,COMMA so this is all very fine <sil=0.526> ,COMMA what we do now <sil=0.334> ,COMMA so basically if you look at your program now <sil=0.313> ,COMMA a large program can be written with the assignment <sil=0.468> ,COMMA the alternative and the repetitive statement <sil=0.901> .PERIOD Now <sil=0.493> ,COMMA it will also be very nice <sil=0.477> ,COMMA if you can have two things <sil=0.311> ,COMMA one is I want to write a program which generates long <sil=0.301> ,COMMA long lasting computations <sil=0.912> .PERIOD I also want a program which can process arbitrary quantity of data and you have already seen in the programming course <sil=0.503> ,COMMA how do you do this <sil=0.303> ,COMMA yes you guessed it right <sil=0.319> ,COMMA we need a function module and the data must be stored in an array <sil=0.966> .PERIOD So <sil=0.614> ,COMMA basically what we are looking at is a program segment that refers to a state space of an arbitrary number of dimensions <sil=0.994> .PERIOD Using arrays and functions <sil=0.442> ,COMMA program segments can be made to process an arbitrary number of dimensions of data <sil=0.951> .PERIOD So <sil=0.557> ,COMMA here is one example again <sil=0.644> ,COMMA you already know what an array is <sil=0.336> ,COMMA I want to reverse the elements of an array <sil=0.453> ,COMMA so I have written one function here which will <sil=0.522> ,COMMA which we already saw the swap for example <sil=0.464> ,COMMA here it is done with a function for example <sil=0.339> ,COMMA I am taking an argument to characters and I want to reverse the string in place <sil=0.383> ,COMMA that is the objective <sil=0.917> .PERIOD So <sil=0.610> ,COMMA that means I have a string like this <sil=0.374> ,COMMA let us say I want write a program of this kind <sil=0.314> ,COMMA where I am taking a string <sil=0.417> ,COMMA I have a string like this and I want to reverse the string <sil=0.374> ,COMMA I want to use this output <sil=0.365> ,COMMA I want to do it in the same array <sil=0.589> ,COMMA let us say this is the array a <sil=0.579> ,COMMA so this is 0 <sil=0.594> ,COMMA 1 <sil=0.410> ,COMMA 2 <sil=0.314> ,COMMA 3 <sil=0.325> ,COMMA 4 <sil=0.502> ,COMMA 5 and this again the same array <sil=0.604> ,COMMA I want to do this in place <sil=0.926> .PERIOD How do we effect this <sil=0.977> ?QUESTIONMARK We simply exchange the first two elements <sil=0.562> ,COMMA the next two elements and then the middle two elements and that we give us the string and that is what this piece of code is doing <sil=0.929> .PERIOD The exchange operation is being done by this swap over here and you already know why we have to pass it with the <sil=0.594> ,COMMA as a point of the simple reason that see does not support pass by reference <sil=0.643> ,COMMA it only supports pass by value <sil=0.931> .PERIOD So <sil=0.387> ,COMMA basically the contents of x location 0 <sil=0.926> .PERIOD 2 by x are exchanged with the contents of y <sil=0.346> ,COMMA but basically the addresses is what we return back to the main program <sil=0.989> .PERIOD So <sil=0.332> ,COMMA what is the program and what have what are we doing here <sil=0.943> ?QUESTIONMARK As I said I come to the divide the array into till the middle for example <sil=0.335> ,COMMA until I can I start from here exchange this <sil=0.576> ,COMMA here exchange with this <sil=0.326> ,COMMA here exchange with this and then once I reach the middle of the array I am done and that is precisely what this program is trying to do and what are we doing till length by 2 I am swapping the two elements <sil=0.389> ,COMMA swapping is exchanging the two elements in the array <sil=0.912> .PERIOD Now <sil=0.336> ,COMMA you have seen in the programming course that you could use arrays or you can also use recursive data structures <sil=0.983> .PERIOD What is the recursive data structures now <sil=0.983> ?QUESTIONMARK I can use for example <sil=0.528> ,COMMA I want to represent as we said we want to do some long lasting operation <sil=0.937> .PERIOD So <sil=0.538> ,COMMA I can write it like this S t R I m and j <sil=0.955> .PERIOD So <sil=0.451> ,COMMA now let us say I want to do the same operation as I did here in this where I reverse the array and so what do I want now <sil=0.999> ?QUESTIONMARK I want to reverse list this I also done in place such that this is the header that I have you know that already you know in recursive data structure it has a header to which points to the starting point in the list in the linked list and now what do I want to do <sil=0.887> ?QUESTIONMARK I want to make this the header and reverse all these arrays and finally <sil=0.394> ,COMMA this should point to the tail and that is exactly what is being done in this program which I show you over here <sil=0.985> .PERIOD So <sil=0.313> ,COMMA what are we doing now <sil=0.884> ?QUESTIONMARK We have three pointers p q and R what are we doing now <sil=0.942> ?QUESTIONMARK We are first setting <sil=0.923> .PERIOD So <sil=0.583> ,COMMA the point to q let me call it q is a pointer which is set to another that is how we started p is the pointer which is pointing over here <sil=0.961> .PERIOD Then what are we doing <sil=0.933> ?QUESTIONMARK We are saying while p does not become null we are putting R so R is pointing over here R is pointing to p point and next then what are we doing <sil=0.985> ?QUESTIONMARK We are saying p point and next now is going to point to q what is q pointing to now <sil=0.902> ?QUESTIONMARK q is pointing to null right then so what are we done now <sil=0.897> ?QUESTIONMARK I have made R point to p point and next and the next element of s is pointing to null next what are we doing <sil=0.930> ?QUESTIONMARK We are setting p is equal to R because I already have a point of q which points to this then we are setting p equal to R before that of course we are setting q equal to p because q is updated over here and we are setting p equal to R <sil=0.910> .PERIOD So <sil=0.500> ,COMMA R is the so this is the new p pointer now <sil=0.912> .PERIOD Then what do I do <sil=0.924> ?QUESTIONMARK So <sil=0.485> ,COMMA basically I have a q which is going like this and this no connection over here and p is passing through this <sil=0.933> .PERIOD Then what do I do now <sil=0.858> ?QUESTIONMARK Once again I repeat the same process what will I do now <sil=0.929> ?QUESTIONMARK I will put there basically I will put R is p point and next R goes over here then what will I do <sil=0.992> ?QUESTIONMARK I will put p point and next is q then I will update q to the position where p was and then I will make this p again and you keep doing this until you reach the end of the list <sil=0.954> .PERIOD So <sil=0.599> ,COMMA another implementation of the reverse string which is done in place <sil=0.987> .PERIOD So <sil=0.483> ,COMMA what we have looked at so far is we looked at basics of programming basic building blocks that we make up a programming language then we looked at the arrays and functions with some examples on reverse string using the array and also reverse string using the building list and these are so now we are kind of equipped with what are called the basic data types what are the basic data types we have <sil=0.975> .PERIOD We have the integers we have the floats we have the character and then in addition to that you have structures like this for example recursive the type is represented using a structure and a point of that matter and then you also have the arrays <sil=0.940> .PERIOD So <sil=0.465> ,COMMA next what we want to do is we have written now <sil=0.994> .PERIOD So <sil=0.595> ,COMMA basically we have started writing programs which execute a number of times <sil=0.959> .PERIOD Now <sil=0.422> ,COMMA let us see I have two ways of solving the same program or maybe four ways of solving the same problem <sil=0.930> .PERIOD How do we know how well this program runs <sil=0.959> .PERIOD So <sil=0.585> ,COMMA we need to get some formalism into how you analyze algorithms <sil=0.947> .PERIOD So <sil=0.390> ,COMMA we will stop here and we will go on to the next lecture on to determine the efficiency <sil=0.979> .PERIOD Welcome to this module <sil=0.922> .PERIOD In this module we are going to learn something called strings <sil=0.950> .PERIOD This is something that happens in the real world very often <sil=1.000> .PERIOD A name <sil=0.529> ,COMMA your name and my name <sil=0.375> ,COMMA college is name <sil=0.499> ,COMMA things like that are all strings <sil=0.920> .PERIOD C does not actually give you direct support for strings and this is why I wanted to have one small lecture on what strings are and how to manipulate strings <sil=0.321> ,COMMA how to read <sil=0.600> ,COMMA how to print and so on <sil=0.918> .PERIOD So <sil=0.411> ,COMMA a string is essentially a sequence of characters and the way C handles this is it handles it as a sequence of characters stored in an array and it is not just the characters that you want <sil=0.902> .PERIOD It also has a special symbol backslash 0 or the null character <sil=0.951> .PERIOD So <sil=0.458> ,COMMA if you see this picture here <sil=0.485> ,COMMA we have these five characters H E L L and O and so you can see that this H E L L and O are the five letters that I need <sil=0.583> ,COMMA but there is an extra character called backslash 0 and the whole six characters is called a string <sil=0.993> .PERIOD So <sil=0.422> ,COMMA we have a string which actually contains five letters and the beginning of the string is H <sil=0.550> ,COMMA the end of the string is actually backslash 0 which is a special character that C uses <sil=0.964> .PERIOD We will in a little while we will see why that special character is needed <sil=0.998> .PERIOD Let us say I have an array S T R of length 11 <sil=0.906> .PERIOD You can see that in this example <sil=0.318> ,COMMA the string even though it has 11 bytes of storage allocated to it <sil=0.643> ,COMMA it only has the contents good space day followed by the special character backslash 0 <sil=0.963> .PERIOD So <sil=0.304> ,COMMA remember that is going to be part of every string <sil=0.990> .PERIOD There are two characters or two bytes that are not used by the program <sil=0.958> .PERIOD So <sil=0.384> ,COMMA this character S T R of 11 <sil=0.359> ,COMMA it has four characters G O O D of space that is the fifth character <sil=0.948> .PERIOD Then <sil=0.477> ,COMMA 6 seventh eighth are characters of day and the ninth character is backslash 0 <sil=0.920> .PERIOD So <sil=0.418> ,COMMA there are two characters that the string could take <sil=0.917> .PERIOD So <sil=0.450> ,COMMA this array can take two more characters <sil=0.304> ,COMMA but the string ends at backslash 0 <sil=0.961> .PERIOD The other things the last two bytes are not part of the string <sil=0.977> .PERIOD So <sil=0.427> ,COMMA let us see the basic difference between what a character is and what a string is <sil=0.994> .PERIOD So <sil=0.328> ,COMMA let us say I say that there is a character H <sil=0.962> .PERIOD So <sil=0.327> ,COMMA let us say there is a character called H <sil=0.968> .PERIOD It is a single byte representation <sil=0.922> .PERIOD So <sil=0.361> ,COMMA it stores H and nothing else <sil=0.912> .PERIOD Whereas <sil=0.618> ,COMMA if you store string H <sil=0.376> ,COMMA it actually requires two bytes <sil=0.986> .PERIOD So <sil=0.461> ,COMMA it stores the letter H followed by backslash 0 <sil=0.902> .PERIOD So <sil=0.477> ,COMMA this is why I said every string has at least this character backslash 0 <sil=0.933> .PERIOD See <sil=0.441> ,COMMA even an empty string <sil=0.499> ,COMMA a string that has no valid characters at all will still need backslash 0 or 1 byte to store it <sil=0.921> .PERIOD So <sil=0.567> ,COMMA to reiterate these points <sil=0.582> ,COMMA a string is a sequence of characters enclosed in double quotes <sil=0.996> .PERIOD So <sil=0.364> ,COMMA in this example on the top S 1 of 2 is declared to be a character array <sil=0.964> .PERIOD So <sil=0.629> ,COMMA S 1 is a character array of size 2 and equals within double quotes a means the right side is a string expression <sil=0.945> .PERIOD And in the string expression <sil=0.606> ,COMMA remember a is a character and because it is a string <sil=0.646> ,COMMA backslash 0 is always part of it <sil=0.939> .PERIOD So <sil=0.311> ,COMMA this will require two bytes of storage <sil=0.953> .PERIOD On the other hand <sil=0.603> ,COMMA if you do it character S 2 equals within single quote a <sil=0.614> ,COMMA a is a single character and character they require only one byte <sil=0.901> .PERIOD So <sil=0.598> ,COMMA S 2 will allocate only one byte and you will store the letter a in it <sil=0.965> .PERIOD So <sil=0.398> ,COMMA this character S 2 is a single character <sil=0.557> ,COMMA it is not an array and S 1 <sil=0.549> ,COMMA however <sil=0.391> ,COMMA is an array of size 2 and it can store a as well as backslash 0 <sil=0.921> .PERIOD So <sil=0.413> ,COMMA there is a difference between the storage that is given to both of these <sil=0.913> .PERIOD So <sil=0.610> ,COMMA let us take a few other examples <sil=0.932> .PERIOD Let us say there is this message 1 and message 2 I have in this example here <sil=0.923> .PERIOD So <sil=0.459> ,COMMA message 1 is declared as an array of size 12 and we have initialized this to the string called hollow world <sil=0.950> .PERIOD So <sil=0.461> ,COMMA hollow space world <sil=0.942> .PERIOD If you look at the length of it <sil=0.628> ,COMMA hollow requires 5 characters and world requires 5 characters <sil=0.932> .PERIOD So <sil=0.546> ,COMMA that is 10 plus space requires 1 character <sil=0.950> .PERIOD So <sil=0.597> ,COMMA that is 11 bytes <sil=0.940> .PERIOD On the left side we have allocated 12 <sil=0.927> .PERIOD So <sil=0.528> ,COMMA the reason for message 1 of size 12 <sil=0.532> ,COMMA the message 1 being size 12 is that hollow and world requires 5 bytes each plus space is 1 byte <sil=0.514> ,COMMA 11 bytes and remember there is always an implicit backslash 0 <sil=0.919> .PERIOD You do not have to put it explicitly <sil=0.990> .PERIOD Backslash 0 is something that if you have as a string backslash 0 is assumed to be added automatically <sil=0.900> .PERIOD So <sil=0.316> ,COMMA the internal representation of message 1 would look like what you see here <sil=0.956> .PERIOD So <sil=0.427> ,COMMA you see hollow space WORLD followed by backslash 0 <sil=0.951> .PERIOD So <sil=0.342> ,COMMA it is actually using all the 12 bytes that is allocated to message 1 <sil=0.901> .PERIOD So <sil=0.449> ,COMMA it is not that you always want to initialize it and so <sil=0.557> ,COMMA declare an array and initialize it <sil=0.957> .PERIOD Sometimes you want to read things from the user <sil=0.956> .PERIOD For instance <sil=0.443> ,COMMA let us say I want to read the message from the user <sil=0.937> .PERIOD So <sil=0.571> ,COMMA I have message 2 which is of size 12 and I scan the message <sil=0.994> .PERIOD So <sil=0.444> ,COMMA the specify for scanning a string is percentage S <sil=0.940> .PERIOD So <sil=0.550> ,COMMA we have seen how to scan integers and characters and so on before <sil=0.938> .PERIOD Percentage S is the specify for scanning a string <sil=0.938> .PERIOD So <sil=0.372> ,COMMA S stands for string <sil=0.924> .PERIOD So <sil=0.388> ,COMMA message 2 and let us say I typed hollow as input <sil=0.986> .PERIOD Then H e L L O will go as the first 5 characters in message 2 and I said see automatically puts in a backslash 0 at the end of the strings if you scan them from the user <sil=0.922> .PERIOD So <sil=0.568> ,COMMA backslash 0 is the sixth character <sil=0.976> .PERIOD So <sil=0.615> ,COMMA that happens in the fifth location <sil=0.901> .PERIOD So <sil=0.477> ,COMMA 0th location has H <sil=0.327> ,COMMA 1th location has E <sil=0.472> ,COMMA 2th location has L and so on <sil=0.973> .PERIOD The sixth location will fifth location would have backslash 0 <sil=0.932> .PERIOD And in this case <sil=0.575> ,COMMA there are only 6 bytes that are required <sil=0.975> .PERIOD The bytes following that even though message 2 has space for 12 bytes <sil=0.634> ,COMMA it has only 6 valid bytes that are useful for the string <sil=0.989> .PERIOD The other 6 are unknown <sil=0.969> .PERIOD We have already seen this when we talked about the notion of arrays and what if we not initialize them <sil=0.957> .PERIOD So <sil=0.379> ,COMMA let us look at another example where we have initialization on the left side <sil=0.921> .PERIOD We see character star message 3 <sil=0.947> .PERIOD So <sil=0.309> ,COMMA message 3 is a pointer to a character or it could be a pointer to a character array <sil=0.967> .PERIOD On the right side we have a hollow world <sil=0.935> .PERIOD So <sil=0.501> ,COMMA what happens here is this hollow world again as I said before requires 12 bytes <sil=0.928> .PERIOD And if you print message 3 <sil=0.321> ,COMMA it will print hollow world with a space in between <sil=0.937> .PERIOD But message 3 here is actually a pointer to an array of characters <sil=0.960> .PERIOD So <sil=0.488> ,COMMA one thing that happens is if you notice the left side <sil=0.398> ,COMMA there is no explicit storage allocated for message 3 <sil=0.956> .PERIOD So <sil=0.389> ,COMMA unlike message 2 or message 1 where you see that there are 12 bytes allocated <sil=0.334> ,COMMA message 3 does not have any storage allocated to it <sil=0.966> .PERIOD So <sil=0.449> ,COMMA the way C handles this is the right side <sil=0.334> ,COMMA what you see as hollow world is treated as a constant string <sil=0.933> .PERIOD What that means is this is a string that cannot be changed <sil=0.970> .PERIOD And this string is put into what is called the read only memory of the process or the program before the program starts running <sil=0.963> .PERIOD So <sil=0.610> ,COMMA there is a portion of the memory for every program which is marked as read only and this hollow world as a string is put into the read only program of the read only portion of the program <sil=0.943> .PERIOD And message 3 is just a pointer to this read only portion of the program <sil=0.906> .PERIOD So <sil=0.503> ,COMMA we already saw the notion of pointers <sil=0.938> .PERIOD So <sil=0.328> ,COMMA message 3 is just a pointer to the beginning of this array which has hello followed by space <sil=0.592> ,COMMA followed by world followed by backslash 0 <sil=0.986> .PERIOD So <sil=0.380> ,COMMA the reason why this is critical is message 3 is not allocated space <sil=0.996> .PERIOD You do not have space allocated for it <sil=0.639> ,COMMA it is done in the beginning of the program and you do not even have control over it explicitly <sil=0.982> .PERIOD So <sil=0.602> ,COMMA if you do message 3 of 1 equals A and since hollow world here is saved in a read only memory location <sil=0.549> ,COMMA this changing any contents of message 3 since you did not allocate space explicitly for it would result in undefined behavior <sil=0.951> .PERIOD So <sil=0.495> ,COMMA this is a common mistake that programmers make <sil=0.961> .PERIOD So <sil=0.494> ,COMMA if you allocate space like what you see in message 1 or message 2 which is ok to go and change the contents of it <sil=0.391> ,COMMA you can read the characters as characters that you allocated <sil=0.528> ,COMMA we saw integer arrays and so on earlier <sil=0.931> .PERIOD So <sil=0.583> ,COMMA this is just character arrays <sil=0.927> .PERIOD But if you did not explicitly allocate a space like in message 3 now <sil=0.608> ,COMMA see allocate space for the strings and you cannot touch it <sil=0.431> ,COMMA you cannot change the contents of it <sil=0.998> .PERIOD So <sil=0.553> ,COMMA let us look at a small example <sil=0.958> .PERIOD In this case we have character star A1 which is hollow world <sil=0.967> .PERIOD So <sil=0.630> ,COMMA what we have is we have a pointer to a constant string <sil=0.923> .PERIOD So <sil=0.324> ,COMMA what I mean by that is the string itself is constant <sil=0.480> ,COMMA it cannot change and A1 is a pointer to it <sil=0.920> .PERIOD Character A2 of square brackets is hollow world <sil=0.984> .PERIOD What this does is it allocates space for A2 as much as it is required <sil=0.918> .PERIOD So <sil=0.511> ,COMMA let us look at the right side <sil=0.942> .PERIOD The right side requires 11 characters for a hollow space world plus remember one character for backslash 0 <sil=0.994> .PERIOD So <sil=0.407> ,COMMA A2 size will be 12 bytes and character A3 of 6 <sil=0.466> ,COMMA we have explicitly said A3 is supposed to be allocated with 6 bytes <sil=0.974> .PERIOD On the right side <sil=0.456> ,COMMA as long as we have 5 or less characters everything will be okay <sil=0.918> .PERIOD So <sil=0.600> ,COMMA if I said world <sil=0.410> ,COMMA it is okay <sil=0.901> .PERIOD But if I put worlds for instance <sil=0.340> ,COMMA worlds itself will require 6 characters WO or LDS and there will be no more space for backslash 0 <sil=0.915> .PERIOD So <sil=0.365> ,COMMA this example A2 <sil=0.554> ,COMMA this character A2 is called a constant pointer to string <sil=0.945> .PERIOD So <sil=0.639> ,COMMA I want to make this small distinction <sil=0.916> .PERIOD So <sil=0.369> ,COMMA A1 is a pointer to constant string and A2 is a constant pointer to string <sil=0.947> .PERIOD So <sil=0.453> ,COMMA let us see what this difference is <sil=0.931> .PERIOD So <sil=0.613> ,COMMA A1 is a pointer and it is pointing to a constant string <sil=0.907> .PERIOD What that means is you cannot change the string <sil=0.977> .PERIOD Whereas <sil=0.553> ,COMMA character A2 is a constant pointer <sil=0.970> .PERIOD What that means is you cannot change it <sil=0.908> .PERIOD You cannot make it point to something else <sil=0.949> .PERIOD But wherever it is pointing to the contents of it can be changed <sil=0.936> .PERIOD So <sil=0.583> ,COMMA I will explain this in a little while <sil=0.925> .PERIOD But before that <sil=0.381> ,COMMA let us look at line 4 <sil=0.917> .PERIOD So <sil=0.450> ,COMMA I want to show the distinction between how A1 is handled versus how A2 is handled by C <sil=0.940> .PERIOD So <sil=0.626> ,COMMA if I go and use the size of operator <sil=0.639> ,COMMA size of is supposed to tell me the size in the number of bytes of the data type that is passed to it <sil=0.964> .PERIOD So <sil=0.595> ,COMMA if you look at size of A1 <sil=0.502> ,COMMA A1 is a pointer character and a pointer to character is the same <sil=0.531> ,COMMA will have the same size as pointer to an integer and so on <sil=0.914> .PERIOD So <sil=0.347> ,COMMA size of all the data types could be different <sil=0.323> ,COMMA but size of the pointers in a specific machine will all be the same <sil=0.971> .PERIOD So <sil=0.619> ,COMMA size of A1 will be the size of the pointer <sil=0.935> .PERIOD So <sil=0.402> ,COMMA in my machine the size of pointers is all 8 bytes <sil=0.955> .PERIOD So <sil=0.351> ,COMMA size of A1 will print 8 <sil=0.929> .PERIOD Whereas <sil=0.432> ,COMMA size of A2 <sil=0.421> ,COMMA so A2 being a constant pointer to a string is actually going to look at not the size of the pointer itself <sil=0.364> ,COMMA but the size of what is pointer to <sil=0.967> .PERIOD In this case <sil=0.621> ,COMMA A2 is pointing to hello world that requires 12 bytes <sil=0.970> .PERIOD So <sil=0.481> ,COMMA size of A2 would be 12 <sil=0.906> .PERIOD So <sil=0.557> ,COMMA if I took this program and ran it on my machine <sil=0.532> ,COMMA I would get 8 for the size of A1 and 12 for the size of A2 <sil=0.951> .PERIOD So <sil=0.560> ,COMMA this distinction happens because even though pointers and arrays are treated as something which can be interchanged <sil=0.504> ,COMMA it is not always true <sil=0.926> .PERIOD So <sil=0.353> ,COMMA this is a classical example of a place where pointers and arrays do not really mean the same thing <sil=0.940> .PERIOD Now <sil=0.350> ,COMMA I said A1 is a pointer to a constant string <sil=0.957> .PERIOD Therefore <sil=0.417> ,COMMA if you make A1 of 1 equals U <sil=0.336> ,COMMA you are trying to change a constant string <sil=0.943> .PERIOD The string is supposed to be not changing through the program <sil=0.579> ,COMMA but you are making A1 of 1 is U that will result in undefined behavior <sil=0.944> .PERIOD So <sil=0.333> ,COMMA you may have A1 even changing to HU LLO <sil=0.624> ,COMMA but you cannot always expect that this will work <sil=0.954> .PERIOD Sometimes when you run the program <sil=0.314> ,COMMA this can even result in an error <sil=0.924> .PERIOD Let us look at the next line A1 equals A2 <sil=0.958> .PERIOD So <sil=0.348> ,COMMA A1 is a pointer <sil=0.621> ,COMMA you can make it 0 <sil=0.949> .PERIOD 2 anything else <sil=0.924> .PERIOD So <sil=0.617> ,COMMA here A1 <sil=0.925> .PERIOD So <sil=0.458> ,COMMA if you look at A1 <sil=0.302> ,COMMA A1 is a pointer <sil=0.509> ,COMMA it is pointing to something which is constant <sil=0.485> ,COMMA but it itself can point to something else <sil=0.996> .PERIOD So <sil=0.592> ,COMMA in this place <sil=0.371> ,COMMA we are making A1 0 <sil=0.935> .PERIOD 2 A2 <sil=0.925> .PERIOD So <sil=0.498> ,COMMA this is acceptable <sil=0.478> ,COMMA this is not a problem <sil=0.909> .PERIOD However <sil=0.308> ,COMMA changing the contents of A1 is not acceptable <sil=0.990> .PERIOD A1 can start pointing to something else <sil=0.961> .PERIOD So <sil=0.349> ,COMMA if you see what happens after this print of statement <sil=0.522> ,COMMA you will see that A2 <sil=0.490> ,COMMA so A1 is pointing to A2 <sil=0.905> .PERIOD So <sil=0.464> ,COMMA it will still print hollow world because A2 is also hollow world <sil=0.981> .PERIOD Let us look at the last line <sil=0.444> ,COMMA A2 equals A3 <sil=0.915> .PERIOD So <sil=0.318> ,COMMA this is where this notion of constant pointer comes through <sil=0.934> .PERIOD So <sil=0.621> ,COMMA you can change the contents of A2 <sil=0.961> .PERIOD So <sil=0.480> ,COMMA I can make A2 of 1 equals U that is acceptable <sil=0.922> .PERIOD However <sil=0.483> ,COMMA A2 is a constant pointer <sil=0.949> .PERIOD What that means is you cannot make it point to something else <sil=0.992> .PERIOD And therefore <sil=0.301> ,COMMA A2 equal to A3 will result in an error and this error will be caught by the compiler itself <sil=0.996> .PERIOD So <sil=0.392> ,COMMA if you take this program and type it up <sil=0.517> ,COMMA your compiler will come and tell you that there is an error in this line <sil=0.999> .PERIOD So <sil=0.326> ,COMMA again I will reiterate this <sil=0.928> .PERIOD So <sil=0.596> ,COMMA A1 is a pointer to a constant string <sil=0.991> .PERIOD You can make A1 point to something else <sil=0.335> ,COMMA but you cannot change the contents of A1 <sil=0.933> .PERIOD A2 is a constant pointer to a string <sil=0.951> .PERIOD You can change the contents of A2 <sil=0.422> ,COMMA but you cannot make A2 point to anything else <sil=0.906> .PERIOD So <sil=0.358> ,COMMA let us go and look at how strings can be read <sil=0.928> .PERIOD We saw how strings can be printed <sil=0.978> .PERIOD Let us see how strings can be read <sil=0.969> .PERIOD So <sil=0.567> ,COMMA for example <sil=0.304> ,COMMA scanf takes this percentage s as a specifier and you can give a pointer to the character array as a parameter to it <sil=0.909> .PERIOD So <sil=0.571> ,COMMA let us assume that there are two strings A underscore string and E underscore string <sil=0.973> .PERIOD And let us assume that both of them have 80 characters in them <sil=0.354> ,COMMA which means they can take 79 valid characters and you have to reserve at least one byte for the backslash 0 <sil=0.959> .PERIOD So <sil=0.543> ,COMMA let us say I end up some typing something which is 7 terrain characters <sil=0.923> .PERIOD The 7 terrain characters will go into location 0 to 78 and automatically backslash 0 will be put in as the 7 terrain character <sil=0.943> .PERIOD So <sil=0.443> ,COMMA let us say I did printf enter some words in a string <sil=0.554> ,COMMA I prompt you and I scanf A string and E string and if I print it <sil=0.445> ,COMMA so that is what the program is doing <sil=0.956> .PERIOD So <sil=0.486> ,COMMA this line is prompting the user to type something <sil=0.528> ,COMMA this line is expecting the user to type something in the keyboard and finally <sil=0.617> ,COMMA it is printing whatever is read in the keyboard <sil=0.907> .PERIOD And let us say when this program ran <sil=0.422> ,COMMA I typed this line <sil=0.515> ,COMMA this is a test <sil=0.462> ,COMMA let us say I typed that this space is space A space test followed by a dot <sil=0.971> .PERIOD So <sil=0.316> ,COMMA what happens is that the scanf percentage s starts from a particular location and keeps reading letters till it finds a white space <sil=0.905> .PERIOD So <sil=0.477> ,COMMA in this case E string when scanf works <sil=0.545> ,COMMA it starts with t and then it reads h reads i reads s and it reads space <sil=0.901> .PERIOD The moment it sees space <sil=0.600> ,COMMA it says that ok <sil=0.979> .PERIOD So <sil=0.531> ,COMMA scanf the way it works is space is not scanned into the A string <sil=0.540> ,COMMA it stops here <sil=0.602> ,COMMA it puts t h i s followed by backslash 0 into A string <sil=0.968> .PERIOD And subsequently when you are reading E string <sil=0.412> ,COMMA what happens is it ignores the space goes to the next location which is not a space which is i here and it starts reading from there till it finds another space <sil=0.993> .PERIOD In this case <sil=0.300> ,COMMA it is the space in after i s <sil=0.998> .PERIOD So <sil=0.318> ,COMMA it keeps reading till it finds a space <sil=0.988> .PERIOD So <sil=0.558> ,COMMA it found the characters i and s <sil=0.910> .PERIOD So <sil=0.503> ,COMMA A string would have in the memory <sil=0.562> ,COMMA it would have t h i s and backslash 0 <sil=0.510> ,COMMA this will be the five letters in A string <sil=0.974> .PERIOD And if you look at E underscore string <sil=0.599> ,COMMA the variable name E underscore string <sil=0.391> ,COMMA it would have i s followed by backslash 0 <sil=0.974> .PERIOD So <sil=0.494> ,COMMA it will have three characters <sil=0.974> .PERIOD Even though you have space for 80 characters <sil=0.435> ,COMMA it has only three characters of which only two are really valiant <sil=0.959> .PERIOD This is how you read strings <sil=0.930> .PERIOD In the last class <sil=0.632> ,COMMA we just studied about the stack erity <sil=0.916> .PERIOD Today <sil=0.413> ,COMMA I will talk about another kind of list erity <sil=0.412> ,COMMA just called the Q-adity <sil=0.926> .PERIOD Q is what <sil=0.317> ,COMMA now Q does not require too much of an introduction <sil=1.000> .PERIOD Stack <sil=0.357> ,COMMA for example <sil=0.528> ,COMMA you had already list <sil=0.435> ,COMMA you already know <sil=0.320> ,COMMA you already used this all the time in your life <sil=0.961> .PERIOD And stack <sil=0.460> ,COMMA for example <sil=0.340> ,COMMA I mean once I gave you the example of stacking plates on a cupboard or stacking books on a desk <sil=0.568> ,COMMA you know that immediately that the stack erity is to be lost in first-out kind of a data structure <sil=0.917> .PERIOD Now <sil=0.313> ,COMMA Q is something that you all know <sil=0.609> ,COMMA you start in India <sil=0.338> ,COMMA we always stand in Q's for almost everything <sil=0.623> ,COMMA whether it is railway station <sil=0.541> ,COMMA the bus stand or you know getting your registration done in your college <sil=0.456> ,COMMA getting your ID card <sil=0.954> .PERIOD Wherever you have a whole lot of Q's and the grocery store for that matter <sil=0.310> ,COMMA if you go to a big bus or something that you are standing in the Q for a long time <sil=0.926> .PERIOD And that is what a Q-adity is all about <sil=0.981> .PERIOD What is the property of the Q-adity <sil=0.881> ?QUESTIONMARK It is just that the person who is at the beginning of the Q is served first and then the next person and so on <sil=0.928> .PERIOD So <sil=0.625> ,COMMA this data structure is somewhat different <sil=0.988> .PERIOD Unlike the original list erity way <sil=0.491> ,COMMA we said you can insert anywhere and delete anywhere <sil=0.914> .PERIOD And the stack erity way <sil=0.615> ,COMMA we said the last person gets priority <sil=0.426> ,COMMA gets deleted first <sil=0.903> .PERIOD This Q-adity is one which is of the type what is called first in first-out <sil=0.984> .PERIOD First in first out <sil=0.535> ,COMMA you also known as Fee-Four <sil=0.949> .PERIOD I was first in the Q and therefore <sil=0.353> ,COMMA MSB served first <sil=0.947> .PERIOD In India of course <sil=0.375> ,COMMA in some places when you have a lot of unruly population <sil=0.494> ,COMMA it behaves like a normal list <sil=0.987> .PERIOD But in a civilized society <sil=0.463> ,COMMA you will have that <sil=0.345> ,COMMA you follow the Q-prints <sil=0.406> ,COMMA first in first out <sil=0.953> .PERIOD So <sil=0.413> ,COMMA what are the various operations that we perform <sil=0.956> ?QUESTIONMARK We want to perform on Q <sil=0.367> ,COMMA DQ <sil=0.411> ,COMMA empty and front <sil=0.962> .PERIOD You want to find out who is there in the front of the Q <sil=0.986> .PERIOD These are the four operations that you would like to perform <sil=0.990> .PERIOD Basically <sil=0.452> ,COMMA let why would I want to look at on Q <sil=0.933> ?QUESTIONMARK Of course <sil=0.560> ,COMMA a particular job has to be on Q and DQ when you want to remove an element from the Q <sil=0.936> .PERIOD MTQ <sil=0.612> ,COMMA you want to find whether the Q is empty or not <sil=0.957> .PERIOD For example <sil=0.562> ,COMMA if I want to close the counter <sil=0.461> ,COMMA I may decide that if I have multiple counters <sil=0.526> ,COMMA let us let us say <sil=0.594> ,COMMA you are waiting at the passport office or whatever <sil=0.975> .PERIOD I have multiple counters <sil=0.999> .PERIOD I would like to check whether the Q has become empty so that I can close a particular counter <sil=0.924> .PERIOD And front of the Q to check who is there in the front of the Q <sil=0.977> .PERIOD For example <sil=0.389> ,COMMA if you go to the passport office <sil=0.599> ,COMMA there is a facility <sil=0.507> ,COMMA Thatkal versus ordinary or whatever <sil=0.930> .PERIOD So <sil=0.529> ,COMMA I would like to move this person to a different Q and say <sil=0.580> ,COMMA do not be in this Q <sil=0.966> .PERIOD If you are asking for some of the priority based <sil=0.490> ,COMMA because this is for non-priority people <sil=0.966> .PERIOD Everybody has the same preference and if you come in first <sil=0.543> ,COMMA you get first <sil=0.920> .PERIOD So <sil=0.539> ,COMMA let us see how we can operate on this <sil=0.913> .PERIOD And clearly <sil=0.392> ,COMMA since the Q is also a special type of a list <sil=0.500> ,COMMA we can again use the list ADT to perform the operations <sil=0.911> .PERIOD So <sil=0.307> ,COMMA what will it <sil=0.639> ,COMMA what will on Q become now <sil=0.976> ?QUESTIONMARK If I have a list ADT <sil=0.643> ,COMMA it will say L dot insert at L dot end <sil=0.940> .PERIOD We are always inserting at the end of the Q <sil=0.985> .PERIOD And dQ would be L dot delete L dot front and empty will be L dot front just like in the stack equal to L dot end would be an empty Q <sil=0.959> .PERIOD Front would be L dot retrieve of L dot first <sil=0.933> .PERIOD So <sil=0.497> ,COMMA what I am <sil=0.370> ,COMMA what I have shown here <sil=0.507> ,COMMA I have shown you that the all the operations that you want on the list can be on the Q can be implemented using the list <sil=0.913> .PERIOD So <sil=0.442> ,COMMA what I could do is in my ADT <sil=0.455> ,COMMA I can say L is of type list and define operations on list to perform these operations on the Q <sil=0.962> .PERIOD So <sil=0.589> ,COMMA this is the first thing that I always advise any student to do <sil=0.905> .PERIOD If you have one ADT <sil=0.551> ,COMMA which you have implemented <sil=0.434> ,COMMA which is completely debugged <sil=0.536> ,COMMA then my advises you just use the reuse that ADT again <sil=0.939> .PERIOD So <sil=0.408> ,COMMA that is what I am doing again here <sil=0.343> ,COMMA just like we did for the stack <sil=0.930> .PERIOD I define the ADT Q in terms of the list and do operations on list to mimic the operations of the Q <sil=1.000> .PERIOD That is all <sil=0.464> ,COMMA then what happens you very quickly have a Q ADT <sil=0.931> .PERIOD Let us see on the other hand I want to implement my own ADT Q <sil=0.559> ,COMMA that is what I am going to talk about now <sil=0.987> .PERIOD So <sil=0.341> ,COMMA what is it that we have the operations which remove elements are DQ front and empty <sil=0.487> ,COMMA which gets from the Q and things that put elements onto the Q <sil=0.931> .PERIOD First you of course <sil=0.437> ,COMMA you always have to create a empty Q <sil=0.508> ,COMMA this is make null operation and an on Q <sil=0.301> ,COMMA which puts elements onto the Q <sil=0.937> .PERIOD In my implementation <sil=0.491> ,COMMA which I am where you see plus plus <sil=0.335> ,COMMA what I do is to make deletion easy <sil=0.554> ,COMMA I have done a linked list implementation here <sil=0.401> ,COMMA we will talk about array implementation a little later <sil=0.977> .PERIOD So <sil=0.379> ,COMMA in a linked list implementation as shown here <sil=0.580> ,COMMA you have a point of which points to the front of the Q and another point of which points to the end of the Q <sil=0.981> .PERIOD In this example here that I have done <sil=0.578> ,COMMA what I do is in addition to that <sil=0.428> ,COMMA these are things by the way <sil=0.307> ,COMMA because you are hiding the implementation from the user of your ADT <sil=0.390> ,COMMA you can do some clever things in your implementation to make some of the operations easy <sil=0.996> .PERIOD What I have done in this implementation over here is <sil=0.504> ,COMMA if you notice here <sil=0.322> ,COMMA my make null operation create an empty Q <sil=0.582> ,COMMA I create a dummy cell <sil=0.565> ,COMMA I did this for the list also if you remember <sil=0.300> ,COMMA I create a dummy cell <sil=0.402> .PERIOD Then my on Q becomes insertion at the end of the dummy cell <sil=0.904> .PERIOD What is the advantage of this <sil=0.868> ?QUESTIONMARK I do not have to check whether the Q is empty and then insert <sil=0.905> .PERIOD I know that as soon as I have created an empty Q <sil=0.596> ,COMMA there is one dummy cell and therefore <sil=0.595> ,COMMA insertion becomes simply inserting at the end of this dummy cell <sil=0.945> .PERIOD Then <sil=0.633> ,COMMA I let us say I have on Qed one more element <sil=0.951> .PERIOD So <sil=0.589> ,COMMA what do I do <sil=0.954> ?QUESTIONMARK I go to the end of the Q and put another element over here <sil=0.993> .PERIOD That is <sil=0.323> ,COMMA I have a front pointer and I have a rear pointer <sil=0.975> .PERIOD Please look at this here <sil=0.390> ,COMMA there are two pointers pointing to the Q <sil=0.520> ,COMMA front points to the same location and rear points to the same location when it is empty <sil=0.945> .PERIOD But what is nice is <sil=0.366> ,COMMA because I have created a dummy cell <sil=0.444> ,COMMA what happens is <sil=0.346> ,COMMA when I create a dummy cell <sil=0.368> ,COMMA the advantage is that there is always one element where both the front and rear are pointing to <sil=0.962> .PERIOD It is not pointing to somewhere <sil=0.330> ,COMMA there is no way <sil=0.955> .PERIOD So <sil=0.560> ,COMMA then what I do is <sil=0.549> ,COMMA when I am doing the on Q <sil=0.605> ,COMMA I am inserting X over here <sil=0.924> .PERIOD So <sil=0.500> ,COMMA what is interesting is <sil=0.558> ,COMMA now <sil=0.529> ,COMMA front is pointing to the dummy cell <sil=0.516> ,COMMA rear is pointing to the element <sil=0.949> .PERIOD Now <sil=0.480> ,COMMA I am on Qing one more element <sil=0.487> ,COMMA then what happens <sil=0.912> ?QUESTIONMARK Rear is updated and Y is on Qed after X and rear is updated over here <sil=0.943> .PERIOD So <sil=0.411> ,COMMA now <sil=0.541> ,COMMA what am I going to do when I do DQ <sil=0.876> ?QUESTIONMARK I just <sil=0.503> ,COMMA when I DQ <sil=0.467> ,COMMA I remove this element <sil=0.955> .PERIOD So <sil=0.526> ,COMMA I keep the dummy cell as it is and DQ the element next to the dummy cell <sil=0.998> .PERIOD This is the fundamental advantage of using a dummy cell and rear is pointing to Y <sil=0.925> .PERIOD So <sil=0.328> ,COMMA this is the advantage of implementing <sil=0.351> ,COMMA when I am doing a linked list expression <sil=0.502> ,COMMA sorry <sil=0.350> ,COMMA when I do a linked list implementation of Qs <sil=0.387> ,COMMA this is the big advantage of using a dummy cell to implement <sil=0.484> ,COMMA when you create an empty Q <sil=0.486> ,COMMA this is the big advantage of it <sil=0.901> .PERIOD And here is a implementation over here and I have just given you the C plus plus implementation over here <sil=0.980> .PERIOD So <sil=0.439> ,COMMA you have a recursive data structure just as before and notice that again <sil=0.417> ,COMMA I have what you call type depth position <sil=0.920> .PERIOD So <sil=0.440> ,COMMA for example <sil=0.491> ,COMMA I have said type depth structs cell star position <sil=0.542> ,COMMA we will see how we do this in the case of the array <sil=0.931> .PERIOD In the case of the array <sil=0.443> ,COMMA when I do a type depth <sil=0.590> ,COMMA it will be integer <sil=0.637> ,COMMA which will be type depth to this <sil=0.910> .PERIOD Basically <sil=0.426> ,COMMA the user is simply going to use this type depth position <sil=0.445> ,COMMA just like you use a type integer <sil=0.457> ,COMMA care <sil=0.573> ,COMMA float for that matter <sil=0.533> ,COMMA we create a new type called position <sil=0.913> .PERIOD And how the implementation of positions in this case <sil=0.382> ,COMMA it is a pointer to a recursive data structure <sil=0.942> .PERIOD In the case of arrays <sil=0.389> ,COMMA it will be an index to an index in the element in the array <sil=0.923> .PERIOD And of course <sil=0.304> ,COMMA you need two positions front end rear because we have two pointers for this <sil=0.929> .PERIOD And we have a creation of the empty Q <sil=0.550> ,COMMA then you have the on Q <sil=0.646> ,COMMA then you have a D Q and then you have a <sil=0.319> ,COMMA some an operation it tells you what is there in the front of the Q <sil=0.439> ,COMMA another one which tells you whether the Q is empty or not <sil=0.937> .PERIOD And here is a simple implementation of how the rear is done <sil=0.422> ,COMMA rear is done <sil=0.390> ,COMMA rear pointer next you <sil=0.944> .PERIOD And then basically that wherever the rear is <sil=0.309> ,COMMA you create a new element in the at the end of create a cell type of new element and put this element over here <sil=0.920> .PERIOD D Q what are we doing <sil=0.863> ?QUESTIONMARK This is the fundamental advantage <sil=0.999> .PERIOD If it is empty <sil=0.610> ,COMMA then you say Q is empty <sil=0.986> .PERIOD Otherwise <sil=0.338> ,COMMA what do we do <sil=0.991> ?QUESTIONMARK We just simply update the front to point to the next element <sil=0.954> .PERIOD What is interesting <sil=0.983> ?QUESTIONMARK The time complexity of all these operations <sil=0.447> ,COMMA what is that there is no loop in any one of them <sil=0.564> ,COMMA there is no going from the beginning to the list to the end of the list <sil=0.955> .PERIOD Therefore <sil=0.378> ,COMMA all these operations <sil=0.533> ,COMMA this is if you let us take on Q for that matter <sil=0.629> ,COMMA this is order 1 <sil=0.325> ,COMMA this is order 1 <sil=0.613> ,COMMA this is order 1 <sil=0.400> ,COMMA this is order 1 <sil=0.441> .PERIOD So <sil=0.419> ,COMMA this is the form of P 1 plus P 2 plus P 3 plus whatever <sil=0.389> ,COMMA if you take each one of these as sub programs over here <sil=0.316> ,COMMA then what is the time complexity of the segment <sil=0.875> ?QUESTIONMARK It is basically the max of all of this <sil=0.912> .PERIOD Therefore <sil=0.339> ,COMMA the time complexity of the on Q operation is order 1 <sil=0.954> .PERIOD Similarly <sil=0.618> ,COMMA we can argue that the time complexity of the D Q operation is also order 1 and creating an empty Q <sil=0.454> ,COMMA every one of these is order 1 <sil=0.922> .PERIOD So <sil=0.366> ,COMMA this particular list implementation is not difficult <sil=0.323> ,COMMA it only takes order 1 time <sil=0.904> .PERIOD Now <sil=0.333> ,COMMA initially sometimes for example <sil=0.647> ,COMMA there is also another operation that you would like to perform <sil=0.505> ,COMMA have which is called the Q length which will return value which tells you how long the Q is <sil=0.901> .PERIOD Some ADTs also of the implementation of the Q also have Q length <sil=0.982> .PERIOD What is the advantage of this <sil=0.873> ?QUESTIONMARK For example <sil=0.530> ,COMMA if I am again a grocery store like you know food world or something like that <sil=0.538> ,COMMA I may decide looking at the length of the Q <sil=0.556> ,COMMA whether I want to increase the number of counters <sil=0.947> .PERIOD So <sil=0.345> ,COMMA it is a big advantage to do something like this too <sil=0.988> .PERIOD You can also have an extra function called length <sil=0.923> .PERIOD Now <sil=0.642> ,COMMA if I am looking at an extra function called length <sil=0.497> ,COMMA how expensive will this operation be <sil=0.871> ?QUESTIONMARK If you keep <sil=0.481> ,COMMA so basically you will need another variable called length which maintains the length of the Q and then what will happen is you just keep on incrementing it when it is on Qs and decrementing it when it D Qs <sil=0.985> .PERIOD So <sil=0.431> ,COMMA again that operation is not going to cost you more than order 1 in terms of time complexity <sil=0.907> .PERIOD So <sil=0.307> ,COMMA we talked about a linked list implementation of the Q <sil=0.948> .PERIOD I would like to talk about an array implementation <sil=0.998> .PERIOD So <sil=0.512> ,COMMA what will you do with an array implementation of Qs <sil=0.962> ?QUESTIONMARK So <sil=0.436> ,COMMA let us say this is my front <sil=0.481> ,COMMA this is a rear <sil=0.427> ,COMMA let us say I have an array of some particular size <sil=0.963> .PERIOD Let me call it some max size <sil=0.974> .PERIOD I am going to leave you this <sil=0.402> ,COMMA I am not going to give you the complete implementation of this <sil=0.930> .PERIOD So <sil=0.516> ,COMMA this is my front <sil=0.341> ,COMMA the rear <sil=0.944> .PERIOD Now <sil=0.614> ,COMMA I D Q <sil=0.524> ,COMMA then what happens <sil=0.956> ?QUESTIONMARK Front moves over here <sil=0.345> ,COMMA this becomes front <sil=0.957> .PERIOD Again I D Q <sil=0.573> ,COMMA this becomes front <sil=0.976> .PERIOD Then let us say on Q <sil=0.428> ,COMMA then maybe your moves here <sil=0.914> .PERIOD Let us say I have E and then now I reach the end again I rear <sil=0.926> .PERIOD So <sil=0.424> ,COMMA what happens is the problem is that the Qs found somewhere between front and rear in the array <sil=0.965> .PERIOD Let me say this is the <sil=0.372> ,COMMA so that means if I am looking at it <sil=0.584> ,COMMA if I am looking at the pink colors over here <sil=0.500> ,COMMA the Q is found between front and rear <sil=0.923> .PERIOD If I am looking at blue <sil=0.589> ,COMMA the Q is found between front and rear and similarly the whites give me the Q between front and rear <sil=0.923> .PERIOD But the basic problem with this is this kind of an implementation <sil=0.382> ,COMMA array implementation of Q <sil=0.369> ,COMMA what will happen <sil=0.918> ?QUESTIONMARK Very quickly you will exhaust the size of the array <sil=0.939> .PERIOD What will happen is suppose I keep on DQing elements <sil=0.469> ,COMMA then the front comes over here and then I cannot add any more elements <sil=0.996> .PERIOD This is not a good idea <sil=0.948> .PERIOD So <sil=0.640> ,COMMA what we normally do is that we convert this array implementation to a circular Q <sil=0.949> .PERIOD Let us say this is 1 <sil=0.348> ,COMMA 2 <sil=0.545> ,COMMA 3 <sil=0.524> ,COMMA 4 <sil=0.616> ,COMMA 5 <sil=0.493> ,COMMA 6 and so on and this is the max size <sil=0.931> .PERIOD There is still a array implementation <sil=0.492> ,COMMA but we do what you call a logical tying of the front and the rear of the Q <sil=0.939> .PERIOD So <sil=0.404> ,COMMA what is the meaning now <sil=0.888> ?QUESTIONMARK If this is front here <sil=0.378> ,COMMA this could be rear here and it could also happen that this is front and this is rear <sil=0.960> .PERIOD How do I perform this kind of arithmetic now <sil=0.891> ?QUESTIONMARK That means I have a circular array and somewhere going clockwise <sil=0.646> ,COMMA I will find the front and the rear of the Q <sil=0.931> .PERIOD So <sil=0.630> ,COMMA how do I perform these operations <sil=0.862> ?QUESTIONMARK You guessed it right <sil=0.458> ,COMMA you have to do modulo operations <sil=0.953> .PERIOD Modulo based on what <sil=0.893> ?QUESTIONMARK Max size to find the location of the element <sil=0.949> .PERIOD So <sil=0.442> ,COMMA what happens if we all the time we are taking when we keep incrementing right <sil=0.619> ,COMMA the array for example <sil=0.304> ,COMMA initially let us say both front and rear are pointing to the first element or let us say front is pointing to the first element and rear is pointing to max size <sil=0.997> .PERIOD So <sil=0.349> ,COMMA whatever to show that it is an empty Q <sil=0.930> .PERIOD I will tell you this is going to become a problem <sil=0.597> ,COMMA but we will talk about it in a little later <sil=0.975> .PERIOD Then what are we doing <sil=0.917> ?QUESTIONMARK When I am going to on Q <sil=0.571> ,COMMA then what am I going to do now <sil=0.920> ?QUESTIONMARK I am going to move put the rear over here and I will put the element over here <sil=0.944> .PERIOD This is front <sil=0.629> ,COMMA let us say I keep on Q <sil=0.970> .PERIOD This is the front <sil=0.320> ,COMMA this is the rear <sil=0.910> .PERIOD Then what happens <sil=0.960> ?QUESTIONMARK I am always doing modulo size arithmetic <sil=0.959> .PERIOD So <sil=0.515> ,COMMA when it exceeds it over here <sil=0.335> ,COMMA then what will happen <sil=0.975> ?QUESTIONMARK The rear will start overflowing onto the beginning of the array <sil=0.976> .PERIOD There is a problem with this implementation <sil=0.343> ,COMMA I want you to think about it <sil=0.961> .PERIOD I said I start with front pointing here and rear pointing here to indicate that it is an empty Q <sil=0.982> .PERIOD Now <sil=0.448> ,COMMA how do we distinguish between an empty and a full Q <sil=0.969> ?QUESTIONMARK This becomes a problem <sil=0.938> .PERIOD So <sil=0.346> ,COMMA we will need another variable or alternatively you can think of something more clever and I would like you to think about this particular problem <sil=0.905> .PERIOD So <sil=0.443> ,COMMA circular Q <sil=0.455> ,COMMA the advantage is that the Q is found anywhere between two indices front and rear <sil=0.967> .PERIOD How are these indices computed <sil=0.851> ?QUESTIONMARK The indices are computed using modulo arithmetic and modulo is based on <sil=0.988> .PERIOD For example <sil=0.391> ,COMMA I will say rear is instead of saying rear plus 1 <sil=0.468> ,COMMA we will do rear plus 1 mod max size <sil=0.949> .PERIOD We have to do a little more bookkeeping as I already said when we are to distinguish between a full and an empty Q <sil=0.967> .PERIOD There are two ways of doing it <sil=0.964> .PERIOD You can introduce an extra variable <sil=0.917> .PERIOD So <sil=0.303> ,COMMA the point is if I am using an array implementation <sil=0.454> ,COMMA what is happening <sil=0.916> ?QUESTIONMARK The linear array <sil=0.385> ,COMMA the array size gets exhausted very quickly <sil=0.506> ,COMMA but the circular array whatever is available in this <sil=0.450> ,COMMA it will the Q can be basically the Q moves like this <sil=0.956> .PERIOD That is the fundamental property of the circular course <sil=0.408> ,COMMA nice data structure and I want you to implement all of this <sil=0.957> .PERIOD Interestingly <sil=0.553> ,COMMA again all the operations on the Q can be implemented in order of one time <sil=0.969> .PERIOD Let me leave you with this <sil=0.918> .PERIOD As I already said <sil=0.496> ,COMMA implementation is a circular Q in an array <sil=0.930> .PERIOD There are issues you need to find out how to fix this <sil=0.595> ,COMMA definitely a distinction between empty and a full Q <sil=0.903> .PERIOD Then I want you to do this as an assignment <sil=0.958> .PERIOD It is nice to <sil=0.340> ,COMMA simulation is a very good way of learning about ADTs and I would like you to simulate a petrol pump <sil=0.987> .PERIOD I have a petrol pump <sil=0.357> ,COMMA it serves petrol for various people <sil=0.945> .PERIOD Let us say you have two different petrol pumps <sil=0.454> ,COMMA pumps one for the four wheelers and one for the two wheelers and for each one of them you can have arrivals that happen to the particular system <sil=0.973> .PERIOD To give you an example <sil=0.582> ,COMMA let us say the two wheelers arrive very frequently <sil=0.950> .PERIOD I almost have a two wheeler in every minute whereas I may have one four wheeler every five minutes or something like that <sil=0.946> .PERIOD Simulate this <sil=0.410> ,COMMA put it in a Q and then on Q and DQ and just give statistics of how long the Q is at different intervals of time <sil=0.900> .PERIOD Another very interesting implementation of Q is using the circularly linked list <sil=0.944> .PERIOD I am having a linked list over here and I tied the back to the front and I am giving you only one point of P <sil=0.572> ,COMMA no two point <sil=0.996> .PERIOD We are not going to have front 10 rear <sil=0.908> .PERIOD I want you to implement the Q <sil=0.984> .PERIOD All operations on Q must be all-dermented <sil=0.996> .PERIOD I want you to do this <sil=0.968> .PERIOD I am giving you only one point of no front 10 rear <sil=0.906> .PERIOD There is only one point of P <sil=0.924> .PERIOD So <sil=0.334> ,COMMA now where should P point <sil=0.895> ?QUESTIONMARK Should it point to the front <sil=0.918> ?QUESTIONMARK Should it point to the rear <sil=0.876> ?QUESTIONMARK I want you to think about it <sil=0.968> .PERIOD It is a circularly linked list <sil=0.902> .PERIOD Now <sil=0.384> ,COMMA there is one more problem which is not listed there <sil=0.933> .PERIOD How do you implement a Q <sil=0.930> ?QUESTIONMARK See <sil=0.476> ,COMMA we saw in the beginning of the class <sil=0.413> ,COMMA how to implement a Q using a list edd <sil=0.959> .PERIOD The question that I want to ask you is how do you implement a Q using stacks <sil=0.985> ?QUESTIONMARK I want to use a stack edd <sil=0.921> .PERIOD Remember <sil=0.342> ,COMMA we reuse the linked list edd to build the Q edd <sil=0.969> .PERIOD Can I do the same thing <sil=0.992> ?QUESTIONMARK After all Q is also a list type of list <sil=0.991> .PERIOD Stack is also a type of list <sil=0.974> .PERIOD Now <sil=0.389> ,COMMA can I use the stack edd to implement a Q edd <sil=0.947> ?QUESTIONMARK What would I require <sil=0.983> ?QUESTIONMARK I want you to ponder about this particular problem <sil=0.986> .PERIOD So <sil=0.409> ,COMMA we now study the analysis of merge sort and also learn a new algorithm for sorting which under special cases is better than merge sort called radic sort <sil=0.991> .PERIOD So <sil=0.526> ,COMMA all merge sort it was it is an algorithm implemented on an array of elements <sil=0.924> .PERIOD If the array size is just a single element it is done otherwise we sort the array of elements in the indices 1 to n by 2 the floor of n by 2 and then the second half of the array whose indices are in the range floor of n by 2 plus 1 to n and then we merge these sorted list <sil=0.934> .PERIOD We did see that the effort involved in merging two sorted list is linear in the size of the data that is to be merged <sil=0.940> .PERIOD In other words if we merge an array of size L with an array of size m then the total number of comparisons taken is L plus m <sil=0.921> .PERIOD The recurrence of merge sort is T of n is equal to 1 if n is 1 and it is 2 times T of n by 2 plus n if n is more than 1 <sil=0.975> .PERIOD The 2 times T of n by 2 comes from the two recursive sub problems that are generated from a given problem and the additional term of n comes for the effort spent in merging two arrays of size n by 2 sorted arrays of size n by 2 <sil=0.969> .PERIOD We now complete the analysis of this recurrence and for these of presentation we analyze the case when n is a power of 2 <sil=0.971> .PERIOD There are many ways to find good upper bounds on T of n for n in general however we expose the way by which T of n is solved when n is a power of 2 because it is an extremely instructive presentation <sil=0.980> .PERIOD The recursion tree for the recurrence is T of n is equal to 2 times T of n by 2 plus n this is the recurrence and the recursion tree is constructed as follows <sil=0.990> .PERIOD At the root of the tree is the function that we want to compute which is T of n <sil=0.947> .PERIOD It is two children are T of n by 2 and T of n by 2 now the root is now replaced by the value n which is added to the sum of T of n by 2 and T of n by 2 <sil=0.972> .PERIOD The tree is further expanded using the same rule where n by 2 replaces the element T of n by 2 and its two children become the values T of n by 4 and T of n by 4 <sil=0.962> .PERIOD One branch of this whole recursion tree right up to the leaf one can note that the values are in the range n n by 2 n by 4 all the way down to 1 <sil=0.946> .PERIOD In other words as the depth of the tree increases from the root the size of the sub problems being solved falls by a ratio of 2 falls by a fraction of 2 it becomes n n by 2 and then n by 4 and goes down all the way to 1 <sil=0.934> .PERIOD Therefore <sil=0.314> ,COMMA the height of this tree is log n to the base 2 the contribution to the whole recursion which is essentially the summation of the values at all the nodes now at the root the contribution is n because the value is just n at the level 1 depth 1 the contribution is again n because there are two nodes of value n by 2 at the next level 2 there are two nodes 4 nodes of value n by 4 and the contribution is the value n and so on all the way up to the leaves and it is clear that the number of leaves is exactly equal to n because every leaf node contributes a value 1 and therefore <sil=0.645> ,COMMA the number of leaf nodes is n therefore <sil=0.308> ,COMMA the contribution from the leaf level is also n <sil=0.954> .PERIOD Consequently the solution to this recurrence is n log n now we have placed an upper bound on the total number of comparisons made by merge sort which is an algorithm which uses the divide and conquer approach and clearly n log n grows more slowly than n square this is very easily visible to us observe the n log n and n square the common term is n and log n and n n is exponentially larger than log n and therefore <sil=0.335> ,COMMA n log n grows much more slowly than n square therefore <sil=0.303> ,COMMA merge sort has a better asymptotic running time than the algorithm insertion sort we go forward with the very natural question of can we beat the n log n bound it is indeed possible to sort linear time when the data that we are sorting has some very special properties <sil=0.939> .PERIOD In this case we study an algorithm called counting sort counting sort is a very special algorithm it does not have any comparisons among the elements the input array is an n element array which contains the values to be sorted in this case we assume that the values come from a range 1 2 to k and we make an assumption that the values are all numbers the output is presented in an array b which is also an n element array and the output is sorted the algorithm uses an auxiliary array called c which has k elements recall that k is the total number of distinct elements that one c is in the input array from the range 1 to k and c is an array of size k elements in essence every value of the value of the value which is in the array a can be an index into the array c and this is an idea that we use to obtain a linear time sorting algorithm in this special case <sil=0.915> .PERIOD So <sil=0.329> ,COMMA let us just look at counting sort counting sort basically has four loops the first loop is the initialization loop where the count array or the array c is initialized to take the value 0 in the next iteration in the next for loop we count the number of occurrences of each element of the array a by making one pass of the array a observe what the for loop does the shape it inside the for loop say for example <sil=0.359> ,COMMA the first element c of a of j if the first element is a one then the array index 1 in the array c is incremented by one <sil=0.923> .PERIOD So <sil=0.308> ,COMMA every time we see a value in the array a the corresponding index location corresponding location and c index by the value is incremented by one at the end of the first for loop every array location in particular the i th array location counts the number of occurrences of the key i in array a in the third for loop the consecutive elements of the array c are added to ensure that the array element i keeps track of the number of elements of value lesser or equal to i in the given array a and finally <sil=0.559> ,COMMA these count information are used to rearrange and obtain the sorted array b which is as follows the key at the element j the key at the index j in array a is moved to its rank and the value of the value of the value of the array in array b in other words if the key at array index j has 4 occurrences in the array a then c of a of j would be 4 and the value a of j would be kept in the array location b of 4 and then the number of occurrences of the value at a of j at the index j is reduced by 1 <sil=0.997> .PERIOD Let us run one example of this algorithm the array a has the values 4 1 3 4 3 in the 5 locations and let us see how the initial array c looks like its initialize to 0 and since the distinct keys are on the range 1 to 4 in the array a all the the array size c has only 4 elements array c has only 4 elements to keep track of the counts of the values 1 2 3 and 4 respectively <sil=0.924> .PERIOD The first element in array a is the value 4 and the second loop increments c of 4 then the value c of 1 is incremented by 1 then the value c of 3 is incremented by 1 then the value c of 4 is incremented by 1 and it becomes 2 now and the value c of 3 is incremented by 1 now which becomes 2 <sil=0.990> .PERIOD It is easy to observe the following invariant that the sum of the array element c is the total number of elements in the array a in this case it is 5 <sil=0.970> .PERIOD In the next iteration we modify and store c and let us see how we do this observe that we now keep track of the number of elements whose values less than or equal to 2 in the array a and in the location c of 2 that is obtained by adding c of 1 and c of 2 to get the value 1 which is a count of the number of elements whose values less than or equal to 2 <sil=0.982> .PERIOD In the next iteration the number of elements less than or equal to the value 3 is kept track of and we can see that the value should be 3 and let us see this that is what it becomes and then the number of elements of value less than or equal to 4 is indeed 5 elements all of them are of value less than or equal to 4 and c of 4 is now updated to the value 5 <sil=0.948> .PERIOD Now comes the phase when the sorted elements are output and this is the loop that runs in the reverse order <sil=0.933> .PERIOD Let us look at the last element in the array a it is a value 3 <sil=0.928> .PERIOD Now there are 3 occurrences of elements less than or equal to 3 in the array a that is the element 1 3 and 3 <sil=0.915> .PERIOD Now the element 3 should definitely be in the third position in the sorted array and therefore 3 is now placed into the third position and the number of relevant occurrences of 3 is now reduced by the number of elements smaller than 3 is now reduced by 1 <sil=0.989> .PERIOD Then 4 is considered and the number of elements of value less than or equal to 4 is 5 and therefore this 4 should occur in the fifth location in the sorted array <sil=0.941> .PERIOD In other words 4 is the largest element and it must occur in the fifth location in the sorted array and then the value of c of 4 is reduced by 1 <sil=0.915> .PERIOD Next element considered as 3 and the number of elements less than or equal to 3 in the given array a which have not been considered so far is 2 and therefore 3 goes into the second location and then naturally 1 goes into the first location and the number of elements less than or equal to 1 is reduced to 0 and then the last element is considered 4 and the number of elements less than or equal to 4 in the sorted array the number of elements less than or equal to 4 in the sorted array is reduced by 4 and 4 goes into the fourth location and the algorithm terminates when the loop comes to an end <sil=0.979> .PERIOD One of the most interesting properties of this algorithm is that counting sort is a stable sorting algorithm <sil=0.927> .PERIOD What is the meaning of a stable sorting algorithm <sil=0.973> ?QUESTIONMARK If 2 elements have the same value if 2 array indices have the same value then in the sorted array the order in which the occur is preserved <sil=0.918> .PERIOD For example if you see the 2 occurrences of 4 in the array indices 1 and 4 respectively observe that the occurrence of 4 in the array location 1 in a goes to b of 4 and the occurrence of 4 in the fourth location goes to b of 5 <sil=0.995> .PERIOD Same is true with 3 therefore not only is the array sorted but interestingly the array also maintains a certain stability in other words it guarantees that the input order among elements of the same value is respected in the sorted output <sil=0.984> .PERIOD It is interesting to ask this question as to which other algorithms that we have seen have this property <sil=0.955> .PERIOD Based on this algorithm we present this approach to sort numbers which is called the erratic sort <sil=0.996> .PERIOD The idea of the erratic sort is to sort numbers digit by digit and the idea is to sort the numbers based on the first digit and use a stable sorting algorithm to sort the numbers based on the first digit <sil=0.926> .PERIOD In other words we will come up with an approach where we just sort the first digit of all the numbers and we will use a stable sorting algorithm to do this and iterate over all the digits <sil=0.971> .PERIOD This is very nicely pictorially represented <sil=0.902> .PERIOD So let us consider the numbers which are given to be sorted which are the numbers 3 <sil=0.443> ,COMMA 29 <sil=0.483> ,COMMA 457 <sil=0.388> ,COMMA 657 <sil=0.323> ,COMMA 8 <sil=0.316> ,COMMA 39 <sil=0.626> ,COMMA 4 <sil=0.436> ,COMMA 36 <sil=0.618> ,COMMA 7 <sil=0.408> ,COMMA 20 and 355 <sil=0.978> .PERIOD Let us consider the least significant digit in each number and visualize this as the array that should be sorted by counting sort which is the stable sorting algorithm that we have just seen <sil=0.989> .PERIOD On sorting the array consisting of the least significant digits the sorted array would look like this which is natural the least significant digits are when they are sorted occur in the order 0 <sil=0.585> ,COMMA 5 <sil=0.617> ,COMMA 6 <sil=0.610> ,COMMA 7 <sil=0.464> ,COMMA 7 and 9 and because counting sort was a stable sorting algorithm observe that the remaining two digits have also been moved to the appropriate location along with the least significant digit <sil=0.999> .PERIOD For example the number 720 has the smallest least significant digit among these and however it is the second largest number but at the end of the first call to counting sort on the least significant digit 720 occupies the first position and the whole number 720 goes to the first place and 0 is at the correct position <sil=0.929> .PERIOD Now the second least significant digit is the number 720 and the number 720 goes to the right and the number 1080 <sil=0.904> .PERIOD As we have seen it the number is at the correct place of the digit is picked up and now this array is sorted again using counting sort and the remaining numbers in some sense are tied to the digit that is being sorted and as a consequence of using a stable sorting algorithm one can observe that the number of the If you focus just on the numbers in the first two digits <sil=0.431> ,COMMA they occur in the sorted order <sil=0.991> .PERIOD And this is an inductive invariant that will be used to argue the correctness of the radixot algorithm <sil=0.938> .PERIOD Finally <sil=0.353> ,COMMA we pick up the third digit and perform a stable sorting and in this case <sil=0.482> ,COMMA we use a counting sort <sil=0.598> ,COMMA counting sort which we have just discussed <sil=0.920> .PERIOD And now we can observe that all the numbers are in sorted order <sil=0.967> .PERIOD And observe that the stability of counting sort is very crucial in the correctness of the algorithm <sil=0.992> .PERIOD And when a certain array is being sorted <sil=0.561> ,COMMA the remaining numbers are visualized as being tied to this particular number <sil=0.955> .PERIOD So the correctness of radixot is argued by induction on the digit position <sil=0.923> .PERIOD So clearly <sil=0.346> ,COMMA after the first call to counting sort <sil=0.638> ,COMMA that is after sorting the least significant digit <sil=0.615> ,COMMA the number whose lower order digits <sil=0.475> ,COMMA the array of least significant digits are sorted <sil=0.972> .PERIOD So let us assume that the numbers are sorted by the lower order t minus 1 digits after sorting the first t minus 1 <sil=0.362> ,COMMA sorting <sil=0.393> ,COMMA applying counting sort on the first t minus 1 digits <sil=0.990> .PERIOD Now when we sort on digit t <sil=0.439> ,COMMA now when we sort on digit t <sil=0.449> ,COMMA the array is now sorted <sil=0.931> .PERIOD It is a stable sorting algorithm <sil=0.941> .PERIOD And let us look at two elements which are in the opposite order <sil=0.933> .PERIOD In other words <sil=0.563> ,COMMA 720 and 329 <sil=0.524> ,COMMA the first two elements <sil=0.488> ,COMMA observe that they have exchanged their places and 329 is smaller than 720 and 720 has gone to its correct location in the sorted array <sil=0.979> .PERIOD Therefore <sil=0.410> ,COMMA the numbers that digit <sil=0.542> ,COMMA that different digit t are correctly sorted <sil=0.946> .PERIOD And two numbers which have the same digit <sil=0.489> ,COMMA two indices which have the same value at digit t are also correctly sorted because we are using a stable sorting algorithm <sil=0.908> .PERIOD Therefore <sil=0.560> ,COMMA we have the correct order among the t digits and this completes the inductive argument <sil=0.928> .PERIOD Let us complete the analysis of <sil=0.962> .PERIOD So <sil=0.453> ,COMMA the first two elements <sil=0.591> ,COMMA counting sort <sil=0.602> ,COMMA the loop 1 which was initializing the count array <sil=0.588> ,COMMA performed K operations because every there are K indices and each of them was initialized to 0 <sil=0.920> .PERIOD Loop 2 performs a computation by looking at every element of the input array A exactly once and then increasing an appropriate index in the count array C by 1 <sil=0.987> .PERIOD So <sil=0.627> ,COMMA this takes n time that is it takes a constant number of operations <sil=0.338> ,COMMA constant number of arithmetic operations per step and loop 3 then gets upper bounds on the values at most on the number of terms whose values are at most each index in C and this again takes K time and loop 4 which writes out the output array B also takes n time and therefore <sil=0.470> ,COMMA the total time taken is order of n plus K <sil=0.926> .PERIOD In this case it is 2 n plus 2 K arithmetic operations <sil=0.935> .PERIOD Now <sil=0.469> ,COMMA if the key set the smallest in the largest value differ by a linear amount by at most n then counting sort takes order of n time <sil=0.923> .PERIOD It is also clear that counting sort does not perform any arithmetic does not perform any comparison operations and it is completely an arithmetic operation based sorting algorithm and it takes linear time in some special cases <sil=1.000> .PERIOD Welcome to lecture 3 <sil=0.922> .PERIOD So <sil=0.408> ,COMMA in the last two lectures we saw basics of C programming and we also saw basic notions of variables and so on <sil=0.997> .PERIOD We looked at control structures <sil=0.515> ,COMMA we also looked at the notion of loops <sil=0.928> .PERIOD So <sil=0.311> ,COMMA in this lecture we will see something really important that C provides us and that is the notion of arrays <sil=0.937> .PERIOD So <sil=0.529> ,COMMA we have seen basic data types like integers <sil=0.343> ,COMMA floating point numbers and characters and these are basic data types <sil=0.970> .PERIOD So <sil=0.426> ,COMMA you can get numbers or letters using that <sil=0.439> ,COMMA but sometimes we also need a logical collection of these values <sil=0.968> .PERIOD It is not that just one value sufficient <sil=0.556> ,COMMA we need a logical collection of values and this is where arrays come in <sil=0.939> .PERIOD So <sil=0.490> ,COMMA arrays are what are called aggregate data types <sil=0.933> .PERIOD So <sil=0.446> ,COMMA it is an aggregate data type of a specific kind <sil=0.505> ,COMMA it aggregates data of the same type of elements <sil=0.987> .PERIOD You can also aggregate data of different types together <sil=0.620> ,COMMA we will see that later <sil=0.533> ,COMMA these are called structures <sil=0.330> ,COMMA we will see them later <sil=0.339> ,COMMA but arrays are aggregate elements of the same data type <sil=0.973> .PERIOD So <sil=0.422> ,COMMA there are lots of examples where you need this <sil=0.955> .PERIOD One primary thing is these arrays are usually fixed at size and they are also sequentially indexed <sil=0.966> .PERIOD So <sil=0.638> ,COMMA we will see all these things as we go along <sil=0.905> .PERIOD So <sil=0.627> ,COMMA arrays are logical collections of the same type <sil=0.963> .PERIOD For instance <sil=0.549> ,COMMA it could be list of marks of a student <sil=0.362> ,COMMA it could be temperature that you are recording over a year or you want to save matrices and do operations on matrices and so on <sil=0.901> .PERIOD So <sil=0.317> ,COMMA these are all examples of arrays and on these arrays <sil=0.608> ,COMMA you want to do operations like find minimum <sil=0.549> ,COMMA find maximum or you want to order all of the elements in such a way that the names of students come in alphabetical order or you may want to search for a particular temperature of the day and so on <sil=0.993> .PERIOD So <sil=0.501> ,COMMA these are common operations <sil=0.975> .PERIOD So <sil=0.367> ,COMMA you want to be able to read entries into an array <sil=0.650> ,COMMA you want to do operations on an array and so on and that is exactly what we will do in this lecture <sil=0.941> .PERIOD So <sil=0.501> ,COMMA let us do a little thought experiment <sil=0.921> .PERIOD I want to find out average temperature of the year <sil=0.972> .PERIOD So <sil=0.537> ,COMMA I have 365 days and if I did not have support for these aggregate data types called arrays <sil=0.535> ,COMMA my program would look something like this <sil=0.957> .PERIOD So <sil=0.485> ,COMMA I show only the code segment here <sil=0.924> .PERIOD Let us see what it has <sil=0.993> .PERIOD So <sil=0.341> ,COMMA there is first of all 365 days <sil=0.545> ,COMMA I will need 365 variables <sil=0.951> .PERIOD Float <sil=0.353> ,COMMA I temperature 1 <sil=0.617> ,COMMA temperature 2 and so on <sil=0.311> ,COMMA up till temperature 365 <sil=0.344> ,COMMA I will need all these declarations <sil=0.922> .PERIOD So <sil=0.481> ,COMMA even though I showed dot dot dot <sil=0.580> ,COMMA you really need so many declarations and then I am going to find out the sum and the average of find the sum and therefore find the average <sil=0.926> .PERIOD So <sil=0.321> ,COMMA one thing that I have to do is take all the variables one at a time and read through them <sil=0.993> .PERIOD So <sil=0.394> ,COMMA I have so many declarations and then I go on and scan all of them and finally <sil=0.646> ,COMMA I need a huge expression which takes each of these variables and add them up and give sum <sil=0.926> .PERIOD So <sil=0.302> ,COMMA what we have is something really cumbersome <sil=0.951> .PERIOD So <sil=0.482> ,COMMA we have 365 variable names <sil=0.641> ,COMMA we will have to scan each one of them and we will have 365 lines in which we will scan them <sil=0.959> .PERIOD So <sil=0.333> ,COMMA that is what you will do in this block here and finally <sil=0.493> ,COMMA this one where you are adding up all the values is also rather cumbersome because if you forget something you have no way to go back and check which one is missed out <sil=0.931> .PERIOD So <sil=0.603> ,COMMA this is not a nice way to do things and programming languages give support for the same data type <sil=0.590> ,COMMA temperature being floating point and have many of those aggregated into something called an array <sil=0.958> .PERIOD So <sil=0.346> ,COMMA let us see the same thing done using arrays <sil=0.954> .PERIOD It is much more elegant if you use arrays <sil=0.935> .PERIOD So <sil=0.460> ,COMMA the first thing you will notice is that there is float temp of 365 <sil=0.965> .PERIOD So <sil=0.391> ,COMMA what you see here is you see that there is a declaration here which goes like open bracket 365 close bracket <sil=0.905> .PERIOD All it says is I do not want a single floating point number <sil=0.547> ,COMMA I need 365 floating point numbers and so that has to be allocated somewhere <sil=0.937> .PERIOD As before we have float sum equals 0 and average and now I want to scan the elements one by one <sil=0.943> .PERIOD This whole thing becomes very nice and simple <sil=0.919> .PERIOD You have seen the for loop before for i equals 0 i less than 365 i plus plus scan f ampersent temp of i <sil=0.940> .PERIOD So <sil=0.357> ,COMMA what this loop does is it scans the elements one by one and it stores it in what is called temp of i <sil=0.903> .PERIOD We will see what temp of i means in a little while <sil=0.925> .PERIOD But the first thing I want you to observe is that it has become much more elegant <sil=0.918> .PERIOD Instead of 365 lines that you had earlier <sil=0.599> ,COMMA now you have three lines of code which is scanning 365 elements <sil=0.926> .PERIOD The second other the other thing that we have very nice is just the addition itself <sil=0.981> .PERIOD So <sil=0.426> ,COMMA as before we iterate over all the elements from i equal to 0 to i equals 364 both inclusive and we add the temperature to sum <sil=0.974> .PERIOD So <sil=0.317> ,COMMA you add one temperature at a time and the result goes back to sum <sil=0.904> .PERIOD At the end of this loop you have the sum which is the sum of all the temperatures over 365 days <sil=0.994> .PERIOD So <sil=0.339> ,COMMA if you divide by 365 you get average <sil=0.901> .PERIOD So <sil=0.511> ,COMMA one thing that you notice you have to notice here is that the sum is actually initialized to 0 here <sil=0.930> .PERIOD Therefore <sil=0.512> ,COMMA you start with 0 as the temperature and then you add on temperature of each of the days to give temperatures of 365 days and then you divide by 365 <sil=0.903> .PERIOD So <sil=0.351> ,COMMA the whole the nice thing about this whole thing is it fits into one screen <sil=0.946> .PERIOD So <sil=0.428> ,COMMA if I have won 5 years all I have to do is ensure that I iterate over 365 into 5 iterations <sil=0.985> .PERIOD So <sil=0.383> ,COMMA the piece of code is still going to be something very very small <sil=0.941> .PERIOD So <sil=0.601> ,COMMA I do not have to declare so many variables and the program does not get clumsy and there is less scope for error when you have arrays than when you have individual variables <sil=0.959> .PERIOD So <sil=0.635> ,COMMA let us go and look at arrays in more detail now <sil=0.933> .PERIOD The first thing is as before we need to declare arrays before we use them <sil=0.913> .PERIOD So <sil=0.586> ,COMMA the syntax is follows <sil=0.937> .PERIOD So <sil=0.617> ,COMMA you start with type and then you give a array name and then you give number of elements <sil=0.984> .PERIOD So <sil=0.600> ,COMMA just like this you specify the type you specify the array name and you want the number of elements <sil=0.953> .PERIOD So <sil=0.529> ,COMMA in this case marks is an array of size 7 and they are all integers <sil=0.980> .PERIOD So <sil=0.482> ,COMMA the key thing is remember there is an aggregate data type of type integer here <sil=0.922> .PERIOD Similarly <sil=0.327> ,COMMA in this line we have temperature which is an array of 365 elements and the values that it can contain are floating point values <sil=0.957> .PERIOD So <sil=0.429> ,COMMA one important thing that you order remember is that then you say in marks of 7 for example <sil=0.543> ,COMMA you get something which is continuous in nature as in these are locations which are continuous in your memory and the individual elements of the array can be indexed as marks of 0 marks of 1 and so on up till marks of 6 <sil=0.999> .PERIOD So <sil=0.377> ,COMMA anything which is of the form marks of i where 0 less than or equal to i less than or equal to 6 is valid <sil=0.933> .PERIOD Let us see what happens from the memory point of view <sil=0.987> .PERIOD So <sil=0.415> ,COMMA earlier we saw what happens to variables from the memory point of view <sil=0.929> .PERIOD Let us see what happens to arrays from a memory point of view <sil=0.964> .PERIOD So <sil=0.337> ,COMMA when you see a declaration like in marks of 7 what you are really seeing is an array <sil=0.979> .PERIOD So <sil=0.611> ,COMMA you see memory locations here I am showing only a segment of the memory and instead of one variable called marks we are going to have 7 variables named marks of 0 to marks of 6 <sil=0.952> .PERIOD So <sil=0.593> ,COMMA this is not a mistake it is marks of 0 to 6 are not 1 to 7 <sil=0.987> .PERIOD So <sil=0.438> ,COMMA some languages start indexing arrays at 1 <sil=0.343> ,COMMA but see indices started 0 <sil=0.980> .PERIOD So <sil=0.388> ,COMMA you can think of it as 7 variables namely marks of 0 to marks of 6 and as we did earlier if you do not have any initialization the values in the array are unknown <sil=0.955> .PERIOD You should assume that these values are unknown and this could get laid out anywhere in the memory just like variables 2 <sil=0.928> .PERIOD The only thing is that these are going to be 7 continuous locations <sil=0.996> .PERIOD So <sil=0.626> ,COMMA for instance let us assume that marks of 0 was allocated address 2731 then marks of 1 would be at address 2732 and so on marks of 6 would be at address 2737 <sil=0.995> .PERIOD So <sil=0.538> ,COMMA this is what I meant by arrays are going to have continuous set of locations <sil=0.938> .PERIOD So <sil=0.301> ,COMMA as I said each element can be thought of as a variable just like individual variables they start out to initialize <sil=0.974> .PERIOD One nice thing is once you have declared an array just like in variables you can assign values to these variables <sil=0.960> .PERIOD So <sil=0.321> ,COMMA we saw that we can have left hand side variable name right hand side value for or expressions for variables the same thing applies for arrays <sil=0.946> .PERIOD So <sil=0.372> ,COMMA in the left hand side you have an individual variable marks of 3 and on the right hand side we have a value 36 <sil=0.953> .PERIOD So <sil=0.314> ,COMMA if you do this in your program then the value will go to 36 <sil=0.921> .PERIOD So <sil=0.545> ,COMMA at this point you know the contents of the location marks of 3 <sil=0.920> .PERIOD As before we can use ampersand to get the location of the memory <sil=0.930> .PERIOD So <sil=0.532> ,COMMA for instance if I want let us say address of marks of 2 then I do ampersand of marks of 2 and ampersand of marks of 2 would give me 2733 as the value <sil=0.923> .PERIOD Ampercent of marks of 1 would give me 2732 as the value and so on <sil=0.909> .PERIOD So <sil=0.301> ,COMMA the addresses are going from 2731 down to 2737 in increasing values <sil=1.000> .PERIOD So <sil=0.603> ,COMMA they are contiguous and they are increasing from 0 to array index 6 <sil=0.991> .PERIOD So <sil=0.345> ,COMMA let us revisit the example that we did earlier <sil=0.966> .PERIOD So <sil=0.631> ,COMMA we have float temp of 365 <sil=0.996> .PERIOD So <sil=0.406> ,COMMA we have an array of type 365 or of type float and 365 values <sil=0.910> .PERIOD At this point we do not care about where it is getting laid out in the memory because that is something that your runtime system should do <sil=0.957> .PERIOD So <sil=0.384> ,COMMA as a programmer we do not care about where it is in the memory location just like for variables we do not care where they are in the memory <sil=0.956> .PERIOD Then this is something that I did not draw attention to earlier <sil=0.969> .PERIOD Now <sil=0.325> ,COMMA let us see what it is doing <sil=0.951> .PERIOD If it is an individual variable we saw that scan of takes the format and the address of a variable <sil=0.991> .PERIOD The same thing is happening here <sil=0.955> .PERIOD We have the format here and we have the address of a variable only that the variable is not an individual variable that is actually array location <sil=0.940> .PERIOD So <sil=0.334> ,COMMA temp of I is temp of 1 temp of 2 <sil=0.983> .PERIOD So <sil=0.392> ,COMMA want to temp of 364 and when finally <sil=0.501> ,COMMA when you look at this loop it runs from 0 to 364 <sil=0.985> .PERIOD So <sil=0.531> ,COMMA it actually runs 365 times <sil=0.988> .PERIOD So <sil=0.453> ,COMMA your array is indexed from 0 to 364 <sil=0.970> .PERIOD The loop also runs from 0 to 364 <sil=0.919> .PERIOD We are actually scanning 365 elements and in this loop we are adding all the 365 elements into some and you average at the end of it <sil=0.989> .PERIOD So <sil=0.568> ,COMMA it is as simple as that <sil=0.982> .PERIOD So <sil=0.472> ,COMMA from arrays we get continuous locations and we have a same data type but we have many elements of the same data type one after the other <sil=0.910> .PERIOD There are various ways to initialize arrays <sil=0.927> .PERIOD You can do something like this <sil=0.959> .PERIOD Let us say I want marks of 7 students and I could have it as int marks of 7 and read it from the user or sometimes I know what these values are <sil=0.990> .PERIOD So <sil=0.640> ,COMMA I could initialize it right away I could do this <sil=0.924> .PERIOD So <sil=0.594> ,COMMA int marks of 7 <sil=0.965> .PERIOD So <sil=0.318> ,COMMA I am declaring marks to be an integer array of 7 elements and you can specify the list of values on the right hand side using a curly braces <sil=0.930> .PERIOD So <sil=0.619> ,COMMA in this case marks of 0 would be 22 <sil=0.963> .PERIOD Marks of 2 would be 75 <sil=0.420> ,COMMA marks of 6 would be 45 and so on <sil=0.938> .PERIOD So <sil=0.317> ,COMMA the locations on the left side can be seen as 0 to 7 and the values can be seen from left to right <sil=0.934> .PERIOD So <sil=0.642> ,COMMA you get a 1 to 1 mapping from left side to the right side <sil=0.997> .PERIOD So <sil=0.622> ,COMMA when you do this let us say these are locations 0 to 6 and the values are 22 for 0 <sil=0.594> ,COMMA 15 for 1 and so on till 45 for marks of 6 <sil=0.937> .PERIOD It is not just that you can initialize and leave it at that you can change the values just like you do for other variables <sil=0.968> .PERIOD So <sil=0.587> ,COMMA you can do something of this effect even though you have initialized mark of 3 to 56 we can do some assignment like this marks of 3 equal to 36 and that will change the value to 36 <sil=0.998> .PERIOD So <sil=0.455> ,COMMA you saw that the value change from 56 to 36 <sil=0.939> .PERIOD So <sil=0.503> ,COMMA there are a few fine points that you have to remember array indices always started 0 in C <sil=0.967> .PERIOD If you come from other programming languages some languages started 1 <sil=0.943> .PERIOD So <sil=0.406> ,COMMA be aware of this there is a common mistake and a lot of people get trapped in this thing that the indexes indices started 1 and not at 0 <sil=0.934> .PERIOD So <sil=0.520> ,COMMA in C they do started 0 and when you do marks of 7 marks of 0 to 6 all are valid marks of 7 is invalid as well as marks of minus 1 or minus 2 and so on <sil=0.939> .PERIOD So <sil=0.642> ,COMMA you will never have indices which are negative nor will you have an index which is greater than the which is greater than equal to the declaration that you had <sil=0.999> .PERIOD So <sil=0.580> ,COMMA for example <sil=0.338> ,COMMA in the float that you showed earlier <sil=0.901> .PERIOD So <sil=0.379> ,COMMA we have 365 <sil=0.980> .PERIOD So <sil=0.529> ,COMMA flow temp of 365 would be invalid because we have only temp of 0 to temp of 364 <sil=0.966> .PERIOD So <sil=0.581> ,COMMA I want to talk about another small example which is along the lines of finding the hottest day <sil=0.989> .PERIOD So <sil=0.395> ,COMMA I have read 365 temperatures into an array called temp but I want to find out the maximum temperature or which day was the hottest day <sil=0.923> .PERIOD So <sil=0.596> ,COMMA what I want the user to print is print the day in which the day was the hottest as well as the temperature of that day <sil=0.982> .PERIOD So <sil=0.630> ,COMMA as before we have float temp of 365 and I have two arrays two variables namely hottest day and I I am going to use hottest day to find out what the which day is the hottest and I am going to use I to iterate over all the locations <sil=0.935> .PERIOD So <sil=0.443> ,COMMA initially what I am going to assume is day 0 is the hottest <sil=0.906> .PERIOD So <sil=0.347> ,COMMA let us say this is January 1 <sil=0.973> .PERIOD I assume that January 1 is the hottest and it is day 0 <sil=0.996> .PERIOD So <sil=0.319> ,COMMA temp of hottest day which is temp of 0 goes to max <sil=0.917> .PERIOD Now <sil=0.393> ,COMMA I run a loop from 1 to 364 <sil=0.931> .PERIOD So <sil=0.489> ,COMMA this goes from January 2 till December 31 and what I am going to do is I am going to see if the current temperature is less than the the current maximum temperature that I have in record is less than temperature of day I <sil=0.909> .PERIOD So <sil=0.369> ,COMMA if it is less then max is that I have is not the actual max <sil=0.943> .PERIOD Some other day became hotter <sil=0.939> .PERIOD So <sil=0.647> ,COMMA I have to update it <sil=0.991> .PERIOD So <sil=0.620> ,COMMA I have hottest day equal to I updated <sil=0.972> .PERIOD I not only update the day in which the day was the temperature was very high <sil=0.939> .PERIOD I also record the actual temperature because that is what you are actually tracking <sil=0.920> .PERIOD So <sil=0.515> ,COMMA what this loop really does is this <sil=0.956> .PERIOD So <sil=0.594> ,COMMA you go from day day 1 to day 364 <sil=0.980> .PERIOD So <sil=0.505> ,COMMA we started day 0 we go from day 1 to day 364 and if some other day becomes hotter we update it and we move forward <sil=0.912> .PERIOD And since I have to find out the hottest day in the year I have to go all the way till days or day 0 to day 364 <sil=0.377> ,COMMA 365 days <sil=0.992> .PERIOD At the end of it hottest day will have the index of the day and max will contain the actual temperature <sil=0.909> .PERIOD So <sil=0.481> ,COMMA I can print that the hottest day was day number hottest day with temperature max <sil=0.915> .PERIOD So <sil=0.527> ,COMMA this is a very simple loop <sil=0.936> .PERIOD I did not show code for reading in the temperature of the 365 days <sil=0.448> ,COMMA but we only see the code for finding out the maximum <sil=0.905> .PERIOD So <sil=0.352> ,COMMA this is a very simple and common example of how arrays are used <sil=0.942> .PERIOD I want to find out the maximum <sil=0.960> .PERIOD So <sil=0.521> ,COMMA it could be marks of 100 students or so and I want to find out which student got the highest mark <sil=0.987> .PERIOD So <sil=0.583> ,COMMA I may have to just iterate over this and find out the largest value <sil=0.998> .PERIOD So <sil=0.567> ,COMMA we start with day 0 being the hottest and if height day is hotter than the current record updated <sil=0.999> .PERIOD There are also multi-dimensional arrays that are possible <sil=0.905> .PERIOD So <sil=0.391> ,COMMA not everything in practical use is one dimensional <sil=0.953> .PERIOD So <sil=0.392> ,COMMA even though I have things like matrices and so on <sil=0.527> ,COMMA naturally they are multi-dimensional or in this matrices are actually two-dimensional <sil=0.945> .PERIOD You could also have three-dimensional structures and so on <sil=0.942> .PERIOD So <sil=0.511> ,COMMA C gives you flexibility to have arrays of multiple dimensions <sil=0.972> .PERIOD So <sil=0.355> ,COMMA for instance <sil=0.522> ,COMMA let us see something of this kind <sil=0.929> .PERIOD If I have a declaration in A square bracket 4 square bracket 3 <sil=0.493> ,COMMA it means that we have 4 rows numbered 0 <sil=0.590> ,COMMA 1 <sil=0.436> ,COMMA 2 <sil=0.352> ,COMMA 3 <sil=0.373> .PERIOD So <sil=0.323> ,COMMA that comes from this and number of columns being 3 numbered from 0 to 2 <sil=0.905> .PERIOD So <sil=0.631> ,COMMA we have 4 rows by 3 columns <sil=0.998> .PERIOD I can also have something which is three-dimensional <sil=0.953> .PERIOD So <sil=0.551> ,COMMA in this case <sil=0.580> ,COMMA I have a floating point array called B and there are three dimensions to it <sil=0.990> .PERIOD So <sil=0.323> ,COMMA you can think of it as x <sil=0.456> ,COMMA y and z dimension <sil=0.981> .PERIOD So <sil=0.467> ,COMMA in the x dimension <sil=0.531> ,COMMA there is two <sil=0.989> .PERIOD You can think of it as two planes <sil=0.415> ,COMMA plane 0 and plane 1 <sil=0.905> .PERIOD In each plane <sil=0.647> ,COMMA I have 4 rows and three columns <sil=0.937> .PERIOD That is what you see here <sil=0.942> .PERIOD So <sil=0.524> ,COMMA in each plane <sil=0.484> ,COMMA I have 4 rows and three columns <sil=0.948> .PERIOD So <sil=0.534> ,COMMA this comes in very handy for handling matrices and graphics and so on <sil=0.997> .PERIOD We will look at these examples in little later <sil=0.973> .PERIOD In a little while <sil=0.323> ,COMMA we will see examples of multi-dimensional arrays <sil=0.906> .PERIOD So <sil=0.311> ,COMMA at the end of this module <sil=0.520> ,COMMA what we have is basic notion of arrays <sil=0.332> ,COMMA what how we can use the arrays <sil=0.638> ,COMMA how we can index them and what happens inside memory <sil=0.933> .PERIOD So <sil=0.500> ,COMMA in the next two modules <sil=0.602> ,COMMA we will see more details about arrays <sil=0.920> .PERIOD So <sil=0.409> ,COMMA good morning class in the last class we did the A D T called list and just recap what is the A D T list list is a sequence of items unordered items for that matter and then we defined a whole lot of operations on list <sil=0.998> .PERIOD We also looked at the implementation of list <sil=0.950> .PERIOD What did we talk about <sil=0.904> ?QUESTIONMARK We talked about two different implementations although I showed you only the linked list implementation both the A A and the linked list and I showed you a linked list implementation of the list I encourage you to do the A A implementation of the list <sil=0.917> .PERIOD Now <sil=0.334> ,COMMA I just have some problems over here <sil=0.996> .PERIOD I would like you to work on storing sets <sil=0.954> .PERIOD I gave you an example of storing sets using lists and basically you want to perform operations on set union intersection and set A minus set B <sil=0.997> .PERIOD I also want you to look at another application of list is to is what we call infinite precision arithmetic <sil=0.940> .PERIOD There is if you want to do let us say you have a 64 bit machine and you want a higher precision than 64 bit then you can use the list as a structure to perform arithmetic on it <sil=0.968> .PERIOD So <sil=0.304> ,COMMA basically what we are talking about is in the list here your A 1 A 2 A n up to n corresponds to different parts of a given number and then you define operations to perform arithmetic operations on this number represented as a list of elements <sil=0.914> .PERIOD What I mean by that is your the numbers represented in parts in terms of A 1 A 2 A n and you want to perform arithmetic operations on them <sil=0.941> .PERIOD So <sil=0.637> ,COMMA I would like you to try these problems <sil=0.970> .PERIOD I also have a few assignment problems <sil=0.980> .PERIOD We talked about this a little the last class <sil=0.355> ,COMMA but I would like you to write a function to remove duplicates in a given list using only list operations and basically a function which takes a list and returns the perj list and I also want you to convert a given unordered list into an ordered list again it should be done in place <sil=0.924> .PERIOD I would like you to do these two problems on this <sil=0.946> .PERIOD Now <sil=0.600> ,COMMA next what we are going to talk about is a different type of ADT called a stack <sil=0.976> .PERIOD What is a stack now <sil=0.967> ?QUESTIONMARK Stack is also a list also a list <sil=0.624> ,COMMA but it has a fundamental difference <sil=0.942> .PERIOD It is a special type of a list ADT and the difference in the stack is that it operates on this principle of what is called last in first out <sil=0.946> .PERIOD What is the meaning of this <sil=0.869> ?QUESTIONMARK That is the last element which enters into the list is removed first this is called a stack <sil=0.996> .PERIOD Now <sil=0.557> ,COMMA let me give you some example when you are putting books on your table then you put the top most the most recent book will be the top most book <sil=0.985> .PERIOD And then when you remove for example <sil=0.579> ,COMMA if you want to remove this particular book you remove the top two books before you can remove this book <sil=0.938> .PERIOD Another example let us talk about plates that are stacked in a cupboard <sil=0.978> .PERIOD So <sil=0.562> ,COMMA you put your plates over here and like this and you remove the top most plate <sil=0.949> .PERIOD The most recent plate is what is first removed <sil=0.916> .PERIOD If you want to remove the third plate from the top here you have to remove the first two before you can remove the third plate <sil=0.904> .PERIOD So <sil=0.617> ,COMMA stack has a lot of nice applications and we will talk about a specific application of stack <sil=0.954> .PERIOD The operations that are supported by the stack are you can push <sil=0.534> ,COMMA you can pop and you can find what is the top most element in the stack can also check whether the given stack is empty or not <sil=0.937> .PERIOD So <sil=0.348> ,COMMA these are the four operations that are normally supported by the stack <sil=0.914> .PERIOD Now <sil=0.525> ,COMMA since stack is a special type of list I want to show you one example here where since you know now the way we look at it is I have already implemented the list ADT <sil=0.902> .PERIOD And since I have already implemented the list ADT I would like that I would like to use the list itself to represent a stack <sil=0.942> .PERIOD So <sil=0.313> ,COMMA how do I go about doing that <sil=0.857> ?QUESTIONMARK The way I would do that is since the list ADT has been you know you already debugged it you have tested it and so on and so forth <sil=0.937> .PERIOD So <sil=0.536> ,COMMA what we could do is we could do is the list ADT itself as a stack <sil=0.939> .PERIOD So <sil=0.594> ,COMMA how would I do that then then what I will do is I will restrict my operation <sil=0.938> .PERIOD So <sil=0.599> ,COMMA what I will say is the push operation <sil=0.996> .PERIOD So <sil=0.570> ,COMMA within my I can write an ADT stack here and say that stack or a class stack and I will say that I have L which is of type list which I have already defined <sil=0.942> .PERIOD This is my private data then I will define a set of operations on stack <sil=0.923> .PERIOD And what are the operations that I want <sil=0.911> ?QUESTIONMARK I want push <sil=0.506> ,COMMA I want pop <sil=0.617> ,COMMA I want top and I want empty <sil=0.943> .PERIOD So <sil=0.578> ,COMMA what will I do for push now <sil=0.900> ?QUESTIONMARK I will say push x comma what do I do L dot first <sil=0.939> ?QUESTIONMARK What is L dot first return <sil=0.956> ?QUESTIONMARK It returns the position right or the first element <sil=0.920> .PERIOD So <sil=0.415> ,COMMA insert at the first position then I can pop I can pop L dot first because this was the most recent element that was inserted <sil=0.921> .PERIOD Top will also give me L dot first <sil=0.978> .PERIOD Pop will be L dot first comma L dot delete L dot first and top is L dot first and what should be empty is if the L dot first equals L dot end then I can say that the stack is empty <sil=0.931> .PERIOD So <sil=0.300> ,COMMA what have we done in this process here now <sil=0.908> ?QUESTIONMARK We have all these operations over here right and sorry this should be retrieve of top should be L dot I will return to here <sil=0.595> ,COMMA tree of L dot first <sil=0.901> .PERIOD This is what we how you would implement all these four operations of the stack using a list <sil=0.953> .PERIOD So <sil=0.305> ,COMMA you can use the list ADT in its present form which you have implemented well as a stack ADT and perform the four operations which are required for the stack <sil=0.980> .PERIOD Now <sil=0.518> ,COMMA what we will do is once I have this so <sil=0.635> ,COMMA the one of the things that I am trying to encourage you to do is that basically that if I already have a ADT which is implemented I try to reuse the abstract ADT type as much as possible because why do I want to do that <sil=0.953> ?QUESTIONMARK The primary reason I want to do that is the list ADT which we implemented in the last class is let us say nicely debugged there are errors in it <sil=0.997> .PERIOD So <sil=0.650> ,COMMA what I will do is I will quickly define a stack using the list and then I will use the stack to perform various operations <sil=0.916> .PERIOD What I am going to do right now is I am going to take give you one application of stacks and then we will look at the implementation of the stack a little later <sil=0.917> .PERIOD Let us say I want to convert an infx expression to a postfix expression to postfix <sil=0.970> .PERIOD Let us see why we want to do this <sil=0.943> .PERIOD Let us say I have an expression which is given like this something like this <sil=0.913> .PERIOD Let us say I have given an expression like this a minus b star c plus d star f plus c by d and suppose we know that star and slash have higher precedence then minus n plus and the all operators are left associated with a minus b plus c <sil=0.984> .PERIOD What do we mean by this is that a minus b plus c is equal to a minus b plus c rather than a minus of b plus c <sil=0.983> .PERIOD Let us assume that all the operators associate to the left <sil=0.984> .PERIOD This is the meaning of it <sil=0.969> .PERIOD If I give an expression like this I do not know whether I have to perform a minus b plus c or should I perform a minus of b plus c that is where b that is where the associativity matters <sil=0.998> .PERIOD What is interesting is that when I am given an expression like this and I do not know the associativity of the operators it is difficult to evaluate this expression <sil=0.950> .PERIOD So <sil=0.468> ,COMMA what is done is given a particular expression the expression is converted to a form called the post fix expression <sil=1.000> .PERIOD So <sil=0.557> ,COMMA let us see what this post fix expression is all about <sil=0.915> .PERIOD Let me just take only a partial expression a minus b star c let us say this will be written as a b c star minus <sil=0.904> .PERIOD What is the meaning of it <sil=0.877> ?QUESTIONMARK We take the top most operator then you come to the next operator and the next one is still an operator <sil=0.928> .PERIOD So <sil=0.498> ,COMMA you push it somewhere take the next operator again you use a stack for this then you take that then you find under top there are two operators over here <sil=0.992> .PERIOD So <sil=0.493> ,COMMA operands over here you compute this b star c the idea is that what happens is that the operator associate with the binary operator associates with the nearest operands that are there <sil=0.966> .PERIOD So <sil=0.530> ,COMMA what is nice is the advantage of this expression when you write it in this form there is no issue about the evaluation why is there no issue about the evaluation because you look at the operator you just for example <sil=0.642> ,COMMA if I keep moving along this as soon as I come across the first operator all that I will do is I will take this operator operate it on these two operands get the result and put it there and let me call it d then I have a d n minus then it means I have to find I must do a minus t <sil=0.957> .PERIOD So <sil=0.567> ,COMMA this there is absolutely no ambiguity when a given expression is given in force fix the order of the operations whereas <sil=0.321> ,COMMA if I give the expression in this form which is called in fix I do not know whether I must perform a minus b star c I do not know the associativity I do not know the precedence of the operators everything is assumed in the post fix expression given a post fix expression all that I have to do is I traverse that post fix expression from left to right as soon as I come across an operator I take the nearest two operands perform the computation then you can put it back on stack there is a way of evaluating again using the stack then once again the result I have a d n minus on the particular stack then again when I traverse this for example <sil=0.376> ,COMMA next I see another operand over here and as soon as I see this I see another operator over here then I take the most nearest two operands perform this operation and I get the result <sil=0.919> .PERIOD So <sil=0.635> ,COMMA the evaluation of expressions is normally done using the post fix expression you take an infix infix expression is very convenient for us to write <sil=0.336> ,COMMA but what we do is we take the infix expression convert the infix expression to a post fix expression and then perform the computation <sil=0.988> .PERIOD So <sil=0.396> ,COMMA now what I am going to show you is the evaluation also can be done using stacks <sil=0.403> ,COMMA but we will take one application we look at conversion of infix to post fix using the stack that see how this gets done <sil=0.916> .PERIOD So <sil=0.609> ,COMMA what is it done here when an operand is read that is I am getting this expression here as soon as I find an operand what am I going to do I am just going to simply place it on the output then when an operator is read what do I do I take this operator <sil=0.980> .PERIOD So <sil=0.441> ,COMMA that means let us go back to this particular expression take this expression now I see an operand I put it this is my output this is my input then what do I do I put it on the I put it to the output when an operator is read what I do is I look at the element I have a stack here right now my stack is empty look at the element which is there on the top of the stack <sil=0.953> .PERIOD If the top of the stack has higher presidents then I keep popping all the elements from the top of the stack <sil=0.922> .PERIOD So <sil=0.519> ,COMMA this part is not there because it is empty so what am I going to do I am going to simply stack the current operator I put minus on it then I have b here then what do I see then I have another I see another operator over here <sil=0.920> .PERIOD So <sil=0.309> ,COMMA now I look at the top of the stack there is a minus sign here minus sign has lower presidents so what I do I just simply stack star also onto it then again I see an operand move it to the output next what do I see I see a plus where I see a plus what I do is the following I look at the content of the top of the stack <sil=0.925> .PERIOD So <sil=0.353> ,COMMA star is the content on the top of the stack so since star is a content on the top of the stack I output and star as higher presidents so the president is like the star comma slash and plus comma minus and of course above this you have the brackets <sil=0.908> .PERIOD So <sil=0.575> ,COMMA what I do is I pop the star then once since I pop the star what do I have I only have minus on top of the stack what is the current operator that I am looking at plus now clearly plus and minus have same president <sil=0.989> .PERIOD So <sil=0.454> ,COMMA what I do I also pop the minus then what I do I put this plus over here onto the stack and we proceed this is how this whole operation goes about all right <sil=0.918> .PERIOD So <sil=0.514> ,COMMA basically this is what we do and now I have done up till this part of the expression now let us look at the next one what do I have now the plus is gone it is gone to the stack I get t I push this onto the stack then what do I have I have a left bracket I put the left bracket also onto the stack then what do I have I have F right then I put the plus on the stack then I have c d then I have the slash over here a compare with what is there put it on the top of the stack then what happens I come across the right bracket <sil=0.963> .PERIOD So <sil=0.588> ,COMMA as soon as I come across the right bracket I pop everything off until I see the left bracket that means I put the slash here I put the plus here and then what do I do I have come to the end of the expression star and plus <sil=0.910> .PERIOD So <sil=0.491> ,COMMA this is how I complete the expression <sil=0.998> .PERIOD So <sil=0.327> ,COMMA this is the conversion from infix to postfix <sil=0.982> .PERIOD So <sil=0.493> ,COMMA what we have done we took the infix expression then we converted it to postfix expression using a stack now let us see if it will give us a evaluation correct what did I say I just keep this as it is then as soon as I see an operator I find the nearest two operands and compute the computation let me call this b prime that is a computer d store and let us say this is the result is p prime then what do I have I have a b minus now clearly there are two operators and an there are two operands and there is an operator <sil=0.908> .PERIOD So <sil=0.608> ,COMMA I compute this let me call this a prime <sil=0.993> .PERIOD So <sil=0.546> ,COMMA what do I what do I have now I have already computed this now I have d f c d slash plus star plus <sil=0.939> .PERIOD So <sil=0.647> ,COMMA what do I do now I keep moving from left this is computed let me call it c prime then I have f c prime d a prime <sil=0.982> .PERIOD So <sil=0.566> ,COMMA what do I do I compute this let me call this f prime <sil=0.993> .PERIOD So <sil=0.631> ,COMMA I have a prime d f prime plus and sorry plus is already gone d prime plus yeah f plus c d right <sil=0.976> .PERIOD So <sil=0.558> ,COMMA c d let me call this c prime plus is already gone I already computed this sum over here and then I have a star over here and a minus <sil=0.968> .PERIOD So <sil=0.584> ,COMMA next what do I do I compute a prime d f prime let me call it d prime after the multiplication because I see the multiplication here multiply these two put the result in d prime I have a minus and now finally <sil=0.633> ,COMMA get the result which is essentially what the so <sil=0.526> ,COMMA basically what it tells me is if I follow the rules of arithmetic for a post-piscuous expression what is the rules say I take the whenever I see an operator I take the nearest two operands perform the computation and store it <sil=0.995> .PERIOD Then what happens that becomes a new operand now b prime then a times b prime a and b prime and there is an operator here minus <sil=0.993> .PERIOD So <sil=0.555> ,COMMA I compute the difference of a and b prime again put it back on top <sil=0.966> .PERIOD So <sil=0.396> ,COMMA then I call it an a prime then what happens I have d f c d I just put them all together then I see a slash when I see a slash what do I do I take the nearest two operands multi divide then here the operator is slash <sil=0.982> .PERIOD So <sil=0.429> ,COMMA I divide c by d I call it c prime then I have a prime d f c prime then what happens I have f and c prime <sil=0.906> .PERIOD So <sil=0.308> ,COMMA this is this part so <sil=0.412> ,COMMA I add them then what do I have a prime d f prime let me call it then d f prime star this star is here <sil=0.949> .PERIOD So <sil=0.590> ,COMMA I perform this computation and after because that is the that is the the first operator that I am saying I take the nearest two operands perform the computation then finally <sil=0.615> ,COMMA I will get a new let me call it I get a new operator operand called d prime and a prime d prime and I subtract one from the other and the post-piscuous expression can be evaluated <sil=0.941> .PERIOD So <sil=0.402> ,COMMA clearly what it tells me is using the algorithm that I have given here the conversion to in fixed to post-pictus correct so <sil=0.358> ,COMMA basically I can use a stack to take this input convert it to post-pictus <sil=0.919> .PERIOD So <sil=0.537> ,COMMA what are we doing when we are doing this we are taking all the operators stacking the operators including brackets and when do we pop as soon as we come across an operator which has lower precedence than what is there on the stack I pop all the operators from the stack which have higher precedence and the operators which have the same precedence to and put this operator onto the stack that is exactly what we did let me illustrate this with the pictorial example again <sil=0.980> .PERIOD So <sil=0.635> ,COMMA let us say we have the same I have the same almost the same expression which I have already gone through over here and I have realized it <sil=0.983> .PERIOD So <sil=0.540> ,COMMA the same expression that is there and here is a pictorial description of what is exactly happening stack the plus this is the top of the stack then a is kept outside and then you get a b c then you put a b c star pop this and so on <sil=0.970> .PERIOD So <sil=0.451> ,COMMA this is how your output gets generated as soon as you see a bracket you just push everything out <sil=0.910> .PERIOD So <sil=0.482> ,COMMA this is how you convert and so <sil=0.556> ,COMMA basically this is the first thing what is it the the stack is a stack of operators <sil=0.935> .PERIOD So <sil=0.596> ,COMMA what is happening now plus and star a stack then as soon as the next plus comes you pop both plus and star just as I already told you and then you see the bracket you put the bracket on top of the stack then repeat the same process again <sil=0.960> .PERIOD So <sil=0.479> ,COMMA this is essentially how stack can be used <sil=0.972> .PERIOD Now <sil=0.434> ,COMMA let us look at the implementation of the stack and what are the operations now I am looking at a separate implementation let us say that I am not going to use the list I want to implement my own stack <sil=0.943> .PERIOD Before that what are the time complexity of these operations when look at L dot insert L dot delete L dot retrieve what will be the time complexity of all of this <sil=0.952> .PERIOD If you can say if you look at the it depends upon the kind of implementation if the implementation is a linked list does not matter for in this particular case if I am inserting at the first all these operations can also be done in order to one time even when I am using the list <sil=0.954> .PERIOD But we can do a cleaner implementation I can we can implement a stack <sil=0.971> .PERIOD So <sil=0.508> ,COMMA since I in this particular example I am using the operators I have created a stack which is I am using an array implementation here this is your static array <sil=0.921> .PERIOD So <sil=0.504> ,COMMA basically the stack size here so you would also like to have a stock stack full perhaps <sil=0.971> .PERIOD So <sil=0.586> ,COMMA I create or you resize the stack if you wanted to be transparent you can always resize the stack then you create an empty stack which is make null then you push a character onto the stack character pop returns the top most element on the stack pop deletes the element from the top of the stack empty tells you when the stack is empty <sil=0.983> .PERIOD So <sil=0.381> ,COMMA here is how the various operations can be performed and basically what is interesting is all the operands operations here if you look at this if you look at the analysis of this I want you to go through this over here make null it simply creates the top of stack to be stack size <sil=0.903> .PERIOD Then we just putting from pushing from the stack what are we doing with here in push for example <sil=0.430> ,COMMA I am making the stack size post the top of stack initially it mapped to the largest element in the array possible in the array largest index possible in the array then what do we do we decrement the top of stack and then push the element and then when we so this is again an order one operation if you notice this is an order one operation this is an order one operation then when then what are we doing if the top of stack is less than stack size is returning the top of the stack that means otherwise what is happening you performing a top operation with no elements on the stack that is the meaning of this return 0 over here then if top of stack greater than stack size return 0 again otherwise what are we doing you popping the particular element on the stack that is you are trying to pop more elements than there are otherwise if there is an element on the stack it it pops this then if stack is empty it is greater than top of stack top of stack greater than stack size then you say return greater than or equal to stack size then you say that the stack is so the time complexity of all the operations that are performed on stacks using arrays is order one now what I want you to do is I want you to go back and implement the stack I have given you a array implementation of stacks I want you to do a linked list implementation of stacks and a mission of stacks and all operations must cost only order one so I want you to go back and experiment with this now what I will do is I will just close this with some applications now I want you to do this right now when we looked at operations we only operators we only looked at left associative operators what happens if an operator associates to the right let me give you an example if I have an example like this x to the power of y to the power of z then what is this this is essentially right to the power of z whole x to the power of so I want you to think of this how do you use the stack how do you modify the infix to post fixed converter if you to work with operators which are right associative another function that I would like you to write is determine whether the parenthesis are balanced in a c program I want you to look at all these types of parenthesis I also want you to write a function that uses a stack we already talked about it to evaluate a post fixed expression <sil=0.972> .PERIOD So <sil=0.484> ,COMMA today let us continue our study of algorithms with exploration of this area of searching as most of us know searching is actually a fairly common word now associated with computer science because of search engines which are accessible to most of us <sil=0.944> .PERIOD And let us start off with the simplest of searching exercises where we want to search a data structure for a key which is given as input <sil=0.914> .PERIOD So <sil=0.601> ,COMMA in this lecture we are going to look at this issue of searching an array of course <sil=0.381> ,COMMA one could consider the problem of searching other data structures <sil=0.971> .PERIOD We will come to it as we progress <sil=0.956> .PERIOD So <sil=0.346> ,COMMA if you look at the question of searching searching is a process that is used to find the location of a given key or a target among the list of objects <sil=0.900> .PERIOD So <sil=0.598> ,COMMA when you search an array the search algorithm is expected to return the first element in the array that contains the given key <sil=0.949> .PERIOD In this picture we can see that the target key that is been given is the key 62 and it occurs in the location 4 and we want to design an algorithm which efficiently gives us the value 4 <sil=0.923> .PERIOD The approach to achieve this particular task is given to us in the coming slide <sil=0.981> .PERIOD So <sil=0.453> ,COMMA now let us explore the procedure for the search of the given key 62 which we know from this visual is at location 4 or it is in the array index with the number 4 <sil=0.990> .PERIOD And it is important to note that the indices of the arrays are from index 0 all the way up to index 11 that is there are 12 elements in this array and we want to search for a given key which is 62 <sil=0.917> .PERIOD Let us look at the basic steps that are to be done <sil=0.922> .PERIOD We start by comparing with the element which is at index 0 and the element there is 4 the comparison of 62 and 4 definitely results in the fact that they are not equal and the next comparison would be with the element at index 1 which is 21 and so on till we come to the third element for example <sil=0.600> ,COMMA where again a comparison with 62 is made with the value which is there which is 14 and after 5 iterations the element 62 is found for the first time in the array index 4 and this is considered as a discovery or a successful search where the search key has been found <sil=0.935> .PERIOD It is apt to indeed call such a search procedure a linear search because in every iteration the queried index in the array increases by 1 <sil=0.976> .PERIOD If you plot the indices of the locations which have been probed or searched you will find that this plot against iteration number that is the x axis being the iteration number and y axis be the index of the location search you will see that this plot is a straight line and it is natural to call this a linear search <sil=0.978> .PERIOD This is very important to understand why this is called linear search the array indices are searched in a linear fashion you start of a 0 then 1 then 2 and 3 and so on and so forth <sil=0.958> .PERIOD Let us consider the running time to search for a key which is 72 which as you can see does not occur in this array and there are 12 elements in this array and we do not show all the comparisons this is definitely not necessary <sil=0.987> .PERIOD As you can see all the comparisons will fail in this linear search till the index value exceeds 11 that is it becomes 12 at which point of time you have an exit condition that is you have searched the array <sil=0.948> .PERIOD Search every compared every element of the array with a given key and you have exceeded the total number of elements that are there in the array and therefore the element is not present in the array and the algorithm at this point of time can report that the given key is not present in the array <sil=0.966> .PERIOD It is very important to note that we have observed 2 of the exit conditions of this algorithm when the key is found and when the key is not found the key is not found when you have compared it with all the elements in the array and when the first time the key is found in the array the algorithm exits these are 2 exit conditions and this can be encoded <sil=0.996> .PERIOD In the following algorithm and to make a distinction with something that we are going to study we call this unordered linear search <sil=0.978> .PERIOD The algorithm is linear search and it is unordered linear search because the algorithm does not use any structure of the data elements which are present in the array for example the data elements in the array could be sorted but the description of the algorithm does not use that fact and therefore this is called an unordered linear search <sil=0.994> .PERIOD In other words unordered linear search is applicable when you are searching for a given key in an array in which you have no a priori information about the organization of the data elements <sil=0.962> .PERIOD The data elements could be in a sorted order or they could not be in an unsorted order and we have seen the conditions under which a straightforward linear search algorithm will exit and this is encoded in this pseudo code which is described <sil=0.925> .PERIOD It says that while there are some more elements in the array if the value is found at the current index then you return the index of the current location otherwise you increment the index and continue in the loop <sil=0.965> .PERIOD At the end if the value is not found at all a return value of minus 1 is given of course one has to if one programs is one has to be very careful and ensure that the array indices are between are at least as large as 0 and minus 1 is not an array index <sil=0.945> .PERIOD In a programming language like C this is definitely the case where the array indices started 0 <sil=0.977> .PERIOD So this is a snapshot of a C program which is included in the slide to to understand the complexity or the amount of time that is spent in executing this particular algorithm which is unordered linear search <sil=0.948> .PERIOD So the function that we have written here that you see here is called the search function the arguments to this function is an array which is called elements and the size of the array is given as an additional argument just for the cases of just to illustrate this example and the key the desired key that is being searched for in elements is also passed as an argument to search <sil=0.953> .PERIOD The for loop there initializes an index to 0 and searches up to the size of the array and in every iteration in every loop the element access at a particular index is compared with a given key and if a successful match is made then the index is returned as the location where the key is present <sil=0.995> .PERIOD If the key is not present in the whole array which is discovered after the loop has run for as many steps as the size of the array the control exits from the loop and a minus 1 value is returned by the search function which informs the calling function that the key has not been found <sil=0.958> .PERIOD The use of this C program mainly is for us to understand where the effort in computation is for us to be able to say something about the running time of this algorithm <sil=0.914> .PERIOD Here is the analysis if the key is at an index i then clearly i comparisons are executed one in every loop <sil=0.947> .PERIOD So in other words if the key is at index 0 then one comparison is definitely executed that is in the first loop <sil=0.923> .PERIOD In the worst case if the key is not present in the array then the loop is executed as many times as the size of the array which we have said <sil=0.914> .PERIOD Therefore the worst case running time of this algorithm is order of size of the array <sil=0.959> .PERIOD Note that we have one arithmetic operation also which increases the value of the variable called index <sil=0.961> .PERIOD The natural question now is the following <sil=0.911> .PERIOD Can we reduce the number of comparisons in the number of arithmetic operations performed by a search algorithm to find a key in a set <sil=0.953> .PERIOD And we also consider cases in which the data in the array is in a sorted order and then we see if it is possible to design better algorithms better in the sense that the number of comparisons in the number of arithmetic operations is reduced <sil=0.922> .PERIOD Here is an exercise at this point of time <sil=0.999> .PERIOD So what happens if one does a linear search in a linked list <sil=0.923> .PERIOD And what is linear search <sil=0.977> ?QUESTIONMARK In this case as you can see linear search involves incrementing the array index starting from the smallest index value to the largest possible index value in the array and searching or comparing for the presence of a key <sil=0.927> .PERIOD So it is important as an exercise to understand what linear search in a linked list is <sil=0.968> .PERIOD That is an exercise and let us move ahead and explore this question of what ordered linear searches <sil=0.913> .PERIOD In other words what is linear search when the data is ordered in the given array <sil=0.917> .PERIOD In other words the array contains the data elements in say sorted order <sil=0.996> .PERIOD Let us say in this case as you can see it is an ascending order and how much time does it take or how good an algorithm can be designed to be able to find a target key in this particular array <sil=0.905> .PERIOD And of course if the key is not found in the array we should return a value minus 1 and we make assumptions as we have been making so far that all the data items are in the range sorry all the indices are at least as large as 0 <sil=0.996> .PERIOD So one of the properties of ordered linear search is that linear search can stop immediately when it has passed the possible position of the search value <sil=0.963> .PERIOD For example if you see this slide if the queried value is the value 8 then one can perform a linear search up to the value 5 up to the value 10 which is found in the location index by the number 5 that is the element a of 5 in this array a and we find that 10 is larger than the queried value 8 and we already know that the array is sorted in ascending order <sil=0.947> .PERIOD Therefore we are not going to ever find 8 after the array index 5 because 10 is the value which is sitting in that location <sil=0.911> .PERIOD So this is one way in which we can use the fact that the array the data elements in the array are in sorted order <sil=0.925> .PERIOD So this is exactly the algorithm that is implemented observe that there is one another check which is there which is done first inside the while loop <sil=0.911> .PERIOD If the value is at the current index is greater than the value that we are searching for then the value will not be found and you can return a minus 1 immediately <sil=0.995> .PERIOD Now while this is one way of using the fact that the elements of the array are ordered in this case in ascending order and this is indeed the pseudo code for this sorry the C code for this <sil=0.901> .PERIOD Let us perform an analysis what is the worst case running time of linear search on ordered data <sil=0.987> .PERIOD In the worst case as we can construct by an example no matter what the array is if one considered the target key to be a value which is larger than the element which is present in the largest index <sil=0.948> .PERIOD In this example consider the key 18 <sil=0.913> .PERIOD 18 is larger than 17 which is the value which is present in the index 7 <sil=0.973> .PERIOD Therefore an execution of linear search to look for 18 in the array will compare 18 with each of the 8 elements which are present in the array and it is the same for loop as we have seen in the previous slide <sil=0.901> .PERIOD Therefore there is an arithmetic operation in every iteration in the worst case and there is also a comparison that happens in the worst case <sil=0.929> .PERIOD Therefore in the worst case the running time is the order of the number of elements in the array <sil=0.940> .PERIOD Therefore there is really no change in the worst case analysis <sil=0.919> .PERIOD Therefore how does one use the fact that the array is ordered to get better algorithms <sil=0.886> ?QUESTIONMARK Is it possible at all <sil=0.926> ?QUESTIONMARK That is the focus of the next search algorithm that we explore which is very well known as the binary search approach and we will see why this is called the binary search approach <sil=0.988> .PERIOD And here the most important principle is that the search key does not have to search or does not have to be compared with every element in the array <sil=0.962> .PERIOD In other words by making certain comparisons we can judiciously discard certain parts of the array from the effort that we have to put into compare the given key with the elements <sil=0.980> .PERIOD For example if the given key is 18 if we end up checking comparing 18 with the element 5 which is presented the array location 3 if 18 is present in the array then it would be present only among the indices 4 <sil=0.526> ,COMMA 5 <sil=0.490> ,COMMA 6 and 7 <sil=0.941> .PERIOD We can see that the search region is kind of reduced by half or approximately by half <sil=0.902> .PERIOD This is exactly what we are going to encode into our algorithmic procedure and let us look at one run of this algorithm <sil=0.909> .PERIOD So A is the array here and the target key is 22 and there are 12 elements in this array <sil=0.983> .PERIOD As you can see 22 is present in this array it is in the array location index by the values 6 <sil=0.930> .PERIOD So the algorithm is very simple it keeps track of 3 values which are called first <sil=0.418> ,COMMA mid and last <sil=0.930> .PERIOD First and last are extremely important they keep track of the sub array that we want to search <sil=0.910> .PERIOD The sub array that we want to search is in this example the unshaded part <sil=0.986> .PERIOD The shaded part is the part that we do not want to search <sil=0.999> .PERIOD So let us see this run of this algorithm initially first is the value 0 <sil=0.322> ,COMMA last is the largest array index which is 11 and mid is the mid point which is the first plus last divided by 2 and we take the flow of the division right in this case the flow would be 5 <sil=0.998> .PERIOD So 11 plus 0 divided by 2 is 5 and a half and we take the value 5 <sil=0.931> .PERIOD A comparison of the given key is made with the data item which is located at the array index 5 which is 21 and 22 is greater than 21 and because the array is sorted in ascending order it is clear that 22 must be present only in the array indices 6 through 11 and definitely is not present in the array indices 0 through 5 <sil=0.949> .PERIOD The array indices 0 through 5 are now shaded gray and first and last are now used to encode the first and last index values of the relevant part of this array A which is now 6 to 11 and the mid point is now you can do the calculation is 8 it is 6 plus 11 by 2 which is 17 by 2 the flow of it is 8 and the algorithm repeats this step of comparison comparing 22 with 62 which is the value in the array index 8 and of course 22 is smaller than 62 and therefore 22 cannot be present in the indices 9 <sil=0.458> ,COMMA 10 and 11 it is not present in the array index 8 as our comparison is shown therefore it can only be present among the array indices 6 and 7 that is among the array indices first and mid minus 1 this is the most important thing that it is present in the array indices first and mid minus 1 in this case and as you can see now first and last have become 6 and 7 respectively and mid is now 6 22 is successfully found and the algorithm terminates reporting the index of the location where 22 has been found which in this case is 6 <sil=0.915> .PERIOD Let us see the condition under which this algorithm exits and reports that the key is not present in this case the target value is 11 and as you can see 11 is not present in the array and again the gray shaded part is the irrelevant part of the array for the search algorithm and the unshaded part is the relevant part first and last as usual end code have do encode the relevant part of the array keeps track of the indices initially it is 0 and 11 a comparison is made with mid 11 is smaller than 21 therefore if 11 is to be found it can be found only to the left of the index 5 that is among the array indices 0 to 4 which is now captured by the modified value of last which has now become 4 mid is now recalculated in the next iteration to be 2 a comparison is made with the value which is sitting in the array index 2 which is 8 <sil=0.940> .PERIOD 8 indeed is not larger than 11 therefore 11 has to be to the right of 8 if it is at all present in the array therefore now in this case 11 should be present if at all in the present if at all in the array indices last and mid minus 1 sorry last and mid plus 1 so mid was the value 2 and now observe that the value of first is now 3 that is mid plus 1 and last as you can see that in one more query it is discovered that the search key is 11 is not present in the array and at termination condition you can see that first has become larger than last and this is the termination condition for the algorithm <sil=0.965> .PERIOD So this is very important the termination condition for the algorithm is when first exceeds the value of last at which point of time you can report that the key has not been found and the key is found the value of mid the location where the key has been found will be as a return value of the algorithm these are the two invariants which precisely map the presence or absence of a key from the array <sil=0.984> .PERIOD So in generic terms binary search is a paradigm of solving a problem by what is called the divide and conquer strategy in this divide and conquer strategy the search space in this case the array is repeatedly divided into smaller and smaller portions with the guarantee that the search value would be present in the region that is being searched at every level or in every iteration as we have seen in with every comparison the size of the array has been reduced by a factor of 2 in other words the array size becomes smaller and smaller by is halved in every iteration and this kind of gives us a clear handle on an understanding of the binary search algorithm <sil=0.922> .PERIOD Let us see the pseudo code and the pseudo code is very important because it tells us how the first mid and last have to be modified <sil=0.950> .PERIOD So initially first and last have said to be the bound I said to take the values of the boundary of the array the mid value is calculated the search value or the key is compared with the element in the mid value if it is indeed present the mid element is returned as the value if it is not present a comparison is made whether the value was if indeed the mid value does not contain but first is more than last <sil=0.977> .PERIOD Then the mid value does not contain but first is more than last then the value is returned first is at least as large as last then the return value is minus 1 saying that the key has not been found otherwise if the value is smaller than that of the middle element last is now made to take the index which is mid element position minus 1 and if value is larger and if value is larger then first is taken to be the mid element plus 1 that is in other words one would visualize the search to be moving either to the left or to the right of the mid point in the array provided the key is not found <sil=0.904> .PERIOD Here is the pseudo code for this function which is binary search it is actually cut and paste from a C program <sil=0.962> .PERIOD Now the arguments are as usual element an array which contains a sorted set of elements the size of the array is given and key is also given as part of the input and first is taken to be the value 0 and last is taken to be the value size minus 1 and you can check the integer division which is middle takes the value of first plus last divided by 2 and whatever comparisons we have discussed so far are made <sil=0.986> .PERIOD The value of this particular piece of code is that it gives us an idea as to the number of operations that are performed in a run of this particular algorithm <sil=0.978> .PERIOD So <sil=0.475> ,COMMA let us just go through this example of binary search in this case where the array has the elements 8 elements in a sending order and the search key is 14 is present in the array index 6 and one can see the conditions under which the algorithm exits <sil=0.940> .PERIOD So <sil=0.545> ,COMMA the first value that is searched is the array index 3 and array index by the value 3 which is 0 plus 7 divided by 2 and the flow of it gives you the value 3 and the search value is 14 and clearly 14 is to the right of 5 and first is the one whose value is updated to take the value 4 last remains unchanged in the next iteration mid becomes 5 7 plus 4 divided by 2 and this search succeeds by computing the mid value 6 <sil=0.971> .PERIOD As you can see the order of the elements in the array guides the choice of the array locations which are probed by the algorithm <sil=0.953> .PERIOD So <sil=0.339> ,COMMA here is an unsuccessful binary search and the unsuccessful binary search can terminate in two conditions where first and last are the same and the middle value does not contain the search key <sil=0.989> .PERIOD This is very important there are three cases here <sil=0.968> .PERIOD The first case we have already seen which is a successful search here is an unsuccessful search where the exit condition is because the key is not present and first and last have the same value here 8 is a search key and it is clear that the sequence of searches finally queries the element 4 which has the value 7 but first and last take the same value at this point of time and because 7 is not equal to 8 and there is nothing else to be searched the search returns a failure <sil=0.900> .PERIOD Here is the case where first exceeds the value last in the next iteration and the key is not present <sil=0.929> .PERIOD So <sil=0.641> ,COMMA this can also be checked the focus now is to analyze binary search which is the algorithm that whose analysis we postponed to the end <sil=0.911> .PERIOD Let us look at the analysis of binary search where our goal is to estimate the total number of comparisons of the binary search algorithm <sil=0.955> .PERIOD So <sil=0.593> ,COMMA let us write the formula for binary search by T of n where T stands for time and N stands for the array size <sil=0.976> .PERIOD For the moment let us assume that N is a power of 2 <sil=0.935> .PERIOD The simplifies the analysis and therefore we use N to be a power of 2 <sil=0.980> .PERIOD Let us look at the case when T of n is a power of 2 <sil=0.991> .PERIOD Let us look at the case when T of n is a power of 2 and the is a power of 2 <sil=0.927> .PERIOD The simplifies the analysis and therefore we use N to be a power of 2 <sil=0.985> .PERIOD Let us look at the case when T of n for N is equal to 2 <sil=0.955> .PERIOD So <sil=0.561> ,COMMA let us just focus on the array it just has two elements and let us assume that the arrayments are 1 and 3 in sorted order <sil=0.916> .PERIOD And let us count the number of steps that it takes to check for a query element <sil=0.913> .PERIOD So <sil=0.357> ,COMMA this is the array index with 0 <sil=0.900> .PERIOD This is the array index by 1 and it is key to the array and we have that a query element can be resolved for whether it is present or not in the array in two comparisons in a maximum of two comparisons <sil=0.960> .PERIOD So <sil=0.467> ,COMMA for example what would happen is that if the search is for a value half then the array index which we compared is half would be compared with 1 <sil=0.942> .PERIOD Half is compared with 1 and then the first mid and last are updated and half will not be found <sil=0.999> .PERIOD So <sil=0.414> ,COMMA that takes only one comparison <sil=0.910> .PERIOD If the value is 3 then in two comparisons it would be found and if the value is larger than 3 then again the value would be found it would be found that the value is absent in at most two comparisons <sil=0.925> .PERIOD Therefore <sil=0.629> ,COMMA T of n for n is equal to 2 is written as T of 2 which is just two comparisons <sil=0.996> .PERIOD So <sil=0.624> ,COMMA let us consider the case when n is a power of 2 and let us look at the array indices <sil=0.954> .PERIOD The array indices are a of 0 that is sorry the index the indices are 0 2 power k minus 1 and the value of the array index that is taken to be relevant is the value 2 power k minus 1 divided by 2 which will be 2 power k minus 1 minus 1 that is the floor of this is 2 power k minus 1 minus 1 which would be the value that would be compared <sil=0.968> .PERIOD Therefore <sil=0.582> ,COMMA as you can see after the first comparison the relevant part of the array would be the range a of 0 to a of 2 power k minus 1 or sorry a of 2 power k minus 1 <sil=0.963> .PERIOD 1 minus 1 or a of 2 power k minus 1 to a of 2 power k minus 1 there are only two possibilities for the rest of the search space after one comparison <sil=0.908> .PERIOD So <sil=0.627> ,COMMA after the first comparison with a given key these are the two range of values as you can see that the range of values is now down by a factor of 2 <sil=0.978> .PERIOD We can write this we can include this using the following recurrence which is T of n is T of n by 2 the time taken to search for the key in an array or size n by 2 plus 1 and the boundary condition is given by T of 2 is equal to 2 and the solution for this recurrence is T of n is order of log n indeed it is log n to the base 2 but the constants in the order take care of it <sil=0.927> .PERIOD So <sil=0.445> ,COMMA this is the analysis of binary search and observe that we have used the fact that the array is sorted to come up with an algorithm which just uses order of log n comparisons as opposed to ordered search which in the worst case was using linear number of comparisons or order of the size of the array number of comparisons and in the case when the array is unordered we were already using a linear number of comparisons which are unavoidable <sil=0.978> .PERIOD So <sil=0.536> ,COMMA with this we stop this discussion on search and we will continue in the next lecture <sil=0.925> .PERIOD Welcome to lecture 2 of this online course on programming <sil=0.983> .PERIOD In today's lecture in the first two modules we will look at input statements and output statements <sil=0.605> ,COMMA compound statements and we will also look at this category of statements called the selection statements <sil=0.927> .PERIOD So we have been looking at print of an scan of for a while and I have not really explained what print of an scan of are about yet <sil=0.961> .PERIOD But in this lecture we will look at what is the syntax of print of and what are the different things that go into the format itself <sil=0.911> .PERIOD So print of an is general form has a format string followed by a list of comma separated variable names <sil=0.942> .PERIOD So the syntax is highlighted at the top <sil=0.988> .PERIOD So you have format string comma separated list of variables 1 to n <sil=0.933> .PERIOD So the format string is enclosed in double quotes <sil=0.983> .PERIOD So we have seen that in several examples before I will also show you examples later <sil=0.928> .PERIOD And the format string essentially indicates how many variables should it be printing on the screen <sil=0.937> .PERIOD What are the types of the variables <sil=0.996> ?QUESTIONMARK How many columns to use for printing them <sil=0.940> ?QUESTIONMARK So numbers could occupy different number of columns and so on <sil=0.918> .PERIOD So we could have right justification or left justification and so on <sil=0.953> .PERIOD So we can specify the number of columns required even though that is not something that you would see in this lecture in detail <sil=0.904> .PERIOD And if you want any character string to be printed <sil=0.977> .PERIOD For instance the very first program that we wrote we did not really have any variables to be printed <sil=0.963> .PERIOD We just said print of hollow world <sil=0.958> .PERIOD So let us look at this example <sil=0.951> .PERIOD Let us say I have int x and float y and let us say x equals 20 and y is minus 16 point something <sil=0.933> .PERIOD If we have this print of statement value x equals percentage d and value y equals percentage f <sil=0.324> ,COMMA backslash n comma x comma y <sil=0.944> .PERIOD So that is a print of statement <sil=0.960> .PERIOD So as you can see the very first part is the format string which is enclosed within double codes and then there is a comma separated list of variables <sil=0.995> .PERIOD In this case it is a comma separated list of two variables namely x and y <sil=0.951> .PERIOD And when you look at this one there is string value space x symbol equal to and then there is something called percentage d and then there is some other string up to here percentage f backslash n <sil=0.956> .PERIOD So percentage d says that whatever value it is or variable it is going to get it should print it as integer and percentage f indicates that whatever it is going to get as a variable it is supposed to be printed as a real value <sil=0.980> .PERIOD So this percentage d is the very first percentage symbol that you see followed by some letter d <sil=0.956> .PERIOD So this percentage d associates itself with the first variable x and the second one percentage f here associated itself with y here and so since percentage d is for integer x is printed as an integer and since percentage f is for real y is printed as real <sil=0.926> .PERIOD So this is the basic example there are other specifiers but more often they are not you will need only d f and possibly a g <sil=0.971> .PERIOD So the output for this would be value x equals 20 and value y equals minus 16 <sil=0.927> .PERIOD 789 <sil=0.901> .PERIOD So the idea behind this is that if you have this strings here so this value appears as it is the space appears as it is x equals to appears as it is only this percentage d is a place holder <sil=1.000> .PERIOD So it is holding its place for this variable to be printed in its appropriate format <sil=0.924> .PERIOD So let us look at some of the print of statements we have used before print f enter the three numbers a <sil=0.469> ,COMMA b and c <sil=0.930> .PERIOD So this is something that we have used before <sil=0.941> .PERIOD So this is just a format specification there is nothing to be printed here it will print the test text as it is <sil=0.958> .PERIOD Then look at this other statement print f the product is percentage d x character 2 plus percentage d x plus percentage d backslash n <sil=0.930> .PERIOD So this is something that we saw in the polynomial multiplication example in the previous lecture <sil=0.985> .PERIOD So now this percentage d associated itself with p 2 this one with p 1 and the third one with p naught <sil=0.994> .PERIOD So the output that we got last time was 3 x squared plus 10 x plus 4 <sil=0.952> .PERIOD So you can see that percentage d was place holding for 3 and percentage d was place holding for 10 here and this one for 4 and everything else gets printed as it is <sil=0.935> .PERIOD So backslash n as I mentioned earlier it is essentially is printing a new line <sil=0.937> .PERIOD So it will print this statement the product is this and the any other print that you give will go to the next line <sil=0.997> .PERIOD What about the input statements <sil=0.949> ?QUESTIONMARK So in the input statement let us look at scan f <sil=0.924> .PERIOD So scan f is also of the similar format you have format string and you have a comma separated list of variables that you want to be scanning <sil=0.919> .PERIOD So the format string as before is enclosed in double quotes and the format string indicates how many variables to expect as it was in print f <sil=0.952> .PERIOD Type of the data items to be stored in var 1 <sil=0.321> ,COMMA var 2 and so on <sil=0.913> .PERIOD So it is very similar to print f except that you see the symbol ampersand in front of all the variables <sil=0.992> .PERIOD So you have ampersand var 1 <sil=0.309> ,COMMA ampersand var 2 <sil=0.626> ,COMMA ampersand var n and so on <sil=0.917> .PERIOD So the symbol ampersand is used to specify the memory address where the value is to be stored <sil=0.920> .PERIOD So remember var 1 whenever you use it directly in your program it goes to the memory location and gets the value but in this case scan f is supposed to take the value from the user and put it in the memory location called var 1 <sil=0.922> .PERIOD So to do that you put ampersand of var 1 we will look at this in more detail later what you are essentially passing on to scan f is a pointer to var 1 by prefixing an ampersand before it <sil=0.988> .PERIOD So ampersand var 1 is a pointer to var 1 and it says this is the memory address for var 1 instead of calling it by name you calling it you now get the memory address and whatever the user inputs will go to that memory address <sil=0.991> .PERIOD So we saw this example in the previous lecture also when scan f happened we went to the specific location and we got the values for a <sil=0.447> ,COMMA b <sil=0.364> ,COMMA c <sil=0.956> ,COMMA d and so on <sil=0.936> .PERIOD So let us look at the other example we have seen before scan f percent hd <sil=0.559> ,COMMA percentage d <sil=0.549> ,COMMA percentage d <sil=0.478> ,COMMA ampersand a <sil=0.420> ,COMMA ampersand b <sil=0.581> ,COMMA ampersand c <sil=0.985> .PERIOD So again the order in which things are done is left to write for the format specifiers as well as left to write for the variables here <sil=0.969> .PERIOD So it will store it will expect 3 integers from the user and put these 3 in locations a <sil=0.345> ,COMMA b and c respectively <sil=0.924> .PERIOD Finally if we have this kind of an example where percentage d <sil=0.331> ,COMMA percentage f <sil=0.607> ,COMMA ampersand marks <sil=0.513> ,COMMA ampersand average marks <sil=0.999> .PERIOD So I am assuming that marks is an integer and average marks is a floating point value <sil=0.972> .PERIOD So if the user keys in 16 let us say some couple of spaces and 14 <sil=0.912> .PERIOD 75 <sil=0.974> .PERIOD First the scanner will come and look at it from the left side and keep scanning till it finds an integer <sil=0.972> .PERIOD In this case 1 <sil=0.419> ,COMMA 6 is an integer and after that is a white space white space is not a part of an integer <sil=0.955> .PERIOD So it will stop scanning <sil=0.908> .PERIOD So there is a number 16 which is a valid integer that goes into the very first variable namely marks <sil=0.902> .PERIOD Then the format specifier says percentage f which means the scanner should look for a floating point number and when it looks at these spaces 1 <sil=0.367> ,COMMA 2 <sil=0.320> ,COMMA 3 <sil=0.400> ,COMMA 4 spaces the space is not a part of a number <sil=0.975> .PERIOD Therefore it keeps looking further <sil=0.916> .PERIOD It sees number 1 <sil=0.320> ,COMMA 4 but there is a dot and followed by 75 <sil=0.948> .PERIOD After that there is no more input which means the input ends at 1 <sil=0.487> ,COMMA 4 <sil=0.326> .PERIOD 75 which is 14 <sil=0.963> .PERIOD 75 <sil=0.986> .PERIOD So 14 <sil=0.910> .PERIOD 75 would go as the average marks <sil=0.953> .PERIOD So usually space <sil=0.581> ,COMMA backslash and so on are not specified in the format specifier <sil=0.908> .PERIOD In the format specifier which we put within double codes you usually do not put space <sil=0.338> ,COMMA command and other things <sil=0.947> .PERIOD In print if it is useful to print something on the screen in scanf you just want the data from the user and the user may enter space and so on scanf automatically ignores it <sil=0.937> .PERIOD So usually you do not put it as part of the format specifier <sil=0.910> .PERIOD So the scanf skips over spaces if necessary to get the next input <sil=0.926> .PERIOD There are several other formats specifiers that you can use but the most commonly needed are percentage d and percentage f <sil=0.984> .PERIOD The other one that might come useful is percentage c where c stands for character <sil=0.935> .PERIOD So percentage d is decimal percentage f is float percentage c is character <sil=0.999> .PERIOD There is also an exponent form for floating point numbers which goes by percentage e <sil=0.963> .PERIOD For example 1 <sil=0.994> .PERIOD 523 e2 means 1 <sil=0.950> .PERIOD 523 into 10 square or 10 power 2 and which is 152 <sil=0.916> .PERIOD 3 <sil=0.311> .PERIOD So there are also several modifications to percentage f and percentage d which are possible which you can use in printf <sil=0.937> .PERIOD However they only control how much space the number takes on the screen it does not really control how the values itself <sil=0.969> .PERIOD So if you say percentage d it is an integer <sil=0.943> .PERIOD So it will get printed as an integer but depending on percentage followed by a number and a d will take as many spaces as you specify the number <sil=0.938> .PERIOD This is useful in justification and so on <sil=0.962> .PERIOD So I am not going to cover how to have a fixed width of numbers and so on <sil=0.936> .PERIOD So that is not that is beyond the scope of this lecture <sil=0.927> .PERIOD So I suggest that you go and read up a book on c to get more details <sil=0.948> .PERIOD Let us move on to statements <sil=0.970> .PERIOD So we know that a program is usually a declaration followed by one or more statements and these statements could be an assignment statement or function calls <sil=0.947> .PERIOD We have already seen these two kinds <sil=0.998> .PERIOD So assignment statements we have seen them in the polynomial example and function calls printf and scan of our functions we have seen them also <sil=0.930> .PERIOD We saw selection statement also when we looked at maximum of 3 numbers and so on <sil=0.954> .PERIOD One thing that we have not seen is repetitive statements <sil=0.900> .PERIOD So statements could be a 4 types assignment function calls selection statement and repetitive statements <sil=0.973> .PERIOD The first two are of a category and the second two are of another category which is what I want to talk about in the next few slides <sil=0.951> .PERIOD So the first category we call simple statements are those statements that are expressions or function calls <sil=0.983> .PERIOD So for example if I have x equals 2 <sil=0.493> ,COMMA x equals 2 is a single statement you take the value to assign it to x <sil=0.981> .PERIOD So it is an assignment statement <sil=0.972> .PERIOD Similarly x equals 2 plus 8 it computes 2 plus 8 on the right hand side gets the value 10 puts it to the left hand side <sil=0.936> .PERIOD It is a simple statement because it is doing only an assignment <sil=0.922> .PERIOD Then there is a function called printf hollow world <sil=0.992> .PERIOD So it is a simple function call and finally sign of x <sil=0.989> .PERIOD So x is passed as a parameter to a function called sign <sil=0.976> .PERIOD Sign computes that and returns the value which is placed in y <sil=0.907> .PERIOD So these are simple statements because the right hand side evaluates a value and the value is put into the variable on the left hand side <sil=0.955> .PERIOD So simple statements are usually terminated by a semicolon and in this case you can see that all these examples <sil=0.367> ,COMMA all these 4 different simple statements have a semicolon at the end <sil=0.946> .PERIOD So anywhere where you evaluate an expression on and so on will all be simple statements <sil=0.922> .PERIOD Anything that you call anywhere where you call functions will all be simple statements as well <sil=0.998> .PERIOD So the other category is what is called compound statements <sil=0.912> .PERIOD A compound statement is a group of declarations and statements collected together <sil=0.920> .PERIOD So a compound statement contains one or more set of simple statements and it may also have declarations on their own <sil=0.967> .PERIOD So for example <sil=0.613> ,COMMA a single simple statement is also a compound statement because compound statement contains one or more simple statements <sil=0.987> .PERIOD So the basic idea behind compound statement is that it forms one logical unit and to say that this is one logical unit we surround the statements that are grouped together using braces <sil=0.948> .PERIOD So sometimes these set of statements that are within the braces are also called a block <sil=0.987> .PERIOD So let us see these examples <sil=0.990> .PERIOD So we have seen something like this <sil=0.932> .PERIOD Let us say I want to calculate the maximum of 2 numbers <sil=0.909> .PERIOD So I have a small program segment which does that <sil=0.973> .PERIOD So you have int max <sil=0.935> .PERIOD If a is greater than b max is a and print of a is greater than b <sil=0.956> .PERIOD Else max is b and print of b is greater than a <sil=0.927> .PERIOD So we are not only printing whether a is greater than b or b is greater than a <sil=0.975> .PERIOD We are also storing the maximum value in this variable called max <sil=0.916> .PERIOD So if you notice you have braces left and right braces for if a greater than b and we have left and right braces for the else clause also and this is one logical unit <sil=0.945> .PERIOD So if a is greater than b the maximum is indeed a and you can also print <sil=0.924> .PERIOD So this is one logical unit <sil=0.901> .PERIOD So I highlight it in orange here <sil=0.988> .PERIOD However the compiler only will look at this left and right bracket <sil=0.974> .PERIOD Anything within this left and right brace is a block and this is treated as everything that should go under the true case <sil=0.903> .PERIOD If a is greater than b is false then max is equal to b and you can print that b is greater than a <sil=0.976> .PERIOD So in fact b is greater than or equal to a in this case <sil=0.900> .PERIOD It is not just greater it is also greater than or equal to <sil=0.902> .PERIOD So this is one logical unit and the braces say that this is one logical unit <sil=0.985> .PERIOD So this is a compound statement and this whole if statement by itself is a compound statement because if statement so this is if followed by an expression followed by a block else followed by a block <sil=0.959> .PERIOD This whole thing is also one logical unit <sil=0.946> .PERIOD Therefore it is also a compound statement <sil=0.942> .PERIOD So a compound statement may have one or more compound statements inside them and it may also have simple statements inside them <sil=0.927> .PERIOD A simple statement is a one line expression or a function call and so on <sil=0.907> .PERIOD So compound statements in turn can come in two varieties <sil=0.988> .PERIOD They can either be conditional statements namely if the null statements or it could be switch statements <sil=0.994> .PERIOD The other variety is also called the repetitive statements or loops I refer to them earlier as repetitive statements <sil=0.929> .PERIOD So there are three varieties of loops available in C namely for loop while loop and do while loop <sil=0.933> .PERIOD So we will look at more details in the next few slides about if then else statements and switch statements and later in the lecture we will see things about loop statements <sil=0.998> .PERIOD So far in this module what we have done is we looked at I O statements and we looked at two categories namely simple and compound statements <sil=0.999> .PERIOD And simple statements we already know they involve arithmetic expressions or a function calls on the right side and variable assignment on the left side <sil=0.942> .PERIOD Compound statements is a collection of either compound statements or simple statements <sil=0.916> .PERIOD Hello all <sil=0.453> ,COMMA this small demo of the debugging environment <sil=0.435> ,COMMA I want to show you some specific features in debugging and how things work with debuggers <sil=0.988> .PERIOD So <sil=0.582> ,COMMA we will go back to this program that we were looking at prime numbers <sil=0.904> .PERIOD Just to recollect <sil=0.623> ,COMMA we declared that 2 and 3 will be prime numbers and for the other prime numbers <sil=0.625> ,COMMA we will actually go and evaluate based on this small logic that we discussed <sil=0.933> .PERIOD If some for a number p <sil=0.311> ,COMMA we are going to check against all the prime numbers that are less than it <sil=0.906> .PERIOD And if it is even divisible by one of them <sil=0.447> ,COMMA we will declare that it is composite <sil=0.990> .PERIOD Otherwise <sil=0.395> ,COMMA at the end of checking all the prime numbers <sil=0.334> ,COMMA if the number is still not divisible <sil=0.374> ,COMMA then we will say that p is prime <sil=0.937> .PERIOD So <sil=0.349> ,COMMA let us switch to the programming environment <sil=0.936> .PERIOD We saw this program earlier and the only modification that we have is <sil=0.409> ,COMMA I have defined N to be 10 <sil=0.395> ,COMMA so that we can quickly see what is happening <sil=0.940> .PERIOD So <sil=0.559> ,COMMA one aspect of this debugging is essentially that <sil=0.428> ,COMMA if there is a small error in the program <sil=0.362> ,COMMA how do we find it out <sil=0.942> ?QUESTIONMARK So <sil=0.479> ,COMMA I can always go and run the program multiple times or I can put print of statements in multiple locations and track <sil=0.429> ,COMMA but that is not the best thing to do <sil=0.971> .PERIOD So <sil=0.554> ,COMMA if the programs get very large <sil=0.648> ,COMMA then the print of can be very annoying <sil=0.976> .PERIOD So <sil=0.408> ,COMMA instead <sil=0.424> ,COMMA many ideas including DevC++ give a very nice mechanism for debugging and that is what we are going to do <sil=0.965> .PERIOD So <sil=0.507> ,COMMA there are 2 things that we are going to do when we have a debugger <sil=0.910> .PERIOD The first thing we are going to do is <sil=0.509> ,COMMA set up what are called breakpoints <sil=0.921> .PERIOD So <sil=0.648> ,COMMA generally what happens is your program starts executing at line number 6 <sil=0.344> ,COMMA let us say <sil=0.332> ,COMMA and it executes to line number 27 <sil=0.988> .PERIOD And you do not get to see any of it <sil=0.304> ,COMMA you only see the program running and you get to see the final result <sil=0.983> .PERIOD But what if I want to see <sil=0.488> ,COMMA what is the effect of each of these lines <sil=0.893> ?QUESTIONMARK So <sil=0.615> ,COMMA I will do single stepping and I can take one line at a time and show the effect of each of these lines <sil=0.977> .PERIOD And I will also set up something called a break point <sil=0.302> ,COMMA so that I can see how things should run up to the break point <sil=0.950> .PERIOD So <sil=0.545> ,COMMA let me illustrate those <sil=0.949> .PERIOD So <sil=0.646> ,COMMA what I am going to do is <sil=0.473> ,COMMA I am going to set up a break point at line number 8 by pressing on key F 4 <sil=0.957> .PERIOD The moment I press that <sil=0.487> ,COMMA you can see that the background of that line changes to red <sil=0.909> .PERIOD And there is also a small tick mark on line number 8 <sil=0.907> .PERIOD I am also going to set up a break point on line number 12 <sil=0.989> .PERIOD So <sil=0.548> ,COMMA I have set it up for break points at 8 and 12 <sil=0.954> .PERIOD So <sil=0.532> ,COMMA what is going to happen is when the program is run <sil=0.585> ,COMMA it will not run all the way <sil=0.960> .PERIOD First <sil=0.485> ,COMMA it will break just before line number 8 <sil=0.906> .PERIOD And after that <sil=0.348> ,COMMA if I continue running the program <sil=0.331> ,COMMA it will break at line number 12 and so on <sil=0.995> .PERIOD So <sil=0.407> ,COMMA remember line number 12 is inside the loop <sil=0.912> .PERIOD So <sil=0.576> ,COMMA it will break every time <sil=0.608> ,COMMA it will give us a chance to inspect values at line number 12 <sil=0.954> .PERIOD So <sil=0.599> ,COMMA to actually look at the values <sil=0.549> ,COMMA we need a few other things <sil=0.983> .PERIOD So <sil=0.377> ,COMMA I am going to click on debug <sil=0.391> ,COMMA so that the debugging is turned on and I am going to add watch on a few variables <sil=0.988> .PERIOD So <sil=0.538> ,COMMA what are the variables of interest <sil=0.940> ?QUESTIONMARK I want to see what prime says and if you see that right <sil=0.954> .PERIOD So <sil=0.579> ,COMMA primes seems to have all these values <sil=0.528> ,COMMA which we really do not want and this is the first thing that you should be observing <sil=0.988> .PERIOD So <sil=0.324> ,COMMA there are values of primes and since primes is uninitialized <sil=0.421> ,COMMA remember we are in we have still not executed the program <sil=0.376> ,COMMA we are just in line number 8 <sil=0.993> .PERIOD So <sil=0.407> ,COMMA we do not know what values must be there for primes <sil=0.999> .PERIOD Let us also watch p <sil=0.576> ,COMMA which is the value that we want <sil=0.980> .PERIOD We watch i <sil=0.354> ,COMMA let us watch prime index and finally <sil=0.458> ,COMMA let us also watch this prime <sil=0.996> .PERIOD So <sil=0.328> ,COMMA I want to show how these things change as we run in the program <sil=0.926> .PERIOD So <sil=0.499> ,COMMA watch the left side <sil=0.449> ,COMMA you will see all these variables that are there and let us see what happens now <sil=0.944> .PERIOD So <sil=0.316> ,COMMA as of now <sil=0.589> ,COMMA I am going to do f 7 <sil=0.434> ,COMMA which is single step <sil=0.925> .PERIOD So <sil=0.539> ,COMMA it will go one line at a time <sil=0.972> .PERIOD So <sil=0.364> ,COMMA primes of 0 is now 2 and primes of 1 is 3 <sil=0.930> .PERIOD So <sil=0.575> ,COMMA as I keep pressing f 7 <sil=0.359> ,COMMA it goes one line at a time and whatever line is to be executed will be highlighted <sil=0.954> .PERIOD So <sil=0.428> ,COMMA as of now line number 8 and 9 have executed <sil=0.983> .PERIOD So <sil=0.494> ,COMMA 2 and 3 went to the first entries in primes <sil=0.916> .PERIOD So <sil=0.397> ,COMMA now <sil=0.590> ,COMMA I go to line number 10 <sil=0.646> ,COMMA I executed <sil=0.945> .PERIOD So <sil=0.620> ,COMMA prime index became 2 <sil=0.929> .PERIOD So <sil=0.568> ,COMMA I am going to start filling up prime numbers from location 2 onwards <sil=0.926> .PERIOD So <sil=0.313> ,COMMA as of now <sil=0.538> ,COMMA 2 and 3 are correct <sil=0.505> ,COMMA I am going to start filling up from location 2 onwards <sil=0.929> .PERIOD And what is the value now <sil=0.931> ?QUESTIONMARK p is 5 <sil=0.401> ,COMMA I am going to check whether 5 is prime or not <sil=0.919> .PERIOD I assume that it is prime to start with <sil=0.905> .PERIOD So <sil=0.532> ,COMMA now the whole program is ready for running <sil=0.991> .PERIOD We have various things <sil=0.912> .PERIOD 2 and 3 are already in place <sil=0.980> .PERIOD I know p equal to 5 <sil=0.595> ,COMMA I have to start checking from 1 onwards and see if it is divisible or not <sil=0.936> .PERIOD And if so <sil=0.498> ,COMMA we are going to see if this is prime changes <sil=0.910> .PERIOD So <sil=0.524> ,COMMA let us start moving <sil=0.914> .PERIOD I is 1 <sil=0.916> .PERIOD So <sil=0.527> ,COMMA the first <sil=0.567> ,COMMA so I am at line number 15 <sil=0.577> ,COMMA p at this point is 5 <sil=0.561> ,COMMA primes of I <sil=0.952> .PERIOD So <sil=0.516> ,COMMA primes of 1 is 3 <sil=0.938> .PERIOD So <sil=0.645> ,COMMA this line is checking if 5 percent H 3 is 0 or not <sil=0.944> .PERIOD It is not 0 <sil=0.924> .PERIOD So <sil=0.488> ,COMMA this line will not execute <sil=0.950> .PERIOD And let us look at prime index <sil=0.573> ,COMMA prime index became 2 and I is also 2 <sil=0.994> .PERIOD So <sil=0.510> ,COMMA you go and check if this is prime or not <sil=0.995> .PERIOD The flag has not changed <sil=0.951> .PERIOD So <sil=0.497> ,COMMA 5 is the prime number <sil=0.927> .PERIOD You record that <sil=0.972> .PERIOD So <sil=0.611> ,COMMA if once I finish line number 19 <sil=0.363> ,COMMA you will see that this location <sil=0.455> ,COMMA this 53 will change to 5 <sil=0.990> .PERIOD You can see that now <sil=0.940> .PERIOD And prime index is 3 <sil=0.985> .PERIOD So <sil=0.320> ,COMMA now we are ready to see whether the next odd number which is 7 is prime or not <sil=0.950> .PERIOD So <sil=0.488> ,COMMA let us continue now <sil=0.971> .PERIOD So <sil=0.391> ,COMMA we are ready to check whether 7 is prime or not <sil=0.930> .PERIOD We go back and assert 7 is prime <sil=0.965> .PERIOD And I am going to check from 1 to I less than prime index <sil=0.978> .PERIOD So <sil=0.594> ,COMMA prime index is 3 <sil=0.920> .PERIOD So <sil=0.437> ,COMMA I am going to check 7 against 3 and 5 <sil=0.911> .PERIOD So <sil=0.451> ,COMMA first you check 7 against 3 <sil=0.906> .PERIOD It is not 0 <sil=0.957> .PERIOD Then you check 7 against 5 <sil=0.973> .PERIOD It is also not 0 <sil=0.936> .PERIOD So <sil=0.568> ,COMMA its prime does not change <sil=0.994> .PERIOD So <sil=0.322> ,COMMA its prime remains at 1 <sil=0.926> .PERIOD So <sil=0.516> ,COMMA primes of prime index is you can record 7 <sil=0.932> .PERIOD So <sil=0.490> ,COMMA you will see a change here <sil=0.983> .PERIOD It changes to 7 <sil=0.984> .PERIOD And prime index will change to 4 <sil=0.983> .PERIOD So <sil=0.639> ,COMMA we are trying to find out the next prime number <sil=0.902> .PERIOD Then now we are checking 9 <sil=0.964> .PERIOD We assume that 9 is prime to start with <sil=0.905> .PERIOD Then I am going to check against all the numbers from 2 to 7 <sil=0.939> .PERIOD So <sil=0.334> ,COMMA sorry 3 to 7 <sil=0.913> .PERIOD I am going to check against 9 <sil=0.959> .PERIOD If p percentage primes I equal to 0 <sil=0.998> .PERIOD So <sil=0.318> ,COMMA 3 <sil=0.316> .PERIOD 9 percentage 3 is actually 0 <sil=0.956> .PERIOD So <sil=0.501> ,COMMA this is the first time this line is executed <sil=0.924> .PERIOD So <sil=0.563> ,COMMA its prime becomes 0 <sil=0.930> .PERIOD As I said earlier <sil=0.461> ,COMMA we are checking still against 5 and 7 <sil=0.924> .PERIOD So <sil=0.474> ,COMMA we check against 5 <sil=0.911> .PERIOD Then we check against 7 <sil=0.994> .PERIOD And the key thing is this prime is 0 at this point <sil=0.932> .PERIOD So <sil=0.629> ,COMMA since this prime is 0 <sil=0.639> ,COMMA this block of code from 18 to 20 will not execute <sil=0.932> .PERIOD And we are going to now go and check the next number <sil=0.933> .PERIOD So <sil=0.359> ,COMMA p is 11 <sil=0.918> .PERIOD So <sil=0.381> ,COMMA 11 is actually greater than 10 <sil=0.976> .PERIOD So <sil=0.398> ,COMMA at this point you exit out of this loop from 12 to 22 <sil=0.935> .PERIOD We are now ready to print all the prime numbers <sil=0.999> .PERIOD So <sil=0.508> ,COMMA at this point <sil=0.411> ,COMMA you can see that prime index is 4 <sil=0.448> ,COMMA which means the first 4 entries starting from 0th location till third location have valid prime numbers <sil=0.990> .PERIOD So <sil=0.550> ,COMMA that is what we are going to do <sil=0.961> .PERIOD We can check and print the prime numbers <sil=0.996> .PERIOD So <sil=0.307> ,COMMA print 2 <sil=0.642> ,COMMA print 3 <sil=0.387> ,COMMA print 5 <sil=0.423> ,COMMA print 7 and we are done <sil=0.930> .PERIOD So <sil=0.518> ,COMMA at this point we are done <sil=0.920> .PERIOD So <sil=0.363> ,COMMA if you go and look at this <sil=0.440> ,COMMA we already see 2 <sil=0.540> ,COMMA 3 <sil=0.300> ,COMMA 5 and 7 printed <sil=0.997> .PERIOD And once this is all over <sil=0.557> ,COMMA you can stop the execution <sil=0.902> .PERIOD So <sil=0.324> ,COMMA this program is actually correct <sil=0.925> .PERIOD So <sil=0.557> ,COMMA I can stop the execution and so on <sil=0.927> .PERIOD So <sil=0.580> ,COMMA what you are really seeing is this break point gives you an opportunity to start from a particular <sil=0.560> ,COMMA so let us say these break points 8 and 12 <sil=0.918> .PERIOD If I start at 8 <sil=0.506> ,COMMA it actually gives me an opportunity to run till 12 without executing the lines in between <sil=0.989> .PERIOD Even though I was doing single stepping <sil=0.470> ,COMMA I actually showed every single statement and how it was executing <sil=0.902> .PERIOD You do not really have to do that <sil=0.949> .PERIOD So <sil=0.634> ,COMMA let me quickly demonstrate that <sil=0.918> .PERIOD So <sil=0.344> ,COMMA I am going to run one more debug now <sil=0.953> .PERIOD Again <sil=0.521> ,COMMA I am watching all these things <sil=0.919> .PERIOD You can see that all these prime numbers and so on are invalid <sil=0.996> .PERIOD So <sil=0.462> ,COMMA I start running the program <sil=0.918> .PERIOD So <sil=0.617> ,COMMA primes of 0 is 2 <sil=0.995> .PERIOD Then I can press continue <sil=0.972> .PERIOD It will take me to the next break point <sil=0.983> .PERIOD So <sil=0.551> ,COMMA at this point it went from line number 8 to 12 directly without showing each of these steps <sil=0.961> .PERIOD So <sil=0.412> ,COMMA now since the next break point is 12 and it is inside the loop from line number 11 to 22 <sil=0.479> ,COMMA if I click on continue <sil=0.352> ,COMMA we will do everything that is required for the loop and go to the next time when the p itself is changing <sil=0.916> .PERIOD So <sil=0.473> ,COMMA p changes to 7 <sil=0.616> ,COMMA you can see the left side p changes to 7 <sil=0.633> ,COMMA p changes to 9 and so on <sil=0.979> .PERIOD So <sil=0.618> ,COMMA all the things that were happening here <sil=0.369> ,COMMA all the work got done <sil=0.963> .PERIOD It is not that the work did not get done <sil=0.906> .PERIOD The work got done <sil=0.360> ,COMMA but you are waiting at line number 12 and seeing what is happening <sil=0.966> .PERIOD So <sil=0.586> ,COMMA at this point prime is you are still checking for 9 and the whole thing got done now <sil=0.945> .PERIOD You can go and see that the program is executed and if I we have run till the end of the program <sil=0.972> .PERIOD So <sil=0.629> ,COMMA at this point you can stop the execution and all the values from 2 <sil=0.542> ,COMMA 3 up to 7 are already in the prime <sil=0.937> .PERIOD So <sil=0.504> ,COMMA you can use the debugger for debugging various programs <sil=0.925> .PERIOD This is a very effective tool <sil=0.902> .PERIOD I suggest that you get used to this debugging so that you can check all your programs once before you go and do your homeworks on the website <sil=0.988> .PERIOD And this is a very useful utility <sil=0.976> .PERIOD So <sil=0.649> ,COMMA I cannot emphasize this more <sil=0.985> .PERIOD You have a good handle of how the debugger is used and you do not have to print screen fulls of debugging statements instead use the debugger effectively <sil=0.978> .PERIOD So <sil=0.473> ,COMMA the key trick will be in finding out what variables you want to watch and where to set your break points <sil=0.907> .PERIOD So <sil=0.451> ,COMMA I knew this ahead of time <sil=0.902> .PERIOD So <sil=0.567> ,COMMA I had set break points at line number 12 and line number 8 <sil=0.428> ,COMMA but you have to be careful about where you are setting your break points <sil=0.960> .PERIOD It does not make sense to set break points at every line <sil=0.967> .PERIOD Thank you very much <sil=0.911> .PERIOD So <sil=0.533> ,COMMA now let us move on to another program and in this program what I am going to do is I am going to post the problem and actually show a piece of code running inside this software <sil=0.597> ,COMMA running inside the IDE <sil=0.967> .PERIOD So the problem is find all the prime numbers that are less than or equal to n <sil=0.941> .PERIOD So I am going to give a n and I want you to find out all the prime numbers that are less than n <sil=0.931> .PERIOD So clearly this is something that you want the computer to do <sil=0.959> .PERIOD You want the program to give you this <sil=0.416> ,COMMA right <sil=0.963> ?QUESTIONMARK It is not something that is going to come from the user and it is not something that is as simple as Fibonacci where you just have to add two elements <sil=0.950> .PERIOD This requires a little more work <sil=0.916> .PERIOD It requires some bit of logic to find out all the prime numbers that are less than or equal to n <sil=0.950> .PERIOD So let us start with some very simple observations <sil=0.906> .PERIOD So we know that two is the only prime number that is even <sil=0.953> .PERIOD So two is the smallest prime number and we also know that that is the only even number that is prime <sil=0.914> .PERIOD All the other even numbers are not prime because two is a factor <sil=0.960> .PERIOD Three is the smallest odd prime number <sil=0.906> .PERIOD And from now on we know that two and three are prime numbers <sil=0.913> .PERIOD We will have to start checking from four onwards if they are prime number or not <sil=0.426> ,COMMA right <sil=0.993> ?QUESTIONMARK So four is not a prime number because it is a multiple of two <sil=0.957> .PERIOD It is an even number <sil=0.997> .PERIOD Five is a prime number <sil=0.939> .PERIOD Six is not because it is even <sil=0.940> .PERIOD Seven is a prime number <sil=0.910> .PERIOD Eight is not because it is even nine <sil=0.915> .PERIOD Even those are odd number is not a prime number because it is three times three and so on <sil=0.947> .PERIOD So what we are going to do is we are so I am going to lay out a technique to solve this problem <sil=0.924> .PERIOD So let us see how to do this using paper and pencil first and then we will move on and see how to write a program for this <sil=0.995> .PERIOD So I am going to assume that n equals 10 <sil=0.977> .PERIOD So I want all the prime numbers that are less than or equal to 10 <sil=0.955> .PERIOD If 10 is a prime number I want to use <sil=0.937> .PERIOD I want to declare that 10 is a prime number also <sil=0.945> .PERIOD So 10 is not but whatever n I take I want to print all prime numbers that are less than or equal to n <sil=0.934> .PERIOD So this is a program to find out prime numbers less than or equal to n <sil=0.916> .PERIOD So since I start with n equals to 10 <sil=0.915> .PERIOD So let us make use of the observations <sil=0.936> .PERIOD So what could I have <sil=0.947> ?QUESTIONMARK I could have T234567 89910 <sil=0.962> .PERIOD I already know that 2 is a prime number and 3 is a prime number <sil=0.951> .PERIOD I also know that all the even numbers are not prime <sil=0.963> .PERIOD I know that all the even numbers are not prime <sil=0.966> .PERIOD So I am going to start with 2 and 3 and I have all the odd numbers that are less than or equal to n <sil=0.982> .PERIOD So in this case it is 23579 and of these I already know that 2 is a prime number and 3 is a prime number <sil=0.905> .PERIOD Let us see how to find out if 5 is prime or not <sil=0.932> .PERIOD So one thing we are going to do is we are going to assume that 5 is a prime number initially <sil=0.939> .PERIOD Until we have a proof that 5 is not prime <sil=0.935> .PERIOD So in this case 5 is guilty of being prime until it is proven otherwise <sil=0.988> .PERIOD So what are the different things that we can do to check whether 5 is prime or not <sil=0.940> ?QUESTIONMARK Of course I can go from if 5 is not a prime then one of these numbers 23 or 4 we should be able to divide 5 by that and get no reminder <sil=0.920> .PERIOD So let us do that <sil=0.959> .PERIOD Let us say I do 5 divided by 2 the reminder is 1 <sil=0.979> .PERIOD I do 5 divided by 3 the reminder is 2 <sil=0.985> .PERIOD I do 5 divided by 4 the reminder is 1 <sil=0.963> .PERIOD So all these numbers which are less than 5 I divide by I divide them into 5 it leaves a reminder so 23 and 4 are not factors of 5 <sil=0.927> .PERIOD So 5 is actually prime <sil=0.903> .PERIOD But one thing we can observe is that if you look at 4 right 4 is already 2 times 2 right <sil=0.924> .PERIOD So if I want to check whether 5 is divisible by 4 or not right <sil=0.991> .PERIOD Let us assume that some number M is divisible by 4 right M is actually divisible by 4 <sil=0.921> .PERIOD But if M is divisible by 4 it is also actually divisible by 2 <sil=0.976> .PERIOD The reason is 4 is actually 2 times 2 <sil=0.980> .PERIOD So I do not have to really check whether M is divisible by 4 or not if I have already checked if M is divisible by 2 right <sil=0.969> .PERIOD So for 5 I am going to check only if it is divisible by 2 or 3 I will not check if it is divisible by 4 right <sil=0.933> .PERIOD So I go and check whether 5 is divisible by 2 it is not it is 5 divisible by 3 it is not I started with the assumption that 5 is prime so it is not changing <sil=0.910> .PERIOD So 5 is indeed prime <sil=0.921> .PERIOD Let us do the same thing for 7 <sil=0.951> .PERIOD So what I am going to do is I am going to so as for 7 also I can start from 2 check for 3 check for 4 check for 5 6 and so on <sil=0.911> .PERIOD But I really do not have to check for 4 and 6 divisibility because if for 4 I already know 2 is a factor for 6 I already know that 2 and 3 are factors <sil=0.951> .PERIOD So therefore I do not have to check 7 divisible by 6 or 4 <sil=0.958> .PERIOD So to put it more succinctly what we are checking is for any number N we are going to check only if it is divisible by other prime numbers that are strictly less than N or not <sil=0.999> .PERIOD For 7 the list of prime numbers that are less than 7 or 2 3 and 5 I do not have to check other numbers like 4 and 6 and so on <sil=0.936> .PERIOD We will only check prime numbers that are less than 7 <sil=0.949> .PERIOD So what are the prime numbers that are less than 7 they are 2 3 and 5 <sil=0.901> .PERIOD So again as before I will assume that 7 is actually prime until it is proven otherwise <sil=0.935> .PERIOD So I will go and check whether it is divisible by 2 it is not I can check whether 7 is divisible by 3 it is not is 7 divisible by 5 it is not <sil=0.949> .PERIOD So you have checked all the prime numbers that are less than 7 so at this point 7 is actually guilty of being prime and it does not change <sil=0.948> .PERIOD Let us do this little thing for 9 I start with number <sil=0.981> .PERIOD So what are the prime numbers that are less than 9 they are 2 3 5 and 7 I will I will assume that 9 is a prime number to start with I check whether it is divisible by 2 it is not I can check whether it is divisible by 3 or not <sil=0.930> .PERIOD In this case 9 is actually divisible by 3 so it is divisible it is not divisible by 5 and it is not divisible by 7 <sil=0.952> .PERIOD So I started with the assumption that 9 is actually prime however 9 was divisible by 3 the moment it is divisible by 1 prime number even 1 prime number less than the end that I am looking at right then this assumption that this number is prime is not true anymore I have to change that assumption right <sil=0.935> .PERIOD So 9 was assumed to be prime and it is not prime anymore because it is divisible by 3 <sil=0.948> .PERIOD So in summary what I am going to do is I am going to start with number 2 and 3 I will assume that they are already prime and I am going to check for given n I am going to check only odd numbers starting from 5 7 and so on up till n <sil=0.959> .PERIOD So if n is odd I will include n also if n is even I will go only till n minus 1 right and for each of these numbers I am going to look at all the prime numbers that are less than that number and see if that number divides into this current number under consideration or not right and I do this till n right <sil=0.909> .PERIOD So let us see a small program segment that I have written to do that right <sil=0.975> .PERIOD So in the process I also want to show you some features of the IDE that I am using which is called DevC++ <sil=0.968> .PERIOD So as before I start with hash include scdo <sil=0.972> .PERIOD h because I want to be able to print the prime numbers later and I also have hash define n equals 10 <sil=0.999> .PERIOD So I defined n to be 10 I want to print all the prime numbers starting at 2 up to 10 whatever prime numbers are there I want to find them out right <sil=0.909> .PERIOD So in the worst case all of them could be prime numbers <sil=0.961> .PERIOD So I have an array called primes right <sil=0.997> .PERIOD So I have this array called primes and what it is going to keep is all the prime numbers that are less than or equal to n and you are actually allocating n numbers or n locations for prime numbers <sil=0.913> .PERIOD So upfront if I give you a number 100 you do not know how many prime numbers are there I am assuming that all 100 could be prime numbers and I assign or I create an array of size 100 <sil=0.944> .PERIOD So they are of course going to get index from 0 to 99 <sil=0.985> .PERIOD So I look at this line primes of 0 is 2 <sil=0.908> .PERIOD So the first prime number is 2 I put that at location 0 primes of 1 is 3 so the next prime number is 3 <sil=0.925> .PERIOD So I already have 2 locations filled up namely location 0 and location 1 I can start at location 2 and start filling up the prime numbers <sil=0.906> .PERIOD So the array that we are going to maintain right so this is the setup we are going to maintain an array right and this array is going to be called primes <sil=0.962> .PERIOD It is going to have values for locations from 0 to n minus 1 location 0 is going to contain 2 location 1 is going to contain 3 and prime index is a variable that I am going to use to index into the array called primes <sil=0.946> .PERIOD So that is prime index and p is an iterator that is going to run from 5 <sil=0.610> ,COMMA 7 <sil=0.644> ,COMMA so on <sil=0.989> .PERIOD So if n is 15 it will go till 15 at 5 <sil=0.336> ,COMMA 7 up to 15 <sil=0.953> .PERIOD So that is what this loop does right so p equal to 5 <sil=0.350> ,COMMA p less than or equal to n <sil=0.973> .PERIOD So the nice thing that I have done here is I have incremented p by 2 already <sil=0.924> .PERIOD So if I start with 5 if I go up to n in increments of 2 I am starting with 5 and then it will be 7 <sil=0.422> ,COMMA 9 and so on <sil=0.904> .PERIOD I am looking only at odd numbers I will never have even numbers right <sil=0.988> .PERIOD So I also want to show you something else <sil=0.913> .PERIOD So on the left side if you see there are line numbers <sil=0.919> .PERIOD So the line number hash include gets line number 1 this for loop is starting at line number 12 this for loop is starting at line number 14 and so on <sil=0.995> .PERIOD So I do not know if you have been paying attention so far when I showed the IDE <sil=0.952> .PERIOD So this for loop starts at this line and ends at this line and you can see a thin line running from f to close bracket <sil=0.916> .PERIOD Similarly this if statement here right you can see a thin line running from here to here and for this for loop it is running from somewhere you do not see the end of it <sil=0.947> .PERIOD So this is something that many IDE give you for tracking source code and being able to write code easily <sil=0.978> .PERIOD So you see the line numbers on the left side you also see what is called the gutter <sil=0.995> .PERIOD So gutter is a small gully on the left side <sil=0.903> .PERIOD So on the gutter you see the line numbers we also see small rectangles on the left side <sil=0.958> .PERIOD So if so these are called foldables <sil=0.981> .PERIOD So if you see this for loop right I can click on this line number 14 and it folded you after 14 you see line number 19 now <sil=0.987> .PERIOD So line numbers 14 up to 18 are now hidden <sil=0.995> .PERIOD If I click on this minus symbol next to 19 it again folded <sil=0.915> .PERIOD So I can click on it again and it will expand <sil=0.994> .PERIOD So you can click to expand or fold <sil=0.966> .PERIOD So let us assume that these are folded now <sil=0.996> .PERIOD So if you do that what the IDE does is it just shows you opening and closing braces without the statements inside <sil=0.938> .PERIOD So let us see what the loop starting at 12 and ending at line number 23 is supposed to do <sil=0.978> .PERIOD We are going to start with p equals 5 <sil=0.913> .PERIOD I will assume that 5 is prime and then I will check whether it is prime or not then I will either write it into the array or not <sil=0.933> .PERIOD Then I will assume that 7 is prime <sil=0.901> .PERIOD I will check whether it is actually prime or not <sil=0.939> .PERIOD I will register it if it is prime then I move on to 9 and so on up till n is over <sil=0.975> .PERIOD So the loop running from line number 12 to 23 is only iterating over all the odd numbers <sil=0.904> .PERIOD For each odd number we assume that it is prime <sil=0.916> .PERIOD So this we are going to track by using a variable called is prime <sil=0.986> .PERIOD So you can think of this as a question is 5 prime and one means it is prime and 0 is usually used for false <sil=0.925> .PERIOD So one is usually used for true and 0 is usually used for false <sil=0.963> .PERIOD So is 5 prime <sil=0.978> .PERIOD I will assume that 5 is actually prime and I have to run a loop to actually verify if it is prime or not <sil=0.911> .PERIOD So let us look at the loop from line number 14 to 18 <sil=0.973> .PERIOD So in line number 14 we have a loop for i equals 1 i less than prime index i plus plus <sil=0.995> .PERIOD So if p is divisible by some p of i then p is not prime <sil=0.943> .PERIOD So we are checking that in line number 16 to 17 <sil=0.936> .PERIOD So if p is actually divisible by a prime number that is less than it that is what you have in line number 16 <sil=0.954> .PERIOD Then your is prime becomes 0 <sil=0.901> .PERIOD We start with is 5 prime yes and this if condition checks whether that has to be changed or not <sil=1.000> .PERIOD And when this fall loop is over you come and check whether your assumption is true or not <sil=0.938> .PERIOD If the assumption still holds true if the current p is not divisible by any prime number less than it then it is still prime and you updated increment the prime index by 1 <sil=0.994> .PERIOD Otherwise you do not increment the prime index you do not record the value and so on <sil=0.951> .PERIOD And line number 24 is just a loop which prints all the prime numbers <sil=0.994> .PERIOD So we have this setup now <sil=0.978> .PERIOD I want to run it compile it run it and show what it does <sil=0.969> .PERIOD So see that n is equal to 10 <sil=0.997> .PERIOD I am going to compile it <sil=0.925> .PERIOD So I see that there are no errors and I run it <sil=0.980> .PERIOD You can see that I printed values 2357 <sil=0.901> .PERIOD So it doesn't have any number which is not a prime number <sil=0.961> .PERIOD So as I said earlier I want to go and change this <sil=0.995> .PERIOD Let us say I want to print all the numbers from 2 to 15 which are prime <sil=0.918> .PERIOD So the first thing I did is I edited it and then I saved it <sil=0.980> .PERIOD So let us say I change it to 15 <sil=0.939> .PERIOD You can see that there is a star on the top which says it is not saved yet <sil=0.961> .PERIOD The first thing I do is save <sil=0.962> .PERIOD Let us say I do not compile it <sil=0.998> .PERIOD I just run it <sil=0.969> .PERIOD I saved it but I didn't compile it <sil=0.950> .PERIOD So it is still the executable that I have is still holding the old value of n which is 10 <sil=0.923> .PERIOD So it is printing only prime numbers up to 10 <sil=0.904> .PERIOD So to correct that what I have to do is I have to compile it once more <sil=0.923> .PERIOD I compile it once more <sil=0.967> .PERIOD Now the compilation is over <sil=0.986> .PERIOD Now I run it <sil=0.923> .PERIOD You see that the print is 235711 and 13 <sil=0.906> .PERIOD So I have all the prime numbers from 2 to 13 included in this <sil=0.978> .PERIOD Then let us say I want to change this number and I want the first 100 numbers <sil=0.991> .PERIOD Not the first 100 numbers and whatever is prime in the first 100 integers I want to print those <sil=0.916> .PERIOD I change n to 100 <sil=0.971> .PERIOD I save it <sil=0.939> .PERIOD I compile it first <sil=0.901> .PERIOD So I compile it and then I run it <sil=0.911> .PERIOD You can see that the print is 100 <sil=0.912> .PERIOD So you can see that numbers are starting from 2 <sil=0.901> .PERIOD It goes from 35711 and so on up till 97 <sil=0.982> .PERIOD So this is what I was talking about earlier <sil=0.987> .PERIOD Usually you test your program with small values and once you are comfortable about that then you go ahead and put larger values <sil=0.943> .PERIOD So let us say I want 1000 up to 1000 <sil=0.908> .PERIOD I want all the prime numbers to be printed <sil=0.960> .PERIOD So again I change it to 1000 <sil=0.942> .PERIOD I compile it first <sil=0.999> .PERIOD Then I run it <sil=0.953> .PERIOD Now you can see that I have a screen full of prime numbers <sil=0.941> .PERIOD So I start with 2 and the last prime number less than 1000 seems to be 997 <sil=0.920> .PERIOD So you can go and verify that <sil=0.915> .PERIOD The number before that is 991 and so on <sil=0.936> .PERIOD You can go and verify that <sil=0.912> .PERIOD So one thing that I want you to observe is that the line numbers are a very useful thing <sil=0.938> .PERIOD So use them when you want to discuss programs and so on <sil=0.950> .PERIOD And you can also use this collapse and expand <sil=0.967> .PERIOD If you do not want to see all the code you collapse and expand <sil=0.958> .PERIOD So when I want to see what the outermost loop is doing <sil=0.472> ,COMMA I collapse everything else inside <sil=0.929> .PERIOD So now this is very clear <sil=0.968> .PERIOD So I am iterating over all the odd numbers less than or equal to n <sil=0.966> .PERIOD And if I want to see how I am actually checking whether a number is prime or not <sil=0.418> ,COMMA I expand this loop on line number 14 <sil=0.920> .PERIOD And I see that I am checking all the I am checking the current p against all the prime numbers that are less than this <sil=0.948> .PERIOD And finally if the assumption is still true <sil=0.522> ,COMMA I record it <sil=0.909> .PERIOD Otherwise I do not record it <sil=0.931> .PERIOD So if his prime is 0 <sil=0.369> ,COMMA you see that there is no else clause <sil=0.957> .PERIOD So we are not recording <sil=0.922> .PERIOD And I print everything and return 0 <sil=0.958> .PERIOD So we wrote a small program which printed all the prime numbers less than or equal to n <sil=0.952> .PERIOD So at line number 12 <sil=0.610> ,COMMA we had this outermost loop running which is iterating over all the odd numbers <sil=0.934> .PERIOD At line number 14 <sil=0.584> ,COMMA we had this primality check <sil=0.936> .PERIOD And line number 19 goes and verifies our initial assumption whether it is actually prime or not <sil=0.964> .PERIOD So there are a lot of things that you can do to this program <sil=0.995> .PERIOD You can make this program more efficient <sil=0.944> .PERIOD So for example when we checked 15 <sil=0.437> ,COMMA we would have checked 2 <sil=0.514> ,COMMA 3 <sil=0.582> ,COMMA 5 <sil=0.618> ,COMMA 7 <sil=0.412> ,COMMA 9 and so on <sil=0.914> .PERIOD If you did not account for just the prime numbers <sil=0.901> .PERIOD If you checked only the prime numbers <sil=0.540> ,COMMA you would have still checked 2 <sil=0.485> ,COMMA 3 <sil=0.543> ,COMMA 5 <sil=0.500> ,COMMA 7 <sil=0.306> ,COMMA 11 and 13 also to check for 15 <sil=0.942> .PERIOD But there is a small mathematical property that if you are looking at a prime number <sil=0.350> ,COMMA it is enough to check prime numbers that are less than or equal to square root of n <sil=0.971> .PERIOD You do not even have to go to the last prime number that is less than n <sil=0.963> .PERIOD So you can make that change <sil=0.926> .PERIOD The other thing is if p is divisible by some prime number <sil=0.536> ,COMMA the loop will still check and keep running <sil=0.978> .PERIOD So for example <sil=0.367> ,COMMA if you have 9 <sil=0.635> ,COMMA you would have checked it against 2 <sil=0.392> ,COMMA when you check against 3 <sil=0.422> ,COMMA you already know that it is not prime <sil=0.556> ,COMMA 9 is not prime <sil=0.947> .PERIOD You still go ahead and check it with 5 and 7 <sil=0.923> .PERIOD What is the point <sil=0.909> ?QUESTIONMARK We already know that with 3 <sil=0.358> ,COMMA 9 is not a prime anymore because 3 is a factor of 9 <sil=0.962> .PERIOD So you can use these 2 tricks <sil=0.990> .PERIOD Go only till prime numbers that are less than square root of n and at some point if your assumption is violated <sil=0.645> ,COMMA why even bother looking at all the entries <sil=0.940> .PERIOD So you can break right then and there and say that the number is not prime anymore <sil=0.962> .PERIOD So you can combine each of these techniques <sil=0.929> .PERIOD So you can have each of these techniques in place or you can even combine them both to give you a better program <sil=0.934> .PERIOD So this code segment can be modified to do these 2 changes <sil=0.928> .PERIOD So don't go till all the prime numbers less than n <sil=0.337> ,COMMA go in little square root and even in that at some point if you find out that a number is composite <sil=0.366> ,COMMA don't go any further <sil=0.488> ,COMMA you can break out of the loop <sil=0.982> .PERIOD So you may have to make changes in 2 places <sil=0.922> .PERIOD So you have to make changes here so that you do not run everywhere and at some point once you get if is prime <sil=0.435> ,COMMA so if is prime becomes 0 which means it is already a composite number <sil=0.623> ,COMMA you do not run the loop anymore <sil=0.310> ,COMMA you can stop and do something about it <sil=0.930> .PERIOD So I give you these 2 things as exercises go and do this <sil=0.924> .PERIOD So thank you very much <sil=0.958> .PERIOD So <sil=0.433> ,COMMA in module 3 we will look at the notion of variables assignments and how operators in C works <sil=0.971> .PERIOD So <sil=0.599> ,COMMA let us take a small problem again <sil=0.978> .PERIOD This is a problem on polynomial multiplication <sil=0.915> .PERIOD Let us say we are given two polynomials A x plus B and C x plus D <sil=0.960> .PERIOD So <sil=0.477> ,COMMA by given what I mean is you are given the coefficients A comma B and you are also given the coefficients C comma D <sil=0.954> .PERIOD And you are expected to compute the product of the polynomials <sil=0.985> .PERIOD So <sil=0.303> ,COMMA the product would be A C x squared plus A D plus B C times x plus C D <sil=0.986> .PERIOD So <sil=0.497> ,COMMA what we really want is the coefficient of x squared <sil=0.476> ,COMMA the coefficient of x and C D itself <sil=0.910> .PERIOD So <sil=0.383> ,COMMA to write a program for this problem P 1 <sil=0.930> .PERIOD 1 we need the following steps <sil=0.981> .PERIOD So <sil=0.473> ,COMMA we need to declare storage A <sil=0.466> ,COMMA B <sil=0.583> ,COMMA C D or all coefficients <sil=0.940> .PERIOD If you read from the user you need to store them temporarily somewhere <sil=0.991> .PERIOD And once the declarations done you need to actually read the coefficients from the user <sil=0.914> .PERIOD Perform all the arithmetic operations required and finally print them on the screen <sil=0.992> .PERIOD So <sil=0.489> ,COMMA that is the basic steps <sil=0.920> .PERIOD So <sil=0.346> ,COMMA I already have a small program written up here <sil=0.957> .PERIOD So <sil=0.390> ,COMMA we start with declaration of storage that is step 1 <sil=0.921> .PERIOD So <sil=0.537> ,COMMA again ignore the first few lines you see that there is A comma B comma C comma D and A into P 2 P 1 P naught <sil=0.948> .PERIOD So <sil=0.643> ,COMMA this is very much like what we did earlier <sil=0.997> .PERIOD So <sil=0.534> ,COMMA we have A <sil=0.490> ,COMMA B <sil=0.603> ,COMMA C D <sil=0.948> .PERIOD So <sil=0.512> ,COMMA we need four coefficients and the product the polynomial has only three coefficients P 2 P 1 and P naught is the name that I am giving them <sil=0.969> .PERIOD Step 2 is read the inputs <sil=0.938> .PERIOD So <sil=0.519> ,COMMA in this program I have written the written intents that will prompt the user for one coefficient at a time <sil=0.955> .PERIOD So <sil=0.406> ,COMMA there is print F enter A and the user is expected to enter a number and it is read using the statements can of <sil=0.925> .PERIOD Then you have print of enter B <sil=0.915> .PERIOD Now <sil=0.491> ,COMMA you are ready to read B and so on <sil=0.931> .PERIOD So <sil=0.345> ,COMMA four coefficients are read <sil=0.978> .PERIOD So <sil=0.458> ,COMMA this is step 2 <sil=0.908> .PERIOD Step 3 calculate the coefficients and print <sil=0.990> .PERIOD So <sil=0.437> ,COMMA here there are three lines P 2 P 1 and P naught <sil=0.955> .PERIOD P 2 is A times C <sil=0.941> .PERIOD P 1 is A into D plus B into C and P naught is B into D <sil=0.999> .PERIOD So <sil=0.505> ,COMMA this is the very first time you are seeing an assignment <sil=0.904> .PERIOD So <sil=0.517> ,COMMA the way to look at assignments is look at the equality sign in the first line here <sil=0.920> .PERIOD You see A star C <sil=0.959> .PERIOD So <sil=0.348> ,COMMA star is the operator for multiplication <sil=0.985> .PERIOD So <sil=0.570> ,COMMA you are multiplying A with C and that is assigned to P 2 <sil=0.943> .PERIOD So <sil=0.598> ,COMMA the way to look at this line is you do the operation A times C and the values assigned to P 2 which is on the left side <sil=0.923> .PERIOD Then you have A times D plus B times C <sil=0.986> .PERIOD So <sil=0.355> ,COMMA you do this operation and you assign it to P 1 and B into D is assigned to P naught <sil=0.963> .PERIOD So <sil=0.420> ,COMMA at the end of these three statements we expect P 2 P 1 and P naught to reflect the point that you have already taken care of the multiplication of the polynomial <sil=0.942> .PERIOD Now <sil=0.637> ,COMMA you are ready to print and the product is printed on the screen <sil=0.938> .PERIOD So <sil=0.505> ,COMMA again forget all the fancy looking things there <sil=0.958> .PERIOD So <sil=0.361> ,COMMA you can see that print if the product is and something there <sil=0.968> .PERIOD So <sil=0.451> ,COMMA ignore it for now <sil=0.938> .PERIOD It is only printing the coefficients along with the in the polynomial format itself <sil=0.983> .PERIOD So <sil=0.453> ,COMMA let us run this program <sil=0.954> .PERIOD I have written this program up and let us run this program <sil=0.966> .PERIOD So <sil=0.622> ,COMMA you can see that the program is the same as what I said <sil=0.995> .PERIOD So <sil=0.341> ,COMMA you have in take M of B comma C comma D <sil=0.957> .PERIOD Then you have the three coefficients P 2 P 1 and P naught <sil=0.996> .PERIOD The four scan statements for reading the variables <sil=0.536> ,COMMA three statements for doing all the assignments or doing the arithmetic operations and one final statement which takes care of printing <sil=0.903> .PERIOD So <sil=0.542> ,COMMA I will compile it now <sil=0.973> .PERIOD It gives me no errors or no warnings <sil=0.978> .PERIOD So <sil=0.637> ,COMMA so far I have not shown you what errors and warnings could be <sil=0.919> .PERIOD I have written programs which are all correct <sil=0.949> .PERIOD Now <sil=0.647> ,COMMA I am ready to run <sil=0.945> .PERIOD So <sil=0.416> ,COMMA as before we see the value prompt for A <sil=0.911> .PERIOD So <sil=0.478> ,COMMA I am going to enter the polynomial 1 comma 2 <sil=0.997> .PERIOD So <sil=0.491> ,COMMA essentially 1 x plus 2 for the first polynomial and 3 x plus 4 for the second polynomial <sil=0.927> .PERIOD So <sil=0.471> ,COMMA the result is 3 times x squared plus 10 x plus 8 <sil=0.925> .PERIOD So <sil=0.581> ,COMMA it is 1 x plus 2 times 3 x plus 4 <sil=0.959> .PERIOD So <sil=0.447> ,COMMA that is 3 x squared plus 10 x plus 8 <sil=0.944> .PERIOD So <sil=0.417> ,COMMA let us look at the program in its entirety <sil=0.958> .PERIOD We have the first few lines which has the comment <sil=0.960> .PERIOD So <sil=0.326> ,COMMA there is a comment on the top here which says this is a program to multiply 2 polynomials A x plus B and C x plus D <sil=0.957> .PERIOD So <sil=0.468> ,COMMA it is always good to show the intention of the programmer and this kind of documentation is helpful for somebody else who is going to read your program and understand what is happening <sil=0.973> .PERIOD Then as before we have this line has include sdio <sil=0.945> .PERIOD h <sil=0.937> .PERIOD This is necessary for doing all the IO operations <sil=0.926> .PERIOD If you want to read from the keyboard or if you want to print on the screen you will need this <sil=0.960> .PERIOD And then we have the declarations for a <sil=0.408> ,COMMA b <sil=0.474> ,COMMA c <sil=0.969> ,COMMA d <sil=0.575> ,COMMA p 2 <sil=0.491> ,COMMA p 1 and p naught <sil=0.906> .PERIOD Then we did a series of printing on the screen and reading from the user and we did the operations and printed the result on the screen <sil=0.982> .PERIOD So <sil=0.443> ,COMMA I already showed you the executions <sil=0.996> .PERIOD So <sil=0.534> ,COMMA this by itself is not what I want to show <sil=0.974> .PERIOD I want to drive something else <sil=0.908> .PERIOD Let us look let us take a close look at the program and see some of the nitty gritty details that are involved <sil=0.964> .PERIOD So <sil=0.603> ,COMMA let us start with a <sil=0.595> ,COMMA b <sil=0.463> ,COMMA c <sil=0.915> ,COMMA d <sil=0.366> .PERIOD So <sil=0.367> ,COMMA I assume with the polynomial is A x plus B and C x plus D <sil=1.000> .PERIOD So <sil=0.327> ,COMMA however we need the user to give these four coefficients and these four coefficients have to be taken from the user and stored temporarily somewhere and that is where we are going to use these variables A <sil=0.446> ,COMMA B <sil=0.405> ,COMMA C and D <sil=0.937> .PERIOD So <sil=0.432> ,COMMA in a little while explain what the word variable means at this point just assume that A <sil=0.440> ,COMMA B <sil=0.505> ,COMMA C and D are four variables <sil=0.936> .PERIOD And it is not enough to just have these coefficients because we are supposed to produce the product terms <sil=0.906> .PERIOD So <sil=0.461> ,COMMA you have A <sil=0.457> ,COMMA B <sil=0.611> ,COMMA C <sil=0.560> ,COMMA D and you have p 2 <sil=0.305> ,COMMA p 1 <sil=0.639> ,COMMA p naught <sil=0.965> .PERIOD And when you have int A <sil=0.537> ,COMMA B <sil=0.588> ,COMMA C <sil=0.391> ,COMMA D <sil=0.479> ,COMMA it actually allocates storage for A <sil=0.546> ,COMMA B <sil=0.314> ,COMMA C and D because once you read it from the user you have to save it somewhere <sil=0.925> .PERIOD And when you have p 2 <sil=0.461> ,COMMA p 1 <sil=0.380> ,COMMA p naught again you allocate the storage for p 2 <sil=0.621> ,COMMA p 1 <sil=0.327> ,COMMA p naught and store it somewhere <sil=0.970> .PERIOD So <sil=0.573> ,COMMA essentially it takes care of all the storage that you need to do all the operations and this storage is going to be in the main memory <sil=0.943> .PERIOD So <sil=0.364> ,COMMA we already saw the model for the computer <sil=0.978> .PERIOD So <sil=0.495> ,COMMA we have memory and we have a CPU and we have other units <sil=0.983> .PERIOD So <sil=0.336> ,COMMA these variables will be stored in the memory <sil=0.975> .PERIOD And if you look at this int <sil=0.598> ,COMMA int basically means that int stands for integer and it means that anything that follows this is going to be a variable which is of an integer type <sil=0.912> .PERIOD So <sil=0.459> ,COMMA when you have int A <sil=0.321> ,COMMA B <sil=0.464> ,COMMA C <sil=0.448> ,COMMA D we have four integers or four variables of the data type called integers <sil=0.962> .PERIOD Similarly <sil=0.335> ,COMMA we have p 2 <sil=0.485> ,COMMA p 1 <sil=0.375> ,COMMA p naught which also have this int before it which means there are three integers by name p 2 <sil=0.587> ,COMMA p 1 and p naught <sil=0.946> .PERIOD So <sil=0.308> ,COMMA if the input coefficients A <sil=0.571> ,COMMA B <sil=0.392> ,COMMA C <sil=0.563> ,COMMA D are all integers <sil=0.561> ,COMMA the product and sum of integers are always integers <sil=0.956> .PERIOD So <sil=0.499> ,COMMA therefore <sil=0.373> ,COMMA I have used integer for p 2 <sil=0.334> ,COMMA p 1 <sil=0.565> ,COMMA p naught also <sil=0.937> .PERIOD And this is called the data type <sil=0.993> .PERIOD So <sil=0.649> ,COMMA whenever you want a variable it cannot be a variable of an unknown type <sil=0.308> ,COMMA it has to be a variable of a known type <sil=0.903> .PERIOD And there are a few basic data types that the language provides you <sil=0.932> .PERIOD There are other data types that you can build on your own <sil=0.997> .PERIOD In this case <sil=0.389> ,COMMA I am going to use basic data type provided by C which is called int <sil=0.957> .PERIOD So <sil=0.339> ,COMMA remember int stands for integer <sil=0.903> .PERIOD Now <sil=0.427> ,COMMA let us see what is going to really happen from the memory point of view <sil=0.915> .PERIOD So <sil=0.416> ,COMMA let us see the program <sil=0.949> .PERIOD So <sil=0.589> ,COMMA initially the memory is unused <sil=0.519> ,COMMA I am showing a segment of the memory here <sil=0.972> .PERIOD So <sil=0.415> ,COMMA let us assume that the memory is huge and it has several bytes of storage <sil=0.956> .PERIOD I am going to show you only a portion of the memory on the right hand side <sil=0.980> .PERIOD So <sil=0.536> ,COMMA initially everything is unused and the moment there is a declaration int a <sil=0.572> ,COMMA B <sil=0.445> ,COMMA C <sil=0.334> ,COMMA D what it really means is when you run the program <sil=0.442> ,COMMA there are going to be four memory locations which will be called by the names A <sil=0.633> ,COMMA B <sil=0.452> ,COMMA C and D <sil=0.988> .PERIOD So <sil=0.490> ,COMMA the memory that you all that you have is initially uncommitted <sil=0.400> ,COMMA the declaration int a <sil=0.555> ,COMMA B <sil=0.388> ,COMMA C <sil=0.600> ,COMMA D will attach some names to the memory locations <sil=0.924> .PERIOD So <sil=0.444> ,COMMA in this example <sil=0.334> ,COMMA this memory location is going to be called A <sil=0.490> ,COMMA this memory location is called B <sil=0.613> ,COMMA this is called C and this location is called D <sil=0.945> .PERIOD So <sil=0.365> ,COMMA I am purposely showing these locations without any values because when you declare you should not assume that there is going to be some known value already present in the memory <sil=0.949> .PERIOD So <sil=0.422> ,COMMA when you start the program <sil=0.466> ,COMMA we do not know what the values are and thus we also expect the user to input these values A <sil=0.384> ,COMMA B <sil=0.337> ,COMMA C and D <sil=0.991> .PERIOD And the next line was int p2p1p0 which means there are going to be three memory locations which are going to be called p2p1p0 <sil=0.940> .PERIOD So <sil=0.341> ,COMMA in this picture even though it shows A <sil=0.513> ,COMMA B <sil=0.549> ,COMMA C and D to be continuous and p2p1p0 also to be continuous <sil=0.393> ,COMMA it does not necessarily have to be so <sil=0.953> .PERIOD So <sil=0.584> ,COMMA they do not have to be continuous memory locations <sil=0.997> .PERIOD So <sil=0.495> ,COMMA we have this <sil=0.925> .PERIOD So <sil=0.546> ,COMMA we looked at the first few lines of the main function and all it does is it is declaring storage <sil=0.975> .PERIOD So <sil=0.576> ,COMMA you are saying various memory locations are going to be called by these names <sil=0.925> .PERIOD Now <sil=0.326> ,COMMA let us look at the statements that follow <sil=0.951> .PERIOD So <sil=0.628> ,COMMA we have printf enter a and let us say it prints this enter a on the screen <sil=0.627> ,COMMA it is prompting the user and when it comes to scan f <sil=0.357> ,COMMA it is going to read one number from the screen <sil=0.956> .PERIOD Let us assume that the user actually input 1 <sil=0.909> .PERIOD So <sil=0.389> ,COMMA we assume that the polynomial is A x plus B is 1 x plus 2 and C x plus D is 3 x plus 4 <sil=0.913> .PERIOD So <sil=0.401> ,COMMA at this point the user is expected to have entered 1 and that would go into the memory location which is called A <sil=0.992> .PERIOD So <sil=0.321> ,COMMA 1 goes into this memory location then printf enter B that will show enter B on the screen when you when the user inputs B in this case it is 2 that would go into this memory location and so on and so forth <sil=0.975> .PERIOD So <sil=0.562> ,COMMA at the end of all these can of statements shown here if we if the user entered 1 2 3 4 these locations would contain 1 2 3 4 <sil=0.950> .PERIOD P 2 P 1 P 0 I am showing blank it does not mean that it does not have any value <sil=0.980> .PERIOD It only means that we do not know the value at it has to be calculated yet <sil=0.963> .PERIOD So <sil=0.475> ,COMMA at this point A B C D are all ready and is available in the program <sil=0.918> .PERIOD So <sil=0.405> ,COMMA let us move to the next set of statements the next set of statements or for calculation of P 2 P 1 and P 0 <sil=0.973> .PERIOD So <sil=0.576> ,COMMA remember in this computer's model I showed a control unit which contain the CPU which contain the control unit and the ALU you had memory <sil=0.952> .PERIOD So <sil=0.438> ,COMMA in this at this point I am showing the memory and the ALU I am not showing the input and output and other nodes and so on <sil=0.961> .PERIOD So <sil=0.385> ,COMMA ALU stands for arithmetic and logic unit and since we need arithmetic operations here like multiplication <sil=0.441> ,COMMA addition and so on I am also showing the ALU <sil=0.954> .PERIOD So <sil=0.410> ,COMMA let us see the very first statement here P 2 is A times C <sil=0.948> .PERIOD So <sil=0.429> ,COMMA this star means multiplication <sil=0.969> .PERIOD So <sil=0.503> ,COMMA what you want is A and C to be multiplied and the result of that must be stored in P 2 <sil=0.983> .PERIOD This is what you want and the way it works is this <sil=0.969> .PERIOD So <sil=0.535> ,COMMA when you have P 2 is A times C <sil=0.338> ,COMMA A and C are brought in from the memory into the ALU <sil=0.950> .PERIOD The ALU does the operation multiplication in this case it is 1 times 3 and the result 1 into 3 which is 3 is written back into P 2 <sil=0.992> .PERIOD So <sil=0.509> ,COMMA if you look at this statement you read the value of A which is 1 <sil=0.453> ,COMMA you read the value of C which is 3 <sil=0.565> ,COMMA you do multiplication the result is 3 and the result is written back in the memory location P 2 <sil=0.951> .PERIOD So <sil=0.616> ,COMMA which is what we have so far <sil=0.920> ?QUESTIONMARK We read 1 and 3 and the result is 3 here <sil=0.959> .PERIOD So <sil=0.409> ,COMMA now we are ready to move to the next statement <sil=0.993> .PERIOD The next statement is slightly more complicated <sil=0.966> .PERIOD It has a star <sil=0.338> ,COMMA it has a plus and it has another star and the order in which the operation is done is you perform the operation A times D first <sil=0.558> ,COMMA you then perform the operation B times C <sil=0.998> .PERIOD The result of these two are then added up and the result will be the end result is put back into P 1 <sil=0.913> .PERIOD So <sil=0.409> ,COMMA that is what we are going to see the animation now <sil=0.943> .PERIOD So <sil=0.599> ,COMMA A and D are both read into the ALU and it is not ready to be returned back to P 1 yet because you still have more operations on the right hand side <sil=0.951> .PERIOD So <sil=0.313> ,COMMA this 1 times 4 the result is 4 <sil=0.415> ,COMMA it is temporarily stored inside the ALU itself <sil=0.928> .PERIOD Then you have B times C <sil=0.628> ,COMMA B and C are read from the memory and the result is 6 <sil=0.993> .PERIOD So <sil=0.324> ,COMMA 2 times 3 is 6 and you cannot write 6 to P P 1 yet because this is also a temporary result <sil=0.932> .PERIOD What we really want is A times D plus B times C <sil=0.968> .PERIOD So <sil=0.311> ,COMMA we cannot write 6 to the memory yet <sil=0.971> .PERIOD At this point the ALU has 4 and 6 which are required for this addition operation to be performed <sil=0.908> .PERIOD So <sil=0.609> ,COMMA if you have only one of these operation let us say A times D was available but B times C was not available then the addition cannot be performed <sil=0.941> .PERIOD But at this point of time you have both 4 and 6 and 4 plus 6 is executed by the ALU the result is 10 and once you have the result you are ready to write it back into P 1 <sil=0.980> .PERIOD So <sil=0.591> ,COMMA the RHS or the right hand side is ready we have the result and we write the result into P 1 <sil=0.910> .PERIOD Now next the CPU moves to the last line which is P naught is B times D <sil=0.913> .PERIOD So <sil=0.622> ,COMMA again B and D are brought from the main memory in this time so B and D did not change they are 2 and 4 and the result of that is written back into the main memory <sil=0.936> .PERIOD So <sil=0.537> ,COMMA at the end of the program we have 3 <sil=0.381> ,COMMA 10 and 8 <sil=0.931> .PERIOD So <sil=0.396> ,COMMA let us take a quick look at the program here <sil=0.937> .PERIOD So <sil=0.546> ,COMMA what we saw was these 4 or these statements from line number 10 to 17 initially filled up the 4 memory locations A <sil=0.519> ,COMMA B <sil=0.645> ,COMMA C and D with values by reading from the user lines 18 <sil=0.585> ,COMMA 19 and 20 did operations <sil=0.911> .PERIOD The user is not involved here the values from the memory are red and the calculations are performed the results are written back into the memory and finally when line number 22 is executed it is asking P 2 P 1 and P naught to be printed on the screen in a certain format and the way it is going to be printed is as follows <sil=0.996> .PERIOD So <sil=0.459> ,COMMA you have the product is percentage D x squared plus percentage D x plus percentage D backslash n what that means is <sil=0.986> .PERIOD So <sil=0.352> ,COMMA if you look at this percentage D and if you run this program you will never see this percentage D on the screen <sil=0.956> .PERIOD So <sil=0.471> ,COMMA I enter the same thing if you see the result the product is only 3 x squared plus 10 x plus 8 <sil=0.925> .PERIOD What is really doing is this percentage D is called a format specifier <sil=0.926> .PERIOD So <sil=0.531> ,COMMA wherever you have percentage D here you look at what is the value outside the codes <sil=0.986> .PERIOD So <sil=0.331> ,COMMA it says print P 2 as integer that is what this percentage D means <sil=0.944> .PERIOD So <sil=0.619> ,COMMA P 2 is an integer printed as an integer P 1 is also an integer printed as an integer also and P naught as an integer printed as an integer also <sil=0.997> .PERIOD So <sil=0.587> ,COMMA that is why you get this result 3 times x squared plus 10 x plus 8 <sil=0.916> .PERIOD This x carrot 2 or x squared is verbatim in the program itself and this x plus is also verbatim in the program you see that in the result here and finally 8 <sil=0.955> .PERIOD So <sil=0.624> ,COMMA we will get into the format specifier and so on in in more detail later but as of now just remember that this percentage D is not something that is printed on the screen <sil=0.957> .PERIOD So <sil=0.316> ,COMMA to print something on the screen you need P 2 P 1 P naught stored in the main memory but we have them as 3 10 and 8 <sil=0.993> .PERIOD So <sil=0.579> ,COMMA when you see the print of statement you can read these 3 10 and 8 and print them on the screen <sil=0.989> .PERIOD So <sil=0.402> ,COMMA far we talked about different types of binary trees <sil=0.912> .PERIOD We looked at the construction of Huffman code using the binary tree ADT and then we also looked at another special type of binary tree called the binary search tree and then we also looked at how to construct a binary tree from the pre-order and in order traverses given the pre-order and in order traverses <sil=0.969> .PERIOD Now <sil=0.404> ,COMMA I am going to give you one more application of binary trees which is very important called the heaps or priority queues <sil=0.913> .PERIOD Now <sil=0.649> ,COMMA in the first few classes when we did lists for example <sil=0.354> ,COMMA we talked about queue as a special type of list where we said insertions happen at one end and deletions happen at the other end and it was a first in first out queue <sil=0.948> .PERIOD You got into the queue first <sil=0.619> ,COMMA you got served first that was the idea <sil=0.983> .PERIOD But now <sil=0.624> ,COMMA sometimes it is possible that you want to have queues where you give some priority treatment <sil=0.923> .PERIOD For example <sil=0.535> ,COMMA if I am a computer center in charge and there are large number of programs that are running <sil=0.404> ,COMMA I would like to ensure that those programs or those processes which take very less time should be executed first rather than processes that take a lot of time <sil=0.990> .PERIOD So <sil=0.457> ,COMMA I would like to give some kind of a priority or you know if you have your internet service provider <sil=0.591> ,COMMA if you request is very small <sil=0.553> ,COMMA you get higher priority compared to request where you are downloading huge videos <sil=0.982> .PERIOD So <sil=0.368> ,COMMA now how do we implement priority queues that is the idea <sil=0.937> .PERIOD Suppose we implemented a priority queue using an array like this or a link list like this and we also stored at every node the priority <sil=0.961> .PERIOD Let us say this was 387650 <sil=0.986> .PERIOD You know something like this and same numbers over here 6 of 15 remember in a queue you always deleted and this pointed to the front and this pointed to the rear and this pointed to the front and this pointed to the rear <sil=0.919> .PERIOD Now <sil=0.474> ,COMMA if you want to serve the jobs based on priority then what do you have to do <sil=0.862> ?QUESTIONMARK You keep on moving down front until you come to the rear and for example <sil=0.553> ,COMMA because that was the where the highest priorities and then serve that job <sil=0.996> .PERIOD Similarly <sil=0.565> ,COMMA in this linked list example you start from the front <sil=0.340> ,COMMA keep moving down till you reach the priority with the largest value and serve that <sil=0.954> .PERIOD So <sil=0.472> ,COMMA basically what happens is whether it is the array implementation or the linked list implementation remember this is an abstract data type <sil=0.913> .PERIOD So <sil=0.645> ,COMMA everything is hidden from the user you have to use only the front keep moving down until you come find out which is the largest priority and you will know that only if you have reach the end of the queue <sil=0.929> .PERIOD Therefore <sil=0.596> ,COMMA the time complexity of implementing a priority queue can be as largest order n where n is the number of elements in the queue <sil=0.958> .PERIOD The question is can we do better and that is what we are going to answer using what are called priority queues <sil=0.916> .PERIOD Let us see how we can use priority queues to do this <sil=0.918> .PERIOD The definition of a priority queue comes from the definition of a maximum tree <sil=0.978> .PERIOD What is a maximum tree <sil=0.898> ?QUESTIONMARK A maximum tree is a tree in which the key value in each node is no smaller than the key value in its children if n <sil=0.988> .PERIOD A max heap look at the definition over here is a complete binary tree that is also a max tree <sil=0.989> .PERIOD What we remember is sometime back we saw the definition of a complete binary tree and we said that complete binary trees look like this remember <sil=0.967> .PERIOD We said this is complete binary tree while this is not a complete binary tree <sil=0.908> .PERIOD So <sil=0.460> ,COMMA this what we are saying is we not really have to have this max tree satisfied <sil=0.997> .PERIOD It is no smaller than this children that means this can be 8 <sil=0.598> ,COMMA 7 <sil=0.570> ,COMMA 6 <sil=0.394> ,COMMA 4 and this is a heap <sil=0.908> .PERIOD This is what is a definition of a max heap and it is a complete binary tree not a full binary tree it is a complete binary tree <sil=0.910> .PERIOD So <sil=0.303> ,COMMA the question is so what is this complete binary tree is a binary tree the structure of this tree being a complete binary tree is very important for the implementation of operations on heaps <sil=0.955> .PERIOD We already saw in the context of queues we inserted into the queue we deleted from the queue <sil=0.963> .PERIOD So <sil=0.453> ,COMMA in much the same way where we look at operations on heaps it is a priority queue but a create an empty priority queue you want to insert a queue element into a priority queue and you want to delete the largest element from the priority queue <sil=0.987> .PERIOD By the same thing can be done for minimum also it does not matter you can use a min tree or a max tree <sil=0.964> .PERIOD The difference between a max tree and a max heap is that the max heap is a max tree which is also a complete binary tree <sil=0.910> .PERIOD So <sil=0.466> ,COMMA now let us see how we can perform these operations of insertion into a max heap <sil=0.953> .PERIOD So <sil=0.324> ,COMMA what is what is claimed is that when you implement priority queues using heaps the time complexity is order log in for both insertion and deletion and we already talked about the if you use a normal queue it would be very expensive but priority queues have to be implemented as complete binary tree is using arrays that is what gives it this property of log in <sil=0.938> .PERIOD Let us take an example here is an example let us say I want to I will go through this example completely let us say I want to insert the elements in the first let us say 6 <sil=0.574> ,COMMA 7 and 15 <sil=0.470> ,COMMA 3 <sil=0.391> ,COMMA 2 and 5 into a priority queue <sil=0.928> .PERIOD Let us see how this is done <sil=0.987> .PERIOD It is implemented as an array in this example here the root node corresponds to the index of the array 1 and the next level for example corresponds to the index of the first left child corresponds to the index of the array 2 <sil=0.950> .PERIOD So <sil=0.319> ,COMMA for example in this particular tree what we are saying is 15 has index suppose if there is an array implementation the a is the array that we are using then 7 is at index 2 and 2 is at index 3 this is very very important and see it go essentially if you look at it the array indices go through something like a level order this is the first level second level third level and so on <sil=0.991> .PERIOD And 3 is at near 5 and so on let us see now how we insert these elements into the heap <sil=0.997> .PERIOD Let us say this is what was given to us <sil=0.926> .PERIOD So <sil=0.312> ,COMMA you start with initially there is an empty heap <sil=0.970> .PERIOD So <sil=0.452> ,COMMA you create a node with the number 6 where is the stored now this is stored at a of 1 how many elements are there in the heap there is only one element in the heap <sil=0.999> .PERIOD So <sil=0.593> ,COMMA you keep track of a variable called last and say last is pointing to 1 <sil=0.987> .PERIOD Last is being pointing to the newest element that has been inserted into the heap <sil=0.983> .PERIOD Next I want to insert 7 <sil=0.942> .PERIOD So <sil=0.393> ,COMMA what do I do I insert it at a of 2 initially then I find that because now what is happening now if I insert it here 7 and 6 when I compare what is happening the heap property is violated <sil=0.997> .PERIOD So <sil=0.400> ,COMMA what I do is I exchange these numbers I bring here 6 and 7 <sil=0.958> .PERIOD Next what do we have we have 15 right <sil=0.950> .PERIOD So <sil=0.594> ,COMMA now I insert initially 15 at this position I compare 15 and 7 I find that 15 is larger than 7 <sil=0.908> .PERIOD So <sil=0.318> ,COMMA I exchange 15 and 7 <sil=0.905> .PERIOD Next I want to insert 3 <sil=0.925> .PERIOD So <sil=0.539> ,COMMA where will I insert 3 initially this is a 1 a 2 a 3 suppose is the array implementation and at a 4 I will first insert this element then what do I do I compare this node with its parent and you find that it is in the correct order <sil=0.900> .PERIOD So <sil=0.320> ,COMMA I leave it as it is next I insert 2 <sil=0.999> .PERIOD Now <sil=0.470> ,COMMA 2 is also in the correct place with respect to its parent and next I insert 5 which will be in the correct place <sil=0.901> .PERIOD In the example that is given in the slide I give a slightly different example suppose I had inserted 2 earlier suppose it was there at this position in the tree then if I was inserting 5 then what will happen I will compare 5 with 2 its parent I find that 2 is smaller than 5 therefore <sil=0.383> ,COMMA I will move them and get this new tree <sil=0.923> .PERIOD So <sil=0.366> ,COMMA basically this is the idea of insertion into a heap <sil=0.901> .PERIOD Now <sil=0.432> ,COMMA let us see how long we took to insert a new element into the heap <sil=0.985> .PERIOD First when we inserted the element 6 there was only one element to be inserted therefore <sil=0.326> ,COMMA constant time is it then when we came to the second element we had to go one level down and so on how many elements were there in the heap at that time there were only 2 elements in the heap and we had to go height of 1 <sil=0.983> .PERIOD Now <sil=0.469> ,COMMA when I came to inserting the let us say I wanted to insert 3 for example <sil=0.577> ,COMMA then what happened now clearly what do I do I am initially putting it over here and comparing it suppose let us say instead of 3 I had to insert 25 or something in that let us say these were non-thing <sil=0.951> .PERIOD So <sil=0.599> ,COMMA I put 5 in the original position which is at the position of last <sil=0.984> .PERIOD So <sil=0.600> ,COMMA this is last this was last this was last this was last and finally <sil=0.633> ,COMMA now last is equal to 4 then what I do is I compare it with its parent then what do I do I move it to its position depending upon I keep comparing with this for example this is clearly larger than this therefore <sil=0.479> ,COMMA this should be above this then I compare with its parent I keep doing this until I reach the root in this particular case what will happen we will find at 6 will move here 15 will move here and 25 will move here <sil=0.911> .PERIOD So <sil=0.346> ,COMMA this is the idea of insertion into a heap how long did it take now there were 4 nodes and we had to go only 2 levels down or we had to basically do log in operations to insert an element into a heap it really makes a lot of difference when you have huge heaps especially jobs in a priority queue here is an implementation of the heap I have defined a class heap and I have given insertion into the heap notice that I have defined a priority heaps size basically an array of heaps size the heaps size can be fixed let us say can reallocate if you want there is insertion of element x as usual element type is defined by the user and delete root you always only the priority queue we only have to delete the root <sil=0.973> .PERIOD So <sil=0.648> ,COMMA now let us see what will be do if you have to delete this root because the highest priority element has to be served first then what will happen it will root less now <sil=0.959> .PERIOD So <sil=0.568> ,COMMA what we do is we take this put it over here so 3 will come here once 15 has been deleted and then what do we do we compare with its children clearly 3 is greater than 7 and it is also greater than 6 so 3 will come here 6 will come here and 7 will go here and this will be the new structure of the heaps <sil=0.969> .PERIOD So <sil=0.319> ,COMMA when you delete a particular element again how many elements did we do we took this last element moved it here moved to steps down so again the complexity of delete is also only log n <sil=0.922> .PERIOD So <sil=0.437> ,COMMA here is a C plus plus implementation and insertion what are we doing we incrementing the position last by 1 and what are we doing here we are checking where the priority of the given node is greater than the priority of I by 2 <sil=0.988> .PERIOD So <sil=0.393> ,COMMA greater than I by 2 wherever it is for example <sil=0.412> ,COMMA we put it in that particular position and moving all the other elements appropriately how are you finding the indices if this is I clearly if this is the notice that the index of the parent is 2 the index of the root this one index of its child is either 2 or 3 and index of 2 children is what now 4 or 5 and so on <sil=0.949> .PERIOD So <sil=0.373> ,COMMA given the index of the parent I can find the index of the child children and given the index of the children we can find the index of the parent this is possible only because I am implementing the priority queue as an array otherwise it will not be possible <sil=0.966> .PERIOD So <sil=0.472> ,COMMA what is the piece of code is simply doing is while I dot equal to 1 while looking at it is we are starting from last element and we are continuously checking trying to move up the tree depending upon where that particular node has to be inserted notice that we are starting from last <sil=0.974> .PERIOD So <sil=0.340> ,COMMA we are assigning to I priority I by 2 that means <sil=0.369> ,COMMA the element at I by 2 is replaced <sil=0.906> .PERIOD So <sil=0.362> ,COMMA basically if you are here if this one is smaller than what has been recently inserted you may move it one down the example I already talked about in the concept context of insertion and this is and you repeat that until you have reached the root node <sil=0.967> .PERIOD Now <sil=0.575> ,COMMA this is the deletion again what are we doing we are looking at basically first what we do is here we once again deletion means what the number of element is going to reduce by 1 <sil=0.921> .PERIOD First of course <sil=0.301> ,COMMA what we do is start with the parent as the root child as to the left child of root and we take the last element from the root and then perculate it that is what I said go back to the root and perculate it <sil=0.911> .PERIOD So <sil=0.379> ,COMMA what are we doing over here we first check which of the two children has higher priority and switch them because you want a higher priority node to move up to the root that is what we are saying is if I have 15 here and I have deleted 15 and this was 17 this was 14 this was let us say this was 12 and this was 14 then what I do is I want to make sure that 14 goes on top <sil=0.933> .PERIOD So <sil=0.522> ,COMMA that is the first thing that I do because this is being deleted so <sil=0.518> ,COMMA next element that must become root is 14 and that is what this step is doing over here it is comparing which of the two children have higher priority and then afterwards what does it do it keeps on finding out the child by taking parent times 2 because it is parent is i by 2 which we saw in the insertion case in the deletion case parent is at child is at parent start 2 <sil=0.994> .PERIOD So <sil=0.442> ,COMMA what we do is we essentially what are we doing over here we are essentially repeating this same process over here and we do the deletion of the given node again percolator is take the last element from the heap put it to the root and percolator down <sil=0.963> .PERIOD So <sil=0.385> ,COMMA that is all the rest 2 heaps and what is interesting is the complexity of the heap whether insertion or deletion is only a log n operation <sil=0.965> .PERIOD Now <sil=0.599> ,COMMA I want to think of some nice problems let us say I am giving you a heap and I want to do and let us look at some problems on heaps which I would like you to do think about this heap you are given a heap that is already there let us call it a max heap <sil=0.910> .PERIOD Now <sil=0.397> ,COMMA what I want you to do is I give you the index of a node given the index of a node problem 1 how do I change the priority priority of the node <sil=0.991> .PERIOD I want to give you one more problem let say I am given k sorted list I want to create 1 more <sil=0.981> .PERIOD 1 sorted list and I want you to use a priority queue to do this priority queue to do this let see how you can do these 2 problems <sil=0.947> .PERIOD Good morning class <sil=0.917> .PERIOD So <sil=0.495> ,COMMA far we have learnt about various ADTs namely the stacks <sil=0.605> ,COMMA queues <sil=0.325> ,COMMA lists and trees and today we are going to learn about another kind of ADT which is very popular especially in practice and the objective of this ADT is primarily as we already have seen in all the ADTs the objective is to put a set of items into the ADT or the object and retrieve items from the object <sil=0.950> .PERIOD And what is our objective in the process that whatever operations we perform in the ADT things are done very very fast <sil=0.970> .PERIOD Whether it is an insertion <sil=0.410> ,COMMA a deletion or modification this is what we have seen in the context of the mind research tree priority <sil=0.432> ,COMMA queue <sil=0.394> ,COMMA stack <sil=0.587> ,COMMA list <sil=0.937> ,COMMA queue whatever <sil=0.917> .PERIOD So <sil=0.609> ,COMMA now here today we are going to talk about a different type of an ADT where we keep the size of a table fixed and see if we can kind of retrieve the attributes of a particular item in the table in a very quickly <sil=0.938> .PERIOD We also want to modify the attributes of that particular item on name and we want to insert new names with its attributes <sil=0.564> ,COMMA deletion name and its attributes and all the speed like to see if we can how quickly can we do it <sil=0.911> .PERIOD The difference here is unlike the stack or the tree or the queue or the list here is a ADT where the size of the table is kind of fixed but it gives us very good performance and we will see this <sil=0.975> .PERIOD What we have seen depending upon the two retrieve items from a table you may say you know we could also use what we have already done the ideas can we do better and we have already seen whether it is in a binary search tree for example <sil=0.512> ,COMMA if you want to retrieve an item it was an unbalanced search tree then the time complexity is as high as order of the height of the tree <sil=0.994> .PERIOD Similarly in a list for example <sil=0.480> ,COMMA if you want to locate a particular item again it is as large as the length of the list there are n items in the list the time complexity can be out there <sil=0.919> .PERIOD What we are going to try and do is can we do better <sil=0.902> .PERIOD The area that I am going to talk about talk about you might have already guessed it is what is called a hash table and we basically use a hash function to access an element from a table <sil=0.906> .PERIOD There are two types of hashing static hashing and dynamic hashing I am going to talk about static hashing what is static hashing is all about is that the identifiers or names are stored in a fixed size table called the hash table <sil=0.992> .PERIOD The address or location often identifier x is obtained by computing some arithmetic function h on x <sil=0.914> .PERIOD So <sil=0.522> ,COMMA h of x gives the address of x in the table the hash table is partitioned into what we call b buckets and each bucket can hold a set of s records <sil=0.961> .PERIOD So <sil=0.440> ,COMMA the total number of items that can be show stored in a hash table is s b and h of x is a function that maps the set of possible integers to possible items into integers between 0 and b minus 1 <sil=0.979> .PERIOD The key can be anything any kind of string for that matter <sil=0.954> .PERIOD So <sil=0.607> ,COMMA we have a table here we call this the hash table let me call h t this has indices which go from 0 1 to up to b minus 1 and our objective is and it can be such that let us say these are the indices each index can store a set of items <sil=0.993> .PERIOD All right let me give you an example maybe little big what I am talking about over here h t is essentially an adding and it is consists of b buckets and the index of these buckets are 0 3 b minus 1 and each bucket can hold a set of identifiers <sil=0.967> .PERIOD Why does this happen essentially that if you are depending upon the kind of function that we have x is the identifier name and if I pass the identifier as argument to this function h it is possible that to identify map to the same bucket <sil=0.952> .PERIOD Haching is very effective and why is it effective because if you look at an identifier which is 6 characters long there are t you know 26 to the power of assuming that we are using the letters of the English alphabet we have 26 to 36 to the power of i distinct possible values for x but any application actually use a very small number fall fraction of these <sil=0.912> .PERIOD That is what we are saying is there are so many different possibilities for a 6 character identifier which is given by the expression t in this view graph but out of which only we in a application you are going to use a very small fraction of them <sil=0.970> .PERIOD So <sil=0.501> ,COMMA identifier density is defined as if there are n identifiers and total t is a total number of possible identifiers then n by t is what is called the identifier density <sil=0.963> .PERIOD Then if there are b buckets in the table and each bucket can hold a set of identifiers the loading factor alpha is total number of identifiers divided by the total number of items that can be held in the stable <sil=0.934> .PERIOD For example <sil=0.612> ,COMMA let us say I have bucket 0 to b minus 1 in this example let us say each bucket can hold 2 identifiers that is what we mean over here that is s here and b is the total number of buckets and that is what you can hold <sil=0.975> .PERIOD We define what are called synonyms if h of i1 i1 is a particular key value i2 is another key value identifier value name value whatever may be I am using all of these interchangeably here then we say that 2 identifiers are synonymous if both of them hash to the same value <sil=0.909> .PERIOD Then we also define what is called an overflow it is possible that a new identifier i it has only 2 slots suppose it has to this then we do not have a space to keep it here because each bucket can only hold 2 items in this example then we define overflow when an identifier has to do a full bucket then we call it a collision when 2 not an identical identifiers has to the same value which is almost like a synonym here and how do we handle the problem <sil=0.936> .PERIOD So here is an example we have a hash table with 26 buckets and 2 slots per bucket notice the indices over here the indices go from 0 to 25 and what I am doing is let us say I am using the first letter of the identifier to put it into the particular bucket and what I used the each slot for example is defined by the first letter in the given identifier or key value <sil=0.984> .PERIOD So 0 goes into slot into the bucket 0 <sil=0.537> ,COMMA B goes into the bucket 0 B goes into the bucket 1 <sil=0.312> ,COMMA C goes into the bucket 2 and so on and Z goes into the bucket 25 and each bucket can hold 2 identifiers <sil=0.980> .PERIOD So here I have a and a 2 and here in d I have only 1 element g a and g are 2 identifiers which are stored in the 6 slot and the notice that there are lot of empty slots <sil=0.959> .PERIOD This is one thing about a hash table that you can have as we said identifier the number of identifiers which can be stored in R stored in a hash table and a total size of the hash table notice that we only have 5 identifiers but we have 26 into 2 slots therefore we identified density the loading factor on this hash table is very small <sil=0.928> .PERIOD Now obviously what would we like X is an identifier let us say you know some variable name called let us say I have a variable X non 0 or something like that <sil=0.951> .PERIOD Okay a variable name like this and this has to be or an identifier name which has to be hashed into this then I also have let us say Y non 0 and so on <sil=0.961> .PERIOD I am using 7 characters in this particular example <sil=0.955> .PERIOD Now what we want I can have a huge hash table what we would like is and so I am on this H of X and H of operating with the function hash function H of X on it <sil=0.940> .PERIOD So H operates on this string operates on this string and gives me an index this let us say gives me I 1 and this gives me I 2 <sil=0.963> .PERIOD What would be ideally like if the 2 identifiers in this case for example X non 0 and Y non 0 are different okay different by 1 character right <sil=0.967> .PERIOD What we would like is the hash function should be such that it spreads these keys as much as possible on the table <sil=0.943> .PERIOD Why so if X non 0 and Y non 0 hash to the same index there will be a collision and what am I going to do <sil=0.980> .PERIOD So maybe I will put X non suppose it hashed here 0 and I put Y non 0 after this <sil=0.980> .PERIOD So next time if I want to retrieve this particular item once again I am giving Y non 0 or X non 0 and it will come to this and then to access Y non 0 I have to go through this bucket and look at the second element in the bucket <sil=0.908> .PERIOD So what we would like is if I the keys are distributed as uniformly as possible on this hash table the performance of the hash table can be very very good okay <sil=0.974> .PERIOD So crucial part in this hash table definition is what is called hash function which transforms or identifier or a name X into its bucket address <sil=0.939> .PERIOD There are number of different techniques and if you look at Kanut's book on the art of programming he has a whole lot of hash functions that he has defined <sil=0.992> .PERIOD Midsquare for example square the identifier that means you converting it to the integer square the identifier then use an appropriate number of bits from the middle to obtain the bucket address this is one division divide identifier that is compute the remainder and access divided by on this is the most popular and that you will also see in the example problem that is given and use this as the hash to hash <sil=0.940> .PERIOD Folding is partition identifier into different parts add partitions and use the status <sil=0.999> .PERIOD So number of different hash functions that people have come up with to ensure that the keys in a given application are distributed as uniformly as possible <sil=0.967> .PERIOD Another variant which is not part of the beyond the scope of this particular course is what is called dynamic hashing <sil=0.921> .PERIOD As number of items to be stored increases the performance of static hashing because the size is small deteriorate showing to collision the hash table must be extendable dynamically which I do not want to talk about in this course but you should know about it okay <sil=0.991> .PERIOD So let us do an analysis of hashing how good is a hash function <sil=0.970> .PERIOD So I am going to take a particular hash function assume that there are k items and the table sizes n then the probability of hitting a free location the first time is 1 minus k over n okay because there are already k items and I want to choose one of the locations where the k items are not present <sil=0.997> .PERIOD So in general what we can do is the probability PI of an insertion requiring I probes assuming that the collision handling mechanism what it does is let us say the first time you when you hash this when you ran h of x for x of 0 and y of non 0 it came to the same location <sil=0.950> .PERIOD Then hopefully the next time when I make a probe and let us say this already full it will distribute it says that this location is not used and it accesses the other locations then we have that so basically what do we have here probabilities n minus 1 minus k over n that is what we saw <sil=0.913> .PERIOD The second time it is collided with this k by n and then there are we assume that it is not using any of them say n minus k by n minus 1 one of these it is collided so it is choosing the rest of the locations and p 3 for example k by n k minus 1 n minus k and so the third probe the first probe the second probe the third probe that it hits a free location and we can define this as for the I th probe <sil=0.993> .PERIOD Now let us compute the expectation of this of the k plus 1 of expectation is basically I p I and the table size is n and the number of keys in the table is n then we can find you overall average number of probes that are required to insert an element number of probes that are required to insert an element search for an element whatever it may be there is small expression over here which says how you get this complexity and it turns out this value of E the expected number of probes is minus 1 over alpha log of 1 minus alpha what is alpha now alpha is the total number of m is the total number of keys which are present divided by n plus 1 and it is called the loading factor of the hash table here is an example alpha is let us say the loading factor notice that point 1 means you have 10 percent full point 2 5 means 25 percent full 0 <sil=0.998> .PERIOD 5 is 50 percent full 0 <sil=0.906> .PERIOD 75 is 75 percent full 95 percent full 99 percent full and so on <sil=0.997> .PERIOD What do we mean by that where I look at this particular table I have only 5 elements out of 52 here so that is the percentage of items that have been stored in the hash table what is it giving here is that it is telling me that if the hash table is having only about 10 percent of identifiers which are present 25 percent of the identifiers that are present this is giving me the expected number of probes and what is very interesting to see is that even if the hash table is 95 percent full if you have a good function such that it redistributes the keys against such that it not using that particular location then we can see that the hash function gives for example even when the hash function if the table is 99 percent full it only requires 4 <sil=0.944> .PERIOD 66 probes on the average or 4 5 probes on the average I wanted to compare this with a binary search tree a balanced binary search tree with a large number of items <sil=0.992> .PERIOD So <sil=0.424> ,COMMA it basically it is going to depend upon even a few assume a balanced binary search tree and if the number of items is very large then the depth is divided defined by log in <sil=0.974> .PERIOD So <sil=0.405> ,COMMA let us see I have 1024 items and then I am going to have 10 steps to identify me to determine the location of that particular element what is nice about the hash table is notice that it does not talk about the number of elements it only talks about the loading factor what is the loading factor this is the size of the table how many items are stored in the table a ratio of the number of items that are stored in the table to the size of the table ok <sil=0.985> .PERIOD Now <sil=0.598> ,COMMA this is for a very good hash function another hash which I just showed you here this is called kind of linear probing what we do is it has to the same value and we probe at that particular location let us say these are consecutive locations and we search for the particular element <sil=0.957> .PERIOD So <sil=0.621> ,COMMA for example <sil=0.637> ,COMMA if it has to the same value x drawn 0 is not what I wanted y non 0 is not is what I want <sil=0.959> .PERIOD So <sil=0.474> ,COMMA it access this item and it was not it and it has to do one more probe to find out what the element is this is called linear probing and if we did this then there are two ways of doing this in a hash table for example <sil=0.345> ,COMMA so let us say 0 through let us say I have a whole huge hash table like this whatever it may be of size s b then one kind of hashing scheme let us say these are the this is the location at which it hashes to let us say <sil=0.956> .PERIOD So <sil=0.303> ,COMMA it can be any number of elements 0 through s b minus 1 here then what we do is we run the hash function it let us say maps to one of these then what you do is suppose is already filled then you find the next nearest empty location and put the element ok this is actually called linear probing this one we are doing it <sil=0.979> .PERIOD Now <sil=0.306> ,COMMA the one is you divide the hash table into buckets like we have done here to b minus 1 and at each location have what is called a linked list ok <sil=0.935> .PERIOD So <sil=0.450> ,COMMA this is let us say the first element in this example let us say here this is where we saw it <sil=0.972> .PERIOD So <sil=0.577> ,COMMA let us say this was x non 0 and at its attributes at then this is going to point to y non 0 ok and so on <sil=0.932> .PERIOD So <sil=0.383> ,COMMA basically what we are saying is we have an array of lists over here this list need not necessarily be implemented using a linked list it can also be implemented using an array which we have already seen <sil=0.994> .PERIOD So <sil=0.491> ,COMMA you have hash table which is an array of lists and whenever there is a collision it is going to keep on adding a new element to this list <sil=0.999> .PERIOD This is a different this is one type of hashing is also using linear probing here in the other hand what you do is you have one long table and on this long table if the first if a location is already occupied then you linearly go down find out what is the empty location and put it there <sil=0.907> .PERIOD So <sil=0.488> ,COMMA when you are searching for an element what do you do you search for that particular element it hashes to this and then from there you linearly search and find out where the element is ok <sil=0.931> .PERIOD So <sil=0.342> ,COMMA you can do various types of hash functions so the crucial properties on designing the hash function and what is interesting is suppose we use linear hashing there is a proof which says that if alpha is the loading factor then expected number of probes is this <sil=0.972> .PERIOD I wanted to look at this table this is very very exciting in the sense that again here 10 percent 25 percent 50 percent 75 percent 90 percent and so on and you find that it actually requires only about 10 probes even when the hash table is about 99 percent full and remember 99 percent full does not mean that your the that the number of elements is fixed can have any number of elements but the identifiers number of identifiers that are stored in that table the loading factor should can be even up to that much <sil=0.965> .PERIOD So <sil=0.356> ,COMMA there is something about hashing hashing is a very very powerful technique for storage and retrieval of keys it has been extensively used primarily because of its speed and especially if the size of the table can be adjusted <sil=0.964> .PERIOD There are algorithms today for re adjusting the size of the table well table become 75 percent full you double the size of the table redistribute the keys with a again you need a good hash function which will redistribute it uniformly and you can show that the amortized analysis of that is just about order one <sil=0.945> .PERIOD So <sil=0.471> ,COMMA this is something which is very exciting about hash tables the primary issue with hashing is deletion it is a little combustion because let us say I found this item here I did not find my item I have to continue to linearly probe and once I delete the item there might be an empty slot and we have to worry about this how do you handle this <sil=0.942> .PERIOD So <sil=0.548> ,COMMA what we have talked about is a special type of an abstract data type and this is called a symbol table ADT and it is very popular where you have strings which get mapped into locations and each key for example <sil=0.523> ,COMMA can have a whole lot of attributes which can be very quickly unwritten in fact <sil=0.629> ,COMMA you can have a hash table of objects it is very common hash table of function pointers the very common to see in practice which makes these speeds of algorithms very very good very efficient especially in practical applications <sil=0.940> .PERIOD So <sil=0.329> ,COMMA we will stop here this completes the lecture on hash tables <sil=0.962> .PERIOD So <sil=0.419> ,COMMA we in lecture 2 <sil=0.531> ,COMMA we will now look at conditional statements <sil=0.927> .PERIOD So <sil=0.383> ,COMMA as I explained earlier <sil=0.396> ,COMMA conditional statements are of two kinds <sil=0.409> ,COMMA they are of the if the null kind or the switch case kind <sil=0.907> .PERIOD So <sil=0.619> ,COMMA we will start with the conditional statements <sil=0.921> .PERIOD These are also called selection statements for the reason that you actually have an expression based on the evaluation of the expression <sil=0.401> ,COMMA you actually select what should be done <sil=0.993> .PERIOD So <sil=0.568> ,COMMA for example <sil=0.371> ,COMMA there is the single selection statement <sil=0.909> .PERIOD So <sil=0.465> ,COMMA let us see this example if attendance is less than 75 grade equals W <sil=0.910> .PERIOD So <sil=0.628> ,COMMA what this is really doing is this if attendance is less than 75 <sil=0.569> ,COMMA if the class attendance is less than 75 percentage <sil=0.406> ,COMMA grade is withdrawn that is what the statement is supposed to be <sil=0.958> .PERIOD So <sil=0.412> ,COMMA if attendance is less than 75 grade equals W <sil=0.982> .PERIOD So <sil=0.359> ,COMMA this is an this does not have any other choice <sil=0.443> ,COMMA there is no else here <sil=0.996> .PERIOD So <sil=0.400> ,COMMA this is a single selection statement <sil=0.936> .PERIOD So <sil=0.436> ,COMMA you choose to assign W to grade or not depending on this expression <sil=0.539> ,COMMA attendance less than 75 <sil=0.937> .PERIOD If attendance is actually greater than equal to 75 <sil=0.430> ,COMMA this assignment will not be chosen for execution <sil=0.336> ,COMMA which means it will not be executed <sil=0.942> .PERIOD So <sil=0.475> ,COMMA this is a single selection statement <sil=0.930> .PERIOD A double selection statement on the other hand has two things that you could do <sil=0.414> ,COMMA you could have if marks less than 40 <sil=0.429> ,COMMA 40 <sil=0.941> ,COMMA past equals 0 <sil=0.352> ,COMMA else past equals 1 <sil=0.980> .PERIOD So <sil=0.353> ,COMMA you have two statements past equals 0 and past equals 1 and one of them will be executed depending on the choice of marks <sil=0.996> .PERIOD So <sil=0.401> ,COMMA if marks is less than 40 <sil=0.592> ,COMMA past equals 0 will be executed <sil=0.446> ,COMMA otherwise past equals 1 will be executed <sil=0.957> .PERIOD So <sil=0.587> ,COMMA there is a semicolon missing here that has to be included and otherwise it can be a switch statement where it is multiple selection <sil=0.929> .PERIOD So <sil=0.555> ,COMMA you have single selection <sil=0.358> ,COMMA you have double selection or you have multiple selection <sil=0.952> .PERIOD So <sil=0.342> ,COMMA we will first see the single selection and double selection in gore details before we go into the switch <sil=0.984> .PERIOD Let us look at the basic structure of a if statement <sil=0.950> .PERIOD So <sil=0.625> ,COMMA the if statement is starts with this keyword called if followed by an expression followed by a block called statement 1 <sil=0.925> .PERIOD Optionally <sil=0.370> ,COMMA it can also have the else clause under block for the else clause called statement 2 <sil=0.955> .PERIOD So <sil=0.504> ,COMMA the meaning of this is if expression evaluates true statement 1 will be executed <sil=0.946> .PERIOD So <sil=0.422> ,COMMA the statement 1 is remember it is a compound statement it is not a single statement <sil=0.513> ,COMMA STMT1 is supposed to be a compound statement <sil=0.969> .PERIOD So <sil=0.465> ,COMMA compound statement will be 1 will be executed if the expression evaluates false this statement 2 will be executed <sil=0.921> .PERIOD So <sil=0.352> ,COMMA STMT1 and STMT2 are usually blocks of code need not be just single line code <sil=0.446> ,COMMA even though single line code is acceptable need not be single statement code <sil=0.985> .PERIOD So <sil=0.356> ,COMMA the else part is completely optional and that is what we have when we have this square brackets here <sil=0.992> .PERIOD Square bracket is not part of the syntax it is just to tell you that everything that comes within square bracket is optional here <sil=0.942> .PERIOD So <sil=0.458> ,COMMA if there is no else part in the statement this becomes a single selection statement and if the expression evaluates to true statement 1 will be executed <sil=0.983> .PERIOD Otherwise the statement would have no effect <sil=1.000> .PERIOD So <sil=0.638> ,COMMA what it really does in terms of execution of programmers <sil=0.988> .PERIOD Let say I do not have any of these selection statements you have a series of simple statements <sil=0.931> .PERIOD If you start from let say line 1 you will do line 2 line 3 so on up till line n the last line in the program and exit <sil=0.931> .PERIOD So <sil=0.315> ,COMMA this is a sequential structure whereas <sil=0.372> ,COMMA once you have selection statements it could change the flow of the program <sil=0.902> .PERIOD So <sil=0.568> ,COMMA let us say there is some piece of code here in this blue dot here and you evaluate an expression which is indicated by the diamond <sil=0.961> .PERIOD If the condition evaluates to true you execute a block of statement in the true branch and if the condition evaluates to false you do not do anything and either way after executing this you come here or if the condition is false you come here <sil=0.951> .PERIOD So <sil=0.329> ,COMMA this branch that you have here over the true case will not happen if the expression evaluates to false and it will go to this blue dot <sil=0.969> .PERIOD So <sil=0.551> ,COMMA this is a single selection statement you choose to execute this true block or not depending on the expression here <sil=0.916> .PERIOD Then there is this other type which is the double selection statement you have a body of code here and after that you evaluate an expression <sil=0.933> .PERIOD So <sil=0.557> ,COMMA this body of code could be scanning something from the user or some other program some other piece of program that you have written before you evaluate an expression <sil=0.955> .PERIOD Now there are two choices either true or false if the condition evaluates to true you execute the right block if the condition evaluates to false you execute the left block and once you execute one of these blocks you come and execute this blue block of code which is after the if statement <sil=0.934> .PERIOD So <sil=0.522> ,COMMA this is the general structure of if then else <sil=0.919> .PERIOD So <sil=0.591> ,COMMA let us look at several examples now <sil=0.959> .PERIOD So <sil=0.499> ,COMMA starting with example one where there is no else class <sil=0.932> .PERIOD So <sil=0.431> ,COMMA let us say the problem that I want you to solve is given a number find out if it is a multiple of 3 <sil=0.947> .PERIOD So <sil=0.478> ,COMMA I give you a number x and you have to find out whether it is a multiple of 3 if it is a multiple of 3 then print it on the screen print that it is so on the screen <sil=0.903> .PERIOD So <sil=0.354> ,COMMA the equivalent code segment would be if x percentage 3 equal to equal to 0 print f x is a multiple of 3 <sil=0.906> .PERIOD So <sil=0.320> ,COMMA this print f is a simple statement here and this if is a compound statement which contains only one selection if the condition is true it will print this on the screen if the condition is false it will not do anything <sil=0.930> .PERIOD So <sil=0.358> ,COMMA remember this percentage as the model operator that are introduced in lecture 1 right this percentage 3 means you are looking at x mod 3 and this is something that is new here which is this equal to equal to <sil=0.950> .PERIOD So <sil=0.623> ,COMMA this equal to equal to is essentially an operator in c with checks for equality a single equal to symbol is useful for expression evaluation <sil=0.975> .PERIOD So <sil=0.516> ,COMMA we did this in the previous lecture <sil=0.918> .PERIOD So <sil=0.433> ,COMMA p 2 equal something p 1 equal something and so on <sil=0.901> .PERIOD So <sil=0.596> ,COMMA you evaluate something on the right side and assign it to the left side <sil=0.956> .PERIOD But if you have 2 equal to symbols right after the other that is checking for equality <sil=0.976> .PERIOD So <sil=0.640> ,COMMA the meaning of this expression is if x modulo 3 is equal to 0 then do this else there is no else statement here <sil=0.945> .PERIOD So <sil=0.306> ,COMMA if this condition is true this statement will be executed <sil=0.948> .PERIOD Let us move to another example where there is no else clause but it is a compound block <sil=0.938> .PERIOD So <sil=0.434> ,COMMA if the given number is multiple of 3 let us say you want to ask the user for another input right <sil=0.951> .PERIOD So <sil=0.590> ,COMMA if x percentage 3 is 0 you not only want to tell the user that x is a multiple of 3 you also want the user to enter another number and you should be able to scan it <sil=0.959> .PERIOD So <sil=0.399> ,COMMA if x percentage 3 equal to equal to 0 then so <sil=0.336> ,COMMA the then block is between this and this brace <sil=0.967> .PERIOD So <sil=0.577> ,COMMA print f x is a multiple of 3 please enter another number <sil=0.936> .PERIOD So <sil=0.444> ,COMMA you are prompting the user to enter another number since the user is expected to enter another number you have to scan it scan f percentage d and f percentage x <sil=0.909> .PERIOD So <sil=0.607> ,COMMA this is a collection of 2 simple statements that goes into a code block and if this condition is true we have a logical collection of statements here or a logical sequence we not only want to print we also want the user to enter another input <sil=0.935> .PERIOD So <sil=0.487> ,COMMA you need a brace because there are two simple statements inside <sil=0.910> .PERIOD So <sil=0.618> ,COMMA you have there is a little bit of warning that I want to give here say let us say I want to say I will solve the same problem but if I left out the braces that is what you are seeing here <sil=0.916> .PERIOD If x percentage 3 is 0 then I have left out the brace here and here <sil=0.963> .PERIOD So <sil=0.376> ,COMMA from the view of the compiler the if statement x percentage 3 equals to 0 print f that means instead of becoming a compound statement with two lines of a simple statements it instead becomes one compound statement of if only this print f is evaluated if this condition is true and this can of statement is executed unconditionally <sil=0.925> .PERIOD So <sil=0.443> ,COMMA what I mean by that is this print f will happen only if x percentage 3 is actually 0 or if x is a multiple of 3 and this can of will happen no matter x is model 3 x is model 3 is 0 or not <sil=0.929> .PERIOD So <sil=0.596> ,COMMA scan of statement is actually outside the if condition even though it is formatted in such a way that this print f and scan of seems to be inside the if block the compiler does not care about the spacing that you have given here this can of is actually is outside the if condition here <sil=0.953> .PERIOD So <sil=0.603> ,COMMA the result the result would be the the user will have to enter a number even if x is not a multiple of 3 and that is not what we wanted we wanted the user to enter a number enter a new number only if x is a multiple of 3 otherwise we want to do something else with it <sil=0.969> .PERIOD So <sil=0.322> ,COMMA the simple thumb rules use the left hand right brace to enclose if and else blocks and I typically use it even if there is only one single statement inside this will save several headaches the program can become slightly undreadable because you have too many of these left hand right braces <sil=0.938> .PERIOD However <sil=0.587> ,COMMA it will cause you lesser headaches <sil=0.968> .PERIOD So <sil=0.605> ,COMMA that is why if you go back to my lecture 1 you will see that this if then else clause that I had even though there were only single statements inside I always enclose them within braces <sil=0.962> .PERIOD Let us look at another example with then else clause here <sil=0.986> .PERIOD So <sil=0.336> ,COMMA if the given number is a multiple of 3 ask for another number otherwise let us say I want to thank the user <sil=0.950> .PERIOD So <sil=0.442> ,COMMA if x percentage 3 equal to 0 then you print this on the screen and you scan the another input <sil=0.963> .PERIOD So <sil=0.474> ,COMMA this is one logical condition now you have multiple selection though or double selection else <sil=0.913> .PERIOD So <sil=0.535> ,COMMA if this is not true you print if thank you right <sil=0.953> .PERIOD So <sil=0.305> ,COMMA this is the structure for else and we have seen this before in our lecture 1 also <sil=0.911> .PERIOD So <sil=0.564> ,COMMA one word of caution here <sil=0.955> .PERIOD So <sil=0.323> ,COMMA just because you are scanning here it does not mean that the user would enter a number which is not a multiple of 3 the user may still enter a number which is multiple of 3 we are not checking here <sil=0.906> .PERIOD So <sil=0.616> ,COMMA I want to show this program just to show the structure of if then else <sil=0.919> .PERIOD So <sil=0.582> ,COMMA at the end here x could still be a multiple of 3 <sil=0.974> .PERIOD So <sil=0.322> ,COMMA you need a mechanism by which you repeatedly scan the input here till the user input something else if that is what you want in this case we are not checking for that I just want to show you the structure of if then else <sil=0.986> .PERIOD So <sil=0.425> ,COMMA there are 2 other useful collection of if statements <sil=0.907> .PERIOD So <sil=0.344> ,COMMA one that you see on the left side is what is called a cascading if else and one that you see on the right side is the case of what is called nested if else <sil=0.949> .PERIOD So <sil=0.547> ,COMMA in the cascading if else case what you have is if expression 1 evaluates to true you do a you execute a block of statements in the else clause you actually evaluate another expression else if expression 2 evaluate you execute another block of code else if expression 3 you execute another block of code and so on <sil=0.968> .PERIOD You can have a series of this else statements ending with a final else clause where you execute another block of code <sil=0.940> .PERIOD So <sil=0.541> ,COMMA this is called cascading if else we will see a quick example later <sil=0.956> .PERIOD The other case is nested if else <sil=0.936> .PERIOD So <sil=0.578> ,COMMA we have if expression 1 do a block of code if expression 2 do a block of code and so on <sil=0.958> .PERIOD So <sil=0.636> ,COMMA what happens here is this block of code or this block or this block only one of them will execute depending on the conditions for expression 1 <sil=0.433> ,COMMA expression 2 and so on <sil=0.933> .PERIOD So <sil=0.420> ,COMMA if expression evaluates to true this block of code will execute and none of this will get executed if expression 1 is false and if expression 2 is true only this block will get executed and so on <sil=0.959> .PERIOD So <sil=0.631> ,COMMA in this cascading if else case there is only one block which will really execute not all of them <sil=0.940> .PERIOD However <sil=0.607> ,COMMA if both expression 1 and expression 2 are true both this block and that block will be executed here <sil=0.983> .PERIOD So <sil=0.310> ,COMMA what is really happening is if you notice if expression 1 there is a curly brace here and there is a curly brace here between these two curly braces is if expression 2 which means this is a compound statement which is within another compound statement <sil=0.970> .PERIOD So <sil=0.455> ,COMMA this is completely contained within the evaluation of this expression <sil=0.965> .PERIOD So <sil=0.393> ,COMMA therefore <sil=0.542> ,COMMA this block of code as well as this statement will be executed if expression 1 is true <sil=0.981> .PERIOD So <sil=0.316> ,COMMA let us see an example of cascading if let us say I am grading your course and let us say this is my grading policy <sil=0.923> .PERIOD If you get below 50 marks in the exam you get a D grade if you get between 50 and 59 you get C if you get 60 to 75 you get B and 75 and above will be A <sil=0.946> .PERIOD Let us say this is my grading policy for the course then I have the integer marks and I have the character grade <sil=0.906> .PERIOD So <sil=0.485> ,COMMA marks is something that you are going to enter and grade is something that I am going to assign from the program <sil=0.980> .PERIOD So <sil=0.602> ,COMMA you see this structure here if marks is less than or equal to 50 then grade is D <sil=0.909> .PERIOD So <sil=0.517> ,COMMA if it is less than or equal to 50 I assign the grade D else if marks is less than or equal to 59 then grade is C else if marks is less than or equal to 75 grade is B else grade is A <sil=0.924> .PERIOD So <sil=0.381> ,COMMA what is happening is we are seeing only one of these will be true if you enter a mark here only one of these things will be true and only one blob of code will execute either you will get grade equal to D or C or B or A you can never have a case where more than one assignment happens <sil=1.000> .PERIOD So <sil=0.447> ,COMMA if my mark is 40 then this if condition is true then the grade would be D if the mark is 65 then if this expression will evaluate to far falls this expression will also evaluate to falls this expression will evaluate to true you will get grade B <sil=0.965> .PERIOD So <sil=0.510> ,COMMA this is the structure of cascading if and these are simple statements therefore <sil=0.336> ,COMMA I have not put braces but putting braces is always recommended <sil=0.910> .PERIOD So <sil=0.638> ,COMMA there should have been a brace here and a brace here there should have been a brace here and brace here and so on <sil=0.916> .PERIOD And <sil=0.436> ,COMMA next if we saw this segment earlier if A is greater than B and of A is greater than C print of A is the largest else print of C is the largest and there is some other blob of code that comes as else <sil=0.917> .PERIOD So <sil=0.343> ,COMMA I am just showing one segment of the maximum of 3 numbers <sil=0.912> .PERIOD So <sil=0.373> ,COMMA if you are in doubt go back to lecture 1 and look at the code we already used an estadestatement inside the code there <sil=0.941> .PERIOD You should be a bit cautious about the use of the else clause <sil=0.943> .PERIOD So <sil=0.561> ,COMMA let us say I did this if marks is greater than 40 and within that if true condition I have if marks is greater than 75 print of you got distinction else print of sorry you repeat the course <sil=0.962> .PERIOD Let us say this is what we have right <sil=0.976> .PERIOD So <sil=0.353> ,COMMA what we really want to do is if somebody got less than 40 we want to tell them that they have to repeat the course <sil=0.339> ,COMMA but let us see what happens here <sil=0.929> .PERIOD So <sil=0.489> ,COMMA if you start with this estadement there is an expression here marks greater than 75 print of you got distinction <sil=0.919> .PERIOD If marks is less than 75 even if it is greater than 40 what happens is this else clause attaches itself with this if clause and not with this if clause <sil=0.945> .PERIOD So <sil=0.341> ,COMMA else always attaches itself to the nearest statement nearest if statement without the else clause <sil=0.955> .PERIOD So <sil=0.421> ,COMMA because of that what happens is let us say my mark was actually 65 it is not greater than 75 <sil=0.947> .PERIOD So <sil=0.589> ,COMMA I do not get distinction <sil=0.974> .PERIOD However <sil=0.526> ,COMMA I will be asked to repeat the course which is not what we intended <sil=0.909> .PERIOD What we really intended is this if marks is greater than 40 and if the marks is greater than 75 print if you got distinction and the else should have been for the this if condition <sil=0.979> .PERIOD So <sil=0.370> ,COMMA since else always attaches itself to the nearest if not having this brace here even though it is just one single statement here not having this brace here would result in something that you do not desire to have <sil=0.959> .PERIOD So <sil=0.588> ,COMMA be cautious about this that is why I said whenever you have an if condition if you automatically put braces and for else also if you automatically put braces none of these confusions will occur <sil=0.901> .PERIOD So <sil=0.622> ,COMMA go back to my basic thumb rule if true block should have braces else false block should have block should have braces by default and that will help in getting rid of all these headaches <sil=0.989> .PERIOD So <sil=0.314> ,COMMA finally let us look at the switch statement which is a multi way decision statement <sil=0.902> .PERIOD So <sil=0.550> ,COMMA in a multi way decision statement it is not a single decision or a double decision it could be more than one or less more than two decisions <sil=0.930> .PERIOD The basic syntax is you have this keyword switch followed by an expression which is within parenthesis and you have braces <sil=0.976> .PERIOD So <sil=0.607> ,COMMA again this is a block of code <sil=0.975> .PERIOD So <sil=0.502> ,COMMA switch is a compound statement and it can contain several cases <sil=0.974> .PERIOD So <sil=0.491> ,COMMA you have case constant expression statements case constant expression statements and so on you can have several cases and you can also have an optional default clause and an optional default say essentially what happens is if you have multiple choices depending on the value of expression whichever evaluates to true those statements will get executed <sil=0.988> .PERIOD If none of these expressions evaluate to true then the default clause will kick in and this set of statements will get executed <sil=0.920> .PERIOD So <sil=0.454> ,COMMA let us see examples <sil=0.972> .PERIOD So <sil=0.358> ,COMMA let us say I have a character C and I read this character from the user <sil=0.963> .PERIOD If the character is one of R <sil=0.603> ,COMMA B and Y I want to print something on the screen <sil=0.988> .PERIOD So <sil=0.318> ,COMMA if the user input capital R as an input I want to print F red <sil=0.923> .PERIOD If the user inputs B I want to print F blue <sil=0.960> .PERIOD If the user inputs Y I want to print F yellow <sil=0.949> .PERIOD So <sil=0.562> ,COMMA if you look at this there is a switch C followed by braces followed by one or more case statements <sil=0.938> .PERIOD The case then there is a constant expression here R <sil=0.552> ,COMMA B or Y followed by a colon and there is a statement here <sil=0.961> .PERIOD So <sil=0.631> ,COMMA that is the structure here <sil=0.977> .PERIOD So <sil=0.336> ,COMMA switch followed by expressions and there is something within the curly braces you have case constant expression colon statements <sil=0.993> .PERIOD So <sil=0.582> ,COMMA you can see that this program is following that structure <sil=0.954> .PERIOD Now <sil=0.595> ,COMMA let us see what this constant expression is about <sil=0.977> .PERIOD So <sil=0.516> ,COMMA this R <sil=0.540> ,COMMA B and Y are not variables <sil=0.958> .PERIOD So <sil=0.320> ,COMMA when you when you put something within single codes you are actually looking for the character R or character B or character Y <sil=0.923> .PERIOD This is these are not variables R <sil=0.573> ,COMMA B <sil=0.428> ,COMMA Y <sil=0.960> .PERIOD So <sil=0.452> ,COMMA remember variables are those that can change value during the execution of the program <sil=0.981> .PERIOD Whereas <sil=0.508> ,COMMA these are constants they cannot change their values during the execution of the program <sil=0.929> .PERIOD So <sil=0.540> ,COMMA C is a variable but within codes R <sil=0.586> ,COMMA within codes B and within codes Y are all character literals they cannot change their values <sil=0.909> .PERIOD So <sil=0.357> ,COMMA what you are looking for is if C the character that you got from the user is one of these then one of these statements should execute <sil=0.931> .PERIOD The other thing that is new here is this notion called break <sil=0.903> .PERIOD So <sil=0.384> ,COMMA what happens with these switch clauses if R is true then it prints then it prints red and you put the break so that you do not want any of these other printfs to execute or even the conditions to be checked <sil=0.940> .PERIOD So <sil=0.542> ,COMMA if you have printf red and you print the red and you are now out of the switch clause if you put a break here <sil=0.911> .PERIOD So <sil=0.343> ,COMMA this is something that is new <sil=0.970> .PERIOD So <sil=0.516> ,COMMA these are the choices that you put in R <sil=0.450> ,COMMA B and Y and this break breaks away from the switch statement to outside the switch statement <sil=0.927> .PERIOD So <sil=0.460> ,COMMA it starts executing block of code after the switch statement <sil=0.906> .PERIOD So <sil=0.303> ,COMMA let us look at another example where we want to handle both lower and upper case choices <sil=0.923> .PERIOD Maybe I as a user enter lower case or upper case I want to handle both of them <sil=0.943> .PERIOD So <sil=0.413> ,COMMA this is also something that you can do with switch statements <sil=0.935> .PERIOD So <sil=0.330> ,COMMA these two lines are as or as before this is also as before the changes in these three lines here to here <sil=0.986> .PERIOD So <sil=0.635> ,COMMA if you look at case R or case R the lower case R in both these cases we want to printf red <sil=0.997> .PERIOD So <sil=0.332> ,COMMA I could write this as case capital R printf red break case small case R printf red break and so on <sil=0.973> .PERIOD But we are executing the same set of statement for both these choices small case R and upper case R <sil=0.945> .PERIOD So <sil=0.336> ,COMMA therefore <sil=0.551> ,COMMA if you have a series of choices for which you want to execute the same set of statements you can just put them back to back and have this set of statements exactly once <sil=0.959> .PERIOD The same thing we have here for both upper case B and lower case B we want to print blue <sil=0.904> .PERIOD So <sil=0.487> ,COMMA therefore <sil=0.398> ,COMMA this set of statements is common for both upper and lower case B <sil=0.924> .PERIOD Similarly <sil=0.556> ,COMMA this set of statements is true for both upper and lower case Y <sil=0.910> .PERIOD So <sil=0.615> ,COMMA one thing that you should also notice here is the last statement here does not have a break because anyway it is the last condition you are checking automatically after checking these conditions if both these are true it will execute this and come out of the switch <sil=0.975> .PERIOD If these are false you will anyway come out of the switch statement a break is not required in the last choice of case <sil=0.958> .PERIOD So <sil=0.584> ,COMMA there are two things that you have to watch out in the switch cases <sil=0.977> .PERIOD So <sil=0.425> ,COMMA one warning is that variables cannot appear as choices <sil=0.948> .PERIOD So <sil=0.452> ,COMMA for example <sil=0.560> ,COMMA let us say I put character car 1 is R and character car 2 is B and case car 1 case car 2 <sil=0.902> .PERIOD So <sil=0.327> ,COMMA remember the expression that you have here should be a constant expression whereas <sil=0.352> ,COMMA you have used a variable called character 1 <sil=0.959> .PERIOD Even though character 1 is initialized to a literal R here you are putting a variable character 1 and that is not acceptable <sil=0.972> .PERIOD So <sil=0.581> ,COMMA C only allows constant expressions to be in the choices you cannot put variables of any kind here <sil=0.951> .PERIOD So <sil=0.583> ,COMMA this is an incorrect program segment <sil=0.955> .PERIOD So <sil=0.603> ,COMMA if you want go and write writing this in a program you will see that the compiler actually indicates an error <sil=0.976> .PERIOD There is another thing that you have to be warned about namely using ranges <sil=0.967> .PERIOD So <sil=0.446> ,COMMA for example <sil=0.460> ,COMMA let us say I want to give these grades and for 0 to 49 I want to give D for 50 to 59 I want to give C for 60 to 74 I want to give B and for 75 to 100 I want to give A <sil=0.901> .PERIOD Let us say I want that you cannot do something like this case 0 dash 49 print F D or 50 dot dot 59 things like what you would do in when you write in paper right you may say 0 dot dot 49 or 50 dash 59 and so on <sil=0.995> .PERIOD Those things are not acceptable also you cannot provide a range of values in a constant expression it has to be a single value for this case clause <sil=0.944> .PERIOD So <sil=0.554> ,COMMA whenever you have multiple values you have to have multiple cases <sil=0.940> .PERIOD So <sil=0.638> ,COMMA that is why we had this here <sil=0.991> .PERIOD There were multiple values R and R for which we wanted to print F red we actually have multiple cases also specified explicitly <sil=0.994> .PERIOD So <sil=0.646> ,COMMA in summary we have a switch statement which has multiple cases and for each of these cases it executes the corresponding block <sil=0.931> .PERIOD If there is a break it will break away from the switch statement <sil=0.910> .PERIOD If there is no break it will go and evaluate the next cases also <sil=0.921> .PERIOD So <sil=0.428> ,COMMA this is not a valid way to give grades you should use the if then else clauses here I already showed you this in the earlier slide <sil=0.927> .PERIOD So <sil=0.537> ,COMMA with this we are the end of module <sil=0.935> .PERIOD So <sil=0.305> ,COMMA in the last class we looked at what an abstract data type is and what is an abstract data type now we said the idea is to use data structures <sil=0.382> ,COMMA use a defined data structures and not even if you have user defined data structures <sil=0.559> ,COMMA you also define operations on these data structures and just like when you write procedures for example <sil=0.645> ,COMMA to find the sum of n elements as we did some time back <sil=0.309> ,COMMA we basically have a procedure that operates on an array and gives you the result <sil=0.952> .PERIOD So <sil=0.349> ,COMMA next thing we have what we can do is we can have that is called the abstract data type or something like this <sil=0.936> .PERIOD I can define it as an ADT let us say abstract data type and let us say I want to define complex which is the example that I am going to take now <sil=0.952> .PERIOD I can define some private data here and this data organization is depending upon our convenience we will see this example whether I want to use the here basically we use the basic data types like the integer float and character and array for that matter pointers to describe the private data then we have a set of operations and these operations are what is visible to the outside world and these operations operate on this private data <sil=0.995> .PERIOD So <sil=0.402> ,COMMA this is how a ADT is defined <sil=0.948> .PERIOD So <sil=0.531> ,COMMA basically when you looking at an abstract data type we are talking about something like this <sil=0.937> .PERIOD I have a mathematical model and an informal algorithm that operates in the mathematical model as we saw in the context of sets and this becomes an abstract data type with a civil language program operating on the data that is within the abstract data and it finally <sil=0.381> ,COMMA it goes to higher level language you are going to use the basic data structures that are there make them you are user defined data structures and you operate higher level language program <sil=0.958> .PERIOD So <sil=0.522> ,COMMA let us take an example I am using C++ over here notice that we have switched from C to C++ we have already gone through a basic overview what C++ is and here I have defined what is called a class the equivalent of an abstract data type is the definition of a class we have a class complex here and remember that in C or C++ it does not support data structure called complex <sil=0.954> .PERIOD So <sil=0.348> ,COMMA I define a complex data structure notice this over here there are two private variables implicitly if you do not say private colon or whatever it means that it is by default private that means these variables are not accessible to the outside world flow trail comma imaginary then what do we have we have the public a set of functions which can operate on this data complex this is like an initialize over here for example <sil=0.392> ,COMMA they are called constructors basically I can pass argument a real and imaginary value which are both the flow type and it will create a object of type complex is also called objects <sil=0.952> .PERIOD Then notice that what I have done I have taken the operator plus and side this operator now should mean what do you mean of this operator this operator takes this particular object which is notice that real here is being defined and this real is added to the argument that is being passed which is also of type complex <sil=0.924> .PERIOD So <sil=0.424> ,COMMA it adds that particular argument and returns the sum of the two complex numbers similarly you have something which is the operator minus when it is complex should mean this <sil=0.914> .PERIOD So <sil=0.543> ,COMMA what we are saying here is we know that by the definition of plus and minus you know with respect to integer x n let us say x equal to 4 comma y equal to 5 then if I say let us say in z and z is equal to x plus y x plus y then you know z equal to the value of z will be 9 <sil=0.939> .PERIOD So <sil=0.345> ,COMMA it knows that when this plus is used here that when both are integer this what we will do suppose I had in u v u equal to 2 <sil=0.965> .PERIOD 5 and v equal to 1 times 0 or something like that then when I say when I say w I am sorry float here not in float here and I had a float w and I say w is equal to u plus v and the value that w will hold is 3 <sil=0.940> .PERIOD 5 <sil=0.939> .PERIOD So <sil=0.548> ,COMMA clearly what is happening is notice that already the plus operator in C or C plus plus is already overloaded what you mean by overloaded here in this context it notes that the operands are integer and in this case it knows that the operands are float <sil=0.921> .PERIOD So <sil=0.436> ,COMMA now what we will be doing here in this example is that it is already overloaded we are overloading it one more type of operand and what is this type of operand complex that is what we have done here <sil=0.975> .PERIOD So <sil=0.595> ,COMMA another one for multiplication multiplication of two numbers here is something for scalar division and there is a operator for division and notice that one is for scalar division and one is for division by complex number itself <sil=0.966> .PERIOD So <sil=0.414> ,COMMA basically depending upon the context it figures out whether this is a this operator overload or this operator overload <sil=0.935> .PERIOD So <sil=0.532> ,COMMA basically if I pass number which is a float then it will know that it has to do scalar division but whereas here when I pass a number which is complex it knows that it has to perform complex division <sil=0.981> .PERIOD So <sil=0.545> ,COMMA this is something that you can define now some we have written a whole lot of things over here we also wrote a print function which is print real plus I b and here is a main program what have we done notice the way we have defined complex a of 0 <sil=0.954> .PERIOD 5 comma 0 <sil=0.961> .PERIOD 5 let us go back to this example we had a constructor here complex of float real comma float imaginary complex bracket whatever is the default values what will take here here in the hand we are assigning the real here to whatever has been passed and imaginary to what has been passed as argument <sil=0.963> .PERIOD So <sil=0.588> ,COMMA that is exactly what we do in here <sil=0.954> .PERIOD So <sil=0.346> ,COMMA when I am defining here in the main program I am defining complex a of 0 <sil=0.928> .PERIOD 5 comma 0 <sil=0.913> .PERIOD 5 b of 2 <sil=0.972> .PERIOD 5 comma 2 <sil=0.988> .PERIOD 5 c is equal to 0 c is this like initializing I have int x y and z I have written a simple small snippet of a program here c is equal to a plus b x is equal to 4 y equal to 6 there is equal to x plus y notice that x and y are integer here here a and b are complex <sil=0.911> .PERIOD So <sil=0.324> ,COMMA here it will perform complex addition <sil=0.310> ,COMMA but here it will perform integer addition <sil=0.954> .PERIOD So <sil=0.454> ,COMMA let us try to run this program let me just run this program for you <sil=0.965> .PERIOD I hope you can see it I have already written this program here I will just cat this I put an extension <sil=0.954> .PERIOD So <sil=0.615> ,COMMA this is the same program which you saw in the slides here the same program which has been written and you see that the classes been defined here just like what I showed you there is a private variable and then there is operator overloading that happens <sil=0.969> .PERIOD Then I compile this in the usual way what do I do to compile <sil=0.972> .PERIOD See I am writing the output to a bin directed this is the source directly here this one advise that it is always good to put all your source programs in the source directly and execute to pulse in the binary directory bin directory and object files in the OBG directory documentation and a doc directory and so on <sil=0.989> .PERIOD So <sil=0.489> ,COMMA I am doing this <sil=0.926> .PERIOD So <sil=0.453> ,COMMA it compiled the program let me run this now <sil=0.946> .PERIOD So <sil=0.441> ,COMMA what is it do here notice that it is giving you 3 plus I 3 because we had 2 <sil=0.981> .PERIOD 5 plus 0 <sil=0.982> .PERIOD 5 <sil=0.929> .PERIOD So <sil=0.398> ,COMMA that was the addition that was being this Z is equal to for example <sil=0.381> ,COMMA C is equal to A plus B and Z is equal to X plus Y when I am getting the output from C what are we doing we have C dot print this what we are doing over here <sil=0.993> .PERIOD So <sil=0.587> ,COMMA it prints the value of C and that is 3 plus I 3 and then we also we also see out this is a standard output function in C plus plus and you find that Z is given the value of 10 <sil=0.991> .PERIOD What is important to notice the plus here is done with respect to complex here is plus which is done with integer these are already available to us from the C plus plus compiler here is this operator here plus being overloaded is what we defined in this piece of code over here where we define the entire complex ADT <sil=0.955> .PERIOD So <sil=0.610> ,COMMA this is the point of using complex using abstract data types the big benefit of using abstract data types is that now I can write you know if you are a electrical engineer for that matter you may want write an FFT program which uses complex to do your FFT algorithm and you can treat it each one of those you can do the addition using in much the same addition subtraction and so on and so forth <sil=0.901> .PERIOD So <sil=0.520> ,COMMA this is about how we what I have shown to you so far is simply a way of creating a new user defined data type with operations defined on it you already had the compiler already provide for you integer and float with operations defined on it and what we have done is to this we have added the complex data type on which we are defining a set of operations <sil=0.910> .PERIOD So <sil=0.526> ,COMMA this is the big thing about abstract data types with operations defined on them <sil=0.928> .PERIOD There is another big very big advantage that we also see as we said here when we say class complex here we have this private data and what is interesting is that we can the operations are actually defined only on the private data the implementation of the ADT and what I mean is that how complex has been stored inside that data structure is completely hidden from the user and the data cannot be accessed directly the implementation of the so what is interesting is that the way we are implementing the data type the private data type for example today we are used an array tomorrow I am using a link list as long as a key the operations should be the same without changing the very operations access the elements you can change this at a user will not even know that you actually change the implementation inside <sil=0.931> .PERIOD So <sil=0.603> ,COMMA let us look at some standard abstract data type the first thing is what is called a list do not confuse with the link list is just a list list of elements will worry about how the implementation is done later the ADT stack and the ADT queue so let us look at this list what is a list now the defined the ADT list as a sequence of 0 more 0 or more elements of a given element type <sil=0.950> .PERIOD So <sil=0.477> ,COMMA it consists of elements a 1 a 2 a 3 up to n n is greater than or equal to 0 and a i is of a particular element type n is the length of the list n greater than or equal to n 1 first element is a 1 and last is a n this is the definition of a list <sil=0.995> .PERIOD So <sil=0.414> ,COMMA notice we are not talked about anything about the implementation how are going to represent this list we are not going to talk about it all that we are saying is is a list of elements which I need to represent and they are for example <sil=0.644> ,COMMA they can be list of jobs it can be list of grocery items it can be a list of items in a set or it can be you know something that I want to use for if I want to do something like infinite precision arithmetic each one of them might correspond to a digit list of the list is used to represent a very long number and each element of the list corresponds to a digit in the number <sil=0.935> .PERIOD So <sil=0.442> ,COMMA you can do anything with that for that matter how we want to represent these list <sil=0.995> .PERIOD So <sil=0.527> ,COMMA let us look at what are the operations that you may like to perform <sil=0.971> .PERIOD So <sil=0.403> ,COMMA let us take look at what are the problems you have a list of jobs list of grocery items representation of sets list can be used to perform infinite precision arithmetic as we say the operations that you would like to do is we say suppose p is a particular position in the list <sil=0.989> .PERIOD So <sil=0.532> ,COMMA when you talking about a list here we just said I have a list a 1 a 2 up to a n <sil=0.909> .PERIOD Now <sil=0.397> ,COMMA a new element comes along let us say b or something I want to insert it into the list <sil=0.937> .PERIOD So <sil=0.534> ,COMMA I want to insert it let us see after some a l l is the position and I want to put it here and then make this list this will become a n plus 1 <sil=0.985> .PERIOD So <sil=0.425> ,COMMA I might want to insert an element at a particular position in the list <sil=0.996> .PERIOD I want to go to the end of the list where is the end of the list after n plus 1 I want to go to the end of the list or I want to locate an element in the list I want to find the where a particular element is formed let us say I am looking for some x is it where is it in this list I want to find the position maybe it is at 8 and I want to return the position to then I may want to retrieve an element at a particular position <sil=0.980> .PERIOD I want to look at let us say a k and I want to say what is there at the kth position in the list what is the value that is there at the kth position <sil=0.933> .PERIOD Then I want to delete a particular position in the list delete an element at a particular position and I may say delete the kth element <sil=0.905> .PERIOD Then you want to go to the next element what is the position of the next element in the list what is the position of the previous element in the list so on <sil=0.907> .PERIOD I want to create an empty list what is the first element in the list and so on <sil=0.932> .PERIOD So <sil=0.318> ,COMMA these are all operations that I have defined on list I can write or I can also have an operator which prints all the elements in the list prints the element at a particular position in the list <sil=0.986> .PERIOD So <sil=0.400> ,COMMA if you look at this here drawn this pictorially here this is an ADT list <sil=0.909> .PERIOD So <sil=0.637> ,COMMA what are we doing things that go into the list it creates an empty list elements are inserted in through the list and here what are we doing we remove elements from the list and delete in locate we find there a particular element x is present the tree element at a particular position p and so on <sil=0.967> .PERIOD So <sil=0.535> ,COMMA there is how you represent the list ADT <sil=0.968> .PERIOD So <sil=0.543> ,COMMA there is some internal representation we are not talking about what it is you can either create an empty list or you can insert an element to this <sil=0.948> .PERIOD So <sil=0.302> ,COMMA these are the operations which become visible to the outside world <sil=0.943> .PERIOD So <sil=0.575> ,COMMA let us look at an implementation of this now how do I represent the list <sil=0.925> .PERIOD So <sil=0.639> ,COMMA now we have already seen when we have large we assume that list list is made up of a set of elements of the same element type that is our definition if you go back to this definition over here even A 2 A 3 are all belonging to the same type is grocery items it is a list of jobs it is a representation of elementary set of the same type or as an infinite position arithmetic it corresponds to the digits that make up a given number <sil=0.970> .PERIOD So <sil=0.440> ,COMMA let us see this what we have in terms of representation <sil=0.939> .PERIOD So <sil=0.393> ,COMMA I need something which will I need a data structure that will it is available in the programming language which will enable be to represent elements of the same type <sil=0.910> .PERIOD So <sil=0.464> ,COMMA we have already seen two such data structures one of these two data structures that we have seen one is the array and the other recursive implementation which is the linked list at distinguish between linked list and the list is a simply a list of items <sil=0.944> .PERIOD So <sil=0.638> ,COMMA but we have here for second third so this is where you find the list and this points to last which is the last element in the list rest of it is empty <sil=0.985> .PERIOD So <sil=0.414> ,COMMA you fix have some fixed array size and say this cannot grow more larger than this and then you keep putting element into this particular list <sil=0.915> .PERIOD But the important thing is the list is accessible any element at any position should be accessible that is what all these operations that we have defined help us to do <sil=0.997> .PERIOD So <sil=0.527> ,COMMA then what we have is we have a header here the if I am using a linked list representation on the other hand the access is where the header <sil=0.496> ,COMMA but as far as the user is concerned he should not be able to he should not know how the implementation is done he does not have to go through the header or whatever <sil=0.998> .PERIOD So <sil=0.435> ,COMMA locate the element at a particular position p it should return the element at the particular position p <sil=0.998> .PERIOD So <sil=0.446> ,COMMA let us see so what I am saying is when you are looking at this position p over here that I am using an array representation the position p corresponds to an index in the array whereas here when I am talking about a position p here that is let me give a slightly better example <sil=0.931> .PERIOD So <sil=0.590> ,COMMA there is a header and this header let us say points to a 1 a 2 and so on and let us say this is a n <sil=0.922> .PERIOD Now <sil=0.502> ,COMMA here I might have a position p when p points to a particular element in the list we will see how this both is implementation certain in one case it is a pointer and this in other case it is an index into the array but the way we will write the we will implement the ADT is the user does not know he knows there is a type called position just like you know there is a data type called in which are there is a data type called card there is a data type called float here you have a data type called position and that is what he will use in the program <sil=0.963> .PERIOD So <sil=0.553> ,COMMA let us look at this implementation I have used a linked list representation in this particular in this particular representation of this particular list ADT here <sil=0.976> .PERIOD So <sil=0.571> ,COMMA what am I doing here I am saying cell pointers cell type is defined here which has an element type which is a type value and what is element type I am using integer elements for the timing and then what we say is that we have a type therefore here which says pointer to the cell type is a type position that is all and here what have we done here element type which is a type integer here is value and so element type is something that the user will define <sil=0.976> .PERIOD The user will say you as the designer of the ADT will say it is a list of element type element type definition comes from the user <sil=0.950> .PERIOD So <sil=0.617> ,COMMA you will have a separate dot h file which will tell you how the element type is represented and position corresponds to the next again because the next element is again a pointer is what we do <sil=0.936> .PERIOD So <sil=0.386> ,COMMA let us look at this so what do we have now when I look at a private data I have a position which points to the list head then we have something that creates an empty list insert list element x at position p delete list element at position p delete whatever is there at position p what is the position of the first element what is the position of the last element what is the position of the next to the position p print the entire list if this is a partial implementation that we have <sil=0.922> .PERIOD So <sil=0.309> ,COMMA what are we doing here I do something clever in this to reduce the computation time that is required let us see what I am doing here I am creating a list head creating an empty list with one element this what this means new cell type and then I am saying list head next points to not so it is what I have done is I create a empty head node without anything and this is the head up I create a empty node I do not have anything in that <sil=0.982> .PERIOD Then what I do is when I am looking at element type to be inserted I do something clever what I do is here if you notice what are we doing we are saying we are the notice that there is an assignment here temp is assigned to p point next p point next I am creating a new element here then what are we doing we are saying p point next point next equal temp and p point next is equal to x <sil=0.917> .PERIOD So <sil=0.452> ,COMMA what are we doing here let us go through this if I want to do it pictorially what I am doing is I want to there is an insert here x at position p stilling <sil=0.906> .PERIOD So <sil=0.642> ,COMMA what we are doing is we are saying so let us say this is position p what we do is we assign temp as store in this p point next then what we do is we create here so that means what this is a list which was like this and so on some set of elements I wanted to insert it over here <sil=0.995> .PERIOD So <sil=0.400> ,COMMA when we do is I create here a new element and put that element here and connect this back <sil=0.960> .PERIOD So <sil=0.488> ,COMMA this is the new way which I am adding although I said insert the element here what we do is we keep it as the next position we will see by this is useful by we not inserting it at that particular position itself this reason for doing this because what happens is if I do this then if I want to delete at position p means what I have to take this pointer here now notice that I have inserted this element <sil=0.923> .PERIOD Now <sil=0.328> ,COMMA if I want to delete an element at position p means what lose the element that has to be removed therefore <sil=0.457> ,COMMA all that I have to do is point p to p point next point next <sil=0.901> .PERIOD So <sil=0.576> ,COMMA it is a very single operation of here notice I do not have to do any more bookkeeping <sil=0.916> .PERIOD So <sil=0.506> ,COMMA these are clever things that we do so what did I do I wasted one position here when I created the make null created the empty list I made one wasted position and then what happens when I am inserting I am always inserting for example <sil=0.547> ,COMMA p here a here for example <sil=0.433> ,COMMA I insert it over here then I take this temp and then point this is pointing to this guy then I correct all the pointers the advantages when I am doing deletion here I do not have to do any bookkeeping I know that actual location of the element where I have inserted is p point next <sil=0.921> .PERIOD So <sil=0.300> ,COMMA I just have to do this I just spent of pointers over here <sil=0.941> .PERIOD So <sil=0.537> ,COMMA that the list looks like what we want to have <sil=0.910> .PERIOD So <sil=0.421> ,COMMA let me example this exactly what is showing over here <sil=0.995> .PERIOD So <sil=0.404> ,COMMA this is something which is very nice about doing your own implementation why is this ok you know what happens to the user of the program because you are not giving access to the data structures which is defined within the class you just do not have to worry about it you know that the you are doing the bookkeeping and as long as the operations which you have defined within which operate on the ADT are consistent with each other you do not have to worry about it <sil=0.987> .PERIOD Similarly <sil=0.304> ,COMMA here going to the end of the list means this is go still the position is null ok then move one print list and so on ok <sil=0.944> .PERIOD Now <sil=0.417> ,COMMA what I am going to do is I am going to show you again the running of this program let us go to this here <sil=0.944> .PERIOD So <sil=0.506> ,COMMA I have here a program let us say list at two different I want to show you this let me see we can increase the terminal preferences ok <sil=0.946> .PERIOD So <sil=0.499> ,COMMA let me just increase the font a bit so that you can see bit better ok yeah now this is better all right <sil=0.942> .PERIOD So <sil=0.516> ,COMMA let us look at this let me do the less I have two different implementations list ptr dot c and this is the one which I have just put in the notes over here <sil=0.924> .PERIOD So <sil=0.305> ,COMMA I have all these operations make null insert <sil=0.498> ,COMMA retrieve print list and so on ok <sil=0.959> .PERIOD Now <sil=0.394> ,COMMA I want you to look at these two here there is a main over here notice that this is a main function I want you to look at this main function here it knows that there is a abstract data type of type list <sil=0.910> .PERIOD If you notice this piece of code here we create an empty list then I am initializing the elements in the list I am just saying keep on inserting elements at the end of the list print the list <sil=0.579> ,COMMA divide the element at the first item in the list print the list delete it and so on ok <sil=0.923> .PERIOD Now <sil=0.394> ,COMMA I show you another implementation of this this is list array not c and here what we have done is notice that the position then becomes an index of type integer then notice that the functions look exactly identical I have not changed anything here all right <sil=0.950> .PERIOD Then what I do in make null I am creating an array of size 100 which is of that type cell node there and then what am I doing insertion operation is different but it takes the same arguments ok the position as far as the user is concerned like when you define type int x do you know how int is represented you do not worry about it <sil=0.926> .PERIOD So <sil=0.525> ,COMMA in much the same way here here the position is an index into the array a load it was a pointer into the list and all the operations are defined <sil=0.955> .PERIOD Now <sil=0.610> ,COMMA I wanted to look at this main program this main program is identical to the earlier main program where I had list implemented as a pointer in terms of linked list here I have implemented using the array if these are identical programs let me see if I can put them in the same <sil=0.903> .PERIOD So <sil=0.417> ,COMMA what did you do initialize is the list so 0 1 2 3 9 deleted the first element in the list then again we deleted the second element in the list and you get this result <sil=0.932> .PERIOD So <sil=0.362> ,COMMA what do we expect when we run the list pointer representation it should give me identical results and notice that it is not changed ok <sil=0.920> .PERIOD So <sil=0.634> ,COMMA there is the fun part of actually using ADTs the fun part is that this representation that you have you can change the way the functions are implemented can be changed by the define of the ADT <sil=0.913> .PERIOD But the user of the ADT need not be aware of it <sil=0.907> .PERIOD So <sil=0.640> ,COMMA for example <sil=0.566> ,COMMA suppose you are a you know you are writing code for a you are writing some code to define and so initially you can come up with a poor definition of an ADT the algorithms need not be very efficient <sil=0.903> .PERIOD But after we can make your algorithms which operate on ADT is so much so much more efficient and the user need not to be aware that you actually change the representation totally <sil=0.902> .PERIOD So <sil=0.438> ,COMMA this is the fun part about the defining abstract data types <sil=0.985> .PERIOD So <sil=0.424> ,COMMA what we did so far was we defined an ADT called list and we talked about two different implementations of the list and we wrote a main program which operates on the list and we saw that the main program is actually independent of the implementation of the list ok <sil=0.906> .PERIOD So <sil=0.548> ,COMMA this is the big advantage of ADTs as I have already mentioned <sil=0.938> .PERIOD Now <sil=0.632> ,COMMA I only take some homework back there are some list problems here <sil=0.911> .PERIOD Now <sil=0.551> ,COMMA suppose we use this list to store sets we already said it can be used to store sets <sil=0.998> .PERIOD I want you to think about performing union <sil=0.372> ,COMMA intershared section <sil=0.455> ,COMMA set A minus set B and then I also talked about infinite precision arithmetic let me say what I mean by that <sil=0.933> .PERIOD So <sil=0.627> ,COMMA suppose I have very large number of digits you know is beyond the precision of the computer <sil=0.966> .PERIOD Then can you perform use the list to perform the something like this let us say two very very large numbers can you perform arithmetic that is each element is stored as a digit in the list <sil=0.976> .PERIOD So <sil=0.369> ,COMMA every list element is a digit and I want you to add these two then take the carry add these two and so on addition subtraction division multiplication and now the thing is suppose I have a list with something like this there is already list this kind I want you to remove all the duplicates and give me a list of this ok that is this is this is the existing list that I have and notice it you do not have access to the way the list has been represented just using the list operations here also just using the list operations from given that these are the elements in the list I want you to come up with this <sil=0.918> .PERIOD Similarly <sil=0.447> ,COMMA from this I have two lists which are given like this and I want you to perform the arithmetic <sil=0.960> .PERIOD So <sil=0.621> ,COMMA let see how you can do this ok and also converting an on an order list to an order list <sil=0.995> .PERIOD So <sil=0.331> ,COMMA we kind of complete this first in this introduction what did we do here <sil=0.969> .PERIOD The introduce you to abstractly types we talked about an example on complex and then what did we do we talked about the standard data type list which can be with a large number of operations and we finally <sil=0.479> ,COMMA conclude with one example where we had implemented a list two different implementations where the same main program which operates on both these implementation of the list is what we had looked at <sil=0.972> .PERIOD So <sil=0.405> ,COMMA next we will talk about stacks and we will stop here ok that will be the next lecture <sil=0.969> .PERIOD Stack is another abstract data type <sil=0.976> .PERIOD So <sil=0.645> ,COMMA we will stop here for now <sil=0.977> .PERIOD Welcome to this first lecture of the Algorithms course and I am Naren's Fermi from IIT MIRRUS <sil=0.914> .PERIOD So <sil=0.571> ,COMMA the course is about designing and analyzing algorithms and it is instructive to actually start off with what an algorithm is <sil=0.935> .PERIOD Algorithm is a finite sequence of steps that holds on all inputs <sil=0.990> .PERIOD We are familiar with algorithms <sil=0.967> .PERIOD If you think of it a recipe to cook a dish is an algorithm <sil=0.926> .PERIOD The multiplication the sequence of steps to multiply two numbers is an algorithm <sil=0.929> .PERIOD And if you look at any program written in any programming language it is desired that it encodes an algorithm <sil=0.993> .PERIOD I say it is desired because it is a fairly challenging exercise to ensure that it holds on a finite sequence of steps <sil=0.559> ,COMMA holds on finite number of holds in a finite number of steps on all inputs <sil=0.902> .PERIOD Now <sil=0.534> ,COMMA the question that we address in this course is how do we design algorithms <sil=0.345> ,COMMA how do we ensure that algorithms are correct and how do we also ensure that it holds on all inputs in a finite number of steps <sil=0.923> .PERIOD And for those of few who may already know some programming it should not have infinite loops for example <sil=0.370> ,COMMA and we also address the issue of minimizing the number of steps on every input <sil=0.939> .PERIOD This is not a very well stated goal and this is one of the things that we will formalize as we go through this course <sil=0.914> .PERIOD These are the main four side of this course <sil=0.963> .PERIOD Outland of the course is that we are going to have 10 one hour lectures every week there will be two of them and every lecture will be broken into approximately four modules each of 15 minutes <sil=0.909> .PERIOD And at the end of each module there will be some exercise for the learner to go out and try before the next module <sil=0.940> .PERIOD The contents of the course are as follows during the first week we will focus on fast arithmetic <sil=0.997> .PERIOD During the second week we will work on algorithms for searching and sorting <sil=0.986> .PERIOD The third week we will work on greedy algorithms <sil=0.992> .PERIOD During the fourth week we will move slowly towards advance techniques for designing algorithms and one of them to address quite a few problems is the dynamic programming approach to design algorithms <sil=0.988> .PERIOD And finally we will come to challenging exercises which have immense practical applications like string matching and identifying shortest paths in a network like a road network or any transportation network for example <sil=0.910> .PERIOD So <sil=0.523> ,COMMA let us start off with the contents of the first lecture which is all about fast arithmetic <sil=0.912> .PERIOD Now in these issues we make some minor assumptions which are often verifiable as being satisfied by most processors <sil=0.941> .PERIOD We assume that multiplication and addition of two integers can be done in unit time <sil=0.953> .PERIOD On most processors this is not a completely valid assumption because it is either a 32 bit integer or a 64 bit integer addition or 128 bit integer addition or a finite number of bits addition that happens in unit time <sil=0.905> .PERIOD But for the purposes of understanding the challenge of designing algorithms to do fast arithmetic we relax assumption and we assume that any two integers can be multiplied or added in unit time <sil=0.932> .PERIOD So <sil=0.477> ,COMMA now here is the simplest of the exercises which we can do very efficiently as human beings and let us see how to convert this into a computer program <sil=0.928> .PERIOD To convert it into a computer program we need to ensure that we understand the underlying mathematics first we come up with an algorithm and then you can choose your favorite programming language to convert the algorithm into a program <sil=0.914> .PERIOD This is how algorithms and programming are very closely connected <sil=0.904> .PERIOD So <sil=0.525> ,COMMA whenever you want to solve a problem when you want to write a program to solve a problem we go out and try to design an algorithm <sil=0.996> .PERIOD When we try to design an algorithm we try to go out and understand the kind of inputs that we process and identify the appropriate mathematical logical steps to that part of that play an important role in the algorithm and then ensure that the algorithm is a good algorithm in the sense that it terminates on all inputs and it uses as few steps as possible it uses as few resources as possible <sil=0.951> .PERIOD These are all the parameters that we will try to quantify as we progress through this course <sil=0.906> .PERIOD So <sil=0.573> ,COMMA coming back to fast arithmetic let's consider the simplest of problems let us consider the question where the input to a program is two positive integers x and n and the goal is to design an algorithm that will calculate x to the power of n that is the nth power of the given integer x <sil=0.909> .PERIOD Now <sil=0.546> ,COMMA let's look at a bit of mathematics very simple mathematics which all of us are very familiar with that the definition of x to the power of n is x to the power of n minus 1 that is the n minus 1 with power of x multiplied by x and there is always a boundary condition that x to the power of n is 1 if n equals 0 <sil=0.970> .PERIOD So <sil=0.588> ,COMMA this requires a bit of correction there is an error there this must be 1 <sil=0.943> .PERIOD So <sil=0.504> ,COMMA this is the number 1 and not not 0 <sil=0.980> .PERIOD This mathematical definition of x power n gives us the desired algorithmic idea and this is implemented in any programming language using a loop control structure whichever programming language it is we can use a counter control loop as in this case where we use an almost C like syntax where you see a variable called counter which is of integer type and we initialize the value which is going to store the variable value to contain the value 1 and then here is a loop which has an initial value which sets counter to be equal to 0 and runs for n iterations at the end of each iteration it increases counter by 1 and value is multiplied by x at the end of it value is returned <sil=0.908> .PERIOD Now <sil=0.633> ,COMMA this is quite a simple program and let us run a small example <sil=0.940> .PERIOD So <sil=0.592> ,COMMA for example <sil=0.633> ,COMMA let us say I want to evaluate 4 to the power of 3 right <sil=0.940> .PERIOD So <sil=0.601> ,COMMA this is done in 3 iterations initially value is equal to 1 value is equal to 1 and counter takes a range of values which is 0 <sil=0.561> ,COMMA 1 and 2 right <sil=0.994> .PERIOD Now <sil=0.623> ,COMMA when control enters the iteration for the first time counter is equal to 0 and then so <sil=0.486> ,COMMA this is a table of values value becomes 4 at the end of this counter is incremented by 1 then value becomes 16 and value becomes 64 in the third iteration that is when counter is equal to 2 at the end of this counter becomes 3 control exits from the loop and the final value is returned and that is 64 right <sil=0.952> .PERIOD As you can see the correctness of this algorithm comes from this formal mathematical definition which is exactly what is implemented in the loop in the program and it is clear that this algorithm is indeed correct <sil=0.981> .PERIOD However <sil=0.333> ,COMMA we are not interested just in the correctness <sil=0.458> ,COMMA but we are also interested in how many arithmetic operations are performed and that is really the focus of the next part on this small example right <sil=0.933> .PERIOD As we just mentioned the algorithm is correct because of the mathematical formulation of power of a particular number as one is efficiency goes we measure efficiency as the number of arithmetic operations which are performed and in this case there are only multiplications and it is quite easy to see that every iteration there is a single multiplication that is performed therefore <sil=0.501> ,COMMA for n iterations there are n operations right <sil=0.999> .PERIOD So <sil=0.594> ,COMMA let us just go back to our program you look at this there are n iterations every iteration has an iteration number which is captured by counter counter takes a range of values between 0 to n minus 1 and in every iteration the value is updated by a single arithmetic operation which is a multiplication <sil=0.922> .PERIOD Therefore <sil=0.624> ,COMMA the number of multiplications are associated with this program is exactly n where n is the power of x that we want to compute <sil=0.981> .PERIOD There are also a couple of additions which happen <sil=0.996> .PERIOD So <sil=0.573> ,COMMA where counter gets increased at every step that is one addition that happens in every iteration but we do not interested in counting that because that is more structural exercise and we are interested just counting interesting counting the number of multiplications <sil=0.992> .PERIOD Let us address the question as to how to reduce the number of arithmetic operations which are performed in computing the power <sil=0.914> .PERIOD So <sil=0.387> ,COMMA here is the next approach which is very interesting and this is a technique that you can use even to compute the higher powers of matrices not just numbers <sil=0.991> .PERIOD So <sil=0.621> ,COMMA in this case we want to compute the nth power of x in other words we want to compute x power n and the observation that we make is that x power n is given by x square raise to the power of n minus 1 by 2 if n is odd and multiplied by x <sil=0.966> .PERIOD It is very easy to do the arithmetic 2 times n minus 1 by 2 is equal to n minus 1 that is what happens in the exponent and then there is a multiplication by x <sil=0.917> .PERIOD Observe that when n is odd n minus 1 is even therefore <sil=0.422> ,COMMA n minus 1 is then divisible by 2 <sil=0.953> .PERIOD So <sil=0.627> ,COMMA therefore <sil=0.354> ,COMMA the left hand side is an integer you get the value n minus 1 and then you multiply by x <sil=0.924> .PERIOD So <sil=0.302> ,COMMA this is basically x power n minus 1 multiplied by x when n is odd and n is even it is very clear it is x square whole power n by 2 <sil=0.925> .PERIOD So <sil=0.432> ,COMMA here is a trick which is recursive repeated squaring it is repeated squaring of what let us see that now <sil=0.919> .PERIOD Remember that initially we have the value x and earlier in the first iteration we computed in the iteration number 1 <sil=0.934> .PERIOD Then we computed the value x square and remember that in the next iteration we computed the value x cube instead we do something which is slightly cleverer and compute x power 4 which is x square whole power 2 which is x power 4 and then we compute we square the value of x power 4 in the 4th iteration <sil=0.981> .PERIOD That is the iteration number 3 there is 0 the first iteration the second iteration and the third iteration we compute x power 8 <sil=0.991> .PERIOD The fourth iteration we square the value computed to the previous iteration so we get x power 16 and so on <sil=0.901> .PERIOD So <sil=0.428> ,COMMA what is the whole idea the whole idea is very simple we compute the square of the previous term <sil=0.936> .PERIOD In other words the kth term in the sequences x power 2 power k so let us write this down in the kth iteration we would have computed x power 2 power k and for what value of k is so what we want to compute is x square <sil=0.964> .PERIOD So <sil=0.559> ,COMMA what we do is we compute we perform this operation of repeated square of the value computed in the previous iteration till 2 power k and n by 2 are 1 and the same at which point of time starting from x square we would have computed x square to the power of n by 2 that is we calculate the value of x power n by repeated square and the termination condition is when 2 power k where k is the iteration number becomes equal to n by 2 assuming that we start with x square <sil=0.904> .PERIOD For what value of k is true for what value of k is this equation satisfy that 2 power k becomes equal to n by 2 <sil=0.943> .PERIOD So <sil=0.517> ,COMMA for k equals log n to the base 2 minus 1 for the value k equals log n to the base 2 minus 1 k equals n by 2 and let us do a small exercise here to get an idea as to what we are talking about consider the case when n is a power of 2 <sil=0.937> .PERIOD So <sil=0.403> ,COMMA let us assume that the number that is given is x consider the case when the number is x and we want to compute say x to the power of 64 <sil=0.903> .PERIOD So <sil=0.351> ,COMMA let us write down the sequence we start off with x square then we compute x power 4 then we compute x power 8 then we compute x power 16 we compute x power 32 and finally we compute x power 64 <sil=0.982> .PERIOD To observe that every step the exponent keeps getting doubled <sil=0.962> .PERIOD So <sil=0.472> ,COMMA the most important concept here is that the exponent doubles at every step in each iteration and we start off with x square and we wanted to get the exponent double at every step <sil=0.923> .PERIOD In each iteration and we started off with x square and we wanted x to the 64 x to the power of 64 and observe that the number of iterations is 1 the second iteration the third iteration the fourth iteration and the fifth iteration <sil=0.953> .PERIOD And it is very clear that log 64 to the base 2 is 6 because 2 power 6 is 64 minus 1 because we started off with x square and minus 1 this is 5 <sil=0.967> .PERIOD Therefore <sil=0.532> ,COMMA there are 5 iterations in the 0th iteration its x square in the iteration number 1 x power 4 the iteration number 2 its x power 8 iteration number 3 its x power 16 iteration number 4 it is 35 iteration number 5 64 x power 64 is calculated at the end of it for powers of 2 in log n to the base 2 minus 1 steps the correct number 4 <sil=0.927> .PERIOD So <sil=0.342> ,COMMA this value is calculated when very importantly n is a power of 2 <sil=0.957> .PERIOD So <sil=0.477> ,COMMA this brings us to the exercise here as a student it is very instructive to write a C program to implement the repeated squaring algorithm <sil=0.903> .PERIOD In particular the challenge here is to write down the loop when n is not a power of 2 and this is very interesting <sil=0.987> .PERIOD So <sil=0.556> ,COMMA let me give you a hint as to how to go about this let us assume that n is instead of 64 let us assume that n is 65 and let us write 65 in binary <sil=0.935> .PERIOD It would be 1 0 0 0 0 followed by 1 65 <sil=0.966> .PERIOD So <sil=0.361> ,COMMA this is contributes to value 1 this is 2 power 0 2 power 1 2 power 2 2 power 3 2 power 4 2 power 5 2 power 6 <sil=0.991> .PERIOD So <sil=0.445> ,COMMA this is 64 plus 1 in binary this is 65 <sil=0.900> .PERIOD What we want to do is we want to compute x power 65 and if you write this carefully this is equal to x power 64 plus 1 this is x power 64 multiplied by x power 1 <sil=0.972> .PERIOD And we already know how to handle the case when the exponent is a power of 2 here also the exponent is a power of 2 recall that 1 is 2 power 0 and we know how to handle this and this is a hint for you to complete the algorithm when n is not a power of 2 and implemented in the C programming language <sil=0.956> .PERIOD So <sil=0.382> ,COMMA in module 3 we will look at repetitive statements <sil=0.925> .PERIOD So <sil=0.460> ,COMMA so far we have seen conditional statements both if and select using a switch statements and we will look at repetitive statements <sil=0.962> .PERIOD So <sil=0.416> ,COMMA repetitive statements are also called loops <sil=0.992> .PERIOD It is a it forms a very important class of statements because you get to iterate or repeat over a set of operations <sil=0.902> .PERIOD This is useful in lots of algorithms and it is a very basic construct <sil=0.933> .PERIOD So <sil=0.479> ,COMMA see offers three different kinds of repetitive statements namely the force statement <sil=0.532> ,COMMA the wild statement and the do wild statement <sil=0.968> .PERIOD We will see each one of them and see motivating examples for each one of them <sil=0.997> .PERIOD So <sil=0.417> ,COMMA in any loop construct no matter what language you pick there are two different kinds of loops that you can run <sil=0.966> .PERIOD You can either have them counter controlled or what is called sentinel controlled <sil=0.940> .PERIOD So <sil=0.422> ,COMMA in counter controlled what you have is you have a set of operations and you want to repeat that a certain number of times and this number of times you have to repeat it is already known to you <sil=0.970> .PERIOD Whereas <sil=0.615> ,COMMA in sentinel controlled you keep looping until a certain condition is met <sil=0.916> .PERIOD So <sil=0.478> ,COMMA for example <sil=0.619> ,COMMA you may wait till the user inputs minus 1 and you want to do a repeated set of actions still the user inputs minus 1 <sil=0.969> .PERIOD Maybe you want to find the factors of a number <sil=0.516> ,COMMA but the user could keep on giving these numbers <sil=0.926> .PERIOD At some point of time if the user inputs minus 1 you want to stop the program <sil=0.990> .PERIOD So <sil=0.378> ,COMMA if you want something like that upfront you do not know how many inputs the user is going to give <sil=0.965> .PERIOD In such cases the sentinel controlled structures are useful and this structure is usually used when the number of iterations is dependent on the input and not on the problem being solved <sil=0.999> .PERIOD So <sil=0.561> ,COMMA let us start with the first one namely the for loops <sil=0.975> .PERIOD So <sil=0.437> ,COMMA for loops is actually the for loop construct is a counter controlled repetition structure <sil=0.902> .PERIOD What you have is you start with an initial value of some counter and you modify the counter as we go along till you reach a final value <sil=0.954> .PERIOD So <sil=0.381> ,COMMA maybe I start with number 1 go in steps of 2 and let us say I stop at 43 <sil=0.906> .PERIOD In that case I would be using all the odd numbers <sil=0.964> .PERIOD So <sil=0.616> ,COMMA I am going in steps of 2 from 1 <sil=0.944> .PERIOD So <sil=0.443> ,COMMA I would go 1 <sil=0.301> ,COMMA 3 <sil=0.644> ,COMMA 5 <sil=0.542> ,COMMA 7 and so on up till 43 or I may say just for 20 times print hello <sil=0.916> .PERIOD In that case I would start the initial value at 1 the counter would go by increments of 1 and it stops at 20 <sil=0.952> .PERIOD So <sil=0.636> ,COMMA this for for loop the way C does it it lets the programmer specify an initial value a modification to the counter as well as a final value and on top of that it also lets you put in a body or what you really want to do so many times <sil=0.925> .PERIOD So <sil=0.379> ,COMMA let us look at the basic expression you have a for loop and it starts it works like this <sil=0.950> .PERIOD So <sil=0.392> ,COMMA you have for which is a keyword and you have these 2 parenthesis and you have 3 expressions 1 <sil=0.531> ,COMMA expression 2 and expression 3 and the body of the loop goes inside this statement here <sil=0.913> .PERIOD So <sil=0.579> ,COMMA the meaning of this is you evaluate expression 1 <sil=0.920> .PERIOD So <sil=0.551> ,COMMA expression 1 is just the initialization and you repeat something and what you repeat you evaluate expression 2 if it is true you execute statement if it is false you exit the loop <sil=0.927> .PERIOD So <sil=0.408> ,COMMA when you execute the statement you check if the expression 2 is true if it is true you execute the statement and evaluate expression 3 if it is false exit from the loop <sil=0.953> .PERIOD Typically the statement that you have is a block of code therefore <sil=0.392> ,COMMA usually you have to put this within braces <sil=0.945> .PERIOD So <sil=0.490> ,COMMA you have you need braces here and here typically because that makes a code of that makes a code block <sil=0.914> .PERIOD So <sil=0.426> ,COMMA let us take this small example computing the sum of first 20 odd numbers <sil=0.908> .PERIOD So <sil=0.618> ,COMMA to do so what we are going to do is we are going to have a variable called sum which is initialized to 0 and to that we are going to add k repeatedly and k is just going to be a sequence of odd numbers starting at 1 <sil=0.967> .PERIOD So <sil=0.536> ,COMMA let us see the loop structure in place if you notice the structure of the for loop the for loop runs from i equals 1 i less than equal to 20 i plus plus which means this body that you are seeing here is going to be executed exactly 20 times <sil=0.918> .PERIOD So <sil=0.465> ,COMMA let us check what the overall structure of the program is we set k to be the first odd number which is 1 and i is the loop iterator or the loop control variable and i less than equal to 20 is the termination condition <sil=0.915> .PERIOD Since we are incrementing i in terms of 1 using i plus plus this loop will run exactly 20 times and the body of the loop is in such a way that k tracks the i th odd number the very first iteration k is 1 the second iteration k is supposed to be 3 and so on it tracks the i th odd number and we are adding that to sum and we are incrementing k in increments of 2 which means from 1 we will go 3 5 7 9 and so on and this is the whole setup let us say we want to mentally simulate this <sil=0.973> .PERIOD So <sil=0.307> ,COMMA initially sum would be 0 and initially sum is 0 and k is 1 we start the loop when we start the loop i equals 1 and we are going to check if i is less than equal to 20 this is actually true <sil=0.923> .PERIOD So <sil=0.357> ,COMMA therefore sum plus equal to k so this plus equal to is essentially a shortcut for sum equal sum plus k so sum is 0 now we are adding 1 to it so sum becomes 1 and k we are adding 2 to it so k becomes 3 at the end of it we go and evaluate expression 3 which is i plus plus so now i becomes 2 so this is 1 body of the loop at this point we again go and check is i less than equal to 20 or what it is true so now we add sum plus equal to k so we add 1 and 3 sum becomes 4 and k is incremented by 2 so k becomes 5 and finally at this end of this iteration i becomes 2 and so on so from so essentially what we are doing is we are incrementing i and we will do this exactly 20 times so we will go from number 1 3 5 7 and so on 20 times so it is a fairly simple program but it shows you the basic structure of a for loop <sil=0.912> .PERIOD So <sil=0.595> ,COMMA let us take a small detour and look at what are the different kinds of operators that you can use we already saw equal to equal to in an earlier lecture we also saw greater than in the lecture where we are looking at largest of the numbers and so on there are other operators namely not equal to or less than or equal to greater than and so on so these are the 6 operators that you can use on numbers so you can use them on both integers and floating point numbers but more importantly we also need to understand this notion of what are called logical operators so in all these things that we have seen so far we have only one condition for the expression that we are evaluating sometimes we need more than a few conditions so let us look at this example where let us say if age is less than equal to 45 and salaries greater than equal to 5000 I want to do some work so I cannot so I want to combine this into one condition and you can do this using this operator called and the and operator when you type you type ampersand ampersand be careful it is twice it is not a mistake we have to type ampersand twice that is a logical logical and operation sometimes I may need something like a logical or condition either condition A is true or condition B is true in which case we want logical or operation and you get that using what is called the pipe operator so you press you have this pipe twice you usually see this pipe on top of the backslash symbol so backslash symbol and pipe are in the same key usually and for example if I want to see if a number is a multiple of 2 or a multiple of 3 then I could use this condition num percentage 2 equals 0 checks whether it is a multiple of 2 num percentage 3 equal to equal to 0 checks whether the number is a multiple of 3 and by sticking in this or operator in between I am checking if a number is either a multiple of 2 or a multiple of 3 so this is a very useful thing and we may use it in the next few lectures <sil=0.917> .PERIOD So I want to give another example of a for loop let us say I want to print the nth triangular number so in the previous example the number of iterations was actually known in the program itself so we had i equal to 1 i less than equal to 20 so I said whenever we know the number of iterations it is better to use a for loop I want to show an example here where we really do not know the number of iterations because the user is going to input it but we still know that once the number of iterations once the user gives n the number of iterations is fixed so let us see this small example find the nth triangular number a triangular number is defined as the sum of integers from 1 to n so I am showing a small segment of a code here let us say I as before the iterator and number is the number of the nth triangular number that the user is asking for and some is the result that we want to give to the user so we start with prompting the user what is the triangular number that you want and we are going to scan it from the user we will start with sum equal to 0 so at this point I want to run it as many times as the number that the user wanted so now what we have is we have for i equals 1 i less than equal to number for i equals 1 i less than equal to number i plus plus the key thing that I want you to notice is that this number is not a constant in the previous example we had it as a constant now it is not a constant but the moment this is received from the user the number of iterations is fixed and that makes it suitable for a for loop so for i equals 1 i less than equal to number i plus plus sum plus equals i so the way this is going to work is you are going to check if i which is equal to 1 is less than equal to the number or not let us say I the number that the user inputs is 5 1 is less than equal to 5 you will add 1 to sum then i gets incremented to 2 2 is less than equal to 5 then 2 is added to sum and so on so you will add numbers 1 2 3 4 and 5 and the result would be 15 so that the fifth triangular number is 15 that would be the printout of this program let us look at another example where the user is going to ask for this multiple times so the user is going to ask for some nth triangular number but he wants 5 such numbers so one way in which you can do this is you can ask the user to run the program 5 times but that is not the most desired way to do it instead if we know upfront that the user wants 5 triangular numbers but each time the user may ask for a different triangular number and that is what we have here so we have a for loop here and this for loop is going to take care of the fact that we are going to ask for 5 at 5 numbers from the user and within each body of this loop outside we have this finding the nth triangular number so we are doing 5 iterations of asking n from the user and finding the nth triangular number and printing it and if you notice we have this blue body which is on this outer for loop and this orange body which is the inner for loop so what we have done is we have nested a for loop inside another for loop and this is also a very useful thing to do so we are having this outermost loop running on counter and the inner most loop running on i so we have two iterators and what this program does or what this code segment does is it is going to ask the user 5 times for what is the triangular number that they want and each time once the number is entered it will find the triangular number and print it out so I suggest that you go and write this code and see what happens so let us move on to the next construct which is the while construct so the general form of the while construct is while expression statement and as before the statement is a block of code so typically you put that within braces the semantics is that you repeat this following process you evaluate the expression first if the expression is true then you execute the statement if the expression is false you exit the loop so in the for loop exiting the loop is known up front you run it for a certain number of iterations and you exit the loop whereas in while loop you exit once the expression becomes false which means the expression must change inside the loop if the expression does not change inside the loop you would end up with an infinite loop because the expression would always be true will keep executing the body of the loop infinitely let us see a small example let us say I want to just print the 5 integers the first 5 integers a first 5 positive numbers so I can do this with a far loop running from 1 to 5 and printing it I am showing a small code segment which does something different so I have int count equals 1 so right when we declare we initialize count equal to 1 this is possible in C then while count is less than or equal to 5 print count and count plus plus so the key thing that you have to notice is that this count that we have here is actually changing right if we don't have this count would be 1 forever while 1 is less than or equal to 5 print count we would be printing 1 in an infinite loop however this count plus plus is changing the value of count so the next time you would check if 2 is less than or equal to 5 then you would check if 3 is less than or equal to 5 and so on at some point count would become 6 6 less than or equal to 5 would become false at that point you exit the loop and you move to this location you exit the while loop so this is a natural use for a while loop so this can be written using a for loop but this is a simple example to show how the while loop works let us see a more concrete example where the number of iterations is actually not known so the problem that I am going to post is finding the greatest common divisor of 2 positive numbers let us say the user gives 2 positive numbers let us also assume that m is greater than n there are 2 numbers m and n that are given and let us assume that m is actually greater than n if it is not you can ask the user to give it in that order or you could change m and n so that m actually becomes greater than n that is not the crux but I want you to look at this notion of GCD we are going to use an algorithm called the Euclitz algorithm and this dates back to 300 years before BC so it is a very old algorithm and it is a very neat algorithm so if I want to find out GCD of 2 positive numbers then GCD of m comma n is the same as GCD of n comma m percentage n where percentage transfer modelo and so I have 2 examples below to show that so let us say I want to find out GCD of 43 and 13 see in this case m is 43 and n is 13 and m is actually greater than 13 so the condition that we want to satisfy we start with 43 percentage 13 so 43 percentage 13 is 4 because 13 times 13 times 3 is 39 so 43 divided by 13 gives a reminder of 4 and now you take 13 and the reminder 4 you do 13 percentage 4 that is 1 and then you take 4 percentage 1 this is 0 so at this point you stop and you report this as the GCD right so 43 and 13 are both prime numbers there is no common factor so the common factor is indeed 1 therefore 1 is the GCD let us look at a different example let us say m equals 96 and n equals 28 we start with 96 percentage 28 so 28 3 28 times 3 is 84 therefore 12 is the reminder then you take 28 modelo the reminder that you got in the previous iteration 28 percentage 12 is 4 and 12 percentage 4 is 0 and therefore 4 is the GCD so even though in both these examples we do know that the number of iterations is 3 because we have worked it out up front you may not know what is the number of iterations that is required right so given 2 numbers you do not know the number of iterations that is required up front in such cases the while loop is a natural choice so let us see these basic code we start with if m is greater than n if m is greater than n GCD of m comma n is GCD of n comma m percentage n this is what we want to do and the code segment is as follows so if V is already 0 then there is nothing to do however otherwise what we do is we have a temporary variable called temp we find out U percentage V which is U modelo V that goes as temp and once you do that U becomes V itself and V becomes temp which is what we did here so it is called m and n here it is called U and V in the program so what we did was we took the reminder and called it we will call it V and take the previous divisor call it U and we repeat this at the end of it we will become 0 at some point of time and you report U as the GCD so now let us pay attention to the construct itself and not the logic of the program so what we have is we have while V is not equal to 0 so we keep doing this till we violate this condition and we have two braces here indicating that this is a body of the loop and this body of the loop up front we know we do not know the number of iterations you can see that there is nothing which is doing a iteration count however we are hoping that V will become 0 at some point of time so V does not become 0 at any point of time this while loop will become an infinite loop but because of the property of the numbers and the operations that we are doing here we will indeed become 0 at some point of time and use the GCD of two numbers so again I suggest that you go and try to different examples and ensure that this is actually correct go and verify that this algorithm is actually correct so finally I go one last example for a while loop so again in this at this point we do not know the number of iterations that we are going to execute so the problem is finding the reverse of a positive number so if I want the reverse of the number 234 it is 432 so I need three iterations to find out the reverse but I could give a number which is 19574 and this would be a five digit number you need five iterations in general if I give you a n digit number you need n iterations up front you do not know the number of digits that the user is going to give so the algorithm that we are going to follow is as follows so till the number becomes 0 extract the last digit of the number by doing number is by finding out the number model O 10 so you take a number find number model O 10 that gives you the last digit make it the next digit of the result by multiplying the result by 10 and adding the current digit so I will show you a simple example to make this clear let us say I want to let x be the given number and y be the number that is being computed let us say the user input five six three four two as the number which has to be reversed so 2 is the first digit of the resultant number we want 2 to be the first digit of the resultant number the way we do that is we take five six three four two and do model O 10 right that will get the remainder 2 allow it will extract only the last digit you take that multiply the previous one by 10 and add this to it that will result in 2 and what you do is you take five six three four two divide that by 10 to get five six three four what I mean by divide is you get only the quotient and not the fractional part so five six three four divided by 10 the quotient is five six three four at this point you do percentage 10 again you will get only four you take four and add it to two times 10 the number is 24 so so far we have taken the last two digits and reversed it then you take five six three four itself and again divided by 10 to get five six three and so on if you keep doing this at some point you get two four three six five which is the reverse of five six three four two but at that point x becomes 0 and it is a termination condition so you will keep doing this till x becomes 0 and this is a natural way of using a while loop so let us look at the program itself we have x equals 0 and y equals 0 and you expect the user to give a input number so input and integer and you scan it from the user if the user input 0 itself you check the condition while x is greater than 0 let's say the user gives 0 as the input then the while loop is not even executed once you can directly go and print y equals 0 so we also assume that the user inputs only positive numbers or 0 so if the user inputs 0 this while will not be executed therefore the reverse number is 0 itself however if the user inputs any number greater than 0 then we have y equals 10 times y plus x mod 10 so you remember the evaluation order we have parentheses here this will be evaluated first and that is doing modulo 10 of x that extracts the last digit but it adds it to 10 times y and x itself is diminished by a factor of 10 remember x being an integer the integer division you have integer divided by integer that gives you only the quotient and it truncates the decimal the fractional part so if you so x keeps diminishing by a factor of 10 every time at the end of it you have x equals 0 at that point this while condition is not true anymore when it becomes false you come to the end of the loop and you print the reverse number so this is a full program segment if you type it in your in your editor and compile it it should work let's move to the third construct which is a do while construct and the general form is do statement while expression the semantics is as follows execute the statements and then evaluate the expression so the key key concept is that you executed once and then you evaluate the expression if the expression is true you re-execute the statement otherwise exit the loop so this do while construct is different from the foreign while construct the foreign while constructs both check the condition once even before executing the body of the loop even once however in do while you execute the loop body at least once before you go into checking the condition so let's look at a specific example where do while is natural let's say I want the input numbers to be of a specific kind so I showed you an example earlier where we were checking if the number that is input by the user is a multiple of three or not if it is not we scan the we prompted the user to give this input once more and we scanned it but we had no guarantee that the user actually input a number which is a multiple of three so which means we have to repeatedly keep asking the user till the user actually inputs a multiple of three so this is a natural thing to do with a do while construct so let's see what is happening in this setup here let's as before look at the logic first and then we look at the structure itself so the very first time you have a do there is nothing to check you prompt the user by printing this on the screen and the user is expected to enter a number let's say the user input minus 5 then after this you go and check the loop so now we see an example of ampersand ampersand or the logical and so while x is greater than 0 and x percentage 3 not equal to 0 so the user let's say entered minus 5 minus 5 is not greater than 0 so this condition evaluates to false and this condition also is actually true so minus 5 mod 3 is not equal to 0 however since this evaluates to false and that evaluates to true the overall expression evaluates to false therefore the user has to enter another number at this point you go back here and there is nothing to check you go and print this on the screen once more you scan the users input once more let's say the user now input 9 if the input is 9 x greater than 0 would be true however x mod 3 would still be 0 therefore this while condition is still false you would go back and do the print up statement let's say now the user inputs 5 so we did minus 5 first we did 9 next let's say the user input 5 inputs 5 now and at this point 5 is greater than 0 is true and 5 mod 3 is not equal to 0 is also true therefore 5 is a valid user input at this point you the condition evaluates to true and therefore you stop here so you keep doing this till a certain condition is satisfied so let's look at the construct itself we have the keyword do followed by a block of code and the body of the loop is this one so that is the overall structure for the setup here right so let's look at this in summary in the for loop what we have is we start with an initialization condition we first check an expression if it's true you evaluate the body you do some loop increment and go back right and when you go back you have to evaluate the expression once more at some point this loop increment that you are doing will violate the expression at that point you exit and that's the false branch if you look at the while loop the while loop starts with some body and it checks the expression first if it is true you execute the loop body and come back and evaluate the expression if it is false you exit the loop so the key thing to notice is that this body that you have here must contain something that will change the evaluation of the expression if it doesn't change the evaluation of the expression you will keep doing this loop forever which we want to avoid and this picture clearly shows how do while is different from both these we have a body of the loop that is executed even before the expression is checked once so once you execute the body you then check expression if it is true you go back and execute the body once more if it is false you exit the loop and these are the three basic constructs that is available and see and depending on the problem you need to pick one appropriately so in summary for loops are used whenever you know the number of iterations in which number of iterations that you have to run the body of the loop a while loop is used if you want to check on a condition at least once even before you get to the body but you don't know the number of iterations that you need upfront and do while is used if you want to execute the body at least once even before you check the expression but you don't know the number of times the body is supposed to be executed so there are two ways to change the loop behavior there are two keywords namely break and continue I am not talking about this in this module we will see this later as we see the need for them so far I have been using devc++ to show you program segments I promised earlier that I will actually point out where you can get this devc++ it can be found at sourceforge website at sourceforge <sil=0.929> .PERIOD net slash projects slash or well devcpp it is roughly about 42 megabytes in size you need to download the compiler the debugger the graphical environment and so on it takes about 42 MP in size I suggest that you download and start using that and it takes a few minutes to set up and not more so it is a very useful thing to download so of course there are several other development development environments if you are already using some IDE go ahead and use it if you are coming from the Linux world you are probably used to the shell and you very likely have a GCC or some such compiler installed already you can go ahead and use those also if you are familiar with them but since I am showing a demo using devc++ it may make sense to actually use it so that you can track what you are doing so this is especially useful if you are new to programming I suggest that you actually practice the problems that I have given so far at times I have given complete problem statements at times I am giving only code segments but you have to go and write a complete program you write complete programs whenever you can and whenever it is needed run the programs test with your own inputs and ensure that the programs that I have written so far are indeed correct so it is possible that made some mistakes somewhere along so it is better that you go and check these answers once before you move on to the next lecture so far in this week we have seen basics of programming in C we saw the notions of variables we saw the if statement we saw the switch statement and we saw for while and do while statements we also saw basic operators and how to print and scan inputs from next week onwards we will see more sophisticated uses of these constructs in solving different kinds of problems so we are at the end of lecture 2 thank you <sil=0.904> .PERIOD In the previous module we saw the basics of functions and how it is nice and how it makes it readable and so on <sil=0.902> .PERIOD In this module we will go and look at this notion of functions in lots of gore detail <sil=0.973> .PERIOD So <sil=0.440> ,COMMA what is a function <sil=0.930> ?QUESTIONMARK Function is essentially a part of your program <sil=0.962> .PERIOD So <sil=0.437> ,COMMA one thing that you have to be careful about is it cannot be part of any other function <sil=0.987> .PERIOD A function cannot be part of any other function <sil=0.988> .PERIOD So <sil=0.487> ,COMMA in the previous module we saw that there was a function called main which is the caller and there was a function called power which was the call e <sil=0.910> .PERIOD We cannot go and take the program for power and completely put it within the caller <sil=0.919> .PERIOD So <sil=0.462> ,COMMA function cannot be completely written up inside another function <sil=0.906> .PERIOD So <sil=0.378> ,COMMA there are some languages to allow you to do that <sil=0.980> .PERIOD C does not allow you to do it <sil=0.977> .PERIOD I mentioned this earlier that main itself is a function <sil=0.967> .PERIOD It is the main function <sil=0.983> .PERIOD So <sil=0.610> ,COMMA whenever you have multiple sub tasks <sil=0.304> ,COMMA somebody has to know what is the very first task that you have to start with <sil=0.932> .PERIOD So <sil=0.338> ,COMMA usually it is the main <sil=0.921> .PERIOD So <sil=0.563> ,COMMA you start with main <sil=0.405> ,COMMA main will have a sequence of steps <sil=0.989> .PERIOD If there is any delegation of duty that you want from main <sil=0.425> ,COMMA the main program should have that <sil=0.997> .PERIOD The main function should have the delegation of duty <sil=0.943> .PERIOD So <sil=0.361> ,COMMA we had delegation of duty to power from the main function <sil=0.965> .PERIOD So <sil=0.334> ,COMMA execution starts from the main function <sil=0.984> .PERIOD The control flow starts there <sil=0.977> .PERIOD From there <sil=0.367> ,COMMA the control flow can move to one function or another and return back and so on <sil=0.965> .PERIOD So <sil=0.589> ,COMMA every time you call a new function from a caller <sil=0.627> ,COMMA you are essentially transferring the control to the callee <sil=0.905> .PERIOD So <sil=0.361> ,COMMA with the function call <sil=0.307> ,COMMA you usually pass some parameters <sil=0.979> .PERIOD So <sil=0.593> ,COMMA in our case <sil=0.627> ,COMMA we passed base and n and these parameters are used within the function <sil=0.934> .PERIOD You compute some value <sil=0.481> ,COMMA the value is returned to the caller and the caller could use it in some other computation <sil=0.995> .PERIOD The caller can also choose to ignore the value that is produced <sil=0.930> .PERIOD In fact <sil=0.389> ,COMMA printf to be technically correct actually produces a return value <sil=0.902> .PERIOD Only that generally <sil=0.411> ,COMMA we choose to ignore the return value from printf <sil=0.911> .PERIOD It does some work <sil=0.940> .PERIOD It prints things on the screen <sil=0.911> .PERIOD It actually returns a value also <sil=0.945> .PERIOD Only that we usually do not care about the return value <sil=0.907> .PERIOD It is not useful for most programmers <sil=0.975> .PERIOD Let us look at the template of a function <sil=0.902> .PERIOD We have a function name <sil=0.961> .PERIOD We have all the argument declarations and we have a return type <sil=0.972> .PERIOD And you may want more declarations inside your program itself <sil=0.927> .PERIOD You have further declarations and statements and finally <sil=0.305> ,COMMA you have a return expression <sil=0.923> .PERIOD So <sil=0.591> ,COMMA the function name identifies the name by which you are going to have the subtask called <sil=0.993> .PERIOD It may have a set of arguments <sil=0.960> .PERIOD The arguments will have their names and the order in which the arguments have to be given <sil=0.939> .PERIOD So <sil=0.499> ,COMMA for example <sil=0.442> ,COMMA power of base comma n <sil=0.599> ,COMMA if you pass 3 comma 5 <sil=0.538> ,COMMA it will do 3 power 5 <sil=0.911> .PERIOD Instead <sil=0.635> ,COMMA if you say power of 5 comma 3 <sil=0.396> ,COMMA it will actually raise 5 to 3 <sil=0.954> .PERIOD You will get 125 as the result <sil=0.934> .PERIOD So <sil=0.392> ,COMMA you have to be careful in figuring out what the arguments are and in what order the arguments are passed <sil=0.948> .PERIOD And you have various declarations that are within the functions <sil=0.909> .PERIOD For example <sil=0.636> ,COMMA we needed int i and int p <sil=0.382> ,COMMA which were useful in running the loop and so on <sil=0.940> .PERIOD And finally <sil=0.430> ,COMMA we had a return expression written p earlier and there is a return type in our power function <sil=0.963> .PERIOD It was an integer <sil=0.959> .PERIOD So <sil=0.383> ,COMMA one thing that you have to remember is in the body of a function <sil=0.578> ,COMMA it is a basic block of code and in the body of the function <sil=0.457> ,COMMA you cannot have other function declarations <sil=0.992> .PERIOD So <sil=0.554> ,COMMA it is simply not allowed to have other functions <sil=0.561> ,COMMA which are completely declared and described within another function <sil=0.978> .PERIOD And the arguments essentially form the inputs <sil=0.347> ,COMMA you need both the types and the order <sil=0.905> .PERIOD Sometimes the return expression is optional <sil=0.950> .PERIOD So <sil=0.436> ,COMMA the keyword return can take an expression <sil=0.969> .PERIOD It can also not take any expression and just say return or if you do not even have return <sil=0.535> ,COMMA your program will come to the final closing brace of subtask and automatically it will go back to the caller <sil=0.992> .PERIOD So <sil=0.510> ,COMMA invoking a function is usually done using this function name and you have the set of all the parameters that are passed <sil=0.944> .PERIOD There is this notion of what is called a prototype of a function <sil=0.946> .PERIOD So <sil=0.516> ,COMMA we will see this in a little while <sil=0.952> .PERIOD So <sil=0.397> ,COMMA I had that in the program <sil=0.637> ,COMMA but I did not go into the details earlier <sil=0.946> .PERIOD But we will see what a prototype is <sil=0.913> .PERIOD The prototype essentially defines the number of parameters and the type of each parameter <sil=0.970> .PERIOD It also defines the return value of a function <sil=0.936> .PERIOD So <sil=0.312> ,COMMA a prototype essentially gives you a black box description <sil=0.900> .PERIOD So <sil=0.449> ,COMMA when every function has a prototype followed by the actual definition of the function <sil=0.924> .PERIOD So <sil=0.448> ,COMMA the prototype just tells you what is the black box description <sil=0.414> ,COMMA what are the inputs and what are the outputs and so on <sil=0.988> .PERIOD And somewhere you have to write the program to do the function itself and that is the function implementation <sil=0.956> .PERIOD So <sil=0.407> ,COMMA the prototype is a necessary thing <sil=0.931> .PERIOD The compiler is usually check whether a prototype is present or not <sil=0.987> .PERIOD And if you give a prototype <sil=0.587> ,COMMA a compiler can actually indicate warnings if you have if you have messed up something <sil=0.900> .PERIOD Let us say you have written a function and it takes three parameters and let us say everywhere you called it <sil=0.535> ,COMMA you have only two parameters that are passed <sil=0.989> .PERIOD A compiler can spot it and tell you that this function expects three parameters and you have passed only two <sil=0.932> .PERIOD So <sil=0.514> ,COMMA the prototype here is for power is as follows <sil=0.311> ,COMMA int power of int comma int <sil=0.978> .PERIOD So <sil=0.539> ,COMMA in this place we have actually not named the parameters at all <sil=0.989> .PERIOD Power does take two parameters <sil=0.543> ,COMMA but the names are not mentioned <sil=0.916> .PERIOD So <sil=0.573> ,COMMA a compiler when it looks at this prototype knows that power is supposed to be a function which takes two integers returns another integer <sil=0.990> .PERIOD At this point <sil=0.561> ,COMMA the compiler would not know whether base is the first parameter and n is the second parameter or n is the first parameter and base is the second parameter <sil=0.941> .PERIOD Actually it does not care at this point of time <sil=0.998> .PERIOD However <sil=0.454> ,COMMA later we actually put the variables base and n here and write a program appropriately <sil=0.974> .PERIOD Typically function programs are function prototypes are given in the beginning of the program <sil=0.966> .PERIOD So <sil=0.496> ,COMMA let us see this <sil=0.949> .PERIOD I am showing the same piece of code that we had earlier <sil=0.913> .PERIOD We have this power function <sil=0.995> .PERIOD So <sil=0.470> ,COMMA what you see on the right side is called the function definition or function description and what you see in this line here on the left side is called the function prototype <sil=0.998> .PERIOD So <sil=0.476> ,COMMA we have function prototype and function definition <sil=0.908> .PERIOD So <sil=0.561> ,COMMA the function prototype by itself is not very interesting <sil=0.495> ,COMMA but it is necessary to tell the compiler as well as tell the other programmers that power actually expects two variables and it will return only an integer <sil=0.939> .PERIOD It is not going to return a character <sil=0.948> .PERIOD It is not going to return a floating point value and so on <sil=0.933> .PERIOD So <sil=0.337> ,COMMA so that anyone who uses the function knows what they are getting into <sil=0.909> .PERIOD So <sil=0.341> ,COMMA this is called the function prototype and this is called the function invocation <sil=0.951> .PERIOD So <sil=0.568> ,COMMA whenever we call the function <sil=0.531> ,COMMA we call that function invocation or calling the function <sil=0.914> .PERIOD So <sil=0.567> ,COMMA earlier I said I want to touch upon what is called the control flow <sil=0.941> .PERIOD I said flows the program flows starts with the main program and whenever it calls a function it goes there and so on <sil=0.958> .PERIOD So <sil=0.505> ,COMMA I want to make that slightly more clear now <sil=0.994> .PERIOD So <sil=0.566> ,COMMA let us look at this piece of program and let us see how this function how this program is going to get executed <sil=0.902> .PERIOD So <sil=0.590> ,COMMA as I said earlier all executions start with main right you start with main <sil=0.936> .PERIOD So <sil=0.432> ,COMMA at this point you have two declarations number one and number two <sil=0.957> .PERIOD So <sil=0.542> ,COMMA as with any variables the compiler would have allocated memory for number one and number two <sil=0.971> .PERIOD So <sil=0.639> ,COMMA I am ready to execute this line number one is power of 3 comma 5 <sil=0.963> .PERIOD At that point what happens is instead of getting to the next line here which is what happens usually right <sil=0.900> .PERIOD So <sil=0.513> ,COMMA when we looked at programs so far for loops and other things we always recent how this sequence of code that you see on the screen how will get how will it get executed internally <sil=0.982> .PERIOD So <sil=0.483> ,COMMA if you have no loops or branches you start from line one you go to line two line three line four up to line nine and you return <sil=0.990> .PERIOD If you have iftinal branches either if condition is true or else condition is true and only one of them works if you have a for loop you have a repeated body and so on right <sil=0.916> .PERIOD All those were examples of control flow this is one another example of control flow <sil=0.974> .PERIOD So <sil=0.462> ,COMMA at this point if you are in line number two within main the control gets transferred to line number one of power and then you go and actually do this sequence of operations and once this sequence of operations is done you return back to this line when you return back what happens is you have computed the value power of 3 comma 5 it should have computed number 243 as the result and that is assigned to number one <sil=0.931> .PERIOD Now <sil=0.523> ,COMMA you are again back in the caller in the caller you will by default go to the next line right <sil=0.908> .PERIOD So <sil=0.618> ,COMMA the next line is also a function invocation or a function call again the control is transferred to the call e the call e it goes through the sequence of code here at the end of it you return back to the caller in this case minus 4 comma 3 would have computed minus 64 that value is assigned to number two <sil=0.952> .PERIOD So <sil=0.590> ,COMMA it returns to this location and then you are ready to do printing off both these numbers <sil=0.956> .PERIOD So <sil=0.634> ,COMMA the control flow for this program is you start with main at this line you call this site <sil=0.954> .PERIOD So <sil=0.574> ,COMMA remember for every assignment operation you evaluate the right side and you assign it to the left side right <sil=0.944> .PERIOD So <sil=0.394> ,COMMA there is evaluation on the right side <sil=0.906> .PERIOD So <sil=0.459> ,COMMA power of 3 comma 5 would transfer the control to the power function and you do the sequence of steps the control comes back here you do this assignment the control falls to the next line by default again the next line on the right side it it makes a function call you do this you come back here do the assignment and you have a printf followed by another printf and so on <sil=0.975> .PERIOD In fact <sil=0.393> ,COMMA technically printf is another function <sil=0.910> .PERIOD So <sil=0.385> ,COMMA when you come here printf is a function which takes two parameters a format and a value here these two are the parameters that are passed to printf in fact <sil=0.391> ,COMMA what is hidden is what is happening inside printf <sil=0.943> .PERIOD So <sil=0.478> ,COMMA the control actually gets transferred to printf printf does whatever it has to do to print things on the screen it comes back to this line and the next line it moves to the caller next line again it is a call to printf you go to the internals of printf whatever it does to print on the screen it does it comes back here and then it comes here and returns comes to this line with the return and the last line in the caller is in the main function is return 0 it returns 0 <sil=0.968> .PERIOD So <sil=0.637> ,COMMA if you notice main is a function this is the function name that is the return value and this is the return statement and main is a function which has not taken any parameters <sil=0.932> .PERIOD So <sil=0.590> ,COMMA there are ways in which you can take inputs to main also we will probably cover that in a later class <sil=0.935> .PERIOD So <sil=0.347> ,COMMA main is a function and so is power and so is printf and scanf and so on <sil=0.949> .PERIOD So <sil=0.540> ,COMMA I want to show a slightly different example where we use the same power function inside a loop <sil=0.991> .PERIOD So <sil=0.394> ,COMMA we have int power int int so this says that this is a prototype which takes two integers and returns an integer and what we have done is inside main we have a loop for int i equals 0 i less than 20 i plus plus we are printing i 3 power i and minus 4 power i <sil=0.945> .PERIOD So <sil=0.547> ,COMMA and we have this function for computing power <sil=1.000> .PERIOD So <sil=0.570> ,COMMA this is a slightly more complicated control flow <sil=0.932> .PERIOD So <sil=0.367> ,COMMA we start with here main the first line after that is a for loop the for loop will initialize i equal to 0 it will check if i is less than 20 or not <sil=0.917> .PERIOD So <sil=0.356> ,COMMA when it is 0 it is actually less than 20 and it comes to this line <sil=0.943> .PERIOD So <sil=0.351> ,COMMA when you go to printf it actually requires i 3 power i and minus 4 power i only if you know the values you can print them <sil=0.982> .PERIOD So <sil=0.634> ,COMMA when you see power of 3 comma i it actually makes a function call to 3 power i <sil=0.920> .PERIOD It makes a function call to 3 power i it computes the result you get the result back and then you have my power of minus 4 power i this power function computes the result it comes back <sil=0.964> .PERIOD So <sil=0.632> ,COMMA you have i which comes from the loop 3 power i would have come from the power function minus 4 power i would have come from the power function printf has all the values that it requires it would print things on the screen and then the control comes to this location <sil=0.994> .PERIOD At this point it says it is the time to check go to the end of this for loop which is i plus plus <sil=0.983> .PERIOD So <sil=0.302> ,COMMA you are supposed to do the post loop function which is i plus plus check again whether i is less than 20 <sil=0.953> .PERIOD So <sil=0.479> ,COMMA i would have become 1 it is still less than 20 again it comes to this line which has printf <sil=0.933> .PERIOD At this point it makes two function calls get its arguments prints things on the screen comes back to the end of this for statement at that point you do increment of i again and so on <sil=0.991> .PERIOD So <sil=0.591> ,COMMA this is a slightly more complicated control flow <sil=0.943> .PERIOD So <sil=0.427> ,COMMA you have loops and you have various function calls here <sil=0.981> .PERIOD So <sil=0.639> ,COMMA let us take this example where i equals 3 is done <sil=0.929> .PERIOD So <sil=0.598> ,COMMA let us say for at some point i would have been 3 in the loop let us see how that would have done how that would have happened <sil=0.905> .PERIOD So <sil=0.542> ,COMMA when i equals 3 the printf would see that there is a call to power so power of 3 comma 5 3 comma i at that point that transfer goes to this segment and since you are returning 3 power i which is in this case 3 power 3 which is 27 the result comes back and that is a temporary place holder <sil=0.994> .PERIOD So <sil=0.351> ,COMMA 27 comes back you have i which is already present and you have 27 <sil=0.922> .PERIOD So <sil=0.484> ,COMMA you have two parameters ready printf still needs one more parameter for it to print <sil=0.944> .PERIOD So <sil=0.462> ,COMMA at that point you see that it is power of minus 4 comma i that gets evaluated the result is minus 64 that comes back as a value to the printf <sil=0.939> .PERIOD So <sil=0.587> ,COMMA at this point you have 3 27 and minus 64 printf has everything that it needs to print <sil=0.982> .PERIOD So <sil=0.310> ,COMMA printf function will be called at that point you have you will print 3 comma 27 <sil=0.961> .PERIOD So <sil=0.570> ,COMMA 3 space 27 space minus 64 on the screen and then you are ready to go to the next iteration in i <sil=0.919> .PERIOD In this module we look at how to work with one dimensional arrays <sil=0.571> ,COMMA I am going to show more detailed examples and also write small programs for some sample problems <sil=0.948> .PERIOD Let us look at this piece of code <sil=0.920> .PERIOD What this piece of code does is actually read values <sil=0.983> .PERIOD So <sil=0.422> ,COMMA it says enter value of element number percent hd <sil=0.972> .PERIOD You are reading some values into values of i and you are printing them <sil=0.967> .PERIOD So <sil=0.420> ,COMMA it is a fairly simple program <sil=0.943> .PERIOD So <sil=0.569> ,COMMA I am reading values and I am printing the values <sil=0.989> .PERIOD So <sil=0.428> ,COMMA one thing that happens in real world is that many times you do not know what is the number of things that you want ahead of time <sil=0.903> .PERIOD So <sil=0.315> ,COMMA we want to be able to write generic programs which means I do not want a program to be of a fixed size <sil=0.969> .PERIOD So <sil=0.640> ,COMMA let us say in the previous example temperature I declared it to be 365 <sil=0.956> .PERIOD What if I had a leap year <sil=0.950> ?QUESTIONMARK In which case I need 365 days and not 365 days <sil=0.994> .PERIOD So <sil=0.437> ,COMMA I need a mechanism by which I want this in a generic fashion and that is where C comes in very handy with something called hash define <sil=0.944> .PERIOD So <sil=0.496> ,COMMA as of now <sil=0.424> ,COMMA so see this lines line 2 hash define n 6 <sil=0.995> .PERIOD So <sil=0.470> ,COMMA what this does is wherever you see a symbol n it is going to replace that with value 6 <sil=0.945> .PERIOD So <sil=0.610> ,COMMA now if I go and look at this loop <sil=0.471> ,COMMA let us see how to make sense of this loop for i equals 0 i less than n i plus plus <sil=0.991> .PERIOD Wherever you see n the C pre compiler pre processor will replace that with 6 <sil=0.962> .PERIOD So <sil=0.383> ,COMMA this loop will run from 0 to 6 <sil=0.941> .PERIOD So <sil=0.594> ,COMMA what this loop will do is read 7 elements numbered values of 0 to values of 6 <sil=0.948> .PERIOD And this loop also runs on same n <sil=0.970> .PERIOD So <sil=0.395> ,COMMA it will print values of 0 to values of 6 <sil=0.951> .PERIOD So <sil=0.407> ,COMMA we have declared the array with values of n <sil=0.975> .PERIOD n is not a variable <sil=0.991> .PERIOD So <sil=0.455> ,COMMA n takes the value 6 here <sil=0.911> .PERIOD So <sil=0.397> ,COMMA wherever you see n assume that it is number 6 there <sil=0.906> .PERIOD So <sil=0.526> ,COMMA what you are essentially doing is it is equivalent to saying n values of 6 <sil=0.911> .PERIOD And you have a for loop running from i equals 0 i less than 6 i plus plus and so on <sil=0.920> .PERIOD So <sil=0.567> ,COMMA we have indices that go from 0 to 5 <sil=0.940> .PERIOD I am sorry it is 0 to 5 and not 0 to 6 <sil=0.950> .PERIOD And this loop also runs from 0 to 5 <sil=0.955> .PERIOD So <sil=0.629> ,COMMA we have 6 locations numbered 0 to 5 <sil=0.944> .PERIOD So <sil=0.544> ,COMMA this generic value is very useful <sil=0.907> .PERIOD But one small thing that you have to be careful about is that if I change this n to let us say 10 <sil=0.388> ,COMMA I expect 10 values numbered 0 to 9 <sil=0.902> .PERIOD But if I change the source code it is not enough <sil=0.972> .PERIOD Remember once we have a change in the source code we have to save it <sil=0.627> ,COMMA compile it and then run it <sil=0.903> .PERIOD So <sil=0.388> ,COMMA whenever you have a change in the source program you have to save compile <sil=0.448> ,COMMA run if you want to change the value of n <sil=0.977> .PERIOD It cannot be a single change in the source program and which will automatically reflect in the binary to be different <sil=0.993> .PERIOD So <sil=0.463> ,COMMA whenever there is a change in source program remember you have to compile and you have to save compile and run it <sil=0.923> .PERIOD So <sil=0.328> ,COMMA from now on we will try and use generic as much as possible <sil=0.981> .PERIOD So <sil=0.455> ,COMMA the first exercise that we are going to look at is the notion of Fibonacci numbers <sil=0.985> .PERIOD So <sil=0.313> ,COMMA Fibonacci numbers are very interesting <sil=0.959> .PERIOD They come in various places later <sil=0.937> .PERIOD So <sil=0.497> ,COMMA Fibonacci numbers go like this <sil=0.905> .PERIOD The first Fibonacci number is 0 the next number is 1 and from there on the Fibonacci numbers go in this fashion <sil=0.972> .PERIOD You take the previous 2 add them and that gives you the next Fibonacci number <sil=0.970> .PERIOD So <sil=0.504> ,COMMA 0 plus 1 is 1 <sil=0.932> .PERIOD Then the next Fibonacci number is take 1 and so <sil=0.557> ,COMMA take the previous 2 add them the next number is 2 <sil=0.968> .PERIOD Then again you take the 2 previous ones add them it is 3 and so on <sil=0.939> .PERIOD So <sil=0.479> ,COMMA the Fibonacci numbers go in the sequence 0 <sil=0.592> ,COMMA 1 <sil=0.412> ,COMMA 1 <sil=0.504> ,COMMA 2 <sil=0.531> ,COMMA 3 <sil=0.308> ,COMMA 5 <sil=0.337> ,COMMA 8 <sil=0.479> ,COMMA 11 sorry 5 <sil=0.507> ,COMMA 8 <sil=0.348> ,COMMA 13 and so on <sil=0.900> .PERIOD So <sil=0.330> ,COMMA this is the Fibonacci sequence <sil=0.923> .PERIOD So <sil=0.340> ,COMMA let us say I want to write a program to do exactly this <sil=0.908> .PERIOD So <sil=0.386> ,COMMA till now we were scanning the values from the user <sil=0.968> .PERIOD Now <sil=0.515> ,COMMA we have a program in which it will actually fill in the values <sil=0.927> .PERIOD So <sil=0.528> ,COMMA we are going to generate the first n Fibonacci numbers <sil=0.986> .PERIOD So <sil=0.594> ,COMMA as before we have a hash defined n so <sil=0.565> ,COMMA what we want is we want the first 10 Fibonacci numbers starting from 0 <sil=0.970> .PERIOD So <sil=0.523> ,COMMA we declare an array called Fib of n <sil=0.953> .PERIOD So <sil=0.437> ,COMMA this will declare 10 memory locations and you can address them as Fibonacci 0 to Fibonacci n <sil=0.957> .PERIOD We already know the values of Fibonacci 0 and Fibonacci 1 and what the loop is going to do is it is going to run from 2 to 9 <sil=0.970> .PERIOD So <sil=0.605> ,COMMA you have i less than n which means i less than 10 <sil=0.994> .PERIOD So <sil=0.570> ,COMMA it runs from 2 to 9 <sil=0.999> .PERIOD So <sil=0.513> ,COMMA i equal to 0 and i equal to 1 are already taken care of <sil=0.910> .PERIOD When you run from 2 to 9 you get another 8 values <sil=0.972> .PERIOD So <sil=0.367> ,COMMA overall you are filling up 10 values of Fibonacci <sil=0.905> .PERIOD And as I showed earlier we have we have to take a particular index i and we look at location i minus 1 and we look at location i minus 2 <sil=0.925> .PERIOD When we add these 2 we get Fib of i <sil=0.909> .PERIOD That is exactly what this line is doing <sil=0.968> .PERIOD We take Fib of i minus 1 and Fib of i minus 2 add that and put it in Fib of i <sil=0.919> .PERIOD So <sil=0.554> ,COMMA the first time when i equals 2 Fib of 2 will get updated with 0 plus 1 which is 1 <sil=0.976> .PERIOD Then you go back to the loop you check whether 2 is less than 10 <sil=0.476> ,COMMA yes 2 is less than 10 <sil=0.976> .PERIOD So <sil=0.531> ,COMMA you increment you get 3 <sil=0.956> .PERIOD So <sil=0.380> ,COMMA then you are ready to you are now ready to do Fib of 3 is Fib of 2 plus Fib of 1 which is 1 plus 1 giving 2 and so on <sil=0.973> .PERIOD So <sil=0.413> ,COMMA what you are having is a loop that runs from 2 to 9 and it is taking the previous 2 values and adding them and storing them in Fib of i <sil=0.994> .PERIOD So <sil=0.356> ,COMMA at the end of the loop you will have numbers from numbers of this form <sil=0.908> .PERIOD So <sil=0.360> ,COMMA 0 <sil=0.445> ,COMMA 1 <sil=0.378> ,COMMA 1 <sil=0.424> ,COMMA 2 <sil=0.508> ,COMMA 3 <sil=0.422> ,COMMA 5 <sil=0.332> ,COMMA 8 <sil=0.530> ,COMMA 13 <sil=0.558> ,COMMA 21 and 34 <sil=0.906> .PERIOD So <sil=0.366> ,COMMA that gives us the first 10 values of Fib and notchi series <sil=0.910> .PERIOD So <sil=0.337> ,COMMA you will see the array Fib filled up from 0 to 34 and you can print them here <sil=0.979> .PERIOD If I want the first 100 numbers let us say all I have to do is I do not have to go and touch the program anymore <sil=0.971> .PERIOD I go and change the hash define I now write hash define N 100 this changes N to 100 all I have to do is save it and compile it <sil=0.971> .PERIOD I do not have to go and touch these other lines where I see N <sil=0.990> .PERIOD So <sil=0.394> ,COMMA this is very useful <sil=0.913> .PERIOD So <sil=0.536> ,COMMA initially what we do is we keep values which are very small <sil=0.938> .PERIOD So <sil=0.522> ,COMMA that we can test the programs and then maybe I want something some example where N is very large <sil=0.933> .PERIOD I tested with very small values ensure that it works fine and then I go and change it to some other larger value <sil=0.926> .PERIOD We will see a similar example later <sil=0.988> .PERIOD But once we have this we can now move on to other exercises <sil=0.991> .PERIOD In this exercise the crucial point is we did not have Fib of i filled up with values <sil=0.926> .PERIOD It starts out with uninitialized values and slowly you fill them up one after the other from Fib of 2 to Fib of 9 <sil=0.991> .PERIOD So <sil=0.518> ,COMMA I now I let us move to another example <sil=0.977> .PERIOD Let us say you are taking this course and about let us say 1000 students are taking this course and I want to find out how you students rate the class <sil=0.920> .PERIOD I give a mechanism for you to rate the class you can rate the class from 1 to 5 and at the end of the course I may want to see how the ratings of this course are spread <sil=0.992> .PERIOD So <sil=0.376> ,COMMA each student is supposed to give a rating 1 2 3 4 or 5 <sil=0.617> ,COMMA 1 being bad and 5 being good let us say and at the end of it I want to see how many people said good <sil=0.551> ,COMMA how many people said ok <sil=0.526> ,COMMA how many people said bad and so on <sil=0.922> .PERIOD I want that <sil=0.921> .PERIOD So <sil=0.618> ,COMMA this is something that is very common and what I want is I want to count the number of times each rating is given <sil=0.964> .PERIOD So <sil=0.406> ,COMMA maybe I want to see that oh there are 10 people who gave very good rating <sil=0.406> ,COMMA 100 people who gave good and so on <sil=0.958> .PERIOD So <sil=0.637> ,COMMA I want to see numbers like that right <sil=0.965> .PERIOD So <sil=0.640> ,COMMA let us see how to write a program to do that <sil=0.980> .PERIOD So <sil=0.603> ,COMMA I am going to maintain an array called rating counters that is the array name that I am going to use and I know that the valid ratings are 1 to 5 <sil=0.937> .PERIOD So <sil=0.515> ,COMMA I am going to have 1 2 3 4 5 I have 5 locations and rating counters of I is going to maintain the record of how many students rated the course as I <sil=0.942> .PERIOD So <sil=0.372> ,COMMA if 5 students gave rating 1 I would expect rating counters of 1 to be containing the value of 5 right <sil=0.929> .PERIOD So <sil=0.416> ,COMMA one thing is since the ratings are only 1 to 5 however <sil=0.631> ,COMMA array indices start from 0 what I am going to do is I am going to declare an array of size 6 and I will not use location 0 right <sil=0.936> .PERIOD Therefore <sil=0.485> ,COMMA my even though my arrays actually is 6 elements I want only 5 of those I am using part of the array I am not using the whole array <sil=0.999> .PERIOD So <sil=0.594> ,COMMA this makes the programming slightly more easier <sil=0.934> .PERIOD Let us see how to write this program <sil=0.988> .PERIOD So <sil=0.534> ,COMMA let us say there are only 5 students and the 5 students gave the rating 5 1 2 1 and 5 right <sil=0.928> .PERIOD So <sil=0.359> ,COMMA let us say these are the ratings that were given by students and what I would like to do is go one user at a time <sil=0.945> .PERIOD So <sil=0.607> ,COMMA the first user gave 5 <sil=0.936> .PERIOD So <sil=0.496> ,COMMA I would want this one to be a count of 1 then the second user gave 1 I want this to be a count of 1 the third user gave 2 I want this to be a count of 1 also the fourth user gave 1 which means now there are 2 people who gave rating 1 <sil=0.904> .PERIOD So <sil=0.534> ,COMMA I want this to be 2 and so on <sil=0.971> .PERIOD In general what I want is as soon as I get a rating I want to do a plus plus on the array location which contains the response <sil=0.964> .PERIOD If I get response as let us say 5 I want to go to location 5 and increment the current value <sil=0.948> .PERIOD So <sil=0.312> ,COMMA however <sil=0.579> ,COMMA one thing you have to pay attention to is since we are doing increment we are going to do a plus plus we should ensure that all of these entries are set up at 0 <sil=0.970> .PERIOD If you start with unknown values you may end up with counters which are incorrect <sil=0.938> .PERIOD So <sil=0.395> ,COMMA we assume that all the counters are initialized to 0 we start from there <sil=0.970> .PERIOD So <sil=0.619> ,COMMA let us see how a program of this kind will work <sil=0.948> .PERIOD So <sil=0.625> ,COMMA I have in rating counters of 6 as I said earlier I am going to accommodate 6 locations <sil=0.549> ,COMMA but my actual entries that I am concerned about are rating counters of 1 to rating counters of 5 <sil=0.906> .PERIOD So <sil=0.412> ,COMMA even though I initialize this to 0 I am not really going to touch rating counters of 0 at all I am going to touch rating counters of 1 to rating counters of 5 <sil=0.968> .PERIOD So <sil=0.300> ,COMMA I have this loop which runs from I equal to 1 up to 1000 including 1000 for I equals 1 I less than equal to 1000 plus plus I <sil=0.986> .PERIOD So <sil=0.318> ,COMMA at this point we are scanning 1000 responses and for each each user or each student we are going to take a response <sil=0.934> .PERIOD And we are going first of all going to check if the response is less than 1 or if it is greater than 5 these are invalid responses <sil=0.942> .PERIOD So <sil=0.535> ,COMMA I said the ratings have to be from 1 to 5 as integers <sil=0.994> .PERIOD So <sil=0.344> ,COMMA if it is anything less than 1 or if it is greater than 5 it is a bad response we do not record it <sil=0.902> .PERIOD So <sil=0.578> ,COMMA we will record only valid responses and if it is a valid response we are going to increment the corresponding counter <sil=0.953> .PERIOD So <sil=0.647> ,COMMA remember there are 5 counters rating counters of 1 to rating counters of 5 and based on the response you index that particular counter and increment it <sil=0.966> .PERIOD So <sil=0.301> ,COMMA again if you want to break it down you can think of it as plus plus on a variable and which variable are you incrementing you are incrementing the variable for which you got the response <sil=0.911> .PERIOD So <sil=0.454> ,COMMA if the first user gave 1 as the response rating counters of 1 is going to get incremented <sil=0.952> .PERIOD If the 500th user gave a rating of 5 I would be 500 and rating counters of 5 will be incremented by 1 <sil=0.974> .PERIOD And once you are done with this loop you can now print the rating <sil=0.968> .PERIOD So <sil=0.627> ,COMMA we print rating and the number of responses <sil=0.951> .PERIOD So <sil=0.595> ,COMMA we run from 1 to 5 both inclusive and we print the two values <sil=0.920> .PERIOD What are we printing <sil=0.949> ?QUESTIONMARK We are printing the rating I and we print the count <sil=0.954> .PERIOD So <sil=0.487> ,COMMA at the end of this if I scan 1000 inputs the output would look something like this <sil=0.971> .PERIOD Response of 1 came from 15 people <sil=0.975> .PERIOD Response of 2 came from 85 people <sil=0.960> .PERIOD Response 3 came from 100 people <sil=0.979> .PERIOD Response 4 came from 500 people and response 5 may be came from 300 <sil=0.988> .PERIOD So <sil=0.649> ,COMMA in this case all the users let us say gave valid responses <sil=0.912> .PERIOD 5 people gave 300 <sil=0.341> ,COMMA 4 people gave 500 and so on the summation of this will be 1000 <sil=0.930> .PERIOD So <sil=0.571> ,COMMA that is a quick way to check whether your program is correct or not <sil=0.930> .PERIOD If let us say 5 people gave invalid responses then the count will not be 1000 the addition of this would give you 995 and not 1000 <sil=0.938> .PERIOD So <sil=0.547> ,COMMA I suggest that you take this program and write it in the editor that I showed you in the last lecture and ensure that this actually works <sil=0.992> .PERIOD So <sil=0.602> ,COMMA we use these 7 variables <sil=0.440> ,COMMA ABCD <sil=0.477> ,COMMA P2P1P0 and these are called variables <sil=0.993> .PERIOD So <sil=0.626> ,COMMA every memory location is given a name <sil=0.934> .PERIOD So <sil=0.530> ,COMMA if you have a variable <sil=0.439> ,COMMA you use a name and this name is something that you give so that you can remember what it is about and in turn this variable name is attached to a memory location when you run the program <sil=0.917> .PERIOD So <sil=0.385> ,COMMA the name is <sil=0.333> ,COMMA so when you say A <sil=0.633> ,COMMA the variable name A <sil=0.589> ,COMMA you are actually referring to the value at location that you are going to call A and when you say A times B <sil=0.600> ,COMMA it is actually going to take the value at location A and value at location B and multiply them together <sil=0.970> .PERIOD So <sil=0.613> ,COMMA the name is actually referring to the data and you usually have names which make some sense to you <sil=0.948> .PERIOD So <sil=0.386> ,COMMA it could be role number <sil=0.644> ,COMMA class size or in our example we use P2 <sil=0.351> ,COMMA AB <sil=0.448> ,COMMA etc <sil=0.945> .PERIOD So <sil=0.311> ,COMMA these variables have some kind of data type attached with them <sil=0.929> .PERIOD So <sil=0.487> ,COMMA in our example <sil=0.327> ,COMMA we expected ABCD to be integers or we wrote the program to be in such a way that they are integers and P2P1P0 are also integers <sil=0.953> .PERIOD So <sil=0.455> ,COMMA because they are integers <sil=0.366> ,COMMA they cannot have something like a string <sil=0.962> .PERIOD Let's say it cannot have my name assigned to A <sil=0.364> ,COMMA A equal to Shankar does not make sense <sil=0.358> ,COMMA A should be a number <sil=0.951> .PERIOD Then all the data internal to the computer is actually represented as a sequence of 1s and 0s <sil=0.302> ,COMMA of some particular size or some predetermined size which we will call word <sil=0.929> .PERIOD So <sil=0.522> ,COMMA this integer is supposed to be of certain number of bytes and usually integers of size 4 bytes <sil=0.967> .PERIOD Then there are these various operations that we did <sil=0.980> .PERIOD So <sil=0.372> ,COMMA if you look at A times C which is assigned to P2 <sil=0.575> ,COMMA then the star is an operation <sil=0.397> ,COMMA the assignment itself is an operation and so on <sil=0.952> .PERIOD So <sil=0.578> ,COMMA instructions take the data that is stored in the variables as arguments and some of these instructions actually perform operations <sil=0.965> .PERIOD For example <sil=0.408> ,COMMA if I do X equals X plus 1 <sil=0.469> ,COMMA it takes the integer X <sil=0.599> ,COMMA add 1 to it and the result is then put back in the same location X <sil=0.958> .PERIOD And some other instructions actually do change the order in which the program is run and these are called control instructions <sil=0.531> ,COMMA we will see them in a little more detail later <sil=0.947> .PERIOD So <sil=0.397> ,COMMA I wanted to look at this X equals X plus 1 in a little more carefully <sil=0.955> .PERIOD So <sil=0.634> ,COMMA if you do basic algebra <sil=0.373> ,COMMA you may be confused about this statement <sil=0.971> .PERIOD So <sil=0.605> ,COMMA let's say X equals X plus 1 is written in a C program and you look at it <sil=0.648> ,COMMA if you do basic algebra from your sixth grade of seventh grade <sil=0.570> ,COMMA you would cancel X on both the sides and you would be looking at 0 equals 1 <sil=0.933> .PERIOD So <sil=0.417> ,COMMA but that is indeed not the case <sil=0.925> .PERIOD So <sil=0.328> ,COMMA the assignment operation is something which is different <sil=0.989> .PERIOD Don't treat the equality as don't treat the sign equals to as though it is an equality <sil=0.969> .PERIOD So <sil=0.569> ,COMMA the way it should be looked at is it is a statement <sil=0.404> ,COMMA it has to be executed and the way it is done is you execute whatever is on the right side <sil=0.405> ,COMMA you get a result from there <sil=0.599> ,COMMA you take that result and put that result on the variable on the left side <sil=0.923> .PERIOD So <sil=0.363> ,COMMA let's look at the program <sil=0.318> ,COMMA a program is a sequence of instructions <sil=0.941> .PERIOD Normally the processor will work in the following sequence of steps <sil=0.913> .PERIOD Step A would be pick the next instruction in the sequence <sil=0.337> ,COMMA then step B would be get data that is required for the instruction to operate upon <sil=0.601> ,COMMA execute the instruction on the data <sil=0.917> .PERIOD So <sil=0.529> ,COMMA if it is star <sil=0.391> ,COMMA then you do multiply if it is plus you add and so on <sil=0.951> .PERIOD And a step D would be take it and store it back as a result somewhere <sil=0.542> ,COMMA it could be either a memory location or it could be some internal storage like 4 and 6 were stored in our steps <sil=0.955> .PERIOD And finally <sil=0.614> ,COMMA go back to step A itself <sil=0.521> ,COMMA look for the next instruction and so on <sil=0.980> .PERIOD So <sil=0.603> ,COMMA this is going to be repeated in a loop <sil=0.915> .PERIOD So <sil=0.536> ,COMMA you pick the instruction <sil=0.599> ,COMMA you pick the data that is required for it <sil=0.569> ,COMMA you do the operation <sil=0.575> ,COMMA store the result <sil=0.470> ,COMMA go back and pick the next instruction and keep doing this till there are no more instructions for the particular program <sil=0.902> .PERIOD So <sil=0.331> ,COMMA let's look take a careful look at what the assignment itself means <sil=0.905> .PERIOD So <sil=0.504> ,COMMA this equality or the equal symbol that you saw is called the assignment operator <sil=0.964> .PERIOD So <sil=0.302> ,COMMA when you say when you see P 2 equals A into C <sil=0.582> ,COMMA you multiply A with C and the result is assigned to the variable on the left side called P 2 <sil=0.947> .PERIOD Therefore <sil=0.645> ,COMMA we call this equality and assignment operator <sil=0.417> ,COMMA it takes the value and puts it in the memory location P 2 <sil=0.960> .PERIOD Therefore <sil=0.536> ,COMMA it is doing an operation which is a memory operation <sil=0.990> .PERIOD In this case <sil=0.462> ,COMMA it is a memory write operation <sil=0.457> ,COMMA you are writing to memory <sil=0.963> .PERIOD So <sil=0.591> ,COMMA it is an assignment operator <sil=0.975> .PERIOD So <sil=0.339> ,COMMA the value of a variable could be modified due to an assignment <sil=0.939> .PERIOD So <sil=0.541> ,COMMA the way it works is the left hand side is the variable to be modified <sil=0.995> .PERIOD And right hand side is the value to be assigned <sil=0.992> .PERIOD So <sil=0.332> ,COMMA you have variable name equals value <sil=0.939> .PERIOD So <sil=0.408> ,COMMA if you have A equals to 1 as the assignment statement <sil=0.624> ,COMMA then 1 is the value that gets assigned to A <sil=0.991> .PERIOD If you have A equals to C <sil=0.471> ,COMMA C could itself be another variable <sil=0.970> .PERIOD You do not copy the character C into A <sil=0.998> .PERIOD Instead <sil=0.432> ,COMMA you go and look at the variable called C <sil=0.642> ,COMMA look at the value that C contains and copy that value into A <sil=0.971> .PERIOD If you have something like A equals A into B plus D by E <sil=0.458> ,COMMA then you actually take the variable value contained in the variable A <sil=0.524> ,COMMA multiply that by the value contained in the variable B <sil=0.448> ,COMMA store it temporarily <sil=0.967> .PERIOD Then take D and E <sil=0.611> ,COMMA the values contained in these variables <sil=0.482> ,COMMA divide D by E <sil=0.333> ,COMMA store it again temporarily <sil=0.580> ,COMMA add these two and put it back in the memory location A itself <sil=0.906> .PERIOD So <sil=0.533> ,COMMA the process is the right hand side is evaluated first <sil=0.950> .PERIOD So <sil=0.437> ,COMMA you would evaluate this right hand side first and after completing and only after completing all the operations on the right hand side <sil=0.377> ,COMMA the assignment operation is performed <sil=0.987> .PERIOD This will write the result back onto the left hand side <sil=0.999> .PERIOD So <sil=0.440> ,COMMA variables and constants are two typical things <sil=0.929> .PERIOD So <sil=0.301> ,COMMA this is where I want to bring this distinction between what is a variable and what is a constant <sil=0.978> .PERIOD So <sil=0.471> ,COMMA a variable is something that can change during the execution of a program <sil=0.398> ,COMMA whereas a constant cannot change its value during the execution <sil=0.972> .PERIOD So <sil=0.525> ,COMMA you look at A equals 1 <sil=0.587> ,COMMA A is a variable here <sil=0.361> ,COMMA 1 is number 1 <sil=0.946> .PERIOD Number 1 is not going to change during the execution of the program <sil=0.996> .PERIOD Therefore <sil=0.567> ,COMMA 1 is a constant and A is a variable <sil=0.940> .PERIOD So <sil=0.441> ,COMMA the variable names are made up of letters <sil=0.595> ,COMMA digits and underscore <sil=0.943> .PERIOD So <sil=0.555> ,COMMA these are called identifiers <sil=0.977> .PERIOD So <sil=0.492> ,COMMA for different memory locations <sil=0.528> ,COMMA you give different identifying names just like we have names <sil=0.535> ,COMMA variables are the names for the memory locations and the variable names are what are called case sensitive <sil=0.977> .PERIOD What that means is upper case or capital letters are different from lower case or small case letters <sil=0.954> .PERIOD So <sil=0.429> ,COMMA if I use a variable name called class size with a capital S <sil=0.523> ,COMMA it is going to be different from a variable called class size with a lower case S <sil=0.950> .PERIOD So <sil=0.303> ,COMMA these two are two different variables <sil=0.438> ,COMMA which means they will get two different memory locations assigned to them <sil=0.988> .PERIOD And the maximum size that you can have for a variable name is 31 letters <sil=0.916> .PERIOD You cannot have more than 31 letters for a variable <sil=0.961> .PERIOD The first character for a variable that you have that you write must be a letter <sil=0.907> .PERIOD It cannot be underscore or it cannot be a digit <sil=0.594> ,COMMA it has to be a letter <sil=0.976> .PERIOD Typically <sil=0.315> ,COMMA you use a meaningful and self-documenting name for the variables <sil=0.905> .PERIOD So <sil=0.404> ,COMMA for instance <sil=0.361> ,COMMA let us say I want to use PI or PI <sil=0.914> .PERIOD So <sil=0.426> ,COMMA PI is a constant <sil=0.355> ,COMMA PI is not going to change its value <sil=0.919> .PERIOD It is going to be 3 <sil=0.941> .PERIOD 141 and so on <sil=0.979> .PERIOD It is a constant <sil=0.996> .PERIOD So <sil=0.311> ,COMMA usually constants are given names <sil=0.561> ,COMMA which are all capital letters <sil=0.916> .PERIOD Whereas <sil=0.358> ,COMMA variables are given names <sil=0.515> ,COMMA which are usually a mix of lower case and upper case letters <sil=0.972> .PERIOD And then there are keywords or words that are reserved by the programming language <sil=0.979> .PERIOD We already saw if statement in module 2 <sil=0.961> .PERIOD There are also other statements <sil=0.386> ,COMMA other keywords like for and so on <sil=0.990> .PERIOD We will see them later <sil=0.959> .PERIOD So <sil=0.557> ,COMMA these are not names that you can assign to your variables <sil=0.909> .PERIOD You cannot have a variable by name if or for or else or float or int or while and so on <sil=0.906> .PERIOD So <sil=0.596> ,COMMA the variable declaration goes as follows <sil=0.951> .PERIOD Once you declare you get storage <sil=0.590> ,COMMA I already showed that in the animation <sil=0.985> .PERIOD Decleration is the general form <sil=0.930> .PERIOD You have the data type followed by the variable name or a list of variable names <sil=0.934> .PERIOD The various types that are allowed are integer <sil=0.301> ,COMMA float <sil=0.334> ,COMMA character and double <sil=0.923> .PERIOD Int is for integers <sil=0.998> .PERIOD So <sil=0.415> ,COMMA you can only store integral values in them <sil=0.973> .PERIOD Float and double are for real values and you can store a dot something <sil=0.996> .PERIOD So <sil=0.644> ,COMMA 5 <sil=0.594> .PERIOD 34 <sil=0.912> ,COMMA 3 <sil=0.500> .PERIOD 14 and so on <sil=0.998> .PERIOD Care is for character <sil=0.932> .PERIOD It can store a single letter <sil=0.390> ,COMMA a <sil=0.530> ,COMMA b <sil=0.525> ,COMMA c <sil=0.995> ,COMMA d or such things <sil=0.941> .PERIOD So <sil=0.381> ,COMMA if you look at the statement int x semicolon <sil=0.613> ,COMMA what it really does is you have a variable by name x and it is of data type integer and there is a memory location which is labeled x for this execution of the program <sil=0.956> .PERIOD It assigns a certain number of bytes for this <sil=0.934> .PERIOD Whenever you use the variable x in your program <sil=0.503> ,COMMA during the execution this value which is contained in this location x is used <sil=0.900> .PERIOD We use the term variable not because <sil=0.547> ,COMMA so we actually use the term variable because the value of a variable can change during the execution of the program <sil=0.977> .PERIOD So <sil=0.340> ,COMMA a program is essentially a modification of variable values <sil=0.927> .PERIOD So <sil=0.343> ,COMMA for instance <sil=0.610> ,COMMA even the variables a <sil=0.459> ,COMMA b <sil=0.467> ,COMMA c and d <sil=0.366> ,COMMA they had some unknown values initially and they changed only when the user input those values <sil=0.929> .PERIOD Similarly <sil=0.568> ,COMMA p2 <sil=0.922> ,COMMA p1 and p0 were unknown values initially and they changed once the operations on the respective right hand side were over <sil=0.990> .PERIOD So <sil=0.505> ,COMMA each c program is a modification of variable values and the modification can happen due to operations like plus minus slash which is for division <sil=0.374> ,COMMA star for multiplication and so on <sil=0.942> .PERIOD These variables can also change values because of functions or operators provided by the system <sil=0.995> .PERIOD So <sil=0.393> ,COMMA for example <sil=0.631> ,COMMA I could say a equals sign of x <sil=0.998> .PERIOD So <sil=0.524> ,COMMA x would be treated as a parameter to the function called sign <sil=0.951> .PERIOD Sign is a built-in function in the math library <sil=0.911> .PERIOD It will do a sinusoid or sign of x <sil=0.903> .PERIOD The result of sign of x will be stored in this variable called a or these variables can change due to some functions itself which the programmers create <sil=0.954> .PERIOD We have not written any such functions yet we will see them as we go along <sil=0.987> .PERIOD Let us look at the kind of operators in C <sil=0.976> .PERIOD There are four basic operators for arithmetic namely plus minus star and slash <sil=0.985> .PERIOD They stand for addition <sil=0.639> ,COMMA subtraction <sil=0.526> ,COMMA multiplication and division respectively <sil=0.974> .PERIOD You can use these operations against integers and floating point numbers <sil=0.998> .PERIOD So <sil=0.333> ,COMMA plus and minus for integer and floating point will just add the values or subtract the values <sil=0.918> .PERIOD Star and slash have a little bit of meaning or a change in meaning when you attach them to integers or as opposed to floating point <sil=0.975> .PERIOD When you do integer division <sil=0.359> ,COMMA the fractional part of the result is truncated if you do integer division <sil=0.951> .PERIOD So <sil=0.556> ,COMMA for example <sil=0.435> ,COMMA 1 <sil=0.498> ,COMMA 2 or number 12 is an integer and number 5 is an integer <sil=0.993> .PERIOD So <sil=0.354> ,COMMA if you write 12 slash 5 you are dividing 12 by 5 and even though the result is 2 <sil=0.968> .PERIOD 4 this 0 <sil=0.995> .PERIOD 4 is truncated <sil=0.948> .PERIOD So <sil=0.364> ,COMMA the result of dividing an integer by another integer is also an integer in this case it is only 2 <sil=0.941> .PERIOD So <sil=0.556> ,COMMA a more drastic case is if you divide 5 by 9 for example <sil=0.905> .PERIOD So <sil=0.509> ,COMMA 5 is smaller than 9 <sil=0.968> .PERIOD So <sil=0.326> ,COMMA when you divide 5 by 9 you have a fraction and no integer value <sil=0.991> .PERIOD So <sil=0.527> ,COMMA the result would be 0 <sil=0.987> .PERIOD So <sil=0.632> ,COMMA you have to watch out for this when you program but for now this is not a problem and then there is this modulo operator or percentage <sil=0.979> .PERIOD So <sil=0.541> ,COMMA this percentage if you write x percentage y on the right hand side of assignment statement what it will do is it will take x and divide it by y but instead of putting the quotient it finds out the reminder <sil=0.998> .PERIOD So <sil=0.454> ,COMMA a by b finds out the quotient and a percentage b finds out the reminder <sil=0.941> .PERIOD So <sil=0.504> ,COMMA this is for integers <sil=0.916> .PERIOD So <sil=0.303> ,COMMA of course <sil=0.566> ,COMMA for floating point numbers a percentage b does not make sense <sil=0.973> .PERIOD You can take any floating point number divided by another floating point number and you can always get a coefficient with the modulo being 0 <sil=0.930> .PERIOD So <sil=0.543> ,COMMA this is called the modulo operator because it leaves the it finds out the reminder <sil=0.977> .PERIOD So <sil=0.486> ,COMMA percentage is defined only for integers it is not defined for floating point <sil=0.921> .PERIOD Let us look at these operators <sil=0.911> .PERIOD If you look at operations just like in when you write expressions in your basic algebra there are rules that you have to follow the rules of precedence <sil=0.987> .PERIOD So <sil=0.352> ,COMMA even in our example we had a times d plus b times c which was written as a plus a into d plus b into c <sil=0.930> .PERIOD So <sil=0.551> ,COMMA what is the order in which things are done <sil=0.914> ?QUESTIONMARK So <sil=0.355> ,COMMA the first precedence is for parenthesis expressions <sil=0.991> .PERIOD The next precedence is for star and slash and modulo and last level of precedence is for plus and minus <sil=0.914> .PERIOD So <sil=0.345> ,COMMA to illustrate what I mean by that let us take this expression this complicated expression a plus b times c plus d and c times d and so on <sil=0.926> .PERIOD So <sil=0.625> ,COMMA if you are not careful you may end up doing something like this <sil=0.991> .PERIOD So <sil=0.504> ,COMMA let us say I start looking at it from the left side I see a plus b I take a and b and first add it and then I multiply the result by c <sil=0.954> .PERIOD I take the result multiply by d take that result find the modulo by e and so on <sil=0.952> .PERIOD But this is not the way in which we do this in algebra either <sil=0.982> .PERIOD So <sil=0.542> ,COMMA in algebra we if an expression like this is written then you do not say you do not do the addition first you go and look for higher precedence operations first followed by lower precedence operations <sil=0.938> .PERIOD So <sil=0.548> ,COMMA the numbers that you see on the right side or not the values attached to these variables instead that indicates the order in which the operations will be done <sil=0.909> .PERIOD So <sil=0.569> ,COMMA if this expression is given to you the very first operation that will be done would be b times c <sil=0.929> .PERIOD So <sil=0.377> ,COMMA this star is the very first operation that will be done the result of b times c will be stored temporarily somewhere that result will be multiplied by d <sil=0.988> .PERIOD So <sil=0.440> ,COMMA this star is the second operation that will be done who <sil=0.970> .PERIOD So <sil=0.330> ,COMMA now you have b times c times d the third operation that will be done is percentage <sil=0.989> .PERIOD So <sil=0.626> ,COMMA b c d percentage e will find the reminder of dividing b c d by e <sil=0.905> .PERIOD Once that is done then the next operation that is done is plus <sil=0.950> .PERIOD So <sil=0.420> ,COMMA you will do a plus that whatever is in this expression here <sil=0.918> .PERIOD Then finally <sil=0.597> ,COMMA you do this division followed by excuse me followed by the subtraction <sil=0.915> .PERIOD So <sil=0.313> ,COMMA this is the order in which things will be done <sil=0.931> .PERIOD So <sil=0.352> ,COMMA if you are looking for a parenthesis expression which is equivalent to this this would be the parenthesis expression <sil=0.937> .PERIOD So <sil=0.345> ,COMMA you start with b times c the innermost thing is evaluated first <sil=0.923> .PERIOD Then you have that times d then you have that times that modulo e <sil=0.961> .PERIOD So <sil=0.473> ,COMMA you will have a result from here that will be added to a and you do f by g and this whole expression will be so this f by g will be subtracted from this whole expression on this side <sil=0.991> .PERIOD So <sil=0.341> ,COMMA it is missing one parenthesis here <sil=0.992> .PERIOD So <sil=0.498> ,COMMA there is so expected we expect a parenthesis to be here <sil=0.938> .PERIOD So <sil=0.395> ,COMMA this is the order in which things are done <sil=0.960> .PERIOD So <sil=0.562> ,COMMA use parenthesis always if you are in doubt until you get familiar with the order of precedence <sil=0.934> .PERIOD So <sil=0.586> ,COMMA star slash and percentage has higher precedence over plus and minus and parenthesis has higher precedence over star slash and plus <sil=0.910> .PERIOD So <sil=0.445> ,COMMA let us see another example here <sil=0.934> .PERIOD So <sil=0.330> ,COMMA a times b plus c percentage 5 plus x by 3 plus p minus r minus i it looks complicated enough <sil=0.929> .PERIOD It is also not a very good thing to write <sil=0.913> .PERIOD So <sil=0.369> ,COMMA I am giving it only for illustration purposes you should not be writing such things in your programs <sil=0.909> .PERIOD So <sil=0.404> ,COMMA the evaluation order is b plus c and 3 plus p would be done first because of the brackets that you have around them <sil=0.971> .PERIOD And once you have it star slash and percentage have the same precedence and you have star and percentage here <sil=0.944> .PERIOD So <sil=0.457> ,COMMA star comes before percentage in the program order if you look at it from left to right star comes before percentage <sil=0.975> .PERIOD So <sil=0.581> ,COMMA star will be performed before the percentage <sil=0.953> .PERIOD So <sil=0.346> ,COMMA a times b plus c is evaluated and then you do a module of 5 over it <sil=0.943> .PERIOD Similarly <sil=0.437> ,COMMA when you have x by 3 plus p <sil=0.574> ,COMMA 3 plus p is evaluated already <sil=0.925> .PERIOD So <sil=0.650> ,COMMA you will do x by that <sil=0.971> .PERIOD At the end of it you will have some value for this whole expression <sil=0.408> ,COMMA some value for this whole expression minus r minus i <sil=0.980> .PERIOD So <sil=0.311> ,COMMA now you have only plus and minuses <sil=0.919> .PERIOD You simply go from the left to right side and you will do this plus that the result is then you remove r from it and then you remove i from it <sil=0.990> .PERIOD So <sil=0.521> ,COMMA that will be the order in which you do things <sil=0.917> .PERIOD And finally <sil=0.525> ,COMMA the whole expression is evaluated and you have a value at the right hand side <sil=0.588> ,COMMA that value is assigned to this variable called value <sil=0.501> ,COMMA which is on the left hand side <sil=0.930> .PERIOD So <sil=0.301> ,COMMA equal to is the only operator that violates the left to right rule <sil=0.911> .PERIOD So <sil=0.487> ,COMMA star you do the calculate something on the left side before you calculate something on the right side <sil=0.940> .PERIOD A percentage also you evaluate something on the left side before you evaluate something on the right side <sil=0.918> .PERIOD But for the equal to operator you need to evaluate the right hand side <sil=0.388> ,COMMA get it completely evaluated and then the result is assigned to the left hand side <sil=0.994> .PERIOD Let us look at a few other operators that are useful and very common in C and the increment and decrement operators are these operators which are actually unusual not uncommon unusual <sil=0.966> .PERIOD So <sil=0.417> ,COMMA you so for example <sil=0.534> ,COMMA this plus plus if you add <sil=0.485> ,COMMA see if you do a plus b it is addition of a and b <sil=0.922> .PERIOD But if you do a plus plus it is actually equal into a equals a plus 1 a plus 1 <sil=0.940> .PERIOD So <sil=0.449> ,COMMA plus plus means add 1 to the operand and minus minus means subtract 1 from the operand <sil=0.938> .PERIOD So <sil=0.592> ,COMMA let us look at this small example n plus plus would mean you take n add 1 to it and put the result back in n itself <sil=0.955> .PERIOD So <sil=0.498> ,COMMA it will increment n after the use of n whereas plus plus n means increment before the use <sil=0.987> .PERIOD So <sil=0.520> ,COMMA let us see how this can be useful in a expression or how it can be used in an expression n equals 4 <sil=0.978> .PERIOD So <sil=0.648> ,COMMA there is a right hand side which is 4 the left hand side as n there is nothing to do on the right hand side it is a constant <sil=0.923> .PERIOD So <sil=0.486> ,COMMA 4 is assigned to n <sil=0.932> .PERIOD So <sil=0.477> ,COMMA there is nothing to do there <sil=0.983> .PERIOD Then let us look at this statement x equals n plus plus <sil=0.953> .PERIOD So <sil=0.439> ,COMMA what we have here is this plus plus is a post increment operation <sil=0.960> .PERIOD What that means is use the current value of n assigned to the left side and then combat and change the value of n <sil=0.913> .PERIOD So <sil=0.302> ,COMMA in this case if n equal to 4 was already executed the current value of n is 4 it is assigned to x and then n is incremented to 5 <sil=0.938> .PERIOD So <sil=0.464> ,COMMA at the end of these two statements n would be 5 and x would be 4 <sil=0.984> .PERIOD Then if you have this third statement y equals plus plus n n has a pre increment operator which means n should be incremented before the use in the right hand side <sil=0.980> .PERIOD So <sil=0.305> ,COMMA the current value of n is 5 you pre increment the result is 6 and that result is given to y <sil=0.974> .PERIOD So <sil=0.327> ,COMMA after the execution x would be 4 because you use the value before you incremented y would be 6 because 2 increments happened before you assigned it to y and n would be 6 because n got 2 increments 1 as a post increment here and 1 as a pre increment here <sil=0.910> .PERIOD So <sil=0.581> ,COMMA remember the memory layout there are 3 variables n x and y which means there are 3 memory locations n x and y and mentally simulate how this read and write on the memory is happening involving the ALU <sil=0.946> .PERIOD So <sil=0.567> ,COMMA just remember that whenever you have a post increment read assigned to the left side and then do this operation whenever you have a pre increment do the operation first and then assigned to the left hand side <sil=0.981> .PERIOD So <sil=0.419> ,COMMA it is as simple as that <sil=0.913> .PERIOD So <sil=0.316> ,COMMA we looked at the notion of variables and we looked at the notion of what the memory layout is we also looked at what the various operators in C are the basic arithmetic operators and we looked at a small program <sil=0.960> .PERIOD So <sil=0.572> ,COMMA I want to show something small about the code before I wrap up this session lecture 1 <sil=0.982> .PERIOD So <sil=0.591> ,COMMA I am going to run this program we already had this program <sil=0.987> .PERIOD I am going to run this program we did int a b c d int p 2 p 1 p naught <sil=0.991> .PERIOD I am going to run this program <sil=0.958> .PERIOD So <sil=0.520> ,COMMA let us what I am going to do is I am going to run it with an unexpected input <sil=0.913> .PERIOD So <sil=0.585> ,COMMA I expect integers a b c and d to be given in integral values what if I violate that <sil=0.940> .PERIOD So <sil=0.559> ,COMMA what I am going to do is I am going to take two polynomials 1 <sil=0.997> .PERIOD 5 x plus 1 and multiply it with 1 <sil=0.994> .PERIOD 5 x plus 1 itself <sil=0.906> .PERIOD So <sil=0.406> ,COMMA I will try 1 <sil=0.963> .PERIOD 5 and right away I have some result here which says the product is something it did not even give me a chance to enter b c d and so on <sil=0.994> .PERIOD It gave me some product and clearly this is not what we expect <sil=0.900> .PERIOD So <sil=0.629> ,COMMA the variables a b c d where integers and by just giving the input 1 <sil=0.955> .PERIOD 5 somehow it got values for b c and d incorrect values of course and it gave me some polynomial here as a result also <sil=0.948> .PERIOD So <sil=0.446> ,COMMA something bad happened here <sil=0.938> .PERIOD So <sil=0.322> ,COMMA we will sit down and reason about this at a later point of time <sil=0.962> .PERIOD So <sil=0.433> ,COMMA this is just to show you that in in module 2 we looked at some values that I gave to the program and for a b and c it still gave me correct results <sil=0.964> .PERIOD But it is not because that it got the correct values in place something else happened there will sit down and reason about that at a later point of time <sil=0.953> .PERIOD But this is a program where entering a wrong data type 1 <sil=0.986> .PERIOD 5 is a floating point I gave it when an integer was expected and the program so called crash it gave me something which is unexpected <sil=0.968> .PERIOD So <sil=0.410> ,COMMA with this we are at the end of lecture 1 <sil=0.963> .PERIOD So <sil=0.587> ,COMMA see you in lecture 2 <sil=0.995> .PERIOD Welcome to the very last video for this course for this MOOC <sil=0.914> .PERIOD So <sil=0.385> ,COMMA you have stuck with the course for so long and so this is a place when I do not want to teach something completely new <sil=0.921> .PERIOD So <sil=0.592> ,COMMA this is something that you have done you have already done the programming <sil=0.433> ,COMMA but when you write large pieces of software you may have to do a few things to be just careful and so that it becomes usable even later <sil=0.947> .PERIOD So <sil=0.354> ,COMMA one thing that happens with software is that lot of people start contributing to code and you want your code that you wrote to be able to read by others and maybe they want to change it later or you may even go and change your own code to do a few other things later and so on <sil=0.939> .PERIOD So <sil=0.367> ,COMMA you need to follow a few principles to do this and one major thing that you have to do is take a problem and divide that into smaller subproblems so that you can solve each of these subproblems separately and put them in different places <sil=0.927> .PERIOD So <sil=0.414> ,COMMA instead of so maybe you have not seen this or you have not done it so far because you are writing smaller programs so far <sil=0.505> ,COMMA but this can really become a problem if you write lots of code <sil=0.993> .PERIOD So <sil=0.434> ,COMMA to motivate this whole thing I am going to give a small programming assignment to you <sil=0.950> .PERIOD It is not a very hard assignment so I want you to go and write a program to print these figures <sil=0.930> .PERIOD So <sil=0.367> ,COMMA there is a hexagon looking thing at the left and then there is something like a cup <sil=0.528> ,COMMA there is a stop sign and we will call this the hat <sil=0.990> .PERIOD So <sil=0.365> ,COMMA let us say this we will call this the egg <sil=0.431> ,COMMA the cup <sil=0.430> ,COMMA the stop sign and the hat <sil=0.939> .PERIOD Let us say you want to draw these things <sil=0.987> .PERIOD So <sil=0.347> ,COMMA I am asking you to write a program which will draw you could do something very easy <sil=0.920> .PERIOD So <sil=0.427> ,COMMA in the first line draw dashes in the second line draw this forward slash give some space draw the draw backward slash <sil=0.947> .PERIOD You can do a lot of things so let us look at the very first crack at this problem <sil=0.954> .PERIOD The first version is an unstructured program <sil=0.992> .PERIOD We will create an empty program and a main function <sil=0.923> .PERIOD We will just copy the expected output <sil=0.642> ,COMMA but surround each line with printf and run it to verify the output <sil=0.950> .PERIOD We can do that very well <sil=0.914> .PERIOD So <sil=0.336> ,COMMA your program would look something like this <sil=0.983> .PERIOD In main void printf you have a series of printf in each one you can see what you are trying to print <sil=0.952> .PERIOD So <sil=0.556> ,COMMA only thing that is slightly different than what you will see in the output is for every back slash you have to use this escape character called back slash itself <sil=0.996> .PERIOD So <sil=0.451> ,COMMA every back slash is actually supported by another back slash <sil=1.000> .PERIOD The other thing that is missing is a series of new lines that I have not explicitly added <sil=0.436> ,COMMA but otherwise your program would look something like this <sil=0.988> .PERIOD So <sil=0.614> ,COMMA this is what I will call an unstructured program <sil=0.920> .PERIOD So <sil=0.462> ,COMMA you have not put too much thought into it <sil=0.995> .PERIOD You are asked to print something like this <sil=0.908> .PERIOD You have just write a series of printf statements and this will print some it will print what you want <sil=0.382> ,COMMA but it is not a very nice thing to do <sil=0.913> .PERIOD So <sil=0.518> ,COMMA the first thing that you do in any engineering step is take a problem and divide that into sub problems right <sil=0.962> .PERIOD The same thing applies to writing software <sil=0.900> .PERIOD Can you take this problem and divide that into sub problems <sil=0.998> .PERIOD So <sil=0.324> ,COMMA the main thing that comes with this is what is called decomposition <sil=0.905> .PERIOD Can you take the problem and decompose that into smallest sub problems and identify if there is any structure to the problem itself <sil=0.931> .PERIOD So <sil=0.474> ,COMMA let us go and look at this <sil=0.980> .PERIOD So <sil=0.519> ,COMMA there is some a structure <sil=0.961> .PERIOD So <sil=0.489> ,COMMA there is so <sil=0.440> ,COMMA the first figure will call that the egg <sil=0.382> ,COMMA the second figure will call that the teacup <sil=0.546> ,COMMA the third figure is we will call that the stop sign and the fourth figure will call it a hat <sil=0.931> .PERIOD So <sil=0.454> ,COMMA now I can think of this problem as draw an egg <sil=0.522> ,COMMA draw a teacup <sil=0.393> ,COMMA draw a stop sign <sil=0.321> ,COMMA draw a hat <sil=0.982> .PERIOD That is slightly better than draw some line and draw some other line and draw some other line and so on <sil=0.903> .PERIOD So <sil=0.501> ,COMMA this is slightly better <sil=0.952> .PERIOD Let us see how this might look like <sil=0.901> .PERIOD In your main program <sil=0.327> ,COMMA you will have four function calls draw egg <sil=0.431> ,COMMA draw teacup <sil=0.527> ,COMMA draw stop sign <sil=0.617> ,COMMA draw a hat and you would have to write four functions for each one of them <sil=0.580> ,COMMA egg <sil=0.516> ,COMMA teacup <sil=0.571> ,COMMA stop and hat <sil=0.912> .PERIOD So <sil=0.615> ,COMMA this is something that you can do and it is something that you can write at this level anyway <sil=0.930> .PERIOD So <sil=0.463> ,COMMA you have these four things <sil=0.985> .PERIOD So <sil=0.511> ,COMMA main depends on the function would depend on the function egg <sil=0.477> ,COMMA would depend on the function teacup <sil=0.592> ,COMMA stop sign and hat <sil=0.979> .PERIOD So <sil=0.606> ,COMMA that is another way to write the program <sil=0.526> ,COMMA but this is still not the best thing <sil=0.919> .PERIOD So <sil=0.557> ,COMMA let us go and look at what is happening <sil=0.926> .PERIOD Your main program becomes much simpler <sil=0.943> .PERIOD The task that you are doing in main is I have to do these four tasks in this order <sil=0.933> .PERIOD That is all you care about <sil=0.927> .PERIOD But you do not care about how exactly egg is drawn <sil=0.323> ,COMMA how teacup is drawn and so on because you have delegated this to a function <sil=0.996> .PERIOD Remember when we did functions <sil=0.399> ,COMMA I talked about delegations and we did exactly that now <sil=0.933> .PERIOD So <sil=0.477> ,COMMA when you call this function egg <sil=0.471> ,COMMA this function egg has all the print of statements <sil=0.954> .PERIOD Of course <sil=0.545> ,COMMA new lines are missing <sil=0.901> .PERIOD I did not intentionally added because you can see the structure of the output here clearly <sil=0.953> .PERIOD So <sil=0.412> ,COMMA series of print of statements <sil=0.590> ,COMMA this is slightly better <sil=0.984> .PERIOD What you have is from the main program <sil=0.402> ,COMMA the intent is clear <sil=0.998> .PERIOD You want to draw egg <sil=0.456> ,COMMA draw teacup <sil=0.560> ,COMMA draw stop sign and draw a hat <sil=0.325> ,COMMA but the functions are themselves still ugly <sil=0.913> .PERIOD You have only the series of print of statements <sil=0.985> .PERIOD So <sil=0.334> ,COMMA this is one level of decomposition <sil=0.964> .PERIOD From something which is just a sequence of print of statements <sil=0.363> ,COMMA you have four function calls <sil=0.996> .PERIOD The main program is clear or the main method is clear <sil=0.397> ,COMMA but the internal functions are still a bit ugly <sil=0.944> .PERIOD So <sil=0.363> ,COMMA now <sil=0.616> ,COMMA let us see whether we can decompose the problem a little further <sil=0.906> .PERIOD So <sil=0.353> ,COMMA this is actually just finishes the program with all these four egg teacup stop sign and hat <sil=0.927> .PERIOD Let us see if there is something better that we can do about this whole thing <sil=0.958> .PERIOD Is there some other structure to drawing this or should I be drawing <sil=0.437> ,COMMA writing a series of print of statements for each one of these functions <sil=0.997> .PERIOD So <sil=0.558> ,COMMA let us look at the egg to begin with <sil=0.946> .PERIOD So <sil=0.521> ,COMMA the egg <sil=0.475> ,COMMA there is something in the top half and something in the bottom half <sil=0.945> .PERIOD You cannot really draw the top half with the bottom half <sil=0.445> ,COMMA code or anything like that <sil=0.960> .PERIOD There is no reuse that you can do <sil=0.947> .PERIOD So <sil=0.474> ,COMMA the top half has to be drawn and the bottom half has to be done separately <sil=0.976> .PERIOD So <sil=0.308> ,COMMA this will require a print of a line followed by forward slash and a back slash and forward by another line with a forward slash and back slash <sil=0.995> .PERIOD And in this it would be the reverse <sil=0.929> .PERIOD So <sil=0.483> ,COMMA you cannot reuse anything <sil=0.901> .PERIOD So <sil=0.587> ,COMMA let us assume that there is a function which can draw the top half of the egg <sil=0.945> .PERIOD There is another function that can draw the bottom half of the egg <sil=0.971> .PERIOD So <sil=0.327> ,COMMA we will call those functions egg top and egg bottom <sil=0.902> .PERIOD Let us see if we have identified this <sil=0.948> .PERIOD Now <sil=0.382> ,COMMA let us go and look at this next one which is supposed to be for drawing a cup <sil=0.984> .PERIOD If you notice cup has something which is similar to the bottom of the egg but there is something else also the saucer here right is just a line <sil=0.908> .PERIOD We need something to do there right <sil=0.951> .PERIOD So <sil=0.434> ,COMMA if you want that so <sil=0.491> ,COMMA so <sil=0.499> ,COMMA so <sil=0.348> ,COMMA the cup actually can reuse the egg bottom <sil=0.499> ,COMMA drawing the egg bottom <sil=0.995> .PERIOD So <sil=0.421> ,COMMA if you draw the egg bottom and if you draw a line with the pluses on both ends that is actually okay right <sil=0.964> .PERIOD So <sil=0.432> ,COMMA if you know how to draw bottom of an egg you can actually draw a t cup <sil=0.970> .PERIOD Only thing you have to do is draw the bottom of the egg and draw a line underneath <sil=0.941> .PERIOD So <sil=0.435> ,COMMA t cup requires how you to know how to draw the bottom of the egg and bottom of the line <sil=0.930> .PERIOD If you have already written that as a function you can call the same function once more from t cup there is no harm <sil=0.919> .PERIOD Now <sil=0.348> ,COMMA let us go and look at the stop sign <sil=0.937> .PERIOD The stop sign is also interesting because the top half of the stop sign looks like the top half of the egg <sil=0.917> .PERIOD The bottom part of the stop sign looks like the bottom half the egg and also the top of the cup and there is a line in between which has this stop right <sil=0.937> .PERIOD So <sil=0.476> ,COMMA for drawing a stop sign if you draw an egg top and if you print this line and if you draw egg bottom you have a stop sign right <sil=0.932> .PERIOD So <sil=0.444> ,COMMA we will call this line the stop line <sil=0.935> .PERIOD So <sil=0.472> ,COMMA this is called just a line this is called stop line and for drawing a stop sign you need egg top then you need to draw stop line and you need to do egg bottom right you have that <sil=0.957> .PERIOD Then let us look at the last one which I call the hat the hat seems to be the top of the egg and the bottom of the t cup right <sil=0.932> .PERIOD So <sil=0.439> ,COMMA I already wrote those two things I have let us say I have functions to do those I have top of the egg and bottom of the t cups I have these two <sil=0.979> .PERIOD So <sil=0.503> ,COMMA I do not have to rewrite code anymore right <sil=0.962> .PERIOD So <sil=0.596> ,COMMA we have these two and I already have the methods <sil=0.928> .PERIOD So <sil=0.431> ,COMMA now if you look at this whole structure main program requires you to know how to draw an egg t cup stop sign and hat because those are the four function calls you are doing egg in turn will call egg top and egg bottom in that order t cup will call egg bottom and line in that in that order stop sign will call egg top stop line and egg bottom in that order and hat will call egg top and line in that order <sil=0.930> .PERIOD So <sil=0.352> ,COMMA for for writing egg all you have to do is write egg top and egg bottom and two and make two function calls <sil=0.941> .PERIOD But somebody has to still write egg top and egg bottom and line and stop line and so on <sil=0.969> .PERIOD So <sil=0.314> ,COMMA now there are two questions one can ask what are the methods we should be defining and what is a good order in which we are to implement and test these methods <sil=0.930> .PERIOD So <sil=0.575> ,COMMA clearly main depends on these four and these four depend on these four it dictates that we we have to know how to implement these four without building this there is no point in building these and without building these you cannot build your overall diagram which is on the left side this egg followed by cup followed by stop followed by hat you cannot draw that unless you have drawn you know how to draw these four structures <sil=0.920> .PERIOD So <sil=0.455> ,COMMA we will stop start with each one of them <sil=0.913> .PERIOD So <sil=0.431> ,COMMA main requires a call to egg t cup stop sign and hat this is just like what we had in the version two of the program only that we have a version which draws top of the egg and we draw a version which draws bottom of the egg if we have these two I am ready to draw the egg itself what does the egg need you need top of the egg you need bottom of the egg and you need to draw the egg by calling egg top and egg bottom <sil=0.930> .PERIOD So <sil=0.645> ,COMMA forget this print up for a while now it is actually a mistake it should have a backslash n there <sil=0.922> .PERIOD So <sil=0.436> ,COMMA print up backslash n it will draw a line after the egg is drawn <sil=0.926> .PERIOD So <sil=0.562> ,COMMA if you look at the sequence egg main calls egg egg calls egg top which will draw this then it calls egg bottom which will draw this and it is supposed to be printing a new line again in these places the new lines are intentionally left out so that it does not clutter the program right now <sil=0.939> .PERIOD Then let us look at how to draw a line so you do a plus followed by dashes followed by a plus this is for our saucer to draw a t cup we need the egg bottom and the line and so that will give us the cup and saucer to draw a stop sign we need the egg top and egg bottom but we need a stop line in between <sil=0.981> .PERIOD So <sil=0.341> ,COMMA this stop line is needed only for the stop sign it is not needed anywhere else <sil=0.983> .PERIOD So <sil=0.561> ,COMMA instead of calling a function I could just put the print up statement here itself because it is not used by more than one function <sil=0.913> .PERIOD So <sil=0.497> ,COMMA stop sign is required the stop line is required only for the stop sign nothing else hat you do not need to do anything new at all <sil=0.944> .PERIOD Egg top you have already drawn you know how to draw a line you do these <sil=0.902> .PERIOD So <sil=0.543> ,COMMA you now look at the structure of the program is much cleaner you have reused the code that you have written for egg top and egg bottom in several places <sil=0.928> .PERIOD So <sil=0.552> ,COMMA egg top is used in drawing egg under hat egg bottom is useful in drawing the egg and the t cup and egg top and egg bottom are useful in stop sign <sil=0.923> .PERIOD So <sil=0.425> ,COMMA now this is a much nicely structured and nicely decompose program <sil=0.960> .PERIOD So <sil=0.522> ,COMMA for instance if you make one small mistake in the space in the egg top right you if you had cut and pasted these two the this structure multiple times you have to go and change this multiple times in your program <sil=0.964> .PERIOD But if there is a small mistake in egg top all you have to do is fix it here automatically all the functions which call it will have the fixed version <sil=0.982> .PERIOD So <sil=0.408> ,COMMA this is the setup <sil=0.995> .PERIOD So <sil=0.430> ,COMMA even though I said this is what you should do there is some more things that you have to do <sil=0.938> .PERIOD So <sil=0.389> ,COMMA first thing is taking a problem and dividing dividing that into subproblems and writing functions for each one one of them we have already done that right we need to do something more <sil=0.925> .PERIOD The thing is we have the so called basic shapes <sil=0.968> .PERIOD So <sil=0.323> ,COMMA I am going to call egg top egg bottom and line I am going to call these things as basic shapes using basic shapes you build the shapes and using the shapes you draw your complete picture this is the complete picture <sil=0.944> .PERIOD So <sil=0.448> ,COMMA these are basic shapes these are shapes and this is the complete picture and how do we do that <sil=0.933> ?QUESTIONMARK So <sil=0.625> ,COMMA I want to be able to separate the concern of each one of them <sil=0.962> .PERIOD Drawing the basic shapes and being able to do something that is different from being able to draw the shapes and being able to draw shapes is different from being able to draw the picture <sil=0.970> .PERIOD So <sil=0.417> ,COMMA I am going to do this in a bottom up fashion <sil=0.941> .PERIOD So <sil=0.348> ,COMMA you go look at this we will go and develop this in a bottom up fashion <sil=0.971> .PERIOD We will try and write these things first methods for these things and then write methods for these things and then this but we are also going to do something more which you have not seen so far right <sil=0.995> .PERIOD So <sil=0.403> ,COMMA the first thing we are going to do is so far we have been using the so called header file we have not really developed our own header files <sil=0.951> .PERIOD So <sil=0.372> ,COMMA we use stdao <sil=0.968> .PERIOD h and string <sil=0.933> .PERIOD h and so on <sil=0.919> .PERIOD So <sil=0.562> ,COMMA you need to separate the concerns this is a term that people use in software engineering separate concerns right <sil=0.903> .PERIOD So <sil=0.513> ,COMMA one you are mixing the program what the program is supposed to be doing with what the interface of the functions are <sil=0.903> .PERIOD So <sil=0.372> ,COMMA the implementation and the declaration are all in the same file so far but we can separate these concerns <sil=0.999> .PERIOD So <sil=0.324> ,COMMA use the code <sil=0.928> .PERIOD h or give a file name <sil=0.994> .PERIOD h to do all the prototypes and so on and write file name <sil=0.944> .PERIOD c to write the program <sil=0.956> .PERIOD So <sil=0.415> ,COMMA the implementation usually goes into <sil=0.959> .PERIOD c and the declarations go into <sil=0.949> .PERIOD h files <sil=0.949> .PERIOD Let us say we adopt that right and we are going to do something with the header files <sil=0.977> .PERIOD So <sil=0.573> ,COMMA for every problem there is some solving the problem itself and all the functions and other things that you need for it <sil=0.926> .PERIOD So <sil=0.539> ,COMMA we will see how to do that <sil=0.926> .PERIOD So <sil=0.542> ,COMMA the header files usually have this format <sil=0.945> .PERIOD So <sil=0.561> ,COMMA there is a hash if not depth of code name then define code name put all your structures and prototypes and so on and if <sil=0.922> .PERIOD So <sil=0.548> ,COMMA let us not worry about this if not depth define an end if but all the declarations go within these three structures hash if not depth hash define hash end if <sil=0.942> .PERIOD So <sil=0.311> ,COMMA what it tells you is if something called code name is not defined define it now define all these things and end it <sil=0.948> .PERIOD So <sil=0.337> ,COMMA let us see how this might look like for basic shapes <sil=0.956> .PERIOD I am creating a file called basic shapes <sil=0.976> .PERIOD h This takes care of only the declarations for all the functions which are for basic shapes <sil=0.914> .PERIOD H top <sil=0.376> ,COMMA H bottom and line are three functions <sil=0.992> .PERIOD So <sil=0.478> ,COMMA I have the declarations for these three functions in a file called basic shapes and so whenever I use a file name I will use the same thing for the if not depth if not depth basic shapes h define basic shapes h if this has not been defined so far define this variable now define all these function prototypes end it <sil=0.968> .PERIOD So <sil=0.431> ,COMMA this is the declaration for the basic shapes the description so will come later <sil=0.950> .PERIOD So <sil=0.324> ,COMMA if you want to use that dot h file you do hash include basic shapes dot h this is like hash include stdiot dot h <sil=0.947> .PERIOD So <sil=0.614> ,COMMA put your header file in the same folder as same folder as your c files and use hash include for example in std lib <sil=0.969> .PERIOD So <sil=0.568> ,COMMA I will show you how to write basic shapes dot c <sil=0.914> .PERIOD So <sil=0.589> ,COMMA basic shapes dot c will be a c program this has the implementation this includes a cdiot and also include basic shape and it has the function descriptions for a top <sil=0.401> ,COMMA a bottom and line <sil=0.911> .PERIOD So <sil=0.372> ,COMMA with basic basic shapes dot h and basic shapes dot c you have something that can draw basic shapes and nothing else <sil=0.962> .PERIOD Now <sil=0.630> ,COMMA we want to be able to draw shapes with it right <sil=0.969> .PERIOD So <sil=0.486> ,COMMA let us move up I am going to write a file called dots shapes dot h which has all the things required for drawing the shapes <sil=0.957> .PERIOD So <sil=0.466> ,COMMA the declarations for drawing the shapes and this is the description of those functions <sil=0.943> .PERIOD So <sil=0.314> ,COMMA shapes dot c has shapes dot h because it needs those descriptions and how is egg implemented the implementation is in this file egg top egg bottom and print f t cup egg bottom line and print f and so on right <sil=0.927> .PERIOD This is what you need for drawing the shapes <sil=0.912> .PERIOD So <sil=0.412> ,COMMA now we have four files basic shapes dot h basic shapes dot c shapes dot h and shapes dot c right <sil=0.970> .PERIOD So <sil=0.603> ,COMMA shapes dot h has only the declarations it also includes basic shapes dot h and so on <sil=0.901> .PERIOD So <sil=0.389> ,COMMA now we have four files you cannot compile just one file now you have to create what is called a project I will show you how the project is done in the demo <sil=0.974> .PERIOD Finally <sil=0.585> ,COMMA the top most thing I am going to call that draw figures dot c draw figures need shapes dot h and it need <sil=0.961> .PERIOD So <sil=0.449> ,COMMA now egg t cup stop sign hat are all provided by shapes dot c shapes dot c in turn depends on basic basic shapes dot c <sil=0.943> .PERIOD So <sil=0.464> ,COMMA this is the overall structure we have five files draw figures basic shapes dot h and c shapes h and c <sil=0.946> .PERIOD So <sil=0.315> ,COMMA I will I have already written this here so you can see basic shapes dot h which has it has the declarations basic shapes dot c which has the description shapes dot c shapes dot h which has the declarations shapes dot c which has the description and draw shapes dot c which has the description for the main program <sil=0.969> .PERIOD I have included all of this into a project called draw shapes <sil=0.905> .PERIOD So <sil=0.380> ,COMMA you can do that by saying file new project <sil=0.984> .PERIOD So <sil=0.332> ,COMMA I did file new project I created a file by name draw shapes I included these five files into the project <sil=0.908> .PERIOD Now <sil=0.366> ,COMMA I can compile the project and what it does is it takes all these files and compile them together and when I run it right it actually runs the main program <sil=0.917> .PERIOD So <sil=0.480> ,COMMA if you notice right the individual ones do not have main routines right we do not have main routines in any of these the main routine is only in this one right <sil=0.933> .PERIOD So <sil=0.641> ,COMMA for drawing shapes dot c and basic shapes dot c and shapes dot c they are also compiled and they are compiled along with draw shapes dot c you can see the result of the printout here <sil=0.930> .PERIOD So <sil=0.608> ,COMMA you can see the egg the t cup the stop sign and this and that came from actually having taken the problem and dividing that into sub problems file it identifying the structure which is common and re being able to reuse and so on <sil=0.991> .PERIOD So <sil=0.329> ,COMMA for whatever reason if I want two cups tomorrow right I can actually call the cups twice <sil=0.982> .PERIOD So <sil=0.538> ,COMMA I can call cup t cup and t cup it will draw two t cups one below the other so <sil=0.433> ,COMMA this idea of being able to taking a problem dividing that into sub problems is a necessary skill you probably did that with functions itself <sil=0.609> ,COMMA but separating the concerns of implementation from the so called interface or just the declaration is another thing <sil=0.908> .PERIOD So <sil=0.476> ,COMMA once you have something if you divide that into multiple files you can quickly go and see which file has the basic issue and which file has a problem and so on <sil=0.977> .PERIOD So <sil=0.502> ,COMMA for example <sil=0.483> ,COMMA tomorrow I may not want to draw egg and stop sign and so on <sil=0.554> ,COMMA but I want to draw two cups or three cups I can write a different program which will take the cups and draw them explicitly <sil=0.983> .PERIOD So <sil=0.314> ,COMMA this notion of dividing the problem is decomposition and organizing them into multiple header files and c files is a very necessary skill when you build larger and larger pieces of software right <sil=0.969> .PERIOD So <sil=0.395> ,COMMA I want to end this course with one small piece of advice <sil=0.920> .PERIOD So <sil=0.336> ,COMMA there are lots of things that we did in the course <sil=0.432> ,COMMA but we never wrote or explicitly used libraries for many of them c comes with a lot of libraries these are standard libraries that come with any standard c package right <sil=0.981> .PERIOD So <sil=0.627> ,COMMA your compiler's package these things for you things to operate on strings things to operate on characters for example <sil=0.358> ,COMMA you can take a lower character and convert it to uppercase <sil=0.519> ,COMMA you can check whether a character's lowercase or uppercase things like that <sil=0.945> .PERIOD There are math libraries included from map <sil=0.928> .PERIOD h <sil=0.906> ,COMMA trigonometric functions <sil=0.323> ,COMMA floor <sil=0.305> ,COMMA absolute value <sil=0.552> ,COMMA power and things like that are all available from math libraries <sil=0.984> .PERIOD It is not just that these are the functions that are there even some algorithmic things are available <sil=0.951> .PERIOD For example <sil=0.625> ,COMMA from STD lib <sil=0.507> ,COMMA you learnt binary search <sil=0.470> ,COMMA you do not have to write binary search yourself <sil=0.423> ,COMMA you can call the binary search function available from STD lib <sil=0.917> .PERIOD So <sil=0.619> ,COMMA you learnt how to do various sorting algorithms <sil=0.958> .PERIOD So <sil=0.548> ,COMMA Q sort for instance is an algorithm which does something called quick sort <sil=0.953> .PERIOD So <sil=0.468> ,COMMA you can call Q sort on an array of integers for instance <sil=0.962> .PERIOD So <sil=0.532> ,COMMA you have to learn how to do it I am simplifying a few things here <sil=0.964> .PERIOD But for there are sorting <sil=0.556> ,COMMA searching functions <sil=0.307> ,COMMA mathematical libraries and other things that are already available out there <sil=0.991> .PERIOD If it is available as part of your package learn how to use it <sil=0.946> .PERIOD So <sil=0.589> ,COMMA at some point all you have to do is make appropriate function calls include appropriate header files <sil=0.452> ,COMMA make appropriate function calls and compile with appropriate flags <sil=0.919> .PERIOD So <sil=0.403> ,COMMA I am simplifying a lot of things but learn how to use the basic libraries and not write things from scratch every time you write a program <sil=0.903> .PERIOD So <sil=0.639> ,COMMA this brings us to the end of this module and in fact to the end of this course <sil=0.930> .PERIOD And I hope you enjoyed the course as much as we enjoyed creating it <sil=0.962> .PERIOD And this has been probably a rough and tough 9 or 10 weeks that you have been through with lots of programming assignments and assessments and so on <sil=0.951> .PERIOD But we hope that this course helped you in some way or the other to learn either from scratch or at least be able to if you have already done see programming at least cleared a lot of concepts for you and taught you a few new things like data structures and algorithms and so on <sil=0.900> .PERIOD So <sil=0.533> ,COMMA in for doing this course we took help from quite a few people <sil=0.957> .PERIOD So <sil=0.473> ,COMMA of course <sil=0.497> ,COMMA we three were the faces that you saw but there is a big team that was behind it <sil=0.986> .PERIOD We had 10 TAs who are all behind this <sil=0.991> .PERIOD So <sil=0.357> ,COMMA they were actually responding to you on the forums <sil=0.993> .PERIOD There is a team from Google which was which created the platform and there is also this local team <sil=0.517> ,COMMA the NPTEL team in charge of video recording <sil=0.399> ,COMMA scheduling and so many other things <sil=0.995> .PERIOD So <sil=0.309> ,COMMA there are probably 30 or 40 people who got involved in creating the contents for this course and delivering it to you <sil=0.957> .PERIOD So <sil=0.585> ,COMMA I personally want place on record that V3 tank each and every one of them <sil=0.908> .PERIOD So <sil=0.464> ,COMMA we cannot possibly list all of them by name <sil=0.521> ,COMMA but I want to thank all of them to make this course the success it is now <sil=0.909> .PERIOD And I am hoping that you guys will tune in later for other courses that NPTEL has to offer <sil=0.932> .PERIOD So <sil=0.508> ,COMMA all the best for your exams and I hope to see you in some other course at a later point of time <sil=0.973> .PERIOD Bye bye <sil=0.910> .PERIOD Today <sil=0.390> ,COMMA we are going to study a second problem which is solved using the method of dynamic programming <sil=0.944> .PERIOD This problem is called the matrix chain multiplication <sil=0.933> .PERIOD The problem is that we are given a sequence of matrices that can be multiplied <sil=0.936> .PERIOD So <sil=0.398> ,COMMA A1 <sil=0.515> ,COMMA A2 up to A n are n matrices which are given and our aim is to compute the product of these n matrices <sil=0.905> .PERIOD Let us assume that the product can be performed <sil=0.969> .PERIOD In other words <sil=0.506> ,COMMA the orders of the matrices are appropriately given <sil=0.932> .PERIOD There are many parenthesisizations to compute the product <sil=0.950> .PERIOD What is a parenthesisization <sil=0.948> ?QUESTIONMARK The parenthesisization is an allocation of parenthesis around the expression that has been given so that the expression can be evaluated as specified by the parenthesisization <sil=0.924> .PERIOD Let us now consider this example where there are four matrices A1 <sil=0.370> ,COMMA A2 <sil=0.469> ,COMMA A3 and A4 and A is to compute the product of these four matrices <sil=0.956> .PERIOD There are five possible parenthesisizations <sil=0.909> .PERIOD Let us inspect each of these parenthesisizations <sil=0.951> .PERIOD This is the first one <sil=0.941> .PERIOD We know that in any expression which is parenthesized <sil=0.360> ,COMMA the innermost parenthesis is evaluated first <sil=0.964> .PERIOD Therefore <sil=0.397> ,COMMA in this parenthesisization <sil=0.462> ,COMMA the first one <sil=0.341> ,COMMA A3 and A4 are multiplied first <sil=0.982> .PERIOD The result is then multiplied with A2 and the result is then multiplied with A1 <sil=0.981> .PERIOD In the next parenthesisization <sil=0.557> ,COMMA the innermost parenthesis is the one that encloses the product A2 <sil=0.350> ,COMMA A3 which is computed first <sil=0.999> .PERIOD The result is then multiplied with A4 <sil=0.979> .PERIOD The result of this matrix multiplication is then multiplied with A1 <sil=0.929> .PERIOD The other parenthesis <sil=0.334> ,COMMA this is more interesting than the first two because it is different <sil=0.982> .PERIOD Observe that there are two innermost parenthesis <sil=0.911> .PERIOD One parenthesis contains the matrix product A1 <sil=0.464> ,COMMA A2 and the second innermost parenthesis contains the matrix product A3 <sil=0.622> ,COMMA A4 and again using expression evaluation rules <sil=0.602> ,COMMA the innermost parenthesis is evaluated first <sil=0.932> .PERIOD Therefore <sil=0.509> ,COMMA the expression involving the product A1 <sil=0.382> ,COMMA A2 is evaluated first <sil=0.973> .PERIOD Then the expression involving the product A3 <sil=0.363> ,COMMA A4 is evaluated <sil=0.972> .PERIOD Then the two results are multiplied and this is given as a result of the matrix product of the four matrices <sil=0.947> .PERIOD The following two are symmetric to the second and first respectively and the explanation is similar <sil=0.904> .PERIOD What distinguishes these five different parenthesisizations <sil=0.967> ?QUESTIONMARK Let us just see that <sil=0.934> .PERIOD What distinguishes them is the total number of multiplications <sil=0.905> .PERIOD Our aim is to now count the total number of scalar multiplications which are necessary <sil=0.985> .PERIOD To do this <sil=0.512> ,COMMA let us understand the number of multiplications required to multiply two matrices <sil=1.000> .PERIOD In this case <sil=0.447> ,COMMA let us assume that the matrix dimensions are given <sil=0.972> .PERIOD The two matrices are A <sil=0.481> ,COMMA which is a P by Q matrix and B <sil=0.556> ,COMMA which is a Q by R matrix <sil=0.958> .PERIOD We know that the result is a P by R matrix and let us call this result matrix <sil=0.471> ,COMMA the value <sil=0.371> ,COMMA the matrix C <sil=0.958> .PERIOD It is clear that the total number of matrix multiplications that need to be performed is PQR <sil=0.966> .PERIOD It is clear that the total number of matrix multiplications that need to be performed is P multiplied by Q multiplied by R <sil=0.957> .PERIOD How does this affect the behavior of chain matrix multiplication <sil=0.884> ?QUESTIONMARK For this <sil=0.551> ,COMMA let us consider the following example where we consider three matrices <sil=0.627> ,COMMA A <sil=0.916> ,COMMA B and C <sil=0.920> ,COMMA A is a order 10 by 100 <sil=0.562> ,COMMA B is a order 100 by 5 and C is a order 5 by 50 <sil=0.924> .PERIOD Clearly <sil=0.486> ,COMMA the three matrices can be multiplied <sil=0.445> ,COMMA that is <sil=0.492> ,COMMA the product A <sil=0.579> ,COMMA B <sil=0.315> ,COMMA C can be computed <sil=0.993> .PERIOD There are two ways of parenthesizing this <sil=0.921> .PERIOD This is the first way where the product A <sil=0.462> ,COMMA B is computed first <sil=0.927> .PERIOD The result is multiplied with C <sil=0.992> .PERIOD Let us assume that the product A <sil=0.406> ,COMMA B is called D <sil=0.940> .PERIOD We know that it is a 10 by 5 matrix and C is a 5 by 50 matrix <sil=0.922> .PERIOD The multiplication A <sil=0.585> ,COMMA B takes 5 <sil=0.391> ,COMMA 000 scalar multiplications <sil=0.922> .PERIOD The product D <sil=0.307> ,COMMA C takes 2500 scalar multiplications <sil=0.975> .PERIOD Therefore <sil=0.342> ,COMMA the total number of scalar multiplications is 7500 <sil=0.996> .PERIOD Let us consider the second parenthesization where B and C are multiplied first followed by A <sil=0.979> .PERIOD Let the outcome of multiplying B and C <sil=0.323> ,COMMA B <sil=0.639> ,COMMA the matrix E <sil=0.321> ,COMMA which is a 100 by 50 matrix <sil=0.934> .PERIOD So <sil=0.561> ,COMMA the product B multiplied by C <sil=0.374> ,COMMA which is performed first <sil=0.338> ,COMMA takes 25 <sil=0.490> ,COMMA 000 scalar multiplications <sil=0.952> .PERIOD The subsequent product of A and E takes 50 <sil=0.373> ,COMMA 000 scalar multiplications <sil=0.972> .PERIOD And therefore <sil=0.311> ,COMMA we can already see that the first parenthesization uses only 7500 scalar multiplications <sil=0.489> ,COMMA but the second parenthesization uses 10 times more number of scalar multiplications <sil=0.958> .PERIOD That is <sil=0.432> ,COMMA it uses 75 <sil=0.435> ,COMMA 000 scalar multiplications <sil=0.935> .PERIOD Clearly <sil=0.560> ,COMMA from an efficiency point of view <sil=0.374> ,COMMA the first parenthesization is a more preferred parenthesization than the second parenthesization <sil=0.932> .PERIOD This gives rise to a very interesting minimization problem <sil=0.934> .PERIOD This minimization problem is called the matrix chain multiplication problem <sil=0.966> .PERIOD The input to the matrix chain multiplication problem is a chain of n matrices A1 <sil=0.350> ,COMMA A2 to A n <sil=0.958> .PERIOD For every i <sil=0.422> ,COMMA the i-th matrix has dimension P i minus 1 cross P i <sil=0.914> .PERIOD That is <sil=0.534> ,COMMA the matrix A i has P i minus 1 rows and P i columns <sil=0.909> .PERIOD The first matrix A 1 has P 0 rows and P 1 columns <sil=0.957> .PERIOD The goal is to parenthesis this matrix <sil=0.932> .PERIOD The goal is to parenthesis this chain A1 <sil=0.365> ,COMMA A2 to A n so that the total number of scalar multiplications is minimized <sil=0.903> .PERIOD Recall from the previous example that different parenthesizations give rise to different number of scalar multiplications <sil=0.918> .PERIOD And our aim is to choose the optimal optimal parenthesization to minimize the total number of scalar multiplications <sil=0.965> .PERIOD One natural approach is the brute force method where we try all possible parenthesizations <sil=0.995> .PERIOD I leave this as an exercise to the student to calculate how many parenthesizations are there for a chain of n matrices <sil=0.945> .PERIOD It is indeed an exponential in n <sil=0.900> .PERIOD The exact function is left as an exercise to the student <sil=0.942> .PERIOD So now let us use the dynamic programming approach to come up with an algorithm to find the minimum parenthesization <sil=0.999> .PERIOD Let us use the dynamic programming approach to come up with an algorithm which will come up with a parenthesization that uses the minimum number of scalar multiplications <sil=0.935> .PERIOD To do this let us understand the structure of an optimal solution which in this case is a parenthesization <sil=0.982> .PERIOD For this we need some simple notation <sil=0.936> .PERIOD We use the notation A subscripted by i up to j to denote the matrix which is a result of the product A i A plus 1 and so on up to A j <sil=0.973> .PERIOD Let us know observe that in an optimal parenthesization which we do not know which is what our algorithm is trying to compute in an optimal parenthesization <sil=0.915> .PERIOD Let k be the index where the product A1 A2 to A n is split <sil=0.972> .PERIOD Therefore the approach for computing the product would first be to compute the matrices A1 k and A k plus 1 n and then compute the product of these two matrices to get the final matrix A1 n <sil=0.903> .PERIOD The k observation that we make about this whole exercise is that if we consider an optimal parenthesization of the chain A1 A2 to A n then the parenthesizations of the subchains A1 A2 to A k and A k plus 1 A k plus 2 to A n will also be optimal <sil=0.924> .PERIOD This is the optimal substructure <sil=0.965> .PERIOD Recall that from the previous lecture this is one of the properties of recall from the previous lecture for dynamic programming to be used the problem must have the optimal substructure <sil=0.941> .PERIOD In other words in this case the optimal solution to the parenthesization contains within it the optimal solution to subproblems <sil=0.994> .PERIOD So we will verify the claim that this problem has optimal substructure while coming up with a recursive formulation of the optimum values <sil=0.924> .PERIOD In this case we again introduce a few variables which are necessary for us to compute the minimum number of scalar multiplications <sil=0.937> .PERIOD So we use the two-dimensional array m i comma j to denote the minimum number of scalar multiplications necessary to compute A i j <sil=0.976> .PERIOD We let m i comma j denote let m i comma j by B let m i comma j be the minimum number of scalar multiplications necessary to compute A i j <sil=0.948> .PERIOD Now we can see that the minimum cost to compute the chain product A1 to A n recall this is A subscripted by the range 1 to n is the value m of 1 comma n <sil=0.993> .PERIOD Suppose the optimal parenthesization of A i j splits the product between A k and A k plus 1 where k is a number in the range i to j <sil=0.966> .PERIOD Then we write down a recursive formulation of m of i comma j <sil=0.931> .PERIOD So recursive formulation uses this parenthesization <sil=0.916> .PERIOD The matrix A i j is obtained by the parenthesization <sil=0.904> .PERIOD The matrix A i j is obtained by multiplying the matrix chain A i to A k with the result of the matrix chain A k plus 1 to A j <sil=0.938> .PERIOD In other words this is the product of the two matrices A i k multiplied by A k plus 1 j <sil=0.928> .PERIOD Therefore the total cost of computing A i j is the cost of computing A i k plus the cost of computing A k plus 1 j plus the cost of multiplying the two matrices A i k and A k plus 1 j <sil=0.967> .PERIOD Note here that the cost is the total number of scalar multiplications <sil=0.955> .PERIOD So we know that the third term the cost of multiplying A i k and A k plus 1 j is P i minus 1 multiplied by P k multiplied by P j <sil=0.917> .PERIOD This is because the order of the two matrices are P i minus 1 cross P k and P k cross P j <sil=0.921> .PERIOD So we specify the recurrence now completely which is that the minimum number of scalar multiplications for the chain <sil=0.463> ,COMMA the minimum number of scalar multiplications for multiplying the chain A i to A j is equal to M of i k plus M of k plus 1 k plus 1 k plus P i minus 1 multiplied by P k multiplied by P j for k between i and j <sil=0.962> .PERIOD And indeed the number of multiplications to compute an empty product is 0 that is M of i k i is the cost of multiplying A i where there are no multiplication operations involved therefore this is taken to be the values 0 <sil=0.975> .PERIOD To complete the recursive formulation let us observe that the optimal parenthesisization occurs at one of the values of k between i and j <sil=0.981> .PERIOD We do not know which one it is but the algorithmic idea is very simple we check all the possible values of k between the range i and j and select the one that gives the least value and this specifies completely the recursive formulation of M of i k i j <sil=0.916> .PERIOD If i and j are the same it is 0 because we do not have to perform any multiplication if i not equal to j and i is strictly smaller than j then M of i k i j we know stores the minimum number of scalar multiplications to multiply the chain product A i to A j <sil=0.997> .PERIOD So this is obtained by finding the best value of k by computing M of i k i plus M of k plus 1 k j plus P minus 1 multiplied by P k multiplied by P j and choosing the best possible k that gives the minimum value of M of i k i j <sil=0.970> .PERIOD This completes the recursive formulation of the minimum that we are interested in <sil=0.983> .PERIOD Now we need to convert this recursive formulation into an algorithm and we have to specify the algorithm and efficient algorithm to compute the minimum <sil=0.986> .PERIOD To do this we introduce a second two-dimensional array which we call s <sil=0.459> ,COMMA s stands for split and we refer to this two-dimensional array as the split table <sil=0.914> .PERIOD The split table tells us where to split a chain <sil=0.925> .PERIOD In other words s of i comma j is that value of k at which the chain A i to A j is split for an optimal parenthesization <sil=0.951> .PERIOD The steps in this algorithm are to compute the minimum number of scalar multiplications for chains of length 1 <sil=0.926> .PERIOD From there we compute the minimum number of parenthesizations for chains of length 2 and 3 and so on <sil=0.984> .PERIOD This is the bottom-up calculation method of the optimum value of M of 1 comma M <sil=0.994> .PERIOD This is the algorithm description <sil=0.973> .PERIOD There is an initialization phase where the mincos table M is initialized with 0 for all the diagonal entries because they do not involve any multiplication <sil=0.905> .PERIOD This is followed by three nested iterations to essentially implement the recurrence and the outer loop iterates over <sil=0.940> .PERIOD So let us consider this algorithmic description to compute the optimal cost <sil=0.935> .PERIOD We will then compute the optimal parenthesization also <sil=0.980> .PERIOD The input to this algorithm is an array which is an n plus 1 element array which contains the dimensions of the matrices <sil=0.989> .PERIOD For example <sil=0.550> ,COMMA the fields P of 0 and P of 1 give us the information about the dimension of matrix A 1 that is P0 cross P1 <sil=0.957> .PERIOD The array entries P1 and P2 tell us the dimension of the matrix A 2 and so on <sil=0.990> .PERIOD The result of this algorithm is we get a mincos table and a split table <sil=0.986> .PERIOD These are two arrays that we get <sil=0.902> .PERIOD The mincos table stores the value of the minimum cost parenthesization of the chain multiplication involving the chains involving the chain of matrices A i A i plus 1 up to A j <sil=0.904> .PERIOD Similarly <sil=0.393> ,COMMA the split table the entry S of i j stores the value of the index k at which the chain A i to A j is to be split <sil=0.958> .PERIOD The algorithm is as follows <sil=0.948> .PERIOD It has four four loops <sil=1.000> .PERIOD The first four loop is an initialization phase where the diagonal entries are all initialized to 0 <sil=0.965> .PERIOD This is natural because the diagonal entries store the value 0 to denote the fact that there is no matrix multiplication involving a single matrix <sil=0.954> .PERIOD The remaining three four loops are nested and the intent of these four loops is to fill the remaining entries in the upper half of the matrix is to fill the entries in the upper half of the matrix and this is done by filling each diagonal <sil=0.906> .PERIOD Observe that there are n minus 1 diagonals apart from the principal diagonal of the matrices <sil=0.925> .PERIOD The outer loop iterates over the diagonals of the matrix <sil=0.991> .PERIOD The outer four loop which is indexed by the variable L iterates over the diagonals <sil=0.923> .PERIOD The next four loop is set up to instantiate each element in the appropriate diagonal and the innermost four loop is the one that evaluates the value of the min cos parenthesis <sil=0.917> .PERIOD So <sil=0.646> ,COMMA in the second four loop the initialization of the variable j to i plus L minus 1 is a choice of the appropriate element in the L th diagonal <sil=0.978> .PERIOD So <sil=0.439> ,COMMA m of i comma j is initialized to the value empty which is a standard thing for a minimization problem which takes positive values <sil=0.927> .PERIOD m of i comma j is initialized to the value infinity which is a standard practice for minimization problems which take positive values <sil=0.910> .PERIOD The innermost four loop is the loop that implements the recurrence that we have written to formulate the value of m of i comma j <sil=0.971> .PERIOD The way this is done is to iterate over all the possible values of k starting from i to j minus 1 and the value q is computed as m of i comma k plus m of k plus 1 comma j plus p of i minus 1 multiplied by p of k multiplied by p of j <sil=0.997> .PERIOD The if statement updates the value of m of i comma j if the value of q is smaller and it also updates the value of the split entry if the value of q is smaller than the current value of m of i comma j <sil=0.987> .PERIOD At the end of this whole iteration the matrices m and s are computed and they store the optimum parenthesis for every i comma j they store the optimum number of scalar multiplications for the chain multiplication involving a i to a j and the parenthesis information is stored by keeping track of the split value in the matrix s <sil=0.941> .PERIOD The split table is used to compute an optimum solution the algorithm computes first the min cost table m and the split table s as we saw in the previous slide and the optimum solution can be calculated from the split table using the value k which is stored in s of i comma j this enables us to compute s of 1 comma n recursively <sil=0.982> .PERIOD Thank you <sil=0.933> .PERIOD So <sil=0.588> ,COMMA so far we talked about basic control structures of programs <sil=0.497> ,COMMA we analyzed the complexity of control structures of programs <sil=0.559> ,COMMA but what we have learned so far <sil=0.400> ,COMMA we have learned about some basic data types <sil=0.308> ,COMMA integer <sil=0.333> ,COMMA car <sil=0.609> ,COMMA float and so on <sil=0.361> ,COMMA in C <sil=0.948> .PERIOD Now <sil=0.622> ,COMMA probably these are generally good enough for most of the computation that most people do <sil=0.540> ,COMMA but sometimes maybe you would like to take these basic data types and make more useful data types which are useful for your work <sil=0.966> .PERIOD So <sil=0.521> ,COMMA what you do is for example <sil=0.408> ,COMMA I can write something like a record or a structure as it is called <sil=0.485> ,COMMA I am not writing in C syntax over here and let us say I want to make a student record <sil=0.373> ,COMMA I will say name <sil=0.546> ,COMMA student name which is of a character array <sil=0.448> ,COMMA array of <sil=0.464> ,COMMA I will let say 100 characters of car <sil=0.405> ,COMMA then I will say student role number <sil=0.496> ,COMMA which can again be an array of let us say 10 characters <sil=0.358> ,COMMA this is basically your I <sil=0.585> ,COMMA then I may like to say students mark <sil=0.507> ,COMMA let us say this is with respect to a particular course <sil=0.504> ,COMMA course name <sil=0.980> .PERIOD In IIT we have six characters for courses <sil=0.630> ,COMMA so let us say I have array of six of car and the same course marks <sil=0.588> ,COMMA assignment one <sil=0.646> ,COMMA assignment two <sil=0.550> ,COMMA it is of type real or float and let us say quiz one <sil=0.603> ,COMMA quiz two <sil=0.416> ,COMMA n <sil=0.344> ,COMMA m <sil=0.550> ,COMMA use of type real and then you have a total <sil=0.643> ,COMMA which is also of type real <sil=0.980> .PERIOD So <sil=0.515> ,COMMA we have something which you have seen <sil=0.564> ,COMMA which you might have seen in your first in the basic C course that you already did <sil=0.445> ,COMMA we can put a set of a sorted elements together <sil=0.474> ,COMMA here we have character and total maybe of type individual it is <sil=0.910> .PERIOD So <sil=0.504> ,COMMA what you have here <sil=0.509> ,COMMA role number name which is of type character <sil=0.534> ,COMMA see string of characters <sil=0.408> ,COMMA student role number which is again a string of characters <sil=0.488> ,COMMA course name which is an array of characters again a string of characters <sil=0.438> ,COMMA assignment one <sil=0.478> ,COMMA assignment two <sil=0.645> ,COMMA which is of type real <sil=0.335> ,COMMA quiz one <sil=0.516> ,COMMA quiz two <sil=0.617> ,COMMA n <sil=0.327> ,COMMA which is again of type real and total is integer <sil=0.554> ,COMMA based on which a grade is given <sil=0.479> ,COMMA let us say we also have a grade <sil=0.499> ,COMMA which is of type character <sil=0.944> .PERIOD So <sil=0.337> ,COMMA what I have tried to do is we create a student record with all the information together <sil=0.521> ,COMMA we are doing a kind of an organization if you see <sil=0.421> ,COMMA where the organization that you are doing for a particular student role number <sil=0.532> ,COMMA we keep track of the name <sil=0.455> ,COMMA we have the course number here <sil=0.497> ,COMMA the assignment <sil=0.416> ,COMMA the quizzes that he or she has taken total <sil=0.471> ,COMMA that he has got in this particular course <sil=0.449> ,COMMA I am doing it for a particular close <sil=0.454> ,COMMA let us say and a grade that he is obtained on this course <sil=0.982> .PERIOD So <sil=0.606> ,COMMA there is one type of data organization <sil=0.468> ,COMMA so what have we done <sil=0.351> ,COMMA we take the basic building blocks like the integer <sil=0.333> ,COMMA character <sil=0.389> ,COMMA flow and so on or real for that matter <sil=0.468> ,COMMA put them together and make one data structure and what do we want to do is <sil=0.650> ,COMMA when I am looking at a particular students information <sil=0.499> ,COMMA the entire record is pulled out <sil=0.529> ,COMMA so that I can look at assignment marks <sil=0.617> ,COMMA quiz marks <sil=0.396> ,COMMA and so on <sil=0.408> ,COMMA one way of organizing <sil=0.977> .PERIOD So <sil=0.396> ,COMMA this is called a data structure <sil=0.358> ,COMMA next what we are going to do is <sil=0.549> ,COMMA this is one part of the problem <sil=0.442> ,COMMA where we take these basic building blocks like int <sil=0.575> ,COMMA card and flow <sil=0.523> ,COMMA put them together and make a record and then you <sil=0.516> ,COMMA when you want to pull out a particular person's item <sil=0.427> ,COMMA for example <sil=0.303> ,COMMA I might have an array of <sil=0.339> ,COMMA let me say this is a record of type student or whatever and then I might have an array of <sil=0.524> ,COMMA let say in my classes of 1 to 65 of students <sil=0.930> .PERIOD So <sil=0.353> ,COMMA it is an array of this record of students <sil=0.342> ,COMMA then to access a particular element in this <sil=0.354> ,COMMA all that I have to do is <sil=0.332> ,COMMA look at let say of type student <sil=0.435> ,COMMA let me call it stoodar or something like this <sil=0.404> ,COMMA this is the type and this is the actual allocation <sil=0.961> .PERIOD So <sil=0.399> ,COMMA I look at stoodar of let say 25 and it will give me the 25 record in this particular array and I can access all the elements <sil=0.591> ,COMMA so very nice idea <sil=0.556> ,COMMA putting all a software elements together making a data structure out of it <sil=0.949> .PERIOD Today <sil=0.357> ,COMMA what we are going to talk about is little bit higher than that <sil=0.512> ,COMMA that is what a data structure is all about <sil=0.918> .PERIOD We are going to talk about what are called abstract data types and what we are going to do is <sil=0.642> ,COMMA now what we are going to do in this particular part of the course is that <sil=0.361> ,COMMA not only are we going to do an organization like this <sil=0.589> ,COMMA but we are also going to define a set of operations that can be performed on this data structure <sil=0.901> .PERIOD So <sil=0.373> ,COMMA first thing what we do <sil=0.568> ,COMMA we organize the elements in a particular form and then we are going to define a set of operations <sil=0.923> .PERIOD For example <sil=0.519> ,COMMA you know the <sil=0.569> ,COMMA what are the operations that you can perform on it <sil=0.504> ,COMMA if you are looking at C for example <sil=0.390> ,COMMA you can do addition plus minus division percent <sil=0.952> .PERIOD So <sil=0.492> ,COMMA now only if you are looking at float <sil=0.592> ,COMMA you can do plus minus slash and there are other operations <sil=0.356> ,COMMA but this is the minimal set of operations and multiplication <sil=0.965> .PERIOD And if you look at character for example <sil=0.631> ,COMMA you can you can do a plus where it kind of concatenate and then you have the S T R N <sil=0.385> ,COMMA S T R cat <sil=0.375> ,COMMA S T R count and various operations that can be performed on character strings <sil=0.373> ,COMMA character slash strings <sil=0.335> ,COMMA let us say <sil=0.397> ,COMMA you know set of operations that have been defined <sil=0.956> .PERIOD So <sil=0.533> ,COMMA now for example <sil=0.501> ,COMMA when you look at these operations plus minus slash and percent <sil=0.505> ,COMMA if you look at these operations here which are also used for float and you remember here you can also use a star <sil=0.601> ,COMMA person remainder will give you the <sil=0.982> .PERIOD So <sil=0.643> ,COMMA basically what the compiler knows or what the computer knows for example <sil=0.397> ,COMMA is that when you are performing plus and minus <sil=0.326> ,COMMA if I say in x and y and I say in z and I say z is equal to x plus y <sil=0.639> ,COMMA it automatically knows that the plus operation is performed on operands which are of type integer <sil=0.924> .PERIOD Similarly <sil=0.363> ,COMMA if I say float u v and float w and I write w is equal to u plus p <sil=0.407> ,COMMA clearly it knows that you will be here for a type float and the result is to be stored in w which is also of type float <sil=0.985> .PERIOD Now <sil=0.605> ,COMMA we are using the same operation plus here and plus here also <sil=0.905> .PERIOD So <sil=0.624> ,COMMA what we want to do is that we want to add more functionality <sil=0.920> .PERIOD I want to add by one data types just like you had integer and float here <sil=0.973> .PERIOD Can we add our own data types and give new meaning to these operations <sil=0.869> ?QUESTIONMARK For example <sil=0.307> ,COMMA suppose I wanted to do let us say I want to look at matrix multiplication <sil=0.971> .PERIOD So <sil=0.513> ,COMMA matrix of size two matrices let me say m 1 and m 2 <sil=0.973> .PERIOD Then I want to define a new matrix let us say I would like to say something like this <sil=1.000> .PERIOD Matrix m 1 m 2 and I would like to say matrix m 3 which is the output and I would like to say m 3 is equal to m 1 plus m 2 which is a usual what is the meaning here <sil=0.926> ?QUESTIONMARK Now <sil=0.487> ,COMMA the meaning here is that m 3 is the result of the sum of the two matrices and similarly I may like to say m 3 is equal to m 1 minus m 2 m 3 is equal to m 1 transpose something like that transpose of m 1 let me say m 1 transpose <sil=0.909> .PERIOD I would like to say transpose of m 1 and similarly I may like to say m 3 is equal to inverse of m 1 and so on <sil=0.989> .PERIOD I may like to do a whole lot of operations like this <sil=0.982> .PERIOD What have we done here <sil=0.984> ?QUESTIONMARK I would like to focus on these two operations <sil=0.985> .PERIOD What is the difference here <sil=0.968> ?QUESTIONMARK Here we saw that plus and minus are operating with respect to integer here float plus and minus are operating with respect to float here <sil=0.956> .PERIOD Here plus is operating with respect to character here and here for example <sil=0.303> ,COMMA what are we doing here now <sil=0.954> ?QUESTIONMARK Here you are saying now plus and minus are going to operate with respect to matrices <sil=0.957> .PERIOD So <sil=0.352> ,COMMA basically what we are trying is can we somehow generalize this whole idea of what is an operator <sil=0.851> ?QUESTIONMARK We know that if you look at the string cat and string compare functions what do they do <sil=0.899> ?QUESTIONMARK They are essentially doing some operations on a pair of strings <sil=0.969> .PERIOD The pair of strings are given as argument to string cat and it will concatenate two of them and give you the result which is a concatenated string <sil=0.999> .PERIOD So <sil=0.472> ,COMMA one way of looking at it is it is a function all right <sil=0.456> ,COMMA but the function of the procedure is like generalizing what we call the notion of an operator <sil=0.927> .PERIOD I have a comparison operation to be performed and we are having a function for it or a procedure <sil=0.933> .PERIOD So <sil=0.303> ,COMMA already we have procedures which kind of generalize this notion of what an operator should do <sil=0.987> .PERIOD So now <sil=0.540> ,COMMA instead of using these operators plus minus multiplication division can we have user defined operations <sil=0.970> ?QUESTIONMARK Similarly <sil=0.489> ,COMMA the data on which the procedure should operate like I can give my own organization of the data <sil=0.347> ,COMMA can I also have a whole lot of user defined operators <sil=0.934> .PERIOD So <sil=0.337> ,COMMA what is happening is here if I look at it matrix M 1 M 2 M 3 <sil=0.953> .PERIOD So <sil=0.567> ,COMMA I have to specify how this matrix is actually represented <sil=0.924> .PERIOD It has to be in a particular representation which is a two dimensional array perhaps <sil=0.440> ,COMMA should be the representation of the matrix <sil=0.922> .PERIOD But the operations are actually here being performed on arrays and you know that is internally defined by the user defined functions that we have <sil=0.975> .PERIOD So <sil=0.388> ,COMMA what we want to do is just as you have procedures that can be used to encapsulate functionality <sil=0.393> ,COMMA we can define what are called abstract data types that can be used to encapsulate data types <sil=0.949> .PERIOD I have already given these two examples <sil=0.953> .PERIOD Another example is if you know that in C you have a integer float and car you do not have complex complexes of the fine <sil=0.953> .PERIOD For example <sil=0.539> ,COMMA you have a number A plus I B and can I represent something like C of 0 <sil=0.946> .PERIOD 5 or 0 <sil=0.987> .PERIOD 5 complex C my type here 0 <sil=0.925> .PERIOD 5 come up 0 <sil=0.928> .PERIOD 5 and can I make the operations of addition <sil=0.619> ,COMMA subtraction and division to be mean something different in this particular context <sil=0.983> .PERIOD So <sil=0.595> ,COMMA basically what we are talking about going a little bit higher level here <sil=0.935> .PERIOD We have a mathematical model and an informal algorithm <sil=0.978> .PERIOD What do I mean by that <sil=0.963> ?QUESTIONMARK When I say matrix M1 and M2 then when I am talking about addition I have an informal algorithm which tells me how M1 and M2 should be added <sil=0.984> .PERIOD When I mean informal here I am more talking about something like you know when you write in English kind of statements what this informal algorithm to add to matrices <sil=0.996> .PERIOD Then what we do is from there we go a little bit more formal convert this to what is called an abstract data type <sil=0.998> .PERIOD For example <sil=0.635> ,COMMA in the matrix you know what the meaning of it and then abstract data type is closer to the higher level language then you write a pseudo language program <sil=0.909> .PERIOD What do I mean by a pseudo language program here <sil=0.981> ?QUESTIONMARK You are writing something like an algorithm in a pseudo language program such that if I translate it to a particular higher level language it should work exactly <sil=0.943> .PERIOD And what is the correspondence with this abstract data is represented by a data structure and then the operations that are performed on the data structure are written in a higher level language program <sil=0.936> .PERIOD So we start with the mathematical model informal algorithm like for example in sets how do you say what is your mathematical model you will say S1 is of this form A <sil=0.439> ,COMMA B <sil=0.437> ,COMMA C <sil=0.387> ,COMMA D <sil=0.620> ,COMMA and S2 is of this form C plus C comma D comma E and if I say S1 union S2 is nothing but A comma <sil=0.964> .PERIOD So this is what we mean by A <sil=0.470> ,COMMA B <sil=0.408> ,COMMA C <sil=0.336> ,COMMA D and E is what you will get <sil=0.910> .PERIOD Whereas if I do S1 intersection S2 it is going to give me C and D <sil=0.975> .PERIOD So what have I done here <sil=0.921> ?QUESTIONMARK I have definition of the sets a mathematical model for representing sets and from the elements that I use in the set I know what the type is then I am defining an operation called union I am defining an operation called intersection which operates on these sets <sil=0.974> .PERIOD That is what we mean by a mathematical model and an informal algorithm <sil=0.925> .PERIOD Then abstract data gets closer to the computer <sil=0.931> .PERIOD So now then what we have to do what are the elements in this particular set <sil=0.889> ?QUESTIONMARK What is the type of the elements in the set <sil=0.879> ?QUESTIONMARK For example suppose I had 1 <sil=0.355> ,COMMA 2 <sil=0.648> ,COMMA 3 <sil=0.421> ,COMMA 4 the element type would be of type integer these are elements of type character and then however represent a set I may require a special type of data organization just like we talked about over there and then these operations which operate on the sets now it write functions which will take whatever data organization I have and operate on them and give the result <sil=0.949> .PERIOD Then that we do is finally we say how a higher level language how do I translate this whole thing into the higher level language <sil=0.915> .PERIOD So I converted to a real data structure like this kind of a data structure over here and then I define a set of operations on this <sil=0.902> .PERIOD So finally abstract data type when you look at it it is like it is going to look something like this <sil=0.989> .PERIOD So we have let me call it an ADT for matrix let us look at matrix of set at 2 ADT set <sil=0.940> .PERIOD So have here some representation of the set how to where how should this set be stored should it be stored in an array or a linked list or whatever then I have a set of operations which are performed on the set like union intersection for example it will take union intersection complement and so on <sil=0.928> .PERIOD So these operations are operate on this data and what we normally do is the data is completely the representation of the data is completely hidden from the user <sil=0.944> .PERIOD The operations are known and these operations can take arguments what arguments these operations take for example I may say here it takes is argument set S1 and set S2 and intersection is also taking the same argument complement again because subtracting let us say from one to the other set S1 and set S2 <sil=0.942> .PERIOD So basically it takes is argument sets and then there are operations that are performed on the set <sil=0.929> .PERIOD So obviously what is it going to do it is going to operate on the data the way the data is represented each one of these functions is going to hide the whole information here and it is going to operate on the way the data has been represented and finally the result is going to be the union of these sets and what will this be this will again be a type set this will also be a type set <sil=0.938> .PERIOD This will also be a type set <sil=0.921> .PERIOD So basically these are things that you can do with what are called abstract data types okay <sil=0.991> .PERIOD We have a representation here some representation using whatever structures are available in the programming language integer character float for example I have to specify of course is a set of characters is set of integers is set of some other kind of objects that information is given here and then you decide whether you want to use this set is consisting of a set of items we are left with no choice but to say some array or a linked list representation and then we perform a set of operations <sil=0.912> .PERIOD So now what do these operations do the operations will look at this representation and perform the operation of union intersection and complement like we said in the mathematical model over here <sil=0.960> .PERIOD So we will stop here for now and we will continue with an example on complex in the next class <sil=0.958> .PERIOD Thank you <sil=1.000> .PERIOD In the last class <sil=0.634> ,COMMA we looked at the list ADT and we talked about a generic list ADT where we said insert any element anywhere and then we talked about two other flavors of the list ADT <sil=0.970> .PERIOD One is the stack <sil=0.345> ,COMMA the last in first out and the other is the phi 4 which is the first in first out or the q ADT <sil=0.988> .PERIOD Now the generic list ADT <sil=0.414> ,COMMA what it consists of <sil=0.988> ?QUESTIONMARK It consists of a sequence of items <sil=0.978> .PERIOD So <sil=0.479> ,COMMA it had a set of elements and if you want you could have completely an ordered set of items as a generic list or in the last in first out of the stack ADT <sil=0.500> ,COMMA you had a particular flavor where you said you could only insert at the top and delete from the top and in the first in first out <sil=0.648> ,COMMA this is the q ADT <sil=0.433> ,COMMA we inserted at the end and we deleted from the first <sil=0.949> .PERIOD So <sil=0.465> ,COMMA it is like you know <sil=0.486> ,COMMA when you look at the generic ADT <sil=0.600> ,COMMA it is like a vanilla is cream when you know <sil=0.572> ,COMMA whereas the stack ADT is like chocolate and if you like chocolate <sil=0.597> ,COMMA then it is like chocolate ADT which does something very special and on the list ADT <sil=0.938> .PERIOD And the first in first out is perhaps like butter scotch which does something else special <sil=0.904> .PERIOD So <sil=0.409> ,COMMA depending upon what you like <sil=0.324> ,COMMA I know these are some of the most favored flavors in ice creams <sil=0.951> .PERIOD So <sil=0.636> ,COMMA it is something like that <sil=0.958> .PERIOD So <sil=0.587> ,COMMA either a stack or a q still qualifies as a generic list <sil=0.973> .PERIOD Now <sil=0.449> ,COMMA there is one problem with the stack or the q and the problem is the following <sil=0.957> .PERIOD What we see is that whether directly or indirectly <sil=0.639> ,COMMA there is some kind of ordering in the list <sil=0.908> .PERIOD The items either are pushed onto the stack and popped from the stack in one end or they are you know <sil=0.604> ,COMMA pushed at one end removed from the other end as in the q ADT <sil=0.919> .PERIOD Now <sil=0.496> ,COMMA today what I want to talk about is <sil=0.584> ,COMMA let us say I want to represent the family tree <sil=0.940> .PERIOD Suppose <sil=0.452> ,COMMA I want to represent my family tree <sil=0.598> ,COMMA let us say a is a parent has a p a set of children <sil=0.907> .PERIOD Let me say that p are the parents does not matter with the mother or father and let us say you have four children and these are your siblings <sil=0.927> .PERIOD Now <sil=0.388> ,COMMA let us clearly the older generation and this generation now for example <sil=0.588> ,COMMA generally has the generation one above you guys has had perhaps only two children <sil=0.562> ,COMMA f and so on <sil=0.920> .PERIOD And suppose you want to find out who is the grandparent of whom and so on <sil=0.983> .PERIOD Then if you want to traverse <sil=0.491> ,COMMA if you had to represented all of this using a list <sil=0.629> ,COMMA then the problem would have been <sil=0.451> ,COMMA this would have been number one in your list two <sil=0.431> ,COMMA three <sil=0.465> ,COMMA four <sil=0.911> ,COMMA five <sil=0.521> ,COMMA six <sil=0.517> ,COMMA seven <sil=0.492> ,COMMA eight <sil=0.465> ,COMMA nine assuming that six came after five <sil=0.984> .PERIOD You have put them in this particular list and you have access an element at 10 <sil=0.537> ,COMMA let us say or to access the element <sil=0.632> ,COMMA the element for that matter <sil=0.637> ,COMMA you have to go to the end of the list <sil=0.973> .PERIOD So <sil=0.583> ,COMMA this would have <sil=0.469> ,COMMA but at the same time the reason why I am talking about this is when I am using a list to represent something like this <sil=0.351> ,COMMA then the what kind of a list will I use <sil=0.613> ,COMMA I will use a generic list because there is nothing like when you look at siblings for example <sil=0.583> ,COMMA there is nothing like a priority of one sibling over the other <sil=0.601> ,COMMA but just the representation by itself <sil=0.388> ,COMMA because whoever came first you put them in and so on and so forth <sil=0.968> .PERIOD You know deletion for example <sil=0.500> ,COMMA somebody dies in the family <sil=0.470> ,COMMA it can happen at any point in the list and almost all operations will become very expensive because you have to traverse mostly the entire list <sil=0.911> .PERIOD So <sil=0.405> ,COMMA the idea is can we can we represent these kind of structures in a better way <sil=0.937> .PERIOD So <sil=0.443> ,COMMA one of the most popular representations <sil=0.441> ,COMMA what do we want from this <sil=0.307> ,COMMA if I want to access the node corresponding to j <sil=0.604> ,COMMA then I would like some information right <sil=0.430> ,COMMA what would I like to say <sil=0.417> ,COMMA I want to look at the then I would like j to say who is his or her parent <sil=0.486> ,COMMA who is this one's parent <sil=0.623> ,COMMA who is this one's parent <sil=0.545> ,COMMA if I want to find the G lineage of j <sil=0.989> .PERIOD So <sil=0.412> ,COMMA how easy or how difficult is this depends upon the kind of representation that we are going to use <sil=0.963> .PERIOD So <sil=0.629> ,COMMA a tree is a tree data structure kind of suits this kind of data very well <sil=0.966> .PERIOD So <sil=0.432> ,COMMA what we are going to talk about is <sil=0.631> ,COMMA we are going to talk about a general tree something like this and then as I already said the major objective is to be able to traverse this particular tree <sil=0.526> ,COMMA see if a particular element is present in the tree based on certain criteria that can be satisfied and so on <sil=0.965> .PERIOD We will come back after we do all this to the general tree <sil=0.595> ,COMMA but this is in general tree <sil=0.925> .PERIOD Now <sil=0.498> ,COMMA representation of the tree can be done in a number of ways <sil=0.555> ,COMMA you can use an array representation in the or you can use what is called any general tree is represented by what is called the left most child right symbol representation <sil=0.915> .PERIOD What this means is P A B C D is the representation for this and this is represented like this and we have I B C D E B C D E B C D E B C D E B E which is represented like this <sil=0.577> ,COMMA sorry this has two children F and this one has a left most child J <sil=0.960> .PERIOD I will explain in a minute what this representation is all about <sil=0.908> .PERIOD So <sil=0.613> ,COMMA what is done is notice that we take this particular tree over here and convert it to this format <sil=0.970> .PERIOD What would I do if I was representing an array <sil=0.901> ?QUESTIONMARK I would say here 0 <sil=0.313> ,COMMA this is P <sil=0.612> ,COMMA let us say this is this node corresponds to P and I will keep some information 0 over here <sil=0.935> .PERIOD Then the indices go from 1 to 2 <sil=0.424> ,COMMA I would say A comma 1 <sil=0.505> ,COMMA B comma 1 <sil=0.484> ,COMMA C comma 1 <sil=0.544> ,COMMA D comma 1 and I would say E comma 2 <sil=0.476> ,COMMA F comma 2 <sil=0.362> ,COMMA F comma 2 <sil=0.443> ,COMMA F comma 2 <sil=0.326> ,COMMA F comma 2 <sil=0.316> ,COMMA F comma 2 <sil=0.552> ,COMMA F comma 3 <sil=0.348> ,COMMA I will tell you in a minute what I am representing over here <sil=0.609> ,COMMA H comma 3 and I comma 6 and J comma 7 <sil=0.928> .PERIOD What I am storing here if I am this is an array implementation and this is a linked list implementation <sil=0.909> .PERIOD What is a linked list now <sil=0.967> ?QUESTIONMARK It is a recursive state structure <sil=0.980> .PERIOD What is the problem with the tree <sil=0.883> ?QUESTIONMARK If I want to represent the tree then using a linked list then at every node I must be able to say if I was representing it by saying that node has some max number of pointers n <sil=0.951> .PERIOD To avoid that I could have a list of elements on the other hand that is exactly what we are doing here <sil=0.944> .PERIOD See we look at it over here <sil=0.353> ,COMMA what is it that we are doing <sil=0.955> ?QUESTIONMARK We are saying here P is a root node and it has children A B C D <sil=0.980> .PERIOD Let us say A is the leftmost child or the oldest child then to make our representation more convenient if this is the root node within that it has a pointer to the leftmost child which who is right sibling point to all the other nodes <sil=0.946> .PERIOD Similarly it will also have a pointer to its leftmost child so the tree is like this <sil=0.964> .PERIOD The pointers are all pointing forward <sil=0.915> .PERIOD On the other hand the array implementation why are we doing this <sil=0.899> ?QUESTIONMARK Because I said one of the fundamental problems is we want parent information or from the parent I would like to go to the child <sil=0.924> .PERIOD One of these two information is required <sil=0.979> .PERIOD So if you look at this the array implementation on the other hand what do we do <sil=0.966> ?QUESTIONMARK We say that I store the parent in this particular let us say let me call it the index of the node is 1 2 3 4 5 6 7 8 9 10 and 11 <sil=0.938> .PERIOD Suppose I was storing it in an array <sil=0.942> .PERIOD Then what we do is we store a pointer to the nodes parent and now I have put the index 0 <sil=0.903> .PERIOD Index 0 means what <sil=0.927> ?QUESTIONMARK This particular node is the root node <sil=0.936> .PERIOD Next what I do is the element A <sil=0.928> .PERIOD Now element A is stored here and who is its parent <sil=0.879> ?QUESTIONMARK Its parent is P whose index is 1 <sil=0.911> .PERIOD Similarly the node B is stored in index 3 and its parent is in node 1 and I keep that index <sil=0.937> .PERIOD Now for C what happens <sil=0.878> ?QUESTIONMARK C A B C D is like that <sil=0.953> .PERIOD When I come to E what do I do <sil=0.960> ?QUESTIONMARK I keep the index of its parent which is 2 because A is the parent of E therefore I store E and 2 over here <sil=0.911> .PERIOD Similarly for F what do I do <sil=0.889> ?QUESTIONMARK I store F and 2 over here because for F the parent is again A <sil=0.952> .PERIOD So you repeat like this and you can get use the array representation for any general tree <sil=0.947> .PERIOD In the linked list representation this representation is basically this is array representation where we use pointers to the parent to parent in every node <sil=0.959> .PERIOD On the other hand in the linked list representation what does every node have <sil=0.971> ?QUESTIONMARK Every node has a pointer to its left most child and the right sibling <sil=0.958> .PERIOD So notice that P is the parent right is the root of this particular tree <sil=0.991> .PERIOD Therefore it has only pointer to its left most child <sil=0.956> .PERIOD Its right sibling is pointing into null because the root has no siblings <sil=0.967> .PERIOD And here what is it that is happening here <sil=0.968> ?QUESTIONMARK A is the left most child and it is pointing to the its right sibling <sil=0.429> ,COMMA this is right sibling <sil=0.461> ,COMMA this is right sibling <sil=0.493> .PERIOD This is the right barber left most child <sil=0.497> ,COMMA right sibling martyrs Moto right msoft child <sil=0.332> ,COMMA right sibling left msoft child <sil=0.495> ,COMMA right sibling <sil=0.496> ,COMMA left noibh So <sil=0.595> ,COMMA what I have done now in all the arrows now I have put the which corresponds to the point of which corresponds to that of the leftmost child and right sibling for the RS <sil=0.942> .PERIOD So <sil=0.484> ,COMMA we make these pointers like this <sil=0.940> .PERIOD Now <sil=0.484> ,COMMA that means what is nice about the structure in every node we are having only two pointers the leftmost child and the right sibling <sil=0.970> .PERIOD But so basically you have two pointers in every node <sil=0.400> ,COMMA but you are able to represent any general tree <sil=0.909> .PERIOD Now <sil=0.436> ,COMMA this tree is useful if you want to look at any arbitrary tree <sil=0.909> .PERIOD For the time being we will kind of postpone this and we will talk about this a little later <sil=0.567> ,COMMA but remember that this is one such representation of a tree <sil=0.978> .PERIOD What is the meaning of the leftmost child <sil=0.943> ?QUESTIONMARK Leftmost child is molded sibling and right <sil=0.411> ,COMMA the right sibling corresponds to it next sibling at that particular level <sil=0.905> .PERIOD We will come back to this tree a little later where we have either array representation or this <sil=0.979> .PERIOD What we will look at is we will look at some special trees today in particular we will look at the binary tree <sil=0.971> .PERIOD What is the binary tree now <sil=0.904> ?QUESTIONMARK Here is an example where we have the root and it also has two pointers one to the left child and the right child <sil=0.947> .PERIOD There is no hierarchy here that is the fundamental difference <sil=0.936> .PERIOD It is similar to this where you have a node has two pointers leftmost child and right sibling <sil=0.937> .PERIOD The difference between the binary tree node and the general tree node is that the left child and right child there is no hierarchy <sil=0.981> .PERIOD What do we mean by that <sil=0.895> ?QUESTIONMARK Here a points to be to a node at the same level whereas the leftmost child points to a node at the one level lower <sil=0.910> .PERIOD So <sil=0.308> ,COMMA basically what we are talking about here is one level higher sorry or here in the other hand we are saying leftmost child and right child left child and right child are at the same level <sil=0.929> .PERIOD Now <sil=0.329> ,COMMA what are the use of such trees we will see in a minute <sil=0.949> .PERIOD Now <sil=0.417> ,COMMA how do you define a binary tree <sil=0.924> ?QUESTIONMARK A binary tree is defined like this <sil=0.964> .PERIOD What is it <sil=0.900> ?QUESTIONMARK It is a finite set of nodes that is either empty or consists of a root and two disjoint binary trees called the left and right sub trees <sil=0.978> .PERIOD What is it telling me that this is a binary tree <sil=0.924> ?QUESTIONMARK It can also be empty and it has left and right sub trees which are again binary trees <sil=0.961> .PERIOD Again going back to this example if you started from this node this is a tree still and this is also a tree <sil=0.997> .PERIOD This is also a tree that has only one node <sil=0.977> .PERIOD But basically what we are saying is every at every level the same structure follows again from every node leftmost child right subling <sil=0.991> .PERIOD That is what we said <sil=0.969> .PERIOD Similarly <sil=0.495> ,COMMA in the binary tree here also every node can have optionally two sub trees it can also have one of the sub trees or it need not have any sub tree at all <sil=0.964> .PERIOD If it does not have the root even an empty tree is a binary tree <sil=0.966> .PERIOD So <sil=0.528> ,COMMA this is a skewed binary tree the picture is given here in the slide skewed means skewed to the left and then I have drawn another binary tree just called a full binary tree the nodes are full like this <sil=0.976> .PERIOD Then you also have another variant of it called the complete binary tree <sil=0.911> .PERIOD We will come back to this what we mean by this is when you fill this tree for example <sil=0.495> ,COMMA notice that I have filled the nodes at the first level nodes at the second level nodes at third level when I am filling them I go from left to right <sil=0.979> .PERIOD This is a complete binary tree while this one is not <sil=0.934> .PERIOD This one is not a complete binary tree while it is mirror image this is a complete binary tree <sil=0.907> .PERIOD Such binary trees have lot of applications in building what are called priority cubes we will talk about that little data <sil=0.974> .PERIOD Now first let us see why do we want a binary tree in the first place and is there any use of this and what are the operations that you will perform on a binary tree <sil=0.927> .PERIOD So <sil=0.408> ,COMMA you need something so what is it that we do these are the so now what is the binary tree now the binary tree is also an abstract data type like we saw the stacks <sil=0.332> ,COMMA queues and lists or lists <sil=0.367> ,COMMA queues and stacks and so we have the binary tree a d t and abstract data type <sil=0.966> .PERIOD Therefore <sil=0.615> ,COMMA you have a representation the reference says there is a root node and the left child and a right child that is the representation <sil=0.939> .PERIOD binary tree node so essentially a recursive data structure and then you have operations which can be performed and what are the operations that you perform because a rad t is like a mathematical model and we perform various operations on it <sil=0.940> .PERIOD So <sil=0.436> ,COMMA what do you want to do you want to create a binary tree first create an empty binary tree or create a binary tree with a particular node because you have to start from somewhere then you want to find left child or right child or right sub tree then you want to find a parent of a given node and right child left child or tree talked about and of course <sil=0.585> ,COMMA we need a create empty tree always that is required parent and not always sometimes they ask for the root of a tree <sil=0.932> .PERIOD So <sil=0.519> ,COMMA creation of empty tree tree and sometimes get root this is not good to have but since some of the books talk about it I kept this particular operation because get root if you have it tells you what the implementation of the binary tree is <sil=0.953> .PERIOD So <sil=0.413> ,COMMA now what we will do is we will take one application there lots of applications of binary trees can represent sets can do half-man coding you can represent heaps and dictionaries <sil=0.979> .PERIOD So <sil=0.354> ,COMMA the last few lectures we learnt about different types of data structures <sil=0.977> .PERIOD We talked about little less than we talked about trees <sil=0.949> .PERIOD Then we did specifically binary trees <sil=0.305> ,COMMA binary search trees and priority cues <sil=0.973> .PERIOD This is what we had studied <sil=0.949> .PERIOD Now <sil=0.324> ,COMMA if you look at all these kinds of data structures that we have studied whether it is a tree <sil=0.533> ,COMMA binary tree <sil=0.465> ,COMMA binary search tree or a priority cue <sil=0.945> .PERIOD We always had some kind of a node which had kind of a higher priority <sil=0.972> .PERIOD There was a header node in the case of lists which then pointed to other nodes <sil=0.929> .PERIOD It does not matter whatever the implementation array or we put in a hierarchy there <sil=0.971> .PERIOD For a tree for example we said there is a root and then there are children and so on <sil=0.966> .PERIOD Similarly <sil=0.305> ,COMMA for a binary tree we had what is called a left child and right child and we had a node that was designated as the root <sil=0.974> .PERIOD Now <sil=0.640> ,COMMA let us think of another problem <sil=0.936> .PERIOD Today with all of you are on Facebook I am sure and when you look at Facebook what are you doing you have a set of frames and so a set of frames watch you and then you watch somebody else and so on <sil=0.955> .PERIOD You are connected to somebody else who is also having a set of frames <sil=0.956> .PERIOD You also watch them and so on <sil=0.944> .PERIOD Now <sil=0.594> ,COMMA in such an example and this one has perhaps another set of frames some of them may be disjoint with respect to you <sil=0.960> .PERIOD Let us say this is you <sil=0.905> .PERIOD This is your friend one friend and so on <sil=0.964> .PERIOD So <sil=0.531> ,COMMA what is interesting is this called a social network and interestingly this social network has a lot of branches and in the social network there is nothing like in your friend circle for example <sil=0.353> ,COMMA you have some experience and amongst these experience one of your experience has another set of friends who are disjoint with you <sil=0.984> .PERIOD It is possible and there is nothing like a hierarchy <sil=0.957> .PERIOD In the earlier data structures that we saw we saw the header node then we saw the root node and we said access to any other node is via the root node here via the header node in the list and so on <sil=0.979> .PERIOD Here in the other hand there is no hierarchy amongst the nodes <sil=0.904> .PERIOD So <sil=0.560> ,COMMA we want to represent something like this <sil=0.954> .PERIOD This is a very <sil=0.389> ,COMMA very common natural phenomena in nature but generally things can be represented such that there are different nodes each one has its functionality and they are connected to each other by some property <sil=0.979> .PERIOD Then to represent something like this for example <sil=0.423> ,COMMA I may want to find out who are all the friends that are connected to you or I may want to find all the friends who are connected to f 1 or f 2 or f 3 for that matter <sil=0.966> .PERIOD Then if it if it was using a tree then I would say if you were the root then I would say I have to access any of your friends I have to go through only you <sil=0.971> .PERIOD Then what happens people who are not friends of you I cannot get access to them <sil=0.976> .PERIOD So <sil=0.645> ,COMMA another nice type of a data structure is what is called a graph <sil=0.993> .PERIOD A graph is essentially consists of a set of vertices the vertices here are you and your friends in the social network and these vertices are connected by arcs if there is some connection over here <sil=0.946> .PERIOD So <sil=0.571> ,COMMA you have a set of vertices and if there is a connection between the two of them something you are a friend or whatever it may be then that is represented by an arc <sil=0.948> .PERIOD The vertices are also called nodes or points the rocks are also called edges and edges may be for example <sil=0.482> ,COMMA you may think for example that f 1 is your best friend but f 1 does not think that you are his or her best friend <sil=0.937> .PERIOD So <sil=0.481> ,COMMA that graph for example <sil=0.636> ,COMMA when I am looking at it over here I might have if I am looking at only best friends you think f 1 is your best friend but f 1 things f 2 is best friend and so on <sil=0.937> .PERIOD It is possible something like this and f 3 perhaps things y is you are his best friend but you do not feel the same way <sil=0.939> .PERIOD Such graphs are what we call directed graphs can have directed graphs or you can have undirected graphs <sil=0.963> .PERIOD For example <sil=0.528> ,COMMA if I am looking at network communication across how do you connect to various websites then you are sitting at your home with your computer over here then you are connected to let us say if you using b s in l you are connected to a b s in l router then this b s in l router goes through number of various links through the internet and perhaps your server is somewhere found over here and normally these links are what we call bi directional links and then we say that this is an undirected graph both the graphs are important in practice we like to analyze both of these graphs <sil=0.920> .PERIOD So <sil=0.507> ,COMMA basically what is it that this defines whether a graph is directed or undirected the edges may be directed or undirected when the edges are directed the graph is called a directed graph otherwise the graph is called an undirected graph <sil=0.917> .PERIOD Now <sil=0.384> ,COMMA how do you define an arc or an edge we represent it as an ordered pair of vertices see the example over here if there are n vertices in the graph v 1 2 v n if there is an edge between v 1 2 v 3 let us say we represent it by a symbol like this or if you are writing it you put it as an ordered pair u comma v v 1 comma v 2 in this particular example <sil=0.928> .PERIOD There is an edge between v 1 and v 3 you write it as an ordered pair like this <sil=0.987> .PERIOD Now <sil=0.372> ,COMMA then you also have what are called so if you want to define a path how do I define a path if I have if I want to find a path from here to here then let us say this is node v 1 v 2 v 3 then I would say my path is from v 1 to v 2 2 and v 2 2 v 3 is my path <sil=0.969> .PERIOD So <sil=0.634> ,COMMA this corresponds to a path <sil=0.931> .PERIOD So <sil=0.582> ,COMMA you can have a set of sequence of vertices which gives you the path <sil=0.910> .PERIOD So <sil=0.607> ,COMMA that means what I am saying here I can represented this is v 1 v 2 v 3 corresponds to a path that means there is an edge from v 1 to v 2 v 2 to v 3 and that represents the path starting from here to reach this particular node <sil=0.958> .PERIOD Now <sil=0.395> ,COMMA you can have both labeled and unlabeled graphs <sil=0.575> ,COMMA but labeled graphs are what we are going to look at <sil=0.956> .PERIOD So <sil=0.310> ,COMMA when I look at a labeled graph I have something like this vertices are labeled here <sil=0.976> .PERIOD See here let us say and if I have weights on this 4 6 8 9 <sil=0.999> .PERIOD So <sil=0.524> ,COMMA both edges and nodes can be labeled as a nodes and the edges can be labeled <sil=0.936> .PERIOD What do these weights mean to give you an idea if you want to let us say travel from one place to another and then this could this weight could correspond to the amount of time it takes for you to reach from point a to point p for that matter <sil=0.951> .PERIOD So <sil=0.463> ,COMMA this is what is what a labeled graph is <sil=0.925> .PERIOD Now <sil=0.453> ,COMMA I want to just leave you with one example although we will not be discussing this graph problems can be found in various applications <sil=0.939> .PERIOD Here is a very interesting example <sil=0.995> .PERIOD Let us see this <sil=0.942> .PERIOD Let us say now here is a graph where I want to this is a 5 point intersection there are 5 lanes which are intersecting over here <sil=0.926> .PERIOD There is one road is called a another road is called b c d and e c and e are one way a b d are by directional <sil=0.951> .PERIOD Now <sil=0.594> ,COMMA I want to let us say you know my job is to design a traffic signal for this <sil=0.917> .PERIOD I want to put a traffic signal such that no accidents happen if you follow the signaling rules <sil=0.922> .PERIOD So <sil=0.532> ,COMMA how do I go about defining it <sil=0.996> ?QUESTIONMARK It was first thing let us assume that this is India and all left turns are free for the timing will assume that therefore <sil=0.614> ,COMMA b to c is permitted similarly a to b is permitted and e to a is permitted and d to d to is of course <sil=0.605> ,COMMA is a right turn is not permitted without a signal <sil=0.948> .PERIOD So <sil=0.622> ,COMMA what we will do is I want to just see what I have done here <sil=0.917> .PERIOD I have converted this problem of designing a traffic signal for this such that I have converted it to a graph problem <sil=0.965> .PERIOD What have I done over here <sil=0.967> ?QUESTIONMARK I have I have basically enumerated all the possible paths that exist that is I can go from d to b <sil=0.960> .PERIOD I can go from a to c I can go from e to c can go from a to d we can go from d to a d to b and so on <sil=0.911> .PERIOD So <sil=0.540> ,COMMA what do I do <sil=0.892> ?QUESTIONMARK I look at all the paths that all the roads that can be reached from a from a I can go to b from a I can go to c and a I can go to d <sil=0.997> .PERIOD So <sil=0.613> ,COMMA I put make them as nodes <sil=0.917> .PERIOD Similarly <sil=0.506> ,COMMA from b what are the paths that I can take I can go from b to a I can go from b to c and I can also go from b to d <sil=0.995> .PERIOD So <sil=0.501> ,COMMA there are three paths again similarly <sil=0.522> ,COMMA I do it for the rest also d to I have d to a d to b and d to c and e to a from e to I have e to a e to b e to c and a to d all the four paths are possible <sil=0.999> .PERIOD Then once I so basically what is it what are the nodes the nodes of this graph correspond to the roads that the paths that are possible <sil=0.965> .PERIOD If I am traveling by on this road and if I am taking a vehicle which are all the legal paths that are allowed <sil=0.927> .PERIOD Now <sil=0.607> ,COMMA my job is to design a traffic signal <sil=0.956> .PERIOD Then what I do is I join a pair of nodes by an edge if both of them cannot happen simultaneously <sil=0.988> .PERIOD So <sil=0.440> ,COMMA let us look at this let us look at a to d and e d and let us see that I am looking at a c a d and d b <sil=0.991> .PERIOD So <sil=0.521> ,COMMA this a d and this is d b remember this is left turn right left hand traffic <sil=0.912> .PERIOD So <sil=0.568> ,COMMA this is going this way and this is coming this way <sil=0.921> .PERIOD So <sil=0.408> ,COMMA both of them cannot happen simultaneously <sil=0.942> .PERIOD So <sil=0.331> ,COMMA what I do is I connect here this may be a little incomplete <sil=0.534> ,COMMA but what I have done is I have connected all the nodes in this graph which cannot happen simultaneously by an edge <sil=0.950> .PERIOD Then what happens is this becomes what is called <sil=0.918> .PERIOD Now <sil=0.429> ,COMMA I said as I said I want to define a traffic signal <sil=0.989> .PERIOD So <sil=0.607> ,COMMA what is a problem of traffic signal now basically it is a question of colors <sil=0.967> .PERIOD What are the colors that you are familiar with you have green yellow and red or green and red for the timing let us see that <sil=0.904> .PERIOD So <sil=0.340> ,COMMA what this means is that when I am defining colors for this two parts which intersect intersect cannot have green at the same time <sil=0.920> .PERIOD So <sil=0.375> ,COMMA what I essentially do is I try to find out how many different colors are required to design this traffic signal <sil=0.930> .PERIOD How do I find the number of colors <sil=0.980> .PERIOD So <sil=0.513> ,COMMA what happens is it is very interesting that designing the traffic signal for this intersection simply becomes a problem of finding a graph edges in the graph and ensuring that two nodes which are adjacent to each other that is two nodes which are connected by an edge do not have the same color <sil=0.937> .PERIOD So <sil=0.646> ,COMMA first for example <sil=0.396> ,COMMA so in this example if you see A B C E A simply does not matter at all <sil=0.914> .PERIOD You can you do not have to have any color for them because you do not have any edges a completely free left turns <sil=0.909> .PERIOD A C if I color as green then B and B A and B D cannot have the same color <sil=0.991> .PERIOD So <sil=0.642> ,COMMA you do this kind of then you basically if I given then you find out what are all the colors that A C can go with what are all the turns that A and C can happen together for example <sil=0.910> .PERIOD If I am if I am going from I can go from A to C and I can of course make a D C there is no I can go do a I can do a I can make a free left turn from B to C <sil=0.901> .PERIOD So <sil=0.602> ,COMMA these two do not intersect <sil=0.917> .PERIOD So <sil=0.481> ,COMMA it it need not have to have the same color <sil=0.905> .PERIOD So <sil=0.352> ,COMMA basically what you do is you look at this particular graph start off with coloring this put a give a different color to this and similarly keep doing this until you have satisfied all of that <sil=0.929> .PERIOD So <sil=0.429> ,COMMA to you find the until all the nodes in the graph are colored <sil=0.922> .PERIOD So <sil=0.533> ,COMMA there is just an example coloring problem is a difficult problem in fact finding the minimum number of colors is not a simple solution <sil=0.344> ,COMMA but this is just to give a straight that any there are you you start finding graph kind of problems even for something like this you would not even think about it is an intersection that you want to design <sil=0.915> .PERIOD And for this intersection you can can convert it to graph problem and then it simply boils down to a question of not giving two adjacent nodes the same color <sil=0.904> .PERIOD Developing the algorithm for this problem is a little tough it is a little beyond this scope of this course <sil=0.444> ,COMMA but to just give you an idea <sil=0.951> .PERIOD Now <sil=0.517> ,COMMA how do you represent graphs now graphs are can be represented by matrices here is a graph and what it tells me is whenever the there this is what is called an adjacent seam matrix this is a two dimensional matrix where you have vertices on the y axis and also on the x axis and if between a pair of nodes there is a edge you you market as one otherwise 0 <sil=0.965> .PERIOD If it has if it is a this is an unweighted graph if it is a weighted graph that it has numbers on the edges then you put that number over here <sil=0.908> .PERIOD There is another representation called the adjacent c list representation the adjacent c list representation for every node it is an array of nodes and at every node you have a linked list which says to which node it is connected to for example <sil=0.478> ,COMMA a has edges to b and d and b has edges to a c and so on <sil=0.998> .PERIOD Put all of for every node you give the since this is an undirected graph we also show that d has edges to a b and d because both the forward and the backward edges are present that is what we assume it to be <sil=0.903> .PERIOD So <sil=0.516> ,COMMA there is these are two different representations of graphs <sil=0.961> .PERIOD So <sil=0.549> ,COMMA now we have I think I have motivated you sufficiently to look at graph problems and what we will do is in the next one or two lectures we will look at some different problems on graphs and so we will stop with this introduction on graphs now <sil=0.913> .PERIOD Hello <sil=0.374> ,COMMA welcome to this module on C++ <sil=0.970> .PERIOD I promised earlier that we will see a quick introduction to C++ and this material is done in such a way that it will give you just enough material to understand what is happening in the rest of the course <sil=0.991> .PERIOD So <sil=0.610> ,COMMA I will start with a disclaimer <sil=0.640> ,COMMA this module is not a complete treatment on C++ <sil=0.917> .PERIOD C++ is a vast ocean and this next 15 or 20 minutes is not going to give enough justice to C++ <sil=0.920> .PERIOD So <sil=0.465> ,COMMA it is not a complete exhaustive treatment of C++ <sil=0.961> .PERIOD Also do not expect a lot of object oriented programming skills to be learnt in this 15 minute module <sil=0.935> .PERIOD There is going to be just enough material to appreciate the syntax of C++ and by no means it is complete <sil=0.983> .PERIOD So <sil=0.631> ,COMMA the basic material is based on true strips slides <sil=0.946> .PERIOD So <sil=0.363> ,COMMA he teaches this course on C++ and he is actually the inventor of C++ <sil=0.915> .PERIOD So <sil=0.405> ,COMMA in some sense this is from the horse's mouth <sil=0.926> .PERIOD So <sil=0.362> ,COMMA let us look at the notion of classes and objects <sil=0.995> .PERIOD So <sil=0.339> ,COMMA if you are in slightly senior year in your class in the second year or 30 or maybe you have done some C++ programming <sil=0.957> .PERIOD So <sil=0.303> ,COMMA the notion of classes and objects are probably familiar to you <sil=0.432> ,COMMA but I am not going to assume anything like that <sil=0.981> .PERIOD So <sil=0.370> ,COMMA I am going to assume that you do not know what classes and objects are <sil=0.941> .PERIOD Let us start with this basic declaration called int x <sil=0.941> .PERIOD We can think of int as a class <sil=0.911> .PERIOD So <sil=0.450> ,COMMA it is a basic data type and the moment you say something is int or an integer <sil=0.468> ,COMMA you know that there are certain operations that you can do on it and there are certain properties of integers <sil=0.925> .PERIOD So <sil=0.428> ,COMMA for example integers can have only values like 1 <sil=0.433> ,COMMA 2 <sil=0.629> ,COMMA 3 <sil=0.477> ,COMMA 0 <sil=0.324> ,COMMA minus 1 <sil=0.985> ,COMMA minus 2 <sil=0.547> ,COMMA minus 3 and so on <sil=0.921> .PERIOD You cannot have a valid value 1 <sil=0.943> .PERIOD 6 <sil=0.644> .PERIOD So <sil=0.371> ,COMMA we know some of these properties about int <sil=0.909> .PERIOD So <sil=0.577> ,COMMA anytime when you have something called a class <sil=0.579> ,COMMA you know that there are certain types <sil=0.954> .PERIOD So <sil=0.367> ,COMMA there are certain properties of a class and there are only certain operations that you can do on the data type <sil=0.904> .PERIOD So <sil=0.633> ,COMMA for the basic data types <sil=0.611> ,COMMA the language itself tells you that these are the basic set of values that you can take and these are the valid operations that you can do <sil=0.964> .PERIOD So <sil=0.340> ,COMMA that is the notion of a class <sil=0.924> .PERIOD Here <sil=0.493> ,COMMA if you look at x <sil=0.370> ,COMMA x is actually an object <sil=0.948> .PERIOD So <sil=0.485> ,COMMA what we mean by an object is it is not something abstract when I say integer right <sil=0.626> ,COMMA when I say int and I am describing only the properties that int integers have and the operations <sil=0.929> .PERIOD Only when I say int x <sil=0.356> ,COMMA we get a location allocated to it and on this location <sil=0.559> ,COMMA we can do various operations <sil=0.988> .PERIOD So <sil=0.357> ,COMMA the operations of whatever on x <sil=0.515> ,COMMA whatever operations are allowed or only those operations that are allowed on integers <sil=0.927> .PERIOD So <sil=0.601> ,COMMA x is an object of the type integer <sil=0.975> .PERIOD So <sil=0.503> ,COMMA the class name is int and the object name is x <sil=0.985> .PERIOD I can have more objects of the same type <sil=0.951> .PERIOD So <sil=0.610> ,COMMA for example <sil=0.404> ,COMMA when I say int y <sil=0.497> ,COMMA y is another object of the same type integer <sil=0.953> .PERIOD So <sil=0.474> ,COMMA at some level <sil=0.628> ,COMMA you can think of types as classes and actual variables are objects <sil=0.931> .PERIOD So <sil=0.538> ,COMMA here y is another object of the data type integer <sil=0.902> .PERIOD So <sil=0.576> ,COMMA this is all okay for basic data types <sil=0.914> .PERIOD So <sil=0.323> ,COMMA for basic data types <sil=0.502> ,COMMA you really do not need classes and objects <sil=0.947> .PERIOD This distinction is not really necessary because the language itself gives you all of that <sil=0.930> .PERIOD So <sil=0.325> ,COMMA the notion of operations that you do on integers and so on also already given by the language <sil=0.965> .PERIOD Whereas <sil=0.615> ,COMMA if you have a user defined data type <sil=0.460> ,COMMA then it becomes useful and necessary to define what is allowed and what is not allowed and to define what operations can be done <sil=0.934> .PERIOD So <sil=0.646> ,COMMA let us look at the basic idea of classes <sil=0.911> .PERIOD A class is actually a user defined data type that specifies how objects of its type can be created and used <sil=0.943> .PERIOD How do you create an object of a certain class and how to use it is described in the class <sil=0.982> .PERIOD So <sil=0.590> ,COMMA it directly represents some kind of a concept in a program <sil=0.939> .PERIOD So <sil=0.401> ,COMMA whenever you think of it <sil=0.526> ,COMMA so it is it so this notion of a it as an entity <sil=0.480> ,COMMA it is possible that it is a class or it is an object <sil=0.956> .PERIOD So <sil=0.312> ,COMMA let us see things like this <sil=0.924> .PERIOD So <sil=0.563> ,COMMA I have the notion of a vector <sil=0.617> ,COMMA a matrix <sil=0.484> ,COMMA a string and so on <sil=0.966> .PERIOD So <sil=0.637> ,COMMA these are probably classes <sil=0.931> .PERIOD Whereas <sil=0.584> ,COMMA I have a matrix which contains all my students names and let us say records <sil=0.575> ,COMMA their marks and so on <sil=0.375> ,COMMA then that is a specific object <sil=1.000> .PERIOD I may have a matrix which contains all these integers and I want to do multiplication of integers and so on <sil=0.933> .PERIOD That is also a matrix <sil=0.527> ,COMMA but it is a matrix of integers <sil=0.989> .PERIOD So <sil=0.562> ,COMMA the objects are of a particular class <sil=0.998> .PERIOD So <sil=0.308> ,COMMA it is a physical entity or it is a abstract notion and C++ gives you this basic notion of create defining classes <sil=0.928> .PERIOD You can define what the basic data structure is or the data type is and you can also have instances of that particular data type and classes form the basic building block for building a large scale program <sil=0.969> .PERIOD So <sil=0.361> ,COMMA let us take a small example here <sil=0.932> .PERIOD We have class x followed by left and right flower braces and a semicolon and we are going to put in data members and function members inside this <sil=0.955> .PERIOD So <sil=0.499> ,COMMA the data members are supposed to store the information and the function members are supposed to tell you how to manipulate the data members <sil=0.980> .PERIOD So <sil=0.385> ,COMMA this resembles how you did it for structures <sil=0.936> .PERIOD So <sil=0.447> ,COMMA there also we had something called struct type x and followed by braces and we had members inside <sil=0.957> .PERIOD Only difference is that we not only have data members here <sil=0.572> ,COMMA we also have function members <sil=0.926> .PERIOD So <sil=0.443> ,COMMA let us see a small example here class x and class x has int m which is a data member and int mf of int v which is a function or a method <sil=0.956> .PERIOD So <sil=0.446> ,COMMA we have a basic data type inside it and we have a method inside it <sil=0.909> .PERIOD So <sil=0.538> ,COMMA that is a class <sil=0.948> .PERIOD So <sil=0.572> ,COMMA x has x is a class and it has a variable m or the member m and it has a function mf <sil=0.946> .PERIOD So <sil=0.310> ,COMMA this function mf is supposed to take an integer v and it takes the value of v puts it in m <sil=0.449> ,COMMA but the old value that was there before the old value that was there before the function is called is supposed to be returned <sil=0.913> .PERIOD So <sil=0.562> ,COMMA that is the functions member <sil=0.953> .PERIOD So <sil=0.559> ,COMMA this is something called get and set <sil=0.932> .PERIOD So <sil=0.533> ,COMMA you are getting the previous value which is stored <sil=0.372> ,COMMA but you are also setting it to the new value that you supply <sil=0.976> .PERIOD So <sil=0.305> ,COMMA v is the new value that you supply and the old value of m is supposed to be retrieved <sil=0.944> .PERIOD So <sil=0.384> ,COMMA let us say that is the class description <sil=0.900> .PERIOD We will get to this notion of public in a little while <sil=0.996> .PERIOD So <sil=0.633> ,COMMA let us see how this class can be used <sil=0.925> .PERIOD We have x bar <sil=0.923> .PERIOD So <sil=0.390> ,COMMA remember x is a data type <sil=0.978> .PERIOD So <sil=0.523> ,COMMA instead of class x bar which we did for structures <sil=0.595> ,COMMA wherever we had structures we said struct x and so on <sil=0.985> .PERIOD For classes you do not have to do that in c plus plus <sil=0.967> .PERIOD x bar so <sil=0.607> ,COMMA where is an object of the type x or the class x <sil=0.939> .PERIOD Now <sil=0.475> ,COMMA if you want to access the member m in it <sil=0.453> ,COMMA we can say where dot m <sil=0.996> .PERIOD So <sil=0.514> ,COMMA this is just like the structure <sil=0.900> .PERIOD We saw this before where dot m is 7 will change the data member to 7 <sil=0.961> .PERIOD Interestingly you can do something like this <sil=0.965> .PERIOD We can do where dot m f of 9 <sil=0.983> .PERIOD What this will do is <sil=0.478> ,COMMA we will take the value 9 and supply that to this class <sil=0.982> .PERIOD So <sil=0.557> ,COMMA if the previous value that you contain is 7 <sil=0.357> ,COMMA you will get this small case x to be the value 7 <sil=0.331> ,COMMA but you set it to 9 <sil=0.913> .PERIOD So <sil=0.339> ,COMMA here if you go and print where dot m after this line <sil=0.543> ,COMMA this would have the value 9 <sil=0.987> .PERIOD So <sil=0.423> ,COMMA basically the nice thing about this class is that we have the members access with dot m <sil=0.446> ,COMMA the methods are also access with dot <sil=0.952> .PERIOD So <sil=0.346> ,COMMA both the methods and the data members are access using dot operator <sil=0.904> .PERIOD So <sil=0.351> ,COMMA now let us go and look at what is this notion of public versus private <sil=0.965> .PERIOD So <sil=0.337> ,COMMA again if you are exposed to c plus plus you probably know this already <sil=0.608> ,COMMA but in c plus plus you can have members and functions that are of two types <sil=0.480> ,COMMA public or private <sil=0.941> .PERIOD So <sil=0.325> ,COMMA if it is public these members can be accessed by anyone outside whereas <sil=0.616> ,COMMA if it is private then both if a member is private only the classes methods can access it <sil=0.937> .PERIOD If a function is private <sil=0.514> ,COMMA only this function cannot be called from outside <sil=0.962> .PERIOD So <sil=0.341> ,COMMA private members are supposed to have implementation details that are hidden from the outside world and public methods and members are directly accessible from the outside world <sil=0.957> .PERIOD We will see specific examples in a little while <sil=0.990> .PERIOD So <sil=0.476> ,COMMA what is the difference between struct and the class <sil=0.924> ?QUESTIONMARK So <sil=0.514> ,COMMA let us see class x <sil=0.449> ,COMMA let us say I put int m f by default all members are private in a class <sil=0.985> .PERIOD So <sil=0.444> ,COMMA if I did something like this class x int m f <sil=0.518> ,COMMA it means that m f is a method that you cannot call from outside <sil=0.996> .PERIOD So <sil=0.453> ,COMMA let us say I did class x object x and y is x dot m f <sil=0.430> ,COMMA this would be invalid because m f is a private method it cannot be called from the external world <sil=0.990> .PERIOD Whereas <sil=0.472> ,COMMA if this had been a structure struct x int m by default that means <sil=0.507> ,COMMA it is actually equivalent to a class x with m being a public variable and structs are primarily used for data structures where the members can take any value <sil=0.911> .PERIOD Whereas <sil=0.495> ,COMMA you use classes whenever you want something hidden from the programmer <sil=0.921> .PERIOD So <sil=0.511> ,COMMA the programmer should get clean interfaces like insert delete and so on and whatever manipulation is happening internally need not be exposed to the programmer <sil=0.940> .PERIOD So <sil=0.348> ,COMMA let us see a small example which explain this in a little more detail <sil=0.916> .PERIOD Let us say I have a struct called date which has year month and day and I have date my birthday <sil=0.933> .PERIOD So <sil=0.342> ,COMMA let us say it is tracking a birthday <sil=0.947> .PERIOD If you do this there is nothing which will stop you from writing something like this my birthday dot y is 12 <sil=0.366> ,COMMA my birthday dot m is 30 <sil=0.429> ,COMMA my birthday dot d is 19 <sil=0.570> ,COMMA 19 <sil=0.348> ,COMMA 150 <sil=0.955> .PERIOD So <sil=0.488> ,COMMA if you look at the right side they are all integers and the left side data types are all integers <sil=0.934> .PERIOD So <sil=0.614> ,COMMA you are setting y to 12 m to 30 and d to 1 9 5 0 <sil=0.914> .PERIOD So <sil=0.405> ,COMMA as 3 separate integers use assign 3 separate values which is all ok <sil=0.460> ,COMMA but there is a problem <sil=0.928> .PERIOD If you go and deal with this as a date there is a small problem <sil=0.994> .PERIOD You are looking at year 12 maybe it is 12 AD but the month is 30 and the day is 19 5 0 this does not make sense <sil=0.961> .PERIOD So <sil=0.356> ,COMMA maybe it was a mistake it should have been year 1950 and day must have been 30 and probably the month must have been 12 where we are talking about 30th December 1950 right <sil=0.995> .PERIOD So <sil=0.550> ,COMMA maybe it was a mistake <sil=0.526> ,COMMA but if you have a structure from the outside by mistake if you do this there is nothing which will stop you from doing it <sil=0.999> .PERIOD Whereas <sil=0.332> ,COMMA if it is a class then I can put some check and protect invalid values from not being taken <sil=0.925> .PERIOD So <sil=0.646> ,COMMA let us look at some other additional things right <sil=0.978> .PERIOD Let us say I want to initialize the day I have y m and d which are passed as 3 integers and I want to set up this dd which is a pointer to the date data type <sil=0.974> .PERIOD So <sil=0.420> ,COMMA I want dd's y m and d to be the values y m and d that are passed on <sil=0.975> .PERIOD So <sil=0.646> ,COMMA maybe I want to function like this initialize the members of this structure to certain values or I may want to add a certain number of days to the type <sil=0.976> .PERIOD So <sil=0.494> ,COMMA let us say the current date is 30th December 1950 and I want to add 2 days to it and move to January 1 1951 <sil=0.962> .PERIOD Let us say I want to do that I should be able to do it add a few days and have a mechanism by which I not only recognize that 2 days from 30th December is not 30 second December <sil=0.979> .PERIOD In fact <sil=0.550> ,COMMA it is not even in December it is in January and it is not even in January of this year it is actually moving to the next year <sil=0.923> .PERIOD So <sil=0.462> ,COMMA if I add 2 days to 30th December 1950 internally I want this to automatically move to January 1 1951 <sil=0.918> .PERIOD In fact <sil=0.310> ,COMMA I may want to handle cases like leap year and so on also appropriately <sil=0.912> .PERIOD All these details I do not want to expose it to the programmer <sil=0.999> .PERIOD So <sil=0.589> ,COMMA this becomes very cumbersome all I want to give to the programmers add day as an interface with structures it is not easily doable because you can always come and manipulate these values without going through these methods you may go and increment d directly without realizing that the tuple d comma m comma y is not valid you may do that <sil=0.911> .PERIOD But if you are forced to go through add day as a function always then add day can be implemented in a much cleaner way and all the errors can be checked and the function can be implemented so that it is always correct <sil=0.930> .PERIOD So <sil=0.578> ,COMMA let us look at this small example I have int y comma m comma d I always want some valid value for the dates <sil=0.906> .PERIOD So <sil=0.497> ,COMMA I want what is called a constructor <sil=0.949> .PERIOD So <sil=0.310> ,COMMA any time this object called date is going to be created it has to be supplied valid values otherwise it would be incorrect and I want to be supporting add day <sil=0.956> .PERIOD So <sil=0.439> ,COMMA even though it is given with struck date this is not valid syntax <sil=0.917> .PERIOD So <sil=0.342> ,COMMA we would want class date here and class date will have 3 members y m and d and it will have 2 methods date which will take the 3 initial values and add days which will add the certain number of days to the current date <sil=0.957> .PERIOD So <sil=0.359> ,COMMA the moment you do this if you do date my birthday this would be incorrect because it is not initialized <sil=0.983> .PERIOD If you do date my birthday of 12 comma 30 comma 1950 the year is 12 the month is 30 and days 1950 add day can be written in such a way that this can be recognized as an error and this can be indicated <sil=0.974> .PERIOD However <sil=0.570> ,COMMA if you do date my day of 1950 comma 12 comma 30 this would be recognized as a valid day and later if I do my birthday dot add day of 2 the birthday moves from 30 December 1952 first January 1951 <sil=0.925> .PERIOD So <sil=0.576> ,COMMA this is clean however if I do my birthday dot m is 14 this would be invalid because you are accessing the member m directly and this is not correct <sil=0.968> .PERIOD So <sil=0.551> ,COMMA if you do classes the way to do that is you have y m and d as private and you have the all the methods as public <sil=0.985> .PERIOD So <sil=0.453> ,COMMA date is public add day will actually change the contents of y m and d and we have 3 methods called month day and year and these 3 methods actually return the current month the current day and current year <sil=0.924> .PERIOD So <sil=0.626> ,COMMA these 3 methods give you only read access to the data date is supposed to give write access you can change the contents of y m and d and add day can also change the contents of y m and d <sil=0.908> .PERIOD So <sil=0.335> ,COMMA date my birthday of 1950 12 30 will change y m and d to be these 3 values and I can do print F percentage d my birthday dot month and my birthday dot month is a method if you go and look at that method it returns m and what is the value of m it is supposed to be 12 <sil=0.919> .PERIOD So <sil=0.325> ,COMMA it will print 12 here however if I do my birthday dot m is 14 the compiler will catch it even when you compile it the compiler will catch it and say that m is a private attribute it cannot be manipulated directly <sil=0.925> .PERIOD So <sil=0.606> ,COMMA if you want to manipulate m you can either go and create a new variable and access through it or you can only add days to it you cannot manipulate it directly <sil=0.999> .PERIOD So <sil=0.534> ,COMMA the notion of a valid date is a very important special case and you want to do this and you want to try and design of a data type so that there is always some guarantee that the underlying data is valid <sil=0.944> .PERIOD So <sil=0.322> ,COMMA for example <sil=0.443> ,COMMA maybe I want to design a class that is supposed to represent a point in the first quadrant <sil=0.929> .PERIOD First quadrant is anything including 0 comma 0 or origin <sil=0.957> .PERIOD So <sil=0.481> ,COMMA the first quadrant is anything including 0 comma 0 and if I move to the right or I move up that would be the first quadrant in a plane <sil=0.926> .PERIOD I want to be able to ensure that at no point of time this point gets out of the first quadrant <sil=0.934> .PERIOD I do not want to do manipulations or I do not want to allow manipulations to go out of the first quadrant <sil=0.927> .PERIOD If I want to do things like that then I will do operations and always check whether the data is still in the first quadrant or not and report an error if it gets out of the first quadrant for things like this <sil=0.991> .PERIOD So <sil=0.360> ,COMMA to check validity it is always useful to do this to allow classes to be defined and the classes can also go and check for the validity <sil=0.960> .PERIOD So <sil=0.589> ,COMMA let us see how this whole thing would look like <sil=0.923> .PERIOD So <sil=0.456> ,COMMA I was talking about this function called date <sil=0.966> .PERIOD This date is a special function which carries the same name as the classes name <sil=0.991> .PERIOD So <sil=0.383> ,COMMA you can see that the blue and the red one they have the same name <sil=0.978> .PERIOD The constructors always take the same name as the class <sil=0.939> .PERIOD In this case the constructor is a method which takes three integers y <sil=0.613> ,COMMA y <sil=0.406> ,COMMA m <sil=0.426> ,COMMA m <sil=0.593> ,COMMA dd and what it does is it assigns your local variable y to y <sil=0.495> ,COMMA y and the local variable m is assigned the value m and the local variable d is assigned the value dd <sil=0.928> .PERIOD So <sil=0.647> ,COMMA if you create an object of the type date and if you put date of 12 comma 30 comma 1950 internally you can write code within the constructor which will go and check that and say that it is invalid <sil=0.995> .PERIOD However <sil=0.480> ,COMMA if it is valid it initializes it and this check that you do inside the code may just leave it as it is <sil=0.936> .PERIOD So <sil=0.452> ,COMMA if I end up define let us say I design a function called int date colon colon season <sil=0.996> .PERIOD This is supposed to return 0 <sil=0.449> ,COMMA 1 <sil=0.606> ,COMMA 2 or 3 depending on whether it is winter spring <sil=0.390> ,COMMA summer and autumn <sil=0.914> .PERIOD Let us say that is what we want to do <sil=0.952> .PERIOD If you do int date colon colon season it means you are looking at a function called season which is a method inside this class called date <sil=0.971> .PERIOD However <sil=0.331> ,COMMA the class called date does not have a method called season the compiler will catch it and tell you that it is an error <sil=0.937> .PERIOD So <sil=0.557> ,COMMA this notion of public and private is a useful distinction to make <sil=0.910> .PERIOD We do not make everything public by default because by keeping things private we can provide a very clean interface and we can also maintain things which are supposed to be invariance <sil=0.946> .PERIOD What is the validity of the data inside we can maintain the invariance <sil=0.945> ?QUESTIONMARK This can also help in debugging programs because if you manipulated something and if something went wrong it could have happened only through functions that can manipulate the variables <sil=0.946> .PERIOD It could not have happened through something else which is outside <sil=0.940> .PERIOD So <sil=0.633> ,COMMA you can go and round up the usual suspects essentially and say that if manipulations happened it happened only through these methods and there is something in these methods which is incorrect <sil=0.962> .PERIOD And you will also see that it allows you to change the internal representation <sil=0.975> .PERIOD The notion of a class allows you to change the internal representation <sil=0.937> .PERIOD This is something that you will see in a lot of detail in a later class when we talk about the notion of ADT and data structures <sil=0.969> .PERIOD So <sil=0.406> ,COMMA as an ADT for a list could use a linked list internally or it could use an array internally <sil=0.983> .PERIOD The notion of a list is just a sequence of elements <sil=0.962> .PERIOD I could have used an array internally or I could have used a linked list internally <sil=0.901> .PERIOD This kind of implementation detail can be hidden from somebody who just wants to use a list <sil=0.958> .PERIOD And this is possible if you use classes <sil=0.981> .PERIOD So <sil=0.537> ,COMMA many times we go and look at what makes a good interface <sil=0.917> .PERIOD So <sil=0.381> ,COMMA we define classes in such a way that an interface is minimal <sil=0.930> .PERIOD It should be as small as possible <sil=0.991> .PERIOD At the same time it has to be complete <sil=0.939> .PERIOD So <sil=0.548> ,COMMA it has to be small <sil=0.954> .PERIOD It has to be small enough to do all the basic things but not any smaller than that <sil=0.948> .PERIOD It has to be the smallest and elegant set of things that you want to expose to the external world <sil=0.984> .PERIOD I mean and it has to be safe <sil=0.937> .PERIOD So <sil=0.374> ,COMMA you do not want to have the arguments passed in a different manner and so on <sil=0.974> .PERIOD You ensure that it is type safe <sil=0.944> .PERIOD So <sil=0.497> ,COMMA let us see how to define the linked list in a C plus plus way <sil=0.941> .PERIOD This is what I was promising earlier <sil=0.968> .PERIOD So <sil=0.560> ,COMMA to define linked list in a C plus plus way you would do something like this <sil=0.946> .PERIOD We define a class called node <sil=0.944> .PERIOD This is very similar to a structure <sil=0.907> .PERIOD So <sil=0.531> ,COMMA we had struck node data and next <sil=0.996> .PERIOD Here we have class node where the private members are data and next <sil=0.914> .PERIOD We also provide public methods <sil=0.926> .PERIOD Let us look at the public methods <sil=0.983> .PERIOD You have set data and set next which will let data and next to be changed and we have data and next which will do the get <sil=0.904> .PERIOD So <sil=0.406> ,COMMA these two methods give you get and these two methods give you put access to node <sil=0.998> .PERIOD So <sil=0.424> ,COMMA you are allowed to change with these two and you are allowed to read using these two <sil=0.979> .PERIOD And there is another method called node which is the constructor for class node <sil=0.904> .PERIOD This is not doing anything <sil=0.973> .PERIOD So <sil=0.349> ,COMMA it is not changing anything at all <sil=0.927> .PERIOD So <sil=0.494> ,COMMA it is not setting up anything <sil=0.942> .PERIOD So <sil=0.443> ,COMMA this is the basic class and we are going to use this class inside the linked list <sil=0.984> .PERIOD So <sil=0.436> ,COMMA what is the linked list have <sil=0.989> ?QUESTIONMARK The linked list has a node called the first node <sil=0.911> .PERIOD So <sil=0.489> ,COMMA the linked list has a first node and it supports various operations like print <sil=0.581> ,COMMA append <sil=0.321> ,COMMA delete and so on <sil=0.965> .PERIOD And it has a constructor called list <sil=0.997> .PERIOD If I want an initially empty list <sil=0.506> ,COMMA all it is supposed to do is ensure that there is no valid node that is pointed to from it <sil=0.982> .PERIOD So <sil=0.600> ,COMMA first equals null that is it <sil=0.919> .PERIOD So <sil=0.512> ,COMMA now you can see that the notion of a linked list becomes much cleaner <sil=0.988> .PERIOD So <sil=0.607> ,COMMA if you want to manipulate anything in the list <sil=0.494> ,COMMA you have to go through these functions here append <sil=0.415> ,COMMA delete and print <sil=0.918> .PERIOD You cannot go and access first directly because by default first is private <sil=0.994> .PERIOD You cannot access first directly <sil=0.982> .PERIOD You can only go through the interface functions namely print <sil=0.424> ,COMMA append and delete <sil=0.998> .PERIOD Let us see how a print method would look like <sil=0.908> .PERIOD So <sil=0.543> ,COMMA the implementation of print would look like this <sil=0.947> .PERIOD So <sil=0.538> ,COMMA node start temp equals first <sil=1.000> .PERIOD If temp itself is null which means it is an empty list <sil=0.361> ,COMMA you may want to print empty on the screen <sil=0.976> .PERIOD If temp if there is only one node in the list <sil=0.387> ,COMMA then the first node's next will be null <sil=0.993> .PERIOD We actually do this not using the next field <sil=0.552> ,COMMA but we call the method called next temp's next <sil=0.928> .PERIOD If that returns null <sil=0.645> ,COMMA then print the character which is contained in temp data and then followed by aronull <sil=0.944> .PERIOD Otherwise <sil=0.607> ,COMMA we run a do-by loop which prints one character at a time <sil=0.994> .PERIOD And the way we do that is we do not access the data element or the next pointer of the node directly <sil=0.935> .PERIOD We call the methods temp data and temp next to do that and we keep doing this till we hit the end of the list <sil=0.918> .PERIOD So <sil=0.554> ,COMMA this basic loop takes care of reading one element at a time from the nodes and printing them based on whether there is only zero element or one element or more than one element <sil=0.984> .PERIOD So <sil=0.397> ,COMMA this is clean because anyone who calls print does not have to worry whether it's an empty list or does it contain one element or more <sil=0.957> .PERIOD So <sil=0.522> ,COMMA the print itself takes care of the implementation <sil=0.994> .PERIOD The detail is hidden from the user <sil=0.913> .PERIOD So <sil=0.614> ,COMMA the user can just call print and be done with it <sil=0.917> .PERIOD Let us see append to the list <sil=0.991> .PERIOD So <sil=0.371> ,COMMA for appending to the list <sil=0.523> ,COMMA we are trying to add an element to the end of the list <sil=0.999> .PERIOD So <sil=0.329> ,COMMA we create a new node <sil=0.915> .PERIOD We set its data to the data that is past <sil=0.922> .PERIOD So <sil=0.572> ,COMMA append is supposed to take a data and it sets the data to the last and sets the next pointer to null <sil=0.958> .PERIOD So <sil=0.628> ,COMMA you create a new object of the type node and you start with a temporary variable here which points to first <sil=0.909> .PERIOD If the list is empty <sil=0.514> ,COMMA then you just make first equals new node because there is nothing else to do <sil=0.936> .PERIOD You created a new node and the first pointer will point to that <sil=0.943> .PERIOD However <sil=0.440> ,COMMA if it is not an empty list <sil=0.386> ,COMMA then we keep moving the pointer till we hit the end of the list at that point <sil=0.397> ,COMMA we insert it <sil=0.912> .PERIOD So <sil=0.371> ,COMMA this kind of a setup where we traverse the list and so on is completely hidden from the outside world <sil=0.922> .PERIOD So <sil=0.444> ,COMMA let me explain what I mean by hidden from the outside world <sil=0.927> .PERIOD By showing how the program will look like <sil=0.985> .PERIOD Let me write a small program which shows how clean this notion of classes make the whole program <sil=0.902> .PERIOD So <sil=0.329> ,COMMA I want to create a new link list and I want to add elements A <sil=0.418> ,COMMA B <sil=0.540> ,COMMA C and D and maybe at a later point of time <sil=0.388> ,COMMA I want to even delete the element B in the list <sil=0.933> .PERIOD So <sil=0.415> ,COMMA here I declare a variable called list or an object list <sil=0.632> ,COMMA which is of the data type list and this append A <sil=0.471> ,COMMA B <sil=0.545> ,COMMA C and D is going to add these characters A <sil=0.447> ,COMMA B and C and D to the list <sil=0.989> .PERIOD Let us see how this syntax is <sil=0.947> .PERIOD So <sil=0.556> ,COMMA list is an object <sil=0.988> .PERIOD When I say object <sil=0.927> .PERIOD upend <sil=0.597> ,COMMA this object is of the data type list <sil=0.977> .PERIOD So <sil=0.613> ,COMMA it is going to find out if there is a method by the name append and what does it take append takes the data type character <sil=0.979> .PERIOD So <sil=0.430> ,COMMA we are passing a character and list dot append will add A to the list <sil=0.912> .PERIOD At this point of time <sil=0.491> ,COMMA this list is empty <sil=0.981> .PERIOD We do not have to worry about that <sil=0.974> .PERIOD We just said list dot append of A and the first time append is called inside here <sil=0.552> ,COMMA you would create a node <sil=0.925> .PERIOD This would be not true <sil=0.911> .PERIOD You would just change the first point of the new node and maybe we can print it even <sil=0.942> .PERIOD As soon as you create a list with one node <sil=0.386> ,COMMA you can print it <sil=0.940> .PERIOD And then we do list dot append of B <sil=0.973> .PERIOD At this point <sil=0.507> ,COMMA the list already contains A and now the method will look at this is not the first node <sil=0.923> .PERIOD So <sil=0.394> ,COMMA it will go through the list find out that the null is pointed from A <sil=0.975> .PERIOD At that point <sil=0.483> ,COMMA it will add it <sil=0.907> .PERIOD So <sil=0.522> ,COMMA A will now point to B <sil=0.902> .PERIOD If you do this <sil=0.520> ,COMMA B will point to C <sil=0.944> .PERIOD And when you print <sil=0.642> ,COMMA you start from the first pointer <sil=0.442> ,COMMA print A <sil=0.460> ,COMMA print B <sil=0.525> ,COMMA print C and so on and go to the end <sil=0.932> .PERIOD Now <sil=0.342> ,COMMA you can append D <sil=0.955> .PERIOD So <sil=0.344> ,COMMA the list will have ABCD <sil=0.980> .PERIOD And finally <sil=0.608> ,COMMA if you call list dot delete of B <sil=0.449> ,COMMA if there is a function implemented by the name delete <sil=0.354> ,COMMA we assume that programmer has already taken care of that <sil=0.937> .PERIOD The class's designer has taken care of print append and delete as a user of the class <sil=0.916> .PERIOD So <sil=0.569> ,COMMA when I said user and programmer and so on till now <sil=0.467> ,COMMA I am talking about user of the class <sil=0.961> .PERIOD So <sil=0.317> ,COMMA the user of the class <sil=0.558> ,COMMA as a user <sil=0.512> ,COMMA I want the link list <sil=0.348> ,COMMA I do not want to worry about how the list is implemented <sil=0.367> ,COMMA how the append is implemented <sil=0.387> ,COMMA delete is implemented and so on <sil=0.967> .PERIOD I leave it to the designer of the class <sil=0.980> .PERIOD And this delete of B <sil=0.456> ,COMMA if there is a function defined by the name delete <sil=0.537> ,COMMA I will assume that that gets done and list dot print <sil=0.398> ,COMMA I will expect it to print AC and D <sil=0.962> .PERIOD So <sil=0.388> ,COMMA what did we get <sil=0.876> ?QUESTIONMARK The details of the implementation of append <sil=0.411> ,COMMA delete and creation of the list and so on are not exposed to the user of the class <sil=0.958> .PERIOD The main program became much cleaner <sil=0.957> .PERIOD See this <sil=0.427> ,COMMA this is much cleaner than making function calls to append and checking whether this is the first and second and so on <sil=0.934> .PERIOD We did not do any of that <sil=0.959> .PERIOD This becomes much cleaner here <sil=0.930> .PERIOD And we trust the implementation of the class list to be correct and complete <sil=0.960> .PERIOD This is something that we get from the implementation of a class <sil=0.997> .PERIOD This is the reason why we use C++ in the data structures lectures that are following <sil=0.942> .PERIOD So <sil=0.369> ,COMMA in the lectures on data structures <sil=0.314> ,COMMA you will see syntax of C++ <sil=0.990> .PERIOD So <sil=0.333> ,COMMA do not be bogged down by the syntax of C++ <sil=0.977> .PERIOD Just remember that you have individual members that are going to get operated around or manipulated <sil=0.965> .PERIOD You will either change the values of the members or you are going to read the values of the members <sil=0.986> .PERIOD You will see that there are public methods that are used to manipulate the individual members <sil=0.952> .PERIOD And you may also see private methods which are only called by public methods <sil=0.943> .PERIOD And you will see that the methods are actually invoked using the dot operator <sil=0.965> .PERIOD For example <sil=0.318> ,COMMA the linked list append would do my list dot append of X or you have my birthday dot month and so on <sil=0.922> .PERIOD So <sil=0.482> ,COMMA do not be surprised by functions being called with the dot operator <sil=0.959> .PERIOD So <sil=0.376> ,COMMA all you need is the basic syntax of C++ which shows that there are classes which has internal members and internal methods <sil=0.982> .PERIOD And they may have public members and public methods <sil=0.941> .PERIOD And the members and methods are going to be used just like you do it for structures using the dot operator <sil=0.976> .PERIOD So <sil=0.586> ,COMMA beyond this you probably do not need much of C++ <sil=0.996> .PERIOD And as I mentioned earlier <sil=0.587> ,COMMA we are not going to do anything more than that in this lecture <sil=0.909> .PERIOD So <sil=0.332> ,COMMA I said this is not a completely justified introduction to C++ <sil=0.939> .PERIOD I have done just enough so that you can appreciate the slides that are following or the lectures that are following on data structures <sil=0.931> .PERIOD So <sil=0.350> ,COMMA if you need C++ <sil=0.569> ,COMMA this is actually a completely new course that you have to do where you start with the syntax and semantics of C++ and also understand how to do object oriented design <sil=0.998> .PERIOD Since this course is objective is basic programming and data structures and algorithms <sil=0.308> ,COMMA we will not touch upon C++ in any further detail <sil=0.934> .PERIOD So <sil=0.579> ,COMMA thank you and this brings me to the end of this lecture <sil=0.940> .PERIOD Good morning <sil=0.956> .PERIOD In the last class we looked at binary trees and we looked at two applications <sil=0.968> .PERIOD One is constructing of a Huffman code using binary trees and we also talked about the construction of an expression tree from a post-fix expression using both binary trees and stacks <sil=0.960> .PERIOD Today and then I talked about the different types of traversals of a binary tree and we saw that when we take the expression tree and traverses in order we got the infix expression and when we traversed post order we got the post-fix expression and pre-order we did not do but you will get the pre-fix expression <sil=0.981> .PERIOD So today what I am going to talk about is I am going to and so just to recap what is pre-order traversal <sil=0.300> ,COMMA pre-order traversal is visit the root and visit the left child in pre-order look recursively and then visit the right child in pre-order recursively <sil=0.916> .PERIOD In order is visit the left child in in order recursively then visit the root then visit the right child in in order recursively <sil=0.989> .PERIOD Now and what is post-order visit left child in post-order recursively visit right child in post-order recursively visit root and post-order is what gives you your post-fix expression <sil=0.982> .PERIOD Now what we will do is suppose now we are given the traversal of the trees <sil=0.918> .PERIOD Given the traversal of this trees can we construct a unique tree <sil=0.948> .PERIOD So here we have a binary tree which is given to you and let me go through this example for you <sil=0.912> .PERIOD So what do we have <sil=0.907> ?QUESTIONMARK We have a here b c d e f and g and h some arbitrary binary tree <sil=0.933> .PERIOD What is it that I am assuming <sil=0.964> ?QUESTIONMARK I have given binary tree like this and given this binary tree we want to construct it is determine its pre-order in post-order traversals <sil=0.922> .PERIOD Let us look at the pre-order traversal <sil=0.944> .PERIOD What a pre-order traversal tell me visit root then visit left child and right child recursively <sil=0.978> .PERIOD That means what am I going to do <sil=0.900> ?QUESTIONMARK I am going to do the left child first they find b then this has to be done recursively <sil=0.947> .PERIOD Remember in any recursion what do we have to do <sil=0.855> ?QUESTIONMARK If you go down till the recursion terminates and only then you can backtrack <sil=0.999> .PERIOD So I visit b then I go down this is the next node which I will display and d g then we will come back because this left sub tree is completely over now <sil=0.972> .PERIOD Remember we started with a we came down to b we came down to d this has no child <sil=0.953> .PERIOD Therefore we then look at the right sub tree then again we go back up then all the sub trees of d are covered then we go to the node b go back one level up just as it would happen in recursion and then you look at the right sub tree and it has no other children <sil=0.940> .PERIOD Again this has to be traversed in pre-order therefore you do not have since it has no children e is the last symbol that will be output and then what happens all these nodes have been visited you go back to go back here and go to the right sub tree and visit this in pre-order <sil=0.996> .PERIOD So you will get c f and h I think that is what is said over here <sil=0.917> .PERIOD So pre-order traversal will give me this <sil=0.947> .PERIOD So this pre-order <sil=0.934> .PERIOD Now let us look at in order traversal what is in order traversal visit the left child recursively then root and then d right child recursively <sil=0.962> .PERIOD So what happens now I go down a go down to b visit its left child left child left child because first the first node to be displayed will be the left child then the root and then d right sub tree <sil=0.995> .PERIOD So if I keep going down what do I do I come up to d d has no left child then I display the root so I display root over here d where it is right sub tree g then I go back one level up we have b where it is right sub tree e if for example if this one had then we would again done this in in order everything has to be done in order <sil=0.979> .PERIOD Then we go back then now we display the root a we come down here again now you go to the right sub tree which has to be again traversed recursively the in order recursively in in order <sil=0.901> .PERIOD So it goes to its left child right <sil=0.980> .PERIOD So now this will get displayed because this one has no left child then it this root f h and c this is what will be displayed f if something wrong in that the instead of g there it should be h over there f h and c <sil=0.959> .PERIOD Now this is the in order traversal I encourage you to check this you need at least in order and pre order or in order and post order constructed tree uniquely <sil=0.986> .PERIOD So let us look at this particular example and see how we can get this corrected <sil=0.989> .PERIOD What we will do is the following now clearly in the pre order traversal the root is the node which is displayed first <sil=0.930> .PERIOD So now I look at this particular root node okay this thing is given wrongly so let me go with this only <sil=0.919> .PERIOD So what I will do is we know that the root node is always displayed first <sil=0.993> .PERIOD So now this must correspond to the root then what we do is we go to the in order traversal find out where that root node exists this is where the root node exists <sil=0.905> .PERIOD So what happens is in order traversal the left sub tree nodes are before the root and the right sub tree nodes are after the root <sil=0.980> .PERIOD So what do we have now we have now that d g b e correspond to the left sub tree and f h c correspond to the right sub tree <sil=0.923> .PERIOD We will left sub tree and this is right sub tree we know this information <sil=0.921> .PERIOD So I go back to the pre order traversal <sil=0.976> .PERIOD So this corresponds to these four nodes that means now I have b d g e and d g b e as the this is pre order traversal of left sub tree and this is the in order traversal of left sub tree <sil=0.985> .PERIOD Now again what do we have the first node in the pre order traversal must correspond to the root of the left sub tree <sil=0.985> .PERIOD So I mark this okay <sil=0.954> .PERIOD So what does this mean now d g here belongs to the left sub tree e belongs to the right sub tree <sil=0.977> .PERIOD So once again I mark this okay in the pre order traversal <sil=0.903> .PERIOD Now what do we have we just doing the left subtree now <sil=0.946> .PERIOD So it has d g as the pre order and we have d g also as the in order traversal okay <sil=0.909> .PERIOD So we know that d has to be root right and it is in the same order therefore this is the root that means in the in order traversal what does it mean now g is part of the right sub tree <sil=0.928> .PERIOD Therefore now we can claim what is it that we have done we had a here then we had b which was the root of the left sub tree then we had d and g which were part of the left sub tree of a okay <sil=0.915> .PERIOD So what have we done now we were essentially constructed this part of the tree <sil=0.999> .PERIOD Similarly here what do we have now if you look at the right sub tree of denoted traversal it is only e and there is only one node therefore it has to come over here <sil=0.920> .PERIOD So in much the same you can go ahead and construct the entire binary tree and now you can kind of convince you can convince yourself that given the pre order and in order traversals of a right sub tree of the right sub tree <sil=0.943> .PERIOD Given tree given binary tree the tree can be uniquely constructed okay can convince yourself about this all right I would like you to go back and see how you get constructed unique tree from do this as a homework from in order and post order okay <sil=0.930> .PERIOD Now those of you want to be more challenge can you derive a proof <sil=0.908> ?QUESTIONMARK So in order to do this you have to show that this proof can be done by construction and using induction that pre order in order will give you a unique tree okay <sil=0.930> .PERIOD So let us next what we will look at is so we have looked at the binary tree where binary tree is one where every node has two children and both the children are binary trees it may also optionally have only one child or it may absolutely have no children even an empty binary there also exists empty binary trees this is what we have already see <sil=0.926> .PERIOD Now today what I am going to talk about is I am going to talk about another type of application of binary trees called the binary search tree <sil=0.929> .PERIOD Now what is a binary search tree a binary search tree is it is also a binary tree it may be empty if it is not empty then it satisfies the following properties every node every element or node has a key and node two elements have the same key what is the meaning of it that means the keys are all unique and there is another property the keys in a non empty left subtree must be smaller than the key on the root okay <sil=0.958> .PERIOD The key in a non empty right subtree must be larger than the key at the root the left end right subtree are also binary search trees <sil=0.909> .PERIOD Now let us take an example and see how this will look like <sil=0.959> .PERIOD Let us take the same letters of the alphabet let us say I have notice that all the keys are unique let us say each one of the letters of the alphabet is a key then the key is the number this is a binary search tree <sil=0.923> .PERIOD Notice that all nodes on the left subtree have a key which is smaller than the root I am assuming lexicographic ordering here and all the nodes on the right subtree have a key which is greater than the root and that is true of every node for example if you take the node B here left subtree a smaller key values then B right subtree has larger key values then B here again smaller than G and right subtree has larger value than the given node interestingly this is also a binary tree <sil=0.962> .PERIOD And by the same token we also have that this is also a binary search tree and this is also a binary search tree <sil=0.988> .PERIOD Now what we will do is we look at the subtree so basically why is this also a binary search tree and this is also a binary search tree by definition what do we have a binary search tree has keys that are unique node out about it all the keys are unique and what did we say elements on the left subtree binary search tree can also be empty and elements of the left subtree should be smaller than the root which is smaller than the elements of the right subtree and this is true for this tree and it is also true for this tree these two trees are what we call skewed binary search trees <sil=0.974> .PERIOD What is the application of this binary search tree for example you can put the role numbers in a class in a binary search tree and search for a particular if you want to find a marks of a particular student you can find the marks of a particular student using a binary search tree <sil=0.916> .PERIOD How would I search now this corresponds to the root suppose I find out what was the marks that a obtained in this tree then I would give the key and say key is a go back let us say there is additional information along with here only given the key here marks and other things are stored it stored over here I compare a with d it does not match then clearly but a is less than d so go down the left subtree compare with b a and b again is not match but a is less than b therefore I go down it is left subtree and I find this particular node and I can retrieve all the information corresponding to the given node this is about searching the operation of search if I want to perform <sil=0.995> .PERIOD Now if I want to insert a node what happens now let us say I want to insert f okay in e g h is what I have suppose I want to insert the node f okay then I compare with the root where should it go now compare with the root then clearly it is not matched but f is larger than d so I go down the subtree then I compare with g g and f are again unmatched but clearly g is larger than f if I go down it is left subtree I compare with e e and f are again not matched but f is clearly larger than e therefore I go down here and I insert f over here okay now suppose I wanted to insert e can this be done I compare e with d again starting from the root clearly e is larger than d therefore go down the right subtree I compare with g g is larger than e therefore I go down it is left subtree I found a match but since already the binary search tree has a key e clearly I cannot insert the node e okay because the keys in a binary search tree must be unique okay this is a very very important property keys in a binary search tree must be unique this has to be satisfied now suppose I want to delete the node g so what are the operations we are looking at search we are looking at insertion we are looking at deletion this is also common right a student leaves a program and you want to delete the particular name from the list okay suppose you want to delete the particular node g then what should I replace it I should replace it with some node such that the binary search tree property is not satisfied we can do one of two things we can replace suppose I want to delete g I can replace g with either the largest node on the left subtree or the smallest node on the right subtree why do we do that because then we can guarantee that the tree will still remain to be a binary search tree so this is exactly what we do so I put f over here largest node on the left subtree so I find out so I go to the right most node on the left subtree find that and put that node over here delete it but what might happen is this node might have some left children but since clearly this in this particular case f did not have any left children but suppose f had some left children then what do I do I take these left children make it the right children of e because that is okay because all of them have to be larger than this given node okay so this is the operation of deletion so the operations on the binary search tree that we would like to perform are insertion search insertion and deletion okay so these are the three operations that we would like to perform okay here is one same example I have done it with numbers in the slide over here to show the operation of insertion notice how the now let us see how do you get these skewed binary trees basically if I start out with let us look at the insertion over here let us say I have been given 8 5 7 the keys 8 7 8 5 7 4 and 6 14 let us say 13 18 and 16 okay suppose these keys are given and we want to insert them into a binary search tree this will give us an idea how why these trees become because we are always inserting it just let us go through this example the I given a partial example in the nodes so I 8 here so I there is initially an empty tree okay so into the empty tree I insert the node 8 then next I come across the node 5 8 5 is smaller than 8 therefore I make it the left sub tree notice that again it is being inserted as the leaf node then 7 for example becomes the again you compare with 8 7 smaller than 8 greater than 5 therefore this has to become the right sub tree of this 4 compare with 8 smaller but smaller than 5 therefore 4 go over here 6 compare with 8 compare with 5 compare with 7 and then it comes over here I am going to use a little here compare 14 and 13 18 and 16 okay always what we have seen is in this process all the nodes simply get inserted at the leaf node at every stage now suppose instead giving this sequence I had given you this sequence 1 2 3 4 5 then initially there is an empty tree I insert 1 then I insert 2 right slotted in this then 3 then 4 and then 5 so this is how a binary search tree can become very cute so let us do some analysis of the complexity of this binary search tree what is the cost of search now how expensive can search me okay so clearly in the worst case what is it going to be I may have to traverse down the height of the tree now what is the height of the tree now basically you come compute the path from length of the path from root to the leaf node 1 2 3 okay all right so the worst that you have to do suppose I want to compare with 6 if I if the key that I am searching for is 6 therefore the complexity becomes the the height of this tree is 1 2 3 but after make 1 2 3 4 order height plus 1 so I have introduced a new concept today the height of the tree okay so the height of the tree is the number of comparisons plus 1 is the 2 maximum number of comparisons that you may have to perform if you want to search for a given node and this is also true for deletion right because I want to delete or insert for example I have to come down and then move back up in deletion whereas in insertion again insertion happens at the leaf therefore I have to go down to the height of the tree what can the height be in친 the worst case height what can be in the worst case the worst case what can be in the worst case in the worst case what can happen is you can have a completely is q 3 and the height can be n minus 1 <sil=0.921> .PERIOD If n is the number of nodes in the tree <sil=0.481> ,COMMA nodes then the height of the binary search tree can be as to all as n minus 1 <sil=0.918> .PERIOD So <sil=0.601> ,COMMA when you talking about order of h plus 1 comparisons in the worst case <sil=0.522> ,COMMA you have to do order n comparisons in the binary search <sil=0.995> .PERIOD So <sil=0.447> ,COMMA this kind of completes the and I have just let me give you a small implementation of insertion <sil=0.964> .PERIOD Here is a small segment of C code <sil=0.442> ,COMMA C plus C code sorry which is given here <sil=0.991> .PERIOD So <sil=0.590> ,COMMA let us say that you have a pointer to tree as we add in the half-man tree <sil=0.926> .PERIOD So <sil=0.476> ,COMMA what we are doing over here is if tree is equal to null <sil=0.383> ,COMMA then what are we doing <sil=0.914> ?QUESTIONMARK We are creating a new symbol in this particular case <sil=0.357> ,COMMA I am assuming a binary search tree which only has numbers <sil=1.000> .PERIOD Otherwise <sil=0.345> ,COMMA what am I doing <sil=0.927> ?QUESTIONMARK I am comparing if the if it is not a empty tree <sil=0.331> ,COMMA I compare with tree symbol and then what do we do <sil=0.878> ?QUESTIONMARK Be inserted if it is I go if it is smaller <sil=0.345> ,COMMA then you go to the left sub tree and then do the insertion again insertion is called recursively over here <sil=0.938> .PERIOD Similarly <sil=0.315> ,COMMA otherwise if letter is greater than v given node <sil=0.608> ,COMMA then what are we doing <sil=0.861> ?QUESTIONMARK We are inserting in the right sub tree <sil=0.945> .PERIOD Notice that we are not doing anything if the symbol is already present in the tree <sil=0.964> .PERIOD So <sil=0.409> ,COMMA this is a very important point in binary search trees <sil=0.993> .PERIOD So <sil=0.556> ,COMMA this is something that is a small segment of code over here <sil=0.589> ,COMMA a recursive implementation of the insertion into a binary search tree <sil=0.907> .PERIOD There should be a correction here <sil=0.305> ,COMMA this letter should read number <sil=0.577> ,COMMA please correct this <sil=0.540> ,COMMA it is else if number less than tree symbol <sil=0.566> ,COMMA number less greater than tree symbol <sil=0.921> .PERIOD So <sil=0.438> ,COMMA this is about binary search trees <sil=0.965> .PERIOD Hello <sil=0.576> ,COMMA welcome back all of you <sil=0.919> .PERIOD I hope you have been enjoying the lecture so far and you have been putting in some time to work on the homework exercises as well <sil=0.922> .PERIOD So <sil=0.631> ,COMMA in this lecture we are going to look at what are called structures <sil=0.971> .PERIOD So <sil=0.608> ,COMMA we looked at one kind of aggregate data type called arrays earlier and in this class we are going to look at what are called structures <sil=0.953> .PERIOD So <sil=0.621> ,COMMA structures as arrays are or a collection of one or more variables <sil=0.910> .PERIOD So <sil=0.637> ,COMMA you have one or more variables <sil=0.572> ,COMMA but as opposed to arrays structures can have different types grouped together <sil=0.979> .PERIOD So <sil=0.513> ,COMMA if you look at an array <sil=0.522> ,COMMA right it is an aggregate type of the same variable data same data type <sil=0.945> .PERIOD So <sil=0.334> ,COMMA I can have an array of integers or array of floating point numbers and so on <sil=0.902> .PERIOD Whereas <sil=0.527> ,COMMA structure lets you aggregate data which are even of different data types <sil=0.905> .PERIOD So <sil=0.462> ,COMMA let us take for example <sil=0.417> ,COMMA a point in a two dimensional plane <sil=0.485> ,COMMA a two dimensional plane will have an x coordinate and a y coordinate and you want to keep this group together because that is what a point is and one way to do that is follows <sil=0.965> .PERIOD So <sil=0.633> ,COMMA you have something called a point which we call a struct <sil=0.929> .PERIOD So <sil=0.628> ,COMMA struct is a key word in C <sil=0.949> .PERIOD We say that point is a data type which has two things some integer called x and another integer called y <sil=0.957> .PERIOD From now on point can be treated as a new data type that you created in your program <sil=0.906> .PERIOD So <sil=0.559> ,COMMA this is something that is absolutely new for your setup so far <sil=0.901> .PERIOD So <sil=0.375> ,COMMA far we have been using all the data types that are already in place like int and float and character and so on <sil=0.908> .PERIOD But for the first time we are seeing how to create your own data types <sil=0.952> .PERIOD So <sil=0.361> ,COMMA we have created a new data type called point which has x and y as two possible two members inside it <sil=0.929> .PERIOD So <sil=0.602> ,COMMA by doing this you get a mechanism for defining compound data types <sil=0.917> .PERIOD As of now you do not have a storage this is like saying I have an integer <sil=0.968> .PERIOD So <sil=0.554> ,COMMA only when you do something like int a comma int b and so on you have variables of the names a and b just by having internet you do not have a storage space <sil=0.902> .PERIOD Similarly <sil=0.432> ,COMMA when we have the basic data type called struct point you are saying that this structure is going to have two things an integer called x and an integer called y that is grouped together and this collection is useful <sil=0.990> .PERIOD Instead of looking at it as two different integers this collection is going to be for a represent it is going to be representing a point <sil=0.901> .PERIOD So <sil=0.442> ,COMMA let us look at this a point in 2d is now two integers <sil=0.978> .PERIOD There are different ways to declare structure variables <sil=0.900> .PERIOD So <sil=0.541> ,COMMA let us look at this top part because struct point int x int y and we have this braces closing it followed by point 1 and point 2 <sil=0.999> .PERIOD So <sil=0.580> ,COMMA the weight interpret this is point 1 and point 2 are two variables of the data type called struct point and the struct point data type two integers in it x and y <sil=0.936> .PERIOD So <sil=0.414> ,COMMA this is one way to do it or if you have already defined only the structure without doing declarations for the variables you can declare only this part saying that my point is a data type containing two integers you could leave it at that and then come back and say that I want two variables point 1 and point 2 they are both of the type struct point <sil=0.922> .PERIOD So <sil=0.590> ,COMMA if you look at this line it is quite similar to what we would have done for integers and floats and so on <sil=0.914> .PERIOD So <sil=0.607> ,COMMA on the left side you start with the data type and then you have a comma separated list of variable names only that the data type has this keyword struct in front of it and the name that we have assigned to the data type <sil=0.994> .PERIOD So <sil=0.405> ,COMMA at this point the storage for point 1 and point 2 are allocated <sil=0.953> .PERIOD So <sil=0.606> ,COMMA point 1 will have two integers and point 2 will also have two integers <sil=0.905> .PERIOD There is one way to initialize this that is in the last line here struct point point 1 is 3 comma 2 <sil=0.927> .PERIOD So <sil=0.419> ,COMMA at this point you are saying that point 1 is of data type struct point and since there are two members x and y the two members will get the values 3 and 2 respectively <sil=0.957> .PERIOD So <sil=0.437> ,COMMA that is one way to say that point 1 should have its x as 3 and y as 2 <sil=0.981> .PERIOD So <sil=0.547> ,COMMA this is also very similar to what we have for basic data types where we say int x equal to 5 for instance would mean you are not only declaring a variable called x you also have the storage declared for it plus the initialization of the value to 5 <sil=0.928> .PERIOD So <sil=0.470> ,COMMA let us see how to access the individual elements x and y are called members and referring to the members is done with what is called the dot operator or the period <sil=0.986> .PERIOD So <sil=0.523> ,COMMA point 1 is a variable point 1 dot x will give you the x coordinate and point 2 dot y will give you the y coordinate of point 2 and so on <sil=0.900> .PERIOD So <sil=0.613> ,COMMA let us see the small piece of code let us say I want to print point 1 on the screen <sil=0.905> .PERIOD So <sil=0.599> ,COMMA print f point 1 percentage d percentage d print point 1 dot x and point 1 dot y <sil=0.911> .PERIOD So <sil=0.307> ,COMMA this statement will look at point 1 dot x the x member of point 1 and print it as an integer and look at the y member of point 1 and print it as an integer <sil=0.989> .PERIOD So <sil=0.643> ,COMMA that is what this line does it is not just you can use them for printing <sil=0.981> .PERIOD So <sil=0.352> ,COMMA you have read the values of point 1 and point y you can also go and change the contents of point 1 you can also write to it <sil=0.951> .PERIOD So <sil=0.601> ,COMMA point 1 dot x equals 0 point 1 dot y equals minus 10 <sil=0.946> .PERIOD So <sil=0.444> ,COMMA this one changes the value that you currently have to a point called 0 comma minus 10 <sil=0.971> .PERIOD So <sil=0.448> ,COMMA it could have been something else before and now you could change it to 0 comma minus 10 <sil=0.978> .PERIOD So <sil=0.536> ,COMMA one small thing that you have to watch out for is that you cannot access point dot x and point dot y remember point is a data type point the data type does not mean that you already have storage only when you have a variable of the certain data type you are allocated storage <sil=0.998> .PERIOD So <sil=0.491> ,COMMA you can only use instances of the structures namely the variables that you have used and not the original data type itself <sil=0.947> .PERIOD So <sil=0.589> ,COMMA point 1 dot point 1 dot x is ok point dot x is not point 2 dot y is ok point dot y is not you should also know that point 1 dot x and point 2 dot x are actually two different variables they have two separate memory locations and they do not get mixed up <sil=0.943> .PERIOD So <sil=0.437> ,COMMA let us see various other examples of structures <sil=0.950> .PERIOD So <sil=0.335> ,COMMA one classical example is of a student who has a student ID and as a as an educational institution I may want to track what is the age of the student is the student male or female and what is the student C GPA and so on <sil=0.958> .PERIOD So <sil=0.354> ,COMMA this is one logical group of things I have the student ID and along with that I have an integer called age I have a character I would probably put m or f depending on whether the student is male or female and the C GPA is usually a floating point number <sil=0.983> .PERIOD So <sil=0.545> ,COMMA I am going to keep it as a double C GPA <sil=0.927> .PERIOD So <sil=0.360> ,COMMA this is a logical collection of things instead of keeping them as four separate integers if I have it as a structure <sil=0.929> .PERIOD So <sil=0.325> ,COMMA this collection has a meaning <sil=0.994> .PERIOD So <sil=0.515> ,COMMA it is all the information about a student and we call this information here student info <sil=0.948> .PERIOD Similarly <sil=0.551> ,COMMA if I am going to look at a date I have three things that make a date the day the month and the year we need all these three again I could have kept it as three separate integers <sil=0.943> .PERIOD But putting all of them as one logical unit makes sense because then I can look at is today this date or set up today's date to be this and so on instead of dealing with three separate integers which have no relation to each other <sil=0.943> .PERIOD Finally <sil=0.375> ,COMMA let us look at another example called bank account <sil=0.937> .PERIOD So <sil=0.322> ,COMMA this is a supposed to have details of a bank account I of course <sil=0.597> ,COMMA the name of the person who has the bank account in this case you have name which is a character array of 15 bytes <sil=0.937> .PERIOD So <sil=0.315> ,COMMA the name can be up to 15 bytes then there is an integer account number in this case account number is expected to be integral and the balance that you have in the account is supposed to be a double value and I may want to track the birthday of my customers and that in turn is a structure <sil=0.945> .PERIOD So <sil=0.457> ,COMMA this is what I was talking about earlier that you could actually mix and match data types of different kinds and throw them into a structure <sil=0.943> .PERIOD So <sil=0.504> ,COMMA in this one we have a character we have a character array of size 15 an integer a double and within a structure we have another structure called date or birthday <sil=0.949> .PERIOD So <sil=0.564> ,COMMA there is a member called birthday whose data type is struck date <sil=0.956> .PERIOD So <sil=0.405> ,COMMA date I already mentioned has three members <sil=0.976> .PERIOD So <sil=0.505> ,COMMA in some sense we have a nested structures here <sil=0.916> .PERIOD So <sil=0.510> ,COMMA we have a structure called structure date within the structure called bank account <sil=0.902> .PERIOD So <sil=0.392> ,COMMA this kind of nesting is really useful <sil=0.954> .PERIOD So <sil=0.649> ,COMMA let us see another example here let us say we have a rectangle and I want the rectangle to be a data type by itself but the rectangle is specified by the left bottom point and the right top point <sil=0.916> .PERIOD So <sil=0.320> ,COMMA I have two different points that define the rectangle namely the left bottom point and the right top point and rectangle itself is a data type <sil=0.989> .PERIOD So <sil=0.633> ,COMMA this is useful for example <sil=0.490> ,COMMA I want to go and draw the rectangle I will pass this structure called rectangle to the draw function <sil=0.928> .PERIOD So <sil=0.549> ,COMMA let us look at this struck rectangle <sil=0.975> .PERIOD So <sil=0.486> ,COMMA it says that we want a new data type called rectangle and this in turn consists of two members namely PT1 and PT2 <sil=0.963> .PERIOD PT1 is struck point data type and PT2 is also struck point data type and somewhere we have to remember and know that PT1 stands for left bottom corner and PT2 stands for right top corner <sil=0.964> .PERIOD Now <sil=0.648> ,COMMA if you want to access something in this next nested structure you could do this <sil=0.906> .PERIOD So <sil=0.501> ,COMMA rect1 is a variable of type rectangle you can see the declaration here the data type is in the top and rect1 is the variable of the type rectangle <sil=0.961> .PERIOD So <sil=0.643> ,COMMA rect1 <sil=0.993> .PERIOD pt1 <sil=0.914> .PERIOD x refers to the variable rect1 it has two members PT1 and PT2 and the PT1 member has x as one of its member <sil=0.908> .PERIOD So <sil=0.457> ,COMMA you are looking at member of a member and you want that to be set to 4 and rect1 <sil=0.938> .PERIOD pt1 <sil=0.960> .PERIOD y to be set to 5 <sil=0.990> .PERIOD So <sil=0.321> ,COMMA this sets up the rectangle to have the left bottom point as 4 <sil=0.495> ,COMMA 5 <sil=0.984> .PERIOD You could also do this rect1 <sil=0.979> .PERIOD pt1 is 4 <sil=0.397> ,COMMA 5 we already saw this example only that we have a nested structure case <sil=0.919> .PERIOD So <sil=0.368> ,COMMA rect1 <sil=0.969> .PERIOD pt1 the x member takes the value 4 and the y member takes the value 5 <sil=0.959> .PERIOD This notion of nested structures is really useful to construct a lot of things <sil=0.957> .PERIOD Let us do this example one more time similar nested structures <sil=0.968> .PERIOD So <sil=0.434> ,COMMA we have a struct point which has two members x and y and I have a variable p of the data type point <sil=0.972> .PERIOD Then let us say I have a struct line which takes two points <sil=0.967> .PERIOD So <sil=0.649> ,COMMA a point in two dimensional line in a two dimensional plane is defined with respect to two points and I have these two points this this this blue line here is line L and line L as p1 and p2 <sil=0.939> .PERIOD So <sil=0.499> ,COMMA this point here for line L which is p1 is x coordinate as L dot p1 dot x and the y coordinate is L dot p1 dot y <sil=0.975> .PERIOD This point here is p2 of L which x coordinate is L dot p2 dot x and its y coordinate is L dot p2 dot y <sil=0.936> .PERIOD Similarly <sil=0.430> ,COMMA I can make a triangle and I have to specify three points for it <sil=0.934> .PERIOD So <sil=0.488> ,COMMA the data type is called t <sil=0.996> .PERIOD So <sil=0.577> ,COMMA the data type is called triangle and the variable is called t <sil=0.996> .PERIOD So <sil=0.595> ,COMMA t dot p1 dot x and t dot p1 dot y is one of the corners of the triangle and there are two other corners namely p2 and p3 <sil=0.962> .PERIOD So <sil=0.312> ,COMMA let us say I want to set up a point p to have 4 <sil=0.961> .PERIOD 11 line L1 to have 2 <sil=0.928> .PERIOD 7 going to 10 <sil=0.916> .PERIOD 9 and a triangle with these three as coordinates how do we do it <sil=0.988> .PERIOD So <sil=0.588> ,COMMA this is how we do it <sil=0.975> .PERIOD We first say that there is struck point p we already have struck line L and struck triangle t <sil=0.997> .PERIOD Let us assume that these declarations are already in place declarations for p L t are in place and now we have variables p L and t <sil=0.993> .PERIOD So <sil=0.446> ,COMMA to make this point p to be 4 <sil=0.929> .PERIOD 11 we can say p <sil=0.999> .PERIOD 10 <sil=0.900> .PERIOD x is 4 and p <sil=0.946> .PERIOD y is 11 and for making the line 2 <sil=0.954> .PERIOD 7 to 10 <sil=0.946> .PERIOD 9 L dot p1 dot x is 2 and L dot p1 dot y is 7 takes care of this point L dot p2 dot x equals 10 and L dot p2 dot y equals 9 takes care of this point <sil=0.914> .PERIOD So <sil=0.454> ,COMMA we have two points and for each point we are given the x coordinate and y coordinate and finally <sil=0.625> ,COMMA for the triangle we will we need three points and for each point we give the x and y coordinate <sil=0.994> .PERIOD So <sil=0.620> ,COMMA this defining new data types is a very useful and powerful thing and sometimes it gets very tedious to say that it is struck rectangle and struck p t and so on and C programming language gives you this short cut called type dev <sil=0.931> .PERIOD So <sil=0.338> ,COMMA type dev is used to create new data types <sil=0.927> .PERIOD For example <sil=0.384> ,COMMA let us say I have an integer and the meaning that I want to attach the integer is edge <sil=0.940> .PERIOD So <sil=0.427> ,COMMA you do not want to accidentally mix it with something which is of type let us say volume or something which is of the type date and so on <sil=0.940> .PERIOD So <sil=0.495> ,COMMA this is edge and it is an integer <sil=0.969> .PERIOD If I just say it is int I could accidentally use this variable somewhere else but then now what I am going to do is I am going to say edge is type dev to be an integer <sil=0.938> .PERIOD So <sil=0.549> ,COMMA what I mean by that is wherever I see edge as a data type in turn it is actually just an integer <sil=0.917> .PERIOD Now <sil=0.304> ,COMMA if I declare edge my edge equals 99 it is clear that my edge is of edge data type and I do not want to mix it with things like volume or length and so on it is actually about edge <sil=0.965> .PERIOD So <sil=0.344> ,COMMA this combination of doing type dev is particularly useful in structures <sil=0.987> .PERIOD So <sil=0.402> ,COMMA for example <sil=0.597> ,COMMA I could we were using this struck point struck point and so on repeatedly <sil=0.990> .PERIOD Now <sil=0.376> ,COMMA I am going to use a shortcut which says type dev struck point point type <sil=0.951> .PERIOD So <sil=0.399> ,COMMA what this does is it defines a new data type called point type which is actually a struck of type point <sil=0.985> .PERIOD So <sil=0.498> ,COMMA it is a structure of type point and the nickname for that is point type <sil=0.914> .PERIOD From now on I can avoid saying struck point point 1 and so on and instead I can say point type point 1 point 2 <sil=0.965> .PERIOD So <sil=0.410> ,COMMA in the last line here you can see that this is very similar to what we do for basic variables <sil=0.987> .PERIOD We put the variables data type first and then a comma separated list right <sil=0.904> .PERIOD Only the variables data type does not have this extra thing called struck followed by the structure name <sil=0.968> .PERIOD Instead it has this nickname called point type <sil=0.989> .PERIOD So <sil=0.499> ,COMMA this is actually equivalent to writing struck point point 1 and point 2 right <sil=0.923> .PERIOD So <sil=0.541> ,COMMA it avoids typing the struck point every time <sil=0.945> .PERIOD Let us see what I meant by pointers being a replacement for arrays <sil=0.961> .PERIOD So <sil=0.573> ,COMMA let us look at the small piece of code here <sil=0.964> .PERIOD So <sil=0.578> ,COMMA we have int my array equals this <sil=0.924> .PERIOD So <sil=0.637> ,COMMA let us think about what it really is doing <sil=0.911> .PERIOD So <sil=0.573> ,COMMA int my array there is a left and right square bracket equals a list of values <sil=0.927> .PERIOD So <sil=0.475> ,COMMA what this does is it takes the set of values on the right side <sil=0.974> .PERIOD So <sil=0.463> ,COMMA we have 123 <sil=0.606> ,COMMA 17 <sil=0.505> ,COMMA 4 <sil=0.597> ,COMMA minus 500 <sil=0.940> .PERIOD There are six values <sil=0.945> .PERIOD So <sil=0.459> ,COMMA int my array is actually an array <sil=0.589> ,COMMA which can take six values <sil=0.940> .PERIOD So <sil=0.400> ,COMMA size of my array is six values <sil=0.986> .PERIOD Then we have star ptr and i <sil=0.994> .PERIOD So <sil=0.529> ,COMMA instead of explicitly saying my array should be an array of size six <sil=0.486> ,COMMA we let the compiler figure out how many values are there on the right side based on that appropriately take the size of my array <sil=0.973> .PERIOD So <sil=0.565> ,COMMA in this case the size of my array is six <sil=0.981> .PERIOD So <sil=0.642> ,COMMA following that we have star ptr and i <sil=0.956> .PERIOD So <sil=0.314> ,COMMA what we have in this line is we have two integers <sil=0.969> .PERIOD So <sil=0.436> ,COMMA sorry <sil=0.436> ,COMMA one integer called i <sil=0.329> ,COMMA one integer array called my array and one integer pointer called ptr <sil=0.999> .PERIOD So <sil=0.614> ,COMMA that is what you have in line one <sil=0.942> .PERIOD And in the next line we have ptr equals ampersand of my array of zero <sil=0.930> .PERIOD So <sil=0.437> ,COMMA ptr is now pointing at the zeroth location of my array <sil=0.987> .PERIOD You can also replace this with ptr equals my array that is also valid and it does the same thing <sil=0.976> .PERIOD So <sil=0.528> ,COMMA let us look at this loop here <sil=0.977> .PERIOD So <sil=0.491> ,COMMA print f my array of percentage d equals percentage d <sil=0.928> .PERIOD So <sil=0.347> ,COMMA it is saying that print my array of some integer equals some integer i <sil=0.564> ,COMMA my array of i <sil=0.939> .PERIOD So <sil=0.350> ,COMMA I am going to call this line a and in the next line we have contents in address ptr plus percentage d equals percentage d and for the first percentage d we give i and for the second percentage d we give star of ptr plus i as the variable to be printed <sil=0.901> .PERIOD So <sil=0.622> ,COMMA let us see what this means <sil=0.986> .PERIOD So <sil=0.521> ,COMMA in the first line it is straightforward you are printing the index of the array as well as the value contained in the index for i equals zero through five <sil=0.979> .PERIOD So <sil=0.587> ,COMMA my array has six values and it goes from zero to five and this next line contents in address ptr plus <sil=0.929> .PERIOD So <sil=0.572> ,COMMA if you see the loop it will take i will take zero one two three and so on <sil=0.948> .PERIOD You will see contents of ptr plus zero contents of ptr plus one contents of ptr plus two and so on all the way up to ptr plus five <sil=0.980> .PERIOD So <sil=0.372> ,COMMA that is what you are seeing on this and star of ptr plus i means take ptr plus i which means move it by appropriate number of locations from the base and dereference it using the star operator <sil=0.902> .PERIOD And I am going to call this line B <sil=0.923> .PERIOD So <sil=0.510> ,COMMA I will tell you quickly why I want the lines to be named A and B <sil=0.358> ,COMMA but let us take this program and run it <sil=0.900> .PERIOD So <sil=0.336> ,COMMA I have already taken this program and copied it into my editor and let me compile it and run it <sil=1.000> .PERIOD So <sil=0.529> ,COMMA let us see what is happening in the output <sil=0.931> .PERIOD So <sil=0.353> ,COMMA take some let us take some time to see what is printed in the output <sil=0.984> .PERIOD So <sil=0.600> ,COMMA the first line is my array of zero equals one contents in address ptr plus zero equals one that is what it says <sil=0.967> .PERIOD So <sil=0.315> ,COMMA let us see my array in the program <sil=0.948> .PERIOD So <sil=0.516> ,COMMA my array is one twenty three seventeen four minus five and hundred <sil=0.926> .PERIOD So <sil=0.389> ,COMMA my array of zero is indeed one and ptr plus zero which means the contents of ptr plus zero is star of ptr plus zero <sil=0.939> .PERIOD So <sil=0.302> ,COMMA ptr plus zero is ptr itself and star of ptr is pointing to one <sil=0.944> .PERIOD So <sil=0.595> ,COMMA it is printing one <sil=0.992> .PERIOD Then my array of one is twenty three and ptr plus one is supposed to point at the location one step away from ptr <sil=0.930> .PERIOD So <sil=0.424> ,COMMA remember ptr is only pointing at my array of zero <sil=0.994> .PERIOD So <sil=0.496> ,COMMA one element away from that is A of one <sil=0.992> .PERIOD So <sil=0.452> ,COMMA ptr plus one is the address of A of one and when you do star of ptr plus one you are asking for the value contained in one location of A which means you are asking for the value of A of one <sil=0.943> .PERIOD And this goes on <sil=0.953> .PERIOD So <sil=0.419> ,COMMA ptr plus five is asking for the value <sil=0.915> .PERIOD So <sil=0.526> ,COMMA star of ptr plus five will get the value which is at A of five and it happens to be hundred and that is what you see here <sil=0.948> .PERIOD So <sil=0.421> ,COMMA let us do a small change to the program and I want to show that my array is something that cannot change <sil=0.985> .PERIOD So <sil=0.558> ,COMMA let us say I do this my array plus plus <sil=0.983> .PERIOD So <sil=0.487> ,COMMA what I want my array to do is point two twenty three <sil=0.975> .PERIOD So <sil=0.565> ,COMMA I want my array of zero to be twenty three my array of one to be seventeen and so on <sil=0.986> .PERIOD Therefore <sil=0.582> ,COMMA I am trying to increment my array by one <sil=0.936> .PERIOD So <sil=0.467> ,COMMA I do not it will not point to one anymore it will it is supposed to be pointing at twenty three <sil=0.976> .PERIOD So <sil=0.449> ,COMMA let us try and compile this <sil=0.939> .PERIOD Let us try and compile that and let us look at this error that happens <sil=0.968> .PERIOD So <sil=0.611> ,COMMA in fact <sil=0.582> ,COMMA the compiler stops and points at points error at line number thirteen <sil=0.937> .PERIOD It says L value is required as increment operand <sil=0.948> .PERIOD So <sil=0.411> ,COMMA it is not a very useful error to see but many compilers for see actually give you errors that are slightly cryptic <sil=0.914> .PERIOD In this case <sil=0.388> ,COMMA what it is saying is so let us change this a little bit <sil=0.953> .PERIOD Like I said this is equivalent to saying my array is my array plus one <sil=0.966> .PERIOD So <sil=0.481> ,COMMA let us compile this you still see the same error <sil=0.951> .PERIOD So <sil=0.643> ,COMMA on the right side so it says error incompatible types when assigning to type int of six from type int star <sil=0.954> .PERIOD So <sil=0.599> ,COMMA on the right side it is doing my array plus one which means you are asking for one location away from my array and in the left side you are assigning it to my array even this is a comp it gives a compilation so based on what you write right <sil=0.935> .PERIOD So <sil=0.403> ,COMMA it is changing the error but the basic point is it is not letting you change what my array should be pointing to <sil=0.976> .PERIOD Whereas <sil=0.317> ,COMMA if I had done this let us say I did PTR right equals my array if I did that <sil=0.924> .PERIOD So <sil=0.410> ,COMMA let us look at line number 13 <sil=0.993> .PERIOD So <sil=0.462> ,COMMA if I compile it it is technically not a problem because so PTR so even in this line even this line PTR equals my array of 0 is actually equivalent to this line PTR equals my array <sil=0.978> .PERIOD So <sil=0.629> ,COMMA I said these are lines A and B let us see why this is useful <sil=0.978> .PERIOD So <sil=0.554> ,COMMA I want to use it for to illustrate something now <sil=0.906> .PERIOD So <sil=0.610> ,COMMA both plus plus PTR and PTR plus plus are actually equivalent to saying PTR plus 1 right you you are incrementing PTR by 1 though at different times <sil=0.911> .PERIOD So <sil=0.563> ,COMMA there is a difference between saying plus plus PTR and PTR plus plus plus plus PTR is called the pre increment operator <sil=0.931> .PERIOD So <sil=0.566> ,COMMA it means increment the value of PTR and then use it and PTR plus plus is post increment operator use the current value of PTR and then later increment the value of PTR <sil=0.963> .PERIOD But I wanted to do this little exercise <sil=0.906> .PERIOD So <sil=0.350> ,COMMA change the line B <sil=0.991> .PERIOD So <sil=0.584> ,COMMA if you look at line B it is saying contents in address PTR plus percentage D is i comma star of PTR plus i <sil=0.938> .PERIOD So <sil=0.423> ,COMMA change that to star PTR plus plus and run it again and once more change that line to star plus plus PTR and run it once more <sil=0.918> .PERIOD So <sil=0.409> ,COMMA you take this piece of program which is in this slide but make changes to line B using either this line or this line compile and run it and try and reason why whatever is happening why it is happening <sil=0.909> .PERIOD So <sil=0.466> ,COMMA try and reason about that so let us move forward <sil=0.947> .PERIOD There is another useful thing in C which is called the size of operator <sil=0.933> .PERIOD So <sil=0.591> ,COMMA it is not directly relevant to pointers but this is something that I want to talk about now and I can use the size of operator to explain a few things later <sil=0.916> .PERIOD So <sil=0.300> ,COMMA in this program we have three integers called in size CHR size and float size FLT size and we are going to do this <sil=0.901> .PERIOD In size is size of N <sil=0.402> ,COMMA CHR size is size of car and FLT size is size of float <sil=0.936> .PERIOD So <sil=0.450> ,COMMA as the name might indicate to you you are looking at the size of an integer or size of a character and size of a floating point and so on <sil=0.911> .PERIOD What does it mean by asking for size of an integer <sil=0.873> ?QUESTIONMARK So <sil=0.622> ,COMMA integer is so it is a set of values right integer is actually a set of values and this can be so if you look go and look at the real world the set of integers is unbounded in size <sil=0.915> .PERIOD So <sil=0.389> ,COMMA you have all the way from minus infinity to plus infinity <sil=0.909> .PERIOD It is not something that a C language supports though <sil=0.971> .PERIOD So <sil=0.406> ,COMMA you cannot store every possible integer that is out there <sil=0.927> .PERIOD C instead restricts it to be at least four bytes in size <sil=0.970> .PERIOD So <sil=0.335> ,COMMA if you say size of int it is actually giving you the number of bytes that is used to represent an integer <sil=0.905> .PERIOD Similarly <sil=0.642> ,COMMA size of character is will give you the number of bytes required to store a character and size of float is going to give you number of bytes to give you to for storing a floating point number and so on <sil=0.902> .PERIOD So <sil=0.404> ,COMMA these things can vary across different machines and so on <sil=0.917> .PERIOD But the basic point is whenever you do size of int for the machine that you are running on it will tell you how many bytes are required to store an integer <sil=1.000> .PERIOD So <sil=0.541> ,COMMA in most modern machines the size of integer is either four bytes or it can be even eight bytes <sil=0.955> .PERIOD So <sil=0.369> ,COMMA let us look at a few things related to pointer arithmetic <sil=0.943> .PERIOD So <sil=0.356> ,COMMA I am going back to pointer arithmetic <sil=0.937> .PERIOD You can do a lot of things with pointers and arithmetic related to pointers <sil=0.934> .PERIOD So <sil=0.645> ,COMMA you can assign between pointers of the same type <sil=0.932> .PERIOD You can do addition and subtraction between a pointer and an integer <sil=0.921> .PERIOD We already saw this example we did ptr plus 1 and ptr plus plus and so on <sil=0.985> .PERIOD So <sil=0.320> ,COMMA ptr was of type pointer and plus 1 is actually adding an integer 1 to ptr <sil=0.953> .PERIOD So <sil=0.589> ,COMMA however see allows you to do that <sil=0.998> .PERIOD You can compare two pointers that point to elements of the same array <sil=0.932> .PERIOD You can even subtract two pointers <sil=0.963> .PERIOD We will see a small example at the end of this module and you can assign and compare <sil=0.971> .PERIOD So <sil=0.495> ,COMMA these are several things that you can do with pointers <sil=0.913> .PERIOD Let us see each one one after the other <sil=0.925> .PERIOD The first one is increment decrement <sil=0.998> .PERIOD So <sil=0.477> ,COMMA if p is a pointer to type t <sil=0.908> .PERIOD So <sil=0.609> ,COMMA in this so there is actually no data type called t in c <sil=0.959> .PERIOD So <sil=0.606> ,COMMA I am using this as a template <sil=0.931> .PERIOD Let us say I have a data type called t and p is a pointer to t <sil=0.986> .PERIOD So <sil=0.648> ,COMMA t could be an integer character floating point could be anything <sil=0.954> .PERIOD p plus plus will increase the value of p by size of t steps <sil=0.953> .PERIOD So <sil=0.475> ,COMMA I already mentioned this <sil=0.938> .PERIOD If you say size of data type it tells you what is the number of bytes required to store the data type <sil=0.973> .PERIOD So <sil=0.643> ,COMMA when you do p plus plus it is not incrementing p to point to the next byte <sil=0.919> .PERIOD It is going to make it make p point to the next valid element of the data type t <sil=0.948> .PERIOD So <sil=0.462> ,COMMA let us say my integer is actually four bytes <sil=0.939> .PERIOD So <sil=0.559> ,COMMA I have an integer called a and let us say it is occupying four bytes <sil=0.910> .PERIOD This is not an array of size 5 <sil=0.944> .PERIOD So <sil=0.409> ,COMMA I am drawing a memory footprint and let us say variable a is stored in four bytes <sil=0.957> .PERIOD Let us say location 100 101 102 100 103 and let us say location 104 5 6 and 7 are the next set of locations <sil=0.942> .PERIOD If p tr is made to point a and if you do p tr plus plus p tr will not point 101 because the data type p tr is pointing to is integer <sil=0.947> .PERIOD The next valid integer is four steps away from 100 <sil=0.961> .PERIOD So <sil=0.566> ,COMMA p tr plus plus will make it point to the integer at location 104 <sil=0.979> .PERIOD So <sil=0.590> ,COMMA let us look go back to the slide <sil=0.985> .PERIOD So <sil=0.334> ,COMMA we have if we have data type t tab of n and if you have a declaration t star p <sil=0.970> .PERIOD So <sil=0.330> ,COMMA you can substitute t with int <sil=0.305> ,COMMA care <sil=0.576> ,COMMA float whatever you want <sil=0.948> .PERIOD So <sil=0.550> ,COMMA t itself is not a valid data type and let us say int i equals 4 <sil=0.910> .PERIOD If I do p equals ampersand of tab of i <sil=0.965> .PERIOD So <sil=0.532> ,COMMA i is 4 <sil=0.987> .PERIOD So <sil=0.570> ,COMMA ampersand of tab of 4 will make me point to the fourth entry in tab <sil=0.903> .PERIOD So <sil=0.606> ,COMMA remember the entry started 0 <sil=0.934> .PERIOD So <sil=0.382> ,COMMA we are talking about 0 <sil=0.639> ,COMMA 1 <sil=0.572> ,COMMA 2 <sil=0.415> ,COMMA 3 and 4 <sil=0.988> .PERIOD So <sil=0.517> ,COMMA the ith entry is the fourth entry starting from 0 <sil=0.942> .PERIOD So <sil=0.310> ,COMMA p is going to point at the fourth entry in tab and when you do p plus plus it actually starts pointing at the next entry in tab <sil=0.971> .PERIOD So <sil=0.362> ,COMMA this is an example of pointer arithmetic where you mix pointer and integer operations on it <sil=0.963> .PERIOD You can also do add and subtract from pointers <sil=0.903> .PERIOD You do not have to do just increment and decrement <sil=0.918> .PERIOD You can also add <sil=0.955> .PERIOD So <sil=0.343> ,COMMA in this example what we have done is we have made p point at the zeroth location of tab and we are adding phi to it which means it will start pointing to tab of phi <sil=0.999> .PERIOD It will start pointing to tab of phi <sil=0.938> .PERIOD You can compare pointers if p and q are pointers of the same <sil=0.355> ,COMMA if they are pointing to members of the same array then you can do things like equal to equal to not equal to less than and so on <sil=0.933> .PERIOD So <sil=0.521> ,COMMA let us say I have an integer array and so <sil=0.479> ,COMMA in this case I am drawing an array not memory I am drawing an array <sil=0.970> .PERIOD Let us say I have an array A and let us say this is A of 0 and this is A of 4 <sil=0.936> .PERIOD If I make p point at this location and if I make q point at this location then I can actually ask a question is p less than q <sil=0.946> .PERIOD So <sil=0.516> ,COMMA the meaning of that is is p pointing to a location that is earlier in the array than what q is pointing to <sil=0.987> .PERIOD In this case p is less than q is actually true <sil=0.926> .PERIOD So <sil=0.406> ,COMMA you can also do is p not equal to q <sil=0.984> .PERIOD So <sil=0.431> ,COMMA in this case p is actually not equal to q <sil=0.992> .PERIOD p is pointing to the zeroth location q is pointing to A of 4 <sil=0.919> .PERIOD So <sil=0.421> ,COMMA p is actually not equal to q <sil=0.910> .PERIOD So <sil=0.363> ,COMMA you can meaningfully compare pointers which are pointing to the same array <sil=0.965> .PERIOD You can ask is this the same is this earlier than the other pointer is it later than the other pointer and so on <sil=0.911> .PERIOD So <sil=0.447> ,COMMA you can make pointers point at different locations in an array <sil=0.967> .PERIOD You can ask questions whether one pointer is lesser than the other and so on <sil=0.928> .PERIOD And you can also compare it for inequality is 0 <sil=0.942> .PERIOD So <sil=0.427> ,COMMA you can ask a question is p equal to null <sil=0.914> .PERIOD So <sil=0.447> ,COMMA let us say p is pointing to A of 0 and I can ask a question if p equal to equal to null <sil=0.912> .PERIOD If I ask this question this will actually evaluate to false because p is actually pointing to A of 0 <sil=0.938> .PERIOD So <sil=0.559> ,COMMA you can do comparisons of this kind <sil=0.994> .PERIOD So <sil=0.491> ,COMMA we looked at increment decrement and adding an integer or subtracting an integer from a pointer <sil=0.925> .PERIOD One final beautiful thing about pointers is that you can also do subtraction of pointers <sil=0.927> .PERIOD So <sil=0.536> ,COMMA there is a small piece of code here which actually tries to show that <sil=0.906> .PERIOD So <sil=0.521> ,COMMA it is this one is slightly loaded but let us see what it is doing <sil=0.921> .PERIOD So <sil=0.525> ,COMMA there are two pointers here one called s and one called p and this is actually a function which is called string length strln <sil=0.906> .PERIOD So <sil=0.432> ,COMMA given a string it tries to find out what is the length of the string <sil=0.997> .PERIOD So <sil=0.485> ,COMMA let us see what a string is in c <sil=0.915> .PERIOD I will anyway do this in more detail later but a string in c is actually just a sequence of characters followed by a special character called backslash 0 <sil=0.926> .PERIOD So <sil=0.545> ,COMMA for instance let us say I have a string called hello it will be stored in this form <sil=0.992> .PERIOD You have hech elol so this is letter o and on top of that in c there is a special character called backslash 0 <sil=0.909> .PERIOD So <sil=0.450> ,COMMA in this case it is actually 0 or what is called the null character <sil=0.949> .PERIOD So <sil=0.554> ,COMMA a string called hello it is supposed to be of length 5 but in reality it actually takes 6 bytes <sil=0.927> .PERIOD So <sil=0.463> ,COMMA let us say I want to find out what is the length of this string <sil=0.958> .PERIOD So <sil=0.395> ,COMMA I can keep checking starting from the zeroth location of this string <sil=0.955> .PERIOD I can keep checking for one character after the other and I will look for the special character called backslash 0 <sil=0.980> .PERIOD The moment I see a backslash 0 it means that this is the end of the string and this is a convention used in c <sil=0.948> .PERIOD So <sil=0.536> ,COMMA like I said a wheel again see this in more detail later but as of now let us look at this example <sil=0.937> .PERIOD So <sil=0.645> ,COMMA let us say I want to find out what the length of the string is <sil=0.972> .PERIOD So <sil=0.422> ,COMMA I have written a small function which does that <sil=0.917> .PERIOD So <sil=0.434> ,COMMA character star s and character star p <sil=0.961> .PERIOD So <sil=0.593> ,COMMA at this point p is initialized to s <sil=0.965> .PERIOD So <sil=0.421> ,COMMA s is supposed to be a character array <sil=0.957> .PERIOD So <sil=0.351> ,COMMA s is a pointer to a character array that is what you see here <sil=0.933> .PERIOD So <sil=0.323> ,COMMA s is pointing to a character array and character star p equals s <sil=0.923> .PERIOD So <sil=0.580> ,COMMA p also points at the zeroth location of s <sil=0.941> .PERIOD So <sil=0.534> ,COMMA s is the string for which we want to find out the length <sil=0.949> .PERIOD So <sil=0.630> ,COMMA there is a while loop here that keeps checking if the contents of the memory location pointed by p is it backslash 0 or not <sil=0.993> .PERIOD So <sil=0.529> ,COMMA there is a special character backslash 0 <sil=0.979> .PERIOD I am going to start from location h <sil=0.928> .PERIOD So <sil=0.347> ,COMMA where h is stored all the way till I see a backslash 0 <sil=0.974> .PERIOD So <sil=0.494> ,COMMA initially p is pointing at h and star p is not equal to backslash 0 <sil=0.985> .PERIOD We do a p plus plus <sil=0.945> .PERIOD So <sil=0.351> ,COMMA p will start pointing here <sil=0.948> .PERIOD So <sil=0.481> ,COMMA p is already moved by location <sil=0.396> ,COMMA moved by one location <sil=0.904> .PERIOD It has started pointing at s of 1 <sil=0.908> .PERIOD s of 1 is e and it is not backslash 0 <sil=0.903> .PERIOD So <sil=0.521> ,COMMA the while loop will continue will start pointing at l and this will keep happening and it will stop when p points at backslash 0 <sil=0.962> .PERIOD So <sil=0.327> ,COMMA let us assume that this is at location 100 <sil=0.435> ,COMMA this is at 101 and so on <sil=0.998> .PERIOD This will be at location 105 <sil=0.983> .PERIOD So <sil=0.511> ,COMMA when the while loop stops <sil=0.445> ,COMMA the while loop will stop when star p is equal to 0 <sil=0.977> .PERIOD When this star p equal to 0 <sil=0.421> ,COMMA when p is 105 star p is backslash 0 and which means when p equals 105 the loop will stop <sil=0.942> .PERIOD So <sil=0.420> ,COMMA at that point if you go and ask for p minus s <sil=0.924> .PERIOD So <sil=0.636> ,COMMA p is 105 and s is memory location 100 <sil=0.315> ,COMMA 105 minus 100 is 5 that actually gives us the correct length of hello <sil=0.948> .PERIOD So <sil=0.527> ,COMMA this is a very neat and beautiful trick to show with the pointer arithmetic <sil=0.980> .PERIOD So <sil=0.495> ,COMMA let us not worry about what this return statement is and what is this strange looking in test here L E and so on is later <sil=0.943> .PERIOD But as of now <sil=0.365> ,COMMA I just wanted to pay attention to the while loop <sil=0.948> .PERIOD So <sil=0.416> ,COMMA it iterated over the elements of s and it stopped at backslash 0 at that point p got value 105 and if you do p minus s that actually gives you 105 minus 100 which is so <sil=0.410> ,COMMA when you do arithmetic over pointers if you do subtraction of pointers you actually get an integer back and this is something that is very handy <sil=0.970> .PERIOD We will see cases for use cases for this in a lot more detail later <sil=1.000> .PERIOD So <sil=0.343> ,COMMA we have now come to the end of this module <sil=0.902> .PERIOD In the subsequent modules <sil=0.619> ,COMMA we will see how to use pointers for manipulating arrays and we will also see how pointers are useful in the context of what are called functions <sil=0.929> .PERIOD So <sil=0.559> ,COMMA we will start looking at functions and when we visit functions we will revisit how pointers are handled when we pass them on to functions <sil=0.915> .PERIOD Thank you very much <sil=0.967> .PERIOD Welcome to this last module for this course <sil=0.923> .PERIOD We are going to do two things in this week's videos <sil=0.942> .PERIOD One is about file input and output that will be the first part and later we will also learn something about structured programming <sil=0.943> .PERIOD So <sil=0.364> ,COMMA let us let me give you a little bit of motivation for the lecture itself on file IO <sil=0.925> .PERIOD So <sil=0.499> ,COMMA it is not reasonable to expect a user to always give inputs from the keyboard or always just print things on the screen <sil=0.900> .PERIOD There are several places and instances where you want something recorded and you want it to be reused later and this is a place where files come into picture <sil=0.905> .PERIOD It is not the notion of files is probably not alien to you <sil=0.966> .PERIOD So <sil=0.544> ,COMMA what we will do in this lecture is we will try and learn what a file is and how to perform input and output operations on a file <sil=0.958> .PERIOD We will also see how to write programs that will read from or write to files and we will learn one another topic about command line arguments <sil=0.922> .PERIOD So <sil=0.337> ,COMMA that will be the first video for this week <sil=0.966> .PERIOD So <sil=0.402> ,COMMA let us look at the notion of a stream <sil=0.985> .PERIOD When we look at files things like MP3 files <sil=0.462> ,COMMA video files <sil=0.406> ,COMMA document files or even HTML pages that you download or all files they have all been created somewhere they enable you to transmit information from one place to the other save it <sil=0.607> ,COMMA retrieve it and so on and without files we cannot do any of those <sil=0.980> .PERIOD So <sil=0.374> ,COMMA if you expect a user to always give inputs over a keyboard that is not always good <sil=0.943> .PERIOD Sometimes the input is not even coming from the keyboard it could be coming from some other device <sil=0.948> .PERIOD So <sil=0.508> ,COMMA the notion of a file let you both store and retrieve information and in this context we will use this notion called a stream <sil=0.964> .PERIOD A stream is essentially a flow of input or output data <sil=0.994> .PERIOD These could be anything these could be characters <sil=0.637> ,COMMA bytes <sil=0.373> ,COMMA numbers anything that you send from one program to another program or one from one device to another device and so on <sil=0.977> .PERIOD So <sil=0.421> ,COMMA let us look at this basic example <sil=0.968> .PERIOD So <sil=0.416> ,COMMA let us say I write a program and what we have been doing is we have always been taking inputs from the keyboard whatever I do demonstration of I take inputs from the keyboard and the output was always on the screen <sil=0.962> .PERIOD And when you did your programming exercises online <sil=0.642> ,COMMA this input itself was not from a keyboard you had saved something and it got saved into a file but the output was still on your screen <sil=0.927> .PERIOD There are other places for example <sil=0.613> ,COMMA let us say my program is actually an MP3 player or a CD player <sil=0.927> .PERIOD The input is going to come from a compact disk and the output is probably a speaker or the input stream is coming from a compact disk and let us say you take a wave file and make MP3 out of it <sil=0.932> .PERIOD So <sil=0.364> ,COMMA the input is from your CD you are ripping a CD and you are writing to a disk which is the hard disk <sil=0.958> .PERIOD So <sil=0.524> ,COMMA we need to be able to not just interact with keyboard and monitor alone <sil=0.471> ,COMMA we need to be able to interact with other devices also <sil=0.951> .PERIOD At the same time we do not want to be bogged down by all the details of these devices and so on and that is where the notion of file IOs come in <sil=0.901> .PERIOD So <sil=0.552> ,COMMA see basically has no direct support for input and output <sil=0.961> .PERIOD Instead it is supplied through a library and we have seen this so far the header file that we have been including called a CDIO <sil=0.942> .PERIOD H is essentially that <sil=0.994> .PERIOD So <sil=0.597> ,COMMA it has several functions that will enable you to do input and output <sil=0.991> .PERIOD You do not have to really remember all of them but it is good to know that all the functions that you need for input and output are actually in this file are all in this header called a CDIO <sil=0.973> .PERIOD H <sil=0.990> .PERIOD So <sil=0.414> ,COMMA let us now concentrate on what C gives us <sil=0.961> .PERIOD So <sil=0.650> ,COMMA every C program is automatically associated with three standard streams <sil=0.903> .PERIOD So <sil=0.411> ,COMMA that is how you will see the prefix called STD in STD for it <sil=0.998> .PERIOD So <sil=0.310> ,COMMA there are three standard streams STD in STD out and STD R <sil=0.908> .PERIOD So <sil=0.383> ,COMMA STD in is for input stream <sil=0.573> ,COMMA STD out is for output stream or anything that gets written from the program and STD R is for printing any errors and it is usually associated with the screen itself <sil=0.991> .PERIOD So <sil=0.393> ,COMMA STD in is usually associated with keyboard STD out is usually associated with the screen and STD R is also usually associated with the screen <sil=0.992> .PERIOD And whenever we did things like scan up and get car and so on <sil=0.316> ,COMMA we were actually reading from the keyboard <sil=0.947> .PERIOD So <sil=0.411> ,COMMA that is your standard stream <sil=0.913> .PERIOD So <sil=0.469> ,COMMA you do not have to do anything especially and output was always written to the screen also <sil=0.906> .PERIOD So <sil=0.476> ,COMMA with print up we did not bother what to do with it because we know that the default stream is anyway STD out which is connected to the monitor <sil=0.960> .PERIOD But when you have files that you want to deal with on your own <sil=0.363> ,COMMA it is not the case anymore <sil=0.928> .PERIOD So <sil=0.487> ,COMMA even though STD in out an error automatically connected <sil=0.346> ,COMMA if you want to do anything more with other files <sil=0.550> ,COMMA if you want streams from other places you need to do something more <sil=0.974> .PERIOD So <sil=0.341> ,COMMA reading and writing a file in C requires three basic steps <sil=0.904> .PERIOD You need to be able to open a file you need to be able to do all the reading or writing that goes with it and finally <sil=0.566> ,COMMA you should close the file <sil=0.952> .PERIOD And instead of dealing with file names explicitly in our programs <sil=0.486> ,COMMA we will deal with what are called file pointers <sil=0.954> .PERIOD So <sil=0.649> ,COMMA file pointers essentially a pointer to a structure that contains a lot of information about the file <sil=0.995> .PERIOD Again <sil=0.468> ,COMMA we do not have to know a lot of details about what is in the structure <sil=0.922> .PERIOD But just remember that we will deal with file pointers and not file names directly <sil=0.974> .PERIOD So <sil=0.389> ,COMMA let us start with the first step namely opening a file <sil=0.982> .PERIOD So <sil=0.639> ,COMMA if I want a programmatic way to open a file <sil=0.905> .PERIOD So <sil=0.452> ,COMMA it is not about clicking on a screen and opening a file <sil=0.980> .PERIOD So <sil=0.330> ,COMMA I want my program to be able to open a file and do some operations on it <sil=0.910> .PERIOD So <sil=0.310> ,COMMA to do that <sil=0.587> ,COMMA you declare a file pointer and you open a file using this function called F open <sil=0.963> .PERIOD So <sil=0.585> ,COMMA file pointer is declared with as you see in the second bullet here <sil=0.419> ,COMMA file star F p <sil=0.943> .PERIOD So <sil=0.401> ,COMMA F p <sil=0.552> ,COMMA star F p is indicates that it is a pointer and to what is it pointing <sil=0.883> ?QUESTIONMARK It is pointing to a structure called file <sil=0.967> .PERIOD So <sil=0.446> ,COMMA F p is a pointer to the data type structure and many times we will drop this thing called structure and we will just say that F p is a file pointer <sil=0.984> .PERIOD So <sil=0.336> ,COMMA we have a file pointer now and we can do F p equals F open of name comma mode <sil=0.987> .PERIOD So <sil=0.440> ,COMMA the name should be the name of the file that you are trying to open and mode can be one of the three things <sil=0.970> .PERIOD So <sil=0.582> ,COMMA let us see this example F p is F open of data dot text comma R <sil=0.960> .PERIOD So <sil=0.402> ,COMMA if you say R it is supposed to be in read only mode <sil=0.930> .PERIOD We are trying to open the file data dot text in read only mode which means you do not want to write anything from your program <sil=0.996> .PERIOD You want to only read contents of the file data dot text <sil=0.909> .PERIOD So <sil=0.434> ,COMMA one can notice that both the file name and the mode are actually put within double codes <sil=0.928> .PERIOD So <sil=0.391> ,COMMA F open expects two strings <sil=0.598> ,COMMA one string which is the name of the file and another string which is the mode itself <sil=0.918> .PERIOD So <sil=0.399> ,COMMA let us look at the other modes of opening a file <sil=0.993> .PERIOD So <sil=0.501> ,COMMA R I already mentioned in the previous slide <sil=0.980> .PERIOD W is the other mode in which you open the file but only for writing which means from your program you can only write to it you cannot go and read what is in the file <sil=0.935> .PERIOD So <sil=0.313> ,COMMA that is called write mode and A which is called the append mode <sil=0.979> .PERIOD So <sil=0.584> ,COMMA let us look at the distinction between among these three modes R means it will try and open an existing file <sil=0.960> .PERIOD So <sil=0.628> ,COMMA clearly what if I try to open a file that is not even existent we need to be we need to be able to capture this <sil=0.909> .PERIOD So <sil=0.408> ,COMMA let us say I am going to open a file but there is no file by that name <sil=0.955> .PERIOD If that happens we need a mechanism which says there is no file by that name <sil=0.986> .PERIOD So <sil=0.477> ,COMMA that is an issue that we have to deal with for R <sil=0.985> .PERIOD For W you are trying to write to a file you are not going to write read it from there at least in this program as of now <sil=0.973> .PERIOD So <sil=0.475> ,COMMA if the file already exist and since you are only writing the previous contents of the files does not matter you can as well remove all the contents and start with zero length <sil=0.946> .PERIOD So <sil=0.407> ,COMMA since you are only writing from the current program if you by mistake open an existing file the previous contents will all be deleted <sil=0.944> .PERIOD But normally you would expect your program to create a new file <sil=0.930> .PERIOD So <sil=0.509> ,COMMA if it is a new file and since you are writing it will automatically create a new file with the name that you have suggested <sil=0.927> .PERIOD A stands for append <sil=0.533> ,COMMA append means add at the end and this is as the name indicates it is useful for writing only at the end of the file <sil=0.956> .PERIOD So <sil=0.570> ,COMMA clearly this is similar to write it has some similarity with the write <sil=0.960> .PERIOD If the file already exists the initial contents how are unchanged however if the file is not there append is as good as actually opening with a W mode only that all the writes will always happen to the end of the file <sil=0.934> .PERIOD So <sil=0.406> ,COMMA these are the three modes let us now look at how to open a file <sil=0.983> .PERIOD So <sil=0.492> ,COMMA we have Fptr1 which says F open my data comma R we are trying to open a file called my data in read only mode and Fptr1 should be file star Fptr1 <sil=0.949> .PERIOD In this example Fptr2 is F open results comma W we are trying to write something into results file and so both of these once they are open you have essentially it is like opening a gate through which a stream can flow <sil=0.973> .PERIOD So <sil=0.351> ,COMMA once you open a file you can now start reading and writing so you can either read from the stream or you can write to the stream and these files will remain open until you explicitly close them <sil=0.955> .PERIOD So <sil=0.382> ,COMMA if you do not explicitly close them the files will remain open till the end of the program <sil=0.944> .PERIOD So <sil=0.440> ,COMMA let us look at how do you test for successful open I mentioned this as a problem right <sil=0.977> .PERIOD So <sil=0.318> ,COMMA I try to read a file and the file is not existent what do I do now <sil=0.971> .PERIOD So <sil=0.333> ,COMMA let us see this example file star Fptr1 and you try to open my data <sil=0.962> .PERIOD So <sil=0.463> ,COMMA it will try and open it from the directory in which the program is running from and if the file does not exist Fptr1 will be supplied with the value called null <sil=0.993> .PERIOD So <sil=0.390> ,COMMA if F open fails it will return null however <sil=0.620> ,COMMA if F open succeeds will be a valid pointer <sil=0.913> .PERIOD So <sil=0.571> ,COMMA you can use this information and go and check if Fptr1 is null or not <sil=0.902> .PERIOD If it is null you know that the file open fail for whatever reason maybe the file was not there that is the most common reason it failed and you can say that file my my data did not open and you have to tell the user to input another file name or some such thing <sil=0.919> .PERIOD So <sil=0.450> ,COMMA unsuccessful open for read is a problem because you cannot proceed from there if the file is not even there <sil=0.944> .PERIOD Whereas <sil=0.375> ,COMMA for write F open may not work because you do not have enough space in your disk and so on <sil=0.947> .PERIOD So <sil=0.441> ,COMMA there could be other reasons why F open may fail if you open it in write mode <sil=0.998> .PERIOD So <sil=0.302> ,COMMA now let us look at the second step <sil=0.967> .PERIOD So <sil=0.356> ,COMMA we said we will open the file now we know how to check the error if the file cannot open <sil=0.991> .PERIOD Let us look at the second step reading from the files <sil=0.944> .PERIOD So <sil=0.340> ,COMMA second step is either reading or writing let us start with reading <sil=0.903> .PERIOD So <sil=0.516> ,COMMA int a comma b these are two integers and we have a pointer Fptr1 which is of type file star <sil=0.975> .PERIOD Let us look at this line here <sil=0.928> .PERIOD We have opened the file in this example there is no check on whether Fptr1 is null or not <sil=0.939> .PERIOD But let us see how to read two integers from the file <sil=0.936> .PERIOD Let us assume that Fptr1 has two integers or the file my data has two integers saved in it <sil=0.914> .PERIOD So <sil=0.455> ,COMMA this line here is trying to do a scan and you can see some similarity with scan of that you have seen before <sil=0.990> .PERIOD We have been using this all along <sil=0.980> .PERIOD So <sil=0.556> ,COMMA let us look at this <sil=0.969> .PERIOD So <sil=0.571> ,COMMA it is similar to scan of except that there seems to be three different sets of parameters <sil=0.937> .PERIOD So <sil=0.590> ,COMMA this is the format that you give to F scan of <sil=0.914> .PERIOD So <sil=0.578> ,COMMA this is the format in which you are going to read <sil=0.961> .PERIOD This is the set of pointers that we are passing <sil=0.952> .PERIOD So <sil=0.583> ,COMMA this is very similar to scan of except that you also pass the file pointer Fptr1 <sil=0.953> .PERIOD So <sil=0.542> ,COMMA F scan of takes three parameters one which is the file pointer two which is the format three which is a set of variables in which you have to read <sil=0.946> .PERIOD So <sil=0.448> ,COMMA in scan of all we have done is we got rid of the Fptr1 because scan of by default always reads from STD in <sil=0.961> .PERIOD So <sil=0.346> ,COMMA F scan of once this is over it would have read two integers from the file my data <sil=0.987> .PERIOD So <sil=0.599> ,COMMA when you read a file you could be writing a loop to read one line after the other <sil=0.911> .PERIOD Let us say I have a file in which I have ten lines of two integers each <sil=0.909> .PERIOD I keep reading at some point I have to find out that I have reached the end of the file because once I reach the end of the file for the program there is probably no processing to do anymore <sil=0.927> .PERIOD So <sil=0.483> ,COMMA it has processed the file and maybe all the work that needs to be done is already done <sil=0.974> .PERIOD So <sil=0.347> ,COMMA there could be some other file in which there are thirty lines <sil=0.334> ,COMMA another file in which there are hundred lines and so on <sil=0.970> .PERIOD You need a mechanism by which you do not have to know the number of lines in the file for your program to operate <sil=0.949> .PERIOD So <sil=0.473> ,COMMA you keep processing one line after the other and at some point you realize that you have to find out that you have reached the end of the file and that is done by C using this function called FeoF <sil=0.996> .PERIOD So <sil=0.367> ,COMMA if you do a scan of and let us say you are expecting something from the input stream and if you have already reached the end of the file then if you check on this thing FeoF of FPTR1 <sil=0.963> .PERIOD So <sil=0.537> ,COMMA this EoF stands for end of file <sil=0.905> .PERIOD So <sil=0.553> ,COMMA in your file stream if you have reached the end of file of the pointer FPTR1 it means that whatever that file that you are reading using FPTR1 you have reached that end of the file there is no more processing to do <sil=0.971> .PERIOD So <sil=0.557> ,COMMA this is one way to find out if you have reached the end of the file <sil=0.919> .PERIOD There is also another way in which you can check whether you have reached the end of the file <sil=0.995> .PERIOD You keep reading one line at a time at some point if you reach the end of the file let us say you do this F scan F FPTR1 percentage D ampersand var that is exactly what we had earlier we do a scan F <sil=0.982> .PERIOD Interestingly scan F also returns an return value <sil=0.903> .PERIOD So <sil=0.556> ,COMMA we never bothered checking the return of scan F but F scan F returns a value which can be used to check whether you have reached the end of input stream or not <sil=0.954> .PERIOD So <sil=0.447> ,COMMA there is a special character called special value called EoF <sil=0.919> .PERIOD So <sil=0.360> ,COMMA this capital E capital O capital F <sil=0.922> .PERIOD So <sil=0.491> ,COMMA that is a special value if F scan F returns this special value then it means there was some problem in scanning which <sil=0.998> .PERIOD So <sil=0.643> ,COMMA it actually indicates that you have reached the end of the file <sil=0.970> .PERIOD Otherwise F scan F would return a value which is not EoF <sil=0.980> .PERIOD So <sil=0.332> ,COMMA if F scan F returns EoF you know that you have reached the end of the file <sil=0.942> .PERIOD So <sil=0.465> ,COMMA either you call F EoF of FPTR1 or you call you copy the value return value from F scan F and you check against EoF and it will tell you that the end of file has encoder has been encoder <sil=0.907> .PERIOD So <sil=0.619> ,COMMA that is one of the things that you can do in the second step <sil=0.995> .PERIOD The other thing that you can do is you can actually go and write to files <sil=0.918> .PERIOD So <sil=0.426> ,COMMA for example <sil=0.410> ,COMMA if you look at this code as you can expect this is a variation of print F <sil=0.901> .PERIOD So <sil=0.502> ,COMMA as before we have two integers and we have a file pointer called FPTR2 we open the results file in write mode which means if the file exists it will overwrite it if it does not exist it opens a new file with the name results and now this F print F is similar to print F <sil=0.981> .PERIOD So <sil=0.409> ,COMMA you have the format specifier you have the parameters that are supposed to be printed but you also pass the file pointer as the first parameter <sil=0.922> .PERIOD So <sil=0.412> ,COMMA this line will actually write a comma b the values a comma b into the file pointed by FPTR2 and you keep writing and it will keep writing one line after the other till the when you can so you can stop writing <sil=0.978> .PERIOD So <sil=0.404> ,COMMA for example <sil=0.453> ,COMMA if you have another F print F FPTR2 percentage D percentage D backslash N let us say 5 comma 10 right <sil=0.988> .PERIOD So <sil=0.324> ,COMMA that will write one line of 5 comma 20 and another line would be 5 comma 10 you will see two lines in your file <sil=0.938> .PERIOD The third and final step having file I have done is closing the file <sil=0.963> .PERIOD So <sil=0.305> ,COMMA F close of FPTR1 and F close of FPTR2 will close the file associated with the stream FPTR1 and FPTR2 <sil=0.970> .PERIOD So <sil=0.319> ,COMMA and whatever extra work that it has been doing it will release all of that back to the system <sil=0.994> .PERIOD So <sil=0.568> ,COMMA it is important that you actually close the files because if you have actually open a reading stream maybe it is not that big an issue but if you have if you have been writing to a file and if you did not close you can run into problems <sil=0.900> .PERIOD So <sil=0.570> ,COMMA closing a file is important because usually output is buffered <sil=0.987> .PERIOD So <sil=0.398> ,COMMA what what we mean by that is let us say I want to print F to a screen I want to do print F it may not appear in the screen immediately right <sil=0.935> .PERIOD So <sil=0.558> ,COMMA what can happen is whatever is supposed to be written could get written to the buffer and eventually the buffer gets flushed to the actual device <sil=0.938> .PERIOD So <sil=0.318> ,COMMA the flushing could be to the hard disk or the flushing could be to your monitor and so on <sil=0.970> .PERIOD So <sil=0.444> ,COMMA the best example that I can give is if you use USB sticks many times they tell you to remove the USB sticks especially if you have written something on a USB memory drive they ask you to eject it carefully right <sil=0.949> .PERIOD So <sil=0.594> ,COMMA you would go in click on something and you would say safely remove the device and so on right <sil=0.971> .PERIOD If you have wondered what you have been doing what it actually does is when you remove the if you have written anything to the anything anything to a device it is possible that the actual entries have not been written the actual bits and bytes have not been written they are still in a buffer sitting in the RAM and only when you ask the system to be flushed then there will be a commit to the device <sil=0.908> .PERIOD So <sil=0.643> ,COMMA this happens for various reasons which we cannot get into now <sil=0.584> ,COMMA but if that buffering happened and if you plugged out a USB memory stick your USB memory stick is not guaranteed to have all the data <sil=0.951> .PERIOD However <sil=0.409> ,COMMA if you go through your operating system and say safely eject the device it will flush all the buffers to your device and then you can remove it <sil=0.946> .PERIOD So <sil=0.325> ,COMMA F close essentially forces all the buffers to be flushed and the device the all the contents that you wrote from the program is guaranteed to be written into the file <sil=0.949> .PERIOD So <sil=0.576> ,COMMA there are several other modes that you can use <sil=0.978> .PERIOD So <sil=0.553> ,COMMA there is a mode called R plus there is a mode called W plus and another called A plus <sil=0.920> .PERIOD So <sil=0.394> ,COMMA the plus indicates something <sil=0.935> .PERIOD So <sil=0.348> ,COMMA this is the reason why we have been passing it as a string it is not just one character at times may have to pass more than one character <sil=0.906> .PERIOD So <sil=0.421> ,COMMA in this case R plus W plus R A plus <sil=0.932> .PERIOD So <sil=0.635> ,COMMA R plus is it indicates that you want to be able to read <sil=0.493> ,COMMA but you want something more from this mode <sil=0.947> .PERIOD So <sil=0.413> ,COMMA you open an existing file for both reading and writing because this is also something that you may need once in a while <sil=0.961> .PERIOD So <sil=0.575> ,COMMA what happens is because you are opening in R it will not delete the file it will not delete the contents the initial contents of the file are unchanged and the initial position at which you can start doing your operations will be at the beginning of the file <sil=0.915> .PERIOD So <sil=0.622> ,COMMA if you want to overwrite only part of the file right you can use R plus you open it with R and R plus and you can start writing overwriting from the top and you can stop at some point instead of deleting all the contents <sil=0.908> .PERIOD W plus is also in some sense similar to what you are doing in R plus <sil=0.386> ,COMMA but there is a key difference <sil=0.937> .PERIOD So <sil=0.515> ,COMMA both of them open a file for both reading and writing <sil=0.486> ,COMMA but W plus being this notion that you destroy the file when you open something in W mode it does exactly that <sil=0.959> .PERIOD If the file already exists it is truncated to 0 length otherwise the new file is created and on this you will be able to do both reading and writing <sil=0.948> .PERIOD Finally <sil=0.405> ,COMMA A plus is distinct from W plus it this also opens the file for both reading and writing <sil=0.545> ,COMMA but if the file exists its initial contents are unchanged in that sense it is similar to R plus otherwise it will create a new file in that sense it is similar to W plus <sil=0.947> .PERIOD So <sil=0.427> ,COMMA these are three other modes in which you can open a file <sil=0.978> .PERIOD So <sil=0.336> ,COMMA what we will do now is we will do a quick I will show you a quick demo of file IO I have written some small programs to show you file IO <sil=0.966> .PERIOD So <sil=0.502> ,COMMA there is this file called file 1 <sil=0.951> .PERIOD c in which I have done something <sil=0.989> .PERIOD So <sil=0.523> ,COMMA I am going to open a file called my <sil=0.956> .PERIOD 1 <sil=0.468> .PERIOD text in read only mode and this file is expected to have a bunch of integers and what I am going to do is I am going to sort the numbers which are in the file and I am going to write it to this file called sortin <sil=0.982> .PERIOD text <sil=0.926> .PERIOD So <sil=0.391> ,COMMA I am going to do three things open a file called my <sil=0.922> .PERIOD 1 <sil=0.576> .PERIOD text into an array sort the array in your program and write the sorted results to your another file called sortin <sil=0.979> .PERIOD text that is what this program achieves let us see how this is done <sil=0.990> .PERIOD So <sil=0.560> ,COMMA there are two file pointers FP1 and FP2 <sil=0.921> .PERIOD FP1 opens my <sil=0.947> .PERIOD 1 <sil=0.406> .PERIOD text in read only mode and I also assume that the number of entries in the file is not more than 10 <sil=0.977> .PERIOD So <sil=0.561> ,COMMA I assume that at most 10 integers are stored and nothing more <sil=0.994> .PERIOD So <sil=0.500> ,COMMA what I have done is I have declared an array called A of 10 in size which means it can store up to 10 integers and look at this line line 21 through 24 if you will sorry 24 if you look at it while F scan F of FP1 percentage D ampersand temp <sil=0.959> .PERIOD What does F scan up do <sil=0.983> ?QUESTIONMARK Given a file pointer it will try and use the format and read from the input stream in this case from my <sil=0.978> .PERIOD 1 into this variable called temp <sil=0.993> .PERIOD So <sil=0.472> ,COMMA when you read it is possible that you have 10 integers but at some point you will hit the end of the file right <sil=0.927> .PERIOD So <sil=0.304> ,COMMA F scan F you go and check it will do this work F scan FP1 percentage D ampersand temp <sil=0.932> .PERIOD So <sil=0.600> ,COMMA this line actually reads <sil=0.359> ,COMMA tries and reads from a file but if it is unsuccessful and if it returns EOF the while loop will terminate otherwise it keeps reading the contents into A and as long as there is 10 or less lines A will not be overrun it will have 10 entry so up to 10 integers from this file my <sil=0.965> .PERIOD 1 is ok <sil=0.977> .PERIOD Then I am calling this function short numbs A comma C and T <sil=0.926> .PERIOD I will not worry about short numbs now <sil=0.943> .PERIOD So <sil=0.620> ,COMMA I have written a small program small piece of code which does insertion short <sil=0.946> .PERIOD So <sil=0.379> ,COMMA I will not worry about that I will assume that A gets sorted and I am going to write things to a file and how do I do it <sil=0.944> ?QUESTIONMARK I open FP2 which is opening the sorted <sil=0.941> .PERIOD text in W mode if FP2 is null it cannot file the open for writing otherwise you do F print of FP2 percentage D A of I it takes 1 A at a time and it writes it to FP2 in the format integer and one thing you can notice is line number 25 and line number 36 closes the two files <sil=0.941> .PERIOD So <sil=0.496> ,COMMA this file you are done with reading at line number 24 you do not have anything more to read <sil=0.937> .PERIOD So <sil=0.316> ,COMMA you can close the first file my <sil=0.949> .PERIOD 1 <sil=0.300> .PERIOD text at line number 25 and since you are done with all the writing of all the variables that you of all the values you can close this file at line number 36 <sil=0.992> .PERIOD So <sil=0.450> ,COMMA I will compile this and I will show how it is going to run <sil=0.993> .PERIOD So <sil=0.523> ,COMMA I have compiled it let me show what the file has <sil=0.939> .PERIOD So <sil=0.362> ,COMMA I am going to show you what my <sil=0.950> .PERIOD 1 <sil=0.578> .PERIOD text has <sil=0.974> .PERIOD So <sil=0.417> ,COMMA it has a bunch of integers <sil=0.967> .PERIOD So <sil=0.362> ,COMMA 20 <sil=0.531> ,COMMA 80 <sil=0.521> ,COMMA 30 <sil=0.320> ,COMMA 50 <sil=0.498> ,COMMA 70 <sil=0.332> ,COMMA 60 <sil=0.426> ,COMMA 10 <sil=0.368> ,COMMA 40 there are 80 integers clearly less than 10 <sil=0.973> .PERIOD So <sil=0.392> ,COMMA I am good <sil=0.915> .PERIOD So <sil=0.391> ,COMMA I have already compiled it earlier <sil=0.948> .PERIOD So <sil=0.618> ,COMMA the executable is called file1 <sil=0.953> .PERIOD exe that is what I call the file as file1 <sil=0.951> .PERIOD c when it compiles it gets file1 <sil=0.997> .PERIOD exe and when I run it by now what you to have done is it would have written something called sorted <sil=0.959> .PERIOD text <sil=0.954> .PERIOD You can see that the numbers tend to 80 where all here in un sorted order and they are all in sorted order now <sil=0.934> .PERIOD So <sil=0.417> ,COMMA just to show that this was actually created by the program let me delete the sorted <sil=0.924> .PERIOD text because it is a file that you are supposed to write every time the program is run <sil=0.928> .PERIOD You can see that sorted <sil=0.934> .PERIOD text there is no file by that name and if I run the program again and see what is in sorted <sil=0.990> .PERIOD text you can see that the file got new entries now <sil=0.958> .PERIOD So <sil=0.377> ,COMMA I deleted the file and when I run the program it created the file called sorted <sil=0.991> .PERIOD text <sil=0.924> .PERIOD So <sil=0.409> ,COMMA for while let us assume that this my <sil=0.946> .PERIOD 1 <sil=0.419> .PERIOD text did not exist I will instead call it my <sil=0.907> .PERIOD  <sil=1.000> .PERIOD text this was expected by the program my <sil=0.977> .PERIOD 1 I renamed it <sil=0.958> .PERIOD Now <sil=0.497> ,COMMA if I run file1 <sil=0.961> .PERIOD So <sil=0.417> ,COMMA I printed this error called file0 percent this file which is not present as my <sil=0.949> .PERIOD 1 <sil=0.355> .PERIOD text it would not change the sorted <sil=0.981> .PERIOD text because I exited from the program <sil=0.960> .PERIOD So <sil=0.528> ,COMMA this is a small piece of code that I wanted to show <sil=0.945> .PERIOD I have another piece of code which is also interesting <sil=0.989> .PERIOD So <sil=0.597> ,COMMA it is possible that I have two files which are both sorted entries <sil=0.928> .PERIOD Now <sil=0.568> ,COMMA I want to merge these two files together <sil=0.951> .PERIOD So <sil=0.524> ,COMMA in the previous case one thing that happened was I actually knew that the contents of the file had only 10 entries but I may not know that upfront <sil=0.901> .PERIOD I need a mechanism by which I do not want to depend on any count <sil=0.993> .PERIOD So <sil=0.452> ,COMMA in this program what it does is it takes two files it assumes that both these files are sorted and it will try and merge these two into one single sorted file <sil=0.902> .PERIOD So <sil=0.516> ,COMMA we are going to take two input sorted 1 <sil=0.961> .PERIOD text and 2 <sil=0.902> .PERIOD text and we are going to write a file called sorted <sil=0.937> .PERIOD text <sil=0.914> .PERIOD So <sil=0.344> ,COMMA you can see that sorted <sil=0.972> .PERIOD text gets opened in right only mode <sil=0.929> .PERIOD And if either fp1 or fp2 file failed you know that you cannot read <sil=0.968> .PERIOD So <sil=0.484> ,COMMA it is not present <sil=0.966> .PERIOD Otherwise you scan one integer from each one of these streams <sil=0.989> .PERIOD So <sil=0.581> ,COMMA you have one integer in stream 1 and one integer in stream 2 you read that <sil=0.921> .PERIOD And then I have written a piece of program from line number 25 to 37 right <sil=0.984> .PERIOD There is a piece of program which runs on a while loop <sil=0.967> .PERIOD So <sil=0.511> ,COMMA what does it do <sil=0.877> ?QUESTIONMARK So <sil=0.642> ,COMMA I have two files which are of differing lengths <sil=0.973> .PERIOD It is possible that I will end up consuming everything from one stream before I even finish the other stream <sil=0.956> .PERIOD So <sil=0.464> ,COMMA what I am going to check is have I not reached the end of stream 1 or stream 2 <sil=0.901> .PERIOD If I have not reached the end of stream 1 and not of stream 2 either <sil=0.934> .PERIOD As long as I have not reached the end of any of the streams then I can always read 2 integers and I will be able to compare them and do something with it right <sil=0.927> .PERIOD So <sil=0.380> ,COMMA at this point I have 2 integers that I have read <sil=0.978> .PERIOD I have not reached the end of the stream which means I should be able to compare and write the results path <sil=0.963> .PERIOD So <sil=0.631> ,COMMA the first stream you read into temp 1 the second stream is reading into temp 2 <sil=0.981> .PERIOD So <sil=0.314> ,COMMA you are comparing temp 1 and temp 2 <sil=0.915> .PERIOD If temp 1 is less than temp 2 then write temp 1 into the output file and read one more integer from file 1 <sil=0.930> .PERIOD Otherwise if temp 1 is greater than temp 2 or equal to temp 2 you write temp 2 into the file and you read one more integer from file 2 <sil=0.913> .PERIOD So <sil=0.403> ,COMMA you can see what is happening here <sil=0.939> .PERIOD So <sil=0.582> ,COMMA either the entry in file 1 or the entry in file 2 will be one of them will be the larger than the other <sil=0.997> .PERIOD You write that and move one step in that stream <sil=0.957> .PERIOD And what could happen is when you exit this loop you may not have exhausted both the streams <sil=0.960> .PERIOD One stream could end prematurely and the other one has more numbers <sil=0.963> .PERIOD But remember that the numbers are sorted <sil=0.978> .PERIOD So <sil=0.304> ,COMMA I can do something like what you did in merge sort that is what I have been trying to do here line number 25 to 37 is merging two streams instead of merging two arrays <sil=0.928> .PERIOD But if the arrays are of different size then you have to just concatenate whatever is left out at the end of the resultant array and that is what this loop does <sil=0.972> .PERIOD So <sil=0.341> ,COMMA line number 47 to 50 what it does is it <sil=0.997> .PERIOD So <sil=0.427> ,COMMA this 39 to 46 finds out with stream got over <sil=0.941> .PERIOD So <sil=0.328> ,COMMA FP1 got over FP2 should be copied <sil=0.982> .PERIOD If FP2 got over FP1 and to the end should be copied and what line number 47 to 50 does is it just copies whatever is left out in whichever file it is and it keeps canning and keeps copying till the whole that file is also exhausted <sil=0.993> .PERIOD And once that is over we can close all the streams FP1213 and you can return this 0 <sil=0.997> .PERIOD So <sil=0.334> ,COMMA let me again compile it and there are no compilation errors <sil=0.954> .PERIOD So <sil=0.547> ,COMMA let us look at sorted dot text because that is the output we are going to write <sil=0.982> .PERIOD So <sil=0.541> ,COMMA it has 10 to 80 now <sil=0.946> .PERIOD But let us look at sorted 1 dot text which is one of the input files it has 10 to 70 and sorted 2 dot text I created with more values than sorted 1 dot text it has 5 15 25 all the way up to 105 <sil=0.903> .PERIOD So <sil=0.342> ,COMMA there are 7 values here but there are 11 values here <sil=0.953> .PERIOD So <sil=0.568> ,COMMA your program will finish this stream before it finishes this stream <sil=0.957> .PERIOD So <sil=0.456> ,COMMA you will have more work to do after this stream is processed <sil=0.975> .PERIOD So <sil=0.506> ,COMMA I will run file 2 now <sil=0.941> .PERIOD So <sil=0.499> ,COMMA I run file 2 and it was printing various things on the screen <sil=0.907> .PERIOD Now <sil=0.501> ,COMMA let us go and look at sorted dot text <sil=0.979> .PERIOD So <sil=0.317> ,COMMA it got overwritten first sorted dot text was earlier written by file 1 dot c <sil=0.997> .PERIOD Now <sil=0.443> ,COMMA I have file 2 dot c file this is the second program and it overwrote the sorted dot text <sil=0.940> .PERIOD Now <sil=0.465> ,COMMA we can see that the entries of the resultant file are in sorted order <sil=0.945> .PERIOD So <sil=0.528> ,COMMA we read 2 files the key thing I want you to see is this FeoF is another way to look at end of file and in this case I am simultaneously forwarding both the file pointers by <sil=0.999> .PERIOD So <sil=0.518> ,COMMA I am trying to see if either one of them reach the end <sil=0.588> ,COMMA but one of the file pointers will move inside the loop either this or this will move depending on which one was slower <sil=0.950> .PERIOD Let us get back to the presentation <sil=0.935> .PERIOD So <sil=0.633> ,COMMA we looked at 2 examples in which we read and wrote to files <sil=0.992> .PERIOD The other key thing that I want you to learn is the notion of what are called command line arguments <sil=0.910> .PERIOD So <sil=0.347> ,COMMA if you notice the things that I have been doing here <sil=0.985> .PERIOD So <sil=0.401> ,COMMA let us say I want to copy file 1 dot c to another dot c <sil=0.987> .PERIOD So <sil=0.376> ,COMMA I wrote this thing called so I should it is called copy <sil=0.980> .PERIOD So <sil=0.639> ,COMMA copy is a Windows command to copy one file to another <sil=0.644> ,COMMA but copy itself is a program <sil=0.915> .PERIOD Somehow I am able to pass values file 1 dot c and another dot c here and I am able to get copy to do some work <sil=0.978> .PERIOD I did not say copy and then I type file 1 dot c in keyboard and another dot c in the keyboard and so on <sil=0.941> .PERIOD When I launch the program itself <sil=0.560> ,COMMA I was able to give the parameters that it is needed and the copying got done <sil=0.931> .PERIOD So <sil=0.312> ,COMMA this is called command line parameter <sil=0.935> .PERIOD So <sil=0.471> ,COMMA we are in a command line <sil=0.453> ,COMMA we are calling an executable and we have given 2 parameters file 1 dot c and another dot c <sil=0.979> .PERIOD I want we want to be able to process command line parameters <sil=0.994> .PERIOD That is your that is the next part of this video <sil=0.940> .PERIOD So <sil=0.378> ,COMMA command line arguments work like this <sil=0.923> .PERIOD You can pass arguments to see programs by passing them right when the program is executed <sil=0.912> .PERIOD So <sil=0.417> ,COMMA you can sit in the command line and type along with the parameters that you want <sil=0.911> .PERIOD You do not have to type them in later when the program is running <sil=0.955> .PERIOD So <sil=0.428> ,COMMA for example <sil=0.530> ,COMMA if you type echo hello comma world <sil=0.573> ,COMMA then you would see hello world printed on the screen <sil=0.925> .PERIOD So <sil=0.326> ,COMMA echo is actually taking command line parameters hello comma and world and it is processing it and it actually is printing on the screen right <sil=0.923> .PERIOD So <sil=0.542> ,COMMA this is done using a very sophisticated mechanism <sil=0.979> .PERIOD So <sil=0.640> ,COMMA you remember the main program does not take arguments by default <sil=0.951> .PERIOD So <sil=0.447> ,COMMA we never used <sil=0.959> .PERIOD So <sil=0.410> ,COMMA I even though I said main is a function <sil=0.381> ,COMMA we never passed any arguments to it <sil=0.971> .PERIOD But you can actually pass 2 arguments in Rc and character star Rv of array <sil=0.956> .PERIOD So <sil=0.594> ,COMMA Rc is an integer whereas <sil=0.577> ,COMMA Rv if you look at it is a pointer to a pointer <sil=0.959> .PERIOD So <sil=0.533> ,COMMA it is a set of pointers to a character pointers <sil=0.947> .PERIOD So <sil=0.525> ,COMMA Rv this square bracket means it is a set of pointers and what is it pointing to its character star <sil=0.961> .PERIOD So <sil=0.364> ,COMMA it is a pointer to pointer <sil=0.901> .PERIOD So <sil=0.486> ,COMMA you can also think of it as an array of strings <sil=0.939> .PERIOD So <sil=0.581> ,COMMA Rv of 0 is usually the name of the program <sil=0.911> .PERIOD Rv of 1 is the first argument that you passed Rv of 2 is the second and so on <sil=0.998> .PERIOD So <sil=0.452> ,COMMA Rc is an integer value that takes the number of arguments including the file name itself <sil=0.979> .PERIOD So <sil=0.504> ,COMMA for example <sil=0.371> ,COMMA if I did copy file 1 dot c another dot c <sil=0.428> ,COMMA this is the there are 3 arguments copy file 1 dot c and another dot c <sil=0.967> .PERIOD So <sil=0.534> ,COMMA Rc would be 3 <sil=0.997> .PERIOD Rv of 0 would be copy <sil=0.372> ,COMMA Rv of 1 would be file 1 dot c and Rv of 2 would be another dot c <sil=0.962> .PERIOD So <sil=0.370> ,COMMA what really happens is you get Rc equal to 3 and Rv is a pointer to a pointer and what do you have <sil=0.921> ?QUESTIONMARK You have 3 pointers which are pointing to echo <sil=0.377> ,COMMA hollow and world <sil=0.950> .PERIOD Remember these are strings <sil=0.950> .PERIOD So <sil=0.365> ,COMMA you have a backslash 0 at the end and the 4th pointer actually points to null <sil=0.956> .PERIOD So <sil=0.476> ,COMMA you have in some sense a 2 dimensional array of characters <sil=0.905> .PERIOD Again as before I have written a small program which does something very simple <sil=0.921> .PERIOD So <sil=0.439> ,COMMA it takes Rc and characters are Rv all it does is it iterates over all the arguments and prints them on the screen <sil=0.906> .PERIOD So <sil=0.363> ,COMMA it prints what is the argument number and what is the value of the argument <sil=0.996> .PERIOD So <sil=0.336> ,COMMA I runs from 0 to less than Rc <sil=0.978> .PERIOD So <sil=0.499> ,COMMA it goes 0 1 2 3 up to Rc minus 1 and it prints i comma Rv of i <sil=0.901> .PERIOD So <sil=0.625> ,COMMA I have already compiled this program let me run it now <sil=0.942> .PERIOD So <sil=0.503> ,COMMA I call this program echo <sil=0.991> .PERIOD Let us say I typed only echo dot exe I did not pass any parameters <sil=0.929> .PERIOD It just gives me the 0th Rv which is echo dot c echo dot exe itself <sil=0.989> .PERIOD Let us say now I give echo a <sil=0.603> ,COMMA a is one of the parameters <sil=0.967> .PERIOD So <sil=0.362> ,COMMA this is the 0th Rv and this is the 1th Rv <sil=0.970> .PERIOD So <sil=0.522> ,COMMA you get those two <sil=0.946> .PERIOD I can pass an arbitrary number of inputs <sil=0.926> .PERIOD See this <sil=0.406> .PERIOD So <sil=0.454> ,COMMA you have 0 1 2 <sil=0.935> .PERIOD So <sil=0.318> ,COMMA you have three arguments echo dot exe a and b <sil=0.999> .PERIOD I can do this and so on <sil=0.907> .PERIOD And it is not necessary that you pass only one variable type <sil=0.967> .PERIOD I passed an integer here then I can pass a real value here you can do any of those <sil=0.963> .PERIOD So <sil=0.584> ,COMMA anything that you pass in the command line will be passed to the program as Rv <sil=0.905> .PERIOD So <sil=0.520> ,COMMA they are treated as strings inside and I am printing one string after the other <sil=0.948> .PERIOD So <sil=0.310> ,COMMA this comes in handy whenever you do not want the keyboard input at all from the programmer even to read a file name <sil=0.979> .PERIOD Let us say I want to write a program like this copy file 1 dot c to file 2 dot c <sil=0.941> .PERIOD So <sil=0.506> ,COMMA I do not want the user to type it later <sil=0.955> .PERIOD Instead I want that to be given in the command line itself and automatically this file <sil=0.969> .PERIOD So <sil=0.362> ,COMMA you will read that as a string you have to open the file by that name read it <sil=0.423> ,COMMA open the other file in write mode write it and so on all of that is there <sil=0.990> .PERIOD But you have passed the file names right in the command line itself <sil=0.999> .PERIOD So <sil=0.496> ,COMMA these are two things that are very useful the notion of being able to do file IO and the notion of being able to take command line arguments <sil=0.915> .PERIOD So <sil=0.411> ,COMMA that is the same program that is here and this brings us to the end of this Welcome to lecture 4 <sil=0.965> .PERIOD We have a bunch of modules which are all related to arrays and what are called pointers <sil=0.926> .PERIOD So <sil=0.528> ,COMMA the first module is about multi-dimensional arrays <sil=0.942> .PERIOD So <sil=0.342> ,COMMA multi-dimensional arrays they appear many times in the form of tables <sil=0.916> .PERIOD So <sil=0.526> ,COMMA I am sure you have seen spreadsheets or matrices and so on <sil=0.957> .PERIOD These are all very common things in several engineering disciplines and you can think of them as a two-dimensional array <sil=0.961> .PERIOD So <sil=0.580> ,COMMA you have one dimension which is the set of rows <sil=0.372> ,COMMA another dimension which is the set of columns and you can have rows and columns which form a table <sil=0.961> .PERIOD This could be a 2D array <sil=0.902> .PERIOD You could also have arrays which are more than one more than two dimensions <sil=0.907> .PERIOD For instance <sil=0.425> ,COMMA if you look at graphics 3D graphics will require x <sil=0.359> ,COMMA y <sil=0.409> ,COMMA and z <sil=0.961> .PERIOD So <sil=0.431> ,COMMA you have three dimensions and so on <sil=0.938> .PERIOD So <sil=0.333> ,COMMA we need a mechanism by which we can not only store <sil=0.505> ,COMMA but also be able to access them and manipulate them as variables and so on <sil=0.947> .PERIOD So <sil=0.349> ,COMMA let us look at what a 2D array would be <sil=0.981> .PERIOD So <sil=0.314> ,COMMA in this example what we have is we have an array called a which says int a of 4 <sil=0.405> ,COMMA 2 <sil=0.380> .PERIOD So <sil=0.391> ,COMMA that is the declaration <sil=0.989> .PERIOD So <sil=0.381> ,COMMA just like what we have for basic variables int a of 4 <sil=0.646> ,COMMA 2 tells you that you want 8 integers arranged as 4 rows and 2 columns <sil=0.933> .PERIOD And as with 1D array one thing that you lot remember is that you have 4 rows numbered 0 <sil=0.429> ,COMMA 1 <sil=0.639> ,COMMA 2 and 3 and 2 columns numbered 0 and 1 <sil=0.902> .PERIOD So <sil=0.467> ,COMMA the rows get numbered from 0 and the columns get numbered from 0 as well <sil=0.949> .PERIOD This is something that you have to remember this has to be drilled into you <sil=0.927> .PERIOD And the storage in the memory is actually what is called a row major order <sil=0.901> .PERIOD So <sil=0.423> ,COMMA what I mean by that is as follows <sil=0.991> .PERIOD So <sil=0.596> ,COMMA even though you have two dimensions as a pictorial representation here <sil=0.550> ,COMMA remember memory is just a sequence of memory locations right it is actually one dimensional <sil=0.925> .PERIOD And the way things are going to be stored as follows <sil=0.995> .PERIOD You take the first row that is the 0th row and you take the first column that is the 0th column <sil=0.910> .PERIOD The entry a of 0 <sil=0.445> ,COMMA 0 goes into one location then a of 0 comma 1 which is the next column in the same row gets into the next location <sil=0.910> .PERIOD And then you can think of this as folding down and you have the first row and the 0th column that goes into the next location and so on <sil=0.990> .PERIOD So <sil=0.382> ,COMMA you can see that the order in which things are listed are you have started with 0 <sil=0.426> ,COMMA 0 then you have 0 <sil=0.502> ,COMMA 1 and then you have 1 <sil=0.370> ,COMMA 0 and 1 <sil=0.309> ,COMMA 1 and so on up till 3 <sil=0.464> ,COMMA 1 <sil=0.309> .PERIOD So <sil=0.325> ,COMMA you have 8 memory locations of the type integer and they are all contiguous <sil=0.938> .PERIOD So <sil=0.370> ,COMMA this is called row major order <sil=0.901> .PERIOD You can initialize 2D arrays as you did for 1D arrays also <sil=0.963> .PERIOD So <sil=0.630> ,COMMA for example <sil=0.623> ,COMMA here we have a 2D array called b which has 2 rows and 3 columns <sil=0.990> .PERIOD So <sil=0.564> ,COMMA this set of set braces tell you that you want an array <sil=0.957> .PERIOD And within and within this you have two such curly braces <sil=0.361> ,COMMA two sets of curly braces and list of values there <sil=0.978> .PERIOD So <sil=0.402> ,COMMA the 0th row will contain 45 and 6 and the 1th row will contain 0 <sil=0.457> ,COMMA 3 and 5 <sil=0.927> .PERIOD So <sil=0.315> ,COMMA we have two different things and the entries are again going to be laid out in row major order <sil=0.950> .PERIOD You can go and design or use arrays which are more than 2 dimensions <sil=0.978> .PERIOD So <sil=0.346> ,COMMA for example <sil=0.418> ,COMMA here we have flow b of 243 <sil=0.944> .PERIOD So <sil=0.370> ,COMMA you can now think of this as 2 planes <sil=0.306> ,COMMA each plane having 4 rows and 3 columns <sil=0.986> .PERIOD So <sil=0.325> ,COMMA you have the 0th plane and the 1th plane <sil=0.913> .PERIOD So <sil=0.626> ,COMMA I will call it 1th just so that I can say ith later <sil=0.964> .PERIOD This is the 0th plane and 1th plane and within that I have 0th row <sil=0.315> ,COMMA 1th row <sil=0.340> ,COMMA 2th row and 3th row <sil=0.927> .PERIOD And similarly <sil=0.315> ,COMMA I have 0th column <sil=0.441> ,COMMA 1th column and so on <sil=0.909> .PERIOD So <sil=0.516> ,COMMA essentially you can access ith row of this plane by accessing b of 0 <sil=0.375> ,COMMA i <sil=0.954> .PERIOD And if I want to access ith row and jth column of this plane <sil=0.316> ,COMMA I can say b of 0 <sil=0.527> ,COMMA i <sil=0.913> ,COMMA j <sil=0.938> .PERIOD If I want to access something in here <sil=0.527> ,COMMA I have to use b of 1 <sil=0.315> ,COMMA i <sil=0.908> ,COMMA j and so on <sil=0.934> .PERIOD And see you can actually have dimensions more than 3 also <sil=0.590> ,COMMA but for most practical purposes <sil=0.485> ,COMMA you will need 1d 2d and 3d arrays <sil=0.977> .PERIOD So <sil=0.582> ,COMMA let us look at the most common use of 2d arrays <sil=0.981> .PERIOD These are usually for matrices <sil=0.983> .PERIOD Let us look at a matrix called m <sil=0.334> ,COMMA let it have m rows and n columns <sil=0.956> .PERIOD So <sil=0.446> ,COMMA the rows are going to be numbered from 0 to m minus 1 and columns are going to be numbered from 0 to n minus 1 <sil=0.973> .PERIOD So <sil=0.636> ,COMMA you have m rows and n columns <sil=0.931> .PERIOD And if you want to access the ith row and jth column <sil=0.574> ,COMMA element in the ith row and jth column <sil=0.466> ,COMMA you access it as m of i <sil=0.390> ,COMMA j <sil=0.944> .PERIOD So <sil=0.553> ,COMMA m of i <sil=0.637> ,COMMA j is ith row and jth column <sil=0.964> .PERIOD Just as you have for arrays <sil=0.481> ,COMMA i should be less than m and it starts from 0 <sil=0.576> ,COMMA j should be less than n and it starts from 0 as well <sil=0.913> .PERIOD So <sil=0.409> ,COMMA this is just an extension of what you did for 1d arrays <sil=0.947> .PERIOD So <sil=0.347> ,COMMA let us write a small program in which we are going to fill up values and print a 2d array just to show you how access to an array works <sil=0.997> .PERIOD So <sil=0.475> ,COMMA I have this small program written up <sil=0.920> .PERIOD So <sil=0.492> ,COMMA let us look at this program here <sil=0.957> .PERIOD So <sil=0.300> ,COMMA I have m which is defined to be 3 and n which is defined to be 4 and what I have is I have int a of m comma n <sil=0.908> .PERIOD So <sil=0.524> ,COMMA this is going to allocate an array of 3 rows by 4 columns <sil=0.960> .PERIOD So <sil=0.582> ,COMMA total of 12 elements and you can access an individual element using a of i comma j <sil=0.924> .PERIOD So <sil=0.645> ,COMMA we have this loop running from 9 to 13 which is going to fill up the array and the loop running from line number 14 to 20 which is going to print the array <sil=0.956> .PERIOD So <sil=0.342> ,COMMA in this case these are a is the 2 dimensional array is being filled up in this form <sil=0.983> .PERIOD So <sil=0.363> ,COMMA a of i comma j is going to have the value i plus j <sil=0.909> .PERIOD So <sil=0.471> ,COMMA a of 0 0 will have 0 0 1 will have 1 0 2 will have 2 and so on <sil=0.986> .PERIOD So <sil=0.374> ,COMMA the first the 0th row will have 0 1 2 3 as its elements <sil=0.998> .PERIOD Row number 1 will have 1 2 3 4 as its elements and so on and we want to be able to print it <sil=0.902> .PERIOD So <sil=0.486> ,COMMA that is there in this loop <sil=0.903> .PERIOD You can see that it is a nested for loop that is used here <sil=0.925> .PERIOD So <sil=0.380> ,COMMA this loop starting at line number 9 ending at 13 is the outer loop and this loop is hydrating over the rows and this is the inner loop and that is hydrating over the columns <sil=0.957> .PERIOD And this you are accessing a of i comma j <sil=0.978> .PERIOD So <sil=0.498> ,COMMA you are accessing each element in a row and you go to the next row and so on and you have the same order in which you are printing this <sil=0.951> .PERIOD So <sil=0.608> ,COMMA let us save this and compile and run it <sil=0.955> .PERIOD So <sil=0.626> ,COMMA I am going to run that and as I mentioned earlier <sil=0.416> ,COMMA there is row 0 which has 0 1 2 3 row 1 which has 1 2 3 4 row 2 which has 2 3 4 5 and so on <sil=0.921> .PERIOD So <sil=0.588> ,COMMA the basic idea is that you can access these arrays as though you are accessing the 1D array except that you have 1 dimension which is called the major dimension and 1 which is called the minor dimension <sil=0.946> .PERIOD So <sil=0.631> ,COMMA the rows are the major dimensions and columns are the minor dimension <sil=0.904> .PERIOD If you have a 3D array <sil=0.528> ,COMMA the plane would be the major dimension <sil=0.315> ,COMMA row will be the intermediate dimension and columns will be the minor dimension <sil=0.982> .PERIOD So <sil=0.500> ,COMMA what can we do with these 2D matrices <sil=0.969> ?QUESTIONMARK Let us see what we can do with it <sil=0.981> .PERIOD So <sil=0.426> ,COMMA I am going to talk about how to write a small program to do matrix multiplication <sil=0.994> .PERIOD So <sil=0.586> ,COMMA I am going to assume that there is an array <sil=0.628> ,COMMA there is a 2D array or a matrix called A <sil=0.919> .PERIOD So <sil=0.499> ,COMMA we have a 2 we have a matrix called A and we have another matrix called B <sil=0.903> .PERIOD Let us assume that A has A rows number of rows and A calls number of columns and let us assume that B has B rows number of rows and B calls number of columns <sil=0.901> .PERIOD So <sil=0.619> ,COMMA if you are going to multiply A with B <sil=0.392> ,COMMA we are doing A times B <sil=0.323> ,COMMA the number of columns of A and the number of rows of B should match otherwise the matrix product would be incompatible and however we are going to do this computation <sil=0.945> .PERIOD So <sil=0.327> ,COMMA you can see that the number of rows of C are the same as the number of rows of A and the number of columns of C is the same as the number of columns of B <sil=0.989> .PERIOD So <sil=0.579> ,COMMA that is the first thing that you have to do <sil=0.540> ,COMMA you have to see <sil=0.997> .PERIOD You can see that this size is the same as this size and this size is the same as this size <sil=0.977> .PERIOD So <sil=0.422> ,COMMA given that how do we now find out the actual entries of the final matrix C <sil=0.930> .PERIOD So <sil=0.419> ,COMMA the way you do that is follows <sil=0.954> .PERIOD So <sil=0.488> ,COMMA you take one element from A and you take a corresponding element from B and you multiply that <sil=0.955> .PERIOD So <sil=0.442> ,COMMA I took one element from A <sil=0.620> ,COMMA I took a corresponding element from B <sil=0.945> .PERIOD So <sil=0.383> ,COMMA let us say that I pick the I throw from A and I pick the jth column from B <sil=0.983> .PERIOD So <sil=0.561> ,COMMA I throw will have A calls number of elements and jth column will also have B rows equal to A columns number of elements <sil=0.931> .PERIOD So <sil=0.620> ,COMMA this and this dimension should match <sil=0.991> .PERIOD So <sil=0.472> ,COMMA the number of entries in the rows here and the number of entries in this column here should be the same <sil=0.909> .PERIOD So <sil=0.470> ,COMMA what I am going to do is I am going to take one pair at a time like this <sil=0.597> ,COMMA multiply these two elements and put it in the location here <sil=0.921> .PERIOD Then I am going to multiply these two elements <sil=0.906> .PERIOD So <sil=0.626> ,COMMA in the column one here and row one here and this has to be added to the location at C and so on <sil=0.957> .PERIOD So <sil=0.360> ,COMMA I can proceed taking one pair of elements at a time <sil=0.498> ,COMMA one element from A and another element from B and I have to keep adding it to the elements in C of i comma j <sil=0.980> .PERIOD So <sil=0.424> ,COMMA essentially the bottom line is if you take the I throw of A and the jth column of B <sil=0.526> ,COMMA you get the I jth entry of C and you do this by hydrating over all the elements I throw of A and jth column of B simultaneously <sil=0.537> ,COMMA you have to do this together and take one pair at a time and multiply add it to C of i comma j <sil=0.926> .PERIOD So <sil=0.425> ,COMMA this is the basic logic <sil=0.999> .PERIOD So <sil=0.523> ,COMMA let us see how to write a program for this <sil=0.907> .PERIOD So <sil=0.528> ,COMMA as before we have three matrices <sil=0.393> ,COMMA let us assume that these three matrices can accommodate up to 10 cross 10 elements <sil=0.999> .PERIOD So <sil=0.407> ,COMMA each of these matrices can take up to 100 elements <sil=0.909> .PERIOD However <sil=0.383> ,COMMA I am going to use not all the 100 elements <sil=0.394> ,COMMA I may not want all the 100 elements to be filled up <sil=0.904> .PERIOD I allow for a row and a set of rows and columns that is lesser than 10 <sil=0.917> .PERIOD I am going to take it from the user <sil=0.992> .PERIOD So <sil=0.442> ,COMMA the user is going to give A rows and A calls <sil=0.534> ,COMMA which is the number of rows of A and number of columns of A <sil=0.970> .PERIOD So <sil=0.609> ,COMMA clearly A rows and A columns should both be less than 10 <sil=0.572> ,COMMA less than or equal to 10 <sil=0.938> .PERIOD And what I am going to do is <sil=0.463> ,COMMA I am going to iterate over the number of rows for in A and the number of columns in A and fill up A of i comma j <sil=0.973> .PERIOD Similarly <sil=0.550> ,COMMA I iterate over the number of rows of <sil=0.430> ,COMMA so I scan the number of rows from the user and columns from the user <sil=0.977> .PERIOD I iterate over the set of values and end up with B filled up <sil=0.932> .PERIOD And once I have A and B filled up <sil=0.311> ,COMMA I am ready to do matrix multiplication <sil=0.934> .PERIOD So <sil=0.371> ,COMMA the key thing is the number of rows in C is the same as the number of rows in A and the number of columns in C is the same as number of columns in B <sil=0.958> .PERIOD So <sil=0.453> ,COMMA let us see how this program would run <sil=0.944> .PERIOD So <sil=0.376> ,COMMA you would need these two loops <sil=0.541> ,COMMA the i-th loop and the j-th loop <sil=0.977> .PERIOD So <sil=0.523> ,COMMA the outermost loop and the intermediate loop will iterate over all the elements C of ij <sil=0.958> .PERIOD So <sil=0.389> ,COMMA this is evident from looking at this <sil=0.904> .PERIOD So <sil=0.602> ,COMMA if I want i comma j-th entry <sil=0.518> ,COMMA I will take this row vector here and this column vector here <sil=0.952> .PERIOD I will do a dot product essentially and I will put it here <sil=0.978> .PERIOD Then I have to go and fill up this <sil=0.342> ,COMMA then I have to go and fill up this and so on <sil=0.963> .PERIOD So <sil=0.382> ,COMMA I will start from this location and I am going to start filling up elements in this order <sil=0.975> .PERIOD So <sil=0.460> ,COMMA this is the order in which we are going to fill up elements <sil=0.954> .PERIOD So <sil=0.393> ,COMMA these two loops take care of that i equal to 0 to less than 0 <sil=0.357> ,COMMA j equal to 0 <sil=0.455> ,COMMA j less than C columns will iterate over all the entries of C of ij <sil=0.996> .PERIOD So <sil=0.469> ,COMMA the first thing we do is initialize C of ij to 0 and once you have that <sil=0.600> ,COMMA then we are now ready to do the actual dot product <sil=0.900> .PERIOD The actual dot product is done here <sil=0.924> .PERIOD I am going to look at i comma kth entry of A and k comma jth entry of B and I multiply that added to the current value of C of ij <sil=0.938> .PERIOD So <sil=0.537> ,COMMA that is what the plus equal to does <sil=0.955> .PERIOD You take i comma kth value of A <sil=0.456> ,COMMA k comma jth value of B <sil=0.467> ,COMMA multiply it and add it to the current value of C and when you do that <sil=0.544> ,COMMA you see that C of i comma j will is actually accumulating the value <sil=0.918> .PERIOD You initialize to 0 and it is accumulating the value <sil=0.957> .PERIOD At the end of this <sil=0.589> ,COMMA C of ij will get the final dot product of those two vectors and you are iterating over all the values of i comma j that are permissible for C <sil=0.976> .PERIOD So <sil=0.412> ,COMMA at the end of it <sil=0.434> ,COMMA you have all the entries in C filled up <sil=0.972> .PERIOD So <sil=0.506> ,COMMA this is a basic program in to do matrix multiplication and this loop is printing the entries <sil=0.979> .PERIOD So <sil=0.644> ,COMMA this is a fairly simple program <sil=0.956> .PERIOD So <sil=0.366> ,COMMA the key thing for 2D arrays is that you have to remember it is always rows followed by columns or planes followed by rows followed by columns and you use square bracket to access the row or column and all the numbering for the planes for the rows and columns start with 0 <sil=0.962> .PERIOD So <sil=0.508> ,COMMA all the basic rules related to 1D array also applies here <sil=0.963> .PERIOD So <sil=0.490> ,COMMA if you have A of <sil=0.532> ,COMMA if your array A is of size m cross n <sil=0.305> ,COMMA the largest entry you can access is A of m minus 1 n minus 1 <sil=0.973> .PERIOD So <sil=0.554> ,COMMA today's lecture is about greedy algorithms and specifically we will be studying one algorithm for a problem called job scheduling <sil=0.966> .PERIOD The initial part of the presentation will present you the motivation for greedy algorithms by a very simple algorithm <sil=0.544> ,COMMA very simple example <sil=0.962> .PERIOD The example is the change making example <sil=0.926> .PERIOD So <sil=0.333> ,COMMA let us consider the following problem where for an example let us consider we have 832 rupees and using as few nodes and coins as possible we should keep 832 rupees let us say in our purse <sil=0.914> .PERIOD In general we know that there are 9 denominations of rupees in the Indian currency <sil=0.951> .PERIOD So <sil=0.450> ,COMMA let us call these denominations d1 to d9 indeed they take the values from 1500 <sil=0.494> ,COMMA 150 <sil=0.919> ,COMMA 20 <sil=0.541> ,COMMA 10 <sil=0.496> ,COMMA 5 <sil=0.372> ,COMMA 2 and 1 <sil=0.966> .PERIOD Naturally <sil=0.322> ,COMMA we wish to carry as few nodes and coins as possible and the generic question is given M rupees identify 9 variables these are integer valued variables positive integer valued variables such that the M rupees can be written as a sum of x1 times the first denomination d1 x2 times the second denomination d2 <sil=0.977> .PERIOD So <sil=0.336> ,COMMA 1 up to x9 times the 9th denomination d9 <sil=0.992> .PERIOD For example 832 can be written as 1500 rupees plus 300 rupees 120 rupees 1 10 rupee and 1 2 rupee coin <sil=0.945> .PERIOD In general do we have a natural approach here to solve this problem <sil=0.923> .PERIOD The natural approach seems to be that iteratively we select the largest denomination which is available which is smaller than the current amount <sil=0.995> .PERIOD Let us observe this by the example itself 832 is the current amount and the largest denomination which is available to us is a 500 rupee note <sil=0.944> .PERIOD So <sil=0.567> ,COMMA we pick up 500 rupees and the balance that is to be expressed is 332 <sil=0.990> .PERIOD Now <sil=0.522> ,COMMA 332 the smallest the largest denomination smaller than 332 is a 100 rupee note <sil=0.966> .PERIOD Naturally we pick 3 times 100 <sil=0.942> .PERIOD We pick 100 once then the balance is 232 the smallest denomination large the largest denomination smaller than this amount is another 100 and so on <sil=0.971> .PERIOD So <sil=0.600> ,COMMA we pick 3 times 100 rupees then we pick a 20 rupee note because the balance that is to be expressed is 32 rupees and so on <sil=0.991> .PERIOD So <sil=0.543> ,COMMA the generic idea seems to be that we select the largest denomination that is available such that it is smaller than the current amount that we need to express <sil=0.969> .PERIOD Does this always work independent of the denominations <sil=0.925> ?QUESTIONMARK This is an interesting question <sil=0.990> .PERIOD Observe that we did our exercise with the Indian currency with a fixed set of denominations <sil=0.902> .PERIOD Let us imagine whether this approach will work for any arbitrary set of denominations in some currency <sil=0.909> .PERIOD Let us assume that there is a country with currency right <sil=0.928> .PERIOD Whose denominations are 1 <sil=0.581> ,COMMA 3 and 4 respectively and there is no other denomination <sil=0.906> .PERIOD Would our natural generic approach yield the optimum solution <sil=0.897> ?QUESTIONMARK Let us see <sil=0.386> .PERIOD Let us consider the simplest case of 6 <sil=0.961> .PERIOD So <sil=0.539> ,COMMA if we apply our generic approach we will pick the largest denomination smaller than the amount which is 6 therefore <sil=0.302> ,COMMA we will pick 4 <sil=0.978> .PERIOD Another which we are left with 2 which can be expressed as 1 plus 1 <sil=0.953> .PERIOD So <sil=0.454> ,COMMA our solution would be 4 plus 1 plus 1 <sil=0.912> .PERIOD On the other hand it is clear in this very simple example that the best denomination possible with the best representation of 6 possible in this currency is 3 plus 3 <sil=0.954> .PERIOD Therefore <sil=0.442> ,COMMA it is clear that this generic algorithm which seems to be a very natural approach does not work for all currencies <sil=0.900> .PERIOD It depends only seems to depend on the denominations <sil=0.983> .PERIOD A definite exercise which we will not address in this class is does this work for the Indian currency and if so why does it <sil=0.990> ?QUESTIONMARK We will not address this but this is left as an exercise for the interested student <sil=0.964> .PERIOD This takes us to this whole idea of greedy algorithms <sil=0.945> .PERIOD So <sil=0.448> ,COMMA observe that our algorithmic approach is a greedy approach <sil=0.981> .PERIOD So <sil=0.475> ,COMMA we choose the locally best possible choice <sil=0.941> .PERIOD So <sil=0.552> ,COMMA given a certain amount we choose the largest possible denomination without exceeding the current amount <sil=0.965> .PERIOD So <sil=0.465> ,COMMA this is in some sense a greedy choice hoping that this will eventually lead to a optimal solution as we have seen it does not work for all currencies <sil=0.944> .PERIOD So <sil=0.463> ,COMMA therefore <sil=0.472> ,COMMA greedy algorithms should have an optimal substructure <sil=0.913> .PERIOD What is an optimal substructure <sil=0.884> ?QUESTIONMARK We should be able to guarantee the existence of an optimal solution to the problem such that this optimal solution also contains optimal solutions to the sub problems <sil=0.963> .PERIOD This is a very important concept <sil=0.978> .PERIOD You have a problem and you also have sub problems of the problem <sil=0.914> .PERIOD This is best illustrated by the shortest path problem in any network <sil=0.990> .PERIOD Let us assume that the network is undirected and let us think of the shortest path problem between a source and destination <sil=0.937> .PERIOD Observe that if you pick any shortest path between the source and destination and if you pick any pair of vertices on the shortest path not necessarily source and destination <sil=0.370> ,COMMA it is clear that the shortest path contains the shortest paths between the intermediate points <sil=0.906> .PERIOD So <sil=0.558> ,COMMA very natural property of shortest paths <sil=0.953> .PERIOD So <sil=0.649> ,COMMA this is the optimal substructure <sil=0.949> .PERIOD Observe that no algorithmic choice is here it is just a property of an optimum solution <sil=0.914> .PERIOD The greedy choice property is an algorithmic choice <sil=0.926> .PERIOD It says that you can obtain a globally optimum solution by making locally optimal choices <sil=0.997> .PERIOD We have seen this example of the change making problem and we wonder whether it has the greedy choice property <sil=0.963> .PERIOD We have already observed that if the denomination is denominations are 1 <sil=0.601> ,COMMA 3 and 4 respectively <sil=0.905> .PERIOD If you take an optimum solution <sil=0.624> ,COMMA let us take the optimum solution for 6 in this example <sil=0.421> ,COMMA which is 3 plus 3 <sil=0.964> .PERIOD Note that every subset of notes is the optimum change for its sum <sil=0.917> .PERIOD So <sil=0.408> ,COMMA in this case every subset is just the node 3 itself which is the optimum change for itself <sil=0.996> .PERIOD So <sil=0.625> ,COMMA this is easy <sil=0.931> .PERIOD The greedy choice on the other hand is not satisfied as we have already seen <sil=0.911> .PERIOD We will select 4 <sil=0.365> ,COMMA then we selected 1 followed by a 1 and this turned out to be suboptimal <sil=0.988> .PERIOD So <sil=0.516> ,COMMA we repeat this exercise <sil=0.952> .PERIOD What the greedy choice work for the Indian currency <sil=0.983> ?QUESTIONMARK Indeed in this slide we have observed that the optimal substructure seems to work for any currency <sil=0.904> .PERIOD However <sil=0.479> ,COMMA like I said earlier we will not address it in this presentation because the problem is not as easy as it seems <sil=0.949> .PERIOD It is very easy to state it <sil=0.385> ,COMMA but it is very closely related to problems which after many years of research have not yielded to efficient algorithms <sil=0.921> .PERIOD For example <sil=0.634> ,COMMA there is a problem called the NAPSAC problem <sil=0.901> .PERIOD It does not have efficient algorithms to date <sil=0.604> ,COMMA it is believed not to have efficient algorithms <sil=0.947> .PERIOD There is also the optimum denomination problem which is actually a problem faced by currency designers <sil=0.954> .PERIOD Where the question is what is the best denomination to ensure that for every number you get the smallest possible change by our approach <sil=0.949> .PERIOD So <sil=0.624> ,COMMA therefore <sil=0.555> ,COMMA let us ask a slightly different question are there problems for which greedy algorithms result in optimum solutions <sil=0.976> ?QUESTIONMARK This is the focus <sil=0.977> .PERIOD The change making example was a natural example to visualize the greedy algorithm scenario <sil=0.940> .PERIOD Let us look at the problem which is very well called very well known as a scheduling problem <sil=0.975> .PERIOD There is a single machine and there are N jobs <sil=0.932> .PERIOD Each of these jobs can run only on this single machine and should be run on the single machine <sil=0.942> .PERIOD And the jobs are already known to have running times t1 <sil=0.451> ,COMMA t2 <sil=0.608> ,COMMA tn respectively <sil=0.994> .PERIOD In other words <sil=0.526> ,COMMA the job J i takes T i units of time on the machine M <sil=0.912> .PERIOD The aim is the following <sil=0.351> ,COMMA the aim is to identify a schedule of jobs that is the order in which the jobs will execute in the machine so that we minimize the sum of the completion times <sil=0.992> .PERIOD Now minimizing the sum of completion times can also be thought of as minimizing the average of all the completion times <sil=0.901> .PERIOD It is very important for the student to note that this average duration <sil=0.623> ,COMMA this is not the average duration which is a fixed number <sil=0.997> .PERIOD It is the average time that a machine spends waiting for the average time a job spends waiting for a machine and then the time that it spends on the machine itself <sil=0.964> .PERIOD One wants to minimize this quantity <sil=0.997> .PERIOD Therefore the goal of this exercise is to find an ordering of jobs to execute on the machine so that we minimize the sum of completion times <sil=0.943> .PERIOD Let us do this small example <sil=0.910> .PERIOD There are four jobs <sil=0.977> .PERIOD Job 1 takes 15 units of time <sil=0.987> .PERIOD Job 2 takes 8 units of time <sil=0.956> .PERIOD Job 3 takes 3 units of time <sil=0.925> .PERIOD Job 4 takes 10 units of time <sil=0.964> .PERIOD The total duration that the machine will spend executing these jobs clearly is 15 plus 8 23 units plus 3 26 plus 10 36 units of time <sil=0.913> .PERIOD Therefore the average duration on the machine seems to be 9 units of time <sil=0.933> .PERIOD Is 9 units of time <sil=0.967> .PERIOD However <sil=0.633> ,COMMA the completion time is a completely different entity as shown by this graphic <sil=0.945> .PERIOD What are the first schedule in this graphic where job 1 <sil=0.350> ,COMMA job 2 <sil=0.414> ,COMMA job 3 and job 4 are scheduled <sil=0.987> ?QUESTIONMARK Job 1 finishes after 15 units of time on the machine <sil=0.920> .PERIOD Job 2 then finishes after 8 units of time <sil=0.921> .PERIOD Therefore the completion time of job 2 is 23 <sil=0.905> .PERIOD Job 3 which actually spends the least amount of time on the machine which is 3 units of time completes at time in time in time 26 and job 4 completes at 36 as a time instant <sil=0.943> .PERIOD Therefore now if we average these completion times we see that the average is 25 <sil=0.979> .PERIOD That is 100 units of time is spent <sil=0.977> .PERIOD The sum of the completion time is 100 <sil=0.962> .PERIOD On the other hand let us consider the second schedule where interestingly the shortest job is scheduled first <sil=0.982> .PERIOD Then the second shortest job then the third shortest job then the fourth shortest job which is the order <sil=0.907> .PERIOD Job 3 <sil=0.582> ,COMMA job 2 <sil=0.463> ,COMMA job 4 and job 1 <sil=0.977> .PERIOD Now observe that the average completion time is 17 <sil=0.932> .PERIOD 75 units of time which is smaller significantly than the schedule where the jobs were scheduled according to the order in which they were presented in the input <sil=0.900> .PERIOD So now do we have an algorithm here to minimize the sum of completion times <sil=0.950> ?QUESTIONMARK To do this let us write down a formula for the sum of the completion times <sil=0.903> .PERIOD Before that let us look at the schedule <sil=0.917> .PERIOD Let us look at properties of the schedule <sil=0.997> .PERIOD Before we do the calculation for the sum of the completion times let us look at the property of a schedule <sil=0.906> .PERIOD One observation that we can make is that if we take an arbitrary schedule and exchange the position of a shortest job in particular let us say the first shortest job in the schedule with the first job in the schedule <sil=0.950> .PERIOD So let us look at our example in the first job <sil=0.941> .PERIOD If we exchange the jobs J3 with the first job observe that we will get a better schedule than the one that was given first <sil=0.942> .PERIOD So if we assume that there is always an optimal schedule where the first job is the shortest job then it is clear that there is a very interesting optimal substructure that if you remove the shortest job the remaining schedule for the remaining jobs is indeed optimal <sil=0.993> .PERIOD In other words if you take a optimal schedule in which the shortest job is schedule first by removing that shortest job the remaining schedule is indeed an optimum schedule for the remaining n minus 1 jobs <sil=0.951> .PERIOD Of course we do not know if there is an optimal schedule which contains the shortest job first that is what we are going to study now by writing down a formula for the sum of the completion types <sil=0.965> .PERIOD So do this let us assume that there is a schedule which we refer to using the Greek letter sigma and let us assume that sigma 1 denote the first job and sigma n denote the nth job in the sequence <sil=0.934> .PERIOD Now let us look at the sum of the completion times the sum of the completion times is written as a first formula where there are n jobs and let us observe that the time taken by the first job that is the job sigma of 1 that will be counted it will delay every subsequent job <sil=0.916> .PERIOD Apart from using T sigma of 1 units of time on the machine the first job that we schedule which is sigma of 1 takes T sigma of 1 units of time on the machine not only that it also delays the remaining n minus 1 jobs by T sigma of 1 units of time same for T sigma of 2 it is a second job its completion time is the time that it spent waiting for the machine which is T sigma of 1 plus the time that it spends processing on the machine which is T sigma of 2 <sil=0.947> .PERIOD In general if you look at the whole expression for the sum of completion times the formula is given there it is n terms in the summation and there are n minus k plus 1 copies of T sigma of k and that is explained in the equality there which says that the completion time is T sigma of 1 plus the completion time of the second job which is T sigma of 1 plus T sigma of 2 plus the completion time of the third job which is T sigma of 1 plus T sigma of 2 plus T sigma of 3 and so on up to the completion time of the nth job which is T sigma of 1 plus T sigma of 2 up to T sigma of n <sil=0.902> .PERIOD If we relate this summation by adding and subtracting a few terms we get the third term in the whole equality sequence which is viewed as 2 summations observe the first summation which is n plus 1 multiplied by summation of the processing times of the n jobs that is the first term minus summation k times t sigma of k that is the kth job the processing time of the kth job observe the first term is independent of the schedule and the second term really is very dependent of the schedule observe that this sum of completion times is indeed valid for every schedule sigma this is a very important thing <sil=0.999> .PERIOD So <sil=0.519> ,COMMA what we have done in this slide is to write down a close form expression for the sum of completion times for arbitrary schedule which we have called sigma and then we have observed that this sum of completion times can be viewed as 2 summations 1 that is independent of the schedule itself and the second one which is dependent on the schedule and there is a subtraction term there therefore <sil=0.464> ,COMMA as a second term increases the total cost becomes smaller <sil=0.937> .PERIOD So <sil=0.363> ,COMMA let us see what makes a second term to decrease let us see what makes a second term to actually increase and therefore <sil=0.352> ,COMMA reduces sum of completion terms completion times <sil=0.928> .PERIOD So <sil=0.531> ,COMMA let us see a property of an optimal schedule <sil=0.993> .PERIOD So <sil=0.389> ,COMMA let us imagine a schedule sigma and let us assume that there is an index x which is more than index y but the processing time for the job which is scheduled as sigma of x is smaller than the processing time of the schedule job schedule sigma of y in other words y is scheduled sigma of y is later than sigma of x but the processing time of sigma of y is larger than the processing time of sigma of x <sil=0.954> .PERIOD So <sil=0.452> ,COMMA let us try the most natural thing let us exchange the positions of the two jobs <sil=0.910> .PERIOD So <sil=0.555> ,COMMA in other words what do we do we exchange the position of the job in position sigma of y with the position of the job sigma of x and let us see how it changes the duration <sil=0.912> .PERIOD So <sil=0.643> ,COMMA let us see what happens we should just go back to the formula and observe that the terms just change by modifying the multipliers appropriately <sil=0.996> .PERIOD In other words we have written down an inequality which says that x times t of sigma of x plus y times t of sigma of y <sil=0.911> .PERIOD This is the contribution to the second term by these two jobs and when x change the position of these two jobs the contribution just becomes y times t of sigma of x plus x times t of sigma of y <sil=0.967> .PERIOD We now show that x times t of sigma of x plus y times t of sigma of y is smaller than the summation after swapping it that is y times t of sigma of x plus x times t of sigma of y <sil=0.933> .PERIOD This is very easy to see by the following sequence of expressions by just rewriting x times t x times t of sigma of x plus y times t of sigma of y <sil=0.995> .PERIOD This sequence of expressions actually shows that the exchange actually increases the value of the second term <sil=0.901> .PERIOD As a consequence of this it is clear that if we start off with an arbitrary ordering and if we identify a pair of jobs at sigma of x and sigma of y with the property that sigma of y is later than sigma of x and the time taken by the job is scheduled at sigma of y is more than the time taken by the job scheduled at sigma of x <sil=0.902> .PERIOD If we exchange these two jobs the contribution to the second term in the sum of completion times reduces and therefore we have a new schedule whose sum of completion times is strictly smaller <sil=0.989> .PERIOD Consequently the greedy algorithm is a very simple algorithm it says that the from the given set of jobs schedule the shortest duration job first <sil=0.975> .PERIOD That it is indeed an optimal algorithm follows from our analysis of the completion time that this schedule has a smaller completion time than any other schedule <sil=0.987> .PERIOD So <sil=0.607> ,COMMA we saw the notion of arguments <sil=0.642> ,COMMA these are inputs to the black box called the function <sil=0.999> .PERIOD When we talk about arguments <sil=0.585> ,COMMA there are two kinds of arguments <sil=0.942> .PERIOD There is a this terminology called formal arguments or a formal parameter <sil=0.983> .PERIOD So <sil=0.627> ,COMMA a formal parameter is a name that is used inside the function body to refer to the arguments and the function call is actually made with actual arguments or actual parameters <sil=0.975> .PERIOD So <sil=0.511> ,COMMA there is a name that you use for things within the function and you may have names which are different in the collar <sil=0.935> .PERIOD So <sil=0.557> ,COMMA the collar may have names for the parameters which are different from what is in the call E <sil=0.968> .PERIOD So <sil=0.485> ,COMMA the actual arguments are actually values that are assigned to the corresponding formal parameters <sil=0.965> .PERIOD This actual argument could be a constant or a variable or even a complicated elaborate expression <sil=0.922> .PERIOD So <sil=0.301> ,COMMA in our printf instead of giving the integers directly <sil=0.605> ,COMMA here instead of giving the integers directly <sil=0.390> ,COMMA we actually put an expression that is permissible <sil=0.915> .PERIOD And actual argument is evaluated and its value is and the value of that is copied to the corresponding formal parameter for the function <sil=0.993> .PERIOD So <sil=0.648> ,COMMA we will see this in a little more detail with the next example <sil=0.945> .PERIOD So <sil=0.339> ,COMMA let us say I have a small program which calculates the triangular number <sil=0.943> .PERIOD We saw this notion of triangular number in one of the earlier lectures <sil=0.923> .PERIOD So <sil=0.625> ,COMMA I have a main function and the main function has in main void <sil=0.945> .PERIOD So <sil=0.473> ,COMMA what this means is main is a function which does not take any parameters <sil=0.955> .PERIOD You say that by using the keyword called void <sil=0.975> .PERIOD So <sil=0.342> ,COMMA void means you are not using any input <sil=0.305> ,COMMA you are not taking any input and you are returning integer <sil=0.930> .PERIOD So <sil=0.358> ,COMMA calculate triangular number 10 <sil=0.999> .PERIOD So <sil=0.434> ,COMMA this is a function call and the function description is here <sil=0.989> .PERIOD So <sil=0.574> ,COMMA this program is actually missing the function prototype <sil=0.979> .PERIOD Sorry about that <sil=0.474> ,COMMA there should have been a function prototype which says void calculate triangular number of int <sil=0.994> .PERIOD So <sil=0.461> ,COMMA anyway <sil=0.979> .PERIOD So <sil=0.525> ,COMMA we have a function called calculate triangular number of 10 <sil=0.979> .PERIOD So <sil=0.322> ,COMMA this 10 is an actual argument because in the caller you have the value 10 <sil=0.970> .PERIOD This is the formal argument <sil=0.939> .PERIOD We call it by the name n <sil=0.931> .PERIOD The formal argument for calculate triangular number is n and i and triangular n b are two local variables <sil=0.981> .PERIOD So <sil=0.554> ,COMMA these are two local variables <sil=0.950> .PERIOD i is used for the iteration and triangular n b is used for the summation <sil=0.936> .PERIOD So <sil=0.338> ,COMMA this is a formal argument <sil=0.908> .PERIOD So <sil=0.647> ,COMMA n is a formal parameter 10 <sil=0.512> ,COMMA 20 and 50 are actual parameters and i and n b are local variables <sil=0.973> .PERIOD So <sil=0.607> ,COMMA this is a distinction that you have to keep in mind <sil=0.936> .PERIOD So <sil=0.474> ,COMMA even though there is one formal argument <sil=0.471> ,COMMA the actual arguments are actually changing <sil=0.985> .PERIOD So <sil=0.518> ,COMMA you notice this piece of code <sil=0.444> ,COMMA actual parameter is 10 at this function call <sil=0.399> ,COMMA the actual parameter is 20 for this function call and the actual parameter is 50 for this function call and the formal argument is always by the name n <sil=0.930> .PERIOD So <sil=0.305> ,COMMA let us see a little bit about arguments and local variables <sil=0.903> .PERIOD So <sil=0.410> ,COMMA the variables are actually defined inside a function <sil=0.995> .PERIOD So <sil=0.365> ,COMMA you go and look at this i and triangular n b are actually defined within the function <sil=0.955> .PERIOD Same thing in power <sil=0.557> ,COMMA we had i and p which are designed inside the function <sil=0.909> .PERIOD We call them what are called automatic local variables <sil=0.958> .PERIOD We call them automatic local variables <sil=0.911> .PERIOD The reason we call them automatic local variables is that they are automatically created by the compiler each time the function is called <sil=0.969> .PERIOD So <sil=0.611> ,COMMA the key thing to notice is that they are created each time the function is called <sil=0.933> .PERIOD The values that you have for these variables are local <sil=0.474> ,COMMA that is why we call it local <sil=0.943> .PERIOD So <sil=0.330> ,COMMA these are variables they are automatically created <sil=0.610> ,COMMA but they are local to the functions <sil=0.965> .PERIOD So <sil=0.625> ,COMMA the value of a local variable can be accessed only within the function in which the variable is defined <sil=0.910> .PERIOD So <sil=0.592> ,COMMA for example <sil=0.362> ,COMMA from this function <sil=0.579> ,COMMA I cannot directly use triangular n b or i <sil=0.961> .PERIOD So <sil=0.593> ,COMMA in fact <sil=0.451> ,COMMA this one is only printing the triangular number on the screen <sil=0.902> .PERIOD Let us say I wanted the triangular number <sil=0.901> .PERIOD It is not that I want to print it on the screen <sil=0.956> .PERIOD Let us say I want to use the triangular number <sil=0.418> ,COMMA then this function cannot be used directly because it is calculating triangular number <sil=0.901> .PERIOD It is printed on the screen <sil=0.458> ,COMMA but triangular number is a local variable <sil=0.993> .PERIOD It is printed on the screen and that is it <sil=0.997> .PERIOD You have not returned triangular n b here <sil=0.972> .PERIOD Therefore <sil=0.537> ,COMMA we cannot see the value first of all <sil=0.934> .PERIOD And there is no way to refer to triangular n b from the main function <sil=0.963> .PERIOD So <sil=0.491> ,COMMA the values of the local variables are all local to the function <sil=0.973> .PERIOD You can access it only within the function <sil=0.942> .PERIOD And if an initial value is given to the variable <sil=0.413> ,COMMA every time the function is called <sil=0.631> ,COMMA it is going to be assigned <sil=0.919> .PERIOD So <sil=0.307> ,COMMA this is particularly useful <sil=0.935> .PERIOD For example <sil=0.461> ,COMMA say let us say <sil=0.554> ,COMMA calculate triangular number of 10 <sil=0.997> .PERIOD So <sil=0.611> ,COMMA that is the first function call <sil=0.957> .PERIOD You calculate triangular n b <sil=0.965> .PERIOD At the end of this <sil=0.338> ,COMMA the value would have been 55 <sil=0.992> .PERIOD So <sil=0.418> ,COMMA we are adding 1 <sil=0.331> ,COMMA 2 <sil=0.403> ,COMMA 3 <sil=0.532> ,COMMA 4 and so on up to 10 <sil=0.996> .PERIOD That is 55 <sil=0.984> .PERIOD So <sil=0.416> ,COMMA let us say triangular n b is 55 <sil=0.916> .PERIOD The next time I calculate the triangular number <sil=0.451> ,COMMA since I have outsourced it <sil=0.630> ,COMMA I assume that you are going to take care of the initialization <sil=0.956> .PERIOD So <sil=0.513> ,COMMA when the function comes the next time <sil=0.468> ,COMMA since triangular n b is again initialized to 0 <sil=0.926> .PERIOD So <sil=0.408> ,COMMA the value of 55 is completely lost <sil=0.968> .PERIOD In fact <sil=0.615> ,COMMA the triangular n b is not even present once the first call returns before the second call <sil=0.443> ,COMMA the triangular n b and I are not accessible anymore <sil=0.997> .PERIOD So <sil=0.571> ,COMMA you have 20 <sil=0.967> .PERIOD When you go back here <sil=0.436> ,COMMA triangular n b is again created <sil=0.981> .PERIOD I is again created <sil=0.961> .PERIOD You initialize triangular n b to 0 <sil=0.908> .PERIOD You do the computation <sil=0.954> .PERIOD The result is printed on the screen <sil=0.915> .PERIOD And when you return from the function <sil=0.317> ,COMMA i and triangular n b can be thought of as something that vanishes also automatically <sil=0.976> .PERIOD So <sil=0.336> ,COMMA automatic variables are both created and destroyed automatically <sil=0.939> .PERIOD So <sil=0.407> ,COMMA the formal parameters are slightly different beast <sil=0.995> .PERIOD So <sil=0.394> ,COMMA let us look at this variable n <sil=0.978> .PERIOD So <sil=0.444> ,COMMA from the point of view of this function <sil=0.442> ,COMMA n is also a local variable <sil=0.995> .PERIOD It gets created every time the function is called and n gets destroyed every time the function returns from the <sil=0.624> ,COMMA so every time you return from the function <sil=0.402> ,COMMA the variable called n is destroyed also <sil=0.955> .PERIOD So <sil=0.535> ,COMMA formal parameters essentially behave like local parameters <sil=0.372> ,COMMA they are completely private to the function <sil=0.900> .PERIOD So <sil=0.429> ,COMMA let us look at how this sequence works <sil=0.940> .PERIOD So <sil=0.388> ,COMMA I have the main program <sil=0.962> .PERIOD The control control flow starts there <sil=0.970> .PERIOD You are ready to call calculate triangular number of 10 <sil=0.961> .PERIOD So <sil=0.384> ,COMMA at this point <sil=0.641> ,COMMA n i and triangular n b are all created <sil=0.962> .PERIOD This 10 <sil=0.605> ,COMMA the value of 10 was actually copied to n <sil=0.996> .PERIOD So <sil=0.323> ,COMMA think of each of these boxes as separate memory locations <sil=0.989> .PERIOD So <sil=0.601> ,COMMA 10 is already in some memory location <sil=0.565> ,COMMA 20 is in some memory location <sil=0.344> ,COMMA 50 is in some other memory location <sil=1.000> .PERIOD The value 10 is actually copied to n and then you go through whatever is supposed to happen <sil=0.911> .PERIOD And so <sil=0.590> ,COMMA that happens and then you return the value or you print the things on the screen and you return to the caller <sil=0.932> .PERIOD At that point <sil=0.446> ,COMMA so if you carefully watch the animation <sil=0.607> ,COMMA n i and triangular n b have all vanished <sil=0.955> .PERIOD So <sil=0.598> ,COMMA there is no way to access n or i or triangular n b anymore <sil=0.991> .PERIOD So <sil=0.420> ,COMMA then the function goes to the second <sil=0.434> ,COMMA the main function <sil=0.434> ,COMMA now moves to the second function call <sil=0.978> .PERIOD At that point <sil=0.645> ,COMMA again it goes to the first line of calculate triangular number <sil=0.944> .PERIOD Again you would create n i and triangular n b <sil=0.973> .PERIOD The value 20 gets copied and triangular n b would get the initial value of 0 <sil=0.992> .PERIOD I anyway gets initialized in the loop <sil=0.567> ,COMMA I becomes 1 <sil=0.996> .PERIOD Whatever work you have to do there <sil=0.499> ,COMMA that gets done and you return the control back to the main function <sil=0.906> .PERIOD And finally <sil=0.361> ,COMMA you have the last call and the same thing happens once more <sil=0.993> .PERIOD So <sil=0.510> ,COMMA this is something that you have to remember that every time a function is called <sil=0.383> ,COMMA you would create the variables which are local to the function as well as the formal parameters <sil=0.982> .PERIOD You do whatever work is going to happen there and when you return back from it <sil=0.584> ,COMMA all these local variables and the formal parameters are lost <sil=0.916> .PERIOD The only thing that can potentially be retained is the return value <sil=0.918> .PERIOD If the function had a return of a variable <sil=0.472> ,COMMA that value gets copied back to the right side of an expression <sil=0.944> .PERIOD So <sil=0.358> ,COMMA for the power function <sil=0.441> ,COMMA we return p <sil=0.953> .PERIOD So <sil=0.385> ,COMMA the value of p is comes to the right side of the expression and that can be useful for assignment to the left side namely <sil=0.647> ,COMMA num1 and num2 <sil=0.991> .PERIOD If you do not have a return of a variable <sil=0.535> ,COMMA all the calculations that you have done are completely lost <sil=0.957> .PERIOD All the variables that you declared are completely lost <sil=0.923> .PERIOD Maybe you printed something on the screen <sil=0.558> ,COMMA but you can never use the tenth triangular number in any calculation <sil=0.941> .PERIOD You can only print things on the screen with this function that we have <sil=0.900> .PERIOD So <sil=0.623> ,COMMA in this context <sil=0.491> ,COMMA it is good to understand the notion of lifetime and scope <sil=0.908> .PERIOD So <sil=0.488> ,COMMA lifetime <sil=0.362> ,COMMA so this is something that people get confused about very often <sil=0.970> .PERIOD So <sil=0.319> ,COMMA lifetime is the period of time when a memory location is allocated <sil=0.954> .PERIOD So <sil=0.630> ,COMMA if you go back to this example that we had earlier <sil=0.955> .PERIOD So <sil=0.412> ,COMMA the lifetime of i <sil=0.607> ,COMMA triangular <sil=0.452> ,COMMA n <sil=0.365> ,COMMA b and n are these variables are said to be alive only when this function is called <sil=0.987> .PERIOD Once the function returns <sil=0.501> ,COMMA you can treat them as variables that are dead <sil=0.967> .PERIOD So <sil=0.325> ,COMMA life of the variable is only between the function first line and the functions last line <sil=0.967> .PERIOD These variables and the formal parameters are dead otherwise <sil=0.907> .PERIOD So <sil=0.381> ,COMMA we have the notion of lifetime <sil=0.954> .PERIOD Scope is slightly different and it is an important concept to know also <sil=0.985> .PERIOD So <sil=0.358> ,COMMA scope is the region of program text where declaration is visible <sil=0.984> .PERIOD So <sil=0.461> ,COMMA we have not seen this in any detail earlier <sil=0.960> .PERIOD We will see that now <sil=0.964> .PERIOD So <sil=0.621> ,COMMA all the local variables and formal parameters are not only alive within the function <sil=0.451> ,COMMA their scope is also only within the body of the function <sil=0.923> .PERIOD So <sil=0.351> ,COMMA local variable i in function is different from any other variable i <sil=0.515> ,COMMA you declared anywhere else <sil=0.982> .PERIOD And formal parameter n is also different from any other n that you have declared or used anywhere else <sil=0.923> .PERIOD So <sil=0.383> ,COMMA it is not only that i and n are not alive outside there <sil=0.646> ,COMMA you are free to use i and n in other places in other functions including the caller <sil=0.906> .PERIOD So <sil=0.397> ,COMMA let us see a small example of what the scope is <sil=0.911> .PERIOD So <sil=0.551> ,COMMA let us first look at the main function <sil=0.947> .PERIOD It has a variable called n which takes the value 5 and you call f 1 of 3 f 2 which has no parameter and returns 0 <sil=0.957> .PERIOD So <sil=0.477> ,COMMA this is not really doing anything with n <sil=0.943> .PERIOD This example is only that to show you what the notion of scope is <sil=0.974> .PERIOD So <sil=0.407> ,COMMA as a control <sil=0.633> ,COMMA you will start with int n equals 5 <sil=0.915> .PERIOD So <sil=0.425> ,COMMA 5 gets a value of n and then you have f 1 of 3 <sil=0.930> .PERIOD So <sil=0.514> ,COMMA 3 is the actual parameter f 1 is the function name <sil=0.914> .PERIOD You go and look at f 1 <sil=0.366> ,COMMA f 1 expects a floating point called x <sil=0.960> .PERIOD So <sil=0.447> ,COMMA x is the formal name <sil=0.946> .PERIOD Here <sil=0.541> ,COMMA you have another declaration called int n equals 6 <sil=0.914> .PERIOD So <sil=0.478> ,COMMA you may wonder whether this n and this n are actually the same <sil=0.926> .PERIOD So <sil=0.574> ,COMMA the answer to that is they are not <sil=0.966> .PERIOD Remember <sil=0.333> ,COMMA whenever a function is called <sil=0.577> ,COMMA there are variables that are created <sil=0.906> .PERIOD So <sil=0.580> ,COMMA when you come inside <sil=0.451> ,COMMA you create a new variable called n and only this variable is seen in this function <sil=0.975> .PERIOD So <sil=0.500> ,COMMA here n equals 6 and you called f 1 with 3 <sil=0.960> .PERIOD So <sil=0.344> ,COMMA x is 3 and n is 6 and x plus n would be 9 <sil=0.903> .PERIOD So <sil=0.429> ,COMMA this print f percentage f would print floating point valued 9 on this screen <sil=0.998> .PERIOD Now <sil=0.397> ,COMMA the function would return back to the caller <sil=0.911> .PERIOD In this case <sil=0.413> ,COMMA you have f 2 <sil=0.971> .PERIOD f 2 does not have any parameter <sil=0.332> ,COMMA but when the function gets called <sil=0.410> ,COMMA you have float n equals 10 <sil=0.919> .PERIOD You again create a new variable by the name n <sil=0.962> .PERIOD The life of this variable n is only within this function <sil=0.917> .PERIOD You just print n equals 10 and when you come back here <sil=0.608> ,COMMA you have this return statement <sil=0.917> .PERIOD So <sil=0.638> ,COMMA at this point <sil=0.579> ,COMMA let us say between f 1 and f 2 <sil=0.522> ,COMMA if you printed n <sil=0.406> ,COMMA it would have been 5 <sil=0.972> .PERIOD After f 2 <sil=0.491> ,COMMA if you printed n <sil=0.450> ,COMMA it would have been 5 also <sil=0.967> .PERIOD This n and this n are not in the same scope as this n <sil=0.984> .PERIOD This n is local to this main function <sil=0.977> .PERIOD This n is local to this f 2 and this n is local to f 1 <sil=0.995> .PERIOD So <sil=0.458> ,COMMA x and n are local to f 1 <sil=0.934> .PERIOD They get created when f 1 is called <sil=0.542> ,COMMA they get destroyed when f 1 returns <sil=0.972> .PERIOD Similarly <sil=0.543> ,COMMA n gets created when f 2 is called <sil=0.532> ,COMMA it is destroyed when f 2 is returned <sil=0.928> .PERIOD These variable names are essentially local <sil=0.500> ,COMMA it does not interfere with what is there in the caller <sil=0.916> .PERIOD So <sil=0.616> ,COMMA in this case <sil=0.562> ,COMMA in fact <sil=0.415> ,COMMA this n was a floating point and this was an integer and this was an integer <sil=0.979> .PERIOD For all you care <sil=0.405> ,COMMA there may be another function where n is a character or even a pointer and so on <sil=0.489> ,COMMA it does not matter <sil=0.965> .PERIOD So <sil=0.352> ,COMMA within the same scope <sil=0.442> ,COMMA you cannot have two declarations for a variable <sil=0.925> .PERIOD But <sil=0.446> ,COMMA once you go to different scopes <sil=0.306> ,COMMA namely within across functions and so on <sil=0.331> ,COMMA you are opening a new scope <sil=0.545> ,COMMA you are allowed to declare new variable names <sil=0.924> .PERIOD So <sil=0.601> ,COMMA that is something that you have to keep in mind <sil=0.920> .PERIOD So <sil=0.457> ,COMMA one thing that we have done so far is we have seen what is called call by value <sil=0.954> .PERIOD So <sil=0.612> ,COMMA in C <sil=0.977> ,COMMA the function arguments are all passed by value <sil=0.929> .PERIOD Values are the arguments <sil=0.964> .PERIOD So <sil=0.458> ,COMMA the values contained in the actual parameters are copied to variables which are in the formal parameters <sil=0.949> .PERIOD So <sil=0.591> ,COMMA you have the actual parameters when you call the function <sil=0.483> ,COMMA the formal parameters get created and like any variable <sil=0.562> ,COMMA initially they do not have any values <sil=0.946> .PERIOD And the first thing when you have for a function call is automatically the actual parameters are copied to the formal parameters <sil=0.973> .PERIOD And the formal with the formal parameters <sil=0.352> ,COMMA you do all the local computations <sil=0.312> ,COMMA the value gets returned and those variables are destroyed <sil=0.939> .PERIOD So <sil=0.615> ,COMMA the modifications to the parameter variables do not affect the variables in the calling function <sil=0.937> .PERIOD So <sil=0.309> ,COMMA we already saw this example here also <sil=0.972> .PERIOD So <sil=0.345> ,COMMA n became 10 <sil=0.603> ,COMMA n became 6 and so on <sil=0.970> .PERIOD This has nothing to do with this n first of all <sil=0.931> .PERIOD And you have passed a parameter of 3 that was x here <sil=0.915> .PERIOD So <sil=0.431> ,COMMA this x is not changed in this example <sil=0.456> ,COMMA but even if you changed x <sil=0.396> ,COMMA the value 3 will not change <sil=0.916> .PERIOD So <sil=0.539> ,COMMA there is also something that you can do which is called call by reference <sil=0.954> .PERIOD So <sil=0.413> ,COMMA I want to show you the difference between call by value and call by reference <sil=0.926> .PERIOD When you say call by value <sil=0.627> ,COMMA we copy the contents <sil=0.620> ,COMMA but when you say call by reference <sil=0.593> ,COMMA we pass the reference or the address of the variables instead of the contents of the value <sil=0.926> .PERIOD So <sil=0.625> ,COMMA in fact <sil=0.385> ,COMMA you can think of this as passing the r values and this as passing the l values of the variables <sil=0.914> .PERIOD So <sil=0.628> ,COMMA let us see this call by value using an example <sil=1.000> .PERIOD We have p equals 1 q equals 2 and r equals 3 and I have a function called test <sil=0.941> .PERIOD So <sil=0.550> ,COMMA actually I am sorry this is a function prototype <sil=0.965> .PERIOD This cannot appear within this function <sil=0.996> .PERIOD It has to be outside and we have called s equals test <sil=0.911> .PERIOD So <sil=0.357> ,COMMA test equals p q r <sil=0.928> .PERIOD So <sil=0.326> ,COMMA this is something that should have been outside <sil=0.918> .PERIOD So <sil=0.460> ,COMMA it cannot appear within another function <sil=0.993> .PERIOD It should have been outside <sil=0.985> .PERIOD So <sil=0.378> ,COMMA this is correct <sil=0.993> .PERIOD We have a function prototype which takes three integers p equals 1 q equals 2 and r equals 3 and there is a fourth variable called s <sil=0.933> .PERIOD So <sil=0.520> ,COMMA this is the function prototype now <sil=0.946> .PERIOD You pass s equals test <sil=0.989> .PERIOD So <sil=0.392> ,COMMA you pass p q and r to test <sil=0.939> .PERIOD They are received by the variables a <sil=0.331> ,COMMA b and c <sil=0.955> .PERIOD So <sil=0.482> ,COMMA a <sil=0.645> ,COMMA b and c are local variables <sil=0.914> .PERIOD In this example <sil=0.537> ,COMMA a is incremented by 1 <sil=0.598> ,COMMA b is incremented by 1 and c is incremented by 1 <sil=0.904> .PERIOD So <sil=0.480> ,COMMA a would start with a copy of p which is 1 <sil=0.347> ,COMMA but it gets incremented <sil=0.937> .PERIOD So <sil=0.579> ,COMMA a would be 2 <sil=0.562> ,COMMA b gets a copy of q that is 2 and it is incremented <sil=0.973> .PERIOD So <sil=0.568> ,COMMA b becomes 3 <sil=0.555> ,COMMA c gets a copy of r which is 3 and it is incremented <sil=0.995> .PERIOD So <sil=0.610> ,COMMA it is 4 <sil=0.929> .PERIOD So <sil=0.353> ,COMMA a would be 2 <sil=0.334> ,COMMA b would be 3 and r would be 4 <sil=0.362> ,COMMA a c would be 4 and you add 2 plus 3 plus 4 <sil=0.919> .PERIOD So <sil=0.537> ,COMMA the result would be 9 and that is what is returned as s <sil=0.988> .PERIOD So <sil=0.515> ,COMMA s gets 9 that is something that is probably clear to you by now <sil=0.597> ,COMMA but what happens is p q and r do not change <sil=0.919> .PERIOD Remember <sil=0.625> ,COMMA we made a copy of p to a copy of q to b and copy of r to c <sil=0.991> .PERIOD We really did not do any changes to p q and r <sil=0.930> .PERIOD The variables a <sil=0.433> ,COMMA b and c changed <sil=0.376> ,COMMA they did not change p q and r <sil=0.981> .PERIOD So <sil=0.565> ,COMMA this is called pass by value <sil=0.964> .PERIOD So <sil=0.585> ,COMMA every time a function is called like this <sil=0.501> ,COMMA p gets a copy to a <sil=0.315> ,COMMA q gets a copy to b and r gets a copy to c <sil=0.975> .PERIOD So <sil=0.649> ,COMMA this is called pass by value or call by value <sil=0.902> .PERIOD In contrast <sil=0.439> ,COMMA there is something called pass by reference <sil=0.929> .PERIOD So <sil=0.343> ,COMMA in this slightly loaded example <sil=0.506> ,COMMA we have a few things <sil=0.978> .PERIOD So <sil=0.539> ,COMMA I have 2 integers x and y and let us say I want to find out what is the quotient of dividing x by y and what is the reminder of dividing x by y <sil=0.970> .PERIOD So <sil=0.409> ,COMMA these 2 are integers <sil=0.958> .PERIOD So <sil=0.395> ,COMMA when I do integer division <sil=0.576> ,COMMA I get a quotient and I get a reminder <sil=0.906> .PERIOD So <sil=0.622> ,COMMA I want to know both the quotient and the reminder <sil=0.983> .PERIOD So <sil=0.579> ,COMMA one thing that you have noticed is that functions cannot return multiple parameters <sil=0.932> .PERIOD So <sil=0.309> ,COMMA if you remember the basic prototype <sil=0.482> ,COMMA basic description or template of a function <sil=0.564> ,COMMA you can pass more than one inputs to it <sil=0.510> ,COMMA but you can only return one output <sil=0.916> .PERIOD That is clearly a restriction for this problem <sil=0.985> .PERIOD I want both the quotient and the reminder <sil=0.436> ,COMMA but if I write a function for it <sil=0.612> ,COMMA I can only get the quotient or the reminder <sil=0.447> ,COMMA but not both <sil=0.910> .PERIOD So <sil=0.623> ,COMMA to do that <sil=0.589> ,COMMA we have a small trick <sil=0.958> .PERIOD Here <sil=0.438> ,COMMA we are going to pass what is called passing by value <sil=0.959> .PERIOD So <sil=0.604> ,COMMA we have this function called q o rm that stands for quotient and reminder <sil=0.901> .PERIOD It takes 2 parameters <sil=0.327> ,COMMA numerator and denominator <sil=0.949> .PERIOD It takes 2 more parameters quotient address and reminder address and they are not integers <sil=0.351> ,COMMA they are pointer to integers <sil=0.938> .PERIOD So <sil=0.362> ,COMMA we have 2 pointers that are passed on and 2 integers that are passed on <sil=0.961> .PERIOD So <sil=0.421> ,COMMA num will get a copy of x <sil=0.311> ,COMMA then will get a copy of y and q o a d r will get a copy of ampersand of q o <sil=0.565> ,COMMA which means the address of q o is copied to q o a d r and address of rm is copied to rm of a d r <sil=0.948> .PERIOD But then <sil=0.412> ,COMMA now you have the addresses of quotient and rm <sil=0.914> .PERIOD Now <sil=0.448> ,COMMA if I do num by den <sil=0.308> ,COMMA you do integer division <sil=0.445> ,COMMA the value gets truncated <sil=0.496> ,COMMA but I can assign it to a memory location <sil=0.937> .PERIOD In this case <sil=0.361> ,COMMA I assign it to the location pointed to by q o a d r and num percentage then gives the reminder <sil=0.943> .PERIOD The reminder is computed and it is stored in the location address by rm a d r <sil=0.956> .PERIOD So <sil=0.475> ,COMMA q o a d r and rm a d r are both local variables <sil=0.596> ,COMMA but these are pointer variables <sil=0.963> .PERIOD So <sil=0.642> ,COMMA when you do star q o a d r <sil=0.491> ,COMMA you are not changing pointer <sil=0.548> ,COMMA but you are changing what is pointed to <sil=0.333> ,COMMA you have d reference q o a d r <sil=0.996> .PERIOD So <sil=0.322> ,COMMA the num by den <sil=0.509> ,COMMA the value is stored in the location that is pointed to by q o a d r <sil=0.957> .PERIOD When you come back here <sil=0.534> ,COMMA since q o a d r had a copy of q o and rm a d r had a copy of ampersand of rm <sil=0.307> ,COMMA the pointers were copied <sil=0.930> .PERIOD So <sil=0.455> ,COMMA at this point <sil=0.507> ,COMMA we already saw this <sil=0.398> ,COMMA when you manipulate things with pointers <sil=0.519> ,COMMA the memory locations are the same <sil=0.980> .PERIOD So <sil=0.426> ,COMMA q o and rm actually would have appropriate values from num by den and num percentage 10 <sil=0.940> .PERIOD So <sil=0.456> ,COMMA this does two things <sil=0.378> ,COMMA we did not really have to change c <sil=0.618> ,COMMA the language c to give us two return parameters or three return parameters and so on <sil=0.443> ,COMMA but still one parameter we are able to get things done <sil=0.997> .PERIOD Only that you have to pass pointers instead of passing values <sil=0.987> .PERIOD So <sil=0.401> ,COMMA we have passed references to q o and rm instead of passing the values of q o and rm <sil=0.370> ,COMMA because if you had passed q o and rm directly and if you had integers here <sil=0.439> ,COMMA you would get the local variable calculated <sil=0.408> ,COMMA but remember when they return <sil=0.530> ,COMMA since you have avoid those values get destroyed <sil=0.537> ,COMMA you will not see the appropriate values in the local copies <sil=0.440> ,COMMA but passing by reference takes care of that <sil=0.960> .PERIOD We will see this passing by reference in a lot more gory detail later <sil=0.464> ,COMMA especially in the context of arrays <sil=0.945> .PERIOD So <sil=0.544> ,COMMA this brings us to the end of this module <sil=0.532> ,COMMA in the next few modules we look at more details related to functions <sil=0.921> .PERIOD Hi <sil=0.635> ,COMMA welcome back <sil=0.901> .PERIOD We looked at functions and we looked at functions being called by the main program and so on <sil=0.996> .PERIOD So <sil=0.376> ,COMMA there is nothing which actually stops functions being called by other functions also <sil=0.952> .PERIOD But there is an important and interesting class of functions which are called recursive functions <sil=0.907> .PERIOD So <sil=0.325> ,COMMA these are functions which actually call themselves and this is actually a natural thing that happens in lots of mathematical equations and so on <sil=0.914> .PERIOD So <sil=0.487> ,COMMA it is an interesting thing to learn <sil=0.986> .PERIOD So <sil=0.628> ,COMMA I want to talk about the notion of recursion in this module <sil=0.920> .PERIOD So <sil=0.443> ,COMMA let us start with a very simple example <sil=0.999> .PERIOD Let us look at this notion of factorial of n <sil=0.960> .PERIOD So <sil=0.545> ,COMMA n factorial is defined as the product of the first n terms <sil=0.902> .PERIOD So <sil=0.568> ,COMMA formally n factorial is 1 times 2 times 3 times so on up till n <sil=0.912> .PERIOD So <sil=0.623> ,COMMA for example <sil=0.409> ,COMMA 3 factorial is 1 times 2 times 3 which is 6 <sil=0.965> .PERIOD 5 factorial would be 1 times 2 times 3 times 4 times 5 that is 120 and so on <sil=0.944> .PERIOD So <sil=0.615> ,COMMA if you want to write a small program to calculate factorial of a number that is not very hard <sil=0.902> .PERIOD So <sil=0.639> ,COMMA you have seen loops and you know how to do it <sil=0.901> .PERIOD So <sil=0.378> ,COMMA let us look at this little function here called fact <sil=0.990> .PERIOD It takes 1 parameter n and it has a result variable which is initialized to 1 and there is a loop iterator called i <sil=0.917> .PERIOD So <sil=0.630> ,COMMA the loop iterator runs from 1 to n <sil=0.986> .PERIOD You can see that and the result is just multiplied by itself <sil=0.909> .PERIOD So <sil=0.352> ,COMMA you take 1 and then multiply with 1 <sil=0.904> .PERIOD So <sil=0.471> ,COMMA that is in the result in iteration 1 then i becomes 2 <sil=0.920> .PERIOD You take 1 times 2 that is temporarily stored in result and so on <sil=0.918> .PERIOD So <sil=0.437> ,COMMA at the end of n iterations this loop will terminate and the variable result will have the corresponding factorial at that point you are ready to return it <sil=0.956> .PERIOD So <sil=0.510> ,COMMA there is a fairly straightforward and simple code and so we have seen this notion of function name the formal parameter n the return type int and actual return result and so on <sil=0.964> .PERIOD So <sil=0.377> ,COMMA one small issue this is result can only accommodate a certain value <sil=0.905> .PERIOD So <sil=0.632> ,COMMA integers in the real world are unbounded whereas <sil=0.449> ,COMMA integers in c programming is bounded to a certain large value <sil=0.938> .PERIOD So <sil=0.388> ,COMMA if you give a large enough n this program may actually give you incorrect result <sil=0.944> .PERIOD So <sil=0.628> ,COMMA I suggest that you go and try something like 40 factorial and 50 factorial and so on and see what the result is <sil=0.973> .PERIOD So <sil=0.395> ,COMMA you will be surprised at the result that you get but this is because the variable integer variables cannot accommodate results of indefinite size <sil=0.930> .PERIOD So <sil=0.421> ,COMMA there is one way in which you can look at this program which this problem you can look at n factorial as the product of n times n minus 1 factorial <sil=0.924> .PERIOD So <sil=0.593> ,COMMA this is a very natural and recursive way of defining n factorial <sil=0.959> .PERIOD So <sil=0.591> ,COMMA this is something that you might have seen in your school days <sil=0.939> .PERIOD So <sil=0.564> ,COMMA n factorial is defined as n times n minus 1 factorial for appropriate n <sil=0.955> .PERIOD So <sil=0.496> ,COMMA clearly n cannot be if n goes to negative <sil=0.951> .PERIOD So <sil=0.649> ,COMMA this thing keeps going on forever and so on <sil=0.936> .PERIOD So <sil=0.474> ,COMMA we will have to be careful about it but for positive numbers for positive integers n this seems to be working nice <sil=0.994> .PERIOD So <sil=0.541> ,COMMA let us say I want to take this idea and convert that to a program as the idea shows <sil=0.973> .PERIOD So <sil=0.440> ,COMMA I would like to do something like this return n times factor of n minus 1 <sil=0.920> .PERIOD So <sil=0.608> ,COMMA whenever I am going to call this factorial with variable n I am going to return n times factorial of n minus 1 <sil=0.983> .PERIOD So <sil=0.648> ,COMMA that seems to faithfully do what this mathematical description wants <sil=0.953> .PERIOD However <sil=0.370> ,COMMA as I said we cannot go on doing this indefinitely because at some point let us say I start with 5 <sil=0.947> .PERIOD 5 will go down to 4 <sil=0.405> ,COMMA 4 to 3 <sil=0.576> ,COMMA 3 to 2 <sil=0.601> ,COMMA 2 to 1 and so on and at some point it will become negative and then what do we do <sil=0.949> .PERIOD So <sil=0.460> ,COMMA we have this extra check if n equals 1 we return 1 <sil=0.974> .PERIOD So <sil=0.348> ,COMMA that is the base case for the recursion right even here you need a base case which defines 1 factorial as 1 <sil=0.974> .PERIOD So <sil=0.352> ,COMMA this is clearly very short and if you understand how functions can call themselves it is easy to understand also and it definitely uses fewer variables <sil=0.947> .PERIOD So <sil=0.319> ,COMMA the nice thing about that is it becomes very readable <sil=0.998> .PERIOD But the slightly messy thing here is that so you have fact and we looked at the control flow of programs <sil=0.952> .PERIOD So <sil=0.555> ,COMMA if main called fact we know what it does but then there seems to be a call to fact within fact itself <sil=0.996> .PERIOD So <sil=0.416> ,COMMA we need to understand how this is going to happen <sil=0.958> .PERIOD So <sil=0.345> ,COMMA let us look at this setup first <sil=0.955> .PERIOD So <sil=0.606> ,COMMA I have this program on the right side just for clarity sake and let us see we want to look at how this is going to work <sil=0.992> .PERIOD So <sil=0.608> ,COMMA I want to do factorial of 4 <sil=0.921> .PERIOD Let us say the main function called fact with 4 <sil=0.907> .PERIOD So <sil=0.567> ,COMMA this local this formal parameter n will copy the value 4 <sil=0.912> .PERIOD So <sil=0.478> ,COMMA n is now 4 <sil=0.961> .PERIOD So <sil=0.508> ,COMMA factorial of 4 you go and check if n equals 1 at this point n equals 4 <sil=0.957> .PERIOD So <sil=0.537> ,COMMA this condition is not true <sil=0.928> .PERIOD So <sil=0.575> ,COMMA it you have to return n times factorial of n minus 1 right <sil=0.917> .PERIOD However <sil=0.369> ,COMMA you have 4 which is n factorial of n minus 1 is not known yet <sil=0.975> .PERIOD So <sil=0.317> ,COMMA at this point you have to calculate factorial of n minus 1 which is factorial of 3 and then do this product 4 times that and only then you will be able to return the value right <sil=0.962> .PERIOD So <sil=0.390> ,COMMA it seems logical we we have 4 times some value that we need but we have not computed that yet <sil=0.977> .PERIOD But once it is computed I can multiply that with 4 and I will have the result of factorial of 4 <sil=0.948> .PERIOD I will be able to return the value right <sil=0.960> .PERIOD So <sil=0.570> ,COMMA but now that I have this fact of n minus 1 let us see how to do that <sil=0.918> .PERIOD So <sil=0.533> ,COMMA fact of 4 in in turn calls fact with the parameter 3 <sil=0.917> .PERIOD At that point factorial of 3 again you cook <sil=0.921> .PERIOD So <sil=0.572> ,COMMA n takes the value 3 now and this multiplication is pending and this value 4 has to be remembered <sil=0.981> .PERIOD So <sil=0.421> ,COMMA we will look at that in little more detail later but remember that this star this multiplication is pending as of now we cannot do it yet <sil=1.000> .PERIOD So <sil=0.437> ,COMMA we by by that time we get the factorial of 3 we can then multiply it <sil=0.985> .PERIOD So <sil=0.384> ,COMMA to find out factorial of 3 we call fact with within fact itself and again you check if n equals 1 at that point n equals 3 <sil=0.961> .PERIOD So <sil=0.443> ,COMMA 3 times factorial of 2 is required <sil=0.939> .PERIOD So <sil=0.410> ,COMMA we want fact of 2 again at that point I should remember that n is 3 and I need to do multiplication <sil=0.989> .PERIOD So <sil=0.341> ,COMMA there is a pending calculation and there is a value with which you have to do it <sil=0.971> .PERIOD But right now I am going to just go and look at how to compute fact of 2 <sil=0.926> .PERIOD So <sil=0.487> ,COMMA again if we go one step further it says take 2 and multiply with factorial of 1 <sil=0.913> .PERIOD But finally <sil=0.489> ,COMMA when you call this with factorial of 1 at that point n equals 1 and this condition is true if n equals 1 return 1 which means you are actually going to return from the function <sil=0.942> .PERIOD This else clause will not be looked at anyway because it is n equals 1 <sil=0.910> .PERIOD You are now ready to return from the function and what are you returning you are returning the value 1 <sil=0.920> .PERIOD So <sil=0.547> ,COMMA factorial of 1 is 1 <sil=0.971> .PERIOD So <sil=0.339> ,COMMA we have touched the base case of recursion at this point we know fact of 1 <sil=0.994> .PERIOD So <sil=0.501> ,COMMA there was this pending multiplication it was waiting on this factorial of 1 to be calculated <sil=0.941> .PERIOD So <sil=0.514> ,COMMA we return the value 1 and this 1 when you multiply by 2 factorial of 2 is 2 <sil=0.912> .PERIOD So <sil=0.333> ,COMMA what are all the pending things at factorial of 2 it has to it was remembering 2 and then this product was pending once the product is ready <sil=0.940> .PERIOD So <sil=0.529> ,COMMA once the other factor is ready <sil=0.924> .PERIOD So <sil=0.576> ,COMMA you have n time factor of n minus 1 let us say n equals 2 once factorial of 1 is ready you have to compute this product and that product remember has to be returned <sil=0.907> .PERIOD So <sil=0.641> ,COMMA now we have computed the product as 2 and this once that is computed as 2 you are now ready to return it and there was this version of fact where n was 3 it was waiting on factorial of 2 to be returned back <sil=0.942> .PERIOD So <sil=0.360> ,COMMA factorial of 2 is now 2 you are now ready to do the product which is 6 and you are now ready to return it back <sil=0.965> .PERIOD So <sil=0.361> ,COMMA if we continue doing this at some point we will go back to the very first function call that was made to fact <sil=0.923> .PERIOD So <sil=0.512> ,COMMA we called with 4 so 4 times now I have factorial of 3 ready which is 6 so 4 times 6 is 24 we do the product and we are now ready to return the so 24 actually gets returned back to the caller of fact of 4 <sil=0.988> .PERIOD So <sil=0.357> ,COMMA this is how this works <sil=0.995> .PERIOD So <sil=0.473> ,COMMA this may look like a little bit of magic right now but we will see in the next slide in detail how this actually works <sil=0.987> .PERIOD So <sil=0.390> ,COMMA the calling version whenever it has spending work right it will just as though it will suspend itself and it makes a so it passes the control to the new function once the return value comes back it will do the pending computation <sil=0.950> .PERIOD But during that time the caller needs to remember the values so once the return happens you get a value from there you have to remember what computation has to be done and on what value you have to do this computation <sil=0.921> .PERIOD So <sil=0.309> ,COMMA this is something we will look at in detail in the next slide <sil=0.908> .PERIOD So <sil=0.524> ,COMMA let us see how recursive function calls actually implemented <sil=0.929> .PERIOD So <sil=0.591> ,COMMA we already know with respect to functions that all automatic local variables and formal parameters are created every time you call a function <sil=0.972> .PERIOD So <sil=0.369> ,COMMA we saw this in in an earlier module that every time a function is called you have a new avatar of the variables they get used up during the function and when you return from the function all these actual actual parameters and automatic local variables are all destroyed also <sil=0.987> .PERIOD So <sil=0.561> ,COMMA this is not just true of non recursive functions it is also true of recursive functions <sil=0.974> .PERIOD So <sil=0.463> ,COMMA even for functions like fact this notion is true let us see what the implication of that is right <sil=0.955> .PERIOD So <sil=0.649> ,COMMA whenever you have these automatic variables and formal variables they are actually stored in an area called stack <sil=0.905> .PERIOD So <sil=0.645> ,COMMA this is something which is actually a region in memory and every function call will push what is called an activation record on the stack <sil=0.934> .PERIOD So <sil=0.389> ,COMMA the activation record contains what are the different variables that are local to the function and so on and the activation record gets pushed onto the stack you pass the control to the caller passes the control to the call E and the call E does various calculations and when a function called returns the activation record is removed from the top of the stack <sil=0.943> .PERIOD So <sil=0.531> ,COMMA all this may sound like theoretical mumbo jumbo let us see a pictorially what it is doing <sil=0.972> .PERIOD So <sil=0.321> ,COMMA let us say I called factorial for n equals 3 right <sil=0.947> .PERIOD So <sil=0.584> ,COMMA I called fact of 3 and the fact as a function creates an activation record right <sil=0.901> .PERIOD So <sil=0.347> ,COMMA at that point we have n equals 3 and we do not know the result yet right <sil=0.989> .PERIOD So <sil=0.595> ,COMMA this is the state in the beginning <sil=0.937> .PERIOD Now <sil=0.569> ,COMMA we call n times fact of n minus 1 <sil=0.914> .PERIOD So <sil=0.365> ,COMMA n is already saved so that is there in your record result is unknown we will have to come and update the result later <sil=0.935> .PERIOD But now you make a call to fact of 2 <sil=0.985> .PERIOD So <sil=0.306> ,COMMA to do that it actually creates another activation record with n equals 2 <sil=0.979> .PERIOD So <sil=0.405> ,COMMA remember it is not overwriting the value 3 here in the current activation record <sil=0.952> .PERIOD It creates a new record and for the new record you know the value of n because fact of 3 called fact of 2 <sil=0.951> .PERIOD So <sil=0.346> ,COMMA n equals 2 but fact of 2 the result is unknown so it is pending <sil=0.978> .PERIOD Let us say at some point you called fact of 1 you create another activation record <sil=0.950> .PERIOD So <sil=0.517> ,COMMA you have this activation record n equals 1 and at this point the result is known right <sil=0.905> .PERIOD So <sil=0.466> ,COMMA this actually this activation record assumes that we go all the way down to 0 <sil=0.985> .PERIOD 0 factorial is also 1 <sil=0.972> .PERIOD So <sil=0.613> ,COMMA instead of n equal to 1 if you are checked n equal to 0 and return 1 this example shows that <sil=0.907> .PERIOD So <sil=0.383> ,COMMA n equals 0 returns 1 and when that returns n equals 1 times whatever return from the previous activation record the result was 1 <sil=0.960> .PERIOD So <sil=0.382> ,COMMA 1 times 1 is saved as the result for fact of 1 and this returns to its collar <sil=0.921> .PERIOD Its collar is expecting to compute its result this collar is expecting the result from the collar and it has this variable 2 it has to multiply the result from the collar and the 2 and put that here <sil=0.910> .PERIOD So <sil=0.387> ,COMMA you have that and now the collar is going to return 2 the collar is waiting with another variable n which is having a value of 3 it will take that multiply it and put it in the result and finally <sil=0.363> ,COMMA whoever called fact of 3 will return with a value of 6 <sil=0.904> .PERIOD So <sil=0.313> ,COMMA that is how it works right <sil=0.934> .PERIOD So <sil=0.513> ,COMMA the basic premise in this thing is you have what are called activation records <sil=0.967> .PERIOD So <sil=0.619> ,COMMA the activation records are just copies of all the variables that are local to a function <sil=0.944> .PERIOD If a function calls itself the activation record is kept and then you create a new activation record with new variables n and result and you compute things there and when you return you destroy the activation record and the result the return value is the only thing that is passed on to the collar <sil=0.933> .PERIOD So <sil=0.564> ,COMMA I hope this setup was clear <sil=0.960> .PERIOD So <sil=0.528> ,COMMA we will use this notion of recursion in solving this other problem <sil=0.958> .PERIOD So <sil=0.323> ,COMMA I want to look at a recursive way of solving power of m comma n we have already done this using an iterative setup let us say I want to think about it recursively <sil=0.921> .PERIOD So <sil=0.626> ,COMMA let us do this on a piece of paper <sil=0.929> .PERIOD So <sil=0.487> ,COMMA what we are going to do is we are going to look at a recursive way of doing power of m comma n <sil=0.953> .PERIOD So <sil=0.510> ,COMMA we called this base and n earlier so <sil=0.515> ,COMMA I am going to call it m for now <sil=0.985> .PERIOD So <sil=0.630> ,COMMA earlier what we did was this <sil=0.958> .PERIOD So <sil=0.318> ,COMMA to compute m power n we did something like this we did m times m times m times so <sil=0.513> ,COMMA on m and this you need n of those <sil=0.990> .PERIOD So <sil=0.610> ,COMMA actually what you are doing is you are doing n minus 1 multiplications <sil=0.949> .PERIOD So <sil=0.591> ,COMMA this is the key thing you are actually doing n minus 1 multiplications <sil=0.984> .PERIOD So <sil=0.530> ,COMMA let us take a little while and think about whether we really need n minus 1 multiplications <sil=0.944> .PERIOD So <sil=0.467> ,COMMA that is this nice recursive way of doing power of m comma n <sil=0.945> .PERIOD So <sil=0.451> ,COMMA I will take a specific example and show how this thing works <sil=0.980> .PERIOD So <sil=0.342> ,COMMA let us say I want to compute 3 raised to the power of 13 <sil=0.993> .PERIOD So <sil=0.550> ,COMMA I could always look at computing 3 power 12 and then multiply by 3 or 3 power 11 and then multiply by 3 twice and so on <sil=0.902> .PERIOD But one nice way to do this is take 3 power 13 and split half split 13 into half <sil=0.927> .PERIOD So <sil=0.567> ,COMMA 13 by 2 is 6 <sil=0.999> .PERIOD 5 <sil=0.969> .PERIOD Let us look at the smallest integer so <sil=0.385> ,COMMA the integer which is lesser than n by 2 <sil=0.968> .PERIOD So <sil=0.615> ,COMMA n is 13 let us look at the integer that is just less than n by 2 <sil=0.960> .PERIOD If n by 2 is an integer we will keep that itself <sil=0.926> .PERIOD So <sil=0.394> ,COMMA what is that 13 by 2 is 6 <sil=0.922> .PERIOD 5 the integer that is smaller than that is 6 let us start with 6 <sil=0.981> .PERIOD Let us say I am able to compute 3 power 6 right <sil=0.974> .PERIOD I have to do some computation it is not going to come jump right into our lap <sil=0.978> .PERIOD We need to compute 3 power 6 <sil=0.469> ,COMMA but then if I have 3 power 6 and I can multiply that with another copy of 3 power 6 and if I now multiply that by 3 this is actually 3 power 13 <sil=0.948> .PERIOD 