so this is correct right
so 3 power 13 is 3 power 6 into 3 power 6 into 3
so what have we really done
we still have 2 multiplications
so and instead of looking at 3 power 12 into 3 3 power 1 right we have it as 3 power 6 into 3 power 6 into 3
so what is the big deal
 so what we are going to do is we are going to compute 3 power 6 right but if i am going to compute 3 power 6 this product we can think of it as a pending calculation that we have to do
so i am going to compute 3 power 6 somehow when i get that computed i still have to multiply that by something else
so there is pending computation right
so we will do the pending computation later
so we have 3 power 6
now how do you compute 3 power 6
 so to compute 3 power 6 i am going to write it as 3 power 3 into 3 power 3 right
so i have used the same idea i have taken 6 divided that into 2 divided that by 2
so i have 6 by 2 which is 3 and i am going to calculate 3 power 6 as the product of 3 power 3 and 3 power 3
now again i do not have 3 power 3
so i will keep this as a pending calculation right
i am going to compute 3 power 3
so to do that i will have 3 power 1
so 3 so this exponent here 3 if i divide that by 2 which is 15 i look at then it is just smaller than that which is 1 3 power 1 into 3 power 1 and this time the exponent is odd
so it is not so you have to take care of the fractional part also
so remember 3 by 2 is 15 if i only do 3 power 1 by 3 power 1 i get 3 squared not 3 cube
so i still need to do a multiplication by 3 and to compute 3 power 1 i am going to look at how to do that
so we know that any number raised to the power 1 is n itself
so m raised to the power 1 is m therefore we have 3 right
so now this gives us in some sense a very nice and recursive way of doing it right
so that is the recursion here
so the recursion comes from the fact that if i have 3 power 6 i am going to call
so for computing 3 power 13 i am going to call 3 power 6 to compute 3 power 6 i am going to call 3 power 3 to compute 3 power 3 i am going to call 3 power 1 to compute 3 power 1 i am like it is just any number raised to the 1 i do not have to call the same function once more instead i can have this base case that m power 1 is m that is what we have used here
now let us say we actually did that
so to compute 3 power 3 we wanted 3 power 1 but we got that by making another function called to factorial it returned 3 right
so we got 3 now
now what do we do this 3 we got 3 power 1 we still have some pending work right
at this point what is the pending work i have to calculate 3 power 1 and 3 need not be calculated
so 3 power 1 and 3 i have to take a product of that multiply that with the current product that i got which is 3 itself
but one nice thing is that instead of making a function call to compute 3 power 1 we just got 3 power 1 right
we just got 3 power 1 by we made a function call for 3 power 1 we got the return result as 3 why do not we actually use that right
so what happens now is instead of making another call to compute 3 power 1 since we just got the value 3 for 3 power 1 i will not use 3 power 1 i will instead use a copy of this right which is 3 itself now i have to do 3 times 3 times 3 the result is 27 and this 27 gets returned back to its caller right
so 3 power 3 becomes 27 and i have to do some pending computation the pending computation is compute 3 power 3 and multiply that with whatever value i get right
but i just computed 3 power 3 now i will not call the function once more to get it i will just use a copy of this which is 27
i still have to do this pending multiplication
so i have 27 times 27 that would be 729 right and that gets returned here right
so 3 power 6 is now 729 i want 3 power 6 again but again i will do some computation i will just i just computed 3 power 6 i will use 729 here and i still have these pending multiplications this and this to be done
so eventually i will do 729 times 729 times 3 right and that is the value of 3 power 13
so let us look at the number of multiplications that we did right
so to do 3 power 13 we did 3 power 6 into 3 power 6 into 3
so that requires 2 multiplications right if i know 3 power 6 i have to do only 2 multiplications
to do 3 power 6 we did 3 power 3 into 3 power 3
so that required only 1 multiplication to do 3 power 3 we did 3 power 1 into 3 power 1 into 3
so that required 2 multiplications and to do 3 power 1 we do not have to do any multiplication we will use the base case of recursion that m power 1 is m we will use that directly
so that requires actually 0 multiplications
so if you add all of this up 2 plus 1 plus 2 right that is actually 5 we only did 5 multiplications as opposed to doing it as 3 power 13 if i had done it as 3 into 3 and so on right this would have required 12 multiplications
so clearly 5 multiplications is better than 12 multiplications
so i want you to go and think about what is really happening here if it is instead of 13 if i had used 20 if i use 25 and so on
i want you to think about what number of multiplications you will need if you did it using this way versus what number of multiplications you would need if you have done something like this
so go and think about it you will also see how to write a so how to analyze this algorithm and how many steps it takes and so on in a later lecture
but let us get back to how to write a program for this because that is the thing that we wanted now how do you write a program to compute power of m comma n
so i have written this simple program here to take care of this i have written a function called power it takes base and n as the 2 parameters as it was before and we have in p we had this earlier also right
so instead of writing an iterative way of doing this we have a recursive way of doing this if n equals 1 return base right
so this base case takes care of the fact that m power 1 is m right otherwise what i am going to do is i am going to compute p as power of base comma n by 2 right and if n is odd for example in 13 n is odd
so i need to take 3 power 6 and 3 power 6 and multiply that by 3 once more that is what you get here
so this is p times p times num if n is even then you have only p times p for example in here for to compute 3 power 6 it is enough to have computed 3 power 3 and reuse the 3 power 3 you would get 3 power 6 right
so one thing that you have to probably recollect is that n by 2 if n is an integer will truncate the decimal value it returns only an integer
so 13 by 2 is only 6 it is not 65
so 13 integer divided by 2 integer is 6 it is not 65
so now let us see how this whole thing would have worked power of 3 comma 13 right
so n equals 13
so this check would not have been true p would get power of 3 power 30 3 power 6 because n by 2 is 6 you call power of 3 power 3 comma 6 power of 3 comma 6 would transfer control to power again with n equal to 3 sorry n equal to 6
so for n equal to 6 n is not equal to 1 that would have called power of 3 comma 3 power of 3 comma 3 would have called power of 3 comma 1
so when n equals to 1 you have this return base so it would have just returned 3
so that is going to come back where n equals where n was 3 it will come back here right
so you would have computed 3 power 1
now you check if 3 percentage 2 is 0 3 percentage 2 is not 0 it is odd number
so we are looking at this exponent for this exponent it is an odd exponent
so i have to take 3 times 3 power 1 times 3 power 1 times 3
so that gives 27 it returns back here p becomes 27 for the case where n equal to 6 right
so 6 percentage 2 is actually equal to 0
so you do 3 power 3 into 3 power 3 which is 729 right and then you return to the case where actually n was like 13 for when n was 13 we called any power of base comma 6
so you would have received 3 power 6 you take that as p multiply that by p and by 1 more value of num that gives you 159 4323
so this is the basic idea of recursion
so clearly for every recursive function at some point you should not call the function anymore
so you have if n equals to 1 you return just the base without calling the function anymore
however if n is greater than 1 you will call the function at least once more right
so this is the basic idea behind recursion
so you can think of it as in some sense even for induction we do this right for proof by induction we say this is the base case for induction and from there on we keep building things you can think of recursion in a similar way right
so there is this base case and then you are building something on top of it
if you do not have a base case this program would be incorrect
so we saw 2 kinds of recursive functions namely factorial and power and this is a very powerful setup because once you know recursion right there are several things that you can do very easily and you can write programs very easily you do not have to think about doing them in an iterative manner
but you have to remember a few things about recursion
the first thing is recursion must end at some point of time
if function f calls itself and it calls itself and so on it cannot go on forever
if you if you do that then the program is never going to terminate
so it can be a problem
so you should have some condition inside any recursive function to terminate recursion you should not call the function once more from the base case
so for that go and think about what would happen if the check for n equal to 1 was not there for factorial we just did return n times fact of n minus 1 if you have done that see where you will stop
so it is not that recursion is a silver bullet it is not going to be useful every time sometimes loops are very straightforward to use
so you should see where to use loops and where to use recursion
so in general what you have is recursive recursive functions are actually quite elegant it is very simple to write you can take any mathematical formula it is usually recursive you take that and write it down right it is very elegant
but in general it is less efficient
so it recursive functions you should take more time and if you are not careful it can take a lot more time that this writing loops to do the same thing
and of course in recursive functions you have to take care of the base case
so there are several other things that you can write using recursion
so one classical example is you can do what is called n choose r
so let us say i want to do n choose r recursively i can use n choose r minus 1 plus n minus 1 choose r minus 1 right this is a recursive definition for n choose r
so out of n objects if you want to choose r objects what are the number of ways in which you can choose them right
so this is clearly recursive right
so n choose r uses n choose r minus 1 plus n minus 1 choose r r minus 1
so all these different things can be actually done with recursion
so that brings us to the end of this module
thank you very much
so in the last class we learnt how to analyze the complexity of algorithms
now we will take some somewhat more serious examples
we will take the problems of sorting and searching you may have already learnt that selection sort bubble sort insertion sort in your college and quick sort and merge sort or faster algorithms
so what we will do is we will take one linear sorting algorithm which is selection sort and then we will look at quick sort first and then we look at some searching algorithms also
so actually i have given an array here what is the objective you have an array which is unsorted and the objective is to produce an array that is sorted
i just started the indices from 1 to a 8 here just to in although you can see it starts from 0 through 7 just for when you look at the represented as a set of numbers in pseudo code you write it starting from index 1 and you want this output
whereas in searching what do i want to do i have given a sorted array and given a key 12 let us say and i want to find out whether the key is present in the array or not
it should return the location where the particular key is present in this example for example when i have given key 12 here it should return the index 4 on the searching example
so the selection sort algorithm is a very simple algorithm and i have used again the swap to do this it is not required though but nevertheless it is not very efficient
let us say i have an array like this i am just taking some arbitrary array what you do in selection start let us say this was 10 or 25 26 12 28 and 7
i have written it a little inefficiently in the piece of code here does not really matter
so start with this and then i compare this element with all the elements in the array
so i have a pointer i here a pointer j goes to the entire array then i find out which is the most minimum element and i put that element in the first position
so 2 goes here and 25 10 6 12 13 8 7
i have written a slightly inefficient version in the nodes because whenever i see 2 numbers which are the smaller number is seen i just exchange them that is not required actually you just need to find the location of the smallest element
so now i know that the most minimum element in this is the first position next what do i do i start with this element
so this is my pointer i have the pointer j which again goes to the length of the array finds the most element element this is 6 over here put 6 here and 25 this here
so you get the idea
so repeat this process until what happens finally the last 2 elements for example
so initially it is being this j loop for example goes from let us say index 1 2 3 4 5 6 7 8 the first time the j loop is executed 7 times next time it is executed 6 times and so 1 until it for example for j equal to until it becomes the size of the array which we need to process becomes 1 we have to keep repeating this
so basically if you look at depth for example next after this 2 and 6 have been processed we are starting here and then i compare with these elements and i find 8 is the smallest element 2 6 8 to be here 25 to well 13 10 and 7 is what you will have
so 3 elements are already sorted and then you look at this part of the array again j goes from this point until n i keep repeating this process
so what happens is the size of the array which needs to be sorted keeps on decreasing from iteration to iteration and the size of the sorted array also it gets incremented by 1
but notice that the time that i am going to take the first time i am making n minus 1 comparisons then i am making n minus 2 comparisons n minus 3 comparisons and if i count through all of them until finally i make 1 comparison the time complexity of this algorithm is going to become order n squared where n is the size of the input what is the size of the input here is the length of the array
so i just given this program in c over here
so notice this is comparison assignment and increment i say order 1 this is order 1 all these are order 1
but what happens is this slope for example if you write it in terms of time complexity it is order n again here i have 2 program segments this assignment takes order 1 and this takes order n therefore it is like a sum rule it becomes order n and then this for loop is executed order n times
so therefore it becomes order n squared
so this is the program of the form p 1 into p 2 into p 3 out of most for loop is p 1 in more for loop is p 2 and then within that there is a program p 3
so this is how you compute the time complexity of selection sort this is a bit inefficient
so what we do is we do a slightly different algorithm called the cubic sort algorithm and what we do in the quics sort algorithm is the following we do it a little differently start out with this and what we say is let us start with 2 points we define what is called some pivot element just for convenience i am going to take the fourth element as the pivot element let me call it the pivot element then you have 2 pointers i and j
then what do we expect the pivot element is 6
so what you do is you keep moving the pointers i and j until you come across an element which is larger than the pivot element on the left hand side and on the right hand side you come across with until you find an element which is smaller than the pivot element
so initially itself you are having this then what you do is you simply exchange them
when i exchange these 2 i will get here 7 25 26 12 13 8 and 10
next what do i do i move forward 25 is still larger than is larger than 6 and 8 is the same size is larger than 6
so i ignore this i keep moving forward and what do i find here actually 6 for example it is not smaller than 6 but it is not larger than 6 either
so what i do is 25 will move here and 6 will come here then i come across this and clearly this is smaller than 6
so i leave it as it is now what this does is divides the array into 2 parts where 1 part consists of elements which are less than or equal to 6 and another part consists of elements which are larger than 6
then on each part again i repeat the same process find the pivot element again and then move the make the movements for example here again pivot will be 6 then notice that 7 is larger than 6 and 2 smaller than 6
so 2 comes here 7 goes here i repeat this then again what happens the array will get divided into 2 parts then again i stop when the array size becomes 1
that is what the or the pointers cross for that matter and it is exactly what is being done every time over here
so what we are doing is left is less than j
so basically we have 2 parts here left and right of the array are past us argument to the quick sort algorithm
i is assigned to left j is assigned to right you we are choosing the pivot element as a middle element here this need not necessarily be true
now what are we doing when array i less than x i am incrementing the array i then while x less than array j i am decrementing it then if i is less than or equal to the 2 pointers of not crossed then what are you doing we are performing an exchange over here then we decrement and this and what are we doing until the 2 pointers i and j cross because once you cross that means i have processed the entire array once then what do we do if left is less than j that means the number of elements is more than 1 then i call quick sort again with the new left value a new j value similarly i call quick sort again with the new i value and the new right value
so when i keep doing this if the array is very if the quick sort algorithm is very good then what you will find is the array here for example of size 8 will get divided into 2 parts of size 4 which will get divided into 2 parts of size 2 which will finally get divided into 1 element arrays and the algorithm will terminate
so what you see is that this other the selection sort was an n squared algorithm but here what you are going to see is the this quick sort algorithm is order n into log n let us see why this happens in each this let us see the first time i am looking at the array this is a second time the third time the fourth time assume that it is an array of size 8
so first time i am looking at the array i am looking at an elements then it divided into 2 parts 4 and 4 then again for example these 4 elements of the process these 4 elements also have to be processed the next 2 elements again all the 8 elements have to be processed and here finally all the 8 elements
so when you look at what is happening is that the depth of this recursion how many times the recursive call is going to be executed is only log n and every recursive call means i am processing all the n elements therefore the time complexity is order n log n of this quick sort algorithm
there are other sorts like the merge sort quick sort of course has a worst case type grompless t of order n squared will see why
so for example what we do is just as we saw the recurrence equation we write the recurrence equation let us say the best case t of n is divided into 2 t n by 2 plus c n because all the n elements of process t of 1 is equal to d
so in general the quick sort analysis it divides into 2 parts t of i and t plus n and t of n minus i remember in the example we had one array of size 3 and another array of size 5 this is what it will be
so where is case what can happen the depth can become every time it divides the array into 2 parts such that the only it divides into 2 parts as there are n minus 1 elements and 1 element and this again let us say it divides into 1 element n and minus 2 elements then this depth will go down up to n and the time complexity instead of being order n log n will become order n squared
so this is about the sorting algorithms that we have looked at now we look at searching we look at simple linear search and binary search what are linear search now we have an array which is already circuit going back to this example that we have here we have a sorted array we are giving a key and we have to find the location of the key in the array
so let us do linear search
so what are we what am i going to do while i less than n and not found if i are if i equal to key found equals 1 else i plus plus return i return found basically telling you the key is found or not found
so the this is a very easy program of course it is not capclizing on the fact that the array is already sorted because i could have also checked if i the array is greater than key and you could have also existed but nevertheless in the worst case if i am using this called a linear search algorithm i have to search through all the elements in the array let us even if it sorted 2 10 15 16 30 35 and 40 let us say and i am looking for the element 40 then you have to process you to check with every one of these elements whether the key for keys there or not
therefore the time complexity in this case notice that there is a while block i less than n order 1 order 1 all these are comparisons are order 1 assignment is order 1 increment is order 1 but the while block for example this is a program of the kind p 1 into p 2 and this runs n times therefore the complexity is order m
all right the there is another better way of doing it if the array is already sorted and this is the binary search algorithm and the idea is basically the following what we do is let us say i have sorted array like this what we do is we divide the array into 2 parts let us say this is 1 2 3 4 5 6 7 and 8 find index of the milling element this is 1 plus 8 by 2 which is equal to 4 and then let us say i have given the key 12 i compare it with this middle element clear it is less than 12 that means it is not likely to be found in the right of the array it is likely to be found only in the left of the array
so what we do is that means i can restrict my search to only this part
so what do we do next now we divide this part again team 16 into 2 parts what is the middle part now 10 i compare it with 10 it is larger than 10 therefore it must be only in this part and what is this now this indices are 3 and 4 therefore where is the middle element now i compare it with 15 and clearly the number is less than 15 and it is not there in this part therefore the key is not found in this array
so how many times did we execute it now the first time i divided into half then again we divided into half and we divided it a third time
so what happens is in this particular example we find that binary search is executed actually only log in times let us see this
so here again remember how we get complexity analysis order 1 here comparison is order 1 is 3 is greater than the adder of the middle element when we doing binary search this is going to take order log in time and here this again is going to take order log in time k equal to lower than i am just returning back location and so on and so on
so each recursive call divides the order into 2 this recursion is what makes it log in because going to be executed log in times the recursion terminates when the array size becomes 1 and the number of recursive calls is log in therefore time complexity is order log in to the base 2 as i said best is to draw the recursion tree whenever you have recursive algorithms to solve for
so basically what did we see here array got so i started out with 8 then it goes to 4 then it goes to 2 this comes 1
so basically 1 2 3 4 my n is 8 therefore it is order of log of 8 to the base 2
so this is the number of computations
so this is how you solve the time complexity of programs we looked at recursion we looked at sorting we looked at searching algorithms and we have analyzed the time complexities
so we are now ready basically that we have also learnt the basic data types and the basic control structures that are there on programs you did it in the c programming part and i just reinforced it in this part of the course of quick reinforcement and basically now next what we are ready to do is how do i combine all these small data types like float integer car array and functions to solve better problems
can i think of a nice data organization which will enable me to solve the problems better and that is the part on abstract data types which we will talk about
so we will start with this in the next class
so let us move ahead to a very closely related topic which is polynomial evaluation where we need similar tricks to improve the efficiency of evaluating polynomials
what are the polynomial which you see here which is p of x which suggests that the name of the polynomial is p and x is a variable and the polynomial is a n x power n plus a n minus 1 x to the power of n minus 1 all the way up to a 2 x square plus a 1 x plus a naught
so this is a polynomial of degree n which means that the variable x occurs as x power n and a 0 a 1 to a n are coefficients
as you can see there is an example here the example is a quadratic polynomial
in other words a polynomial of it is a quadratic polynomial which means the polynomial of degree 2 and the algorithmic exercise is an extensively used algorithmic exercise though it looks extremely simple
input a polynomial given a polynomial p of x as input and a value v for x x is given a value v the challenge is to output the value p of v
so for example let us take the given polynomial and let us say v equals 2 in which case we have to compute 2 multiplied by 2 square minus 3 multiplied by 2 plus 1
and this is 8 minus 6 plus 1 which is equal to 1
observe that there are many ways of evaluating this polynomial and the most simple way of evaluating this polynomial is the following iterate a algorithm where you evaluate the formula evaluate the polynomial from right to left
you have to evaluate the polynomial from right to left
what do i mean by right to left
 you start off in the i th iteration for i is equal to 0 you take the value a 0
and this is the value that you have computed
for i is equal to 1 you take the value x multiplied by the value a 1 and perform an addition
in the iteration number 2 you take the value x you multiply it by x again which is gives you x square store this and keep it with you or store it in a temporary variable multiply it this by a 2 and add the value that you have computed so far
and in iteration number 3 you take the value of x square that has been computed in the previous iteration multiply it by x you compute x cube multiply it by a 3 and perform an addition
this is what i mean by evaluate from right to left
in other words you can think of it as the polynomial being evaluated from the element of least degree to the element of highest degree
note that a 0 is a constant the multiplier is x power 0 that is 1 right
and you evaluate this all the way up to a n x power n
let us evaluate this algorithm indeed the algorithm is correct because it is quite clear that in every iteration one part of the polynomial is being calculated on the given value v
so in every iteration you calculate v power i from v power i minus 1 you multiplied by a i this costs a total of 2 multiplication operations
then you add the result to the current value which gives you the value of the polynomial on the degree i polynomial that is a i x power i all the way up to the term a 0
the total number of arithmetic operations that we have performed is 2 in multiplications that is in every iteration you perform 2 multiplications and 1 addition
and this counts for 2 in multiplications plus n minus 1 additions this is a total of 3 and minus 1 arithmetic operations which are performed
let us know see if there is a way of improving this
and this improvement is a very clever trick which is a very important trick which is called the horna's method for evaluating the algorithm
to understand the horna's method of evaluating the algorithm it is extremely important for us to visualize the polynomial which we are interested in evaluating in a slightly different form
in other words we rewrite the polynomial
and how do we rewrite the polynomial
 let us just look at p of x we rewrite it as a 0 the constant term in the polynomial
and in the remaining terms x is a common factor
if you look at all the other terms x is a common factor that x is factored out
and the remaining polynomial is called p 1 of x
in other words p 1 of x is a n x power n minus 1 all the way down up to a 2 x plus a 1
observe that p 1 of x is obtained by taking the first n terms of p of x and taking out the factor x from them
for example if you go back and look at p of x if you look at p of x it has the first n terms have x as a factor you just take that out and consider the remaining polynomial and what we get is p 1 of x
so we have already seen that the harners method is an optimal method for evaluating a given polynomial given as the set of its coefficients in the sense that it uses exactly the required number of arithmetic operations
in other words to evaluate a polynomial of degree n at a given point for the variable x we need definitely n multiplication operations followed by n addition operations and observe that we are not counting the number of operations which are required to compute the higher powers of the value v that has been given
what we have just seen is that the harners method uses exactly the minimum number of operations
in other words it is an optimal algorithm for evaluating a given polynomial at a given point or a given value for the variable x
so let us move on and ask some questions about efficient algorithms for the most simplest looking exercise of multiplying n digit numbers
here is the exercise we have to write a program to multiply two n digit numbers and here we deviate slightly from the model that we have been looking at so far when we assume that any two numbers can be multiplied in any two positive integers can be multiplied in unit time
and we do not we discard that assumption and now explore the challenge of multiplying two n digit numbers
in other words the two numbers have n digits and we want to count the total number of single digit multiplications that are required to multiply the two given numbers
so let us look at this example which we see here which is multiplying the numbers 1 2 3 4 and 5 6 7 8 both of them as we can see are four digit numbers and the straight forward high school multiplication approach is to write down 1 2 3 4 5 6 7 8 and now observe that eight has to be multiplied to each of these four digits
and then seven has to be multiplied with each of these four digits six has to be multiplied with each four digits and five has to be multiplied with each of four digits
in other words each digit and one must be multiplied with all the digits and the other in the straight forward multiplication method which we are all very familiar with and therefore if the two numbers have end digits each we essentially are performing n square multiplication operations single digit multiplication operations
this example it is of course 16 multiplication operations the question now is can we come up with an algorithm which uses a lesser number of single digit multiplication operations
let us try to post this question very clearly and that is exactly what has been written as the question at the end of the slide can we come up with an algorithm and along with the algorithm we must write down a formula for the number of multiplication operations performed by that algorithm and that formula must be smaller than n square for all values of n except for some finite number of n
i repeat this the exercise now is to come up with an improved algorithm
what do we mean by an improved algorithm
 we want to come up a design and come up with or design an algorithm not just design the algorithm but we also want to analyze the algorithm and come up with a formula for the number of operations which are performed by the algorithm
what property do we desire from such a formula
 we desire that the formula must be smaller than n square at all values of n except for a few small values of n meaning maybe for the first 10 numbers n that is for up to 10 digit numbers maybe n square is smaller than the formula that we have come up with but beyond 10 it must be larger than the formula that we come up with and other words our formula must be smaller or the formula associated with our algorithm must be smaller
so there are two tasks here one to design the algorithm and two to analyze the algorithm and write down a formula for the number of single digit multiplication operations that it performs
so we have already seen a very straightforward method let us do something more sophisticated and interesting and exciting and this is the karat subhaz method
so let us just recall the whole exercise we want to multiply x and y which are 2 n digit integers
these are 2 n digit integers and the way we do this is to look at x and y in a slightly different way
so what we do is we consider x to be in the form x 1 multiplied by 10 to the power of n by 2 plus x naught and y to be y 1 to the power of 10 to the n by 2 plus y naught
so let us do a small exercise
so let us consider x let us consider x to be equal to 3 4 5 6 and y to be equal to 6 7 8 6 7 8 9 1 4
so the total number of digits in both these cases is 6 we write x to be 123 multiplied by 10 to the power of 3 plus 456
clearly this can be very easily done 6 is divisible by 2 that gives an exponent value of 3 and therefore you can write this as 123 into 1000 plus 456
similarly we can write down y to be equal to 678 multiplied by 1000 plus 914
what are we interested in
 we are interested in the value x multiplied by y which is this term multiplied by this term
this is a product of the right hand sides
i hope the approach is clear
so the most important thing is that 123 multiplied by 1000 and 678 multiplied by 1000 are very easy to evaluate and they do not require multiplication operations
123 multiplied by 1000 just involves us writing down 123 followed by 3 0s
similarly 678 multiplied by 1000 just requires us writing down 678 followed by 3 0s
if one wants to compute the product of 123678000 then one only needs to evaluate 193 multiplied by 678
once we have computed this number we pad it with 6 0s
let me write this just for the purposes of visualization in this form that we just need to evaluate 193 multiplied by 678
observe that we wanted to multiply 2 6 digit numbers and because we know that we can pad these 6 0s this is the multiplication of 3 digit numbers
this is the multiplication of 2 3 digit numbers
this is the whole idea that we have reduced the size of the problem and this is extremely important
we have reduced the size of the multiplication problem in one step by rewriting the number in this form from a 6 digit multiplication to a 3 digit multiplication
but of course there are some tricks involved
it is not so straightforward
as you can see there are some more multiplications to be done
so let us go back to our slide and look at it in the formal way
as we have just seen we have seen that x can be written in this form and y can be written
in this form we did see this through an example
we saw this through this example
now let us just focus on the values of y0 y1 x1 and x0
we have already seen that x0 and y0 are smaller than 10 to the power of n by 2
now let us just look at xy the product that we are interested in and see how this can be rewritten
this can be rewritten by just expanding this term out
when you try to expand this term out let us assume that the coefficients that one gets are z2 multiplied by 10 power n
that is the product of x1 and y1 is written down as z2
then there is a term where the exponent is 10 to the power of n by 2
this is the product of x1 into y0 plus x0 into y1 and then there is a product of x0 and y0 which we have written as z0
we have already seen that multiplication by powers of 10 is adding least significant 0s
now is this going to help in reducing the total number of multiplication operations single digit multiplication operations
 let us just focus on z2 which we have already seen that is x1 multiplied by y1 z1 which is x1 into y0 plus x0 into y1 and z0 which is x0 multiplied by y0
the most important thing is that this value this is 10 to the power of n by 2
this is selected so that in the sub-problems there are just n by 2 digits that need to be multiplied
in every number that needs to be multiplied there are just n by 2 digits
now let us just look at the second term which is the most important thing
observe that as of now there are 4 multiplications to be done
that is this is a single multiplication
it looks here that this is one multiplication and this is a second multiplication and then this is the fourth multiplication
however a small trick of rewriting z1 into x1 plus x0 into y1 plus y0 minus z2 minus z0
so let us just see this
z2 is x1 minus x1 y1 z0 is x0 multiplied by y0
if you evaluate this and subtract out z2 and z0 we get exactly what we want which is the value of z1
now observe that this is a single multiplication operation and what we are going to see is that all these multiplication operations involve just n by 2 digits
so let us just go to the example
so remember that we wanted to multiply these two six digit numbers
we wrote the number down as 123 into 1000
how many digits are left now
 half the digits are left
if you notice here there are n by 2 digits
there are just 3 digits here
similarly there are also 3 digits here
further observe that these two numbers are obtained by looking at the 3 digits of x
the first is the least significant 3 digits of x and the least significant 3 digits of y
therefore those two values have to be lesser than 1000
they cannot be 1000
they have to be lesser than 1000 because they involve only 3 digits
same with this term
therefore what is the conclusion
 the conclusion is that we now have 4 3 digit numbers
we started off wanting to multiply 2 6 digit numbers
we have broken it down into 4 3 digit numbers and going back to our previous slide
we are now wanting to evaluate
we have now observed that x1 y1 y0 y1 all are n by 2 digits
in that example they have 3 digits
now let us just look at the reduction in the number of multiplication operations
both x1 and y1 as we have seen are smaller than 10 to the n by 2
that is they have less than n by 2 digits
same with y0 and y1
secondly let us just look at the sum of the 2 of them
this is just 2 n by 2 digit 1 n by 2 digit multiplication z0 which is x0 into y0 both are smaller than n by 2
this is again 1 n by 2 digit multiplication
we only have to worry about and reason about this multiplication operation
this multiplication operation
let us just observe that x1 and x0 both are numbers smaller than 10 to the n by 2 10 to the power of n by 2
when you add both of them how many digits can you get
 that is you have two values which are 10 to the power of n by 2 and when you add the two of them how many digits can you have
 you can have a maximum of n by 2 digits because both of them are smaller than n by 2
let us just go back to our example
observe that 456 and 914 are 3 digit numbers
when you add both of them at the most you can get a 4 digit number
let us just see this
you can have 99
you can have 99 a 3 digit number
add it with another 99 which is another 3 digit number
this is 1998
observe that it is a 4 digit number
therefore the most important point that is being made is that if you add 914 with 678 you can at most get another 4 digit number and not a 6 digit number
that is the most important thing
you do not get a 6 digit number
let us just see what the gain in the arithmetic is
the gain in the arithmetic is we have three multiplications of n by 2 digit numbers
we have four additions and two subtractions
we have one multiplication by 10 power n and one multiplication by 10 power n by 2
and the last two do not are not counted as multiplications
they are just shifting operations or adding zeros least significant zeros
let us just go back and calculate this
you see one subtraction a second subtraction
then you see two additions here
then there is a third addition and a fourth addition and there are three multiplication operations
so therefore let us formally analyze the gain in arithmetic
the running time of the algorithm that we have just written where we want to calculate the total number of multiplications
that is our measure of running time
let us not count the number of additions and the shift operations
let us just count the number of multiplications
the number of multiplications on two n digit numbers is given by three multiplications on two n by 2 digit numbers
and if you multiply two two digit numbers we take this to be equal to four
this is easy to check
this is called a boundary condition for this recurrence equation
what is a recurrence equation
 the value for multiplying two n digit numbers
a number of multiplications single digit multiplications to multiply two n digit numbers is given by three times the number of multiplications to multiply two n by two digit numbers
the solution for this the solution for this is given by n to the power of log 3 by 2
the solution for this is given by the value n to the power of log 3 by 2
and observe that log 3 base 2 into the power of log 3 to the base 2 and observe that log 3 base 2 is smaller than 2
therefore n cube into the log 3 base 2 is smaller than n square
and n square is a total number of single digit multiplications in the simple method
this brings us to the last module here which is the concept called a big o notation where the focus is how do we compare a pair of algorithms
 observe that we have done analysis of running time of these algorithms by different methods
we use simple methods and sophisticated methods
so let us just look at the karachubha's method
we know that the karachubha's method uses n to the power of log 3 base 2 multiplications and this is smaller than n square
this is smaller than n square
how does one capture this
 we capture this using the big o notation which will be the focus of the next lecture
thank you
so in module 2 we will look at problem solving
we are going to take up a small problem which is finding the largest of 3 numbers
it is a fairly simple problem but in this problem by looking at this we will see how we can take a problem break it down into smaller chunks
we will see how to do a flow chart or at least come up with a sequence with which we can solve this problem
and i will also show the rudiments of how to write a c program and the software environment that is required for it
so let us jump right into the problem
so we are looking at largest of 3 integers or 3 numbers
so let us call them a b and c
so this forms the input to the program or input to the problem
and what we are interested in finding out is what is the largest of the 3
is it a is it b or is it c
so we have to start somewhere and we have to start with comparisons
so let us say i compare a and b
i am going to check if a is greater than b or not
there are two possibilities
a is actually greater than b or it is not
so if a is greater than b then it is still possible that c could be greater than a
so we go and check if a is greater than c also if it is yes then indeed a is the biggest of all
so you have already checked it against b and you have checked it against c and therefore a is the largest
however if this condition is not true if a is actually less than c we know that a is greater than b
therefore c must be the greatest of all
so this a is greater than b but it is less than c
therefore c is the largest
now let us look at this other side
a is greater than b is false which means b is the largest among a and b
and now we can also check if b is indeed the largest by check comparing it against c
if b is greater than c if it is true then b is the largest otherwise c is the largest
so let us take one look at this problem before we go and write a program for this
we first compare a against b and if it is true we check a against c
if both are true then a is indeed the largest
if a is not greater than b then we checked b against c
so if b is greater than both a and b so if b is greater than a but if it is less than c then c is the largest
if b is greater than both a and b then b is the largest and so on
so this is the basic set of that we have
so at this point of time it may make sense to try with a few examples and check if this is indeed correct if this solution is correct
so let us take this example a is 1 b is 2 and c is 3
so let us check this is a greater than b is the first thing that is checked
so you compare a and b is a greater than b no
a greater than b the answer is no
now you are ready to check is b greater than c and so to compare b and c we take b we take c is b greater than c is b greater than c
so b is not greater than c so the answer is again no and therefore the result must be c
so essentially we have taken this path
let us take another example a is minus 1 b is 5 and c is 2
so again if we check a greater than b it is false and b greater than c is true
therefore you would have taken this path b is indeed the largest
so with these two examples i am now finally convinced that this solution is correct
let us go and write a program for this and you are going to write a small c program and in the process i am going to show you what it means to write a program
so i am going to use this environment or an ide also called an integrated development environment called devc++
it is a piece of software that is available for windows and it is available for free
it is widely used lots of downloads
i can provide you links later for how to download it and how to run it
i already have it installed
so let me start a new program
so i am going to start a new program and i am going to call so i am going to write a piece of a comment in it saying this is a program to find the largest of three numbers
so i want to be able to take input from the user
i mentioned earlier that we need a library for input and output and that is going to come from stdih and i am going to write the main program
so do not worry about the mechanics right now
so as i mentioned earlier main program is the very first instruction that is executed and to do that i am going to be so the body of the main program is enclosed within braces
so i am going to have three integers a b and c
i am going to prompt the user for the values
so printf is a statement which will print things on the screen
so it will print enter a b c on the screen
at this point of time we expect the user to actually print these numbers and there is some scanning that we have to do or reading from the user and we do that with this library function called scanf
so do not get scared by the statement that is there
so all is doing is reading a b and c
so and you can see that every statement ends with a semicolon
so that is the terminator and now let us write this program
so we want to be able to compare a against b and a against c and so on
at this point of time it may make sense to actually go and look at the diagram once
so we first compare a against b and based on s or no we did further comparisons
so let us compare a against b first
if a greater than b then a still might be less than c
so we have to check if a is greater than c also and if it is then we are going to declare a as the largest
so we have to check if a is greater than c also and if it is then we are going to declare a as the largest
however if this condition fails then a is greater than c
so this is the then c is the largest
so again do not look at the mechanics right now
so just follow the logic we already had this
let us go down further
so we have taken care of two cases
we have looked at a greater than b and we have seen this side
we have taken care of this side
now we are ready to write code for the right side
if b is greater than c then b is greater than a
so by this time we already know that b is greater than a
we want to check if b is greater than c also
if b is greater than c already we know that b is greater than a
therefore b is the largest
otherwise b is greater than c
so this is the largest
so this is actually a complete program
so we have at line 2
so you can see the line numbers on the left side
you can see it here
so watch the mouse pointer
at line number 2 we have hash include stdoh
starting at line 4 ending at line 28 is our main program
the body is from line 6 to 28
there seems to be something which is in a b c
so it seems to be reading in the values of a b and c here
we have some checks and we have some print statements
so this is the whole process
so what we have really done is we have prompted the user for entering a b and c
we read it from the user and we have written this piece of code which actually declares whether which one of a b or c is the greatest of the three
so let us save this program
so at this point you have prompted for a name
so i am going to write largest of three numbers
so i am giving a fairly big name to the program but you may want to give a smaller name if you wish to
so i have this and this is not going to result in anything
so we just have a program by looking at the program one can visually check whether things are correct or not but the proof is in the pudding
we have to really make the computer run it
we have to give it test cases and see
so we started with the specification
we have the design which was the diagram that i did earlier and we have coded now
now let us go and compile it
to compile it you go to execute compile in devc++ and voila we do not have any errors
so i have written a program which has no compilation errors
we are ready to run the program now
so i am going to press f 10 for it
when i press f 10 the first statement that is there is print f enter a b and c
so this line number 7 is really not an executable statement
we will see why it is so later
it is actually called a declaration
so we have declared variables a b and c of a type called int which stands for integer
so the first executable statement is actually print f
so print f enter a b and c and if you see the screen it just shows enter a b and c
you can see that the double quotation the open and closed code is actually missing in the output
so this is the way in which print f which is a library function takes an argument
so a library functions are just like mathematical functions
so if i ask you what sign of x is you would write it as sign within parenthesis x
would you not
 it is the same thing here
so print f is a function within parenthesis you pass the so called parameter to it and in this case the parameter is the string enter a b and c and we can see it on the screen here
so now you can see the blinking cursor here that means the user is expected to enter something
so let us take the two examples that we gave earlier
so let us go back to the example
we tested 1 2 and 3 and minus 1 5 and 2
so i am going to enter 1 2 and 3 i am typing in from the keyboard and it says c is indeed the largest
so so far so good
let me go back and try another input to do that i have not really changed the program per say which means nothing in the logic of the program has changed
i could just use the executable directly this is what i mentioned earlier
you could write it once compile it once and run it how many ever times you want
so i am running it the second time without making any edits to the program because i do not see any evidence that the program is erroneous
so enter a b and c
so i am going to use minus 1 5 2 as an input and it says b is the largest
so we have tested two cases this does not mean that it would work for every case
so what i am going to do is i am just going to try and give all possible combinations of starting from let us say 1 2 3 i am going to try these combinations 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 and 3 2 1
so i am going to try these 4 and these two combinations one after the other and if there is any bug i can hopefully catch it
so let me give it one option after the other
so i am going to run it once 1 2 3
so c is the last largest good then let me run it once more 1 3 2 b is the largest good 2 1 3 i am sorry so i am going to try 2 1 3 c is the largest 2 3 1 b is the largest 3 1 2 a is the largest 3 2 1 a is the largest
so i gave 6 permutations that can come from ordering 1 2 1 3 and it looks like this program is actually correct
so this by itself it is not show that the program is correct for the inputs that i have given it is correct and in this case it would actually sort any number
so we have also tried it on negative numbers
so let us try all negative numbers let us say minus 1 minus 2 minus 3 and in this case a is the largest
so just for fun let us try instead of giving numbers let us try something else
so i am going to give input as let us say s t and r
so i gave 3 letters and i did not give numbers and r
so i gave 3 letters and i did not give numbers and it actually says b is the largest
so what happened here
 so we gave 3 letters s t and r and it says t is the largest
so for whatever reason we will see why how this happened we will see why the b is declared as a largest
so what is in fact b what is a and what is c we will see in a later module
but as of now if i give numbers things seem to work
so just for one last time i will try another input 200 100 and 1000 and c is the largest
so so far so good
so this we started with the problem and we went through a sequence of steps and we designed a solution to the problem and the design is here
so this diagram is the design and once we have the design we went and coded it we check the code by testing it
so we have the whole setup
so let me close this ide or devc++
so with this we are at the end of this demo we saw this very first program that we wrote we tested it we compiled it we tested it and we ran it multiple times to ensure that things work well
so this lecture is on algorithms for sorting and the focus of the lecture is going to be not just on the algorithms but the sequence of steps that going to arguing that the algorithm is indeed correct in analyzing the running time
one of the simplest algorithms to sort a given data set and in this case we assume that the input is given in an array of size n that the elements are a of 1 to a of n
the data type of the elements in the array is not so important for the rest of the presentation as long as it is clear that there is a very clear order between every pair of elements
the output of a sorting algorithm is to sort the array in ascending order and insertion sort is a very simple and popular algorithm to understand the challenge of sorting
the approach that is taken by insertion sort is the following it is an iterative approach which means that there is a loop that is running n times recall that n is a number of elements in the array that need to be sorted and at the end of every iteration let us say at the end of the ith iteration the invariant that is maintained by the algorithm is that the elements from the first i elements in the array that is the elements a of 1 to a of i are sorted in ascending order
further in the ith iteration the element a of i is inserted into the correct location among the elements a of 1 to a of i minus 1 and thus this invariant is maintained one iteration after another this kind of guarantees the correctness of the insertions and sort algorithm to sort an array of n elements
of course the challenge here is to understand how the insertion happens recall that in the previous slide we mentioned that in the ith iteration the element a of i is inserted into the correct location so that a of 1 to a of i is sorted given that a of 1 to a of i minus 1 is sorted when the control enters the ith iteration
so how does one insert a of i
 one can look at the step by step procedure we said first j to be a temporary variable and then if j whenever j takes the value 1 you exit right we will see what the motivation for this condition is and as long as j is more than 1 a comparison is made of the elements a of j and a of j minus 1 in other words the elements which are in the array locations j and j minus 1 are compared and if a of j is smaller than a of j minus 1 then there is an exchange that is affected between the elements in the locations j and j minus 1 and now j is decremented by 1 and then we repeat this procedure all over again
indeed it is also possible that the element at the jth location is at least as large as the element at the j minus 1 with location in which case it is clear that a of j is at the correct place given that the rest of the elements are in sorted order right at this point of time the control exits and now we can report that the elements a of 1 to a of i are in sorted order in other words we achieve the goal of inserting a of i into the correct position
let us just look at this pictorially this is taken from korman-lyser's and rivas the standard textbook and let us look at the starting array which is array index by the letter a and observe that there are six elements in this array which are which start out as 5 2 4 6 1 and 3 observe that in the first step right in our case this would be the second step the way i presented the algorithm the elements 2 and 5 are exchanged in the array index by the letter b observe that the first two elements are in sorted order and the element 4 is now being inserted into its correct position and this just requires a single comparison with 4 and 5 but of course the comparison with two should also happen therefore it actually requires two comparisons similarly if you look at six six is larger than 5 and this one comparison keep six exactly where it is and then observe that 1 is now inserted into the correct position after 4 exchanges 6 first goes into the is exchanged with 1 then 5 with 1 then the value 4 with 1 and finally the value 2 is exchanged with 1
similarly 3 now is move towards is inserted into its correct place in the figure index by the letter e at the end of this whole procedure we find that the array is in sorted order this is essentially the idea behind the insertion sort and one can even imagine this as a very natural way of arranging a deck of cards how does one guarantee the correctness of this insertion sort algorithm the way to guarantee the sortness to guarantee the correctness of this sorting algorithm is to now argue that in the i th iteration the element a of i will move to its correct position among the elements a of 1 to a of i minus 1 within i comparisons in other words we prove this by induction we observe that at the end of the i th iteration the elements a of 1 to a of i minus 1 are sorted in a of i are sorted in ascending order we prove this by induction on the value of i observe that when i is equal to 1 which is the base case the array just contain a of 1 is just in sorted order
so let us assume that a of 1 to a of i minus 1 are sorted in ascending order and let us complete the induction step so the hypothesis now is the a of 1 to a of i minus 1 are sorted in ascending order
now a of i let us assume the a of i is now inserted between the elements a of j and a of j plus 1
so let us look at the indices that j can take j can take a value between 1 and i minus 2 and wherever it is inserted on termination it is clear that a of i is at least as large as a of j and a of i is less than or equal to a of j plus 1
in other words as the algorithm progresses the prefix of the array which is sorted its length keeps increasing iteration by iteration
consequently at the end of the n th iteration it is clear that the elements a of 1 to a of n occur in sorted order therefore insertion sort is indeed correct in the sense that it terminates an on termination the array is in sorted order
the analysis of the running time is based on the observation that for the element a of i to be inserted into its correct location in the worst case it just need 2 times i minus 1 comparisons we use comparisons as a measure of the running time and we count the total number of comparisons that need to be made to ensure that i is inserted into the correct place and here we place an upper bound in other words we do a worst case analysis of the number of comparisons which are required
and observe that if the element the worst case is the case where the element a of i should eventually enter the location a of 1 in other words in the elements a of 1 to a of i a of i turns out to be the smallest element in this sub array of consecutive elements then a of i indeed has to be compared with each of the elements that is i minus 1 all the way up to the element index at i minus 1 up to the element index by y by 1
further in each of these iterations if you notice the code that we have written there is a comparison of whether the index is equal to 1 or not right
so that is why we get 2 into i minus 1 comparisons therefore the total number of comparisons made is 1 comparison for the first element and subsequently it is an even number of comparisons up to the the nth element right therefore the total number of comparisons that is made is given by the summation 1 plus 2 plus 4 plus 6 and so on up to 2 times n minus 1
here is a small exercise which is indeed a toy exercise calculate is exactly and verify that it is of the order of n square
so this brings to end the discussion of insertion sort and it is instructive to see on what input insertion sort performs the most number of comparisons
this is also left as a small exercise to the student
natural question now is that can we reduce the number of comparisons made by a sorting algorithm from order of n square to something significantly smaller than n square right
we now show an algorithm which uses the divided conquer paradigm recall that in the last lecture where we studied binary search we encountered the divided conquer paradigm where in that case we were searching for a particular element in a sorted array and in every iteration the region of the array which is sorted became smaller by a fraction of 2
in this case we do something similar we create two sub problems of almost equal size sort the two sub problems recursively and then merge the sorted arrays
so this is the whole idea this is the divided conquer paradigm and this is what merge sort does right
the sequence of steps are as follows for the goal of sorting an array whose indices are in the interval p to q where p is smaller than q
initially the first time when merge sort would be called the value of p would be 1 and q would be n that is we would we want to sort the array of size n
the algorithm takes a middle element in the given array in this case it computes the index given by the formula r which is the floor of p plus q by 2
in other words the range p plus q is taken which is the sum of the two elements divided by 2 gives the middle index in the array and we take the floor just in case p plus q is odd
if r is not same as p in other words if the array has more than one element or more than three elements if the array has more than three elements then merge sort of p comma r is called followed by a recursive call to merge sort of r plus 1 to q
observe here is a boundary condition of what happens when r is equal to p
observe that when r is equal to p there are at most two elements in the array and there is no need to recursively sort the elements of size 1
now the two arrays a of p to r and a of r plus 1 to q are now sorted recursively using merge sort itself at the end of which the array a of p comma r and a of r plus 1 comma q are sorted arrays
we call a function called merge which we will shortly discuss the output of merge is to take these two sorted arrays and insert them into a third array which is called b here
b contains all the elements of both the arrays in sorted in ascending order
now b is now copied into the array p comma q which is now sorted and this is the description of the recursive algorithm
the natural question now is how many comparisons are made by this merge sort algorithm
before we go there let us look at a key step which plays an important role in the merge sort algorithm which is the time taken to merge two sorted arrays
let us look at it as an independent exercise not just in the context of merge sort but just the question of the input consisting of two sorted arrays and the output should be a third array which contains all the elements of the two arrays in sorted order
this operation is called the merging operation of the two sorted arrays a and b
so let us look at the time taken to merge the two arrays a and b into a sorted array c
the idea is quite intuitive
so initially x and y are taken to be one they are the smallest elements in the two arrays respectively and z is the first element the index of the first element in the array c
the first step is the following which is very important this is the beginning of an iteration if z exceeds the total number of elements in the array in the two arrays then you exit merge has been completed you return the value of c the algorithm returns the value c
in the second step the smallest of the two elements second in the second step the smallest of the two elements a of x and b of y are identified and the smallest of the two elements is now assigned to be the element present in the array index z in the array c
this is iteratively done as follows a of x is compared with b of y the smaller the two elements as you can see is assigned to c of z
z is then incremented and depending on where the smaller element came from whether it came from a or b the indices x and y are incremented the indices y and x are incremented
for example if the smaller element came from the array y array b then the element assigned to c of z is b of y and y is now incremented and z is also incremented
if the smaller element came from the array a then x and z are incremented and the array element a of x is copied into the array index z in c
now we will argue that this indeed merges the two arrays and we will also count the total number of comparisons made
at this point of time before we go into that argument let us just look at the execution of the merge out algorithm and again this image is taken from the textbook by convent license and drive-aest and let us look at the run of this algorithm
the leaf levels in this tree tell us the initial array the initial array has had eight elements and the elements are 5 2 4 7 1 3 2 and 6 and observe that in this view every intermediate array that you see as you view this in a bottom of fashion is a sorted array and the parent of two arrays is obtained by merging the contents of the two sorted arrays
let us just look at the leaf level let us look at the elements 5 and 2 individually sorted order and they are merged to result in the parent array which has the elements 2 and 5
if you look at the sibling the right sibling of the array 2 5 it is 4 7 which is obtained by merging the two arrays which have just a single element 4 and 7 respectively
now 2 5 and 4 7 as you can see is merged to give the array 2 4 5 and 7 and eventually the whole sorted sequence is obtained at the root of this recursion tree
it is important to observe that this data structure is present only in the analysis of the algorithm and the algorithm indeed does not run in this order
it runs in a top down order as opposed to the analysis which is happening or which is being presented in a bottom up fashion
let us look at the correctness analysis of the merging step
the merging step is indeed correct
so let us just observe a primary invariant which says that for every z in the range 1 to l plus m after the z z iteration c of z satisfy some nice properties
c of z is smaller than all the values in the array a among the region x to l among the indices x to l and it is smaller than all the values in the array b among the indices y to m
therefore it follows that c of 1 to z
all the values are at most each value in the array indices x to l in a and the array indices y to m in the array b
the third property that is guaranteed by the algorithm is that the array c is sorted for every z
so remember that z is the iteration number
to prove the above claim it is sufficient
if we prove the above claim this proves that the merge algorithm is indeed correct because when you take the value z is equal to l plus m the array c of 1 to z would be sorted
that is the whole array is sorted because of the range of values that z takes from 1 to l plus m
continuing the correctness analysis we set up the proof by induction
let us assume that z is equal to 1 and in this case the singleton array the array containing just one element is sorted
it is indeed the smallest element in the array is a and b
therefore our claim is correct in this base case
let us assume and let us make the induction hypothesis that the claim is indeed true for a value z minus 1
let us prove this for z
this would complete the induction step
so the first claim is that c of z is the smallest element in a of x and among a of x and b of y
this is indeed correct
because if you look at the steps in the algorithm we choose the minimum of the elements a of x and b of y and assign it into the value c of z
therefore c of z is indeed the minimum
since a and b are sorted it is clear that c of z is indeed smaller than the elements in the array locations x to l in the array a and the elements in the array locations y to m in the array b
by induction we know that c of z minus 1 is indeed smaller than or equal to c of z
in other words we know that by induction that c of z minus 1 is smaller than equal to all the elements in the arrays a and b put together and we have taken the minimum of all those elements and put them into c of z
therefore c of z minus 1 is smaller than or equal to c of z
consequently it follows that c of 1 to z is in the sorted order given that c of 1 to z minus 1 was in the sorted order by the induction hypothesis
this proves the induction step and therefore we have proved that merge indeed does succeed that after l plus m iterations the whole array c is in the sorted order and therefore the merge algorithm indeed succeeds
let us now analyze the running time of merge
it is very important to get an understanding of how much time it takes for merge to run
it is crucial to understand how does one count the running time and in this case we count the total number of comparisons
the most important observation that we make is that every time a comparison is affected the size of the array c keeps increasing by exactly 1
as a consequence of this observation after l plus m comparisons there will be l plus m elements in the arrays c and therefore the total number of comparisons used is a sum total of the total number of arrays elements in the two arrays a and b
therefore the number of comparisons used by the merge algorithm is l plus m
in other words it is just linear in the size of the number of elements in the two arrays put together
this gives a handle to analyze the running time of merge sort
again here we count the total number of comparisons made by merge sort
let us now analyze the number of comparisons used by the merge algorithm
let t of n denote the number of comparisons made by merge sort on an n element array
for the sake of simplicity just for the argument let us assume that n is the power of some value k that is n is equal to 2 power k
now t of n is given by the formula t of n is 2 times t of n by 2 plus m and t of 2 is just equal to 1
let us just understand this formula
this is called a recurrence equation and 2 times t of n by 2 is equal to 1 plus the number of comparisons on the recursive subproblems to sort the recursive subproblems
that is the subproblem consisting of 1 half of the array and the second subproblem consisting of the second half of the array
the second term which is n is the total number of comparisons made by merge which we just very recently analyzed
a solution to this recurrence equation gives us a solution to the number of comparisons made by the merge sort algorithm and this will be completed in the next lecture
this lecture on functions this is a very important aspect of c that one has to learn and it also makes programming much more easier and fun
so what is a function
 a function is essentially a self-contained unit of program
it is a piece of code that is designed in such a way that you can accomplish a particular task
so it is a very specific task that you want to do and you rub that up in what is called a function
and one way to look at function is you can treat them as black boxes
so for example let us say i have a function called sqrt which supposedly does square root of a variable
you pass a variable to it and it is supposed to give you a square root
so this kind of thing happens in the mathematical world often right
 so i want to find out f of x and so on
so let us say i as a programmer have very carefully written a program to do square root and let us say you do not know how to do it
so what i do is i write the program for square root and i put it in what is called a function
i give it as a black box to you and you have to give it inputs i will compute square root for you and i will give you outputs
so the program or the subprogram that i wrote will compute the square root for the inputs and you will get output
so this is the notion of a function
so you may not want to know the internal details of square root
for all practical purposes you can think of the square root as a black box that is given to you and as long as it is done correctly you can give inputs you can expect it to give outputs and you can use that in your calculations
so this notion of putting things in a black box is nice because what happens inside the function can be hidden from what happens outside it
so what happens inside the black box is not of concern
of course you have to be careful
so if i say that i have given you a program to write square root and let us say that subprogram is incorrect then you are in soup
so you have to be careful
if the functions are written carefully and implemented correctly then it lets you take a big task and divide that into smaller sub tasks
and we have seen several examples of functions and there are three things that i can immediately point you to main for instance it is a little for function even though we will talk about main in a little more detail later
the two functions that we have been using repeatedly are print-off and scan-off
print-off was used to print things on the screen and scan-off was used to scan things off a keyboard
so these two are functions
so clearly you did not write print-off and scan-off
these were written by someone else and you are using it as a black box
you did not worry about how things go to the screen nor worry about how the keyboard the key press that is done is taken to the internal variables
so this kind of hiding the functionality of what a function does is very useful because you do not have to worry about the inner details of functions as long as the interface is clean
so you can think of functions as giving inputs and getting outputs from there
so let us see what outputs to the function means
so not all functions actually give outputs
so there are functions which compute something and are expected to return a value
for example if i am looking for square root i give it so i want square root of x x is the value that square root will take and in return i should expect a value because it has to do some work and return a value
similarly there is a mathematical function called pow which transfer power
even to floating point values m n it can calculate m raised to the power of n
so clearly m raised to the power of n is a very useful thing in various aspects and i expect a value more importantly
so if i give m n it can do the action but i want to use that
let us say i want to do a squared plus b squared i can do power of a 2 but that a squared should be returned as a value
so there are functions which return values
there are also functions which do not return any values explicitly or at least not return any useful values but perform actions
for example printf as a function does something to do on the screen
it does not return a value to the program where printf is called
so at least it does not return a useful value for all practical purposes
so you can write functions which does a sequence of actions or you can write functions which does a sequence of actions compute something and also returns a value
so the notion of functions is essentially equivalent to outsourcing
let us say you are a busy programmer you are doing something you do not want to spend time on writing square root function
you outsource it to me
i write the square root function
i am good with numerical methods
i go and write the square root function and i give it to you and that way you can outsource your work
so you can take a big problem divide that into smaller problems and compose the smallest subtasks together
this is very useful when you want to build large programs
you can build on top of what you have done earlier or you can also build on top of what others have done
so this is a very nice thing about using functions
so most languages give you what is called a library
see also has a very rich set of libraries and very common things
most common things that most programmers would need are all put in in the library
so imagine every single user or every single programmer having to know how to write things on the screen having to know how to read from the keyboard and so on
instead the c as a language gives you print offence can of
similarly there are several mathematical functions including p w and square root and so on which are all packaged in what is called a library
as engineers you will actually either develop these libraries for others or you may actually end up using libraries that others have written
so one thing that you get from using functions is what is called modular programming
so you take a task divide that into subtasks sub-programs and these sub-programs can either be things that do some work or things that do some work and return a value
if you have been exposed to languages like pascal in pascal they call them procedures and functions
procedures do not return values whereas functions return values
in c and c++ everything is called a function
if a particular function does not return any value it does not have a special name for it
it facilitates modular programming
you can take this sub-program or the function that you have and you can invoke it at several points
so i will show a simple example later on how this becomes modular and as i said it hides the implementation and if you want to make any change to the program it makes it much more easier
so what kind of functions are there in c
 there are several functions available in c for string manipulation
this is a very common thing
how do you take a sequence of characters forming a string and manipulate strings
 so we will look at strings in a later lecture
there are also several mathematical functions that are available as standard libraries in c
so if you are coming from other engineering disciplines so you develop your own things
for example mechanical engineers civil engineers aerospace engineers and so on may use finite element methods very often and there are libraries that are available
not as standard libraries but there are vendors who provide these libraries
many of these libraries are usually domain specific
so what i mean by that is somebody uses specialist in an area requires a specific kind of computation
this may not be useful to people outside the domain
for example finite element methods are useful to certain class of engineers whereas somebody in electrical engineering or computer science may not really need finite element methods or libraries doing that in any of their regular routine job
so as a programmer what you will do is you will learn to use existing libraries and you may also identify scope for building new libraries and you may even make money by building these libraries and selling them later
so let us take a small problem of racing a particular base to the power of n
so this is a very common thing
so a power or base power n is something that you want to do and this is a very common thing that you have in various programs
so you can write that in a very fairly simple way
so let us start with this program int i and p equals 1
so i have two variables i and p and i have a very simple loop which takes care of it
so we have a for loop for i equals 1 for i less than or equal to n i plus plus p is p times base
so it is going to take p and multiply it with itself
so it starts with 1 and you multiply that with p n times
so that takes care of raising p to the power of n
so one aspect that you have to probably be careful about here is i am assuming that both p and base are actually integers
particularly i depend on p to the n to be n integer
the power that you are raising to this is only for such things
let us look at the motivation for functions
let us say a programmer needs 3 power 5 and minus 4 power 3 in the same program
so as a programmer one could write this
so i have i and p and base and n
these are supposed to be 4 variables which take care of base n i and p
so i is for running the loop p is for collecting the product and base and n are the two numbers
you are doing base power n
so the base and n are two integers
and the result is supposed to be gathered in num1 and num2
num1 is supposed to be 3 power 5 and num2 is supposed to be minus 4 power 3
let us say this is the setup that you have
you have to write a program of this kind
so you set up p equals 1 set up base equals 3 and n equals 5 and you write a loop which takes care of raising 3 to the power of 5 and you make num1 equals p
so num1 at this point has 3 power 5
then you have to again change p to 1 set up the base to minus 4 and set up n equals 3
in this case you are ready to do minus 4 power 3
and again you have repeated the same loop that you have earlier
so you look at this loop here and this loop here are exactly the same
the result is accumulated in p and you copy the value of p to num2
so this is the correct program as in num1 and num2 would get 3 power 5 and minus 4 power 3
but let us look at a few things
first of all we have duplicated effort
so there is a for loop that is written here
there is also a for loop that is written here
let us say for some reason i made a small mistake here this mistake could also come here
even if i have written the program correctly it is just that the same task that i am doing i see it in my program over and over and over
that is one thing
so this is something very subtle and you may not catch it if you are not careful
so even though this code this for loop is repeated
let us say i even let you do that and let us say it is not a problem right now
let us look at base and n
anyway these are things that are supposed to change
so i have set up base and i have set up n
so this is okay
but let us look at p
so i have p equals 1 and then we do the set of computations
it gives us 3 power 5
if i forget to do this p equals 1 here
what can happen is i have 3 power 5 that goes to p and then let us say i forget to do p equals 1
i have base equals minus 4 and 3 n equals 3
so if i forget to initialize p to 1 then p will start with 3 power 5 and to that you are going to multiply minus 4 3 times
so you are not really calculating minus 4 power 3 anymore and the result would have been for num 2 3 power 5 into minus 4 power 3
this is a disaster
so every time you want to do this you also have to remember that p has to be initialized to 1
because you would have done change the base and number because you are computing for something new but you may forget initializing p to 1 and this can be a recipe for disaster
so you have to be careful and this is not a very good way of doing it
it is definitely sounds clumsy and we have to change this
it would be really nice to do something like this
would it not
 so int i num 1 num 2 3 integers num 1 is power of 3 comma 4 num 2 is power of minus 4 comma 3
so this is nice for multiple reasons
1 it is definitely more readable
instead of that screen full of code that you saw earlier you now have 3 lines of code
in num 1 int i num 1 num 2 is for declarations and num 1 and num 2 gets 3 power 4 and minus 4 power 3
it is almost like writing mathematical equations on a piece of paper
so you have taken 3 power 4 put it to num 1 minus 4 power 3 put it to num 2 and so on
it is definitely more readable
it is less error prone because if somebody you have essentially outsourced the work of doing this power
it is computing power to someone else or some other functionality
you have made a subtask which is supposed to be computing power of base comma n and when you do that you are not going to run into this problem
so every time the function is going to be called we will assume that all the initializations are properly taken care of
the computation is done carefully and you actually get work done and you get the return value
so if power is a function if it takes these two things and if it returns a value then you have essentially delegated the duty of computation to either someone else or to some other region of the code
definitely this looks much less clumsy
so the only thing is somebody still has to write this power of base comma n
so you are outsourcing it but then somebody has to write it
so let us see how this power of base comma n can be written as a function
i said when you use it you can think of it as a black box
so power is a black box
you get base and then as inputs if you give these as inputs you are supposed to get some result back which is supposed to be base power n
so let us start with this black box
so what i am going to do is i define a body
so i have this body with this left and right flower braces and i have a name for a function called power
this is the name that i am going to use for power
it takes two integers as parameters in base and int n
this takes care of the inputs and i am supposed to be getting a result back and whatever is returned from a function is what you have here
so the way to look at this line is the function is called power
it takes two inputs base and n and it returns an integer
so the return does not have a name
it just has these type
you take two integers as inputs one integer is called base another integer is called n and you get an integer as a result
so that is what you have so far
so this is what the black box setup is
so clearly we have to write the program for it
we did this earlier
so we already had it
so p equals 1 for i equals 1 i less than or equal to n i plus plus p equals p times base
so this actually does the computation
so we already have this program written up and let us say i just did cut and paste of this into this block of code
so i have this
having this is not sufficient
so if i look at this as a sequence of steps i have variable p variable i but these variables are never declared
so there is no declaration for p and i and i mentioned earlier that every variable has to be declared so that you can get a location in memory
so p and i are not declared yet
so let us do that first
in i p you have that
so this is not the end of it
you have declared int i and p
at the end of this for loop p will actually have the final result
but if you look at this function there is a variable i there is a variable p
there are also these two inputs that you took base and n
so i want a result back but which one of these variables is the result
 no way a compiler can figure out which one of these things should be returned as a result
so for that we use the skewered called return
so this return r e t u r n is a keyword
so it is a reserved word in the c language
and what it does is of the various variables that and various calculations that you have done the final result is stored in p
please take that and return it to whoever called it
so if you have base comma n as inputs there are lots of local variables inside power
there are variables like p i and so on and of these you are expecting p to be returned and return p takes care of that
so essentially if you look at the whole program the whole function this is how it is
int power of int base comma int n
so by looking at this i know that it is expecting two inputs and both are supposed to be integers and it is going to give one output which is also an integer
and which integer does it return
 it is going to return p after doing this set of calculations
so now let us see how this is nice
so since p equals 1 is an initialization done here
the key thing is every time this function is going to be called this variable p is going to get initialized to 1
so therefore you do not have to remember to initialize p every time
you have given the task to somebody else
so you have delegated the task and that task or the sub task here called power is supposed to take care of whatever is required to compute power of base comma n
so to put this whole thing in one package let us see a complete program which uses the power function
so what you see on the right side is the function
you have in power in base and in n and we have written this function and let us see how this can be used
so we have two integers number one and number two and i said would it not be nice to have number one is power of 3 comma 5 and number two is power of minus 4 comma 3
we have exactly that
so this is an actual program
we have these set of lines followed by this set of lines let us say
so even though it is all supposed to be in one place one after the other i am showing it right and left
so let us say i have these set of lines followed by this set of lines
so let us see
so we have number one is power of 3 comma 5 number two is power of minus 4 comma 3
so at this point power of 3 comma 5 so that would be 243
i would expect number one to have 243 and power of minus 4 comma 3 is minus 64 negative 64 so that is supposed to be number two
so once i have computed it i can actually print it
so in this case it is only printing
you may want to use it in other calculations later also and we have completely delegated the work of power
so this whole thing is very clean and readable
so in this context i want to give some names
so at this point we say that the power function is being called at this point and this point and power is a function here
so this is called the caller
so the main function here is called the caller
the caller calls power function twice and power is the call e
so you have a caller which is main and you have a call e which is power and the caller can call call e multiple times
so that is what i said earlier
so you may have some task which is repeatedly done
so as long as you have written up the call e function and it is cleaned up it is correct and you have verified it and so on you can call it as many times as you want in any caller
so we will see more details of functions in the subsequent modules
welcome back
earlier i promised that we will look at pass by reference in a lot more detail
so in this module we will look at pass by reference and we will also see the case for passing arrays as parameters to functions and how do you program something like that
so let us start with a very basic example
so let us say i want to exchange the values of two variables
so i have two variables a and b and i want to exchange the values of a and b
so one way to do that is this follows
so a equals b and b equals a
this is a very common thing that beginners do
take a equals b and b equals a
unfortunately this is something that won't work
so let us just take a small example
let us say a was let us say a is a variable
so in memory it has a value of 5 b is a variable in memory it has value 3
then if you do a equals b it takes 3 and overrides the value here
it becomes 3
so because of this the value of a is lost
so both a and b will have the same value
instead what will actually work is something like this
so this is a very basic template for swapping two variables
this is something that you will see very often and you will also use it very often to swap two variables
so this is a very straightforward way of doing it
so instead of two variables just a and b which we already have
so let us say we start with that a equals 5 b equals 3
we also have a new variable called temp in memory
and what we are going to do is since we are losing a we will take a and copy it onto temp
and now if i copy b to a i lose 5 and i have 3
however i have remembered the value 5
so it is not a problem
now what i will do is to compute b i will copy back the value from temp
so from temp i copy it to b that becomes 5
so at the end we have a equals 3 and b equals 5
so this is a basic piece of code
so if i want to swap two variables in the body of a program i could do this
so now i want to take this and write a function instead
so i want to take two variables and i want to write a function called swap which will exchange the variables
it looks like it is straightforward
so we write a function
we take two variables a1 and b1 and this is a body of code
let us say i just copied and paste it from the previous slide
instead of a and b i call them a1 and b1
so clearly if i start with a1 and b1 at the end of this a1 and b1 would be swapped
so if a1 was 3 and b1 was 5 sorry if a1 was 5 and b1 was 3 as i had in the example earlier i would get a1 to b3 and b1 to b5
so that is guaranteed
let us go and look at how the function call would be
so i have a equals 5 and b equals 6
i am calling this function swap 1 of a comma b
and then i am going to print
so since this is calling the function i would expect a and b to be swapped
i would expect the printout to give me 6 and 5
unfortunately this one gives the result 5 and 6 itself
so a is 5 and b is 6 before the function call
even after the function call a and b seems to be 5 and 6 itself
so we need to think about why this is really happening
so to do that we will have to go back to the basic premise in function parameters and c
so let us look at what is going to happen
so i am in the main function let us say
so this is for explaining swap 1
so we had a which was 5 and b which was 6
and let us say at some point i called swap 1
so when swap 1 comes you are going to get an activation record for all the new variables
so what are the new variables
 we had a1 b1 and 10
so a1 and b1 were actually formal parameters
and temp was actually declared within the program
so if you go back we see that temp is a variable that is declared within the program
a1 and b1 are actually formal parameters
and the thing with c is we take whenever i have a function call we copy the formal parameters
so i make a copy of the formal parameters
5 gets copy to a1 because we call swap 1 of a comma b
a gets copy to a1 and b gets copy to b1
so i have 5 and 6
now the function is ready to execute
i have the variables a1 and b1
and what is it that we did there
 we took 5 made a copy on temp
so it got copied
and then we took 6 and then copied it to 5
so a1 got 6 and we took temp and copied it to b1 that got 5
so clearly at the end of this a1 and b1 got 6 and 5
so i already mentioned this
so it swaps a1 and b1
let us say now you are done with this the function returns to the caller
and the function returns to the caller what would happen
 so this side is the caller and this side is the call e
this is swap 1
so when the call e returns all the local variables get destroyed
you do not have them anymore
you cannot access them anymore
and when you came back did it really change a and b
 no
we made copies of a and b on a1 and b1
1 and b1 got swapped but they do not change a and b
so this is a common rookie mistake that people make that use call by value here because we called a1 and b1 by value we pass 5 and 6 within the function it is swap but when you return from the function it has not swapped
now how do we fix this problem
 so clearly this does not work
we need to think about something else
we will write this swap function using references
so as before we will start with the function
so we have a equals 5 and b equals 6
and what i am going to do is instead of swap 1 i am going to write a new function called swap 2
so clearly there was a problem
we should not have used pass by value
i am going to use pass by reference
so the way it is going to work is this follows
so i am going to write how to swap using references
i am going to call this function swap 2
so let us see how i could have done this
i have a which was 5 and b which was 6 and if i had passed values it would have been a problem
so instead what i am going to do is i am going to take the pointer of a and pass it on
so let us say i have pointer of a that would have been ampersand of a
we already know that
and pointer of b is ampersand of b
so the address of a and address of b
i can always get it
what i am going to do is i am going to pass that to the function
the function is going to take two pointers now and what it is going to do is follows
so let us say i have these two pointers
so i have a pointer now
i am going to call that a1
so this actually is now going to 025 and i am going to have another pointer called b1 and that is going to 026
so i copied ampersand of a into a1 and ampersand of b into b1
so a1 and b1 are not integers
they are pointer to integers
so we have them
now what i am going to do is i am going to have another local variable called temp because we already know that we cannot swap two variables without this extra thing
so not so easy
there are ways to do that using only the two variables
but in the method that we saw we declared another variable called temp
and now what i am going to do is i want to swap the not the contents of a1 and b1
i want to swap the contents pointed to by a1 with the contents pointed to by b1
so what is a1 pointing to
 it is pointing to 5 and b1 is pointing to 6
i want to swap the contents of that
in essence i want to change the contents of a and b
now how i am going to do that is i will keep a copy of the contents pointed to by a1
what is a1 pointing to
 it is 5
i will keep a copy of contents of the memory location pointed to by a1
then what i will do is i will take the contents pointed to by b1
so i want to take the contents pointed to by b1 and move it to a location pointed by a1
so what is b1 pointing to
 it is pointing to 6
i am going to take that and move it to the location pointed to by a1
where is a1 pointing to
 a1 is pointing to this location
i will move it here
and finally i still have to get the values of wherever a1 was pointing to that has to
so that has changed
we have to see what contents of b1 must be
so b1 is pointing to this location which had a value 6
so i have to take this value 5 and copy it into that
so that would change the values of this memory location
and when i return as before a1 gets destroyed
so it was a pointer but it was a formal parameter
it gets destroyed
b1 was a formal parameter
it gets destroyed
tempest a formal parameter that gets destroyed
so i return from the callee back to the caller but at that point already a and b are 6 and 5
so the key thing was instead of passing the values 5 and 6 if we pass the pointers to a and pointers to b i can use the dereferencing operator that we talked about earlier and get back to the values and use them
so that is what we are going to do
so i am going to pass address of a and address of b and i am going to try and print
so this is the function call
and let us think about how the function should look like
so swap 2 is not returning any value
it is not returning any value
and you have two pointers that are being passed on
so we need some mechanism by which we will take two pointers and i do not expect any return value so i will not have any return
so the function would look something like this
so i have void because it is not returning anything
i have swap 2 as the function name and as i said earlier we are passing pointers and the way to receive the pointers is instar a1 and instar b1
so we have two pointers to integers one called a1 and one called b1 now
and i was talking about a new variable called temp
so this is actually local to swap 2
it is an automatic local variable
and what i am going to do is i am going to take a1
look at the contents of whatever is pointed to by a1
so that is done by using star
the a1 is a pointer
star a1 gives the contents of the location pointed to by a1
i am going to keep a copy of that
then i am going to take b1
look at the contents of the location pointed to by b1 and make that the value of the contents of the location pointed by a1
and finally take temp which is a local variable and make a copy of that onto contents of location pointed by b1
and when you return back from here a1 b1 and temp are destroyed
so we made copies of the pointer
so it is not really destroying a and b
it is only destroying the copies of the pointers that we had for a and b
it is not even destroying copies of a and b
it is destroying the copies of the pointers for a and b
and it destroyed temp which was a local variable
it did not matter because by now we actually changed the contents of 5 and 6
so a would have become 6 and b would have become 5
so at this point if you print these two things you would get 6 5
so this is called swap using references
so what we have actually done is we have taken the two variables and we want the values of the variables to change
we are not going to work on just the copies
we want actual contents of the variables to change
and whenever you have anything of this sort where you want the contents of some variables to change and if you want a function which is delegated to doing that you have to pass pointers
so i will reiterate that
let us say i have some variables and instead of doing the work on the variables locally let us say i want to work on it by doing some delegation to a function
i want to pass it on to a function
but i expect this piece of code to actually change the contents of the variable
if i am going to only print them on the screen right it did not matter
i could have just printed using a function i do not need pointers
but i want a and b to exchange their values
the moment you write a function for that you have to use pointers to do it
you cannot just copy the contents and do operations on that because whatever you do on the copies will not reflect on the original variables that you had
now let us look at this larger picture
so i showed you how to do pass by reference for the small thing
we also did this earlier for quotient and reminder
there are several cases where we need functions to work on arrays
so let us say i give a list of numbers in an array and i want you to find out the largest of the numbers or i give you list of numbers in an array
i want to put it in decreasing order or increasing order and so on and i want a function to do that
so i can always go and write the whole thing in the main program itself
but if i am going to delegate duty and if i want to make it readable i am going to write functions
in that case we also need to understand how to pass arrays as parameters to functions
not just individual variables we also need to learn how to pass arrays
so let us see a simple example
so we will start with things which are only reading the arrays but not changing the contents of the arrays
so let us look at this simple example called print1
so it is a function which is going to take an array and print the values
that is all
nothing more
so i have two arrays in the main function a and b
so a is an array of size 5 and b is an array of size 7 and this function takes an array and the number of elements in the array
it prints all of it
so if you forget this part right now let us look at the body of the loop
the body of the loop if i have n for i equals 0 i less than n i plus plus print tab of i
so if i have some one dimensional table i want to print the contents of that i can do it definitely
so not a problem
now what i want to point out is the mechanics or how to do this
so if you look at the function call it has print1 a comma 5
so this point you are passing a which is the variable name that we use for the array
what it really does is it sends a pointer to the first element of a
so to print one the caller sends a pointer to the first element of a
and this on the other side in tab of so we have this int tab of left and right bracket
so what this does is it receives the pointer and we can do tab of i because you have received a pointer and from there on if i say i equals 0
so it is that pointer plus 0 steps away from it
then when you do when i becomes 1 it is that pointer plus one more step away from it and then two steps away from it and so on
so that is what we are going to do
so we get a copy of the pointer to this and then if you know how to access the contents of this i can print it
then i will get one step away from it so tab of 1 is one step away from tab of 0
i can look at the contents and print it then tab of 2 is one step away from that i can print it and so on
so this is a one way of passing arrays to functions
so what we have is we have two arrays a and b
so at this point you are passing pointer to a or pointer to a of 0 to print 1
in this line you pass pointer of b
so you pass pointer of b of 0 to the print 1
so tab is a local variable
tag is a formal parameter and n is also a formal parameter
so the formal parameter receives pointer of a of 0 the first time and it takes n equals 5
so it will print 5 entries
the second time it will this formal parameter tab takes the value which is the address of b of 0 and it will take n which is 7 and print 7 times
so this is one way of doing it
so there is another way of doing the same thing
so in all these examples the main function there is no change
you watch out for what is happening in the print alone
so this is the second version of print
so the first change we have is we have in star tab
so instead of in tab so in the previous example we had in tab of a re index like right
so instead we have in star tab in n
so this is as it was before and we have in star pointer ptr
what we are going to do is we are going to take ptr equals tab which means so tab the first invocation of print 2 will have a pointer to a of a of 0
you make a copy of that to ptr
so let us look at the sequence of things
so in print 2 a comma 5 when you call this the caller passes the pointer to a of 0
so a of 0 a of 1 and so on
so let us say that is the pointer
it passes that to tab
so you make a copy of that to tab right
and in this loop you have another variable called ptr which is also of pointer data type
and this pointer data type makes another copy of that
it ptr makes another copy of tab
now if you do star ptr where is it going to point
 so tab had a copy of pointer to a of 0
ptr is a copy of tab
so ptr also points to a of 0 right
so star ptr will print a of 0
then we come back and look at ptr plus plus
so since the this is an integer pointer this is supposed to point to the next valid integer
so ptr would have been pointing to a of 0
now ptr will point to a of 1 right
then star ptr will print a of 1 and we keep doing this till ptr is less than tab plus n right
so this is one way of doing the same thing
so i already talked here about this notion of arithmetic in tab right
so tab plus n means take n steps away from wherever tab was
tab is pointing to a of 0
so we are looking at a of and if i walk five steps away from it so tab would be pointing to something beyond a of 4
so as long as you are less than that you are good you can keep printing
so this is print 2
let us look at print 3
in print 3 we do not use this ptr anymore
in fact if you look at this print 2 all we did was we made a copy of tab to ptr
so tab itself was a copy of pointer to a of 0 and we made a copy of that and we use that for the iteration
we do not have to do that
instead what we are going to do is we have tab which is pointing to a of 0
so as before so we have a and this is a of 0 and a pointer to that is copied to tab when you call the function
so tab actually is also going to point to a of 0 and star tab would be a of 0 first and then this is actually running a loop n times right
so this is not using any pointer arithmetic for stopping the loop
instead we know that we want to print n of these variables on the screen
so just run the loop n times
so this check is actually on an integer right
so i equals 0 i less than n i plus plus will run this loop n times starting from i equal to 0 to i equal to n minus 1
and each time what you are doing is the first time when i equal to 0 star tab will be starting to a of 0
so tab is pointing to a of 0 star tab will actually print a of 0 and then you do tab plus plus which means you are actually pointing to the next location
the next time when you come around star tab would be a of 1 you print that and you increment tab to go here and so on
so that increment is happening here
so there is pointer arithmetic
this tab plus plus is actually saying wherever you are pointing to start pointing to the next location wherever you are
so it starts with a of 0 next time to point to a of 1 and so on right
and once a is printed when you come back here tab gets destroyed and n gets destroyed because these are in the colors they get destroyed
i also gets destroyed
now you start with b b 7
at that point you have this array called b which has 7 entries and you are actually passing the pointer of b to tab
so this is in the collared side in the collied side you have tab which starts with the copy of b of 0 right
so this is the setup right
so we saw three ways of doing this in the so this is one most likely way in which you will do things
this print of 3 the print 3 is the most likely way in which you will actually do things
so now let us go back to looking at how to use arrays and do some simple things
so in this example we have a small function which takes care of swapping right
so we have swap 3 we had two versions of swap earlier swap 1 which was actually incorrect swap 2 which was taking two pointers and swap the contents of the locations where the pointers were pointing to
here what we are going to do is we are going to take an array and 2 indices i and j
what we want is a of i and a of j to be swapped
so that is the goal of this
so the way to do that is very similar to what we did earlier
we have this new thing called temp
temp keeps a copy of array of i array of i copies array of j and array of j copies temp and this i claim is correct right
so even though it looks like it is very so if i replace array of i by a and array of a by b it is looking like it is swapping local variables but you are actually passing the pointer to the local variables
array of i is not the simple value right
it actually goes to what was pointed to by the thing called array
it will take the contents of that put it in temp right
so this is very similar to pass by reference only that the two pointers are the pointer to the ith location and pointer to the jth location
so you are accessing the contents of the location pointed to by what is happening in the ith location and j you can think of it as the index which gives you the pointer to the jth location of the array
you get that pointer you access the contents and so on
so this is a very simple way of swapping the contents of two variables in an array
so we have passed array by reference
we are actually passing pointers here
we didn't copy the contents of arrays onto the formal parameter list
we only passed a pointer to the beginning of the array and if you have i comma j right these are two indices
so array of i will go i steps away from the beginning of array
array of j will go j steps from the beginning of array and you are swapping the contents of these two locations
so this is how you get to swap two elements
so something like this is very useful if you want to do some things like order the elements in an array or find out the largest or smallest values in an array and so on
so this brings us to the end of this module as well
so we will see how to look at using the swap function to do finding out the end element in an array or the largest element in an array and see how to do swapping
thank you very much
there are several things that you can do as operations on structures
structures can be copied by using assignment statement
that is a very common thing you want to copy let us say one student's record to another student or you want to copy the date to another date and so on you can do those things
you can put an ampersand before a structure variable and you can get the address of the structure
so remember structure has intern as front records or members and these members intern may have other members and so on
all of them get packed as one unit in the memory back to back
if i put ampersand of a structure variable i would get the address of the structure itself
you can take structures and pass them on to functions
you can also make structures returned from functions
you can pass the entire structure you can pass only the components or you can even pass a pointer to the structure just like you would do for variables
for a variable i could have transferred the variable or i could have received a i could have passed on a pointer right
just like that you could do it here also
the only thing is you cannot compare structures directly with each other
so if i have int a b i could do if a equals b
however if i have struct point a b i cannot do is if a equal to b as a check
this is something that the compiler will catch and give us an error
so this is probably one major difference between basic data types and user defined data types
you cannot use equality operator or less than and greater than and so on to compare two structures with each other
let us see for an example how structures can be passed on to functions
so let us say i want to write a small function which is trying to find out if a point that is passed on to it is it the origin
so origin is the point 0 comma 0
i want to find out if the point that is passed on to it is actually the origin
so the function is called is origin and instead of passing two integers i am going to pass the data type called point type and the local variable name or the formal name is called pt
so we have talked about formal names and so on earlier
the formal name is called pt
so now this is a variable pt and for pt you have ptx and pty because it is of the type point type
so you are checking if ptx is 0 and pty is 0 in which case the x and y coordinate are 0 comma 0 respectively
yes it is the origin i return true lc return false
so this is the program here
let us see how this little piece of code would work
so let us say i have a point already in place and i call this origin of my pt
so let us say this is inside your main function
you have set up my pt to be let us say 5 comma 4
you want to find out this 5 comma 4 origin or not
so when you make this function call what happens is remember you can see that this is very this is actually passing by value right functions and you have something which is passed on by value
so pt is something which is local and it has two things namely x and y and my pt is in the collar and collar has two things x and y
and when you see this function call what happens is just like what happens for basic variables the value of the structure is copied to here
what i mean by that is the value of the x member is copied to the x member of pt and value of the y member of my pt is copied to y member of pt
so at this point pt has copies of the x and y members of my pt
now you can do this check is ptx 0 and pty 0
so you are going to go and check these values and you return 1 or 0
so the key thing to notice is that if you make a change at pt it is not going to reflect in my pt because you made a copy of my pt to pt the reason being this is a function call where everything is passed by value
we are not passing the reference to my pt
let us look at another example
i want to make a new point with the given x comma y values
so given a x comma y value i give the x coordinate and y coordinate and i want a new data type of the type point type
so this function we are going to call make point it takes two integers x and y and it returns a data type point type
so internally we have a declaration called point type temp
so this is local to make point and you change the x member to the integer that you got and the y member to the integer y that you got
so let us see how the sequence would have worked
you would have received let us say 5 comma 10 as the two integers
now if you say point type temp you have temp which is a structure and it is supposed to get two members x and y
now we say tempx equals x
so i said x was 5 and y was 10
these are the two values that were passed
so tempx equals x would copy the contents of x into tempx
so tempx becomes 5 and tempy equals y copies the content of y into tempy
so this becomes 10
so at this point your temp has the value 5 for x and 10 for y
and just like any other data type you can take this and return it
that is what we have in this piece of code
so again the key thing to notice is that we had integers copies of integers x and y and these two integers x and y there is no confusion of these x this x and y with respect to tempx and tempy
temp is a structure and tempx is a member within the structure whereas x is a free variable it is of the data type integer
so tempx is a qualification to get to the member of this structure called point type and in this case it is of the particular in the variable temp whereas this x is a free variable of the type integer it is not part of the structure
so let us see a few other examples
so let us say i have some declarations of this type
so i want to represent this screen that you see here as a rectangle
so i assume that the rectangle is already declared as a data type before
so i have struct rectangle screen and i have done a type depth point so i do point type middle
so middle is going to be a point and i want to find out given a screen what is the middle point in the screen
so we want these things
so to find out the middle point so let us say i start with 00 which is the left bottom of my screen when i call make point of 00 this is going to return a structure
so the return data type here is a structure and on the left side we have screen which is a rectangle but rectangle dot pdpt1 is a point
so on the right side you have a point on the left side you have a point you have matching data types everything checks out
so we have already marked the rectangles left bottom as 00
i want the rectangles right top to be 1920 1080 this is the resolution of my screen
i want the right top to be 1920 1080
so again then i call make point this is going to return a point so the return data type for this is a point and i want this to be set up as the right top coordinate for screen which is a rectangle
so these two lines take care of setting up the rectangle with the appropriate left bottom and the right top points and finally i want to find out what is the middle of the screen
so maybe it is somewhere here for my screen
i want to find out what this point is
so to do that i take the bottom coordinate of the screen and the top coordinate of the screen i add that and divide by 2 and i take the left coordinate of the screen and the right most coordinate of the screen i add them up and divide by 2 that would give me the center of the screen
so these two things are integers and make point takes two integers and returns a data type called point
left side is already of the data type point and the right side expression gives the data type point so both the sides are of the same data type
so if we assume that these declarations are already in place this code using the structure will give me a given screen it will tell me what is the middle point of the screen is
so let us say i want to give you a point and i want to find out is this point inside the screen or not
so i am going to write a function called this pt in rect
so you can think of it as a question i am asking you is this point inside the rectangle and i am going to pass the rectangle as r and going to pass the point p as the point as p
so i could ask this about any such point it could be something outside the screen or inside the screen i do not know
i want to find out if it is outside i want to get false and if it is inside the triangle i want to get true
so i have let us say this is my rectangle and i could give you point p as this or point p as this or point p as this and so on you could get any of these things
now how do we find out whether this point is actually within the triangle shown here
so i want to find out whether this point is actually within the triangle
so to do that if i know a friend that the x coordinate of the point is to the right of the beginning of the screen and the x coordinate is to the left of the right side of the screen then the point is somewhere in between the left and right side of the triangle
and if it also happens to be above the bottom of the triangle and below the top of the triangle if all these four conditions are satisfied then the point is within the triangle
so this point is not within the triangle even though it is within the y range of the triangle it is not in the x range
so it is to the left of my left most point so this point is not a point in the triangle
so or this point this point and so on these would not be in the triangle
for all these points you would get false and points like this i have started with right so point like this and so on will get true
so this is a small piece of code which actually takes two different structures one which is a rectangle and one which is a point and remember rectangle r has p t 1 and p t 1 has x member and a y member
so p t 1 if it is the left bottom point it will have x and y coordinates and we are comparing that with the coordinates point passed down by variable p
so just like basic data types you can also do a few other interesting things with structures
for instance let us say i want an array of 10 points maybe i want to define a polygon which has 10 sites i could do it using this
so struck point in x comma y and point array of 10
so what this gives us is we define a structure called point with two members x and y
we do not want just one variable of the type point we want 10 variables of the type point
the variables are going to be called point array of 0 point array of 1 and so on all the way up to point array of 9
so you could also do the way it is given here you can just stop with the structure description that is given here on the top and then ask for point type point array of 10
so this is also a valid way of asking for point
so in this case i assume that there is a type def struck point is given as point type and finally even if you have arrays you can initialize them
so this is an array of structures on the right side
so point array is an array of structures
so you can think of it as i have an array and each one is a structure and the structure has x and y
so this is point array of 0 x and this is point array of 0 y
this is point array of 1 x and this is point array of 1 y
this is point array of 2 x this is point array of 2 y and so on
so in this case the point array has 3 points
so the x will get 1 the y will get 2 at point array of 0 then point array of 1 dot x is 2 point array of 1 dot y is 3 and finally this would be 3 4
so this is the setup that we have for array of structures
you can access the individual members using arrays as given below
so you can say point array of 0 will be a structure given that structure you can access dot x and get the x member
or you could even use point array of i to get the i th structure or i th member in the array and in that you want the x coordinate and y coordinate to take the values 5 and 5
you can also do read of these values point array of 0 dot x and point array of 0 dot y can be used as they are given here and printed and so on
so finally arrays structures can be assigned to each other
we have been seeing this for a while now
so if i did make point 4 4 make point is a function which is going to return a point with its x as 4 and y as 4 and since the right side is a structure of the data type point i should have the left side also to be of the same data type
in this case new point is also of the same data type
so what it would do is whatever is returned from here it does member wise copy
it copies each member on the right side to the corresponding members on the left side
so you can assign structures to each other
so this is a useful thing because you want them to be treated as basic data types
so this brings us to the end of this module on basic structures and we will see how we can do a few other things with structures by passing them on to functions and so on in more detail in the next module
welcome to this module on structures
in this module we are going to look at how do we use structures and how do we use pointers to structures because this is something that comes in handy in many places
even in the course later you will be looking at the notion of link list and so on and for that you need not just structures but also pointers to structures
so in this lecture we will go and look at this basic data structure basic structure called complex numbers
so c does not give you a data type for complex numbers
there are a few languages which give you that but c does not provide you that and one way to get complex numbers is by faking it
what we will do is we will define a structure called complex and the complex structure it has two fields or two members namely real and imaginary
so we are going to keep this as our complex number
so a complex number is going to have a real real member and an imaginary number and from now on complex is a data type that i can use
i can take this data type pass it on to functions pass them back from functions and so on
so i am going to write a function called sum which takes two complex numbers m and n and returns a complex number and we are also going to write a function called product which again takes two complex numbers and returns a complex number
so this in some sense is similar to passing two basic data types and getting a value out of it
so c does not prevent you from passing structures to or back from a function
so let us look at how this might be done
so in the first line here we do declaration for four complex numbers a b c and d and we are going to take the complex number c as the sum of the complex numbers a and b and the complex number d is supposed to be the product of the complex numbers a and b
so we first go ahead and scan the real and imaginary parts of a and b and once that is done i would like to do something like this c equals sum of a comma b
it should add up the corresponding real values and put it as c's real value take the imaginary values of b add it up and put it to be put it to the imaginary value of c and so on and i may also want to do things like product of a comma b print sum and product
so this is something that i want to do let us go and see how the sum function and product function are going to get written up
so the sum function is supposed to take two complex numbers m and n
so inside we have a local variable called complex p
so p is a local variable the p's real value gets m dot real and n dot real added up and p's imaginary value gets m dot imaginary and n dot imaginary added up and you return that to the caller
so if you notice p is returned to the caller here
so you can see that here p is returned to the caller if you go back to the caller the caller is expecting something of the type complex numbers the left side is a complex number
so everything is good there
similarly if i want the product so we know that product of two complex numbers is given as follows
so the real part comes from the product of the real part minus product of the imaginary part and the imaginary part is the product of the real and imaginary combinations added up together
so this gives you the real part and this is the imaginary part again we have a local variable of the type p and you compute what should go into p dot real and p dot imaginary and you return p
so you are returning a complex number and when you return on this side the products complex number
so this is a complex number that you get gotten return the real part will get copy to d's real part and the imaginary part that you return will get copy to the d's imaginary part
so this is the way to pass on structure variables to functions and get back structures from functions
so as of now we do not have a mechanism to i did not show you a mechanism to pass on pointers to it
so we will do that now let us look at this basic thing right
so what we have is we are going to have point type p t 1
so point type point 1 and star p t r
so let us take this a little slowly
so we already know point type is defined to be struck point
so point 1 is a variable of the data type struck point and star p t r on the other hand is a pointer to the structure of the type point
so it is a pointer to point type data type right
so here this is like a basic variable and this is only a pointer
so when we say point 1 we actually allocate two members x and y and give it to point 1
whereas when we say point type star p t r we do not do allocation for star we do not do an allocation for a structure
we just allocate space for a pointer that can point to a structure we do not allocate a structure yet
so point 1 is make point of 3 4 this will give you a point whose x coordinate is 3 and y coordinate is 4
now you can do things that you did on basic data types
so p t r is ampersent of point 1 takes the address of the structure point 1 and assigns it to p t r
remember it is not taking the address of the members of point 1
it is taking the address of the whole structure point 1 and it is passing that as the value to p t r
so at this point p t r is going to point to the structure
so if point 1 let say point 1 is of this type
so this is point 1 it has some x and y coordinate and this whole thing is going to sit inside some memory it is going to sit somewhere
when we say p t r p t r is also going to get one memory location and as of now it is not pointing anywhere
the moment you say p t r is ampersent of point 1 it would start pointing to the structure here
actually technically it points to the first byte of the first member of the structure it goes to that location
now we want to know how to dereference this like we did for pointers in basic data types and the way to do that is use what is called a star operator
so in star operator so let us see what this is doing
so print f percentage d percentage d star of p t r dot x
so p t r is of the data type pointer to a structure
if i do star p t r i get structure and therefore if i do structure dot x i get to a member
so this thing what you see in the blue circle here is correct because you started with p t r which is a pointer to a structure when you do star p t r it actually dereferences the pointer and gets the structure and you are looking at structure dot x
so it looking at the member x and member y here respectively
so the parenthesis here is actually crucial
so the star and parenthesis have different precedents
therefore you have to put this whole thing inside the star and p t r should be within the parenthesis but this is sometimes very laborious
so c gives you another shortcut to look at the member that is pointed to by a pointer of a structure
so i will repeat that i want to get to a member that is pointed to by pointer of a structure
so the pointer of a structure is p t r here and i want to get to this member called x
so one way to do that is use p t r arrow x
so it is not a arrow symbol you do not see a arrow symbol on the keyboard it is actually a dash followed by the greater than symbol or a minus sign followed by the greater than symbol
so it is two characters
so when you say p t r arrow x if you see as if you see something like that what it means is p t r is expected to be of a pointer data type
it is not just any pointer it is a pointer to a structure and when you use arrow you actually get to the member
so p t r arrow x takes you to the x member of the structure which p t r is pointing to and p t r arrow y will take you to the y member of the structure that p t r is pointing to
so this is one way to pass on this is one way to refer to the contents pointed by p t r
you can always do star p t r dot x but be caution that you have to use parenthesis around star p t r
so now let us look at the notion of precedence in association
if i have a combination of various operators what gets precedence and how do i interpret do i have left to right association or right to left association for the combination of operators we look at that
so both dot and arrow are actually at the top of precedence hierarchy
so if you have an expression which has a dot and an arrow along with plus and minus and so on dot and arrow gets highest precedence over everything else right
so let us see a small example here we have a rectangle called r and we have a pointer to a rectangle which is called r p and r p is made to point to rectangle r itself
so remember rectangle r is supposed to have so let us say this is the space allocated for rectangle r rectangle r itself had something called p t 1 and something called p t 2 and p t 1 in turn had x and y p t 2 in turn had x and y
so this would be the layout for r r is a variable struct rect is the data type
so this is the layout for r not for rect and r p the moment you say struct rect star r p r p will get a memory location which is supposed to point somewhere and what is it pointing is it pointing to a percent r which means is pointing to the first bite of the first member of r
so it is actually going to point to the address where p t 1 x is present inside the inside the rectangle r
so if i say r dot p t 1 dot x i am referring to the p t 1 p t 1 x member i can also say r p r o p t 1 dot x
so in this case the weight interpret that is r p r o p t 1 is a structure and you want the member x of that structure
so this is where the precedence and association comes in both r o and dot r of the same precedence and they go from left to right
so therefore the way to read that is first do de referencing with respect to r p that gives us a structure and that structure dot x gives us the member
so what this does not do is it is not interpreted as i will first take p t 1 dot x
so p t 1 dot x what is the data ripe for it p t 1 is a structure of the point data type and p t 1 dot x is actually an integer right
and if i say r p r o something there is no r p r o integer because r p is a pointer to a rectangle and rectangle has only points inside it does not have integers inside
so the association went from left to right and the precedence also went from left to right this is the correct interpretation it is not interpreted as r p r o p t 1 dot x
and you can also put arrows if you are in doubt if you are not very careful if you do not really know what it is doing and if you want to be sure what it is supposed to do you can always put arrows around them
so in this case by you can always put parenthesis around them in this case you have put parenthesis
so that r dot p t 1 is supposed to give a structure of the type point and when you do dot x it gives you the x member of that point
and similarly r p r o p t 1 will give you a structure of the data type point and it is now okay to take the data type to do a dot x whereas it would have been incorrect to do r p r o p t 1 dot x right
so this brings us to the end of module on the structures and how to use pointers along with it there are also lot of things that you have to be careful when you use operators like plus and minus and so on when especially when you have the dot operator and the precedence and the arrow operators
so remember that dot and arrow has higher precedence over various other things like plus and plus and minus and so on just keep that in mind and when you are in doubt always put parenthesis around the structures that you want
so this brings us to the end of module and thanks for watching
ok good morning
in the last class we try to motivate you on different types of problems which can be solved very nicely when they converted to graph problems
remember we saw this problem on designing a traffic signal for this five point intersection assuming that all traffic goes from left to is on the left hand side of the road like what it is in india
and we found it all over this looks like very looks like a very domatable task designing a signal for this
we found that as soon as we abstracted information from this and transformed this to a graph problem where we made the nodes the directions and the edges correspond to two nodes that are connected are connected such that these two directions cannot happen simultaneously
we found that it was very easy to design a naive algorithm which is called the coloring problem
and all that we had to do was we start with a particular node and let us say start with ac and then i say for this if this is green then it cannot be green for ba and bd whenever it is directly connected by two edges then you cannot have assuming left hand side traffic as in india
so we found that we could easily solve this problem by a very naive coloring algorithm and make sure that directions which intersect are not colored the same at the same time
and once all the nodes are exhausted in the graph with this coloring problem every node has been colored then we have a design of a traffic signal
so i guess this was a very nice motivating example to show why when you abstract to a graph problem then solving becomes easy then we looked at representation of graphs we defined what graphs were and so on
today what i am going to do is i am going to take one particular problem on two problems actually one on the shortest paths problem which is given a node and nodes and a set of vertices
let us say these are the nodes that we have a set of vertices and given a set of edges sorry and objective is you have this is a directed graph let us say and we are given weights on the edges to say how expensive it is to go via that particular edge to take that particular path
and our objective is let us say let me put some weights on this let us say i have 8 here 2 here 15 here and 3 here and 2 here and let us say 12 here
and our objective is starting with some vertex let us say this is the source vertex s i want to go to all these destinations b c d and e my objective is to minimize the cost
what is the cost now
 the cost of a particular path for example from a to c i can go either via the direct path or i can go via b to c and the total cost of the path here is 8 plus to 10 where is the direct path cost you 15
so the idea is to find parts of the sky for example if is a path from a to c via something else which is so cheaper than the direct path then we should find those parts which are lower in cost
so the objective is of this algorithm is called a single source shortest path problem the single node which is identified as source and you need to find the parts to from a to b a to c a to d and a to d a to e such that the total cost of the path is minimized that is the length of the particular path
so for example if i am going from a to d i can go a b c d or i can do a c d and notice that 8 plus to 10 plus 3 13 whereas this is 15 plus 3 18 therefore this path is shorter from a to d than going from via c
let us see how this algorithm works and then most importantly this algorithm assumes it is important for this algorithm to be able that no edge has a negative label
that is very important to assume and the algorithm uses we already talked you already learnt about the greedy paradigm and the dynamic programming paradigm
here this algorithm uses what is called a greedy paradigm as you already learnt greedy is what we make local decisions which are optimal we do not worry about the global optimum but interestingly what happens is in this algorithm even though the decisions are made locally these also scale for the global case
so even when you know all the notes
so what we do is in this algorithm we start off with a particular vertex a and say that i have what is called a source vertex list and a total vertex list
then what i do is i initialize let me say these vertices are numbered in the particular algorithm 1 2 3 4 5
so initially i say include the vertex a in the given list
in the algorithm for example i have said s equal to 1 because i am using an integer here to map the vertex name to this
so basically this is equal to 1 over here and then what we do is we try to find the shortest paths to all the other nodes
so what we do is for this we do a very simple algorithm we maintain what is called a distance matrix distance vector sorry and we maintain the distances to the other vertices
let us say this is d c d and e
so first we using the adjacency matrix that we have we fill up this for example this information is given
we assume that the graph is the first completely known the graph is static
so what we do is we have the direct edges
so i have from a to b the distances 8 a to c the direct distance is 15 a to b i do not have a direct path
so i market as infinity and then a to e there is a direct path i market as 12
so initially i make a distance vector like this
then what we do is from the set of vertices we include in the set s the vertex that is closest to it
so if you look at 8 15 12 8 is the closest
so what we do is to the vertex a in the directly connected edges
so we include in the vertex list the list b and then what we do is we see whether there is a path to c that is y or b which is short and similarly i do this for the vertex d for the y or b and similarly we also look for vertex e y or b if there is a shorter path
so what we do is if you look at it here
so what is it that we have
 we have a direct connection from a to c which is cost 15 and then 8 y or b to c is 10
therefore this is shorter
so what we do is we update this path and call this 10 here and there is no path still from b y or b there is no path to d
so we leave it as it is there is no path y or b to e
so we leave it as it is
so we have this updated matrix and interestingly the vertex b is part of the source list
next what do we do
 we again take the next vertex which is closest for example with from a using this distance matrix
then we find it i include c here and then from c now some some we remove it from the distance matrix
we know that the cost of the path from a to c is 10 is there a shorter path from c to d such that the distance from a to d can be minimized and that is obvious a to d our original distance was infinite a to c the distance a plus to 10 10 plus 3 13
therefore we update this distance to 13 there is no path to e so we leave it as it is
next what do we do
 we choose the next vertex which is again closest to this list and then we get e over here e is smaller in distance from a
so then we see if this there is a shorter path from a to d there is no other path here and now we are done
so what do we have now finally we include the vertex e to the source list
so this is essentially what the algorithm is and now what do we have if you backtrack you can get all the distances from the vertex a to each one of these vertices
that is what this algorithm is trying to do if you notice v in v minus s it tries to keep updating this particular distance
so once we have finally your matrix d will contain the list of vertices with the list of the distances from the source vertex one or as in this case a to all the other vertices
the time complexity of this algorithm notice that if you look at this over here the cost of the to find the minimum over here it is going to take you order n and this is running n times therefore the time complexity is about n squared for this algorithm you already seen complexity analysis sometime back and this can be much better to order e log n if the number of edges in the graph is much less than n squared with appropriate use of data structures and organization of graph for example if you used an adjacency list representation and then organize the edges in an appropriate data structure you will find that the time complexity can be brought down to order e log n
so this is the single source shortest path problem of daikstra by the way i forgot to mention this algorithm is due to daikstra one of the founding fathers of computer science it is not pronounced as digicstra it is pronounced as daikstra basically he is dutch and that is why this dyke st re ok
the pronunciation is this ij is pronounced as i in dutch ok
so this is the complexity of the algorithm it is most important to note is that the edges cannot have negative weight
why do i say that because it is possible that once one so particular vertex has already been included into the graph let us say you know i had i had let me change this path over here and suppose i had included this vertex into my list and the let me this not a good idea see if it has this and there is a dc d here and let us say i already included e into this graph here at some point and at that time the problem is i cannot have negative edges because if you look at this issue over here as soon as the edge becomes negative that negative edge gets included much later let us say this is 8 plus 2 10 and this was let us say this was minus 10 over here and the let us say i had another vertex here c 2 let us say f which was 5 or something and then i could go back to b like this and so we have said that path length from a to b is a to over here and suppose this was minus 10 and i already included being the source vertex list therefore i am not going to consider it again but when you see here minus 10 plus 7 minus 3 right
so it is possible that from c there is a shorter path to the vertex b suppose this was already there at 15 here and then let us say this was minus 10 plus 2 and i would have a shorter path to b via c and this is precisely why we cannot have negative edges on the given graph
so 15 minus 10 is 5 5 plus 2 7 therefore you have a shorter path via b via c to b c and f to b whereas the original path that we have included is of length 8
so this is the this why this algorithm only works with positive edges
why is this algorithm important especially today in the day of networks for example we have a dynamically changing network and for example what called the cos b the cos could be cos of let us say in the example that i could take that i have taken it is possible that these cars this is i i t madras and you are going to central station and which is the cheaper path is what you are looking at this could be taking a taxi whereas this could be taking a let us know graph if you remember is taking a bus for that matter and whereas in network today it is becoming very important because when you look at congestion that is there in the network you can model the congestion as a weightage or the graph it is a dynamically changing scenario and you are constantly looking for better paths to transfer packets from one node to another on the network ok
so the next problem that i am going to take up is what is called the minimum spanning tree algorithm and if you notice here the idea is given a particular graph of this kind the objective is to find a tree which connects all the nodes in the graph of minimum cost again the cost could be congestion as in a network or the cost of a link for example the here if i want to send something very fast then if this is a fiber optic link then the cost is very less and things like that
this algorithm is again based on the greedy paradigm and what do we do in this here the nodes are named 1 2 3 4 5 and 6
so what we do is let say without loss of generality i can take any node as this source vertex let us say i am taking one as the node then what we do is we incremently keep on including we we basically partition the graph into 2 sets of nodes 1 set of nodes which have already been included in the spanning tree and other which have not been included into the spanning tree
so what do i do i start with 1 and initially i at the lowest cost edge into the tree ok
then what happens i have 1 and 3 in one part of the in the in the which correspond to the one corresponds to the tree edge and 1 and 3 are the nodes which connect this tree edge and they belong to one set then you have 2 5 6 and 4 which belong to the second set
then what we do is given this 1 and 3 are connected i try to find from the original gaps which is the lowest cost edge which connects it to the rest of the graph
so here you find it all 3 are 5 over here and this one is 6 from 1 to 2 the cost is 6 3 to 2 the cost is 5 3 to 4 the cost is 5 and therefore the 3 to 6 the cost is 4 and 3 to 5 the cost is 6
so what we do is amongst all these edges which connect 4 is the cheapest edge so we chose the 4 edge ok and now what happens you have 1 3 and 6 belonging to one set and 2 5 and 4 belonging to the other set
now once again what you do is you find out the lowest cost edge which will connect 1 3 and 6 to 2 5 and 4 which means this is the lowest what is the lowest cost that we have here notice this 1 3 and 6 have been connected right
now when you look at it here you find the low the 4 is connected 6 is connected to the vertex 4 with a weight of 2 6 is connected to 5 with a weight of 4 weight of 6 and 3 is connected to 2 with 5 3 is connected to 4 with 5 and 1 is connected to 2 with 6 therefore this is the lowest cost edge
so we take this lowest cost edge in and finally let me choose this last vertex to be connected once all the vertices are exhausted your the algorithm is done this algorithm is what is due to print and ideas initially what we do we have 2 sets of vertices use a set of vertices you and v is a vertex t is an empty set initially use initialize to 1 and while v is let us say the original vertex set of the graph until all the vertices have been included in that u list you exhaust every one of them
so what are we doing now if v is original vertex set that is given while we be used not equal to v let u v be the lowest cost edge such that use in u and v is in v minus u then you make a tree with t union u come away then you include v into the u list just like we did over here we started with 1 we included 3 and repeat this process until all the vertices are included in the u edge list in u vertex list which is the same as v now the time complexity of prime algorithm is also order n squared but if you use a priority q with when e is much much less than n squared and a appropriate data structure for representing the graph you can get a better algorithm of order e log e where is the number of edges in the graph
in this lecture we are going to learn about traversal of graphs
and you know you remember when we talked about trees we talked about you know a tree was given like this and we said there is a pre-order there is a post-order and there is an in-order traversal of the tree
and then we said pre-orders when you mark the node the first time you see it in order is the second time you see it and post-orders the last time you see a node when you are walking around tree from left to right
if you remember this is what we talked about different traversal of trees
we also talked about a level order traversal of the tree
all this was not discussed in great detail for example if i have a tree like this then let us say 1 2 3 4 5 and 6 would correspond to the level order traversal of the tree
the tree was in a sense a little easier for the simple reason that we had a designated node which was called root and from the root we try to access the other nodes in the graph
there is only one node through which you can access the other nodes
but in the graph as we said there is nothing like hierarchy of nodes
but nevertheless my objective may be to see what are all the nodes that are connected in this graph
and somehow reach all these nodes in the graph
how do i go about reaching it
 when i started a particular node how far can i go
 how deep can i go
 so there are two types of traversals and graphs
one is called the depth first search and the other is called the breadth first search
basically the idea is to visit the vertices and oxafagraph in a systematic fashion
that is the objective of these two traversals
what do we mean by systematic fashion
 we will see in a little while
the depth first search is a kind of a generalization of the pre-order traversal of a tree and it forms the foundation for a large number of problems which we will see
so what i am going to do is i am going to take an example graph here which is a directed graph
let us say these are the nodes that we have a b c d e f g which are connected by directed edges
so let us say it does not matter which node i start the traversal from
in depth first search we try to start with this particular node let us say it what are the edges that are connected
let us assume lexicographic ordering
a is connected to b and a is also connected to d
this is what my adjacency matrix or adjacency list will tell me
similarly b is connected to d and b is also connected to c
c is connected to a and d
all this information will come from your graph representation
so i start with this particular node and we try to go as deep as possible
let me see that we try to explain what this means
i start with a let us say the first node that was listed in the graph
assuming lexicographic ordering was b
so i go to the node b and then from b what i do is i try to reach the node that it is basically the ideal d
start from a go to b from b go one level down go to c then from c i go to d then from d notice that all the arcs are only towards d and it is not possible to go any further
but i want all the vertices in the graph to be visited
so what do i do
 i go to the next vertex that is there
i start with e e is connected to f and from f is not possible to reach g which is the last node in the graph and all these other nodes have already been visited
so i then i finished with f i go to g from e and then the graph traversal is complete
so what does it give me
 it gives me what is called a depth first spanning forest
starting at the node a i have a b c d one tree here and you know i notice that e f and g are two trees which are not connected
they are only connected by what are called back arcs and so basically what does it tell me
 that going forward from a i cannot reach the nodes e and f via the other nodes b c d start separately for that
so this gives some kind of an idea of the reachability of nodes from one node to the entire set of nodes in the graph and there are some definitions that coming
you call for example the arcs that connect between a pair of nodes at the same level or across the forest as cross arcs and then edges that go from a level that is deeper to a level higher are called back arcs
then edges that go from a level from a node that is at a higher level to a lower level when assuming higher level is 1 and 2 1 2 3 for example is a forward arc
so you get some nice definitions of graphs
so this depth first traversal is an important algorithm and this is how this depth first traversal works
so what do we do for every node
 notice that it is very similar to pre-order traversal that you have done with trees
what are we doing
 as soon as you see a node you mark it as specific
then what we do is for if mark of i is unvisited then what are we doing once again
 we are restarting dfs at the node which has been marked visit
and so what are we doing now
 we keep going through this again and again and we call this depth first search algorithm again
so this is dfs of v for w equal to vertex mark v for each w in l of v which is adjacent to the vertex v
if mark of w is unvisited then you call dfs of w that is the most important point
you try to go as deep as possible
this is the algorithm for depth first search
so initially what are we doing here
 we are marking all the vertices as unvisited and for each unvisited vertex we try to go as deep as possible in the depth first search algorithm and we just saw an example in this particular graph
so starting from the vertex a we go to b from b you can see from c you can reach d assuming that we have represented the graph in a lexicographic order
and after d we notice that all the arcs are only coming into the vertex t and you cannot do anything more
therefore you start with the next unvisited vertex in the graph which is the vertex e and then try to reach as far as possible
what are the applications of first of course the complexity analysis it takes about order e time i am sure you guessed it because sometimes you can have arcs which are number of edges can be less than the number of vertices is generally less than the number of edges and therefore the time complexity is can be as large as the number of edges in the graph
what you get the result is a depth first spanning for us
what are the applications of this there are some interesting applications
let us say you want to how can you use in what application can i use depth first search that is the question that i want to ask
let us say you know you have you know all of you register for courses from semester to semester and let us say these are the courses c 1 and c 2 and c 3 means c 1 and c 2 are prerequisites for c 3 and c 4 has a prerequisite of c 2 and c 5 has a prerequisite of c 3 and c 4 which means you must have done c 1 and c 2
so somehow is it possible that when you try to register for a course it looks at the list of courses that you have registered and can come back and tell you whether you are eligible to register or not
so we need some kind of a ordering this ordering is what is called the topological sort and here what am i saying
so c 5 this is one topological order c 5 requires c 3 and c 4 and c 4 requires c 2 and c 1
so c 4 tells gives me an ordering telling something must be done before this particular task
so what we can do is we can go back to the use the depth first search and instead of outputting a given node as soon as you see it you can give it in the reverse order of the depth first search
same depth first search algorithm
so what we do over here is that so this gives you that particular order if you use this particular algorithm here
so what are we doing here this topological sort algorithm mark the particular vertex is visited
then for each vertex w and l of v if m of w is unvisited then top sort of this notice that v is output last that is the most important point
i might have started the topological sort from either of these two vertices and then you print them in reverse order the last vertex that is going to be listed as c 5
once the c 5 and then finally it prints all of these and notice what does it tell me here
it says c 3 and c 1 must have been completed before c 5 and c 4 and c 2 must have been completed before c 5
therefore if you want to register for the core c 5 you must have completed the prerequisites which is c 3 c 1 c 4 and c 2
that is the most important
that is one application of depth first search
now i am going to leave you with another application of depth first search
these are called the articulation points on a graph
an articulation point of a graph is a vertex such that when we remove v all the edges incident upon v the graph g is broken into two or more pieces
so we want to find what are the articulation points on the graph
how do you go about doing it
 if i remove the node a the graph gets disconnected
i am using an undirected graph here
similarly if i remove the node c the graph gets disconnected
if i remove the node b nothing happens because the rest of the graph is still connected as one piece
so how do you find that
 there is a nice dfs using depth first search
there is again another algorithm that you can develop and what we do is suppose i am starting the depth first search here
i give it a number one
this is called dfs numbering
then b is given a number two
d is given number three
e is given number four and so on and five six and whatever
so what we try to do is once we have done the depth first search and we got depth first spanning for us
we also keep track of another number
we say using the graphs which are not the tree graphs
what is the lowest dfs number that i can reach
 so what is the tell me here
 if i look at dfn of b here is two
but using a back arc i can go up to the vertex a
similarly for d its df number is three but i can reach i can go back to one using the back arc
similarly for the vertex e its df number is four but i can reach one
the df number of a if you notice is one and it can only reach up to one
similarly for c and n and so on
see you notice it is five
so what we do is it is once you have done this you found the df numbers based on the way the vertex is accessed to the dfs call and you have kept track of low here and you have formed this particular graph with all these additional information
you look at a particular node and then check whether from that particular node you can reach a node with a lower df number
if you can reach a node with a lower df number that node is not an articulation point
whereas it is equal to that for example i can see over here and a over here a and c correspond to the articulation points in the graph
so this is another application of depth first search and you will find strongly connected components
there are lots of nice problems which can be done with depth first search finding cycles and so on
bread first search is another algorithm where we try to search as broadly as possible
so let us look at this graph again here
so let us say this is the graph that i have
i have taken an undirected graph because for the depth first search we took a directed graph
so what do we do now as widely means again if you assume lexocographic ordering in your vertices
so let us say i am starting with a then as wide means i go to b then i go to d then i go to e then i go to c
then once i have exhausted all these vertices i start from b and check if there are some vertices which is disconnected to that are not part of this bread first spanning tray or spanning forest
and then i try to again connect them notice that is the end year already completed but only from c i can reach fng so again i do as by d is possible
so now depth first search indirectly when you remember in depth first search we meant as deep as possible
therefore it is a recursive function call if you remember here
therefore it uses a stack implicitly to solve this problem
here on the other hand what is it that i want to do going back to this particular graph
i visit the node a then i do as broad as possible then i have to come back to b and check which are the nodes that are easily b d c for that matter
so basically i need to keep track of the nodes that have been visited
so what we do is in breadth first search we use a q data structure
so we put all the starting with the node a for example we initially of course we assume that all the vertices are unvisited
we mark the given work vertex is visited on q in particular vertex
and then while the q is not empty we take the first element in the q
so what are we doing again going back to this example i am taking the first vertex putting it in the q
then after putting it in the q then what do we do
 we d q the element for each vertex y that is adjacent to the vertex x we are if mark of y is unvisited then you make it visited and then make that edge part of the tree
then you keep then you unq the vertex y repeat this process and you repeat this until the q becomes empty that is the most important point
so what are we doing once the q is empty what is that once
so what do we do we take a is unq then d q a then you put b d c in the q then we look at d here there are no adjacent vertices which are not as part of the breadth first search
so i do not need to worry about it similar with d similar with e and finally come to c
then i unq fng and then i make these edges as part of the tree and we are done
so what is the advantage of this there are many application breadth first search you can build what is called a breadth first spanning forest then we cross edges actually correspond to cycles
so we are going to find the closest ancestor and that will give you a cycle
a breadth first search is also useful for designing finding out what is the diameter of graph the longest path between a pair of nodes
so this is kind of the these are the so what we have looked at in this lecture is a set of algorithms which use depth first and breadth first traversal on graph
so that and you notice that these are just algorithms by which i can reach as far as possible all the nodes in the graph i can also find the path between a pair of nodes in the graph and once i have things like a breadth first search spanning forest and i want to send information from one node to another then i can find out what is the total path length to reach these various nodes in the graph
so the references for this course i have essentially used all these references various parts from all these references and i hope you enjoy doing the assignments and the problems
thank you
hello welcome students
so in this session solving problems i thought i will show you the solution to this problem on printing the matrix in a spiral
so we have given a matrix and we have to traverse it in a spiral order and print the elements
so baratmi for today i have a terrible sore throat
so they say here from the horses mouth today you are going to hear from the horse itself
so let us look at this matrix here
it is a 4 cross 4 matrix which is given as a public test case for you and when we say traverse this in spiral manner what we are going to do is we want to go in this order
so we want to traverse the top row first and after the top row we traverse the rightmost column
he traverse the bottommost row and traverse the leftmost column
at this point we have reached the we have done with all the outer layer and now we are supposed to go to the inner layer and do things inside and so on
so i am going to define something called peeling
so think of it as what you do with an onion
so you take an onion and you remove one layer completely what you have done with this you have removed one layer and you are still left with an onion which is similar to what you had earlier
just like that if you take the elements from the top row then strip of elements in the right strip of elements in the bottom and strip of elements on the left you would be if you start with the rectangle you would you would be left with another rectangle
in this case you would be left with the rectangle 4 3 2 and 8 if you remove the outer ones
so you peeled one layer and you are left with another rectangle and on this rectangle again i can start at the left top and move one step at a time and print all these elements
so now i am done with one layer
so of course this arrow must not be there
i am done with another layer inside and so on
so if i keep peeling one layer after another i will be left with a sub problem which is similar to the original problem itself
so this is a nice structure to this whole setup
so now the question is how long do i keep peeling and what are the corner cases
 so to show that i have a small grid which is 10 rows cross 7 columns here
i want to see how many times we can actually do this operation of going on the top traversing on the right being in the bottom and then again traversing on the left how many times we can do that
so just follow my marker carefully
so i start with the left left left most cell on the top i do one traversal then in some sense i turn right then turn right and then go all the way here
so that takes care of one layer of peel
so that is my green line here is the first peel
once i am done with that i am left with a sub problem which is not a 10 cross 7 anymore
so let us go and count what we have
so we have 1 2 3 4 5 6 7 8 rows and 1 2 3 4 5 columns
so this is not a surprise because we started with some m cross n which is 10 cross 7 and from there we remove 2 rows and 2 columns
so now we start with a 8 cross 5
so now let us peel the outermost layer of the 8 cross 5
so that is the second peel
once we remove it as you can expect we will have 4 rows sorry 6 rows and 3 columns
so that will be the third layer
so let us look at the third layer we will have 6 rows and 3 columns
so on that again i can peel once more
so that is the third peel and once the third peel is over now it looks like i have a corner case
so i do not have a proper rectangle anymore it is not 2 rows or 2 columns anymore
in fact i have just 1 row here
so i will mark that with this color
so i have just one column here that i need to traverse
so in all the other ones i can start at the left top of the rectangle and move right towards the right here and then move bottom move left and move up
so essentially what we are doing is on the topmost row we traverse from left to right
then on the rightmost column we traverse from top to bottom
on the bottommost column you traverse from right to left and in the leftmost column you traverse from bottom to top
so and this is a process that you keep repeating only that what is your top right bottom and left keeps changing as you go along
so initially your top is row number 0 and the bottom is row number 9 initially but as we go along
so and in that case the left would be 0 and the right would be 6 because we have a 10 cross 7 system that will be a first layer
once you have that your top will become so this is the left after one round of peeling this is the right after one round of peeling this line will be the top after one round of peeling and this will be the bottom of after one round of peeling
so and we are going to do this repeatedly
so i am going to take this and see how to how to translate that into a program
so to do that i am opening up my local editor
so what i am going to do is as before i will go and scan the matrix first and what are the things that i need
so your problem specification said you should support something for a 5 cross 5 matrix
so i am going to declare into a of 5 comma 5 and you need to scan coordinates of the rectangle what is the size of the rectangle
i am going to assume that rows is m and columns is n and i am going to declare two variables called int n j int i and j will declare other things as we go along
so for now what i am going to do is for i equals 0 i less than m i plus plus for j equals 0 j less than n j plus plus scan of two integers sorry scan of one integer which is a of i comma j
so before doing that i need m and n itself
so i will do that outside scan of m and m and m and m
so assuming that i have read the rows of number of rows and columns and both of them being less than equal to 5
so then i am going to read m cross n matrix inside this system
so i want to imitate what i did earlier in the graphics
so i know that the top most row is actually row number 0 and bottom most row is row m minus 1
so i have the top and bottom and i need the left hand right
i will start with left most being the 0th column and right most being the n minus 1th column
so this takes care of c style of indexing
so only that i have not declared top bottom and so on i will declare that now in top bottom right and left
now what i am going to do
 so let us let us write code for one layer peeling one layer let us write code for that
so what i am going to do is i am going to start at the top and i am going to traverse from left to right
so from left to right one element at a time let us say if i access a of top comma i right i am going to do something to a of top comma i but that will take care of doing everything on the top most row because my row index is top i keep changing it goes from top comma left in one step to top comma right
so it goes one step after the other and what work i am going to do
 i am going to show later right
then i need to start at one row below the top most row
so i will start with that row below the top most row
then i will go up to the bottom most row again i am increasing i
here what i am going to do is i am going to access a of i which is the row number and write most column
i am going to do something on that later
so now i have taken care of traversing on the top and traversing on the right
then what i am going to do is i am going to start from right minus one and go up to left but i am going in the reverse direction
so i am going to do i minus minus and in this case we are accessing a of bottom comma i
and finally i can go from the bottom most so i will go from bottom minus one
then i want to go up to top plus one i minus minus
again i am going to access a of i comma left
so you can see what is happening here
so this part this part line numbers 19 20 and 21 you are accessing a of top comma i where i goes from left to right
then line numbers 20 20 23 and 24 is accessing a of i comma right
so since right is fixed you are accessing a column and which rows are you accessing you are accessing from the top plus one through to the bottom most row
and line numbers 25 26 and 27 you are accessing the bottom most row but you are going from right side to left side
you are starting with right minus one because you have already touched the right bottom cell and you go greater than equal to left
and finally go from bottom minus one greater than equal to top plus one and i minus minus
so the first two loops move in the left and bottom direction and the second the bottom two loops moving in moving the left and above direction
so this is what we have
now we have to do a few things
so one thing i am going to do first is i am not going to assume that this is printed directly because so many of you run into problems with presentation errors i am going to show a technique of how to avoid presentation errors
so instead of actually printing right here what i am going to do is i am going to store in a matrix called b that i accessed a
so i am going to declare b and other things appropriately
what i am going to do is i am going to do b of c and t plus plus
so count as a variable i am going to run and i am going to ensure that this records what i visited and not printed and i am going to do that on all of them
so i do it on all of them
so now all i need is i should ensure that b is also declared properly
so a is of size 25 i could not visit more than 25 elements
so i am going to keep b of 25 and since count is a variable that is counting the elements i am going to put in count equals 0
so now what i have is i have peeled exactly one layer
so i have moved from left to right top plus 1 to bottom right minus 1 to left and bottom minus 1 to top plus 1 and at the end of this i would have peeled exactly one layer
so let us go back to this picture let us see what we would do after peeling one layer
so in this picture after we peeled one layer top can actually be incremented by 1 because this was the earlier top
now the top most row is this row and bottom can be reduced by one layer
so this was earlier bottom and now it is going up this will be the row which is bottom
similarly left moves to the right side by one column and the right can move to the left by one column right
so i will put that in
so top can move up it can move down by one step bottom can move up by one step left can move to the right by one step and right can move left move to the left by one step right
now the second question arises this takes care of one peeling but we need to see how many times we can peel right
so let us go back to the picture and if i give you m cross n right if i give you a general m cross n right how many times can you really peel
 so let us see after the first peel so before the first peel you have m cross n
after the first peel what do you get you will have a m minus 2 cross m minus 2 rectangle system
after the second peel you will have m minus 4 cross m minus 4 because you remove 2 columns 2 rows from here and you remove 2 columns from there and we can keep doing this but how many times can you keep doing this
 you cannot do it forever right
you can do it at most m by 2 times or m by 2 times whichever is smaller right
so let me repeat this you are removing 2 columns at a time and simultaneously you are removing 2 rows right
so which will peel the outer layer of the rectangle and how many times can you do this
 you cannot do it more than m by 2 times or m by 2 times
so that is the first thing i am going to do
so i am going to ensure that this process of peeling
so the code that you are seeing is for peeling right from line number 22 to line number 35 is what you are seeing for peeling except that i have not said how many times you can peel
so i am going to declare another variable called count 1 and i am going to say count 1 must be less than or equal to both m by 2 and m by 2 right
what this takes care of is is that it ensures that peeling happens exactly either m by 2 times or m by 2 times whichever is lesser
so now this takes care of peeling various things but then sometimes we are left with the current case right
so let us see one of those current cases
for example if i have a 3 cross 3 if i have a 3 cross 3 system like this
so m equals 3 and n equals 3
so i said we can peel at most 3 by 2 times or 3 by 2 times whichever is smaller
so 3 by 2 happens to be 1 this is integer division 3 by 2 happens to be 1 also
minimum of 1 1 is 1 time
so it can be peeled exactly 1 time
so you do this you can peel it exactly 1 time right
so let us take another small example which is a 3 cross 4 system
so the claim is that you can either peel it minimum of 1 time or 2 times whichever is smaller
so minimum of 1 2 is 1 itself
so i can peel it exactly once
let us verify that claim
so i have 3 rows and 4 columns
how many time can i peel it completely
 i will start from here go up here and so on
these 2 cells are part of inner one which i cannot peel
so i have peeled it once right
so in general i said we can peel it minimum of m by 2 times or m by 2 times and that is exactly what this check task right
so cnt1 is less than or equal to m by 2 and cnt1 is less than or equal to m by 2
so of course i need to declare cnt1 itself
so i am going to declare it here
cnt1 is also equal to 0
so now i have the various things except for the fact i have not taken care of what the corner cases the final case right
so before i do that let me take one more example
let me take a 4 cross 4 system
so this is a 4 cross 4 system
if i start peeling i will start from here and end up here with 1 peel and the second peel would start from here and end up here
in this case it does not leave anything to me traversed at all actually traverses everything
so in general if you have a m cross n which are both even what would happen is you can actually do peels which is minimum of m by 2 times or n by 2 times you will actually touch all the elements
but if one of them is odd let us say m is odd and n is even for example 4 cross 3 then you would peel but you would be left with either 1 row or 1 column
so we saw that example here right in a 3 cross 4 system with 3 rows and 4 columns 3 is odd we can do 1 peeling but then we will be left with 1 row
but if you do a 4 cross 3 system you will be left with 1 column and if you start with something like a 3 cross 3 system where both are odd both m and n are odd you will traverse this exactly once and then you will be left with 1 element in between
so i am going to use this idea and write the rest of the program
so at the end of it if you are done with everything and let us say both your top and bottom coincide and left and right coincide it means that you are left with exactly one element
so i am going to do i am going to traverse that
so a of left
so what this does it takes care of touching that exactly one element that you left out
else let us say top is still less than bottom it means you have a column that you have to traverse from top to bottom but it is just one single column and which is that column it is either left or right
in fact left and right should both be same at this point of time
so what i am going to do is i am going to traverse from the top up to the bottom and what is the element that i am going to access
 i am going to access a of rho which is i and column which is either left or right it does not matter at this point actually left should be equal to right
else if you get this condition that left is actually less than right which means they have not coincided yet
now you are actually ready to go from left most column to the right most column but it is just one single row and which row is that it is either the bottom or the top row
in fact both should be the same at this point of time
so i am going to traverse that a of i am going to take top but even if you put bottom here it is not wrong
i do that and at this point at the end of line 51 now the whole traversal is over
so the final thing that we need to do is just be able to print
so what i am going to do is i am going to start from i equal 0 which is the 0th element of b and i am going to traverse overall there are m times n minus 1 elements i am going to print all of them with a space
so percentage d b of i right
so this takes care of printing m cross n elements
for the last element we do not want a space
so i will just print it directly and this is my whole program right
so i am going to save this as spiral dot c
let me compile it
so there is a small problem here
so this time there is no compilation error let me run it
i am going to test it on some of the public test cases
the first public test case is this 3 comma 3 system and it has 0 1 2 and so on
there is a small problem i think i forgot to put a scan of with the ampersand
let me go and check
yeah
so this problem the scan of was without the ampersand it was a mistake
so let me save it and compile it once more
i am running it now
so 0 1 2 and 7 8 3 and finally 6 5 4 and this seems to give the output 0 1 2 3 4 5 6 7 8 which is what is expected
let us try it on some of the kernel cases
what if i have only a 1 cross 1 system and that is the last test case
 1 cross 1 the output is supposed to be 20
so this seems to be okay right
so let me take this and put it in the system
so as before i have this saved in my setup like last week
so i have opened it up i just copied and pasted it
so i will save and compile and run
so let me see hopefully this is okay
so all the 4 test cases have passed which is a good good thing to get and finally i do a submit
so under got 100 and 100
so this program seems to be correct right
so the key thing that i did was not just traversal i want you to look at what i did with b
so instead of printing a as and when i saw the elements i started collecting them in b right
if you notice i started collecting them in b right from line 24 onwards i started collecting them in b
so at the end of all the traversal my b the array b would have m times n elements index from 0 to m into n minus 1 right
what i did here is i printed elements from 0 to m into n minus 2 with a space and printed the m into n minus 1 element without the space because that is the last one
so i did not do any printing before this
so this is a nice way to do things because you are done with all your work you just have to concentrate on printing now you just have to do this one step right
so this is a common way in which you can solve several presentation problems that you have been seeing so far
always go and record what your output must be and take care of the printing as the last thing in the program
so this is something that did not touch the logic of the program ever
so i believe that many of you had trouble in putting the logic for printing appropriately inside the loop itself but i wanted to show that you can do all of this without worrying about the logic
all i did was i saved all of them in an array called b and finally i printed them outside right
so this is a technique that you can use for many problems in week 3 onwards right
i hope you actually adopt this technique from now on
so thank you very much and i hope that you enjoyed this session as much as i did
so there are lots of interesting things that happened here
i did some mathematical derivations to show that you can only run m by 2 times or n by 2 times whichever is smaller and i will leave it to you to think how i how do i know for sure that either i have only one row left or one column left or exactly one element left
so go and think about that it is a very interesting and challenging problem to think about
so i knew that i had of time because of the way because of the way i was doing things
so maybe you should go and practice yourself on how to prove something like that and proceed with it
so thank you very much and see you next week
bye bye
we did a recap just a while ago and now we will look at the efficiency of the programs that we have done
and as i said you could have the same problem being solved using multiple algorithms or multiple programs
so which one is better than the other
 that is what we want to find out
let us take a simple example
let us say i want to find whether it given non-zero positive integers prime or composite
all if you know what a prime number is what a composite number is a prime number is a number that is divisible by another than one and itself
so others numbers are all called composite numbers
one is the only exception is called trivial divisor
so what will you do
 look at the definition
it says a number that is divisible by non-other than one and itself
so i can start with a simple program
see what we have here
 let us say n is the given number
we start with a variable i which is initialized to 2
we initialize a flag e prime to 1 and then if n is not equal to 2 then what are we doing
 we are checking whether n is divisible by i or not
and if it is divisible by i then the reset is prime to 0
otherwise we increment i to the next value and keep doing this
and finally if not is prime then you say number is composite
otherwise you print that the given number is prime
this is a small segment of c code
now the question is do we really need to run this prime classification program
 so if you check for every value of i can we do better than this
 so for example any number
so what will mean a number is prime
 a number is prime means if i take example 13 the factors of 13 are only 13 and itself
on the other hand if i take a number like 4 its factors are 2 1 2
if i take a number like 25 its factors are 5 1 5
let us take 18 its factors are 6 and 3
and let us take 24 its factors are 2 and 12
what is interesting is here numbers here which are perfect squares 4 25 and then you have numbers which are not perfect squares
but what we observe here
 clearly if i take the square root of 18 the square root of 18 should be somewhere slightly greater than 4 because the square root of 16 is 4 into 4
so it will be slightly greater than 4
what we see in the factors is there is one number which is less than the square root of 18 here
similarly here you find one factor which is smaller than the square root of 24
so what it tells is i do not have to check for all the numbers going from 2 to n minus 1
all that we need to do is check up to the integer square root of the number
and if the number is divisible by any of the numbers after the integer square root then i do not have to test beyond that
now i think the p also notices if a number is divisible by 2 what does it mean
 it is a even number
so for example so what we can do is we can illuminate 24 68 from the division
so what we can do is we can start from 3 and then increment test with 3 within the numbers divisible 57 up to the integer square root of the given number and that is the piece of code that i have written over here
what we are doing again we are again setting e is prime of flag 2 1
and if number is greater than 2 and number percent 2 equal to 0 that means if it is an even number then e is prime is not 2 and then you just come out of the program
otherwise what you do is start with a divisor equal to 3 and keep checking whether the given number here for example a number divisor 3 a number percent divisor equal to 0 then you reset the e is prime flag
so what is it the piece on
 we look at the prime classification program that we looked at we looked at two versions of it there are even much better algorithms for prime classification
and you find that one program clearly the number of steps that are required to execute the second program is much smaller than the number of steps that are required for executing the first program
so what do we need now
 you have to find out what is the running time of the program
so how do we define running time
 running time clearly can be dependent upon the input to the program quality of the code that is generated by the compiler used to create the object code
it can also depend on the nips of the machine what do we mean by the nips of the machine
 the faster the machine the quicker your program is going to run
but what we want to do is what the compiler generates we cannot be sure whether it is optimized very much
and nips of a machine today i run my program on a pentium tomorrow i am running on a quad core or whatever
so clearly what we need is we need to define this complexity in what is called a machine independent pain
gendelies so what we do is we define the size of the input rather than the input itself
for example sorting a list of n elements depends upon the number of elements given in the list
what i mean is if i have an array to be socket let us say i have an array with these numbers let us say i have two four ten fifteen ten ten ten ten sixteen twelve to be sorted
suppose i have something like this to be sorted and i have another array with numbers let us say which are very large i have let us say twenty thousand ten twenty five thousand and so on
what we mean is the size of the number does not matter but as long as what is the dependent upon here
 both arrays are of size eight over here and that is what will matter when you looking at the computation of the running time of a sorting algorithm
gendelies for number theoretic problems we talk about complexity in size three input and the size of the input is actually defined by the number of digit it takes to write number
for example if i want to determine whether this number is prime or not the number of digits is five
so complexity is defined by the length of the digit sequence that make up the given number
so let us formally define what is the running time of the algorithm
running time of the algorithm is given by this equation let us say the algorithm takes is input some size n then the complexity is let us say t of n equal to c in square that means it is it is quadratic in the number of elements or the size of the input that is given to the particular program
what is c here
 c is a constant and units of t of n are generally left unspecified we talk about t of n in machine independent way and we are talking about operations that can be performed on an ideal computer
we will see in a while what we mean by operations on an ideal computer and generally when we are talking about t of n the running time of a program
we refer to the worst case running time that is maximum on all kinds of inputs
there are other types of time complexities which are beyond the scope of this particular course called the average of n which is the average over all inputs of size n and the average n of course is computed assuming that all inputs are equally likely but there are other algorithms which talk about inputs which are not necessarily equally likely and the running time of such programs are also computed
but we will talk about very simple worst case time complexity
what you have to know is there are two specific type of notations one is called the big o notation and the big omega notations when we talk about time complexity of programs
what do you mean t of n when it is written as big o 1 squared it means that we can find two constants c and n not such that when n is greater than or equal to n not then and for a particular value of c t of n is guaranteed to run in less than c n squared time
then what it is basically telling us is that if i have the input to the program in terms of a particular value of n then if i write t of n is equal to order of f of n then f of n is an upper bound on the growth rate
so what how do you define this
 we define time complexity like this let us say this is t of n as a function of n
so what is it saying let us say now the actual running time of a program was let us say 3 n squared plus 2 n plus 1
i would write that this is equal to t n is guaranteed to be less than or equal to big o of n squared which means this is going to be less than or equal to c times n squared for a value of c and n which is greater than or equal to some n not
so let us take this example let us take n equal to 1 then t of n equal to 6
let us take a value of n equal to 1 and then t of n equal to 6
now let us say that i take c equal to 1 then what is it that we get when i look at t of n in terms of n squared here then t of n should be less than or equal to c into n squared and 1 into n squared
so what for what value of n will it get set
 so now notice that i have taken c equal to 1
so if n equal to 1 then what do we get we get that t of n is greater than this take n equal to 2 n equal to 3 n equal to 4 and so on and you can ultimately and take a different value of c for example suppose i have taken c is equal to 6 for that matter
then i would have got this one and this t of n is less than or equal to 6 n squared for n greater than or equal to 1
so basically what we are saying is now what happens for n equal to 2 3 so on
so what happens i can as n increase what is happening is this is going to be for n equal to 1 for n equal to 2 what happens we have t of n is equal to 3 2 is a 6 2 is a 12 plus 4 plus 4 plus 1
so what happens when when n equal to 2 i get 6 into 2 into 2 12 into 2 24 16 17 therefore it is still less than n squared
so basically what we are saying is i have some t of n like this and then the big of n squared is going to be above this particular line that is the meaning of this big o notation and what is big omega say it says the big omega is the lower bound
if i say big omega n squared for example if c equal to 1 we can always say t of n is going to be greater than or equal to n squared
so you have a lower upper bound for the running time of the algorithm and a lower bound for the running time of the algorithm
what it says is t of n which is the actual running time of the algorithm is going to be bounded on one side by big o of n squared and omega of n squared on the lower end
there are certain things that you must worry about you must remember that when you look at big o of n what is the meaning of it it is a straight line
now you look at big o of n squared it is like this suppose i say big o of 2 to the power of n then what is going to happen it is going to go even more steeply this is called exponential running time exponential in n and when you have order of n squared order of n cubed and so on this is polynomial time and this one when it is big o of n it is linear time you also have one more big o of n for example for all values of n if it takes order 1 what is the meaning of it is taking a constant amount of time whatever be the value of n that is a linear another complexity
so what have you see basic idea of big o of n because we are talking about worst case complexity will not deal with so much omega n omega n but we will look at big o of n
so as a function of n we see what the time complex to you the problem is then n for example increases and time taken does not change then we call this constant time big o of 1 when it is linear is a straight line then there is for example n squared n cube or all polynomial and then for example it is 2 to the power of n it is exponential for example what do you mean by 2 to the power of n is very dangerous algorithm when n equal to 1 the time complex t is 2 n equal to 2 the time of complex t is 4 n equal to 3 the time complex t is 8 grows extremely fast
so you should always worry about it whenever you write algorithms what we try to do is we try to see if you the more efficient the algorithm is for example linear time is more efficient than polynomial time polynomial time is more efficient than exponential time and constant time is more efficient than any of these
so those what we will like to look at there are other notations the theta n omega n small o f n small omega n and small o of n these are beyond the scope of this particular course but enough to for you to know it
what it means for computing the running time of a program there are two specific rules the sum rule and a product rule the sum rule states that if a program is made up of two segments p 1 and p 2 what do you mean by this let me illustrate this what this means is that i have program p 1 here have another program p 2 here and i say then that this program p is made up of two sum of two program segments p 1 plus p 2
remember we saw in the when we did the recap that you can you know you can use assignment statements make a big program alternative statements the big program combination of assignment alternative repetitive whatever
so what we do is you compute a time complexity of p 1 separately compute a time complexity of p 2 separately and use the sum rule to compute the time for complexity of the program p
so how do we do this if the program segment p 1 takes order f of n and program segment p 2 takes order g of n we are we know what order is g of n and f of n are functions of n then the total time complexity of the program is a maximum of f of n and g of n this is called the sum rule
so what do we mean by this it let us say this program takes t of sum t of n is sum big of g of n f of n sorry and this program segment takes big of g of n then the time complexity t of n of the entire program is max of order of max of f of n comma g of n this is what it tells you ok to the c n example in a little while
before that i would like to talk about another rule which is called a product rule product rule is p 1 programs as obvious p is made up of p 1 into p 2 what are the meaning of this what this means is that simply that you have some kind of a repetition block that is there
so i have some kind of a loop statement here and within this this loop statement corresponds to let us say p 1 and within this i have the volume the program p 2 and basically it means that the program segment p 2 is getting executed p 1 times ok
then what the product rule says is that if the time complexity let us say for this one is t 1 of n and for this 2 is 2 to f n then what the product rule states is the time complexity t of n is big of sorry t of n equal to f of n and let us say this is g of n then this is this is equal to order of f of n into g of n the product of the 2 time complexities
so let us see an example now i have a small program segment again here some is initialized to 0 there is a fault for loop which sums the first n number starting from 0
so now some is equal to 0 it is an assignment statement it takes constant amount of time therefore we say it is order 1 look at this for loop for i equal to 0 i less than n i plus plus
so this is again an assignment this is a comparison and this is an increment
so all of these are basically like some rule with 3 statements being executed therefore it takes the maximum of order 1
then again here there is some kind of assignment here i am not written the rest of it here so it again costs you order 1
but very time complexity for the segment of each loop the slope on the other hand is being executed n times
so if you look at the outer program p 1 here that is going to be executed n times therefore it is order n
so whatever we do now so this kind complexity becomes so for the segment of each loop is order 1 but time complexity for the entire for loop becomes order of n into 1 because n is the time complexity of this for loop because it is executed n times and the total time complexity of this algorithm is order of n
and before that we also had this what you call order 1 statement here
so if you look at the time complexity of the entire program now this is the program segment p 1 and this is another program segment p 2 and it is a some program now you apply the some rule and you get that the time complexity for the program segment is order of next what we will do is we look at another kind of complexity analysis
so simple programs we know how to do assignment statements we can evaluate and loops we know that when you evaluate a loop you have to find out how many times a loop is executed
before we go to recursive functions i would like to leave you with this how long does this program take to execute suppose i have i is equal to 1 and i say while i less than n i is equal to 2 s plus 1 minus 1 minus 2 star i
what is the meaning of it
 so basically how many times will be execute normally students have this habit of saying when i less than n they say n times that is not correct for example let us take n equal to 8
so i started out with i and let us see how many times this loop this body of the loop gets executed and let us take the value of i and n here i equal to 1 n is 8 then i becomes 2 n is still 8 of course then i becomes 4 n is 8 i becomes 8 and n becomes n is still 8 and what happens i is not less than n and you execute you exit
suppose n becomes n is equal to 16 then what will happen will have 8 to 16 over here and this will also be 16
so once mode it will execute
so basically what we are saying is depending upon the value of n here
so notice that it is only from when you change from n equal to 8 to n equal to 16 it only executes the body of the while block one more time when n equal to 32 i am sure you got it right it will execute one more time compared to n equal to 16
so if you look at it in terms of time complexity it is approximately log n times not exactly it is order of log of n to the base 2
notice that for example first time when it executed 1 2 3 and then next time was 4 and so on
so the time complexity is not the same as of this segment of course is log n
so this is something that you must remember that you have to look at the kind of computation being done with respect to the loop to decide how many times it gets executed
the program that i had given here clearly we had done i equal to i plus 1 in the previous case over here
therefore it executes the n times whereas this program which i have shown you that is not execute n times
so next thing that i want to look at is how do we analyze recursive programs
all if you have seen recursion in the c part of your course
so what are we doing here n is equal to n 1 then value set 2 i am just finding this sum of elements in an array i am just writing a simple recursive function this statement is what is important this is a comparator here it cos order 1 order 1 here in the other hand is order 1 and the way you write it is because it is a recursion here it reduces the size of the problem which was originally n to n minus 1 and it is order 1 for the addition and the assignment plus t of n minus 1 because this function is going to be called again
so what we do is when you do time complexity analysis and if you look at it is c plus t of n minus 1 some constant time if n is greater than 1 it is equal to 2 d if n equal to 1
so in general i can write that t of n is i c plus t of n minus i if n is greater than i and then i equal to n minus 1 what happens c into n minus 1 plus t of 1 c into n minus 1 plus t and therefore the time complexity of this algorithm is order n
so there is something here is something that i want you to be a little careful about recursion is somewhat dangerous
so this was a function that we wrote if i write it in some kind of algorithm type of statements and i say that you know function recursive and n this was a function of this kind if n equal to 1 then do something else we said return one legacy return n else we said else it was like recursive is equal to n plus recursive of n minus it is something like this if i was going to write it in pseudo code the program would have looked like this
so this harmless statement and then you found that the time complexity was order n
now suppose i replace this n here and make this recursive of n minus 1 what will happen to this program let us see what will happen
this way to analyze this is to draw what is called a recursion b
so i started off with the pop most recursive of n and what do i do i do i do i write it into
so it is going to call recursive of n minus 1 at recursive of n minus 1 and this one in turn is going to call what recursive of n minus 2 recursive of n minus 2 and this recursive is also going to call recursive of n minus 2 and recursive of n minus 2
now what is the issue and then n minus 2 will call n minus 3 and so on let us start with recursive of n minus 8 then this is going to call 7 and 7 or maybe instead of 8 let me start with 4 it is easier 4 calls 3 and 3 3 calls 2 and 2 2 calls 1 1 and that is when it will terminate 2 calls 2 2 1 1 and finally terminate
so now if you look at this computation which was order n originally now if you look at the what is n now n is 4
so now if you look at the number of computation 1 2 3 4 5 6 7 ok
so basically 7 times the recursive call is being made and therefore this one is time complexity in terms of 7 is of the order of 2 to the power n and this is something you must be very careful when you write recursive programs ok
so this is all constant time over here
so it becomes order of the exponential in terms of 2 to the power of n
so imagine if it if it was 8 here and what would i say 8 given it becomes 7 6 6 5
so there are 4 5 here 5 5 5 5 and so on and you notice that the tree is little start growing very very large ok
so you have to that best way in my opinion to analyze recursive programs this is simply draw this recursion tree and count the number of nodes that are there in the recursion tree and that will give you exactly the amount of time the program is going to take to execute like we saw in this case big of 2 to the power of n ok
so on the other hand i can also have here the recursive is let us say the recursive of n by 2 plus recursive of n by 2 you guessed it right
so what is happening now 4 is getting divided becomes 2 2 2 becomes 1 1 and we are done ok
so how many times it is basically this 1 1 2 3 add into 2 perhaps
so it is only order n the time time complexity of this algorithm
so these are things that you must keep in mind when you analyze the time complexity of recursive functions
so we will stop here and then we will take 2 algorithms for sorting and searching and we will analyze the complexity in little bit of detail ok
welcome to this online course on programming
i am shankar balachandran from the computer science engineering department at iit madras
this course is designed in such a way that it can be spread across five weeks and you are going to have about two lectures every week
so a total of 10 lectures and this course is designed also designed in such a way that you can take this in 15 minute chunks called modules and you would be given a small practice test right after every module
so let us jump right into the course
so before getting into programming we need to understand a little bit of what computers are about
what you are seeing in this picture here is eniac the so called first digital computer which was built in the 1940s and you can see how huge it is
it is almost like house in size
it was massive compared to the modern personal computer standards by no means eniac can be called a personal computer
it had 17000 vacuum tubes 5 million joints hands-holded joints it weighed quite a bit and it used to consume 150 kilowatts of power
no way this would be a personal computer
however zoom to 2000 what you are seeing in this picture is a micro photograph of pentium 4 and it was designed in the year 2000 and deployed in the market
it could run at 15 gigahertz that means it can do 15 billion operations per second
it had 42 million transistors as opposed to this puny eniac and it was built in this technology called 018 micron technology which means the transistors and the gates that were used to design are as small as 018 micron
so in the 40 or 50 years computers have moved quite far away from the first notion of digital computer
in this picture you can see google's data center
it is one of the data centers that they have across the world and what you are seeing is racks and racks of machines crunching data running algorithms and running programs various kinds of software that we use on a daily basis and this is just one of their data centers and this requires enormous organization of the equipment power systems cooling systems and so forth
but all of this is basically a computing machine
all we see in the pentium 4 or these data centers are all built of what are called computing machines and the basic abstraction is what we see here
we have a processor and we have memory and this is what makes any computer
you have a processor and memory
you can think of the memory as a series of locations to store information
let us say for example we have 256 megabytes of ram and you would be laid out in some in some order and you can address them as location 0 location 1
so 1 up to 256 megabytes just like how your houses would be numbered in a if they were all lined up in a line and processor is the heart or the brain of the computing system
so typically memory is divided into two portions
there is some portion dedicated for programs and some portion dedicated for data
a program is essentially a sequence of instructions as able to do some task
so it could be a game it could be a piece of software that you write for this course it could be a search engine it could be a browser it could be anything and most of these instructions actually operate on data and the data is something that you store in the memory as well
there are instructions which could also control the flow of operations
it is not that all the programs have what is called a straight line sequence they do task a task we task c and so on up to land
based on the conditions that come through some branch operations could happen and because of which the control could change
we will see these in more details later anyway
but the basic setup behind a processor is given in this picture here
we have an input system the input system could be a keyboard a mouse or any other device
you have an output system this could be a monitor some gears that are shifting it depends on the computer that you are building and most systems have a reasonable amount of memory
nowadays you probably have two gigabytes or four gigabytes of ram on your desktop and laptops
there is the central processing unit the central processing unit consists of two things
one is called the control unit the other one is called the alu or the arithmetic and logic unit
arithmetic and logic unit is it consists of various circuitry or it can do things like additions subtractions comparisons and so on
and control unit in some sense is the overall master
so it controls what happens in each of these units and how data gets processed in each of these units and when data moves in when data moves out and so on
so let us look at the basic operations of a cpu
cpu can fetch an instruction from memory it can execute the instruction based on whatever instruction is given to it it can actually execute it
this could be addition subtraction multiplication comparison it could be anything
it can also store the result back in memory
so when you write a program it is going to be translated into sequence of instructions and a basic machine instruction would have this following setup
you have an operation you have all the operands or the data on which the operation is going to be done and where is the result going to be stored also called the destination
a simple operation could be of this kind add a comma b it adds the contents of memory locations a and b and it could be storing the result back in a itself
so sometimes you may somewhere down the line you may learn a language called the assembly language and we are seeing some small example here
an x 8 6 intel 32 processor can execute the following binary instruction
so you have 1011400114001 this is a binary code for moving 61 in hexadecimal to an internal memory called a register of the name al
so al is a register which is an internal memory inside the cpu
so the meaning of this instruction is move number 61 in hexadecimal to al and this is something that you and i may not know you and i may not even understand if you are just given the binary binary bits
however for the cpu everything is translated into these bits
operating in these bits at this level is very very hard for us humans
therefore we use so called high level languages but sometimes you also have this intermediate language called the assembly language which is a human understandable but at the same time it is more detailed
for example we have mvi al comma value
so this could mean move the value to al and such instructions are called mnemonics
so mnemonics are essentially easy to remember and this binary sequence we could write them as mvi al comma value
this could be given to an assembler which would translate that into this binary code
but even operating at this assembly level is quite hard
this does not capture the kind of problems that we want to solve directly
they get too detailed
instead we used so called high level languages and a single high level statement could have more than one assembly instruction in it
so let us take a small example
let us say i want to add z to y and the result has to be stored in x
so i would write this as x equals y plus z and it could require the following sequence of operations
you may have to fetch y from the memory store it in an internal memory location or a register called r1
you fetch z also from the memory you store it in another register called r2 and the al you would then add r1 and r2 store the result back in r1 itself and it may require a move from r1 to the memory location named x
so a single operation x equals y plus z has resulted in four smaller operations and these operations could be written in assembly language if you would like to
however this becomes too tedious
so we would like to operate at a level which is much higher than what the processor can understand and something that is easier for the human beings to program with and that is how the evolution of high level languages started and in this course we are going to learn one such high level language namely c
once you have a high level once you have a program written in high level and you need a set of tools to convert them into the machine level and typically the programs that we write are called source code
they are called source because that captures the intention of the programmer and a set of tools will convert the source code into machine code
you may have more than one such source program available and you give this to a tool called a compiler
the compiler is essentially a piece of software which can convert this high level code into assembly code and in turn an assembler can take this assembly code and generate machine code
at runtime you have a linker and a loader which will actually execute the program
even if you do not understand these details now slowly and steadily we will build up an understanding towards all these ideas
we will also see software demonstrated along the way
so as of now just remember that you have a high level program which gets converted by a compiler into assembly code and assembly code downwards is taken care by assembler linker and loader
what we bother about is at the high level namely the high level language
so when we write programs we are actually looking at solutions
we are trying to solve things
from the cpu's perspective a program is nothing but a sequence of instructions
you have instruction 1 2 3 4 instruction 5 could be a condition based on whatever the result of instruction 5 is
you may execute instruction 6 or instruction 10 and so on
however this is not the way we think about solving a problem
for us a program is a solution to a problem and sometimes it is a frozen solution
by frozen what we mean is we have written the program it is already compiled and it is ready to execute and at this time the solution is frozen
you cannot change the solution unless you go and change the program and compile it once more
so from the perspective of a human being a program is the representation of a solution device by a human being and the nice thing about a program is that it can be compiled and stored and it is ready for execution from there on
you can also distribute the programs to others for them to read understand or even comment and change
you could distribute the machine version or machine code for others to execute but not be able to see the program
you can do lots of things and you write the program once you can run the program as many times as you want
let us get into what programming is about
a program is essentially a piece of software that you write and programming however is problem solving
this is what we really want to do
in this course we will learn how to solve problems but in the process we will also learn this language called c with which we can take problems break them down and write them using a program use tools to compile and run them
we will learn this whole cycle
any software development process starts with understanding the problem
you should first of all understand what the problem is
typically the problem is stated in english
so that is called requirements analysis
from there you get a precise specification of the problem usually mathematically specified and you devise the solution
so given a problem you go and devise the solution or design the solution and once you have the design for the problem then you go and write it in a program
you could write it in any program programming language
this is also called coding and finally once the coding is done we have to test it before we deploy it
so we start with requirements analysis and get the specifications out
design the solution for the problem
go and model it and program it using a language
compile it run it and test it before it is ready for use
however the most crucial part of this whole process is actually the solution design
so you have to solve the problem and analyze the steps and ensure that this problem is captured properly and you have a solution that is indeed correct
any ambiguity in the specification can result in program that does not behave as expected
so you have to be careful about understanding the specification
you should also understand the nuances of the programming language itself so that the intent is captured carefully and you use a programming language for that
finally you test it
so as i mentioned earlier we are going to use this language called c
c is a very old language
it has been there for almost 4 decades now very widely used in the industry even now
even now
so there are other languages like c++ and java and so on
however learning c well and understanding c thoroughly is a basic requirement in the industry even now
c is a general purpose language
it is not for any specialized purpose unlike a language like html and so on
it is extremely effective and expressive
you will see this in a short while
it has a finally compact syntax
the language is not too big
it has a rich set of operators pretty much every arithmetic logic operation that you think about is already available as an operator
c also has an extensive collection of libraries
so you do not have to really write every single thing down
you can call library functions whenever you need them and c comes with a rich set of libraries and that is one of the basic reasons why we pick c
let us look at a tiny c program
so you may not understand it right away but it is really tiny
it has only six lines of code
the first line is actually a comment
it says a first program in c and the next line says hash include stdih
there is this so-called function by name main and there is exactly one statement inside this main
so watch the most pointer
we have a function called main and within the braces we have a single statement called printf and printf seems to be taking this hollow world
so this has been a custom for a while now
almost every programming language book that you go to will teach you how to printf hollow world
so let us see or let us break down what this program is about
so as i mentioned the first line is just a comment
it is for us to understand it does not really result in anything that is executable
so the program has it but the machine code will not have these comments
it is not an instruction for the cpu to do anything
it is just for us to understand and let us look at the next line
it says hash include it means include something which is already built
i mentioned earlier that c has several library calls that you can make and stdih is one such library with which you can do standard input and output
so if i want to type something on a keyboard and if i want to see something on a screen that is what you get from stdih
every c program will have something called a main function and the very first instruction that is executed will be from main
and within this body of these curly braces you have a single statement here called printf
you can see that this printf is a function
we will see what a function is in more detail later
it seems to take an argument or a parameter
so you can say printf hollow world and it will printf hollow world on the screen
you can say print hollow your name it will print hollow and your name on the screen and so on
but every statement is terminated with a semicolon and the body of the function is usually within the braces
so this is a fairly simple program
if we compile it and run it it will print hollow world on the screen
so with this we are at the end of module 1
in the next module we will see how we will take a small problem and we will see how to solve the problem and we will also see how to write it as a program
so in this module what we are going to look at is a very interesting aspect that c and several other programming languages give you which is not just accessing values that are stored in variables but also getting access to the memory locations or the addresses
so what is a pointer
 so to do that let us remember what happens when we declare a variable called k
so if i do int k k is the name of a memory location that can hold a single value at a time right
so for instance if i have int k a k could be a given array location 100 and at some point of time you could have k equals 38 and the value 38 will get into this location called k
so from the program's perspective we are going to use k which is the name of the variable
internally it is stored in location 100 and the value that is stored is 38
so that is the concept of a variable
now what is a pointer
 a pointer is essentially a variable and in this example we have this thing called int star p right
so the key thing is the key thing to note here is this thing called star right
it is not int p it is int star p
so remember star is not a valid character in a variable name for c
so the star is reserved for something specific and in this case p is supposed to be a pointer to an integer
so let us see what this does
if i declare something called int star p this p can contain memory locations instead of the actual value
so let us see what that means
so p is a variable as we had before which means your compiler is going to allocate some location for it right
so let us say p as a variable is allocated location 200 and when you say int star p it means it is a pointer right
if i put int star p equals to 100 the value 100 gets into this location 200 and if i do star p star p is an operation that you are doing
the meaning of that is you take location 100 c what that is pointing to right
so i take the value 100 instead of treating it as a value i treat it as an address and in that address what is the value that is present
so the value that is present is 38
so p is an integer pointer what that means is the value that is stored that you are going to reference to is actually an integer
p is just pointing to it p does not contain the value 38 but p contains the address in which 38 is stored
so one way to look at this is as follows
so let us say we have so in our department we have a hod and so the head of the department right
so it is actually a person
so let us assume that there are people and there are several people who could be hods but at any point of time there is only a single person who is the head of the department
let us say you as a student walk in and you want to find out who the hod is right
so of course you could go and ask each one of these faculty members who the hod is but the notion of hod is always just one person
let us say i have the small marker which says the current hod is person professor z right
so let us assume that there are three professors x y and z and you come in and ask who is the current hod and i say that the current hod is z
so that way from outside you do not have to know who the current hod is you ask who the current hod is and you get pointed to professor z
at some point of time in the future professor z steps down as hod and let us say professor x takes up the headship then the pointer points to x
so again let say somebody else walks in and ask the same question who is the current hod
this pointer can now point to x and not z
so that way what you are actually getting is not the actual value which is x y or z but you are getting the pointer to the actual value
so this is very useful for instance this is something that we have in our department
so in our department we have an email address called head at cseitmacin
so this head at cseitm is a permanent email address but this in turn points to different people at different times
so for instance our current hod in year 2013 his email address is pointed to now when his turn comes to give up the position let us say in 2015 somebody else becomes the hod let us say professor y becomes a hod then i can remove the pointer pointing to professor x and i can instead make that pointer point to professor y
and this way q always will email head at cse and the internal pointer will forward it to professor x or y or z according to who the current hod is
so this is a very useful concept and it can come in very very handy we will see examples of this later
but as of now just remember that p is just like any other variable it gets a memory location but the value in that is not a integer or a floating point value or a character it is going to be a memory address and this memory address you can think of it as pointing to some location and when you do star p you are looking at the address and what is pointing to and from there what is the value that you get
so just like any other variable p can hold only one address at a time but you can point to different addresses at different times
so just like variables can have different values at different times a pointer variable can have different addresses at different points of times
so let us say i change the pointer value from 100 to 250 i change p from taking the value 100 to 250 then it can point to a new location 250 and star p would now be 84 and not 38
so to understand this it may be useful to know this concept of what is called a l value and a r value
let us say i am given a variable k the l value refers to the address of the memory location
so l value is used on the left side
so whenever i say k in turn it is actually a specific memory location that is the l value and the r value is the actual value that you are going to put in
so if i say k equals x plus y then x plus y is going to be a value and the value of this is going to be stored in k
so x plus y the value of x plus y is the r value and the address of k is the l value
so pointers are actually allowing you to manipulate the l value
you always have expressions on the right side you get the r value always but pointers are a mechanism by which you actually can get access to the l value also
so pointers are themselves variables that store the address of a memory location and the memory required by a pointer depends upon the size of the memory in the machine
so for instance let say the i have a pointer of size 8 bits or 1 byte it can only 0256 different locations
but if i have a pointer of 2 bytes in size it can 0264 or 64 k locations
so that 65536 locations
if it is 4 bytes it can 04 gigabyte locations or 2 by 32 locations and so on
so let us see how to declare a pointer variable
you proceed the name
so p is the variable name and you proceed a variable name by this mark called asterisk or a star
and before that you have the data type
so there are three things that go with a pointer variable
you have the data type you have star and you have the variable name
so p is the name of the variable and the star symbol there informs the compiler that we want a pointer variable it should not be an integer p it should be a pointer p which means you are going to store addresses in them and not integer values
and the compiler will set aside how many of bytes you want to store the address
and this thing before that says we intend to use this pointer to point to integer values
so you could you could have floating point values and so on in which case you need a floating point pointer
so let us see what the contents of the pointer variables are
so there is a small piece of code here on the left side
so int k equals 38 which means there is a variable called k whose value is going to be 38 and you have int star p and this int star p
so i have int k equals 38 which means i have an integer variable called k
int star p is a pointer variable called p and then we are going to do some operations later
so let us see what this means
so int k equals 38 what does that do
 the compiler sees that k is an integer of data type integer
so k is a variable of data type integer
so it gives you a memory location in this case i am assuming that it is 100
from the program side we are going to call it k and the value that is stored is 38
so this is something that you already know
now let us look at the next line int star p
so p is a variable name
so every variable gets a memory location
so p gets a memory location in this case i am assuming that it is 200
but what type is p
 p is of the type int star or it is a pointer to integer
so int star p is a pointer to integer as of now i do not have anything to initialize here
so initially it is a unknown value for p
next statement says p equals ampersand of k
so the meaning of ampersand of k is give the address of k not the contents of k give the address of k and what is the address of k it is 100
so when you say p equals ampersand k right p gets the value 100 remember it is not 38 it gets 100
at this point you can imagine that p is pointing to the address of k and when you say star p equals 5 it means take p which is at location 200
it is supposed to be a pointer which is 100 and star p is the contents pointed to by 100 which is now 38 it says change it to 5 right
so star p is 38 change it to 5
so let us do this once more
so p is at location 200 when you say star p equals 5 you first go to location 200 and find out what is the value there the value is 100 and star p means the value that is pointed to by p which is currently 38 right
so you take 38 and you want star p to be 5 which means this 38 should be change to 5
so it is not changing this 100 to 5 it is changing this 38 to 5
so the pointer is still pointing to location at which k is available so at this point if you go and print k k will actually have the value 5 and not 38 because k is at address 100 and you use p to manipulate the value at address 100
so i have a small program here which shows this in more detail
so there are two integers a and b a currently holds the value 10 and b currently holds the value 5 and this in star ip is a pointer
so ip is an integer pointer and currently it is uninitialized
so at this point you can imagine that a and b are two locations
so i am going to do a small diagram on the right side
so a is some location let us assume that it is 100 and a equals 10
so this is then we will put 10 at location 100
b is another variable let us say this is at location 105 and it is going to take a value 5 and ip is a pointer variable let us say this is at location 211 and since there is no initialization there is unknown value here
it is unknown let us look at the first statement here ip equals i am percent of a
so i am percent of a is the address of a
so what is the address of a it is 100
so this will contain the value 100
then let us look at the print of statement here
so it says print a print print a print ip and print star ip
these are the three things we are going to print
so what would print a give us it will give us the value 10 itself right because all the variables when you access them you directly get the value and what do you get for ip
so here we are also printing ip what will be the value of ip
ip should give you the value 100 because 100 is the address stored in ip and star ip is the contents of the address that is stored in ip that is the way it interpreted star ip is give me the contents of the address that is stored in ip
so the address that is stored in ip is 100 the contents of 100 is 10
so this print of statement is expected to print 10 is a total of 10
so this is expected to print 10 here it is expected to print 100 and it is expected to print 10 here as well right
all right then let us look at this line the next line says i star ip equals so star ip equals 4 let us see what that does
so star ip what is star ip
so it says change the contents of the address that is pointed by ip to 4
so ip is still pointing to 100 the contents of that should be is actually 10 now it says change that to 4
so contents of the integer pointer pointed by ip should be changed to 4
so you go here you look at 100 100 is pointing to a now
so 100 is pointing to a and you want to change that to change that to 4
so this print of statement right
so since you have changed that to 4 you would expect star ip to be 4 but what happens because of that is since a is location 100 this a equals percentage d this is supposed to print the value of a this will now be 4
ip is still address 100 right you want 100 there ip has not changed
so this will still be 100 and star ip is now take the address contained in ip chase that pointer find out the value that pointer is 4
so this will also print 4
so star ip and a contain the same value
so so far so good now let us see what happens because of this statement we have ip equals ampersand of b we are now changing the value of ip itself
so ip still resides at location 211 and you have ip equals ampersand of b
so instead of 100 now you will have ampersand of b that is 105
so this will be 105
so this will be 105
so you overwrote 100 with 105
now if you take a step back and think about what star ip must be
so let us look at star ip star ip is take the contents of p which is 105 and find out the value that is stored in location 105 that should be 5 right
so b is already 5
ip will now have 105 and star ip is the contents of the address 105 that is 5 right
so one thing that is new in this program is we have used this format specifier called percentage p instead of percentage d
so percentage d is meant for integers and percentage p is meant for printing the pointer data types
so let us see a small program which is essentially going to run this thing
so i am going to look at pointers exercise
so i have the same program here
so instead of a and b it is called count and number here
so count equals 10 and number equals 5 and you have these things here
so let us compile it and run it
so i want you to pay attention to what is happening here
so initially count equals 10
so look at this program here
so let us look at this line number
so this line is saying print count print ip and print star ip
so count is 10
ip is some zeros followed by 2 3 f e 5 4
so this is actually an address do not worry about why it is printing f and so on
so it is printing something in hexadecimal format
so that is the address of count and star ip is 10 as we expected
so because ip is a percent of count
then we have star ip equals 4 which means change the value of the address that you already have
change the contents to 4
so in the second line we can see count is also 4
ip is the same address and star ip is 4
and in line number 15 we changed ip to point to number instead and numbers address is some other address
it is 2 3 f e 5 0 and not 5 4
so you can see that ip change 2 2 3 f e 5 0
the value is 5 and through star ip you actually get the same value 5
so instead of a and b this program has count and number
so hopefully this explanation and the program there helps you in understanding what is happening
so one minor point and this is something that many novice programmers in see mess up is the actual notion of memory allocated to values
so declaring a pointer does not allocate memory for the value
so let me explain what i mean by that
let us say i have in star p
so i have a declaration called in star p
what this is supposed to do is i am going to have a variable called p which is a data type integer pointer
let us say that is at location 200
since i have no initialization i have no known value of p
so that is what you see here
so here you see that there is a dash dash
there is no initialization
and let us say i do this star p equals 4
what is this supposed to do
 this is an hitherto unknown value and the star ip is saying take the address stored in p change that pointer and initialize the value to or change the value to 4
but since this is unknown you are saying take this unknown go to some memory location i do not know which and change that to 4
so this is pointing to some unknown address and you want this unknown address to have the value 4
this is not a legal operation in c
so if at some point you have to take p and put a valid address in it and only then you will be able to access star p
so let us see what the sequence of things are
i am percent of p is 200 because p is given a memory location
compiler will do that because it is a variable you will get location 200
however p itself is unknown
so if you access the variable p you get the contents of this location 200
this is unknown and therefore star p is illegal
so this brings us to the end of module 2 and in module 3 and 4 we will look at various other subtleties related to pointers
we will not only see pointers as a problem of its own but we will also see how to use pointers and access arrays and what are the different issues that come up when we use pointer to access arrays
so you have reached the end of module 2
we will see these things in modules 3 and 4
thank you
and compare the current minimum to the new data that is entered into the sub problem
in other words in the second iteration where we consider the second element and compare it with the minimum which was the first element
if indeed the second element is smaller than the current minimum then it indeed becomes the minimum among the array which consists of the elements a of 1 and a of 2
so this is an iterative procedure where one scans the array from the element index by the smallest value up to the element index by the largest value in this case 1 to n and start off with the an estimate of the minimum value to be the first element and update the estimate by a comparison by one comparison in each iteration
it is very clear that we will have to perform n minus 1 comparisons
it is not possible to perform anything less than n minus 1 comparisons in this approach unless we know something else about the array
therefore this algorithm that we have just discussed is an optimal algorithm with respect to the number of comparisons
so the number of comparisons is you need n minus 1 comparisons in the algorithm above performs exactly n minus 1 comparisons
therefore this is an optimal algorithm
it is a very interesting exercise to ask if one can compute both the minimum and the maximum elements in the array by efficiently but more importantly by in a simultaneous fashion
that is we want the algorithm at every point of time to keep estimates of both the min and the max in the array and update both these estimates and finally conclude that min and the max have been found
here is one way of doing it
use n minus 1 comparisons for each of them
that is can the elements from the first element to the last element assume that the first element is both the minimum and the maximum and compare the current minimum and the maximum in every iteration with the current element
this is two comparisons per element
there are n minus 1
there are n minus 1 elements that are compared against the minimum and the maximum values
and therefore we were formed 2 n minus 2 comparisons
we are interested in coming up with a better algorithm which uses strictly smaller than 2 n minus 2 comparisons and we present an algorithm which uses at most 3 n by 2 comparisons
so let us just understand how this can be done
in the straightforward approach which is listed at the first item we have estimates of min and max and we compare both min and max with the next element in the array
that is in the i th iteration we compare the i th element with both min and max to check if the i th element replaces the minimum value or the maximum value
of course one can use the fact that we have computed 2 values which are min and max and if we compare min and max with a pair of values then min needs to be compared only with the smaller of the 2 and max needs to be compared only with the larger of the 2
and therefore you can compute the min and max among these 4 elements with 3 comparisons
this is the whole idea
so the whole idea is to process the elements in the array in pairs and maintain the minimum and the maximum values in each iteration that have been calculated so far and compare the minimum element with the smaller element of a pair and compare the maximum to the maximum element in the pair
observe that the in a pair the smaller element can be identified with 1 comparison and after that we count only 2 comparisons therefore among 4 elements we are able to compute the minimum and maximum using just 3 comparisons and this is a trick that we generalize to reduce the total number of comparisons
so here is the algorithm which is described
see the values when n is odd min and max are taken to be the first element and when n is even min and max are taken to be the first 2 elements
this takes 1 comparison min is taken to be the smaller of the first 2 elements and max is taken to be the larger of the first 2 elements
this is done at the cost of 1 comparison
and then based on this algorithm that we have outlined there will be a total of n by 2 comparisons or if n is odd there will be n minus 1 by 2 comparisons and if n is even there will be n minus 2 by 2 comparisons comparison pairs and each of them requires 3 comparisons to identify or update the minimum and maximum
therefore the total number of comparisons which are made are 3 times n minus 1 by 2 plus the first comparison and 3 times n minus 2 by 2 plus the first comparison
this is the total number of comparisons which are made
so this is the whole idea and let us run it on a single example where there are 5 elements in the array
the array has elements 2713 and 4 and we just illustrate how the simultaneous min and max calculation happens
initially because n is odd min and max are taken to be 2 then we compare the elements by considering the pairs 1 and 7 and the pair 3 and 4
in one iteration we consider the pair 1 and 7 1 is smaller than 7
this involves 1 comparison and after that 1 is compared with the current minimum and 7 is compared with the current maximum
as you can see this is sufficient for us to very easily extract the minimum and maximum among the elements 271
now min and max are updated to be 1 and 7 respectively they are different from their earlier estimates which was both 2 and we have now used 3 addition 3 comparisons
then 3 and 4 are brought into the whole exercise
now 3 is compared with the current minimum because it is smaller of the 2 and 4 is compared with the current maximum because it is larger of 3 and 4
already 1 comparison is used to identify which of 3 and 4 is smaller
therefore we use 3 more comparisons at total of 6 comparisons are used which is 3 times n minus 1 by 2 comparisons
similarly when n is even we use 1 more comparison to identify the smaller of the first 2 elements and subsequently we have 3 times n minus 2 by 2 comparisons
in this case it is very easy to see that there are 7 comparisons that have been made
so this is the whole idea and let us run it on a single example where there are 5 elements in the array
the array has elements 271 3 and 4 and we just illustrate how the simultaneous min and max calculation happens
initially because n is odd min and max are taken to be 2 then we compare the elements by considering the pairs 1 and 7 and the pair 3 and 4
in one iteration we consider the pair 1 and 7 1 is smaller than 7
this involves 1 comparison and after that 1 is compared with the current minimum and 7 is compared with the current maximum
as you can see this is sufficient for us to very easily extract the minimum and maximum among the elements 271
now min and max are updated to be 1 and 7 respectively they are different from their earlier estimates which was both 2 and we have now used 3 addition 3 comparisons
then 3 and 4 are brought into the whole exercise
now 3 is compared with the current minimum because it is smaller of the 2 and 4 is compared with the current maximum because it is larger of 3 and 4
already 1 comparison is used to identify which of 3 and 4 is smaller
therefore we use 3 more comparisons at total of 6 comparisons are used which is 3 times n minus 1 by 2 comparisons
finally when n is even we use 1 more comparison to identify the smaller of the first 2 elements and subsequently we have 3 times n minus 2 by 2 comparisons
in this case it is very easy to see that there are 7 comparisons that have been made
in this module we will see a little bit more of details on pointers itself
so let us go back to the code that we saw earlier
so we have int k equals 38 in star p and p is ampersand of k star p equals 5
so one thing that i did not emphasize earlier is this notion of asterisk what is it used for
 so it is you can see that it is used in two places in one place as int star p and the other place we have star p equals 5
so there are related to pointers this asterisk symbol is used in two connotations
first time when you declare a pointer you say in star p at that point you are saying that p is a variable of type pointer to integer and later when you say star p equals to 5 the meaning is slightly different
what you are doing is you are doing what is called dereferencing the pointer
so at this point this is not telling the compiler to allocate space for the variable p or anything like that
here actually you are dealing with the r value of p
so one small thing that you will see in the the course as well as elsewhere is that we usually say p is pointing to k
so in this case p is ampersand of k
so instead of using this technical term that p equals ampersand of k p usually say that p points to k or p is pointing to k and so on
so let us look at the dereferencing operator
so it is the asterisk symbol and when you say star p equals to 7 it takes the value 7 and copies it to the address pointed to by p
so the so we saw this if p points to k then the above statement will actually change the contents of k also to 7 and this dereferencing is something that you will see as a technical term that is used later in the lecture also
there is a special pointer called the null pointer and generally we use pointers to point to some specific variable
so if i have in star p then i do i did p equals ampersand k in that in that case p started pointing to k
but there are several cases where you explicitly want the pointer not to point at anything at all and c provides you a special way of doing that and that is called the null pointer
so one key thing about the null pointer is that no other valid pointer
so by that i mean no other pointer that is actually storing some value or which is going to get point which is an address of a variable and so on will ever compare equal to the null pointer
so let us see what it means
so first of all c gives something called a predefined constant called null and this is defined in a cdi o dot h
so just like print affants can have this constant null is also defined in a cdi o dot h
so generally it is a good practice to check whether a pointer is null or not before you use it and we will see this in lot more detail when we do what is called dynamic memory allocation
but let us look at this code for right now
so what we have is we have hash include cdi o dot h and we have in star ip equals null
so this is generally considered a very good programming practice
you not only said you want a pointer variable of type integer pointer the variable name is ip and the pointer is of an integer type
you also said here that it is pointing it is not pointing to any valid location
so if you do this then we never run into this problem of ip pointing at an unknown location and what happens in this unknown location and so on
so the moment you have null it means that it is a it is not valid location and you want to you will probably come back and change it later
so you may do ip equals address of something later and this is what i was talking about earlier
so this tip says if ip is not equal to null printf star ip or if ip printf star ip and so on
so what this does is it actually checks whether ip is null or not
if i know that it was initialize to null and at this point if ip is not equal to null then there was a valid assignment to ip that happened here
if there is no valid assignment ip will still remain at null and you will not print the value
so this is a check that is done usually in practice again we will see how this is useful when we do what is called dynamic memory allocation
so we have not done that yet but when we do malloc we will use this template later
so another subtle thing with the c is that it provides pointer of type void
so void is so you declare it by saying void star vptr and this void pointer is actually a generic pointer what i mean by that is it can be made to point at anything
so so far we saw integer star pointer
so you could also have float star ptr 1 and so on but this void star vptr is a generic pointer you can make it point to a integer you can make it point to a floating point you can make it point to a character or you can actually make it point to a pointer itself and so on
so this is another thing that comes very handy and this is just for you to notice now we will see this in detail later
so let us let us look at a small code segment using pointers
so here we have two integer variables m and k and we have a variable ptr which is actually of the type integer pointer
so one thing you can notice is that in this single line right we have done a few things we have initialized declare and initialized two variables m and k we have also declared a pointer variable of integer pointer type
so you can combine declarations in one line and this is the way to declare both integer variables and pointers to integers in the same line
so in this case ptr is made to point at k so ptr equals 1 percent k is made to point so you are making ptr to point at k
so let us look at these four lines of code
so it is so the first line says m has the value percentage d and stored at percentage p and we give two parameters as inputs to print f
so the first thing you notice is this percentage p is a format specifier for pointers
so just like we have percentage d for integers percentage f for floating point and so on for pointers it is recommended that you use percentage p and so let us see what happens in this line
you have percentage d as a specifier that will attach it to m
so here you want m printed as percentage d format which means print m as an integer and the second argument is void star ampersand of m
so this is the case of what is called type casting
so ampersand of m is of pointer type and it is an integer pointer type you type cast that into what is called void star
so you can take a pointer which is of integer type and make it a generic pointer
so if you look at the data type of void star ampersand m it is actually a void pointer now it is not integer pointer anymore and you are printing that using format specifier for called percentage p
so in the second line k has the value percentage d and stored at location whatever is the address of k
so i already showed something very similar
so ptr itself is a variable which means ptr is given space or it is given some memory in it is given a memory location
so ptr has the value percentage p and distorted percentage p
so in this case this one the first argument itself is a pointer and the second argument is taking the address of ptr and casting that to void star and finally the last line says the value of the integer pointer 2 by ptr is percentage d
so star ptr as i said is dereferencing ptr
so see here we are not declaring ptr
so that has already happened in this line here we are doing dereferencing of ptr
so this is what i was pointing to earlier
so there are two ways in which you can use the star associated with the pointer one is for declaration the other one we are seeing here it is useful for dereferencing
so it is getting the r value of k and it will print the value of k
so the key thing to notice in this slide is there is percentage p specifier for pointers and we did what is called type casting
so we took integer pointer ampersand m and we converted that to void pointer using this bracket void star
so i suggest that you actually take this piece of program and try it out to understand what is happening there
so one key use of pointers is that it is something that is used for manipulating arrays
so in c there is a very very strong relationship between pointers and arrays and without pointers you cannot do a few things in c when you actually want to use arrays
so we will see this again in more detail when we look at functions
so but so take it for now that there is a strong relationship between pointers and arrays and anything that you do using array subscripts can actually be done using pointers
so pointers in that sense is more powerful and more generic way of dealing with either continuous set of locations or something that is not continuous
so let us see this small example we have int a of 12 as i said earlier right int a of 12 will declare space for a and let us say that is the top set of boxes that you are seeing and we know that a of 0 is the very first location a of 1 is the second location and so on and a of 11 would be the last location
so indices go from 0 to 11 12 is not a valid index for a
so if i have int star ptr this will give me a memory location called ptr and if i do either of these two right if i say ptr equals ampersand of a of 0 or ptr of a then ptr starts pointing to so let us see what really happens here
so let us look at this statement first
so if i look at the statement ptr is ampersand of a of 0 right
so let us see what this does
so a of 0 is a value right it is not a pointer a of 0 is actually a value
so we have seen this in array so far right but the moment you put ampersand in front of it it means do not get the value that is stored in a of 0 instead give me the pointer to the 0th element
so the left side is asking for a pointer and the right side actually gives a pointer
so this is valid
so what this is really doing is ptr begins to point at the 0th element of a
you can also achieve the same thing by a sliders shortcut which says ptr equals a
so this is also something that you will see good programmers doing
so experience programmers do not use this format instead they use ptr equals a
so what this is doing is ptr is now going to contain the address of the 0th element of a
so in some sense the name of the array a is actually only a synonym to the 0th element to the address of the 0th element
so when we say a right a is an integer array of size 12 but the variable a is actually just a synonym for the address of the 0th element of this array
let us see what all this means
so if i do in star ptr equals a
so in this place in this piece of code we are declaring a pointer integer pointer called ptr
so this says we are declaring an integer pointer and the variable name is ptr and right when we are declaring we are also initializing it to a
so if a is this array that we have here then ptr starts pointing at the 0th location
so this is something that comes from the using a as a synonym for the address but the nice thing you can do with ptr is that you can do something like this
ptr is ptr plus 1
so let us see what this means
on the right side we actually have a pointer variable and we are adding one to it
so what that means is instead of making ptr point at a of 0 now you actually point it to the next element after the current one
so at this point ptr was pointing at a of 0 right
so you can see that here but the moment you do ptr is ptr plus 1 it starts pointing to the next element
so clearly you can see that if you do ptr is if you do another ptr equals ptr plus 1 it will start pointing to the 2th location and so on
so it starts with 0th
so like i said i abuse this abuse english language i say 0th 1th and 2th and so on
so right now it is pointing at 0th location and if you do ptr is ptr plus 1 it will start pointing at 1th location and if you do one more ptr equals ptr plus 1 it will start pointing at 2th location and so on
so we can use like arithmetic like you would do on integers and so on but there are certain rules
we will see this in a little more detail in a little while
so one thing i would want you to think about is what does star ptr equals star ptr plus 1 do
so clearly there is a difference between saying ptr equals ptr plus 1 versus star ptr equals star ptr plus 1
so take some time and think about it
so it will be useful to think about what this statement ptr equals ptr plus 1 does versus star ptr equals star ptr plus 1 does
take a while to think about it
so let us go back to arrays
so in some sense arrays i said are less flexible than pointers
so arrays are what are actually called constant pointers
so let us look at p's of code on the left side
we have int a of 10 and we have int star p a
so p a is an integer pointer and when we say p a equals a now p a starts pointing at the 0th location of a and if you do p a plus plus we are incrementing p a what this does is it makes p a point at a of 1 instead
so this is actually okay to do because pointers are variables and here you did one assignment to p a and you change the assignment to p a here which is perfectly fine for p a because p a is a variable
let us do something which is slightly different here
we have in on the right side in the red box we have int a of 10 we have in star p a and we say a equals p a right
so the first thing is that a equals p a is not permitted at all
so this is not permitted
the reason is that when you do a equals p a a is supposed to point at some 10 locations and you are now asking a to point at some other location as indicated by p a
so this is not allowed nor is a plus plus allowed
so even though a is a synonym for the 0th location it is not valid to take the variable name that is used for the array and do any kind of arithmetic on it
you cannot do a plus plus you cannot do a equals p a or anything of that sort
so to summarize a cannot appear in the left side of any expression
so a plus plus is actually just a equals a plus 1 right
so a cannot appear in the left side of any manipulation at all of any expression at all whereas p a being a variable can appear freely on the left side
so the a the variable the variable a is actually an array and it is called a constant pointer
so what i mean by constant pointer is that a of 10 is actually a set of 10 locations
so we have 10 locations and a is actually pointing to a of 0 technically and it cannot point at anything other than a of 0 that is what it means by that is what i mean by constant pointer a can point at a of 0 and nothing else the moment you say in a of 10
in today's lecture we are going to look at algorithms for finding the i th smallest number in a given data set
the specialty about the problem that we are going to look at is that it is a recursive algorithm and it is very efficient compared to the most simplest algorithm to answer this question
the problem in question is given n distinct numbers you can imagine it to be presented in an array
the goal of the problem is to find the i th smallest element which is also given as part of the input the value i is also given as part of the input
in other words we want to find an element which is larger than exactly i minus 1 elements in the given data set
one natural approach to solve the question needs to sort the given n distinct elements in ascending order and one can use an algorithm like merge sort which is known to run in order of n log in time and then we return the i th element in the sorted array
this definitely does solve the problem
the focus of this lecture is to see if we can design better selection algorithms
in other words our aim is to design selection algorithms which run in time order of n in the worst case
the main idea behind the algorithm that we are going to look at is the concept of a median
let us just recall the definition of a median
median is the middle rank element in a given set of numbers
if there are n distinct odd numbers in the data set then the middle rank element is the unique element
if n is indeed even then there are two medians the elements rank n by 2 and the elements rank n by 2 plus 1
we define the median to be the element whose rank is floor of n plus 1 by 2
if n is odd this is a single element and if n is even this is the n by 2th rank element
the idea for identifying the i th rank element is that we use the power of recursion and given the elements in an array we aim to partition the elements of the array into two parts based on an index r the elements a of 1 to a of r that is the first r elements in the array are of values smaller than the r plus 1 the element in the array and the remaining elements that is the elements with indices r plus 2 to n are of value more than a of r plus 1
indeed if r has the value i then we have indeed found the i th rank element
this is very clear because the first i minus 1 elements are smaller than the i th element and therefore a of r is the i th rank element for r is equal to i
we are going to do this for some carefully chosen r so that we can get our desired efficient algorithm
the way to do this is if r is not equal to i then we ensure that we have recursively smaller sub problems to solve so that we can get to the i th rank element as quickly as possible
so now we set up the recursion
if indeed i is smaller than r then we find the i th rank element in the set a of 1 to a of r
this is indeed the most natural thing r is larger than i and all the elements below r all the elements whose indices are in the range 1 to r and the array a are indeed smaller than r and therefore the i th rank element would also have an index smaller than r
therefore it is natural to search for the elements in the range a of 1 to a of r the i th rank element in the range a of 1 to a of r
i is more than r clear that we look for the i minus r th rank element in the range a of r plus 2 to n
in either case it is clear that we have smaller recursive sub problems but to get our efficient running time we will see that it is desirable to have the two parts in the partition to be of almost same size
and we will try to ensure this
so let us just go to the design of this whole algorithm
we refer to this algorithm as the select procedure
the procedure has two arguments and an array a and a rank i
the output of this select function is to return the value of the i th rank element in the array a
select a of i is a recursive function
let us just recall recursive function
it is a function which makes calls to itself with of course different parameters
so what we now do is we try to partition
we come up with a procedure to partition the array based on an index r
to do this what we do
 we do not have a function is to take the n elements and divide it into n by 5 groups
the n by 5 groups are the elements with index 1 to 5 the elements a of 6 to a of 11 and so on up to a of n minus 5 to a of n
it is important to notice here that the last group could be of value smaller than 5
for example if n is not a multiple of 5 then clearly the last group will be smaller than 5
in each of these groups we find the median element
we call that in each group there are 5 elements except for the last one
for the purposes of this discussion let us assume that the last one also has 5 elements
and we pick the median element in each of these n by 5 groups
and for this we can use insertion sort and sort the 5 elements and pick the median
in other words this will be the third-rand element in each group
what we do is we visualize these median elements from each of these groups in an array m
now here is the first use of recursion
we look at the array m and ask for the median of the n by 5 elements in the array m
so the recursive call is described here
if there are m elements in the array then the recursive call is select on the array m the median element which we know is floor of m plus 1 by 2
let the return value be x
now what we do is to partition the array a into 2 parts around the element x
we will see how to do this
but before that let us also analyze how good this partition is
what do we mean by a good partition
 we analyze what properties of this partition are there which could give us a linear time algorithm to find the i-th-rand element
so let us see how good this partition is
and let us make some observations
let us ask in the array a how many elements are greater than x
we call that x comes from the array m and indeed it is a median element of the array m
m has n by 5 elements in it
therefore x has n by 10 elements larger than it
that is half the elements in the array m are larger than x x being the median element in the array m
let us also recall that x is each element in m is a median element in those n by 5 groups
and there are 3 elements which are at least as large as each element of m in the array a
i repeat this for each element in the array m
there are definitely 3 elements in the array a which are at least as large as that particular element
therefore there will be at least 3 and by 10 elements which are at least larger than x in a
therefore at least half the groups have 3 elements smaller than or equal to x
this is except for the group containing x which has 2 elements and the last group which may contain only one element
therefore the number of elements which are smaller than x in a is at least 3 and by 10 minus 6
so let us complete this
let us complete this discussion of how good this partition is
using the symmetric argument the number of values at most x in a is also at least 3 and by 10 minus 6
as a consequence of this argument it follows that the 2 arrays a of 1 to a of r and a of r plus 1 to a of n
after the partition step have size at most 7 by 7 and by 10 plus 6
this is because the array has a total of n elements and therefore the number of elements in the 2 parties at 2 arrays a of 1 to a of r and a of r plus 1 to n is at most 7 and by 10 plus 6
therefore by making a recursive select call on one of these 2 arrays we get a running time which is given here which is t of n the time taken to find the i th rant element in the given array a is equal to t of n by 5 which is to find the median element in the array m plus t of 7 and by 10 plus 6 which is the time taken to solve the recursive subproblems plus the time taken to create the partition which is also a linear time procedure
finally if the array has a single element to find the i th rant element is extremely easy
so it just is so t of 1 is taken to be 1
it is easy to see that t of n is order of n for this recurrence
we do not evaluate the recurrence here but this is a recurrence which evaluates to order of n
what are the remaining steps of the algorithm
 we partition the input array around the element x to do this is the following steps have to be done
we identify the position of x in the array a
this can be done in order of n time by scanning the element scanning the array a for the element x and then we perform a partition procedure linear time partition procedure which identifies an index r such that a of r has x and the elements 1 to r minus 1
the elements in the indices 1 to r minus 1 are smaller than x and the elements in the indices r plus 1 to n are more than x
this is exactly what we want
there are r minus 1 elements on the low side of the partition and n minus r elements on the high side of the partition
so the algorithm is almost complete now
if i is equal to k then we return the value x
otherwise we use select recursively and the recursive calls are made as follows
we find the i th smallest element in the low side if i is smaller than r and we find the i minus r th smallest element in the high side if i is more than r
let us run through an example of this algorithm
in the given array of 28 elements we want to find the 11th rank element
in the first step we divide the array into 5 groups of 5 elements each which counts for 25 elements and one group the last group of 3 elements
we sort the groups and then find the median element in the 6 groups and the median elements are marked in red
observe that in the groups of size 5 the median element is a third element and the last group the median element is the second element
in the third step we find the median of the medians and this is our array a this is our array m and one can see that there are 6 elements and the median element is the element 17
we partition the array around 17 and in the first part we have all the elements which are smaller than 17 and 17 is the 11th rank element and the algorithm terminates and returns the value 17 as the 11th rank element
if for example we wanted to find the 6th smallest element then we would have to request our search in the first part which is the values which are smaller than 17 and similarly if we want to find an element of rank 15 then we would have to find the element of rank 4 in the second part
this completes the description of the algorithm to find the i s smallest element in a given array a
after looking at the basic algorithms and techniques like the greedy techniques today we come to an advanced technique called dynamic programming
dynamic programming is an algorithm design method
it is used when the solution to a problem can be obtained by selecting a solution to some sub problems
this is a very loose way of putting it but we will set up all the formal details in the lecture today
most importantly the role of this slide is to tell you that dynamic programming techniques are very fundamentally different from greedy algorithmic techniques
often in the greedy algorithms there is this power of making a greedy choice which we have seen in earlier lectures
and the greedy choice identifies a single recursive sub problem to solve
let us look at the shortest path problem as an example
what you see is a layered graph
it has four vertices s a b and t and you also see the edge cause
and if one uses the greedy technique to find the length of the shortest path from s to t by being greedy
in the sense that from s we choose the edge of least weight
then from a we choose an edge of the least weight and from b we choose an edge of the least weight
then we can conclude that the greedy algorithm will output a path of length 8
however it is quite clear that the length of the shortest path is indeed 9
in this example the in this example the algorithm does output the shortest path
but let us look at the shortest path in a slightly more complicated looking graph
if we are greedy then the greedy algorithm will choose the path which goes from s to the vertex a because the edge weight 1 is the shortest among all the edges that go out of s
and from a it chooses the cheapest edge weight which is 4 and takes it to the vertex d and d it chooses the shortest edge whose cost is 18
and we conclude that the greedy algorithm outputs a path whose length is of 23 units as opposed to the shortest path which is from s to c c to f and f to t and the cost of this path is indeed 9
therefore it is clear that to solve the shortest path problem a greedy strategy does not work
let us just look at the dynamic programming approach and let us also make some observations about the shortest path
the length of the shortest path from s to t is obtained by calculating the shortest paths via the vertices a b and c respectively and then picking the shortest path among the three in this example
it is quite clear s and s has three neighbors only which are called a b and c respectively
now if we know the shortest path from a to t and the shortest path from b to t and the shortest path from c to t respectively then adding up the appropriate edge cost from s and then choosing the minimum will very clearly give the shortest path from s to t
therefore what we have now observed is that to solve the shortest path problem we need to solve recursive versions of the shortest path problem from neighboring vertices
let us just run the example on let us just look at the formulation of the distance from s to t or in other words the shortest path from s to t
clearly as we just discussed distance from s to t is minimum over 1 plus the distance from a to t the 1 comes because of the edge rate from s to a is 1 2 plus distance from b to t because edge rate from s to b is of cost 2 and 5 plus the distance from c to t the edge rate from s to c being 5
indeed if we know the shortest paths from a to t b to t and c to t respectively this minimum gives us the shortest path from s to t
now the distance from a to t the part of the relevant part of the graph is shown here the distance from a to t as you can see is the minimum of 4 times the distance 4 plus the distance from d to t plus the distance from a to t is given by the minimum of 4 plus the distance from d to t and 11 plus the distance from e to t where d and e are the only neighbors of a
we can similarly now formulate the distance from b to t the distance from c to t and distance from s to t can then be used to calculate
so the distance from b to t is again 9 plus the distance from d to t the distance from b to t is given by the minimum of the 3 distances via d via e and via f respectively
similarly the distance from c to t there is just a single path that goes through f and this is given as 2 plus the distance from f to t
one can now observe that the distance from s to t will indeed choose the path that goes via c which is of cost 9 because that is where the minimum is attained
what we have done in the slide so far is to observe that a recursive formulation of the distance function in terms of distances from other vertices to the destination is helpful in computing the shortest path
it is also possible to observe that one can calculate the distances from the recursive formulations which we have just observed
one can observe the distance from s to d an intermediate vertex not necessarily t is the minimum of the distance from s to a plus the distance from a to t and similarly the distance from s to b plus the distance from b to t
in other words we are taking the minimum of the distances via intermediate points a and b respectively
similarly the distance from s to e and distance from s to f are also presented
now that we have seen this example let us just formally state dynamic programming and its purposes
it is used for solving optimization problems which are minimization problems or maximization problems and in all these problems a set of choices must be made to get an optimum solution
in the examples that we looked at the appropriate edges must be chosen to find the length of the shortest path from s to t
the choices are the edges that must be taken by a shortest path from s to t
there may be many such paths for example in an undirected graph you every path with the least number of edges from s to t is indeed a shortest path and our goal is to find an optimal solution
in other words to find the optimal set of choices
when we design a dynamic programming algorithm the approach that we take is to first understand the structure of the optimal solution and characterize this optimal solution
by characterisation we mean that we identify certain very important properties of solutions which necessitate them to be optimal solutions
that is what we mean by a characterisation
after characterising the structure of an optimal solution we then recursively go ahead and write a recursive expression for the optimal solution and then compute the value of the optimum solution in a bottom of fashion
the last computation is indeed done via a program but the first two are analytical exercises and the computation indeed implements the recursion
as an example we study the assembly line scheduling exercise which is an introductory exercise and dynamic programming in the standard textbook where carbon lysos and and rivus and the pictures that you see are taken from the textbook
assembly line scheduling can be very intuitively visualised
it is a very important problem in the area of manufacturing
the framework is of an automobile factory
the framework is of an automobile factory which has two assembly lines
each line has end stations and processing stations
on the first line the processing stations are called s1 1 to s1n and in the second line the processing stations are called s2 1 to s2n respectively
there are end stations
now corresponding to the stations each of the stations have a certain processing time
in particular for the station s1j that is a j station on the line 1 the processing time is a1j units of time and similarly at the station s2j the processing time is a2j units of time
the entry times into the station are e1 and e2 respectively
the entry times into the lines that is the entry into the first station s1 1 and the entry into the first station s2 1 are e1 and e2 respectively and the exit times from the stations are x1 and x2 respectively
one can assume that in this automobile factory a car chassis enters one of these two assembly lines and then goes through from one station to another and exits with a completed vehicle
along the way the car station the car along the way a car can stay on the same line by going to the next station in the line and it does not pay any cost in terms of time duration or it could transfer to the other line with a cost which is tij units of time
in other words if a car gets processed at station s1 1 if a car gets processed at station s1 1 then it can either go instantaneously to station s1 2 or in t11 units of time it can go to the station a22
so what is the problem in this whole exercise
 the problem in this whole exercise is that a chassis must be rooted through this network
it must visit every station it does not matter in which line it gets processed but it must get processed at every station and exit in a minimum amount of time
this is for a single chassis
now one of the ways of solving the problem is to actually try all the possible ways by which a chassis could go through the assembly lines and it is very clear that there are two power n of them and computationally spending two power n units of time to actually find out which is the most optimal sequence is not an efficient approach
so the implementation of this idea is essentially to have a bit vector a binary vector which essentially says if a certain bit for example in this case at step 3 if the bit is set to 0 then the vehicle goes through station 4 the vehicle goes through station 2 in step 3 and if it is one the vehicle goes through station 1 in step 3
the implementation of this brute force algorithm is to keep a bit vector where 0 indicates that the vehicle 0 indicates that the chassis will go through line 2 and 1 indicates that the chassis will go through line 1 and once these are fixed the time that the chassis spends in the factory can be easily calculated
it is just the length of the path that goes through these stations the sum of the time durations on the edges will tell us the total time that the vehicle will tell us the total time the chassis spends in the factory before exiting and then we can choose the bit vector which gives the least solution and indeed we would have solved the desired problem
however we would have spent two power n units of time to avoid this inefficiency in terms of the amount of time that has been spent by the algorithm in finding the optimal path we try and understand the structure of an optimal solution which is the first step in the design of a dynamic programming algorithm
in this graphic we indeed have highlighted the optimum path in dark color we will see how the algorithm will indeed find this particular path
to understand the optimal solution we invent a parameter of interest
let us look at the station j on the first line and let us ask if a shortest path goes through s1j then do we have some information as through shortest paths to other stations that preceded it that are computed in that shortest path
to understand the structure of the optimal solution we ask the following question if there are two if we look at the set of all possible ways from the start to exit via s1j there are two possibilities for a path that goes via s1j the previous vertex before the station s1j could have been the station s1j minus 1 and a direct transfer to s1j or the previous station could have been s2j minus 1 that is the station on the second line and the transfer over to s1j
we now make the observation that the fastest way through s1j is through s1j minus 1 in other words if we consider all the paths go from the start to exit which go through s1j and among these if we consider the path which is the fastest and let us say that such a shortest path or such a fastest path indeed goes through s1j minus 1
then it is also clear that such a path must have taken the fastest way from start through s1j minus 1
the reason is very straightforward indeed if there is a faster way through s1j minus 1 then we could have used it and found a faster path through s1j
this is really the optimal structure or it is a structure of an optimal solution
the structure of an optimal solution is the fastest way through s1j contains with it an optimal solution to the fastest way through s1j minus 1 or s2j minus 1 whichever is there in the fastest way through s1j
this is referred to as the optimal substructure property
it is this property that is used to write down the recurrence for the length of the shortest path from s to t or the fastest path from s to t
so what we are going to do now which is a second step in the process of dynamic programming is to write down the optimal solution in terms of the optimal solutions to subproblems
let us introduce some necessary notation
let us assume that f star is the fastest time to go through the whole factory and let fij denote the fastest time to go from the starting point through the station sij
therefore f star is very clear f star is a minimum of the two terms which is f1 of n plus x1 that is the time taken to exit from line 1 f2 of n plus x2 which is the time taken to exit from line 2
therefore this expression tells us that we need to compute f1 of n and f2 recursively
let us start off with the base case
let us consider f1 of n
let us consider f1 of 1 that is through station 1
what is the fastest path that goes through station 1 on line 1
 it is a time taken to enter line 1 and get processed at the first station
in this case as you can see it is 9 units of time but the generic formula that we can write down is that f1 of n is e1 plus a11
this is the time taken to enter into line 1 and the time taken to be processed at the first station on line 1
similarly f2 of 1 is a time taken to enter into line 2 plus the time taken to be processed at station 1 on line 2
the formula i have written there f1 of 1 is e1 plus a11 and f2 of 1 is e2 plus a21
in general we can write down a recursive specification of f1j or f2j
they are symmetric
let us just look at the case for f1j
so the fastest way through sij has only two possibilities
the two possibilities are use the fastest way to come to station j-1 on line 1
use the fastest way to cross station j-1 on line 1 and then be processed at station j on line 1 or use the fastest way to arrive at station j-1 on line 2 then transfer to line 1 and then get processed at station j on line 1
therefore f1 of j is a minimum of f1 of j-1 plus a1 of j comma f2 of j-1 plus the time to transfer out of the j-1 station on line 2 to the j-1 line 1 that is t2j-1 plus a1j
observe that this is a recursive specification of f1 of j
the recursive specification of f2 of j is also similar and this basically tells us the recursive solution of interest for every station on each of the two lines
having formulated this recursive specification of the time taken to cross station j on line 1 and the time taken to cross station j on line 2 and this we have done for every j between 1 and n
we now wonder how what it is to calculate these values from these formulae and this is the exercise of computing the optimum solution and one of the ways of solving the optimum solution is to solve this in a top-down fashion and clearly if one tries to compute f1 of n and f2 of n in a top-down fashion at every step we are taking the minimum of two quantities and it is clear that the running time of this algorithm which is to evaluate this recurrence in the top-down fashion will take an exponential time
in other words it will take two power n units of time which does not seem to be a significant improvement which is not an improvement at all over the simple algorithm that we started out with the brute force algorithm
on the other hand if one uses the bottom-up approach one can indeed observe that the values of interest f1 of n and f2 of n can be very easily calculated
the main observation that we make is that for j greater than or equal to 2 the value of fi of j depends only on f1 of j minus 1 and f2 of j minus 1
in other words the fastest way of crossing station j on either line depends only on the fastest way of crossing station j minus 1 1 line 1 and the fastest way of crossing station j minus 1 on line 2 and we compute the values of fij as described here in increasing order of j
let us look at the time taken to cross station 1 which we know
in this example we can see that the fastest way of crossing station 1 on line 1 is 9 units of time
on station 2 it is 12 units of on line 2 the fastest way of crossing station 1 takes 12 units of time
after this let us look at station 2 the fastest way of crossing station 2 on line 1 is 18 units of time and the number in parenthesis says which station was the on which line was the previous station
in this case the fastest way of crossing station 2 on line 1 is via station 1 on line 1 itself which is an instantaneous transfer to station 2 and then 9 units of processing time
also the fastest way of crossing station 2 on line 2 is to actually go through station 1 in line 1 and then transfer to station 2 on line 2 and be processed at station 2 on line 2
observe that this is 16 units of time as opposed to 12 units of time plus 2 units of time to transfer as opposed to 12 units of time at station 1 on line 2 and then instantaneously be transferred to station 2 on line 2 and then use 5 units of time which makes it 23 units of time
similarly at station 3 on line 1 observe that the fastest way of crossing station 3 on line 1 goes through station 2 on line 2 and uses 20 units of time as opposed to crossing station 3 on line 2 which takes 22 units of time
similarly crossing station 4 on line 4 takes 24 units of time via station 3 on line 1 itself and on line 2 it takes 25 units of time via station 3 on line 1 and crossing station 5 takes 32 units of time via station 4 on line 1 and 30 units of time via station 4 on line 2 and then the exit takes 3 and 5 units of time respectively
therefore the quickest way of getting from entry to exit is 35 units of time via station 5 on line 1
having gone through this whole exercise of recursive of identifying the optimal substructure and recursively specifying the distance function and observing that it can be computed in the bottom of fashion
computing the optimal route that is the sequence of stations through which the shortest path passes through is left as an exercise
the next example of dynamic programming which we will study is the problem of optimal matrix strain multiplication which will be done when we meet next
thank you
in today's lecture we will look at remember very important tool in programming in that the information of pointers
so the interest are let me try to motivate some use for pointers
as we have seen when we were discussing functions the communication between the collar function and the cauliflower function that is the function that has been called is in two ways
by communication we mean the flow of information or the transfer of information one is the collar can pass some arguments to the cauliflower function
this communication is from the collar to the collar and in the reverse direction the cauliflower function can return a value to the collar function and this communication is from the collar to the collar
but note that the return value as you have seen can be a single value it cannot be more than one value
now suppose we want a function to return more than one value then how do we achieve that
so here is a example problem in which you might want to actually do that
suppose you want to write a function to convert from polar coordinates to rectangular coordinates maybe the program that we are writing is a graphics program and deals with geometric objects and so on
so we want to write a function which converts from polar coordinates that is r theta to rectangular coordinates that is x y
now how do we write such a function the parameters of the functions are clear they would be the values of r and theta and the return value should comprise of x and y
but that is not possible because we cannot return two values from a function
one possibility as we know is that we could make the variables x and y global variables and then the function which converts from polar to rectangular coordinates could modify these global variables instead of returning any value
but in general that is not a good idea
we should avoid using global variables as far as possible because when two functions share global variables that is they both access the same set of global variables then this increases what is known as binding between the two functions
and what binding means is that the two functions cannot really be understood in isolation that is for understanding one of these functions you have to also understand what the other function is doing
so that makes it more difficult for somebody to understand the program by reading it because he cannot just focus on one function anytime and consider it independently of the rest of the function
so we should use global variables when it is really required
but in most cases we should avoid using global variables and variables which really are of use to only one function should be made local to that particular function
so the question remains how do we solve this problem
so we will solve this problem using pointer
i will show you the solution towards the end of the lecture
but having motivated the use of pointer let us now look at what pointers are and what we can do with them
so suppose we did not use pointers and wrote our polar to rectangular function by adding two extra arguments x and y to it and the polar to rectangular function modified these x and y values
as you know what would happen is that when polar to rectangular modifies this variables x and y what it is really modifying are the parameter of the function polar to rectangular and this change would not have effect on these variables x and y of the main function
so that is something that we can do only using pointer
if we wrote the function like this as we have already seen this does not work because the x and y in the calling function they do not really get modified
so let us not try to understand what pointers are but to understand that let us go back to our basics and first talk about what a variable is
so recall that a variable represents a cell or a location in the memory of the computer that holds a certain value at any given point in time
recall that the memory consists of a large number of memory locations or memory cells and each of these cells has a distinct address associated with it that is how at a lower level we identify or refer to individual cells in the memory
so a pointer to a variable is nothing but the address of the memory location which is associated with that particular variable
so so far we have been using variables that is accessing their values and altering or modifying their values using only their names that is use the name of a variable to refer to it or to get its value or to modify its value and so on
but using pointers what we can also do is to instead of using the name of a variable to access it we could use its address to actually access the same variable
so that is what pointers allow us to do
it is actually not important to worry about the actual addresses of variables because what the actual address of a variable is depends on what address the compiler really assigns to it
but the actual addresses are not important what is more important to realize is that a particular value is the address of a particular variable
so that is better understood using a pictorial representation
so what we are going to do is to represent variables as boxes
so each variable is a box in which some value can be stored or placed the name of the variable we can think of as a label attached to that box
the value of the variable is the value stored in the box or written in the box and finally we can represent or think about a pointer to the variable as an arrow pointing to the box
so for example here is a variable x with value 5
so we have represented this variable as a box
the value 5 is written inside it and x is a label for this box and a pointer to this box is nothing but we should think of it as an arrow pointing towards the box
we will see that it is very helpful to use this notation to understand what a particular program is doing because we do not need to actually deal with actual numerical values of the addresses
so all that all the information that we need to know about a particular address or a pointer is that is the variable that it is pointing to
so representing it as an arrow pointing towards the box representing a particular variable is a very powerful notation and we will see that we can using this notation very easily visualize what is going on in a program that is using pointers
now the next important thing to understand is that pointers are also values and just like values of types like integers and characters and floating points and so on and so forth
they can also be stored in variables and they can be passed as arguments to functions and so on and so forth
but the type of a pointer is not in tors float or car or something like this
there is a notation for specifying the types of pointers and the type of a pointer depends on the type of the variables that it can point to
a particular pointer variable can hold a pointer to only variables of a certain fixed type
for example if we say that we have a variable which will hold pointers to integers then this variable can only hold pointers to a variable of the type int
at different points in time in the execution of the program it may hold pointers to different integer variables but it will always hold pointer to some variable which is of type int
so if a variable is going to point to if a pointer is going to point to a variable of type p and therefore also the type of a variable that is going to store such a pointer then the type of that pointer and the type of the variable which will store such a pointer is t star
this is just a notation that see uses
so t star should be read as pointer to t and t itself could be any of the types that we have seen it could be an int it could be a car it could be a float or a double or whatever else
as an example suppose we want to declare a variable that will hold a pointer to some variable of type int then this variable would be declared as says here p is the name of the pointer variable and int star is the type of this variable
so what this declaration says is that p is a variable which means that p is itself a box somewhere with the label p and what this box will contain is not an integer but a pointer or an arrow to some other box which contains an integer which might be x at a certain point in time at a certain later point in time we may modify the value of this variable and make it point to another variable may be y which itself has the value 5 and so on so forth
so there are two operators associated with pointer the first is the operator ampersand and the other is the operator star both of which we will look at one by one
so the operator ampersand is a new operator it should not be confused with another ampersand operator that exists in c this is a unary operator which means that it has just one operand
now this operator can be applied to a variable it cannot be applied to an expression which cannot appear on the left hand side of an assignment
so suppose x is a variable than the expression ampersand x refers to the address of or the pointer to the variable x
so using this particular operator we can obtain the pointer to or the address of any variable that we care to and this itself is a value and it can be stored in a variable of an appropriate type and so on so forth
note that this kind of an expression ampersand x cannot appear on the left hand side of an assignment because we cannot modify the address of a variable the address of a variable is fixed and it is assigned by the compiler we cannot really change that and therefore this expression can appear on the right hand side of an assignment because we can store it somewhere but we cannot place it on the left hand side of an assignment because we cannot modify this value
so for example to illustrate the pictorial representation that we have been talking about consider this simple piece of code
so we have two variable declarations here the variable x is of type integer and has the value 5 and the variable p has the type in star which means that it is it will hold a pointer to an integer variable and it is initialized to the value ampersand x
so what this means really is that x has the value 5 x is a box is the value 5 in it and p is another box labeled p and what it contains is a pointer to or an arrow pointing towards the variable x
the other operator that is associated with pointer is the unary star operator and again please do not confuse it with the multiplication operator of c the multiplication operator is a binary operator whereas this is a unary operator and this is not an arithmetic operator this does not really do an arithmetic
so again let us assume that p is a pointer variable that currently points to the variable x
so the situation is something like this
the type of p is some p star and the type of x is the type t could be int or float or anything else
now the expression star p refers to not the value of the variable p but the value of the variable to which p points
so the expression p itself would be a pointer to the variable x but the expression star p is the same as the value of the variable x of to which the point to which the variable p points
so if x happen to have the value 5 and p happen to point x then star p would have the value 5 also
so this can be used on the right hand side of an expression to obtain the value of the variable to which a particular pointer is pointing
it could also be used on the left hand side of an assignment to modify the value of the variable to which the pointer is pointing
so for example if we have the assignment star p assigned 7 then this does not change the value of the variable p itself what it changes is the value of the variable to which p is pointing which in this case is x and that value becomes 7
so you can see in this case what is happening is that by using star p we are actually referring to the variable x itself but instead of referring to the variable x by its name we are referring to the variable x by its address which is the value of the expression which is the value of the expression p
so let us make this more concrete with the help of a detailed example
so here is a piece of code and we will trace through this piece of code and see exactly what is happening here
so we have three variable declarations i j and p and these are the three boxes for these three variables i j and p i and j are of type n
so these boxes will contain some integer values and p is of type n star which means that p will hold a pointer to some integer variable
we have only two integer variables in this particular example
so p can hold a pointer to either i or 2 j note that as we will seen this example indeed that at different points in time of the execution of this program the variable p may hold pointers to different variables
so let us just step through this code and see what happens
so this is the statement that we need to execute next i is i and p when that is executed you all know what is going to happen
the variable i will get the value 3 and control goes to the next statement j is i and 4 and when j sign 4 is executed the value of j becomes 4
so till now everything is familiar
now the next statement is p assigned m percent j m percent i
so what that is going to do is the following m percent i represents a pointer to i or the address of i
so this value is going to be stored in the variable p
so what that is going to do is establish an arrow from p to i and that is precisely what it does in day 2
and the next statement is j assigned star p
so what should happen here what is the so the left hand side of the assignment is j
so clearly the value of j is going to change but what is going to the new value the new value is the value of the expression star p the value of star p as we just saw is the value of the variable to which the pointer variable p points
now p is pointing to the variable i and so the value of the expression star p will be 3
so what is going to happen is that j should become 3 when we execute this particular assignment statement as indeed that is precisely what happens
now the next statement again modifies the value of p to the address of j
what that means is that now p will stop pointing to the variable i this pointer will be removed and instead the value of p itself will change and will start pointing to the variable j
so that is what is the effect of this statement
the next statement of course is simple is assigned 5
so that just changes the value of the variable 5
and finally here we have an assignment in which the expression star p appears on the left side of an expression of an assignment
so in this case what is going to change
 what is going to change is the value of the variable to which p points
now at this point in time p is pointing to j
note that the fact that p earlier pointed to i is no longer relevant that fact is forgotten
p is now pointing to j and therefore when star p is assigned something the value of the variable j will change and what will the value of the variable j will become
 this will be the value of the expression on the right hand side of the assignment which is i plus 3 which of course is 8
so this value should become 8 as indeed that is what happens
so having understood the basic concepts of pointers we can now solve the problem of conversion from polar to rectangular coordinates
and this example will also illustrate how we can pass pointers as arguments to functions
and so recall that the basic problem was that we wanted the function polar to rectangular to modify the variables x and y of the function mean
now it cannot access this variables x and y of mean by name because the scope of these variables is only within the body of the function mean
but it can access them if it has the addresses of these variables
and how does it obtain the addresses of these variables
 well if the main function itself passes them as arguments to the function polar to rectangular
when the function polar to rectangular will have access to the addresses of these variables
and when it uses these addresses to access these variables that process is called d referencing then it will be able to modify the variables x and y of mean itself
so let us see what the solution will look like
the function polar to rectangular is similar to what we have written with some important differences
now the type of the variables x and y which we are calling p x and p y to stand for pointer to x and pointer to y are double star instead of double the value the parameter r and theta remain of the type double
so and when we compute the value of x and y r star cos theta is the x component and r star sin theta is the y component instead of running to x which would be illegal because the variable x is not in scope we assigned to star p x and to star p y respectively
and when we call this function from main the variable declarations in main are the same as before
so we pass these parameters r and theta we pass these arguments r and theta as before
now instead of passing the value of x and y what we are passing are addresses of x and y note that m percent x denotes the address of x or a pointer to x and similarly m percent y denotes the pointer to y
so that is what we are passing
so let us try to understand in terms of pictures comprising of boxes and arrows what exactly is going on in this particular example
so we have these when when when when main starts executing the space for these variables get created as we saw in the last lecture
so four variables get created r theta x and y and somewhere here r and theta are initialized let us assume that the value of r is 1 just for example and the value of theta is 5 by 2
now when this function is called polar to rectangular r theta m percent x m percent y what exactly happens as you know space will be created for the local variables and the parameters of the function which is being called the function being called is polar to rectangular which has four parameters but no local variables
so the space for these four parameters will be created r theta note that these r and this theta have nothing to do with the r and theta of main and then we have p x and p y
now these variables will be initialized by the values of these expressions which are being passed as arguments
so the the parameter r gets the value of the expression r in main which was 1
so this gets initialized to 1 similarly theta gets initialized to the value of theta in main which is 5 by 2
so this gets initialized to 5 by 2 what is p x get initialized to p x will get initialized to the value of this expression which is nothing but a pointer to x
so p x gets initialized to an arrow pointing towards the variable x of main and similarly the variable p y the parameter p y or the function polar to rectangular gets initialized to a pointer pointing towards the variable y of main
so this is what the picture looks like when the function polar to rectangular starts executing
now this assignment takes place
so right hand side is r into cos theta r is 1 theta is 5 by 2 and cos 5 by 2 is 0
so 1 into 0 is 0
so this entire thing evaluates to 0 and that gets assigned to star p x
now star p x refers to the variable to which p x points which is x
so the value 0 is actually written here and similarly next assignment computes the value of r sin theta
r sin theta will be 1 because sin 5 by 2 is 1 and that value gets written to the variable to which the parameter p y points and that is the variable y
so the value 1 gets written over here and then the function polar to rectangular returns
when the function polar to rectangular returns these variables get destroyed
the control goes back to main but when the control goes back to main note that the variables x and y have been modified to contain the rectangular equivalent of the polar coordinates r comma theta
so before we end this lecture today here is an exercise for you to utilize the concepts that we have seen so far
so should write a program that given a month name and an year the month name could be january february and so on and an year 1995 2005 whatever should print the calendar for that month and you should use the techniques that we have learnt so far that is divide the entire problem into sub problems that is identify the functions possibly identify global variables and then use either the top down or the bottom up approach and then start implementing the functions one by one and finally put them together as the main program to implement the entire solution
in today's lecture we will start talking about a very important concept in programming and that is the notion of arrays
these are very useful for storing and manipulating large volumes of data
so as an example to motivate the use of arrays let us consider the following two problems
the first problem is very simple you are required to read 10 integers and find their average
we know how we can do that we can write a simple loop and in each iteration of the loop we read them integer and add it to the sum and at the end of the loop we just simply divide the sum by the number of integers and that is the average
the important point is that in this algorithm we do not need to store all the integers that we have read at the same time what we need to remember or store is only the most essentially writing integer
now contrast that with this second problem where we are supposed to again read 10 integers find the average but now find out how many integers in the input were less than the average
now if you have to solve this problem we will have to first find the average as before but then we will have to look at each number again and compare it with the average to find out whether it is less than or equal to or more than the average and count the number of integers which are less than the average
this means that we cannot forget an integer soon after reading it we must remember this integer we must store its value in some variable so that later it can be retrieved
now without the use of arrays we could solve this problem by having maybe 10 integer variables but then the problem will be that will have difficulty in writing the loop because the variable name will change for every iteration of the loop
the arrays allow us to solve this problem very elegantly as we will see soon
so as we have seen an array is essentially mechanism that allows us to store and systematically manipulate large number of values
an array is what is known as a structured type in contrast
so as i mentioned arrays are a mechanism that allows us to store and systematically manipulate large number of values
so in contrast to the simple type that we have seen so far an array is a structured type that is an array is composed of values of simpler types and this is how we declare an array will soon see number of examples
here is the first what we have to write is the base type
the base type is the type of the individual elements of the array
an array is composed of a large number of individual elements which are of some type they have to be all of the same type
so this base type is the type of the elements of the array and then the next the variable name is the actual name of the variable that represents the array and then within the square brackets we have to mention how many elements of this base type will the array have
so the base type can be any type that we have seen so far the number of elements must be non negative integer constant that is the compiler at compile time must be able to figure out how much how many elements are there in the array and therefore how much space in memory is to be allocated for that array
so let us see some examples of array declarations
so here is the simplest example in here is the base type the name of the array or the variable name is number and 50 is the size of the array and this declaration essentially says that numbers is an array which will be comprising of 50 integers
there is another array so this time the array name is p number of elements is 20 and the type of each element is k
this shows that the base type can really be any type
this in this next example that base type is short and instead of giving the size as a literal constant we have used a symbolic constant which we define using this hash define which should be familiar to you already from earlier examples
so this size size of the array need not be literal constant but it has to be a constant value whose value can be determined by the compiler at compile time
here is the next example in this case we have declared the size of the array to be capital n where n is declared to be a constant in a different way
this style of declaring constants is also something that we have already seen and the base type in this example is unsigned log
here is an example in which the array declaration is invalid that is if we have generic declaration in the program and the compiler will give an error and the reason is that the size of the array has been declared to be n which is the name of a variable here
so this is not allowed because as i said the size of the array has to be a constant which is known at compile time
let us now talk about how we can access and manipulate the individual array elements
so if an array we have declared to have n elements then these array elements can be accessed as a 0 a 1 a 2 up to a and minus 1
so essentially the array element is accessed by giving the name of the array a for example and then within the square bracket the number or the index of the array element that we wish to access and if an array has n elements then the index will range from 0 to n minus 1
so we can have expressions like this which denote array element and such expressions can be used both on the left and the right sides of an assignment
here are some examples
so this assignment statement is assigning the value x minus y to the fifth array element
remember that the array element starts from the 0th element and go up to the n minus 1 element where n is the size of the array
in this second example the array element a j plus 2 occurs on the right side of the assignment and the other thing we should notice about this particular assignment is that the array index which is being used here is not a constant
it is j plus 2 where j could be any variable whose value will be known only at runtime
so only while declaring the array the size has to be declared as a constant but while accessing individual elements of the array the indices used can be arbitrary expressions which result in an integer
here is one more example showing how an array element can be read from the input
we are using the familiar scanf library function for doing that and the way we are doing that is very similar to the way we read a normal integer variable
when we read an integer variable we say scanf percent b m percent x
if we want to read in the value of the ira element then all we have to say is instead of m percent a x m percent a i
now it is very important in programs to be careful about the indices that we are using for the array elements
as i have mentioned earlier if the array has been declared to have n elements then the array is range from 0 to n minus 1 and it is very important to ensure that the array element that we are accessing has an index between 0 and n minus 1
so for example suppose we have declared an array to have 100 elements
what will happen if the array index used in a particular expression is less than 0 or more than 99
now answer is that in this case the results of the program execution will be unpredictable
we will not be able to say what will really happen this is an error because we are not allowed to use array indices less than 0 or more than 99 in this case where the array has 100 elements
but the c compiler does not check these kinds of errors and so what will happen at runtime is some unpredictable and unexpected behavior
therefore it is the programmer's responsibility to ensure that the array bounds are not validated and violation of array bounds actually is a very common problem in many programs
many programmers make the mistake of accessing array elements which do not exist and such errors do not necessarily always result in the program trash they can have other unexpected effects and so therefore and these errors are very hard to track down
therefore we need to be very very careful while dealing with arrays that the expression that you are using for an array index is within the bounds for the array
so now here is our first simple example program using an array and this is the problem that i mentioned earlier while motivating the use of arrays
you have to read 10 integers and find the number of integers that are smaller than the average
so we start the declaration of the variables
the variable sum is the one that will use to store the sum of all the integers that we read
numptem is the array which will use to store all the integers that we have read
recall that once we have computed the average by summing up all the integers and dividing by the number of integers we will need to once again look at each integer that we read and compare it with the average to find out whether it is less than the average or not
the variable count will be used to count the number of elements which finally turn out to be less than the average and the variable avg or standing for average will contain the average and this can in general not be an integer and so therefore we have used the float type to store the average
so this loop is as before so we are trying to read 10 integers and find their sum
so this for loop runs 10 times for values of i from 0 to 9 and each iteration of the loop we read the i's element of the array and also add it to the sum
after that once we have found out the sum the average is nothing but the sum divided by 10 but we have to be a little careful here because remember that the sum the variable sum is of type int and the literal constant 10 is also of type int which means that if we just divide sum by 10 we will get we will do an integer division which will mean that the fractional part of the result will be dropped and the final value that we get will always be an integer
so therefore to avoid that we are first type casting sum into a float so that one of the operands of the division is now a float and so automatically the other operand which is 10 will also be type cast to a float by the compiler before the division and the answer will retain both the integer and the fractional part of the result of the division and finally having found out the average this loop is being used to find out the number of elements in the array which are less than the average
note that we have again used the comma operator from the previous lecture to make two initializations in the for loop we are initializing count to 0 remember count is the number of elements that we that are found to be less than the average and i is also assigned to 0 this is the loop variable this will run from 0 to 9 when i become equal to 10 the loop will terminate
so within each iteration of the loop if the i have element that we write all the i have integers that we write is less than the average we add 1 to the count and note again that this entire statement is a single if statement and therefore we do not need it need braces around it to make it the body of the for loop and finally this statement is outside the for loop this will be executed once the for loop finishes and this is simply prints the value of the variable count which is nothing but the number of integers that have been found to be less than the average
next we come to array initialization as you know when we declare variables we can initialize them with the value at the same time the same thing can be done with arrays as well and array initialization is quite simple all we have to do is that the element values of the array in the order of their indices have to be placed in braces and they have to be separated by commands
so we will see an example of the use of such kind of an array initialization suppose we are writing a program that finds the day of the week for a given date
so what we need to do probably is to store the number of days in each month in an array and since these are constant values we can initialize this array right at the time of declaration
so our program might look something like this
so we define symbolic constants for the various months from january to december january is defined as 1 and december is defined as 12
the number of months is of course 12 and then we have this array month days which stores the number of days for each month
now we want to refer to january month january with the index 1 in this array let us say we could of course also have used 0 for january and 11 for the summer and so on but that might have become a little unintuitive
so what we call that when we declare an array to be of size n and its indices range from 0 to n minus 1 and not from 1 to n and since we need indices from 1 to 12 in the array we will need to make the array size 1 larger than the number of months and so therefore the array size is number of months plus 1 which is of course 13
so that means that the array has elements at indices 0 to 12
the index the element at the index 0 will not be used so we are assigning it a value 0 and the rest are the number of days in the various months from january to december ignoring of course leap years
so as you can see these array values initial values of the array elements have been placed in the order of the array indices and they have been separated by commerce and they have been enclosed in these curlibe so this is how we can initialize an array
next we come to higher level arrays or 2 dimension or higher dimension arrays these are very useful for manipulating structures like matrices and so on so forth
so as an example this is a very common engineering problem suppose you want to solve a set of n simultaneous linear equations and n variables then we need to store the coefficients occurring in the n equations
so these can be easily stored in mathematics we represent them as an n cross and matrix so in c they can be easily stored as a 2 dimension matrix or a 2 dimensional array and the solution vector can be stored as a 1 dimension array as usual
so let us see how we can declare and use 2 dimensional array
so conceptually 2 dimensional array is just like a matrix or a table with a certain number of rows and a certain number of columns and 1 value at each cell of the table or the matrix
so when we declare an array of 2 dimensions or indeed for higher dimension again what we need to is to specify the base type of the array elements the name of the array in this case matrix the base type in this example is int is int and then we have to give the number of rows and the number of columns both in square brackets one after the other the first is the number of rows and the second one is the number of columns
again the number of rows and number of columns again have to be constant whose values can be determined at compile time
so in this example the number of rows in this matrix is m and the number of columns in this matrix is n and while accessing array elements of a 2d array we have to specify the indices for both the dimensions
so just like a matrix element is referred to as a ij if a is declared as a 2 dimensional array then we have to access its array elements as a ij in this particular notation
so we have to give both the indices for the 2 dimensions and in the first dimension the value of the index again should range from 0 to the size of that dimension and this is true for all dimensions
so the value of j in this example assuming the previous declaration where the number of rows was m and the number of columns was n the value of i should be between 0 and m minus 1 and the value of j must be between 0 and n minus 1
so the indices range from 0 to n minus 1 where n is the size of that particular dimension
so here are some examples of usage of array elements a ij assigned size
so again an expression denoting an array element can occur on the left inside or on the right inside
so this is initializing the ijth element of the array a to the value 5 and here the jth ijth element of the array a is being assigned to the value of the ijth element of another 2d array b
so this is simple enough let us now look at an example program using 2 dimensional arrays
so let us take a familiar problem from matrices
suppose the problem is to read in take as input a square matrix from the user of size at most 10 by 10 that is the matrix that the user gives may be smaller than 10 by 10 but it cannot be larger than 10 by 10 and this limit has to be placed because recall that when we declare an array we have to declare the size of the array and so if it is declare the size of the array to be 10 we cannot store more than 10 elements in that array
so that is why we are saying that the matrix that we read from the user should be of size at most 10 by 10 where suppose to compute the transpose of the matrix and print the transpose matrix
so let us start developing this program this is the beginning part we define a symbolic constant representing the maximum size of any dimension of the array and here are the variable declarations and is the actual matrix size that we are going to read from the user
this remember may be less than 10 but cannot be more than 10
this a is the 2 dimensional array that we are declaring note that the size of both dimensions is max size which happens to be 10 i and j and t will use as temporary variables for looping and other purposes and so on
okay so the first part is simple enough the first we have to read the matrix from the user and for doing that let us first ask the user for the matrix size we have to ask only the size in one dimension because we are assuming that it is always a square matrix that we are reading
so this should be familiar this do while loop should be familiar to you from the last lecture and we are using this to continuously prompt the user for entering the size of the matrix till he gives an appropriate size and the appropriate size for a matrix will be something which is at least one and at most max size
so as long as the value of n is less than one or greater than max size which is 10 we keep giving this prompt to the user to enter the matrix size and reading the value of n
so finally when we reach here we have read the matrix size n and it is known it is guaranteed to be between one and 10 and finally we have to read a matrix
so for reading a matrix we have to read each element a ij of the matrix in the usual matrix notation we write rows we write the matrix row y and so therefore we will expect the input in the same fashion and so for doing that we have used two nested for loops here
the first pair loop runs from i is equal to 0 to n minus 1
note that n is the actual size of the matrix so the number of rows is n and number of columns is also n and so the row indices will use will be from 0 to n minus 1 and the column indices that will use will also be from 0 to n minus 1 and this kind of a nested loop structure is very common for manipulating structures like matrices because this allows us to individually process each element of the matrix 1 by 1
so this outer loop runs for every row of the matrix and for every row this inner loop accesses elements in every column of the matrix and together these loops will ensure that we access and process each element of the matrix 1 by 1 in the row order and for each element of the matrix right now all we need to do is to read it value so we use a scan of statement to read the value of the matrix
let us before writing the program further let us think a little bit about how we are going to transpose the matrix so let us assume we have a matrix looking something like this
the transpose of the matrix is the matrix which has the rows and columns interchange so the transpose of this matrix will be this matrix so the question is how are we going to convert this array into this array
one simple answer could be that we use another array variable of the same size and assign values in the various elements of this array such that the value at a particular element is the value of the element at the mirror image with respect to the diagonal offset element in the original array that is this value should be placed at this position in the final thing
so that means that if this new array is called b and the original array was called a then we should set b ij to aj i
so that is one way of doing this but suppose we want to do it in different fashion and we want to transform the original matrix itself so that it becomes a transpose of itself then we need to do something different let me write the matrix again and let us write the transpose again to
so let us look at these two matrices if you note the diagonal remains the same in the transpose and if you take any element other than the diagonal then that gets interchanged with the mirror image of that element on the other side of the diagonal
so we had 6 and 8 here and we have 8 and 6 here
so that means what we need to do is that for all elements on one side of the diagonal let us say this triangle or this triangle the lower triangle or the upper triangle for each element in let us say the lower triangle suppose we strapped with the corresponding element in the upper triangle that is aij is strapped with aji
if that happens let say for this and this this will become 4 and this will become 2 and similarly this will become 3 this will become 7 this will become 8 and this will become 6
so what we need to do for implementing this algorithm is to write a loop which excesses all elements in the lower triangle of the matrix and for each element in the slower triangle it straps it with the mirror image of that element in the upper triangle or upper triangle of the matrix the elements on the diagonal need not be modified at all because they remain at their original positions in the final matrix and the one final thing that we need to do is to find out how we strapped 2 array elements and the procedure for that is very simple suppose you have to strapped 2 variable values of 2 variables x and y then clearly strapping like this will not really work this will not work because let say x at the value 5 and y at the value 7 when x is assigned the value y it becomes 7 and the original value of x is lost
so when we do when we do the assignment y assigned x the value of y remains 7 instead of doing this what we need to do is to take a temporary variable and before we assign to x the value of y we have to store the old value of x into the variable t
so this is what it could look like so when we do this let us see what happens when t is assigned x the value of t becomes 5 this example and then x is assigned y so x becomes 7 but we have not lost the original value of x because it is still available in t and so the value of y is changed to the value of t which now becomes 5 and the same procedure can be used for swiping the array elements
so having understood this let us go on and see how we can write the program for implementing this algorithm
so coming back to the program having read the matrix let us not transpose this
so we have loop here and you will notice that it is slightly different loop the first outer loop is the same as before for i from 0 to n minus 1 so this will run once for every row in the matrix but for every column in the matrix we want to access only the elements in the lower triangle of the matrix
so the array elements in that row that should be accessed are the ones which lie before the diagonal and the diagonal element in the row i is at column i so therefore we should only access array elements at columns 0 to i minus 1 and so therefore you can see that this loop runs from 0 to i minus 1 it terminates when j becomes equal to i
so for each element in the row before the diagonal we have to swap a i j with a j i so we use the swiping technique that we just saw p assigned a i j a i j assigned a j i a j i assigned t
so this swap the i s j element with the j s i s element and that the end of the loop
note that the inner loop has three simple statements body and so therefore they have been clubbed into a compound statement using these curly braces as far as the outer loop is concerned the body consists of this single four statement and therefore the braces are not required
so finally when the loop ends it is time to print the transpose matrix and we just print the matrix row wise so for each row we print all the elements one by one so this loop will print all the elements in the ith row one by one note that after the percent there is a blank space so that after printing one there is a blank space left in the output and then the next element is printed and so on and after this entire loop has finished so the first row in the transpose matrix has been printed
so let us say that was one two three and then after that we want to start printing the next row on the next line note also that there was no backslash n in the format string of the first print f so that will ensure that all these three values or all the n values of the same row are printed on the same line with the blank in between but at the end of the row we want to go to the next line so that the next row is printed on the next line in the familiar matrix notation therefore once this row has been printed using this inner for loop the print one new line character using the familiar put care function and note that now for the outer loop in the body there are two statements one is this four statement and one is this statement calling the library put curve function and so therefore we have enclosed these statements in braces for the outer loop and that is the end of the program
okay let us now see how two dimensional arrays can be initialized that is again very simple a two dimensional array is essentially considered to be an array of one dimensional arrays that is if we have an array of size two cross three it is considered to be an array of two arrays of three integers each and so it can be initialized like that so we have to give the value of each row which itself is an array within the curly braces so this is row zero and this is row one within row zero this is the element at column zero column one and column two and so on so forth so this is fairly straight forward
next let us quickly see how we can use arrays with dimensions higher than two or more than two and the ideas are very similar to what we have already seen for two dimensional arrays the natural generalization hold so we can declare and use arrays with any number of dimensions in very similar ways to what we have already seen for example a 3d array could be initial could be declared like this giving the sizes on all the three dimensions and when we access an element of the array we again have to give the indices at all the three array dimensions
so this is the end of today's lecture in the next lecture we will be talking about some special kinds of arrays which are known as strings and which are very useful in manipulating data which are which comprises of text rather than numbers so we will look at strings in the next lecture
you you you you you you you
welcome back in the last lecture we had talked about the notion of an algorithm and i showed you how to write the algorithm for a simple problem in due to compute the factorial of a given number
in this lecture i will try to familiarize you with the basic use of the computer
so you can start working with the compute right away and whatever we learn in the class you can put that to practical use
but before we start with today's lecture let me once again talk a little bit about class lecture success size
so if you recall last lecture success was to compute the quotient in the remainder when x is divided by y assuming that only addition and subtraction are available as primitive arithmetic operations
so how do we go about doing this
 well we need to use the properties of the quotient in the remainder and as you know if q and r are the quotient in the remainder respectively obtained after dividing x by y then these two properties are satisfied that q times y plus r is equal to x and secondly r is just and y
so how do we use this property is to come up with an algorithm to compute q and r given x and y
well the idea is pretty simple
we keep subtracting y from x repeatedly till we end up with a number which is smaller than y and once we do that then the final number that we are left with is nothing but the remainder r that we are looking for and what is the quotient
 the quotient is the number of times that we have subtracted y from x
so here is a solution to this problem
so as before we read the values of x and y and the variable q is going to denote the quotient which will essentially count the number of times we are going to subtract y from x till x becomes less than y
so we initialize value of q to 0 and as long as x is greater than equal to y we perform these two steps and meet step we subtract y from x
so x becomes x minus y note that we have seen the notation slightly from the last lecture and we are now using a more concise notation
the left arrow here indicates an assignment which means that the value of the variable x is being changed
so the left hand side of the arrow denotes a variable whose value is being changed and the right hand side denotes the new value that this variable is going to have
so this statement 31 should be read as x assigned x minus y and which means that the new value of x is set to the old value of x minus the value of y
and similarly since we have subtracted y from x 1 we add 1 to q remember that q counts the number of times that we subtract y from x and finally after some time since x is decreasing in every step ultimately x will become less than y and at that time we stop executing step number 3 and we come to step 4 which is to print the result the remainder is x remember that every time we have subtracted y from x we have told the result back in x
so finally x becomes less than y and it is the remainder and the quotient of course is the number of times we have subtracted y from x which is nothing but q
so coming back to today's lecture as i said today i will familiarize you with the basic working and use of a computer so that we can start using the computer to write programs and to execute those programs
in this lecture series we will be using the linux operating environment
there are several operating systems available for computers as you might have heard of for example windows linux and solaris etcetera
now operating environment essentially consists of an operating system and number of application programs
an operating system is a program that manages the computer resources and all application programs run under the control of this software
so inside there are several operating systems like windows linux and solaris will be using linux for all demonstrations in this particular lecture series
application programs are useful programs that make it easier and convenient for us to use and program the computer
we will see a number of application programs and see how to use them
let me first introduce you to the various parts of the computer
this is what is known as the cpu box which contains the drains of the computer and the memory and so on will be talking in a little bit more detail about what this contains
this is a keyboard which as you can see contains keys for various things including which we can type information into the computer and this is what is known as the mouse
this computer is like the different from what you will probably see in your lab
this is a laptop computer
another thing that you will find in your lab will be monitor attached to the computer
so this computer trying to this monitor is attached and you can see the output of the computer
so let us first familiarize ourselves with the keyboard
this is what the keyboard looks like
as you can see that the main area of the keyboard has keys corresponding to the various english alphabet and then we have these number keys at the top
using these english alphabet keys of course you can type whatever english words we like
now that these keys can be used to type lowercase as well as uppercase english character
so if i have to type statuses the small g and if i have to type capital g i have to first press the shift key like this keep it press and then press the g key and then release the shift key
this is the control key
the control key is used to type special characters
for example sometimes we might ask you to type control c
what that means is press control press c and then release both of them one by one
this is the capital of key and if it press h then what this means is that whichever english character we know type will now appear in upper case instead of in lowercase and if it press h again the capital of mode is now switched off
these are the number keys
on top of the numbers we also have certain special symbols printed on the keys
so if i just press this key correctly then the number 5 will appear whereas if i want to get the character first and then again i have to press h and then press this key and then release them one by one
this is the back space key
this is also a very important key
if you want to erase something that you have typed previously for us incorrectly then we just press this and whatever we have typed is erased
this is another important key
this is called the enter key
usually most of the time when we type a line of text we have to then press enter to say that we whatever we are typing now will appear on the next line
the rest of the keys are not very important at the time linked
we will talk about them whenever we need to
okay and this is the mouse and if i move this around you can see this little arrow moving on the screen
this little arrow is called the pointer and using this mouse i can move this pointer anywhere that i like
also on this mouse you can see these two buttons which are called as the left button and the right button
most of the time the left button will be used whereas occasionally the right button might be used
okay so let us now start using the computer
the first screen that we are seeing over here is what is known as the login screen
so here we have supposed to identify ourselves through the system and this identification consists of two parts
the first part is a user name which is signed to us by the system administrator of this computer
so my login name or the user name is ed on this computer
so i move the mouse and make the pointer appear in this small window where i am supposed to type the user name
i click here with the left button so that my whatever i type on the key goes now we will go here and i type my user name which is bg and after doing that i have to press enter
now the computer is requesting me for a password
this password is a secret combination of characters that i alone am supposed to know and if i type this sequence of characters correctly then the computer will be ensured that it is indeed the user dg who is trying to use this computer and if i type this password incorrectly okay let me type some arbitrary password
so as you can see it says that the user name or the password is incorrect
let me now correctly login
my user name again is bg
this what i am typing now is my secret password and you can notice that the password is not appearing on the screen
so for obvious reason that if somebody is watching over your shoulder your password should not be revealed
so after typing my password once again i just press enter key and the computer is now logging main and this is the initial screen that you are going to see
so once this login process is complete this is what we get
this entire area is what is known as a desktop
so think of it as the desktop on your physical desk on which you can place some pieces of paper
you do not have any pieces of paper on this desktop yet but we will soon have them
these little pictures are called icons and these are short-cuts to starting some useful applications
so let's start some application programs running
so for example let's first get a calculator program
let me start another program
we can actually run more than one program at the same time
so let's start a game of chess
so think of these two what are known as windows as pieces of paper on your desk and just like on your desk you can move these windows around on your desk and you can choose which paper should be on the top and so on
so for example if we now want the chess window to be on top all we have to do is take the pointer to the title bar
this is the title bar of this window at the top and flip the left mouse button here
so the chess window now comes on the top
similarly if i now want the calculator window on the top this is what i have to do
i can move these windows around just like moving papers around on my real desk
so if i want to move this calculator a little bit to the right what i need to do is to take my pointer again to the title bar of this window
press the left mouse button and keep it pressed like this and how move the mouse while holding the left mouse button down and then the window is in the desired position
i just release the mouse button and the window has this pair and i can do a similar thing with this chess window for example
i can also change the sizes of these windows in most cases
so for example if i want to make this calculator window a little bigger i bring my pointer to the edge of this window and as you can see the pointer shape has changed here and now i again press the left mouse button keep it pressed and move the mouse like this and you can see the calculator window becoming larger and smaller
another thing that we can do with these windows is to minimize them and that means putting them away will be really need to use them again
so if you see this small button in the title bar for minimization of this window if you just click the left mouse button here then this window has been minimized and you can see that it has come here and if you just click this again it will come back similarly we can minimize it
so in terms of real depth we can choose to put away some of the paper still be actually need to use them
also and many of these applications you will find things like these which are menu buttons
so if you click your mouse button on any of these you will see a menu of actions that you can choose from for example this recesses the game of session or this using this memory you can choose whether the machine plays white or the machine plays black now the machine has playing the white and we are using the mouse again to make our moves in this game of chess
the next important concept that we need to understand is that of files and directories this is very fundamental to a computer because any piece of information that you wish to store in a computer is stored in a file and every file has a name
so you can think of a file as being a piece of paper on which you can write something and using programs we can create files and put whatever content that you want to place in those files these programs are called text editors using these programs you can also change the contents of a particular file so see the use of a text editor that you later on today
directors are also a very important concept to understand files are organized into directory so you can think of directory as a folder in which you can place several papers
the only difference here from normal physical folder is that it is very common to actually place folders inside folders
so you have a hierarchical directory structure where you have a directory in which you have some files and some sub directory which also may contain some other files and then some more sub directory and so on so forth
so let us look at the physical directory structure in a unique machine
all these things are folder this folder is called the root directory this is a special directory because this is where the hierarchy of files begin
everything else is contained directly or indirectly within this root directory
so in this example within this root directory there are three sub directory or sub folders within the same folder which are called home etc and bin
so name of the root directory you can see is always flash this is a flash collector and the names of these folders are then flash home flash etc flash bin and this flash in the beginning of the name signifies that this folder is contained within the flash folder which of course is the root directory
so this folder home in this example contains a retaminser folder which is called dg and therefore the complete path starting from the root directory to this folder is flash home flash dg
so the flash character separates the various components of a path and the path is nothing but a sequence of names of folders within which using which the folder or the files can be accessed and in this example this particular folder contains a file which is called letter and therefore the path to this file is flash home flash dg flash letter and another folder which is called my folder and therefore the path to this folder is flash home flash dg flash my folder
and in this entire directory structure every user is assigned a part of the directory structure within which he or she can create his or her own file
this is called the user home directory
every user has a system assigned home directory and the user can create any file for the directory within this directory but not elsewhere
so in the previous picture this directory is the home directory of the user dg and within this i can create any files and subfolders that i wish to create
so this part of the directory tree belongs to me in some sense and at any point in sign while the user is working he is working in some current directory and we can actually change what the directory we are working in at any given point in time
just after we log in the home directory is also the current directory that is just after the log in the current directory is nothing but the user's home directory
so in my particular example just after i log in the current directory would be flash home flash dg and as i show you slightly later on we can easily change what the current directory is and therefore it is useful to be able to refer to files not just with reference to its entire path starting from the root directory but also it is convenient to refer to files by their relative path starting from the current directory
the absolute path is a unit is unit to a file and it is a full path starting with flash whereas the relative path is the path for the file relative to the current directory and this will change depending on what the user's current directory at that particular moment happens to be
so for the same file the relative path will be different depending on the current directory and we will see some examples very soon and within the path there are these two special components called dot and dot dot which refer to the current directory and the parent directory of the current directory in the directory tree respectively
so let's see some examples
so this is the same directory structure as before we are assuming in this example that flash home flash dg which as i said is my home directory on this computer is also the current directory and this particular point in time
so these paths in the brackets are the relative path relative to the current directory flash home flash dg
so the path for the current directory itself relative path would be just dot as we said dot is used to refer to the current directory itself and the relative path for this directory namely flash home would be dot dot because as i said dot dot is used to refer to the parent directory of the current directory and similarly the relative path for the root directory would be dot dot flash dot dot because it is the parent of the parent of the current directory and similarly now the etc directory this particular folder can be referred also as dot dot slash dot slash etc because this is within the root directory which has the actual relative path dot dot slash dot dot and therefore the relative path of this folder become dot dot slash dot slash etc and if you look at these two files and folders in my own home directory so relative path for this the actual path for this particular file remember is flash home flash dg flash letter
so the relative path becomes either just letter or dot slash letter because remember again that dot is used to refer to the current directory we do not need to actually use dot here we can just say letter if we do that then because the path is not starting with the flash it is assumed to refer to the it is assumed to be a relative path and similarly relative path for this folder would be either nice folder or dot slash my folder
let us now look at some of the units commands that you will find helpful to build with files and directory for doing that we need to first start a unique command window so this is how i will start it on this computer it may be a little different on your own machine in the lab so in this menu go to system tools and within this sub menu click at the node that every time i am clicking left mouse button so this brings up a command window in which i can type command first command that you are going to see is very important that is the command to change your password the change of password the command is simply pass some duty this will ask you for the current password in order to ensure that this is not somebody who is using your terminal while you are a puppy and once you are correctly given your current unique password it asks for the new password so let me type some new password i have to type it again to ensure that i haven't made any mistake so i did make some mistakes that time let me try it again okay so the password has been changed successfully having done that let's try out our new password so let's first log out of the system tell the system that you are no longer using it and then log in again for doing that let's first close this command window into close any window we just need to click with the left mouse button on this cross which appears in the title bar of every window so log out will use this menu which you have used earlier so i click here and here is the log out option so i click on this it's asking me to confirm that i really wish to log out so i click here and the system has logged me out and as you can see now we are again back to the login frame and this time when we log in we will have to use our new password so this time i type new password and we have successfully log in so let's start the command window once again system tools terminal we have the command window back the first command that we will look at is called the phwd command which stands phwd stands for print working directory and this shows what our current directory is so as we start off the login the current directory is the same as the user's home directory since my home directory is slash home strategy that's my current directory as well and this is what the output of the phwd command is more that after typing the command i have to press enter let's now see some more command using the cd command which in change the directory and after separated with length you have to specify which directory we need to go to and here we have to give the path of a directory which can be either an absolute path or a relative path let's just go to the root directory which means that i can use the absolute path slash and now we have want the root directory the next command that i remember show is the ls command ls stands for directory listing so this shows the list of files present in the current directory so in the current directory remember is the root directory and these are the files or directories present in the root directory we want to see more details about these will use the ls minus l command note that the ls the words ls and minus l are separated by a blank so it is enter again and we see more details about each of these let's look at some of these details closely this first character for each line says whether this is a directory or a regular file so this game happens to be directly because the first character is d and as a matter of fact in this particular directory in the root directory all the sub files are actually directories so let's try pwd again pwd again shows us slash as the current directory because we have changed into that now if of course we have seen name of the directory and this we have to date at which it was last modified let's let's let me now go back to our home directory which always will take me to the home directory so pwd here shows home strategy again let us try an ls minus l command here the ls minus l command here shows that within this directory slash home strategy there is a directory called ssop because there is a d here and there is a file called tscchd this gives a date at which this file was last modified and this gives the number of characters present in the file we can see what this file contains by using the cat command so again for the cat command i have to give as argument to the command the path to the file and since the file pwdchd happens to be in the current directory we can directly use the relative path which would be simply cscchd and this is what are the contents of the file let's now use a text editor to create a new text file and see how we can change the contents of an existing text file or create a new text file so one of the text editor programs available in the line is called t-added and as an option to this as an argument to this command i have to give the file name that i want to create so let me name the new file that we are going to create as rydchd so the command is here again blank rydchd and this is the text editor window now and i can type here so for example i have type this is a new text file that we are creating if i now want the next words to appear on the next line all i have to do is press enter and as you can see this blinking cursor has come to the next line whatever i type here will now go on the next line so i want to edit something if i have made a mistake in what i just said i can of course use the back space key to erase what i have just done and if i want to change something in text long time back i for example if i want to change this a with the then what i can do is take the pointer here click here this half to be a so the cursor has now come here now press back space and start typing the new text that i want to enter we can also do more interesting things for example we can create we can tag regions of the text and delete them and mask for example if i want to delete the world text here of course i could take the cursor here and press black say four times to delete the entire world but i could also select this entire world and to select this i have to first bring the cursor just before this world and then to select this world what i do is press the left mouse button keep it fresh and drag it a little bit towards the right till the entire world is selected or whatever text i want to select has been highlighted now once the world text file has been highlighted i can press black space so the entire two words will go away and i can replace it with something else for example letter or i could do more interesting things such as if i want to make copy of this engine i can select this entire sentence like this and then usually copy command there is a shortcut to the copy command on this menu so this letter icon says for copy so when i say copy the selected text is copied it does not appear anywhere on the screen but if i now say take then this whatever has been copied will appear wherever the cursor happens to be so this is the icon for the for paste if i press this is what i get okay let me now change this little bit again okay suppose we want to interchange the order of these two lines what do we need to do well let me first select this and then instead of copying this entire line i will touch this entire line using this silver light picture over here so i touch this so this disappears and it has also been copied in some internal space now if i bring my cursor here i can also use the arrow keys to move the cursor around as you just saw so i create a blank line here and if i paste now then the original selection that we have set appears over here now we would after typically creating the contents of the file once we are satisfied with the content we would typically want to save the file what saving means is that so far what we have been doing in this editor window has not actually been written to the file on the system so if we wanted to be actually written to the file on the system we have to first save the contents of the editor window for the file and to save the file all we need to do is to click this small copy disk like image and this the file has been written you can see here wrote try to text now we can close this editor window and try to see what contents has been written in this file so using the old command chat you can see the contents of this file this says this is the new text file that we are creating this is the new letter that we are creating this is precisely what we had entered in this text file so as you can see using this editor program we can create whatever text document that we want to create and in particular we will see that if program is also a text document and will use the same program to actually write new program that we develop ourselves that also now try to edit an existing file again so let's just edit this file try it or take once again and as you can see the old contents have come back i can now change whatever i like to make whatever changes i like to make save it close this window and changes have taken effect okay another thing that you would like to do is to organize our files that we create into folder and therefore we need to be able to create new folder and the command to do that is encoder so i can create a new folder within this current directory itself so using this command encoder i am saying that i want to create a new folder whose name will be new folder and now if i look at the directory contents you can see that the new folder has been created i can now change directory into this folder and if i want i can create some files lf shows nothing here because there is no files in this folder yet i can use the editor command as before to create some files here we can also make more copies of an existing file and do that we have to use the cc command cp stands for copy and this time we have to give it to argument the first argument is the part to an existing file which you want to copy somewhere else so let's copy the trycxt file that we just created and since this is in the parent directory of the current directory remember that the current directory is slash home slash eg slash new folder whereas the file that we created was in slash home slash eg so the relative path to this file would be dot dot slash trycxt and the second argument is where we want to copy this so we want to copy this to the current directory and to refer to that we can just use dot as a side earlier and this copies the file to the current directory let's have a look using the alice-alpha- so as you can see in the directory new folder there is a file trycxt and the contents are the same as what we are in the original trycxt and in the parent directory which is my home directory also there is a file trycxt with the same contents
we can also move files from one place to another for example if we want to move this file pscx to the new folder that is just created we use the process similar to what we used for hopping files but this time you will see mv command which stands for move we can use to move file to another directory we can also use it to assign a different name to an existing file so suppose we move it to the new folder as you can see the file is no longer in this folder and if we go to new folder the file has appeared here we can also use the move command to actually change the name of the file so if i use this command the name of the file is changed to xyzcxt
so here is a summary of the unique commands that we have seen today the passable disk command is used to change your password the alice command is used to list the files in directory the cd command is used to change the parent directory the pwd command is used to print ctern directory or the working directory the cat command is used to display the contents of the file the key edit command is used to create or edit the contents of the file the cp command is used to copy a file and the mv command is used to move a file
so in today's lecture we have familiarized ourselves about using a computer the notion of files and directories how to create files and directories to edit files and so on so forth and as an exercise for today please try all the things that we have seen here today in the lecture in your lab or at home using your own computer from the next time onwards we will actually start writing some programs
in the last lecture we had talked more about functions than we had introduced motion of scope and left time and we had talked about global variables etcetera
and finally i have left i had left you with a problem to think about and that problem was to write a program to find a path through the maze
i hope you spend some time thinking about the problem
so let us just review the problem once again
we want to write a program to find a path through the maze
the maze is represented as a grid of characters a two dimensional grid of characters a star in the grid represents a part of the wall where one cannot go and a blank space represents an open space where movement is possible
and an entry point into the maze is given by the user as an x comma y value and remember that we had said that if there is any other exit in the maze then the path should take one from the entry point to some other exit in the maze
and if there is no other exit in the maze then the path should bring one back outside the maze through the same entry point
and this member walls our representation of the maze on the x y plate the star represents walls and the blanks represent open spaces and assuming this is the entry point this is the path that the program should tell us to take
so in terms of the coordinate system this path turns out to be this
now this problem might look to be complicated but as it turns out it has a very simple algorithm to solve this problem
i will give you the algorithm but and i will leave you to convince yourself that this algorithm works in all cases
so the algorithm is very very simple
so we started the entry point and as long as we are not outside the maze that is as long as we are somewhere within the maze we do the following
so this entire thing is one step in the path
so we have to maintain a current sense of direction the direction could be not south east or west
the first thing you do at any place in the maze you turn right and then if you are facing a wall turn left if you are still facing a wall turn left again if you are still facing a wall turn left again and so on
so as long as you are facing a wall keep turning left
note that you cannot turn left more than four times because then you will be facing in the original direction
and if you had come to a particular point from some direction then there is at least one way to move from the current point which is to go back in the direction from which we had come
so when this loop terminates then step forward in the current direction
so essentially while we are turning the direction is changing
now the reason this algorithm really works is that by trying this we are trying all possible four directions and seeing which way we can go
but we are trying these four directions in a certain order
so if we reach a dead end and then this loop will make sure that we turn back and come back to some place which we had visited earlier
and then later on we will not go back to a path that we have already visited once
that is because when we come back to the same place we will be facing in the reverse direction as compared to the direction in which we were facing when we visited this particular place the first time
so this is of course very intuitive explanation of why the algorithm works
i would like to encourage you to take some examples and see for yourself that the algorithm indeed works
and the nice thing about the algorithm is that if there is no path in the maze from the entry point to some other exit point then it will plot a path which brings you back to the original entry point
so the algorithm straightforward enough
now we have to focus our attention on how to implement this algorithm as a program
and the first thing that we have to worry about for implementing this as a program is how we are going to represent a maze
so the obvious answer to that is that we represent the maze as a two dimensional array of characters
because it is a two dimensional create and each character in the array at any id
location would either be a star character which represents a wall or a blank character which represents an open space
so maze x y suppose maze is the name of the array would represent the maze character at position x y
now since we will also finally go outside the maze and at other places we will check whether we are facing a wall or not
now when we are checking whether we are facing a wall or not we are going to be at we may be at the edge of the maze and the direction we are facing is outside the maze
so if you have to check that the character facing us is a wall or an open space we have to make sure that we do not violate array bounds
remember that it is very important that when we access an array element the index or the indexes that we specify for the array element are within the bounds of the array
so we have to make sure that even when we are outside the maze or when we are on the edge of the maze and we are checking and we are facing outside the maze and we are checking whether we are facing a wall or not we have to ensure that we never violate the array bounds and to make sure that we never do that what we are going to do is to create an open path all around the maze
so let us say the user gives us a maze of size 5 by 5 what we are going to do is to convert that maze into a maze of size 7 by 7 and in the center of this size 5 by 5 maze the original maze is even by the user is placed and all around it on all four directions there is an open path
so let me show you what i mean
so let us say this is the maze that the user has given us
i have instead of putting blank characters i have put the dash character just to show you that these characters exist
now around this maze we are going to put a one character thick open path
so this path we have created outside the maze on all four directions
so the idea is that even if from this point we come out here and we are at this location the x and y positions are still within the bounds of the array and similarly for example if we are here and we are facing towards the south assuming that downwards is south and we want to check whether we are facing a wall or not then we will have to check this character in the maze
now if the maze is if the array is only till here then this index would be outside the bounds of the array and we will have to we will have to put special checks to ensure that we do not wallet the array bounds by putting an extra path all around the maze we avoid those kinds of complications
so the next result is that the size that will declare for the maze will be 2 more than the actual maximum size that we want to permit
let us now try to develop a program for this but let us first look at a design for this problem this is a reasonably complicated problem
so here is a possible what is known as functional decomposition of the problem that is we can identify these distinct and independent subproblems and so what we will do is to define functions for each of these and then put together these functions and use these functions in the main program to solve the overall problem
so the first function is read maze which will read the maze from the user
the second function will be read starting position which will read the starting or the entry point of the user
note that we need to make these into functions because even though the complexity even though the functionality of these functions might appear simple it is actually little bit more complex because we want to make sure that the input given by the user is always consistent and it is not invalid and so on so forth and so as you will see we need to make a large number of checks on the user supplied inputs and that is why we prefer to make these into independent functions
the next function is outside maze which will just tell us whether we are currently outside the maze or within the maze and you can see that this function would essentially check whether our current position is on that border around the maze that is somewhere on that border around the maze that we are created
so if it is on the border then we are outside the actual maze otherwise we are inside it
the next function is facing wall which will tell us whether we are currently in the current direction what we are facing is a wall or not
so if we are facing a wall we cannot move ahead and then functions turn left and turn right which will change our direction appropriately
the step forward function will move one step ahead in the current direction and that will change the current position that we are at in the maze and finally the function print position will use to simply print one position in the path
so at each step in the path will print the current position
so we need to write all these functions and as you can see that most of these functions are going to use number of large amount of common information
so all of those will define as global variable
so these are the global variable so you do not need the maze itself which is going to be as we said a two dimensional array
then the actual size of the maze as opposed from the as opposed to the maximum size of the maze that we can accept
so in the size x will be the actual size of the maze in the x direction and size y will be the actual size of the maze in the y direction and the power x power y is the current position within the maze at what point we are within the maze at any given step and finally direction is the direction that we are facing at the current moment which could be not south east or west
so let us now put together these ideas in the form of a program and using bottom approach let us develop these functions one by one and then finally put these together into an overall program
so let us now look at the program for solving this maze problem
so we start with some constant in global variable declarations
so this max maze size is a constant which says what is the maximum size of the maze that the user can give
so this is in the x direction as well as the y direction
so we have defined this two have the value 20 meaning that the maximum maze size can be 20 by 20 and then we have defined these four constants for the four directions north west south and east
they could have been different to any numbers as long as they are distinct numbers
these are the global variables that we had already identified for the program
the maze is a two dimensional area of characters of size max maze size plus 2 into max maze size plus 2
the direction is the current we are facing which will be one of north west south and east
pause x and pause y are the coordinates of the current position within the maze and size x size y are the actual maze size in the x and the y directions
so let us now look at the function read maze that is the first function
so first ask the user to enter the maze size and read the sizes in the two directions size x and size y
note that we store the return value of scan f in the local variable r and now we need to check whether the user supplied input for the maze sizes is correct or not
so if the value of r is not equal to 2 that means he did not really enter two integers and therefore the next message should be printed or if the x size or the y size is more than next maze size then the size x specified for the maze is 2 large and we cannot handle that
so again we should give an error message or if the maze size in either direction is 2 small less maze of size less than 2 does not really make sense then also we should print an error message
so in any of these circumstances we print this error message that the maze size that was entered was invalid and then we use the library function exit here
now this is a function that we are seeing for the first time
so this exit function is a library function which causes the program execution to terminate immediately
note that this is different from the return statement in that the return statement causes the currently executing function to immediately return but calling the exit function causes the entire program to terminate immediately
the argument to the exit function is an integer which we have specified as one here
so this argument to the exit function is a kind of exit status of the program and usually the convention is that if the program terminates successfully then it should exit within exit status of 0 otherwise if it terminates due to some kind of error condition then it should exit within with a non-zero exit status
so since in this case we are exiting because of an error in the input we are supplying a non-zero value for the exit status
so after having read the size of the maze we will need to read the actual maze but before doing that we need to be careful because the first line of input that the user entered contained the two integers and at least the return character or the end of line character after that
now we are going to use the get-car function for reading the configuration of the maze that is for each position in the maze whether it contains a open space or parts of all
so in the get-car library function recall that it does not skip any character in the input
so suppose the user entered 5 and 5 for the size of the maze and then he entered the return character
now if we now read the next character we will see the new line character as the value returned by the get-car function
now this is clearly not part of the maze itself
so what we need to do is that whatever the user entered on this line after the second integer and till and including the new line character that needs to be skipped
so that is precisely what this simple while loop is doing note that the body of the while loop is empty
it has just this empty statement in it
so the body is not doing anything all the action is actually happening in the condition itself which has the side effect of reading a character because it is calling the get-car function
so as long as we read characters as long as we do not see a new line character and we stop reading characters when you have seen a new line character
and the effect of that is that on this in first input line whatever the user entered after the second integer till the new line character all these characters are read from the input and they are discarded
so the next character that we read from the input will be the first character entered by the user on the next line
so after doing that we prompt the user to start inputting the maze and this big loop reads the maze
now how are we going to read the maze
 i said we are going to use the get-car function to read individual characters in the maze
recall that our x and y directions for like this
so the user is going to give the maze configuration in this fashion that is for he will first supply the entire row for y equal to 1 and then the row for y equal to 2 and so on so forth
the y equal to 0 row in the array we will reserve for the path that we are going to create around the maze
so for each successive value of y from 1 till size y we have to read the entire row of maze character and the number of character is size x
so for x from 1 to size x we read the maze character at the position x y using the get-car function and now again we make sanity checks on the input that we have just received
so the maze character that we have just seen should either be a star character indicating a wall or it should be a blank space character indicating an open path
so if the character that we just saw is neither star nor the blank character then again we print a mirror message that an invalid character in the maze was entered by the user and we specify in the bracket what character was found to be invalid and then we exit from the program
so once this inner loop terminates we have read all the characters in the in a particular row and then at the end the user of course terminated this line by and by hitting the enter key which means a new line character is also there
so now if we immediately start reading the next row the first character that we will read will be the new line character which of course would be an invalid character
so what we need to do is to discard again this new line character and that we are doing by calling get-car one more time to discard the end of the line character at the end of the line
so after having read the maze now our array is of size let us say 7 by 7 if the size x was 5 and size y was also 5 and what we have done is that we have read this part of the array from the user and this part of the array outside this has to be initialized to a to an open path
now note that this part of the open path will have the value y equal to 0 and x will range from 0 to size x plus plus 1 and similarly this portion of the path will have y is equal to size y plus 1 and x again will range from 0 to size x plus 1 and similarly these two paths will have the same y but will have the same x but different values of y
so this first loop is initializing these paths in the north north of directions on the two sides of the maze
so essentially what we are doing is for x equal to 0 and for x equal to size x plus 1 we are initializing all elements of the maze to the blank character for y from 0 to size y plus 1
note that the loop front still y is less than size y plus 2 which means that y is less than or equal to size y plus 1 and then this loop essentially initializes these two parts of the path
so now we have created the open path around the maze also there is nothing else to be done in this function
so the function finishes note that there is no return statement
return statement as we had discussed is not needed for functions that do not have any return value when the function body finishes then the function automatically returns
so here is the next function that we had identified namely read starting point
so again it has no parameter and has no return value it will read the starting point and store the starting point in the variables or x or y which are declared to be global variables
so again it asks the user to enter the starting point and reads two integers into or x and for y which are global variables and again stores the return value of scan s into local variable r
so if the value of r is not equal to 2 or if the starting position is not a valid starting position then we want to print an error message and exit from the program
what we mean by start by a valid starting position well the starting position must be on the boundary of the maze
so first of all what we are going to check is that or x and for y have valid values that is for x must be at least one and or for x must be no more than size x and similarly for y must be at least one and for y must be no more than size y
and then we are checking that the starting point that the user has specified at that point in the maze there is an open space because if at this place there is no open space then this cannot be a starting point and then this last check ensures that the starting point is indeed on the boundary of the maze
so a point is on the boundary of the maze if either x the the value of x is one or size x or the value of y is one or size y
so if the value of x is one that it is on this border of the maze somewhere if the value of x is size x then the starting point is somewhere on the side of the maze if the value of y is one then the position is somewhere on this line and is the value of y is size y then the starting position is on on this edge
but if it is on neither of these four edges then the starting point specified is somewhere inside the maze and that is obviously not permitted
so therefore if project is not equal to size x and project is not equal to 1 and positive is not equal to size y and positive is not equal to 1 then the starting point that the user has specified is again invalid
so in that case also we print the message that it is an invalid starting point and terminate the program by calling the exit function
so we print that it is an invalid starting point and then we terminate the function by calling exit
so now if we reach this point in the program that means that the starting point entered by the user was a valid starting point and now we need to initialize the initial direction
now how do we initialize the direction to begin with well that is again simple if the starting position is somewhere here then the initial direction must be south similarly if the starting position is somewhere here then initial position initial direction must be west if it is here then it must be north and if it is here then it must be west
so if positive is one that means the starting point is like this somewhere on the left edge of the maze then the starting direction is east this way
if positive is equal to size x then it is a situation like this and the starting direction is west this way
similarly if positive is one then it is a situation like this and therefore this direction is south otherwise it must be the case that the starting point is on the bottom edge of the maze because if it is on neither of the four edges you would have not accepted that starting point at all
so in this last case the starting point the starting direction would be north
so after having computed the starting direction in this way the function simply returns all the initializations it needed to do have been done
let us now look at the next function which is turn left and this is quite simple depending on the current direction just the direction changes the position within the maze does not really change
so if right now we are facing north then on a left turn will start facing west
so if the direction is north the direction becomes west similarly if the direction is west if we take a left turn we start facing south and if we were initially facing south then on taking a left turn we start facing east and otherwise if the direction is neither north west or south then it must be the case that the direction is east
so on a left turn the direction becomes north
the turn right function is exactly similar except that from north we go to east and so on so forth
so the next function is to determine whether we are in the current position and in the current direction facing evolve
so this function is supposed to return true if we are facing evolve and false otherwise
so again there are no parameter because all the information that we need is available in global variables but there is a return value which is true or false and in c as you know there is no boolean type
so we use the integer types to represent boolean
so we have declared the return type as int
now how do we determine whether we are facing evolve or not
 let us say we are facing in the north direction that is the current direction is not then if this is the current position then if we go one step north the current position then the new position will become x comma y minus 1 because x will remain the same and y will get decremented by 1
now if whether we are facing evolve or not depends on whether the maze at this new position had we moved one step north from the current position this new position whether it contains a wall or not
so if maze post x post y minus 1 is equal to star that means we are facing evolve otherwise we are not facing evolve
so note that what we are returning is the value of this entire expression and the value of this entire expression is true if the maze element at post x post y minus 1 is star and it falls if the maze element at this position is a blank
so that is precisely what we are supposed to return and so therefore this is the current this is the correct return value
similarly if the direction that we are facing is west then if we move one step west from the current position then the new position would become x minus 1 comma y and so what we return is whether maze post x minus 1 post y is equal to star or not
similarly if the direction is south then moving one step in the south direction would lead us to x comma y plus 1 and that is what we return here whether that new position contains a wall or not and similarly as the direction is east this should be east
so we are facing east by moving one step we would have east x plus 1 comma y and so in this case we return the result of checking whether at that new position the maze contains a wall or not
okay the next function is to determine whether the current position is outside the maze or not
so again there are no parameters because all the information required is available in global variable and the return value is of type int because we are going to return two or false
so how do we determine whether we are outside the maze or not all we have to check is whether we are somewhere on this path that we have created around the maze or not and so if post x is 0 note that the actual maze runs from y equal to 1 to y equal to size y and in the x direction from x equal to 1 to x equal to size x
so if the current value of x is 0 that means we are somewhere on this path or if the current position of x is size x plus 1 then we are somewhere on this path and if the current value of y is 0 that means we are somewhere on this path and if the value of y is size y plus 1 then we are somewhere on this path
so in all these cases we are supposed to return true and that is what precisely this expression consisting of or of these multiple conditions we do
so if cos x equal to 0 then this entire expression whose value we are returning will evaluate to true and similarly if cos x is equal to size x plus 1 then this expression evaluates to true and therefore the entire expression also values to true and so on
and in all other cases the expression representing the return value evaluates to false and so therefore we end up returning the right value
so that is almost the end of the program just need to write a couple of simple functions
so the next function is to step forward from the current position in the current direction
so all we need to do is to change the value of the current or this other line of need to take a couple of different
so that is the first square x will get incremented by 1 remember that our coordinate system is like this x is increasing this way and y is increasing southwards
the next function print position is equally simple all it does is that it prints recurrent position power x power y in this notation
so if the current position happens to be 3 and 2 that is power x equal to 3 and power y equal to 2 then this function will print something like 3 comma 2 where they blank after the bracket
so that if we successfully print multiple positions within the maze they are separated by blank spaces
so finally we are in a position to write the main program which we just call all these functions that we have written
so in the main function we first read the maze note that the main function does not really require any local variables at all
we first read the maze then we read the starting point then we print the current position and then essentially this loop captures the algorithm for this problem that we have already seen
while we are not outside the maze turn right and then while facing evolve turn left and then step forward and then since we have step forward we have moved to a new position
so we print that position as well
so at the end of this loop the entire path has been printed and then we finally print a new line character
so that the cursor comes to the next line and that is all that the main program needs to do
you can see that once the functions have been written the main program is really simple and somebody on reading this immediately understands what are algorithm for solving this particular problem is
that is the end of today's lecture
in the next lecture we will start by discussing another important tool in programming and that is the notion of pointers
in today's lecture we will look at a very powerful programming technique that known as recursion
in many cases recursion can be used to obtain in many cases very simple and elegant solutions to many problems that matter otherwise appear very difficult
the basic idea in recursion is that we solve a given instance of a problem
what we mean by an instance of a problem is the problem for the given parameters
for example finding the factorial is a problem and finding factorial of a given value of n is a problem in the instant
so using recursion what we do is we solve a given instance of a problem by using a solution to be smaller or a simpler instance of the same problem
so suppose the problem can be defined or expressed in such a fashion that the problem to a given instance of the problem can the solution to the given instance of a problem can be expressed in terms of the solution to a simpler instance of the problem
then we can use recursion to solve that problem very simply and essentially how do we obtain the solution to the simple instance of the problem that is accomplished by calling a function from within itself
that is a function f can call itself and that is essentially what is known as recursion
now this may appear to be counter intuitive to you because one might say that if a function calls itself then is that not a circular definition of a function well that is not necessarily true
as you know recurrence relations are often used in mathematics to define functions
for example you know that this is a common definition for the factorial function 0 factorial is defined as 1 and n factorial for n greater than 0 is defined as n times n minus 1 factorial
now so n factorial is defined in terms of n minus 1 factorial but tell this definition is found because the solution to the factorial of n is defined in terms of the solution to a simpler problem which is the effective finding the factorial of n minus 1 which in terms which in turn is defining terms of n minus 2 factorial and so on and finally 0 factorial is defined without reference to the factorial function itself
so the key is to realize that any the solution to any instance of the problem must be defined in terms of the solution of a simpler instance of the problem and finally there must be a base case in in which for which the solution is defined without reference to the function itself
on the other hand one could also possibly think of defining the factorial function this way that 0 factorial is 1 as before but now we are defining n factorial to be n plus 1 factorial divided by n plus 1
note that as a property this is clearly true because follows directly from the definition of the factorial function
but as a definition this definition is not found because n factorial is defined in terms of n plus 1 factorial which is defined in terms of n plus 2 factorial which is defined in terms of n plus 3 factorial and so on and this never ends and so you never reach the base case in which for which n is 0
so clearly this definition is not found
so the basic point we are trying to make is that calling a function from within itself recursively as it is known is is not necessarily incorrect
it is not it can not only be correct it can be extremely useful in certain cases as well
so for example now let us see how the factorial function in c can be defined recursively
we have already seen that the non recursive definition of the factorial problem is simple enough but let us see how it can be done recursively
so there are two things that we will talk about in terms of in the context of recursion
one is how to think about recursion and how to you know develop solutions to problems using recursion and the other which is equally important to understand is to understand how recursion actually works what is happening when a function is calling itself and so on
so forth how do we trace the execution of the program and so on
so what we will do is that in this lecture we will talk about how to use recursion is a technique for finding solutions to problems and how to write recursive function
we will talk about how actually recursion works in the next lecture
so i said the way you use recursion is if the solution to be given problem in sense can be computed using the solution to a simpler instance of the same problem
then essentially we assume that the solution to the simpler instance is available by magic
of course it is not really available by magic what to obtain that solution what you need to do is to call the same function recursively to obtain the solution to the simpler instance
and finally of course you must have a base case in the function definition where the function is not called recursively and the solution is directly given
so let us see a recursive definition of the factorial function
as i said you have already seen that the factorial function can be defined non recursively also without too much trouble but the recursive definition would be illustrative that is why we are looking at it
in many cases we will see that the recursive solution is much simpler than the non recursive solution
so here is the recursive definition of the factorial function
so we are defining the function factorial which takes a given n which is assumed to be greater than equal to 0 as an argument and returns n factorial
so first we check whether n is equal to 0 or not because that is the base case
so if n is equal to 0 then we return 1 because 0 factorial as you know is equal to 1 and otherwise if n is greater than 0 we return n into factorial of n minus 1
now this is the recursive call the factorial function is calling itself but with a different parameter
so the parameter here is n minus 1 and so factorial of n minus 1 is a simpler instance of the same problem and we are using recursion to find the solution to the simpler instance and finally using the answer to this problem we are computing the answer to be given instance
so if the factorial of n minus 1 is known then we know that the factorial of n is nothing but n times the factorial of n minus 1
let us look at another problem where recursion can be applied very easily
i call that we talked earlier about the gcd function or the greatest common divisor function and i showed you some properties of the gcd function and we will see that using this properties of the gcd function the gcd function can be implemented very easily recursively
so these are the property gcd of a and a is a
so if the two numbers are equal then the gcd is equal to the same number
gcd of a and b is equal to gcd of b and a
so you can trap the two numbers if you wish and finally gcd of a and b is the same as gcd of a minus b and b if a is greater than b
so if a is greater than b then you can subtract the smaller number from the larger number and this difference and this smaller number where gcd is the same as the gcd of the original two numbers and as we will just see the properties can be directly used to implement the gcd function
here is the definition
so this gcd function that we are defining there are two parameters a and b
this is the base case if a is equal to b then we return a or return b since both are equal it does not really matter
otherwise if a is greater than b then we return gcd of a minus b comma b
so this these parameters a minus b and b define the simpler instance of the problem in this case and given the solution to the to this simpler instance the answer to the given instance is is trivial to compute it is the same as the as the solution to this simpler instance
and if a happens to be less than b then we can mentally trap the two numbers and then apply the last property that we saw and that will result in gcd of a and b being equal to gcd of b minus a and a
so that is what we return in that case if a happens to be less than b
so now having written a recursive function we need to be able to argue or convince ourselves that this definition is indeed correct
now there are two aspects of proving the correctness of a recursive function or for that matter of any program
the first is to show that the function actually terminates or the program actually terminates


